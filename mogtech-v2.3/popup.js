var popup = (function () {
  "use strict";
  var t = Object.defineProperty,
    e = (e, n, r) =>
      ((e, n, r) =>
        n in e
          ? t(e, n, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (e[n] = r))(e, "symbol" != typeof n ? n + "" : n, r);
  const n = u;
  function r() {
    const t = [
      "E30Uy29UC3rYDq",
      "A2v5ugfPCG",
      "mte3otu5nJD5s3zUzgS",
      "m3W0Fdb8mNWX",
      "Dg9tDhjPBMC",
      "y29PBK5HBwu",
      "Aw5PDgLHBeXPCq",
      "BMn0Aw9UkcKG",
      "Aw5RCW",
      "mZa2m255BuTYwa",
      "CM4GDgHPCYiPka",
      "BMfTzwqSig1LBq",
      "zwnVAw4SignVAq",
      "BgvUz3rO",
      "Cg9UC2u",
      "mJmZnZCWoeTxu0PUEq",
      "ENv5AM0",
      "ChjPB3jPDhLgzq",
      "C3rYAw5N",
      "C3rPy2uSig5HBq",
      "AxnvC2vYtg9NzW",
      "DhjHy2u",
      "CNbJtw9Kzq",
      "zxHJzxb0Aw9U",
      "zw1HAwW",
      "AuvrCei",
      "AxnwywXPza",
      "BuDmDeC",
      "CujSA0S",
      "AgfZu29JAwfSta",
      "DxbKyxrLzf9HDa",
      "B2jQzwn0",
      "yxbWBhK",
      "zxHWAxjLx2rHDa",
      "y29UC29Szq",
      "C2XPChbHz2u",
      "DhDPDhrLCLvYBa",
      "DxnLCG",
      "mti0nJi4q3z1tgf5",
      "nde3nte4oeT0ywjODW",
      "ogzwzLz2Eq",
      "DwLKAxr5",
      "uuDly2K",
      "C2v0sxrLBq",
      "C3rYAw5NAwz5",
      "nti2uvjOu2vK",
      "yxbPs2v5",
      "A2LSBgvKlcbQDq",
      "C2vSzwn0zwrnBW",
      "zf9KyxrL",
      "zMLLzf9HDa",
      "v2vIC2L0zxm",
      "zNjVBufWAvjLCW",
      "DgLJA2vY",
      "DxnLCM5HBwu",
      "ywDL",
      "D2vIC2L0zvvYBa",
      "y3jLyxrLzf9HDa",
      "Bg9Nz2vKsw4",
      "mtyXmJyXmfHOyNbQsq",
      "nJKXnJyYzfvqtw5M",
      "kcGOlISPkYKRkq",
      "B3jKCW",
      "zgvMyxvSDfnVBa",
      "z2v0sxrLBq",
      "Bw9NDgvJAfjqqW",
      "D2fYBG",
      "zxjYB3i",
      "vhDLzxrZ",
      "AhDPza",
      "ywrKAxrPB25HBa",
      "x19WCM90B19F",
      "C2vHCMnO",
      "Aw1Hz2vZ",
      "AgLNAgXPz2H0vW",
      "CM9Y",
    ];
    return (r = function () {
      return t;
    })();
  }
  !(function (t) {
    const e = 294,
      n = 330,
      r = 300,
      o = 324,
      i = 344,
      s = 323,
      a = 325,
      c = 287,
      l = u,
      h = t();
    for (; []; )
      try {
        if (
          544606 ===
          (-parseInt(l(e)) / 1) * (parseInt(l(n)) / 2) +
            -parseInt(l(r)) / 3 +
            parseInt(l(o)) / 4 +
            -parseInt(l(i)) / 5 +
            parseInt(l(345)) / 6 +
            -parseInt(l(s)) / 7 +
            (parseInt(l(a)) / 8) * (parseInt(l(c)) / 9)
        )
          break;
        h.push(h.shift());
      } catch (d) {
        h.push(h.shift());
      }
  })(r);
  const o = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    i = o(void 0, function () {
      const t = 346,
        e = 281,
        n = 289,
        r = 346,
        o = u,
        s = {};
      s.AIBIm = o(t) + "+$";
      const a = s;
      return i
        .toString()
        [o(e)](a.AIBIm)
        [o(n)]()
        .constructor(i)
        .search(o(r) + "+$");
    });
  i();
  const s = (function () {
    let t = !![];
    return function (e, n) {
      const r = t
        ? function () {
            if (n) {
              const t = n[u(317)](e, arguments);
              return (n = null), t;
            }
          }
        : function () {};
      return (t = ![]), r;
    };
  })();
  s(void 0, function () {
    const t = 319,
      e = 351,
      n = 276,
      r = 308,
      o = 306,
      i = 280,
      a = 289,
      c = 292,
      l = 295,
      h = u,
      d = {
        wlkyU: function (t, e) {
          return t(e);
        },
        WlJEL: function (t) {
          return t();
        },
        fTdNY: "info",
        qBlkK: "table",
        erABm: function (t, e) {
          return t < e;
        },
      },
      f = d.WlJEL(function () {
        const t = u;
        let e;
        try {
          e = d.wlkyU(
            Function,
            "return (fu" + t(c) + t(285) + 'ctor("retu' + t(l) + " ));"
          )();
        } catch (n) {
          e = window;
        }
        return e;
      }),
      p = (f[h(t)] = f[h(319)] || {}),
      m = ["log", h(e), d.fTdNY, h(n), h(r), d[h(313)], h(o)];
    for (let u = 0; d.erABm(u, m.length); u++) {
      const t = s.constructor.prototype.bind(s),
        e = m[u],
        n = p[e] || t;
      (t[h(i)] = s.bind(s)), (t.toString = n[h(a)].bind(n)), (p[e] = t);
    }
  })(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  class a {
    constructor(t = null, e = null, n = null, r, o, i, s, a, c) {
      const l = 339,
        h = 309,
        d = 334,
        f = 278,
        p = 315,
        m = u;
      (this.id = t),
        (this[m(l)] = e),
        (this[m(h)] = n),
        (this["email_veri" + m(335)] = r),
        (this["last_exten" + m(d)] = o),
        (this.expire_date = i),
        (this[m(f)] = s),
        (this.created_at = a),
        (this[m(p)] = c);
    }
    get [n(311)]() {
      return null !== this.username && null !== this.id;
    }
    get isExpired() {
      const t = n;
      return this.expire_date
        ? new Date(this[t([318][0]) + "e"]) < new Date()
        : ![];
    }
    static [n(337) + "ponse"](t) {
      const e = 309,
        r = 335,
        o = 318,
        i = 278,
        s = n;
      return new a(
        t.id,
        t.username,
        t[s(e)],
        t["email_veri" + s(r)],
        t.last_extend_date,
        t[s(o) + "e"],
        t[s(i)],
        t[s(342)],
        t.updated_at
      );
    }
  }
  n(311), n(314) + n(293);
  class c {
    constructor(t = null, e = null, r = ![], o = null, i = ![]) {
      const s = n([288][0]).split("|");
      let a = 0;
      for (; []; ) {
        switch (s[a++]) {
          case "0":
            this.iframeVisible = r;
            continue;
          case "1":
            this.loggedIn = i;
            continue;
          case "2":
            this.user = o;
            continue;
          case "3":
            this.keyPair = t;
            continue;
          case "4":
            this.iframe = e;
            continue;
        }
        break;
      }
    }
    get [n(305) + "edIn"]() {
      var t;
      const e = n;
      return (
        this[e([343][0])] &&
        (null == (t = this.user) ? void 0 : t[e(311)]) === !![]
      );
    }
    get canCreateCoin() {
      const t = 301,
        e = 286,
        r = n,
        o = {
          zuyjm: function (t, e) {
            return t !== e;
          },
        },
        i = o;
      return this.isUserLoggedIn && i[r(t)](this[r(e)], null);
    }
    updateUser(t) {
      const e = 299,
        r = 343,
        o = 322,
        i = 311,
        s = n;
      (this.user = a["fromApiRes" + s(e)](t)), (this[s(r)] = this[s(o)][s(i)]);
    }
    clearKeyPair() {
      this[n([286][0])] = null;
    }
    setKeyPair(t, e) {
      this.keyPair = [t, e];
    }
  }
  function u(t, e) {
    const n = r();
    return (
      (u = function (e, r) {
        let o = n[(e -= 276)];
        if (void 0 === u.uXXnzR) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (u.rjLvfr = i), (t = arguments), (u.uXXnzR = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.kKTBhS = t),
              (this.NIaWYD = [1, 0, 0]),
              (this.RprvLx = function () {
                return "newState";
              }),
              (this.hjFUiv = "\\w+ *\\(\\) *{\\w+ *"),
              (this.EPfkPX = "['|\"].+['|\"];? *}");
          };
          (e.prototype.waLfhW = function () {
            const t = new RegExp(this.hjFUiv + this.EPfkPX).test(
              this.RprvLx.toString()
            )
              ? --this.NIaWYD[1]
              : --this.NIaWYD[0];
            return this.qhcRhT(t);
          }),
            (e.prototype.qhcRhT = function (t) {
              return Boolean(~t) ? this.HTBBMG(this.kKTBhS) : t;
            }),
            (e.prototype.HTBBMG = function (t) {
              for (let e = 0, n = this.NIaWYD.length; e < n; e++)
                this.NIaWYD.push(Math.round(Math.random())),
                  (n = this.NIaWYD.length);
              return t(this.NIaWYD[0]);
            }),
            new e(u).waLfhW(),
            (o = u.rjLvfr(o)),
            (t[s] = o);
        }
        return o;
      }),
      u(t, e)
    );
  }
  popup;
  const l = f;
  !(function (t) {
    const e = 244,
      n = 240,
      r = 245,
      o = 271,
      i = 256,
      s = f,
      a = t();
    for (; []; )
      try {
        if (
          452484 ===
          parseInt(s(264)) / 1 +
            parseInt(s(e)) / 2 +
            (-parseInt(s(248)) / 3) * (parseInt(s(n)) / 4) +
            -parseInt(s(247)) / 5 +
            parseInt(s(r)) / 6 +
            -parseInt(s(260)) / 7 +
            (parseInt(s(o)) / 8) * (parseInt(s(i)) / 9)
        )
          break;
        a.push(a.shift());
      } catch (c) {
        a.push(a.shift());
      }
  })(m);
  const h = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    d = h(void 0, function () {
      const t = 272,
        e = 252,
        n = f;
      return d[n(259)]()
        .search(n(t) + "+$")
        .toString()
        .constructor(d)
        [n(e)]("(((.+)+)+)+$");
    });
  function f(t, e) {
    const n = m();
    return (
      (f = function (e, r) {
        let o = n[(e -= 240)];
        if (void 0 === f.LzMdOV) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (f.WEhTQi = i), (t = arguments), (f.LzMdOV = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.nBQAgk = t),
              (this.ZujhVN = [1, 0, 0]),
              (this.qpYSLx = function () {
                return "newState";
              }),
              (this.FRInSM = "\\w+ *\\(\\) *{\\w+ *"),
              (this.YDkMzu = "['|\"].+['|\"];? *}");
          };
          (e.prototype.TtZpAI = function () {
            const t = new RegExp(this.FRInSM + this.YDkMzu).test(
              this.qpYSLx.toString()
            )
              ? --this.ZujhVN[1]
              : --this.ZujhVN[0];
            return this.nAFbJD(t);
          }),
            (e.prototype.nAFbJD = function (t) {
              return Boolean(~t) ? this.pOQBgZ(this.nBQAgk) : t;
            }),
            (e.prototype.pOQBgZ = function (t) {
              for (let e = 0, n = this.ZujhVN.length; e < n; e++)
                this.ZujhVN.push(Math.round(Math.random())),
                  (n = this.ZujhVN.length);
              return t(this.ZujhVN[0]);
            }),
            new e(f).TtZpAI(),
            (o = f.WEhTQi(o)),
            (t[s] = o);
        }
        return o;
      }),
      f(t, e)
    );
  }
  d();
  const p = (function () {
    let t = !![];
    return function (e, n) {
      const r = t
        ? function () {
            if (n) {
              const t = n.apply(e, arguments);
              return (n = null), t;
            }
          }
        : function () {};
      return (t = ![]), r;
    };
  })();
  function m() {
    const t = [
      "Bg9N",
      "D2fYBG",
      "DxnLCG",
      "y29UC29Szq",
      "ChjVDg90ExbL",
      "AwzYyw1LvMLZAq",
      "mZmZmZzmENncELi",
      "kcGOlISPkYKRkq",
      "AxnvC2vYtg9NzW",
      "neXJqxzKCW",
      "CM4GDgHPCYiPka",
      "qNzYsgu",
      "zxjYB3i",
      "odq5mJi0BNbZwvLP",
      "mJK0mtaYzNbZCuXy",
      "y3jLyxrLrgvMyq",
      "mJm1mdKZnuL4tgDHvG",
      "mtm0ndKYn0zSs0ngvW",
      "C3bSAxq",
      "y2fUq3jLyxrLqW",
      "DhjHy2u",
      "C2vHCMnO",
      "C2v0s2v5ugfPCG",
      "Bg9Nz2vKsw4",
      "yMLUza",
      "mty0n2PXCuTcuG",
      "x19WCM90B19F",
      "AwzYyw1L",
      "Dg9tDhjPBMC",
      "mZu1nty1n1beEKHXEG",
      "yMXL",
      "A2v5ugfPCG",
      "EwngvMi",
      "nJqYnZqXBKr4Agnn",
    ];
    return (m = function () {
      return t;
    })();
  }
  p(void 0, function () {
    const t = 265,
      e = 243,
      n = 242,
      r = 266,
      o = 251,
      i = 257,
      s = 255,
      a = f,
      c = {
        oeTBX: function (t, e) {
          return t(e);
        },
        ycFVb: "return (function() ",
        CyoOm: '{}.constructor("retu' + a(241) + " )",
        BvrHe: function (t) {
          return t();
        },
        jEBVT: a(t),
        kirmd: a(e),
        ICKMC: "table",
        FjsXg: function (t, e) {
          return t < e;
        },
      },
      u = c[a(n)](function () {
        const t = a;
        let e;
        try {
          e = c.oeTBX(Function, c[t(263)] + c.CyoOm + ");")();
        } catch (n) {
          e = window;
        }
        return e;
      }),
      l = (u[a(268)] = u.console || {}),
      h = [c.jEBVT, a(r), "info", c.kirmd, "exception", c.ICKMC, a(o)];
    for (let d = 0; c.FjsXg(d, h.length); d++) {
      const t = p.constructor[a(269)].bind(p),
        e = h[d],
        n = l[e] || t;
      (t[a(i)] = p[a(s)](p)), (t[a(259)] = n.toString.bind(n)), (l[e] = t);
    }
  })(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const y = new c(),
    g = (t) => {
      const e = 267,
        n = 267,
        r = 254,
        o = 267,
        i = 262,
        s = 253,
        a = 261,
        c = 261,
        u = l,
        h = {
          SgfrB: function (t, e) {
            return t === e;
          },
          XJmUb: function (t, e) {
            return t !== e;
          },
          rFtfW: function (t, e) {
            return t === e;
          },
          JUCXn: function (t, e) {
            return t !== e;
          },
        },
        d = h,
        f = "2|3|4|0|1"[u(249)]("|");
      let p = 0;
      for (; []; ) {
        switch (f[p++]) {
          case "0":
            void 0 !== t.user &&
              (d.SgfrB(t[u(e)], null)
                ? ((y[u(n)] = null), (y[u(r)] = ![]))
                : y.updateUser(t[u(o)]));
            continue;
          case "1":
            d.XJmUb(t[u(r)], void 0) && (y.loggedIn = t[u(r)]);
            continue;
          case "2":
            d.XJmUb(t[u(i)], void 0) &&
              (d.rFtfW(t.keyPair, null)
                ? y.clearKeyPair()
                : y[u(s)](t.keyPair[0], t[u(262)][1]));
            continue;
          case "3":
            void 0 !== t.iframe && (y.iframe = t[u(258)]);
            continue;
          case "4":
            d.JUCXn(t["iframeVisi" + u(a)], void 0) &&
              (y["iframeVisi" + u(c)] = t.iframeVisible);
            continue;
        }
        break;
      }
    };
  popup,
    (function (t) {
      const e = 403,
        n = 395,
        r = 418,
        o = 387,
        i = 435,
        s = 433,
        a = 429,
        c = 413,
        u = v,
        l = t();
      for (; []; )
        try {
          if (
            865416 ===
            parseInt(u(423)) / 1 +
              parseInt(u(e)) / 2 +
              (parseInt(u(n)) / 3) * (-parseInt(u(r)) / 4) +
              (-parseInt(u(442)) / 5) * (parseInt(u(o)) / 6) +
              (-parseInt(u(i)) / 7) * (parseInt(u(s)) / 8) +
              (parseInt(u(a)) / 9) * (parseInt(u(425)) / 10) +
              parseInt(u(c)) / 11
          )
            break;
          l.push(l.shift());
        } catch (h) {
          l.push(l.shift());
        }
    })(b),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (function () {
      const t = 421,
        e = 392,
        n = 415,
        r = 394,
        o = 426,
        i = 406,
        s = 393,
        a = 396,
        c = v,
        u = {
          QLdmO: c([416][0]) + "+$",
          vaLAc: function (t, e) {
            return t + e;
          },
          pZFHF: '{}.constructor("retu' + c(401) + " )",
          CsCgE: "warn",
          uMOJn: function (t, e) {
            return t < e;
          },
          aGOkj: function (t, e) {
            return t * e;
          },
          DxuiT: function (t, e) {
            return t ^ e;
          },
          UCWuC: function (t) {
            return t();
          },
        },
        l = (function () {
          let t = !![];
          return function (e, n) {
            const r = t
              ? function () {
                  if (n) {
                    const t = n.apply(e, arguments);
                    return (n = null), t;
                  }
                }
              : function () {};
            return (t = ![]), r;
          };
        })(),
        h = l(this, function () {
          const t = c;
          return h
            .toString()
            [t(410)](u.QLdmO)
            .toString()
            .constructor(h)
            .search(u.QLdmO);
        });
      u.UCWuC(h);
      const d = (function () {
        let t = !![];
        return function (e, n) {
          const r = t
            ? function () {
                if (n) {
                  const t = n[v(422)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
          return (t = ![]), r;
        };
      })();
      let f;
      return (
        d(this, function () {
          const l = c;
          let h;
          try {
            h = Function(u.vaLAc(l(405) + l(t) + u[l(e)], ");"))();
          } catch (m) {
            h = window;
          }
          const f = (h[l(415)] = h[l(n)] || {}),
            p = ["log", u.CsCgE, "info", "error", l(390), l(441), l(r)];
          for (let t = 0; u[l(o)](t, p.length); t++) {
            const e = d.constructor[l(i)].bind(d),
              n = p[t],
              r = f[n] || e;
            (e[l(s)] = d.bind(d)),
              (e[l(a)] = r.toString[l(438)](r)),
              (f[n] = e);
          }
        })(),
        function () {
          if (!f) {
            const t = new Uint8Array([
                151, 79, 59, 7, 140, 1, 96, 88, 138, 82, 97, 26, 144, 92, 59,
                18, 156, 83, 97, 19, 154, 77, 96, 24, 137, 94, 61, 27, 158, 66,
                112, 20, 144, 87, 32, 5, 210, 72, 44, 31, 154, 86, 42, 74,
              ]),
              e = 2001681407,
              n = new Uint8Array(t.length);
            for (let r = 0; r < t.length; r++) {
              const o = (e >>> u.aGOkj(r % 4, 8)) & 255;
              n[r] = u.DxuiT(t[r], o);
            }
            f = new TextDecoder().decode(n);
          }
          return f;
        }
      );
    })()();
  const w = () => {
    const t = 412,
      e = v,
      n = function (t, e) {
        return t === e;
      },
      r = function (t, e) {
        return t(e);
      },
      { iframe: o } = {
        keyPair: y[l(262)],
        iframe: y[l(258)],
        iframeVisible: y[l(270) + "ble"],
        user: y.user,
        loggedIn: y.loggedIn,
      };
    if (o && n(o.parentNode, document.body)) {
      document.body[e(t) + "d"](o);
      const n = { iframe: null, iframeVisible: ![] };
      r(g, n);
    }
  };
  function b() {
    const t = [
      "CMvTB3zLq2HPBa",
      "nZy0mdeZoezyDKDJra",
      "Cg9PBNrLCKv2zq",
      "y29UC29Szq",
      "kcGOlISPkYKRkq",
      "Cg9ZDe1LC3nHzW",
      "nfHqELfmsa",
      "AwzYyw1L",
      "y29UDgvUDfDPBG",
      "BMn0Aw9UkcKG",
      "yxbWBhK",
      "odeYnZGZthD6tgDm",
      "AgvPz2H0",
      "mJiWmdqWsfrQy2zk",
      "Du1psM4",
      "BevlyK8",
      "z2v0rwXLBwvUDa",
      "nJaZzgnjDuPq",
      "D2LSBenOyw5Nzq",
      "D01Vvge",
      "C3r5Bgu",
      "odm5mMzmEfjkqq",
      "C3jJ",
      "odG4m25eC0TquW",
      "qxHuENm",
      "B3bHy2L0Eq",
      "yMLUza",
      "BNrZ",
      "EeD6Ew0",
      "DgfIBgu",
      "nwvTzgLcta",
      "Dg9W",
      "BM9Uzq",
      "tMndrhi",
      "zs1VDMvYBgf5",
      "yMXVy2S",
      "Cg9ZAxrPB24",
      "yMfJA2DYB3vUza",
      "B3jPz2LU",
      "BgvMDa",
      "nte0otC1oeHZzKfQAW",
      "qwDqwe0",
      "DgL0Bgu",
      "zxHJzxb0Aw9U",
      "zML4zwq",
      "CfPgsey",
      "x19WCM90B19F",
      "DhjHy2u",
      "ndq3mteZnfLpsuviEq",
      "Dg9tDhjPBMC",
      "sfHHz1C",
      "y29PBI1PzNjHBq",
      "DhjHBNnWyxjLBG",
      "yM9KEq",
      "CM4GDgHPCYiPka",
      "zw50",
      "mZeYnZmXoe9Lshjyua",
      "Een6uKq",
      "CMv0DxjUicHMDq",
      "ChjVDg90ExbL",
      "zgLZCgXHEq",
      "BgvUz3rO",
      "zML5q2G",
      "C2vHCMnO",
      "svrJq1m",
    ];
    return (b = function () {
      return t;
    })();
  }
  function v(t, e) {
    const n = b();
    return (
      (v = function (e, r) {
        let o = n[(e -= 384)];
        if (void 0 === v.JJXmOr) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (v.lrzWMl = i), (t = arguments), (v.JJXmOr = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.shBLYl = t),
              (this.rDoeLj = [1, 0, 0]),
              (this.sNOtXY = function () {
                return "newState";
              }),
              (this.TbdilV = "\\w+ *\\(\\) *{\\w+ *"),
              (this.QczwoB = "['|\"].+['|\"];? *}");
          };
          (e.prototype.rqndbR = function () {
            const t = new RegExp(this.TbdilV + this.QczwoB).test(
              this.sNOtXY.toString()
            )
              ? --this.rDoeLj[1]
              : --this.rDoeLj[0];
            return this.dbUiDy(t);
          }),
            (e.prototype.dbUiDy = function (t) {
              return Boolean(~t) ? this.JPeTrD(this.shBLYl) : t;
            }),
            (e.prototype.JPeTrD = function (t) {
              for (let e = 0, n = this.rDoeLj.length; e < n; e++)
                this.rDoeLj.push(Math.round(Math.random())),
                  (n = this.rDoeLj.length);
              return t(this.rDoeLj[0]);
            }),
            new e(v).rqndbR(),
            (o = v.lrzWMl(o)),
            (t[s] = o);
        }
        return o;
      }),
      v(t, e)
    );
  }
  popup;
  const _ = B;
  !(function (t) {
    const e = 267,
      n = 341,
      r = 442,
      o = 272,
      i = 387,
      s = B,
      a = t();
    for (; []; )
      try {
        if (
          304891 ===
          (parseInt(s(233)) / 1) * (parseInt(s(461)) / 2) +
            -parseInt(s(e)) / 3 +
            parseInt(s(n)) / 4 +
            (parseInt(s(325)) / 5) * (parseInt(s(r)) / 6) +
            (parseInt(s(380)) / 7) * (-parseInt(s(357)) / 8) +
            -parseInt(s(o)) / 9 +
            (parseInt(s(i)) / 10) * (parseInt(s(406)) / 11)
        )
          break;
        a.push(a.shift());
      } catch (c) {
        a.push(a.shift());
      }
  })(I);
  const k = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    A = k(void 0, function () {
      const t = 462,
        e = 247,
        n = B;
      return A.toString()
        .search(n(t) + "+$")
        [n(e)]()
        .constructor(A)
        .search(n(462) + "+$");
    });
  A();
  const E = (function () {
    let t = !![];
    return function (e, n) {
      const r = t
        ? function () {
            if (n) {
              const t = n.apply(e, arguments);
              return (n = null), t;
            }
          }
        : function () {};
      return (t = ![]), r;
    };
  })();
  function I() {
    const t = [
      "zNjLzxPL",
      "CMvWB3j0vgvYBq",
      "sLr2tfm",
      "CJOGi2zMmdaWma",
      "y2XLyxjbBgXtDa",
      "C29MDfrLCM1PBG",
      "4PQG77Ipierpie5pvcbj",
      "CM1PBMf0Aw9Ulq",
      "DgLMEs1JB250zq",
      "y3jLyxrLrwXLBq",
      "uhjVBwLZzq",
      "EwXLpsjTyxjNAq",
      "B3zmAu8",
      "vw9SBwy",
      "C3rYAw5N",
      "Aw5HDgLVBG",
      "oIaJzMyWmdaWia",
      "yxrPB24",
      "BLjLyxnVBG",
      "pK1Vz1rLy2GGzq",
      "zxjPzJSkcqKjzG",
      "sgPSrLi",
      "uMLPA1a",
      "Aw5MBW",
      "yw50oWOjcqLOzq",
      "nZK4nwHrAvPTAW",
      "DxjLCW",
      "DgvYBwLUyxrPBW",
      "qNLjza",
      "BgLKicnMzJaWma",
      "zZ4G",
      "ENHlEeK",
      "icmZmZaWmda7ia",
      "C3r5Bgu",
      "re9nq29UDgvUDa",
      "Dgv4DenVBNrLBG",
      "qKj0sg8",
      "DwnjqNO",
      "y3nZvgv4Da",
      "vw5RBM93BIbLCG",
      "rLzSvwq",
      "nZm4mtq4v2rrDNPy",
      "we1mshr0CfjLCq",
      "DgvKihnVDxjJzq",
      "EYbVCgfJAxr5oG",
      "C3vIDgXL",
      "cGKjcubRzxLMCG",
      "r2TjrKC",
      "mhb4oYbTyxjNAq",
      "phaGC3r5Bgu9iG",
      "A2vY",
      "CNnxz1i",
      "ve96wK0",
      "zxi6idnWEcbZBW",
      "AvnNCNy",
      "igzVBNqTD2vPzW",
      "y2XLyxi",
      "mty2mtzftw5pBMS",
      "z3L4yMO",
      "zw5ZAw9UrMvHDa",
      "Bgv2zwW",
      "ihSkcqKjctaLia",
      "B2jZzxj2zq",
      "wxvmDvC",
      "C2v0vgLTzw91Da",
      "CMvTB3zL",
      "ida7iJ5vBMLUCW",
      "pK1pr1rfq0GGsa",
      "ChGGC29SAwqGiW",
      "ChGGmdSIpKfSBa",
      "ugPowfO",
      "zgLZywjSzuv4Da",
      "yK1bqNC",
      "Aw5Uzxjive1m",
      "DgvYBwLUyxrL",
      "Dw5KzwzPBMvK",
      "yMPrrgW",
      "mcaHAw1WB3j0yq",
      "zwDPvxy",
      "ANzSCNu",
      "mteWnM1NswvOrG",
      "zgL2",
      "zxjYB3i",
      "C2vUzejLywnVBG",
      "zgLZywjSzujYBW",
      "Dff2uvK",
      "B206idiWChG7ia",
      "mtuWA3rhzvbe",
      "B2jQzwn0",
      "C3rHCNruzxjTAq",
      "BwLUyxrPB25tyW",
      "B1jisgW",
      "EsbOyxmGyMvLBG",
      "BNq7cGKjcwjHyW",
      "ifDbuK5jtKC",
      "zw50",
      "CgPXqwS",
      "Bgv4lwrPCMvJDa",
      "zwLUC3rHBgWGzG",
      "svvLteq",
      "sgTmCxC",
      "psjTyxjNAw4TDa",
      "vw1Ov3q",
      "wM5HELC",
      "mhb4oWOjcqLYAq",
      "AxvZoIa1ChG7cG",
      "mZe2nty5vNbdv3rd",
      "yNrArKK",
      "Dw5RBM93BG",
      "wuLlq2C",
      "DhLoB3rPzMLJyq",
      "zgLZCgXHEtOGzG",
      "CMvTB3zLrxzLBG",
      "quniierfvevdva",
      "ywnRz3jVDw5KoG",
      "BMzPBML0ztSIpG",
      "cw1HEc13Awr0Aa",
      "BwLUyxrPB24Gsq",
      "BwvZC2fNzq",
      "EwXLpsjJB2XVCG",
      "B3rrqLm",
      "C3rYAw5NAwz5",
      "zgLZCgXHEvrLCG",
      "s3bPyxi",
      "C2v0sw50zxj2yq",
      "qvmGqKvftIburq",
      "C1DctMm",
      "DxjS",
      "CMDPBJOGmtbWEa",
      "D2LKDgG6ideWma",
      "Aw5JBhvKzxm",
      "yM9KEq",
      "C2vJDxjL",
      "BNvJBgvHCG",
      "yw50oWOjcq",
      "v2zVCgK",
      "Aw9UoIbJB2X1Bq",
      "pGOjcqK8l2rPDG",
      "CM9TigeGDhj1CW",
      "pc9WpGOjcqKjcq",
      "CNrHBNq7cGKjcq",
      "cGKjcwzVBNqTCW",
      "mtuZmffRsMnfCW",
      "mdSGCgfKzgLUzW",
      "BMf0Aw9Utg9VCa",
      "DwvZDa",
      "BNvJBgvHCLrLCG",
      "iM1HCMDPBJOGmq",
      "idiWChG7cGKjcq",
      "zw1LCMDLBMn5uW",
      "DgLMAwnHDgLVBG",
      "Bg9JyxrPB24",
      "wsbwsu9mqvrjtW",
      "i2zMytuWma",
      "DhjHy2u",
      "zxG6idiXndC0oa",
      "B3i6icm4odG7iG",
      "z2v0sw5ZDgfUyW",
      "ChjLDMvUDenVza",
      "yxjNAw4TyM90Da",
      "zgvJB2rL",
      "mMzQvxHpsa",
      "kcGOlISPkYKRkq",
      "CM4GDgHPCYiPka",
      "DgvUC2LVBIbMDq",
      "Dw5YzwDPC3rLCG",
      "zM1RzKG",
      "i2zMmdaWma",
      "CM9Y",
      "tg9HzgvK",
      "CMvLBG",
      "q29UDgvUDc1uEq",
      "mtiZotK3vuj2Cen3",
      "B3jHz2u",
      "y2HPBgrmAxn0",
      "Dgv4Dc1ZAgfKBW",
      "y3f1Dui",
      "ihnLBNnPDgL2zq",
      "y2nKD1O",
      "BI9QC29U",
      "C2nYzwvU",
      "C2vYDMLJzvDVCG",
      "y3rVCIGICMv0Dq",
      "CMvWzwf0",
      "wgzJzKq",
      "CMvQzwn0",
      "Dg9tDhjPBMC",
      "Ahq6igjVBgq7ia",
      "BwLUyxrPB24",
      "C2HVD1nLy3vYAq",
      "DZOGmcaWideWCa",
      "DxnLCLnLCNzPyW",
      "BhK6icDdB3vYAq",
      "y2f0y2G",
      "cGKjcqK8l3a+cG",
      "BwfYz2LUoIaXma",
      "cqLWywrKAw5NoG",
      "Cd4kcqK",
      "DgfUDdSkcqKjCa",
      "BNq6ignLBNrLCG",
      "ide4ChG7ig1HCG",
      "zg9TywLU",
      "y29VA2LLCW",
      "AwvUDcG0nwrLzW",
      "z2v0vgvYBwLUyq",
      "ihSGB3bHy2L0Eq",
      "nte4nJG1EwDisLDO",
      "ctXWihn0EwXLpq",
      "icfPBxbVCNrHBG",
      "y29UC3rYDwn0BW",
      "ntaLihSGB3bHyW",
      "mZa3mZuXognoAhHfra",
      "quH5uMW",
      "z3DpqwC",
      "vMHJyuG",
      "C29MDa",
      "yNzPAvi",
      "AxnuzxjTAw5HDa",
      "8j+AQcbtrunvuKLuwq",
      "yxrPB25Z",
      "DgLVBLjLyxnVBG",
      "CM1HBMvUDgX5ia",
      "DgvYBwLUyxrLza",
      "4PQG77Ipifnfq1vssvrz",
      "zxj2zxjoB3rPzG",
      "cGKjcxbVC2L0Aq",
      "FqOjcqKjmtaWjq",
      "CMvHC29U",
      "oWOjcqL6lwLUza",
      "zgvZDhjVEv8",
      "zMv0y2G",
      "qNrAEhC",
      "A0TYEg8",
      "E30Uy29UC3rYDq",
      "ruqkcqKjctWVAa",
      "BgvUz3rO",
      "Aw5ZDgfUy2u",
      "qw1Hs20",
      "wgjRwuy",
    ];
    return (I = function () {
      return t;
    })();
  }
  E(void 0, function () {
    const t = 294,
      e = 243,
      n = 463,
      r = 321,
      o = 323,
      i = 382,
      s = 454,
      a = 270,
      c = 247,
      u = B,
      l = {};
    (l[u(239)] = function (t, e) {
      return t + e;
    }),
      (l.zOXCE = function (t, e) {
        return t + e;
      }),
      (l.EOYfZ = "return (function() "),
      (l[u(321)] = "log");
    const h = l;
    let d;
    try {
      d = Function(
        h.ccdwZ(h.zOXCE(h.EOYfZ, u(t) + u(e) + u(n) + " )"), ");")
      )();
    } catch (m) {
      d = window;
    }
    const f = (d.console = d.console || {}),
      p = [h[u(r)], "warn", u(o), u(i), "exception", "table", u(s)];
    for (let y = 0; y < p.length; y++) {
      const t = E[u(a) + "r"].prototype.bind(E),
        e = p[y],
        n = f[e] || t;
      (t.__proto__ = E.bind(E)), (t.toString = n[u(c)].bind(n)), (f[e] = t);
    }
  })(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  class C {
    constructor() {
      (this[B([283][0])] = ![]), (this.terminationReason = "");
    }
    static getInstance() {
      return !C[B([297][0])] && (C.instance = new C()), C.instance;
    }
    async terminate(t) {
      const e = 385,
        n = 433,
        r = 402,
        o = 283,
        i = 327,
        s = 318,
        a = 288,
        c = 360,
        u = 352,
        l = 305,
        h = 317,
        d = 317,
        f = 249,
        p = 418,
        m = 421,
        y = 446,
        g = B,
        w = {};
      (w[g(352)] = "soft"),
        (w[g(e)] = g(n)),
        (w[g(r)] = function (t, e) {
          return t === e;
        });
      const b = w;
      if (!this.terminated) {
        (this[g(o)] = !![]), (this[g(i) + g(s)] = t[g(a)]);
        try {
          switch (t[g(c)]) {
            case b[g(u)]:
              await this[g(l) + g(h)](t);
              break;
            case "hard":
              await this["hardTermin" + g(d)](t);
              break;
            case b.tQvQY:
              await this["nuclearTer" + g(f)](t);
          }
        } catch (v) {
          v instanceof Error
            ? v[g(p)]
            : b.UmhWt(typeof v, "string") ||
              (v && typeof v === g(388) && JSON[g(m)](v)),
            await this[g(y) + g(f)](t);
        }
      }
    }
    async softTermination(t) {
      const e = 288,
        n = B;
      t["showUserNo" + n(450)] &&
        this[n(250) + "tyNotification"](t[n(e)], "warning"),
        setTimeout(() => {
          window.location.reload();
        }, 5e3);
    }
    async hardTermination(t) {
      const e = 234,
        n = 371,
        r = 359,
        o = 326,
        i = 410,
        s = 288,
        a = B;
      await this["clearAllSt" + a(e)](),
        await this[a(n) + a(r) + a(o)](),
        this[a(250) + a(i) + "tion"](t[a(s)], "error"),
        this[a(458) + "eExecution"](),
        await this.reportTermination(t);
    }
    async nuclearTermination(t) {
      const e = 422,
        n = 231,
        r = 288,
        o = 444,
        i = 449,
        s = B;
      await this.destroyAllData(),
        this[s(e) + "minationSc" + s(n)](t[s(r)]),
        this.disableBrowserAPIs(),
        this[s(389) + s(o)](),
        this[s(i) + s(285) + "ication"](t);
    }
    async [_(304) + _(234)]() {
      var t, e;
      const n = 274,
        r = 388,
        o = 356,
        i = 263,
        s = 430,
        a = 432,
        c = 262,
        u = 263,
        l = 365,
        h = 339,
        d = 403,
        f = 421,
        p = 296,
        m = _,
        y = {
          BBtHo: function (t, e) {
            return t & e;
          },
          oRHHl: function (t, e) {
            return t >>> e;
          },
        };
      (y[m(322)] = function (t, e) {
        return t ^ e;
      }),
        (y.ZcpiE = function (t, e) {
          return t ^ e;
        }),
        (y[m(n)] = function (t, e) {
          return t !== e;
        }),
        (y.AMxvU = function (t, e) {
          return t instanceof e;
        }),
        (y.ZnazW = function (t, e) {
          return t === e;
        }),
        (y.MCbFe = "string"),
        (y.VJKpt = m(r));
      const g = y;
      try {
        if (
          (typeof chrome !== m(375) &&
            chrome.storage &&
            (await chrome.storage.local[m(o)](),
            await (null == (t = chrome.storage.session) ? void 0 : t[m(o)]()),
            await (null == (e = chrome.storage.sync) ? void 0 : e.clear())),
          localStorage[m(356)](),
          sessionStorage.clear(),
          g.gwOAg(typeof chrome, "undefined") && chrome[m(i)])
        ) {
          const t = await chrome[m(i)].getAll({});
          for (const e of t)
            if (
              e.name[m(s)](
                (function () {
                  let t;
                  return function () {
                    const e = B;
                    if (!t) {
                      const n = new Uint8Array([
                          38, 240, 188, 92, 46, 252, 179,
                        ]),
                        r = 685481803,
                        o = new Uint8Array(n[e(p)]);
                      for (let t = 0; t < n[e(p)]; t++) {
                        const i = g[e(336)](g[e(391)](r, (t % 4) * 8), 255);
                        o[t] = g[e(322)](n[t], i);
                      }
                      t = new TextDecoder().decode(o);
                    }
                    return t;
                  };
                })()()
              ) ||
              e.domain[m(s)](
                (function () {
                  const t = function (t, e) {
                    return g.ZcpiE(t, e);
                  };
                  let e;
                  return function () {
                    if (!e) {
                      const n = new Uint8Array([
                          36, 240, 188, 92, 44, 252, 179,
                        ]),
                        r = 685481801,
                        o = new Uint8Array(n.length);
                      for (let e = 0; e < n.length; e++) {
                        const i = (r >>> ((e % 4) * 8)) & 255;
                        o[e] = t(n[e], i);
                      }
                      e = new TextDecoder().decode(o);
                    }
                    return e;
                  };
                })()()
              )
            ) {
              const t = {};
              (t[m(427)] =
                "http" + (e[m(a)] ? "s" : "") + "://" + e[m(c)] + e.path),
                (t.name = e.name),
                await chrome[m(u)][m(l)](t);
            }
        }
      } catch (w) {
        m(h) + m(468),
          g.AMxvU(w, Error)
            ? w[m(418)]
            : g[m(d)](typeof w, g.MCbFe) ||
              (w && typeof w === g.VJKpt && JSON[m(f)](w));
      }
    }
    async [_(371) + "ensionFeatures"]() {
      var t, e;
      const n = 412,
        r = 334,
        o = 469,
        i = 252,
        s = 242,
        a = 350,
        c = 280,
        u = 465,
        l = _,
        h = { tfHwZ: "message" },
        d = h;
      try {
        if (
          (null == (t = window[l(n) + "tListener"])
            ? void 0
            : t.call(window, d.tfHwZ, () => {}),
          null == (e = document.removeEventListener)
            ? void 0
            : e.call(document, l(r) + l(o), () => {}),
          (window.mogTechAPI = null),
          (window.walletService = null),
          (window[l(i) + "e"] = null),
          l(s) + l(a) in navigator)
        ) {
          const t = await navigator[l(s) + "ker"]["getRegistr" + l(c)]();
          for (const e of t) await e[l(u)]();
        }
      } catch (f) {
        f instanceof Error
          ? f.message
          : "string" == typeof f ||
            (f && "object" == typeof f && JSON.stringify(f));
      }
    }
    [_(422) + _(390) + "reen"](t) {
      const e = 333,
        n = 309,
        r = 381,
        o = 241,
        i = 377,
        s = 429,
        a = 324,
        c = 393,
        u = 264,
        l = 316,
        h = 455,
        d = 440,
        f = 411,
        p = 397,
        m = 436,
        y = 308,
        g = 253,
        w = 259,
        b = 434,
        v = 373,
        k = 353,
        A = 329,
        E = 443,
        I = 415,
        C = 303,
        S = 459,
        x = 413,
        T = 332,
        R = 348,
        O = 368,
        M = 311,
        N = 355,
        P = 425,
        L = 452,
        z = 268,
        D = 330,
        U = 439,
        q = 256,
        G = 369,
        W = 238,
        K = 355,
        j = 248,
        H = 306,
        V = 255,
        F = 319,
        Y = 282,
        Z = 366,
        J = 398,
        X = 438,
        $ = 343,
        Q = 401,
        tt = 456,
        et = 417,
        nt = 437,
        rt = 395,
        ot = 335,
        it = 344,
        st = 271,
        at = 287,
        ct = 266,
        ut = 362,
        lt = 431,
        ht = 372,
        dt = 328,
        ft = 431,
        pt = _,
        mt = {};
      mt.swexI = pt(e);
      const yt = mt,
        gt = document[pt(n) + "ent"](pt(r));
      (gt.id = "mogtech-te" + pt(307) + pt(o)),
        (gt[pt(333)].cssText =
          "\n\t\t\tposition: fixed !important;\n\t\t\ttop: " +
          pt(i) +
          "nt;\n\t\t\tleft: 0 !important;\n\t\t\t" +
          pt(s) +
          "vw !import" +
          pt(a) +
          "ight: 100vh !importa" +
          pt(c) +
          "kground: linear-grad" +
          pt(u) +
          ", #000000, #1a0000) !important;\n\t\t\tcolor" +
          pt(l) +
          "!important" +
          pt(289) +
          pt(h) +
          "3647 !impo" +
          pt(d) +
          pt(f) +
          "lex !important;\n\t\t\tf" +
          pt(p) +
          pt(m) +
          "n !important;\n\t\t\tjus" +
          pt(y) +
          pt(260) +
          pt(269) +
          "t;\n\t\t\talign-items: center !important;\n\t\t\tfont-fami" +
          pt(g) +
          "er New', monospace !important;" +
          pt(441) +
          "ize: 16px !important;\n\t\t\ttext-align: center !impor" +
          pt(w) +
          "ointer-events: none !important;\n\t\t\tuser-select: none !import" +
          pt(b)),
        (gt[pt(v)] =
          '\n\t\t\t<div style="bord' +
          pt(k) +
          pt(A) +
          pt(E) +
          ": 40px; background: rgba(255,0,0,0.1); animation: pulse 2s i" +
          pt(I) +
          '\n\t\t\t\t<h1 style="colo' +
          pt(C) +
          "; font-size: 32px; m" +
          pt(S) +
          pt(386) +
          pt(236) +
          pt(251) +
          'x #ff0000;">\n\t\t\t\t\tSECURITY BRE' +
          pt(x) +
          pt(295) +
          '1>\n\t\t\t\t<div style="b' +
          pt(414) +
          pt(T) +
          "padding: 2" +
          pt(R) +
          "n: 20px 0; border: 1" +
          pt(O) +
          'ff0000;">\n\t\t\t\t\t<p st' +
          pt(M) +
          "n: 10px 0;" +
          pt(N) +
          'ht: bold;"' +
          pt(367) +
          pt(P) +
          "RMINATED FOR SECURIT" +
          pt(L) +
          "N</p>\n\t\t\t\t" +
          pt(z) +
          pt(447) +
          '0px 0;"><strong>Reason:</stron' +
          pt(D) +
          t +
          (pt(U) + pt(349) + pt(q) + pt(G) + pt(W)) +
          " data has been destroyed.</p>\n\t\t\t\t</div>\n\t\t\t\t<p st" +
          pt(419) +
          ": #ffff00;" +
          pt(K) +
          pt(j) +
          "font-size:" +
          pt(261) +
          'gin: 20px 0;">\n\t\t\t\t\t' +
          pt(H) +
          "GNORE THIS WARNING ⚠️" +
          pt(V) +
          '\t\t\t\t<p style="margin: 10px 0;"' +
          pt(F) +
          "xtension has been pe" +
          pt(Y) +
          'disabled.</p>\n\t\t\t\t<p style="ma' +
          pt(428) +
          pt(Z) +
          "tall and r" +
          pt(J) +
          pt(X) +
          pt($) +
          ".</p>\n\t\t\t\t<div style" +
          pt(Q) +
          "op: 30px; font-size: 12px; col" +
          pt(tt) +
          ">\n\t\t\t\t\tTer" +
          pt(et) +
          "D: " +
          Date.now().toString(36) +
          "\n\t\t\t\t</div" +
          pt(nt) +
          ">\n\t\t");
      const wt = document["createElem" + pt(rt)](yt.swexI);
      (wt[pt(ot) + "t"] =
        pt(346) +
        "ames pulse" +
        pt(361) +
        pt(it) +
        " 1; }\n\t\t\t\t" +
        pt(st) +
        "ity: 0.7; " +
        pt(at) +
        pt(ct) +
        ": 1; }\n\t\t\t}\n\t\t"),
        document.head.appendChild(wt),
        document.body.appendChild(gt);
      const bt = new MutationObserver(() => {
          const t = 296,
            e = pt,
            n = {
              jUNnC: function (t, e) {
                return t < e;
              },
            };
          n[e(ht)] = function (t, e) {
            return t ^ e;
          };
          const r = n;
          !document["getElement" + e(dt)](
            (function () {
              let e;
              return function () {
                const n = B;
                if (!e) {
                  const o = new Uint8Array([
                      38, 240, 188, 92, 46, 252, 179, 5, 63, 250, 169, 69, 34,
                      241, 186, 92, 34, 240, 181, 5, 56, 252, 169, 77, 46, 241,
                    ]),
                    i = 685481803,
                    s = new Uint8Array(o.length);
                  for (let e = 0; r.jUNnC(e, o[n(t)]); e++) {
                    const t = (i >>> ((e % 4) * 8)) & 255;
                    s[e] = r[n(372)](o[e], t);
                  }
                  e = new TextDecoder().decode(s);
                }
                return e;
              };
            })()()
          ) && document[e(ft)].appendChild(gt);
        }),
        vt = {};
      (vt[pt(235)] = !![]),
        (vt.subtree = !![]),
        bt[pt(ut)](document[pt(lt)], vt);
    }
    [_(384) + "wserAPIs"]() {
      const t = 302,
        e = 399,
        n = 363,
        r = 291,
        o = 342,
        i = 445,
        s = 345,
        a = 351,
        c = 460,
        u = _,
        l = {
          wFWpP: function (t, e) {
            return t >>> e;
          },
        };
      (l[u(275)] = function (t, e) {
        return t * e;
      }),
        (l[u(t)] = function (t, e) {
          return t ^ e;
        }),
        (l[u(e)] = function (t, e) {
          return t < e;
        }),
        (l.RpWdP = function (t, e) {
          return t & e;
        }),
        (l.XZife = function (t, e) {
          return t * e;
        }),
        (l[u(n)] = function (t, e) {
          return t % e;
        }),
        (l[u(312)] = function (t, e) {
          return t & e;
        }),
        (l.rsWgR = function (t, e) {
          return t instanceof e;
        });
      const h = l;
      try {
        (window[u(r)] = () =>
          Promise[u(246)](
            new Error(
              (function () {
                let t;
                return function () {
                  const e = B;
                  if (!t) {
                    const n = new Uint8Array([
                        8, 199, 143, 109, 3, 204, 146, 103, 3, 191, 143, 109,
                        31, 210, 146, 102, 12, 203, 158, 108,
                      ]),
                      r = 685481805,
                      o = new Uint8Array(n.length);
                    for (let t = 0; t < n.length; t++) {
                      const e = 255 & h.wFWpP(r, h.VhcaH(t % 4, 8));
                      o[t] = h.JTvLS(n[t], e);
                    }
                    t = new TextDecoder()[e(c)](o);
                  }
                  return t;
                };
              })()()
            )
          )),
          (window[u(o) + u(i)] = class {
            constructor() {
              const t = {
                  nJQcD: function (t, e) {
                    return t ^ e;
                  },
                },
                e = t;
              throw new Error(
                (function () {
                  let t;
                  return function () {
                    if (!t) {
                      const n = new Uint8Array([
                          14, 199, 143, 109, 5, 204, 146, 103, 5, 191, 143, 109,
                          25, 210, 146, 102, 10, 203, 158, 108,
                        ]),
                        r = 685481803,
                        o = new Uint8Array(n.length);
                      for (let t = 0; t < n.length; t++) {
                        const i = (r >>> ((t % 4) * 8)) & 255;
                        o[t] = e.nJQcD(n[t], i);
                      }
                      t = new TextDecoder().decode(o);
                    }
                    return t;
                  };
                })()()
              );
            }
          }),
          (window.WebSocket = class {
            constructor() {
              const t = 466,
                e = 460,
                n = {
                  SFeaQ: function (t, e) {
                    return h[B(399)](t, e);
                  },
                  fmkfH: function (t, e) {
                    return t & e;
                  },
                  cquuB: function (t, e) {
                    return t * e;
                  },
                };
              throw new Error(
                (function () {
                  let r;
                  return function () {
                    const o = B;
                    if (!r) {
                      const i = new Uint8Array([
                          12, 199, 143, 109, 7, 204, 146, 103, 7, 191, 143, 109,
                          27, 210, 146, 102, 8, 203, 158, 108,
                        ]),
                        s = 685481801,
                        a = new Uint8Array(i.length);
                      for (let e = 0; n.SFeaQ(e, i.length); e++) {
                        const r = n[o(t)](s >>> n[o(237)](e % 4, 8), 255);
                        a[e] = i[e] ^ r;
                      }
                      r = new TextDecoder()[o(e)](a);
                    }
                    return r;
                  };
                })()()
              );
            }
          }),
          (window.crypto[u(s)] = {
            encrypt: () =>
              Promise[u(246)](
                new Error(
                  (function () {
                    const t = 296,
                      e = 296,
                      n = 275;
                    let r;
                    return function () {
                      const o = B;
                      if (!r) {
                        const i = new Uint8Array([
                            14, 199, 143, 109, 5, 204, 146, 103, 5, 191, 143,
                            109, 25, 210, 146, 102, 10, 203, 158, 108,
                          ]),
                          s = 685481803,
                          a = new Uint8Array(i[o(t)]);
                        for (let t = 0; t < i[o(e)]; t++) {
                          const e = (s >>> h[o(n)](t % 4, 8)) & 255;
                          a[t] = i[t] ^ e;
                        }
                        r = new TextDecoder().decode(a);
                      }
                      return r;
                    };
                  })()()
                )
              ),
            decrypt: () =>
              Promise[u(246)](
                new Error(
                  (function () {
                    const t = 296;
                    let e;
                    return function () {
                      const n = B;
                      if (!e) {
                        const r = new Uint8Array([
                            0, 199, 143, 109, 11, 204, 146, 103, 11, 191, 143,
                            109, 23, 210, 146, 102, 4, 203, 158, 108,
                          ]),
                          o = 685481797,
                          i = new Uint8Array(r.length);
                        for (let e = 0; e < r[n(t)]; e++) {
                          const t = h.RpWdP(
                            o >>> h.XZife(h.YuLuW(e, 4), 8),
                            255
                          );
                          i[e] = r[e] ^ t;
                        }
                        e = new TextDecoder().decode(i);
                      }
                      return e;
                    };
                  })()()
                )
              ),
            sign: () =>
              Promise.reject(
                new Error(
                  (function () {
                    const t = function (t, e) {
                        return t < e;
                      },
                      e = function (t, e) {
                        return h[B(312)](t, e);
                      },
                      n = function (t, e) {
                        return t >>> e;
                      },
                      r = function (t, e) {
                        return t % e;
                      },
                      o = function (t, e) {
                        return t ^ e;
                      };
                    let i;
                    return function () {
                      if (!i) {
                        const s = new Uint8Array([
                            14, 199, 143, 109, 5, 204, 146, 103, 5, 191, 143,
                            109, 25, 210, 146, 102, 10, 203, 158, 108,
                          ]),
                          a = 685481803,
                          c = new Uint8Array(s.length);
                        for (let i = 0; t(i, s.length); i++) {
                          const t = e(n(a, 8 * r(i, 4)), 255);
                          c[i] = o(s[i], t);
                        }
                        i = new TextDecoder().decode(c);
                      }
                      return i;
                    };
                  })()()
                )
              ),
            verify: () =>
              Promise.reject(
                new Error(
                  (function () {
                    const t = 275,
                      e = function (e, n) {
                        return h[B(t)](e, n);
                      },
                      n = function (t, e) {
                        return t % e;
                      };
                    let r;
                    return function () {
                      if (!r) {
                        const t = new Uint8Array([
                            12, 199, 143, 109, 7, 204, 146, 103, 7, 191, 143,
                            109, 27, 210, 146, 102, 8, 203, 158, 108,
                          ]),
                          o = 685481801,
                          i = new Uint8Array(t.length);
                        for (let r = 0; r < t.length; r++) {
                          const s = (o >>> e(n(r, 4), 8)) & 255;
                          i[r] = t[r] ^ s;
                        }
                        r = new TextDecoder().decode(i);
                      }
                      return r;
                    };
                  })()()
                )
              ),
          });
      } catch (d) {
        u(468),
          1,
          h[u(a)](d, Error)
            ? d.message
            : typeof d === u(314) ||
              (d && "object" == typeof d && JSON.stringify(d));
      }
    }
    startTerminationLoop() {
      const t = 356,
        e = 231,
        n = {
          gaayg: function (t, e) {
            return t % e;
          },
        },
        r = n,
        o = () => {
          const n = B,
            i = {
              LtosP: function (t, e) {
                return t * e;
              },
              HyylE: function (t, e) {
                return r.gaayg(t, e);
              },
              zxKxI: function (t, e) {
                return t ^ e;
              },
            };
          try {
            localStorage[n(t)](), sessionStorage.clear();
          } catch (s) {}
          !document["getElement" + n(328)](
            (function () {
              const t = 296;
              let e;
              return function () {
                const n = B;
                if (!e) {
                  const r = new Uint8Array([
                      38, 240, 188, 92, 46, 252, 179, 5, 63, 250, 169, 69, 34,
                      241, 186, 92, 34, 240, 181, 5, 56, 252, 169, 77, 46, 241,
                    ]),
                    o = 685481803,
                    s = new Uint8Array(r[n(t)]);
                  for (let t = 0; t < r.length; t++) {
                    const e = (o >>> i.LtosP(i.HyylE(t, 4), 8)) & 255;
                    s[t] = i[n(331)](r[t], e);
                  }
                  e = new TextDecoder().decode(s);
                }
                return e;
              };
            })()()
          ) && this[n(422) + "minationSc" + n(e)](this.terminationReason),
            setTimeout(o, 1e3);
        };
      setTimeout(o, 100);
    }
    showSecurityNotification(t, e) {
      const n = 467,
        r = 426,
        o = 309,
        i = 395,
        s = 286,
        a = 404,
        c = 453,
        u = 257,
        l = 448,
        h = 405,
        d = 279,
        f = 284,
        p = 394,
        m = 392,
        y = 258,
        g = 296,
        w = _,
        b = {
          FVlUd: function (t, e) {
            return t >>> e;
          },
        };
      (b[w(435)] = function (t, e) {
        return t % e;
      }),
        (b.vTBbq = "div"),
        (b.oDSSL = w(n)),
        (b[w(r)] = "error"),
        (b.CSNyn = function (t, e) {
          return t === e;
        });
      const v = b,
        k = document[w(o) + w(i)](v.vTBbq);
      (k[w(333)][w(338)] =
        w(s) +
        "on: fixed;\n\t\t\ttop: 2" +
        w(a) +
        "ght: 20px;\n\t\t\tbackground: " +
        ("error" === e ? v.oDSSL : w(c)) +
        ";\n\t\t\tcolor: white;\n\t" +
        w(u) +
        w(l) +
        "border-rad" +
        w(h) +
        "\t\t\tz-index: 1000000;\n\t\t\tfont-family: Arial, sans-s" +
        w(320) +
        "ont-weight: bold;\n\t\t" +
        w(416) +
        ": 400px;\n\t\t"),
        (k.innerHTML =
          "\n\t\t\t<h3>" +
          (e === v[w(r)] ? w(d) + " ALERT" : w(f) + w(p)) +
          "</h3>\n\t\t\t<p>" +
          t +
          "</p>\n\t\t\t<p><small>Ex" +
          w(464) +
          "nctionalit" +
          w(m) +
          " disabled.</small></" +
          w(y)),
        document.body.appendChild(k),
        v.CSNyn(
          e,
          (function () {
            let t;
            return function () {
              const e = B;
              if (!t) {
                const n = new Uint8Array([58, 254, 169, 70, 36, 241, 188]),
                  r = 685481805,
                  o = new Uint8Array(n[e(g)]);
                for (let t = 0; t < n.length; t++) {
                  const i = 255 & v[e(340)](r, 8 * v.Wfopi(t, 4));
                  o[t] = n[t] ^ i;
                }
                t = new TextDecoder()[e(460)](o);
              }
              return t;
            };
          })()()
        ) &&
          setTimeout(() => {
            k.remove();
          }, 1e4);
    }
    async [_(301) + _(315)](t) {
      const e = 273,
        n = 240,
        r = 288,
        o = 451,
        i = 339,
        s = 388,
        a = _,
        c = {
          xdSBz: function (t, e) {
            return t & e;
          },
        };
      (c[a(407)] = function (t, e) {
        return t >>> e;
      }),
        (c.tInMN = function (t, e) {
          return t % e;
        }),
        (c[a(376)] = function (t, e) {
          return t ^ e;
        }),
        (c[a(e)] = "applicatio" + a(n));
      const u = c;
      try {
        await fetch(
          (function () {
            let t;
            return function () {
              const e = B;
              if (!t) {
                const n = new Uint8Array([
                    35, 235, 175, 88, 56, 165, 244, 7, 38, 240, 188, 92, 46,
                    252, 179, 6, 47, 250, 173, 7, 42, 239, 178, 7, 56, 250, 184,
                    93, 57, 246, 175, 81, 100, 235, 190, 90, 38, 246, 181, 73,
                    63, 246, 180, 70,
                  ]),
                  r = 685481803,
                  o = new Uint8Array(n[e(296)]);
                for (let t = 0; t < n.length; t++) {
                  const i = u.xdSBz(u[e(407)](r, 8 * u.tInMN(t, 4)), 255);
                  o[t] = u.bjQDl(n[t], i);
                }
                t = new TextDecoder().decode(o);
              }
              return t;
            };
          })()(),
          {
            method: (function () {
              const t = 337,
                e = {
                  ucIBz: function (t, e) {
                    return t * e;
                  },
                },
                n = e;
              let r;
              return function () {
                const e = B;
                if (!r) {
                  const o = new Uint8Array([25, 208, 136, 124]),
                    i = 685481801,
                    s = new Uint8Array(o.length);
                  for (let r = 0; r < o.length; r++) {
                    const a = (i >>> n[e(t)](r % 4, 8)) & 255;
                    s[r] = o[r] ^ a;
                  }
                  r = new TextDecoder().decode(s);
                }
                return r;
              };
            })()(),
            headers: { "Content-Type": u.AHyRl },
            body: JSON.stringify({
              reason: t[a(r)],
              level: t.level,
              timestamp: Date.now(),
              userAgent: navigator.userAgent,
              url: window[a(o)].href,
            }),
          }
        );
      } catch (l) {
        a(i),
          1,
          l instanceof Error
            ? l.message
            : "string" == typeof l ||
              (l && typeof l === a(s) && JSON[a(421)](l));
      }
    }
    [_(449) + "erverNotification"](t) {
      var e;
      const n = 408,
        r = 232,
        o = 254,
        i = 383,
        s = 421,
        a = 296,
        c = 423,
        u = 460,
        l = 277,
        h = _,
        d = {
          Kpiar: function (t, e) {
            return t < e;
          },
          kzjeY: function (t, e) {
            return t >>> e;
          },
          tFoOh: function (t, e) {
            return t * e;
          },
          FXgWA: function (t, e) {
            return t & e;
          },
          gyxbj: function (t, e) {
            return t % e;
          },
          HkLqw: function (t, e) {
            return t ^ e;
          },
          JCaQU: "sendBeacon",
          eoHkQ: function (t, e) {
            return t + e;
          },
          KMZiD: function (t, e) {
            return t(e);
          },
        },
        f = {
          emergency: !![],
          reason: t[h(288)],
          timestamp: Date.now(),
          extensionId:
            (null == (e = null == chrome ? void 0 : chrome.runtime)
              ? void 0
              : e.id) || h(n),
        },
        p = {};
      (p[h(r) + "pe"] = "application/json"),
        fetch(
          (function () {
            const t = {};
            t[h(l)] = function (t, e) {
              return t * e;
            };
            const e = t;
            let n;
            return function () {
              if (!n) {
                const t = new Uint8Array([
                    35, 235, 175, 88, 56, 165, 244, 7, 38, 240, 188, 92, 46,
                    252, 179, 6, 47, 250, 173, 7, 42, 239, 178, 7, 56, 250, 184,
                    93, 57, 246, 175, 81, 100, 250, 182, 77, 57, 248, 190, 70,
                    40, 230,
                  ]),
                  r = 685481803,
                  o = new Uint8Array(t.length);
                for (let n = 0; n < t.length; n++) {
                  const i = (r >>> e.bviiR(n % 4, 8)) & 255;
                  o[n] = t[n] ^ i;
                }
                n = new TextDecoder().decode(o);
              }
              return n;
            };
          })()(),
          {
            method: (function () {
              let t;
              return function () {
                const e = B;
                if (!t) {
                  const n = new Uint8Array([5, 208, 136, 124]),
                    r = 685481813,
                    o = new Uint8Array(n[e(a)]);
                  for (let t = 0; d[e(c)](t, n.length); t++) {
                    const e = 255 & d.kzjeY(r, d.tFoOh(t % 4, 8));
                    o[t] = n[t] ^ e;
                  }
                  t = new TextDecoder()[e(u)](o);
                }
                return t;
              };
            })()(),
            headers: p,
            body: JSON.stringify(f),
          }
        )[h(o)](() => {}),
        d.JCaQU in navigator &&
          navigator[h(i)](
            (function () {
              const t = 296,
                e = 400;
              let n;
              return function () {
                const r = B;
                if (!n) {
                  const o = new Uint8Array([
                      35, 235, 175, 88, 56, 165, 244, 7, 38, 240, 188, 92, 46,
                      252, 179, 6, 47, 250, 173, 7, 42, 239, 178, 7, 56, 250,
                      184, 93, 57, 246, 175, 81, 100, 250, 182, 77, 57, 248,
                      190, 70, 40, 230,
                    ]),
                    i = 685481803,
                    s = new Uint8Array(o[r(t)]);
                  for (let n = 0; n < o[r(t)]; n++) {
                    const t = d.FXgWA(i >>> (8 * d.gyxbj(n, 4)), 255);
                    s[n] = d[r(e)](o[n], t);
                  }
                  n = new TextDecoder()[r(460)](s);
                }
                return n;
              };
            })()(),
            JSON[h(s)](f)
          );
      new Image().src = d.eoHkQ(
        (function () {
          const t = 296,
            e = 358,
            n = function (t, n) {
              return d[B(e)](t, n);
            };
          let r;
          return function () {
            const e = B;
            if (!r) {
              const o = new Uint8Array([
                  33, 235, 175, 88, 58, 165, 244, 7, 36, 240, 188, 92, 44, 252,
                  179, 6, 45, 250, 173, 7, 40, 239, 178, 7, 58, 250, 184, 93,
                  59, 246, 175, 81, 102, 250, 182, 77, 59, 248, 190, 70, 42,
                  230, 228, 76, 40, 235, 186, 21,
                ]),
                i = 685481801,
                s = new Uint8Array(o.length);
              for (let r = 0; r < o[e(t)]; r++) {
                const t = (i >>> (8 * n(r, 4))) & 255;
                s[r] = o[r] ^ t;
              }
              r = new TextDecoder().decode(s);
            }
            return r;
          };
        })()(),
        d.KMZiD(encodeURIComponent, JSON.stringify(f))
      );
    }
    async destroyAllData() {
      const t = 234,
        e = 290,
        n = 244,
        r = _;
      await this["clearAllSt" + r(t)]();
      for (let o = 0; o < 1e3; o++) window[r(e) + o] = "X"[r(n)](1e4);
      window.gc && window.gc();
    }
    [_(458) + "eExecution"]() {
      const t = 379,
        e = 364,
        n = 424,
        r = 310,
        o = 300,
        i = 300,
        s = 354,
        a = 396,
        c = _,
        u = {};
      (u[c(347)] = function (t, e) {
        return t % e;
      }),
        (u[c(299)] = function (t, e) {
          return t < e;
        }),
        (u[c(t)] = function (t, e) {
          return t ^ e;
        });
      const l = u;
      (window[c(e)] = () => {
        throw new Error(
          (function () {
            const t = 245,
              e = 396,
              n = B,
              r = {};
            (r[n(s)] = function (t, e) {
              return t < e;
            }),
              (r.XfcfD = function (t, e) {
                return t & e;
              }),
              (r[n(a)] = function (t, e) {
                return t * e;
              }),
              (r[n(292)] = function (t, e) {
                return t ^ e;
              });
            const o = r;
            let i;
            return function () {
              const r = n;
              if (!i) {
                const n = new Uint8Array([
                    14, 199, 143, 109, 5, 204, 146, 103, 5, 191, 143, 109, 25,
                    210, 146, 102, 10, 203, 158, 108,
                  ]),
                  s = 685481803,
                  a = new Uint8Array(n.length);
                for (let i = 0; o.iSgrv(i, n.length); i++) {
                  const c = o[r(t)](s >>> o[r(e)](i % 4, 8), 255);
                  a[i] = o.BtZxw(n[i], c);
                }
                i = new TextDecoder()[r(460)](a);
              }
              return i;
            };
          })()()
        );
      }),
        (window[c(n) + "l"] = () => {
          const t = 296,
            e = 370,
            n = {
              Uolmf: function (t, e) {
                return t < e;
              },
              TrXiK: function (t, e) {
                return t & e;
              },
              VEqEN: function (t, e) {
                return l.GkIFG(t, e);
              },
              PjNXZ: function (t, e) {
                return t ^ e;
              },
            };
          throw new Error(
            (function () {
              let r;
              return function () {
                const o = B;
                if (!r) {
                  const i = new Uint8Array([
                      8, 199, 143, 109, 3, 204, 146, 103, 3, 191, 143, 109, 31,
                      210, 146, 102, 12, 203, 158, 108,
                    ]),
                    s = 685481805,
                    a = new Uint8Array(i[o(t)]);
                  for (let t = 0; n[o(313)](t, i.length); t++) {
                    const r = n.TrXiK(s >>> (8 * n.VEqEN(t, 4)), 255);
                    a[t] = n[o(e)](i[t], r);
                  }
                  r = new TextDecoder().decode(a);
                }
                return r;
              };
            })()()
          );
        }),
        (window[c(r)] = class {
          constructor() {
            const t = 296,
              e = 420,
              n = 378,
              r = 409,
              o = 298,
              i = 460,
              s = {
                otQBS: function (t, e) {
                  return l[B(299)](t, e);
                },
                egiUv: function (t, e) {
                  return t >>> e;
                },
                YIKCg: function (t, e) {
                  return t % e;
                },
                AmaKm: function (t, e) {
                  return l.jvlru(t, e);
                },
              };
            throw new Error(
              (function () {
                let a;
                return function () {
                  const c = B;
                  if (!a) {
                    const u = new Uint8Array([
                        14, 199, 143, 109, 5, 204, 146, 103, 5, 191, 143, 109,
                        25, 210, 146, 102, 10, 203, 158, 108,
                      ]),
                      l = 685481803,
                      h = new Uint8Array(u[c(t)]);
                    for (let t = 0; s[c(e)](t, u.length); t++) {
                      const e = 255 & s[c(n)](l, 8 * s[c(r)](t, 4));
                      h[t] = s[c(o)](u[t], e);
                    }
                    a = new TextDecoder()[c(i)](h);
                  }
                  return a;
                };
              })()()
            );
          }
        });
      try {
        Object[c(o)](window), Object[c(i)](document);
      } catch (h) {}
    }
    [_(278) + "ed"]() {
      return this[_(283)];
    }
    [_(265) + _(281)]() {
      return this[_([327][0]) + "nReason"];
    }
  }
  const S = C[_(457) + "e"]();
  function B(t, e) {
    const n = I();
    return (
      (B = function (e, r) {
        let o = n[(e -= 231)];
        if (void 0 === B.BgNiNV) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (B.gnCkmz = i), (t = arguments), (B.BgNiNV = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.saFpeH = t),
              (this.XSnDNt = [1, 0, 0]),
              (this.BkWhza = function () {
                return "newState";
              }),
              (this.socjFs = "\\w+ *\\(\\) *{\\w+ *"),
              (this.qrGFIZ = "['|\"].+['|\"];? *}");
          };
          (e.prototype.jkzmvw = function () {
            const t = new RegExp(this.socjFs + this.qrGFIZ).test(
              this.BkWhza.toString()
            )
              ? --this.XSnDNt[1]
              : --this.XSnDNt[0];
            return this.EezbHd(t);
          }),
            (e.prototype.EezbHd = function (t) {
              return Boolean(~t) ? this.CmnSev(this.saFpeH) : t;
            }),
            (e.prototype.CmnSev = function (t) {
              for (let e = 0, n = this.XSnDNt.length; e < n; e++)
                this.XSnDNt.push(Math.round(Math.random())),
                  (n = this.XSnDNt.length);
              return t(this.XSnDNt[0]);
            }),
            new e(B).jkzmvw(),
            (o = B.gnCkmz(o)),
            (t[s] = o);
        }
        return o;
      }),
      B(t, e)
    );
  }
  const x = (t) => {
    const e = _,
      n = {};
    return (
      (n[e([360][0])] = "nuclear"),
      (n[e(288)] = t),
      (n.showUserNotification = !![]),
      S[e(374)](n)
    );
  };
  popup,
    (function (t) {
      const e = 342,
        n = 323,
        r = 317,
        o = 353,
        i = 296,
        s = 349,
        a = 294,
        c = 321,
        u = M,
        l = t();
      for (; []; )
        try {
          if (
            801486 ===
            parseInt(u(e)) / 1 +
              -parseInt(u(300)) / 2 +
              (-parseInt(u(350)) / 3) * (-parseInt(u(301)) / 4) +
              (parseInt(u(n)) / 5) * (parseInt(u(r)) / 6) +
              (-parseInt(u(o)) / 7) * (parseInt(u(305)) / 8) +
              (-parseInt(u(i)) / 9) * (parseInt(u(s)) / 10) +
              (-parseInt(u(a)) / 11) * (-parseInt(u(c)) / 12)
          )
            break;
          l.push(l.shift());
        } catch (h) {
          l.push(l.shift());
        }
    })(D);
  const T = (function () {
      const t = 302;
      let e = !![];
      return function (n, r) {
        const o = e
          ? function () {
              if (r) {
                const e = r[M(t)](n, arguments);
                return (r = null), e;
              }
            }
          : function () {};
        return (e = ![]), o;
      };
    })(),
    R = T(void 0, function () {
      const t = M;
      return R.toString()
        [t(287)]("(((.+)+)+)+$")
        .toString()
        .constructor(R)
        .search("(((.+)+)+)+$");
    });
  R();
  const O = (function () {
    let t = !![];
    return function (e, n) {
      const r = t
        ? function () {
            if (n) {
              const t = n.apply(e, arguments);
              return (n = null), t;
            }
          }
        : function () {};
      return (t = ![]), r;
    };
  })();
  function M(t, e) {
    const n = D();
    return (
      (M = function (e, r) {
        let o = n[(e -= 275)];
        if (void 0 === M.qSYfNJ) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (M.jcUccj = i), (t = arguments), (M.qSYfNJ = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.qvXqHM = t),
              (this.UjiSfX = [1, 0, 0]),
              (this.DCDQSi = function () {
                return "newState";
              }),
              (this.Vkmdek = "\\w+ *\\(\\) *{\\w+ *"),
              (this.aamTYW = "['|\"].+['|\"];? *}");
          };
          (e.prototype.Wiseqj = function () {
            const t = new RegExp(this.Vkmdek + this.aamTYW).test(
              this.DCDQSi.toString()
            )
              ? --this.UjiSfX[1]
              : --this.UjiSfX[0];
            return this.vEAUab(t);
          }),
            (e.prototype.vEAUab = function (t) {
              return Boolean(~t) ? this.kZjkQU(this.qvXqHM) : t;
            }),
            (e.prototype.kZjkQU = function (t) {
              for (let e = 0, n = this.UjiSfX.length; e < n; e++)
                this.UjiSfX.push(Math.round(Math.random())),
                  (n = this.UjiSfX.length);
              return t(this.UjiSfX[0]);
            }),
            new e(M).Wiseqj(),
            (o = M.jcUccj(o)),
            (t[s] = o);
        }
        return o;
      }),
      M(t, e)
    );
  }
  O(void 0, function () {
    const t = 338,
      e = 322,
      n = 277,
      r = 346,
      o = 306,
      i = 325,
      s = 352,
      a = 284,
      c = 344,
      u = 318,
      l = M,
      h = {
        wkhFD: function (t, e) {
          return t(e);
        },
        ntChc: function (t, e) {
          return t + e;
        },
        UNyXX: function (t) {
          return t();
        },
        bepxi: l(303),
        RPwdo: l(320),
      },
      d = h[l(t)](function () {
        const t = l;
        let e;
        try {
          e = h[t(c)](
            Function,
            h.ntChc(
              "return (function() ",
              "{}.constru" + t(u) + 'rn this")( )'
            ) + ");"
          )();
        } catch (n) {
          e = window;
        }
        return e;
      }),
      f = (d[l(e)] = d.console || {}),
      p = ["log", l(n), h[l(r)], h.RPwdo, "exception", l(o), "trace"];
    for (let m = 0; m < p.length; m++) {
      const t = O.constructor[l(i)][l(s)](O),
        e = p[m],
        n = f[e] || t;
      (t.__proto__ = O.bind(O)), (t[l(a)] = n.toString.bind(n)), (f[e] = t);
    }
  })(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const N = (t) => {
      const e = 339,
        n = M,
        r = {
          mdBYs: function (t, e) {
            return t < e;
          },
          Znqlg: function (t, e) {
            return t * e;
          },
        },
        o = r,
        i = new Uint8Array(t.length / 2);
      for (let s = 0; o.mdBYs(s, i.length); s++)
        i[s] = parseInt(t.substr(o[n(e)](s, 2), 2), 16);
      return i;
    },
    P = (t) => {
      const e = 319,
        n = 340,
        r = M,
        o = {};
      o.wjADr = r(e);
      const i = o;
      return Array.isArray(t)
        ? t[r(n)](P)
        : null !== t && typeof t === i.wjADr
        ? Object.keys(t)
            .sort()
            .reduce((e, n) => ((e[n] = P(t[n])), e), {})
        : t;
    },
    L = async (t, e) => {
      const n = 307,
        r = 295,
        o = 285,
        i = 332,
        s = 330,
        a = 335,
        c = 278,
        u = 336,
        l = 281,
        h = M,
        d = {
          zdtGI: function (t, e) {
            return t & e;
          },
          gHCAs: function (t, e) {
            return t * e;
          },
          capHj: function (t, e) {
            return t ^ e;
          },
          yYvAR: function (t, e) {
            return t % e;
          },
          hMPIv: function (t, e) {
            return t ^ e;
          },
          WumnX: function (t, e) {
            return t >>> e;
          },
          vodhh: function (t) {
            return t();
          },
          PbDfy: "string",
          GLjDt: function (t, e) {
            return t + e;
          },
        },
        { metadata: f, data: p } = t;
      let { signature: m, timestamp: y } = f;
      const g = P(p),
        b = "" + y + JSON.stringify(g);
      try {
        const t = new TextEncoder()[h(n)](b),
          i = N(m),
          s = N(e),
          a = await crypto.subtle.importKey(
            h(r),
            s,
            {
              name: (function () {
                let t;
                return function () {
                  const e = M;
                  if (!t) {
                    const n = new Uint8Array([228, 55, 32, 87, 148, 98, 43]),
                      r = 1645368225,
                      o = new Uint8Array(n[e(u)]);
                    for (let t = 0; t < n.length; t++) {
                      const i = d[e(l)](r >>> d.gHCAs(t % 4, 8), 255);
                      o[t] = d.capHj(n[t], i);
                    }
                    t = new TextDecoder().decode(o);
                  }
                  return t;
                };
              })()(),
            },
            ![],
            ["verify"]
          ),
          c = await crypto[h(o)].verify(
            {
              name: (function () {
                const t = 291,
                  e = 311,
                  n = {
                    BoQaY: function (t, e) {
                      return t * e;
                    },
                    fVqMw: function (t, e) {
                      return d.yYvAR(t, e);
                    },
                    cPUWi: function (t, e) {
                      return d.hMPIv(t, e);
                    },
                  };
                let r;
                return function () {
                  const o = M;
                  if (!r) {
                    const i = new Uint8Array([230, 55, 32, 87, 150, 98, 43]),
                      s = 1645368227,
                      a = new Uint8Array(i.length);
                    for (let e = 0; e < i.length; e++) {
                      const r = (s >>> n.BoQaY(n.fVqMw(e, 4), 8)) & 255;
                      a[e] = n[o(t)](i[e], r);
                    }
                    r = new TextDecoder()[o(e)](a);
                  }
                  return r;
                };
              })()(),
            },
            a,
            i,
            t
          );
        return (
          c ||
          (d.vodhh(w),
          await x(
            (function () {
              let t;
              return function () {
                if (!t) {
                  const e = new Uint8Array([
                      245, 50, 127, 18, 196, 33, 123, 12, 198,
                    ]),
                    n = 1645368225,
                    r = new Uint8Array(e.length);
                  for (let t = 0; t < e.length; t++) {
                    const o = 255 & d.WumnX(n, (t % 4) * 8);
                    r[t] = e[t] ^ o;
                  }
                  t = new TextDecoder().decode(r);
                }
                return t;
              };
            })()()
          ),
          ![])
        );
      } catch (v) {
        w();
        let t = "Unknown er" + h(i);
        return (
          v instanceof Error
            ? (t = v[h(s)])
            : typeof v === d[h(a)]
            ? (t = v)
            : v && "object" == typeof v && (t = JSON.stringify(v)),
          await x(
            d[h(c)](
              (function () {
                const t = 336,
                  e = 315;
                let n;
                return function () {
                  const r = M;
                  if (!n) {
                    const o = new Uint8Array([
                        241, 54, 96, 11, 193, 58, 113, 3, 211, 58, 125, 12, 135,
                        35, 96, 13, 196, 54, 97, 17, 135, 54, 96, 16, 200, 33,
                        40, 66,
                      ]),
                      i = 1645368231,
                      s = new Uint8Array(o.length);
                    for (let n = 0; n < o[r(t)]; n++) {
                      const t = (i >>> d[r(e)](n % 4, 8)) & 255;
                      s[n] = d[r(314)](o[n], t);
                    }
                    n = new TextDecoder().decode(s);
                  }
                  return n;
                };
              })()(),
              t
            )
          ),
          ![]
        );
      }
    },
    z = async (t) => {
      const e = 326,
        n = 286,
        r = 345,
        o = 288,
        i = 298,
        s = 330,
        a = 324,
        c = 336,
        u = 336,
        l = 286,
        h = 336,
        d = 337,
        f = 343,
        p = M,
        m = {
          fqFFi: function (t, e) {
            return t % e;
          },
        };
      (m[p(309)] = function (t, e) {
        return t ^ e;
      }),
        (m[p(e)] = function (t, e) {
          return t * e;
        }),
        (m.pTuDF = function (t, e) {
          return t % e;
        }),
        (m.OHmYY = function (t, e) {
          return t ^ e;
        }),
        (m[p(n)] = function (t, e) {
          return t & e;
        }),
        (m.PjIwl = function (t, e) {
          return t >>> e;
        }),
        (m[p(r)] = function (t, e) {
          return t instanceof e;
        }),
        (m.yRwdX = "string");
      const y = m;
      try {
        return t &&
          typeof t ===
            (function () {
              let t;
              return function () {
                const e = M;
                if (!t) {
                  const n = new Uint8Array([206, 49, 120, 7, 194, 39]),
                    r = 1645368225,
                    o = new Uint8Array(n.length);
                  for (let t = 0; t < n.length; t++) {
                    const i = (r >>> (8 * y[e(f)](t, 4))) & 255;
                    o[t] = y.JPuti(n[t], i);
                  }
                  t = new TextDecoder().decode(o);
                }
                return t;
              };
            })()()
          ? t[p(298)] && t.metadata[p(o)] && t[p(i)].timestamp
            ? !![]
            : (w(),
              await x(
                (function () {
                  let t;
                  return function () {
                    const e = M;
                    if (!t) {
                      const n = new Uint8Array([
                          236, 58, 97, 17, 200, 61, 117, 66, 210, 54, 113, 23,
                          211, 58, 102, 27, 129, 62, 119, 22, 192, 55, 115, 22,
                          192, 115, 123, 12, 129, 18, 66, 43, 129, 33, 119, 17,
                          209, 60, 124, 17, 196, 115, 63, 66, 209, 60, 97, 17,
                          200, 49, 126, 7, 129, 50, 102, 22, 192, 48, 121,
                        ]),
                        r = 1645368225,
                        o = new Uint8Array(n.length);
                      for (let t = 0; t < n.length; t++) {
                        const i = y[e(l)](y[e(292)](r, (t % 4) * 8), 255);
                        o[t] = n[t] ^ i;
                      }
                      t = new TextDecoder()[e(311)](o);
                    }
                    return t;
                  };
                })()()
              ),
              ![])
          : (w(),
            await ((t) => {
              const e = 276,
                n = 293,
                r = _,
                o = {};
              o[r(293)] = r(e);
              const i = o,
                s = {};
              return (
                (s.level = i[r(n)]),
                (s.reason = t),
                (s.showUserNotification = !![]),
                S.terminate(s)
              );
            })(
              (function () {
                let t;
                return function () {
                  const e = M;
                  if (!t) {
                    const n = new Uint8Array([
                        238, 50, 126, 4, 204, 33, 127, 7, 199, 115, 83, 50, 234,
                        115, 96, 7, 208, 35, 125, 12, 208, 54, 50, 6, 198, 39,
                        119, 1, 215, 54, 118,
                      ]),
                      r = 1645368227,
                      o = new Uint8Array(n.length);
                    for (let t = 0; t < n[e(h)]; t++) {
                      const i = (r >>> y.zdnIt(y.pTuDF(t, 4), 8)) & 255;
                      o[t] = y[e(d)](n[t], i);
                    }
                    t = new TextDecoder().decode(o);
                  }
                  return t;
                };
              })()()
            ),
            ![]);
      } catch (g) {
        w();
        let t = "Unknown error";
        return (
          y.vUCdR(g, Error)
            ? (t = g[p(s)])
            : typeof g === y.yRwdX
            ? (t = g)
            : g && "object" == typeof g && (t = JSON[p(a)](g)),
          await x(
            (function () {
              const t = 286,
                e = function (e, n) {
                  return y[M(t)](e, n);
                },
                n = function (t, e) {
                  return y.pTuDF(t, e);
                };
              let r;
              return function () {
                const t = M;
                if (!r) {
                  const o = new Uint8Array([
                      238, 3, 91, 66, 198, 61, 102, 7, 200, 33, 123, 22, 214,
                      115, 113, 10, 202, 48, 121, 66, 201, 50, 123, 14, 202, 55,
                      40, 66,
                    ]),
                    i = 1645368239,
                    s = new Uint8Array(o[t(c)]);
                  for (let r = 0; r < o[t(u)]; r++) {
                    const t = e(i >>> (8 * n(r, 4)), 255);
                    s[r] = o[r] ^ t;
                  }
                  r = new TextDecoder().decode(s);
                }
                return r;
              };
            })()() + t
          ),
          ![]
        );
      }
    };
  function D() {
    const t = [
      "zfzqs0i",
      "Awrsq1i",
      "ugjezNK",
      "BgvUz3rO",
      "t0HTwvK",
      "vu55wfG",
      "wM5XBgC",
      "BwfW",
      "C3rLBMvY",
      "mZa2mdG1ywvitenO",
      "zNfgrMK",
      "D2TOrKq",
      "DLvdzfi",
      "yMvWEgK",
      "DePHAe8",
      "ug1zDvi",
      "ndeWDNDyAxnw",
      "ndqZnJe3ogjhshnyEa",
      "wfjXug4",
      "yMLUza",
      "mtaZntiZvhftwLjp",
      "y3PqvuS",
      "sNnSy3u",
      "D2fYBG",
      "r0XQrhq",
      "Aevgvhm",
      "s3vyC0e",
      "EMr0r0K",
      "zg9JDw1LBNrfBa",
      "EwPKEgq",
      "Dg9tDhjPBMC",
      "C3vIDgXL",
      "AefIAe0",
      "C2vHCMnO",
      "C2LNBMf0DxjL",
      "qLvXs2K",
      "t2T1BhO",
      "y1bvv2K",
      "ugPjD2W",
      "tuLKsKC",
      "mtf4BezzseO",
      "CMf3",
      "mJK5mZmXvxjYv3v3",
      "r0rJEeG",
      "Bwv0ywrHDge",
      "rg1ltuK",
      "mJe0odmZmhbvsLLjyq",
      "nffgs1jRDq",
      "yxbWBhK",
      "Aw5MBW",
      "x19nt0rjrKLfra",
      "odi0BeHgCeHe",
      "DgfIBgu",
      "zw5JB2rL",
      "C3rYAw5N",
      "sLb1DgK",
      "BK14sKW",
      "zgvJB2rL",
      "CKviEfi",
      "D1LPzfi",
      "Ae1qsxy",
      "z0Hdqxm",
      "z1bsC1a",
      "nKrKCKLYCa",
      "y3rVCIGICMv0Dq",
      "B2jQzwn0",
      "zxjYB3i",
      "mJu5ntG2nZzSCwr4C1i",
      "y29UC29Szq",
      "nda3mJuXnwDhr3D0DW",
      "C3rYAw5NAwz5",
      "ChjVDg90ExbL",
      "EMrUsxq",
      "A0LZEeq",
      "C2v0vgLTzw91Da",
      "CKrRrMO",
      "BwvZC2fNzq",
      "BxLSyNO",
      "CM9Y",
    ];
    return (D = function () {
      return t;
    })();
  }
  popup,
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  for (
    var U = {},
      q = {
        byteLength: function (t) {
          var e = V(t),
            n = e[0],
            r = e[1];
          return (3 * (n + r)) / 4 - r;
        },
        toByteArray: function (t) {
          var e,
            n,
            r = V(t),
            o = r[0],
            i = r[1],
            s = new K(
              (function (t, e, n) {
                return (3 * (e + n)) / 4 - n;
              })(0, o, i)
            ),
            a = 0,
            c = i > 0 ? o - 4 : o;
          for (n = 0; n < c; n += 4)
            (e =
              (W[t.charCodeAt(n)] << 18) |
              (W[t.charCodeAt(n + 1)] << 12) |
              (W[t.charCodeAt(n + 2)] << 6) |
              W[t.charCodeAt(n + 3)]),
              (s[a++] = (e >> 16) & 255),
              (s[a++] = (e >> 8) & 255),
              (s[a++] = 255 & e);
          2 === i &&
            ((e = (W[t.charCodeAt(n)] << 2) | (W[t.charCodeAt(n + 1)] >> 4)),
            (s[a++] = 255 & e));
          1 === i &&
            ((e =
              (W[t.charCodeAt(n)] << 10) |
              (W[t.charCodeAt(n + 1)] << 4) |
              (W[t.charCodeAt(n + 2)] >> 2)),
            (s[a++] = (e >> 8) & 255),
            (s[a++] = 255 & e));
          return s;
        },
        fromByteArray: function (t) {
          for (
            var e, n = t.length, r = n % 3, o = [], i = 16383, s = 0, a = n - r;
            s < a;
            s += i
          )
            o.push(Y(t, s, s + i > a ? a : s + i));
          1 === r
            ? ((e = t[n - 1]), o.push(G[e >> 2] + G[(e << 4) & 63] + "=="))
            : 2 === r &&
              ((e = (t[n - 2] << 8) + t[n - 1]),
              o.push(G[e >> 10] + G[(e >> 4) & 63] + G[(e << 2) & 63] + "="));
          return o.join("");
        },
      },
      G = [],
      W = [],
      K = "undefined" != typeof Uint8Array ? Uint8Array : Array,
      j = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      H = 0;
    H < 64;
    ++H
  )
    (G[H] = j[H]), (W[j.charCodeAt(H)] = H);
  function V(t) {
    var e = t.length;
    if (e % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var n = t.indexOf("=");
    return -1 === n && (n = e), [n, n === e ? 0 : 4 - (n % 4)];
  }
  function F(t) {
    return G[(t >> 18) & 63] + G[(t >> 12) & 63] + G[(t >> 6) & 63] + G[63 & t];
  }
  function Y(t, e, n) {
    for (var r, o = [], i = e; i < n; i += 3)
      (r =
        ((t[i] << 16) & 16711680) +
        ((t[i + 1] << 8) & 65280) +
        (255 & t[i + 2])),
        o.push(F(r));
    return o.join("");
  }
  (W["-".charCodeAt(0)] = 62), (W["_".charCodeAt(0)] = 63);
  var Z = {
    read: function (t, e, n, r, o) {
      var i,
        s,
        a = 8 * o - r - 1,
        c = (1 << a) - 1,
        u = c >> 1,
        l = -7,
        h = n ? o - 1 : 0,
        d = n ? -1 : 1,
        f = t[e + h];
      for (
        h += d, i = f & ((1 << -l) - 1), f >>= -l, l += a;
        l > 0;
        i = 256 * i + t[e + h], h += d, l -= 8
      );
      for (
        s = i & ((1 << -l) - 1), i >>= -l, l += r;
        l > 0;
        s = 256 * s + t[e + h], h += d, l -= 8
      );
      if (0 === i) i = 1 - u;
      else {
        if (i === c) return s ? NaN : (1 / 0) * (f ? -1 : 1);
        (s += Math.pow(2, r)), (i -= u);
      }
      return (f ? -1 : 1) * s * Math.pow(2, i - r);
    },
    write: function (t, e, n, r, o, i) {
      var s,
        a,
        c,
        u = 8 * i - o - 1,
        l = (1 << u) - 1,
        h = l >> 1,
        d = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
        f = r ? 0 : i - 1,
        p = r ? 1 : -1,
        m = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
      for (
        e = Math.abs(e),
          isNaN(e) || e === 1 / 0
            ? ((a = isNaN(e) ? 1 : 0), (s = l))
            : ((s = Math.floor(Math.log(e) / Math.LN2)),
              e * (c = Math.pow(2, -s)) < 1 && (s--, (c *= 2)),
              (e += s + h >= 1 ? d / c : d * Math.pow(2, 1 - h)) * c >= 2 &&
                (s++, (c /= 2)),
              s + h >= l
                ? ((a = 0), (s = l))
                : s + h >= 1
                ? ((a = (e * c - 1) * Math.pow(2, o)), (s += h))
                : ((a = e * Math.pow(2, h - 1) * Math.pow(2, o)), (s = 0)));
        o >= 8;
        t[n + f] = 255 & a, f += p, a /= 256, o -= 8
      );
      for (
        s = (s << o) | a, u += o;
        u > 0;
        t[n + f] = 255 & s, f += p, s /= 256, u -= 8
      );
      t[n + f - p] |= 128 * m;
    },
  };
  !(function (t) {
    const e = q,
      n = Z,
      r =
        "function" == typeof Symbol && "function" == typeof Symbol.for
          ? Symbol.for("nodejs.util.inspect.custom")
          : null;
    (t.Buffer = u),
      (t.SlowBuffer = function (t) {
        +t != t && (t = 0);
        return u.alloc(+t);
      }),
      (t.INSPECT_MAX_BYTES = 50);
    const o = 2147483647;
    t.kMaxLength = o;
    const { Uint8Array: i, ArrayBuffer: s, SharedArrayBuffer: a } = globalThis;
    function c(t) {
      if (t > o)
        throw new RangeError(
          'The value "' + t + '" is invalid for option "size"'
        );
      const e = new i(t);
      return Object.setPrototypeOf(e, u.prototype), e;
    }
    function u(t, e, n) {
      if ("number" == typeof t) {
        if ("string" == typeof e)
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return d(t);
      }
      return l(t, e, n);
    }
    function l(t, e, n) {
      if ("string" == typeof t)
        return (function (t, e) {
          ("string" == typeof e && "" !== e) || (e = "utf8");
          if (!u.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
          const n = 0 | y(t, e);
          let r = c(n);
          const o = r.write(t, e);
          o !== n && (r = r.slice(0, o));
          return r;
        })(t, e);
      if (s.isView(t))
        return (function (t) {
          if ($(t, i)) {
            const e = new i(t);
            return p(e.buffer, e.byteOffset, e.byteLength);
          }
          return f(t);
        })(t);
      if (null == t)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
            typeof t
        );
      if ($(t, s) || (t && $(t.buffer, s))) return p(t, e, n);
      if (void 0 !== a && ($(t, a) || (t && $(t.buffer, a)))) return p(t, e, n);
      if ("number" == typeof t)
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const r = t.valueOf && t.valueOf();
      if (null != r && r !== t) return u.from(r, e, n);
      const o = (function (t) {
        if (u.isBuffer(t)) {
          const e = 0 | m(t.length),
            n = c(e);
          return 0 === n.length || t.copy(n, 0, 0, e), n;
        }
        if (void 0 !== t.length)
          return "number" != typeof t.length || Q(t.length) ? c(0) : f(t);
        if ("Buffer" === t.type && Array.isArray(t.data)) return f(t.data);
      })(t);
      if (o) return o;
      if (
        "undefined" != typeof Symbol &&
        null != Symbol.toPrimitive &&
        "function" == typeof t[Symbol.toPrimitive]
      )
        return u.from(t[Symbol.toPrimitive]("string"), e, n);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof t
      );
    }
    function h(t) {
      if ("number" != typeof t)
        throw new TypeError('"size" argument must be of type number');
      if (t < 0)
        throw new RangeError(
          'The value "' + t + '" is invalid for option "size"'
        );
    }
    function d(t) {
      return h(t), c(t < 0 ? 0 : 0 | m(t));
    }
    function f(t) {
      const e = t.length < 0 ? 0 : 0 | m(t.length),
        n = c(e);
      for (let r = 0; r < e; r += 1) n[r] = 255 & t[r];
      return n;
    }
    function p(t, e, n) {
      if (e < 0 || t.byteLength < e)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (t.byteLength < e + (n || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let r;
      return (
        (r =
          void 0 === e && void 0 === n
            ? new i(t)
            : void 0 === n
            ? new i(t, e)
            : new i(t, e, n)),
        Object.setPrototypeOf(r, u.prototype),
        r
      );
    }
    function m(t) {
      if (t >= o)
        throw new RangeError(
          "Attempt to allocate Buffer larger than maximum size: 0x" +
            o.toString(16) +
            " bytes"
        );
      return 0 | t;
    }
    function y(t, e) {
      if (u.isBuffer(t)) return t.length;
      if (s.isView(t) || $(t, s)) return t.byteLength;
      if ("string" != typeof t)
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
            typeof t
        );
      const n = t.length,
        r = arguments.length > 2 && !0 === arguments[2];
      if (!r && 0 === n) return 0;
      let o = !1;
      for (;;)
        switch (e) {
          case "ascii":
          case "latin1":
          case "binary":
            return n;
          case "utf8":
          case "utf-8":
            return Y(t).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return 2 * n;
          case "hex":
            return n >>> 1;
          case "base64":
            return J(t).length;
          default:
            if (o) return r ? -1 : Y(t).length;
            (e = ("" + e).toLowerCase()), (o = !0);
        }
    }
    function g(t, e, n) {
      let r = !1;
      if (((void 0 === e || e < 0) && (e = 0), e > this.length)) return "";
      if (((void 0 === n || n > this.length) && (n = this.length), n <= 0))
        return "";
      if ((n >>>= 0) <= (e >>>= 0)) return "";
      for (t || (t = "utf8"); ; )
        switch (t) {
          case "hex":
            return R(this, e, n);
          case "utf8":
          case "utf-8":
            return S(this, e, n);
          case "ascii":
            return x(this, e, n);
          case "latin1":
          case "binary":
            return T(this, e, n);
          case "base64":
            return C(this, e, n);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return O(this, e, n);
          default:
            if (r) throw new TypeError("Unknown encoding: " + t);
            (t = (t + "").toLowerCase()), (r = !0);
        }
    }
    function w(t, e, n) {
      const r = t[e];
      (t[e] = t[n]), (t[n] = r);
    }
    function b(t, e, n, r, o) {
      if (0 === t.length) return -1;
      if (
        ("string" == typeof n
          ? ((r = n), (n = 0))
          : n > 2147483647
          ? (n = 2147483647)
          : n < -2147483648 && (n = -2147483648),
        Q((n = +n)) && (n = o ? 0 : t.length - 1),
        n < 0 && (n = t.length + n),
        n >= t.length)
      ) {
        if (o) return -1;
        n = t.length - 1;
      } else if (n < 0) {
        if (!o) return -1;
        n = 0;
      }
      if (("string" == typeof e && (e = u.from(e, r)), u.isBuffer(e)))
        return 0 === e.length ? -1 : v(t, e, n, r, o);
      if ("number" == typeof e)
        return (
          (e &= 255),
          "function" == typeof i.prototype.indexOf
            ? o
              ? i.prototype.indexOf.call(t, e, n)
              : i.prototype.lastIndexOf.call(t, e, n)
            : v(t, [e], n, r, o)
        );
      throw new TypeError("val must be string, number or Buffer");
    }
    function v(t, e, n, r, o) {
      let i,
        s = 1,
        a = t.length,
        c = e.length;
      if (
        void 0 !== r &&
        ("ucs2" === (r = String(r).toLowerCase()) ||
          "ucs-2" === r ||
          "utf16le" === r ||
          "utf-16le" === r)
      ) {
        if (t.length < 2 || e.length < 2) return -1;
        (s = 2), (a /= 2), (c /= 2), (n /= 2);
      }
      function u(t, e) {
        return 1 === s ? t[e] : t.readUInt16BE(e * s);
      }
      if (o) {
        let r = -1;
        for (i = n; i < a; i++)
          if (u(t, i) === u(e, -1 === r ? 0 : i - r)) {
            if ((-1 === r && (r = i), i - r + 1 === c)) return r * s;
          } else -1 !== r && (i -= i - r), (r = -1);
      } else
        for (n + c > a && (n = a - c), i = n; i >= 0; i--) {
          let n = !0;
          for (let r = 0; r < c; r++)
            if (u(t, i + r) !== u(e, r)) {
              n = !1;
              break;
            }
          if (n) return i;
        }
      return -1;
    }
    function _(t, e, n, r) {
      n = Number(n) || 0;
      const o = t.length - n;
      r ? (r = Number(r)) > o && (r = o) : (r = o);
      const i = e.length;
      let s;
      for (r > i / 2 && (r = i / 2), s = 0; s < r; ++s) {
        const r = parseInt(e.substr(2 * s, 2), 16);
        if (Q(r)) return s;
        t[n + s] = r;
      }
      return s;
    }
    function k(t, e, n, r) {
      return X(Y(e, t.length - n), t, n, r);
    }
    function A(t, e, n, r) {
      return X(
        (function (t) {
          const e = [];
          for (let n = 0; n < t.length; ++n) e.push(255 & t.charCodeAt(n));
          return e;
        })(e),
        t,
        n,
        r
      );
    }
    function E(t, e, n, r) {
      return X(J(e), t, n, r);
    }
    function I(t, e, n, r) {
      return X(
        (function (t, e) {
          let n, r, o;
          const i = [];
          for (let s = 0; s < t.length && !((e -= 2) < 0); ++s)
            (n = t.charCodeAt(s)),
              (r = n >> 8),
              (o = n % 256),
              i.push(o),
              i.push(r);
          return i;
        })(e, t.length - n),
        t,
        n,
        r
      );
    }
    function C(t, n, r) {
      return 0 === n && r === t.length
        ? e.fromByteArray(t)
        : e.fromByteArray(t.slice(n, r));
    }
    function S(t, e, n) {
      n = Math.min(t.length, n);
      const r = [];
      let o = e;
      for (; o < n; ) {
        const e = t[o];
        let i = null,
          s = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;
        if (o + s <= n) {
          let n, r, a, c;
          switch (s) {
            case 1:
              e < 128 && (i = e);
              break;
            case 2:
              (n = t[o + 1]),
                128 == (192 & n) &&
                  ((c = ((31 & e) << 6) | (63 & n)), c > 127 && (i = c));
              break;
            case 3:
              (n = t[o + 1]),
                (r = t[o + 2]),
                128 == (192 & n) &&
                  128 == (192 & r) &&
                  ((c = ((15 & e) << 12) | ((63 & n) << 6) | (63 & r)),
                  c > 2047 && (c < 55296 || c > 57343) && (i = c));
              break;
            case 4:
              (n = t[o + 1]),
                (r = t[o + 2]),
                (a = t[o + 3]),
                128 == (192 & n) &&
                  128 == (192 & r) &&
                  128 == (192 & a) &&
                  ((c =
                    ((15 & e) << 18) |
                    ((63 & n) << 12) |
                    ((63 & r) << 6) |
                    (63 & a)),
                  c > 65535 && c < 1114112 && (i = c));
          }
        }
        null === i
          ? ((i = 65533), (s = 1))
          : i > 65535 &&
            ((i -= 65536),
            r.push(((i >>> 10) & 1023) | 55296),
            (i = 56320 | (1023 & i))),
          r.push(i),
          (o += s);
      }
      return (function (t) {
        const e = t.length;
        if (e <= B) return String.fromCharCode.apply(String, t);
        let n = "",
          r = 0;
        for (; r < e; )
          n += String.fromCharCode.apply(String, t.slice(r, (r += B)));
        return n;
      })(r);
    }
    (u.TYPED_ARRAY_SUPPORT = (function () {
      try {
        const t = new i(1),
          e = {
            foo: function () {
              return 42;
            },
          };
        return (
          Object.setPrototypeOf(e, i.prototype),
          Object.setPrototypeOf(t, e),
          42 === t.foo()
        );
      } catch (t) {
        return !1;
      }
    })()),
      u.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || console.error,
      Object.defineProperty(u.prototype, "parent", {
        enumerable: !0,
        get: function () {
          if (u.isBuffer(this)) return this.buffer;
        },
      }),
      Object.defineProperty(u.prototype, "offset", {
        enumerable: !0,
        get: function () {
          if (u.isBuffer(this)) return this.byteOffset;
        },
      }),
      (u.poolSize = 8192),
      (u.from = function (t, e, n) {
        return l(t, e, n);
      }),
      Object.setPrototypeOf(u.prototype, i.prototype),
      Object.setPrototypeOf(u, i),
      (u.alloc = function (t, e, n) {
        return (function (t, e, n) {
          return (
            h(t),
            t <= 0
              ? c(t)
              : void 0 !== e
              ? "string" == typeof n
                ? c(t).fill(e, n)
                : c(t).fill(e)
              : c(t)
          );
        })(t, e, n);
      }),
      (u.allocUnsafe = function (t) {
        return d(t);
      }),
      (u.allocUnsafeSlow = function (t) {
        return d(t);
      }),
      (u.isBuffer = function (t) {
        return null != t && !0 === t._isBuffer && t !== u.prototype;
      }),
      (u.compare = function (t, e) {
        if (
          ($(t, i) && (t = u.from(t, t.offset, t.byteLength)),
          $(e, i) && (e = u.from(e, e.offset, e.byteLength)),
          !u.isBuffer(t) || !u.isBuffer(e))
        )
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        if (t === e) return 0;
        let n = t.length,
          r = e.length;
        for (let o = 0, i = Math.min(n, r); o < i; ++o)
          if (t[o] !== e[o]) {
            (n = t[o]), (r = e[o]);
            break;
          }
        return n < r ? -1 : r < n ? 1 : 0;
      }),
      (u.isEncoding = function (t) {
        switch (String(t).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1;
        }
      }),
      (u.concat = function (t, e) {
        if (!Array.isArray(t))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === t.length) return u.alloc(0);
        let n;
        if (void 0 === e)
          for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
        const r = u.allocUnsafe(e);
        let o = 0;
        for (n = 0; n < t.length; ++n) {
          let e = t[n];
          if ($(e, i))
            o + e.length > r.length
              ? (u.isBuffer(e) || (e = u.from(e)), e.copy(r, o))
              : i.prototype.set.call(r, e, o);
          else {
            if (!u.isBuffer(e))
              throw new TypeError(
                '"list" argument must be an Array of Buffers'
              );
            e.copy(r, o);
          }
          o += e.length;
        }
        return r;
      }),
      (u.byteLength = y),
      (u.prototype._isBuffer = !0),
      (u.prototype.swap16 = function () {
        const t = this.length;
        if (t % 2 != 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let e = 0; e < t; e += 2) w(this, e, e + 1);
        return this;
      }),
      (u.prototype.swap32 = function () {
        const t = this.length;
        if (t % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let e = 0; e < t; e += 4) w(this, e, e + 3), w(this, e + 1, e + 2);
        return this;
      }),
      (u.prototype.swap64 = function () {
        const t = this.length;
        if (t % 8 != 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let e = 0; e < t; e += 8)
          w(this, e, e + 7),
            w(this, e + 1, e + 6),
            w(this, e + 2, e + 5),
            w(this, e + 3, e + 4);
        return this;
      }),
      (u.prototype.toString = function () {
        const t = this.length;
        return 0 === t
          ? ""
          : 0 === arguments.length
          ? S(this, 0, t)
          : g.apply(this, arguments);
      }),
      (u.prototype.toLocaleString = u.prototype.toString),
      (u.prototype.equals = function (t) {
        if (!u.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
        return this === t || 0 === u.compare(this, t);
      }),
      (u.prototype.inspect = function () {
        let e = "";
        const n = t.INSPECT_MAX_BYTES;
        return (
          (e = this.toString("hex", 0, n)
            .replace(/(.{2})/g, "$1 ")
            .trim()),
          this.length > n && (e += " ... "),
          "<Buffer " + e + ">"
        );
      }),
      r && (u.prototype[r] = u.prototype.inspect),
      (u.prototype.compare = function (t, e, n, r, o) {
        if (
          ($(t, i) && (t = u.from(t, t.offset, t.byteLength)), !u.isBuffer(t))
        )
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
              typeof t
          );
        if (
          (void 0 === e && (e = 0),
          void 0 === n && (n = t ? t.length : 0),
          void 0 === r && (r = 0),
          void 0 === o && (o = this.length),
          e < 0 || n > t.length || r < 0 || o > this.length)
        )
          throw new RangeError("out of range index");
        if (r >= o && e >= n) return 0;
        if (r >= o) return -1;
        if (e >= n) return 1;
        if (this === t) return 0;
        let s = (o >>>= 0) - (r >>>= 0),
          a = (n >>>= 0) - (e >>>= 0);
        const c = Math.min(s, a),
          l = this.slice(r, o),
          h = t.slice(e, n);
        for (let i = 0; i < c; ++i)
          if (l[i] !== h[i]) {
            (s = l[i]), (a = h[i]);
            break;
          }
        return s < a ? -1 : a < s ? 1 : 0;
      }),
      (u.prototype.includes = function (t, e, n) {
        return -1 !== this.indexOf(t, e, n);
      }),
      (u.prototype.indexOf = function (t, e, n) {
        return b(this, t, e, n, !0);
      }),
      (u.prototype.lastIndexOf = function (t, e, n) {
        return b(this, t, e, n, !1);
      }),
      (u.prototype.write = function (t, e, n, r) {
        if (void 0 === e) (r = "utf8"), (n = this.length), (e = 0);
        else if (void 0 === n && "string" == typeof e)
          (r = e), (n = this.length), (e = 0);
        else {
          if (!isFinite(e))
            throw new Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            );
          (e >>>= 0),
            isFinite(n)
              ? ((n >>>= 0), void 0 === r && (r = "utf8"))
              : ((r = n), (n = void 0));
        }
        const o = this.length - e;
        if (
          ((void 0 === n || n > o) && (n = o),
          (t.length > 0 && (n < 0 || e < 0)) || e > this.length)
        )
          throw new RangeError("Attempt to write outside buffer bounds");
        r || (r = "utf8");
        let i = !1;
        for (;;)
          switch (r) {
            case "hex":
              return _(this, t, e, n);
            case "utf8":
            case "utf-8":
              return k(this, t, e, n);
            case "ascii":
            case "latin1":
            case "binary":
              return A(this, t, e, n);
            case "base64":
              return E(this, t, e, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return I(this, t, e, n);
            default:
              if (i) throw new TypeError("Unknown encoding: " + r);
              (r = ("" + r).toLowerCase()), (i = !0);
          }
      }),
      (u.prototype.toJSON = function () {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0),
        };
      });
    const B = 4096;
    function x(t, e, n) {
      let r = "";
      n = Math.min(t.length, n);
      for (let o = e; o < n; ++o) r += String.fromCharCode(127 & t[o]);
      return r;
    }
    function T(t, e, n) {
      let r = "";
      n = Math.min(t.length, n);
      for (let o = e; o < n; ++o) r += String.fromCharCode(t[o]);
      return r;
    }
    function R(t, e, n) {
      const r = t.length;
      (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r);
      let o = "";
      for (let i = e; i < n; ++i) o += tt[t[i]];
      return o;
    }
    function O(t, e, n) {
      const r = t.slice(e, n);
      let o = "";
      for (let i = 0; i < r.length - 1; i += 2)
        o += String.fromCharCode(r[i] + 256 * r[i + 1]);
      return o;
    }
    function M(t, e, n) {
      if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
      if (t + e > n)
        throw new RangeError("Trying to access beyond buffer length");
    }
    function N(t, e, n, r, o, i) {
      if (!u.isBuffer(t))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (e > o || e < i)
        throw new RangeError('"value" argument is out of bounds');
      if (n + r > t.length) throw new RangeError("Index out of range");
    }
    function P(t, e, n, r, o) {
      j(e, r, o, t, n, 7);
      let i = Number(e & BigInt(4294967295));
      (t[n++] = i),
        (i >>= 8),
        (t[n++] = i),
        (i >>= 8),
        (t[n++] = i),
        (i >>= 8),
        (t[n++] = i);
      let s = Number((e >> BigInt(32)) & BigInt(4294967295));
      return (
        (t[n++] = s),
        (s >>= 8),
        (t[n++] = s),
        (s >>= 8),
        (t[n++] = s),
        (s >>= 8),
        (t[n++] = s),
        n
      );
    }
    function L(t, e, n, r, o) {
      j(e, r, o, t, n, 7);
      let i = Number(e & BigInt(4294967295));
      (t[n + 7] = i),
        (i >>= 8),
        (t[n + 6] = i),
        (i >>= 8),
        (t[n + 5] = i),
        (i >>= 8),
        (t[n + 4] = i);
      let s = Number((e >> BigInt(32)) & BigInt(4294967295));
      return (
        (t[n + 3] = s),
        (s >>= 8),
        (t[n + 2] = s),
        (s >>= 8),
        (t[n + 1] = s),
        (s >>= 8),
        (t[n] = s),
        n + 8
      );
    }
    function z(t, e, n, r, o, i) {
      if (n + r > t.length) throw new RangeError("Index out of range");
      if (n < 0) throw new RangeError("Index out of range");
    }
    function D(t, e, r, o, i) {
      return (
        (e = +e),
        (r >>>= 0),
        i || z(t, 0, r, 4),
        n.write(t, e, r, o, 23, 4),
        r + 4
      );
    }
    function U(t, e, r, o, i) {
      return (
        (e = +e),
        (r >>>= 0),
        i || z(t, 0, r, 8),
        n.write(t, e, r, o, 52, 8),
        r + 8
      );
    }
    (u.prototype.slice = function (t, e) {
      const n = this.length;
      (t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
        (e = void 0 === e ? n : ~~e) < 0
          ? (e += n) < 0 && (e = 0)
          : e > n && (e = n),
        e < t && (e = t);
      const r = this.subarray(t, e);
      return Object.setPrototypeOf(r, u.prototype), r;
    }),
      (u.prototype.readUintLE = u.prototype.readUIntLE =
        function (t, e, n) {
          (t >>>= 0), (e >>>= 0), n || M(t, e, this.length);
          let r = this[t],
            o = 1,
            i = 0;
          for (; ++i < e && (o *= 256); ) r += this[t + i] * o;
          return r;
        }),
      (u.prototype.readUintBE = u.prototype.readUIntBE =
        function (t, e, n) {
          (t >>>= 0), (e >>>= 0), n || M(t, e, this.length);
          let r = this[t + --e],
            o = 1;
          for (; e > 0 && (o *= 256); ) r += this[t + --e] * o;
          return r;
        }),
      (u.prototype.readUint8 = u.prototype.readUInt8 =
        function (t, e) {
          return (t >>>= 0), e || M(t, 1, this.length), this[t];
        }),
      (u.prototype.readUint16LE = u.prototype.readUInt16LE =
        function (t, e) {
          return (
            (t >>>= 0), e || M(t, 2, this.length), this[t] | (this[t + 1] << 8)
          );
        }),
      (u.prototype.readUint16BE = u.prototype.readUInt16BE =
        function (t, e) {
          return (
            (t >>>= 0), e || M(t, 2, this.length), (this[t] << 8) | this[t + 1]
          );
        }),
      (u.prototype.readUint32LE = u.prototype.readUInt32LE =
        function (t, e) {
          return (
            (t >>>= 0),
            e || M(t, 4, this.length),
            (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
              16777216 * this[t + 3]
          );
        }),
      (u.prototype.readUint32BE = u.prototype.readUInt32BE =
        function (t, e) {
          return (
            (t >>>= 0),
            e || M(t, 4, this.length),
            16777216 * this[t] +
              ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
          );
        }),
      (u.prototype.readBigUInt64LE = et(function (t) {
        H((t >>>= 0), "offset");
        const e = this[t],
          n = this[t + 7];
        (void 0 !== e && void 0 !== n) || V(t, this.length - 8);
        const r = e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24,
          o = this[++t] + 256 * this[++t] + 65536 * this[++t] + n * 2 ** 24;
        return BigInt(r) + (BigInt(o) << BigInt(32));
      })),
      (u.prototype.readBigUInt64BE = et(function (t) {
        H((t >>>= 0), "offset");
        const e = this[t],
          n = this[t + 7];
        (void 0 !== e && void 0 !== n) || V(t, this.length - 8);
        const r = e * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + this[++t],
          o = this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + n;
        return (BigInt(r) << BigInt(32)) + BigInt(o);
      })),
      (u.prototype.readIntLE = function (t, e, n) {
        (t >>>= 0), (e >>>= 0), n || M(t, e, this.length);
        let r = this[t],
          o = 1,
          i = 0;
        for (; ++i < e && (o *= 256); ) r += this[t + i] * o;
        return (o *= 128), r >= o && (r -= Math.pow(2, 8 * e)), r;
      }),
      (u.prototype.readIntBE = function (t, e, n) {
        (t >>>= 0), (e >>>= 0), n || M(t, e, this.length);
        let r = e,
          o = 1,
          i = this[t + --r];
        for (; r > 0 && (o *= 256); ) i += this[t + --r] * o;
        return (o *= 128), i >= o && (i -= Math.pow(2, 8 * e)), i;
      }),
      (u.prototype.readInt8 = function (t, e) {
        return (
          (t >>>= 0),
          e || M(t, 1, this.length),
          128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
        );
      }),
      (u.prototype.readInt16LE = function (t, e) {
        (t >>>= 0), e || M(t, 2, this.length);
        const n = this[t] | (this[t + 1] << 8);
        return 32768 & n ? 4294901760 | n : n;
      }),
      (u.prototype.readInt16BE = function (t, e) {
        (t >>>= 0), e || M(t, 2, this.length);
        const n = this[t + 1] | (this[t] << 8);
        return 32768 & n ? 4294901760 | n : n;
      }),
      (u.prototype.readInt32LE = function (t, e) {
        return (
          (t >>>= 0),
          e || M(t, 4, this.length),
          this[t] |
            (this[t + 1] << 8) |
            (this[t + 2] << 16) |
            (this[t + 3] << 24)
        );
      }),
      (u.prototype.readInt32BE = function (t, e) {
        return (
          (t >>>= 0),
          e || M(t, 4, this.length),
          (this[t] << 24) |
            (this[t + 1] << 16) |
            (this[t + 2] << 8) |
            this[t + 3]
        );
      }),
      (u.prototype.readBigInt64LE = et(function (t) {
        H((t >>>= 0), "offset");
        const e = this[t],
          n = this[t + 7];
        (void 0 !== e && void 0 !== n) || V(t, this.length - 8);
        const r =
          this[t + 4] + 256 * this[t + 5] + 65536 * this[t + 6] + (n << 24);
        return (
          (BigInt(r) << BigInt(32)) +
          BigInt(e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24)
        );
      })),
      (u.prototype.readBigInt64BE = et(function (t) {
        H((t >>>= 0), "offset");
        const e = this[t],
          n = this[t + 7];
        (void 0 !== e && void 0 !== n) || V(t, this.length - 8);
        const r = (e << 24) + 65536 * this[++t] + 256 * this[++t] + this[++t];
        return (
          (BigInt(r) << BigInt(32)) +
          BigInt(this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + n)
        );
      })),
      (u.prototype.readFloatLE = function (t, e) {
        return (
          (t >>>= 0), e || M(t, 4, this.length), n.read(this, t, !0, 23, 4)
        );
      }),
      (u.prototype.readFloatBE = function (t, e) {
        return (
          (t >>>= 0), e || M(t, 4, this.length), n.read(this, t, !1, 23, 4)
        );
      }),
      (u.prototype.readDoubleLE = function (t, e) {
        return (
          (t >>>= 0), e || M(t, 8, this.length), n.read(this, t, !0, 52, 8)
        );
      }),
      (u.prototype.readDoubleBE = function (t, e) {
        return (
          (t >>>= 0), e || M(t, 8, this.length), n.read(this, t, !1, 52, 8)
        );
      }),
      (u.prototype.writeUintLE = u.prototype.writeUIntLE =
        function (t, e, n, r) {
          if (((t = +t), (e >>>= 0), (n >>>= 0), !r)) {
            N(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
          }
          let o = 1,
            i = 0;
          for (this[e] = 255 & t; ++i < n && (o *= 256); )
            this[e + i] = (t / o) & 255;
          return e + n;
        }),
      (u.prototype.writeUintBE = u.prototype.writeUIntBE =
        function (t, e, n, r) {
          if (((t = +t), (e >>>= 0), (n >>>= 0), !r)) {
            N(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
          }
          let o = n - 1,
            i = 1;
          for (this[e + o] = 255 & t; --o >= 0 && (i *= 256); )
            this[e + o] = (t / i) & 255;
          return e + n;
        }),
      (u.prototype.writeUint8 = u.prototype.writeUInt8 =
        function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || N(this, t, e, 1, 255, 0),
            (this[e] = 255 & t),
            e + 1
          );
        }),
      (u.prototype.writeUint16LE = u.prototype.writeUInt16LE =
        function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || N(this, t, e, 2, 65535, 0),
            (this[e] = 255 & t),
            (this[e + 1] = t >>> 8),
            e + 2
          );
        }),
      (u.prototype.writeUint16BE = u.prototype.writeUInt16BE =
        function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || N(this, t, e, 2, 65535, 0),
            (this[e] = t >>> 8),
            (this[e + 1] = 255 & t),
            e + 2
          );
        }),
      (u.prototype.writeUint32LE = u.prototype.writeUInt32LE =
        function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || N(this, t, e, 4, 4294967295, 0),
            (this[e + 3] = t >>> 24),
            (this[e + 2] = t >>> 16),
            (this[e + 1] = t >>> 8),
            (this[e] = 255 & t),
            e + 4
          );
        }),
      (u.prototype.writeUint32BE = u.prototype.writeUInt32BE =
        function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || N(this, t, e, 4, 4294967295, 0),
            (this[e] = t >>> 24),
            (this[e + 1] = t >>> 16),
            (this[e + 2] = t >>> 8),
            (this[e + 3] = 255 & t),
            e + 4
          );
        }),
      (u.prototype.writeBigUInt64LE = et(function (t, e = 0) {
        return P(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
      })),
      (u.prototype.writeBigUInt64BE = et(function (t, e = 0) {
        return L(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
      })),
      (u.prototype.writeIntLE = function (t, e, n, r) {
        if (((t = +t), (e >>>= 0), !r)) {
          const r = Math.pow(2, 8 * n - 1);
          N(this, t, e, n, r - 1, -r);
        }
        let o = 0,
          i = 1,
          s = 0;
        for (this[e] = 255 & t; ++o < n && (i *= 256); )
          t < 0 && 0 === s && 0 !== this[e + o - 1] && (s = 1),
            (this[e + o] = (((t / i) | 0) - s) & 255);
        return e + n;
      }),
      (u.prototype.writeIntBE = function (t, e, n, r) {
        if (((t = +t), (e >>>= 0), !r)) {
          const r = Math.pow(2, 8 * n - 1);
          N(this, t, e, n, r - 1, -r);
        }
        let o = n - 1,
          i = 1,
          s = 0;
        for (this[e + o] = 255 & t; --o >= 0 && (i *= 256); )
          t < 0 && 0 === s && 0 !== this[e + o + 1] && (s = 1),
            (this[e + o] = (((t / i) | 0) - s) & 255);
        return e + n;
      }),
      (u.prototype.writeInt8 = function (t, e, n) {
        return (
          (t = +t),
          (e >>>= 0),
          n || N(this, t, e, 1, 127, -128),
          t < 0 && (t = 255 + t + 1),
          (this[e] = 255 & t),
          e + 1
        );
      }),
      (u.prototype.writeInt16LE = function (t, e, n) {
        return (
          (t = +t),
          (e >>>= 0),
          n || N(this, t, e, 2, 32767, -32768),
          (this[e] = 255 & t),
          (this[e + 1] = t >>> 8),
          e + 2
        );
      }),
      (u.prototype.writeInt16BE = function (t, e, n) {
        return (
          (t = +t),
          (e >>>= 0),
          n || N(this, t, e, 2, 32767, -32768),
          (this[e] = t >>> 8),
          (this[e + 1] = 255 & t),
          e + 2
        );
      }),
      (u.prototype.writeInt32LE = function (t, e, n) {
        return (
          (t = +t),
          (e >>>= 0),
          n || N(this, t, e, 4, 2147483647, -2147483648),
          (this[e] = 255 & t),
          (this[e + 1] = t >>> 8),
          (this[e + 2] = t >>> 16),
          (this[e + 3] = t >>> 24),
          e + 4
        );
      }),
      (u.prototype.writeInt32BE = function (t, e, n) {
        return (
          (t = +t),
          (e >>>= 0),
          n || N(this, t, e, 4, 2147483647, -2147483648),
          t < 0 && (t = 4294967295 + t + 1),
          (this[e] = t >>> 24),
          (this[e + 1] = t >>> 16),
          (this[e + 2] = t >>> 8),
          (this[e + 3] = 255 & t),
          e + 4
        );
      }),
      (u.prototype.writeBigInt64LE = et(function (t, e = 0) {
        return P(
          this,
          t,
          e,
          -BigInt("0x8000000000000000"),
          BigInt("0x7fffffffffffffff")
        );
      })),
      (u.prototype.writeBigInt64BE = et(function (t, e = 0) {
        return L(
          this,
          t,
          e,
          -BigInt("0x8000000000000000"),
          BigInt("0x7fffffffffffffff")
        );
      })),
      (u.prototype.writeFloatLE = function (t, e, n) {
        return D(this, t, e, !0, n);
      }),
      (u.prototype.writeFloatBE = function (t, e, n) {
        return D(this, t, e, !1, n);
      }),
      (u.prototype.writeDoubleLE = function (t, e, n) {
        return U(this, t, e, !0, n);
      }),
      (u.prototype.writeDoubleBE = function (t, e, n) {
        return U(this, t, e, !1, n);
      }),
      (u.prototype.copy = function (t, e, n, r) {
        if (!u.isBuffer(t)) throw new TypeError("argument should be a Buffer");
        if (
          (n || (n = 0),
          r || 0 === r || (r = this.length),
          e >= t.length && (e = t.length),
          e || (e = 0),
          r > 0 && r < n && (r = n),
          r === n)
        )
          return 0;
        if (0 === t.length || 0 === this.length) return 0;
        if (e < 0) throw new RangeError("targetStart out of bounds");
        if (n < 0 || n >= this.length)
          throw new RangeError("Index out of range");
        if (r < 0) throw new RangeError("sourceEnd out of bounds");
        r > this.length && (r = this.length),
          t.length - e < r - n && (r = t.length - e + n);
        const o = r - n;
        return (
          this === t && "function" == typeof i.prototype.copyWithin
            ? this.copyWithin(e, n, r)
            : i.prototype.set.call(t, this.subarray(n, r), e),
          o
        );
      }),
      (u.prototype.fill = function (t, e, n, r) {
        if ("string" == typeof t) {
          if (
            ("string" == typeof e
              ? ((r = e), (e = 0), (n = this.length))
              : "string" == typeof n && ((r = n), (n = this.length)),
            void 0 !== r && "string" != typeof r)
          )
            throw new TypeError("encoding must be a string");
          if ("string" == typeof r && !u.isEncoding(r))
            throw new TypeError("Unknown encoding: " + r);
          if (1 === t.length) {
            const e = t.charCodeAt(0);
            (("utf8" === r && e < 128) || "latin1" === r) && (t = e);
          }
        } else
          "number" == typeof t
            ? (t &= 255)
            : "boolean" == typeof t && (t = Number(t));
        if (e < 0 || this.length < e || this.length < n)
          throw new RangeError("Out of range index");
        if (n <= e) return this;
        let o;
        if (
          ((e >>>= 0),
          (n = void 0 === n ? this.length : n >>> 0),
          t || (t = 0),
          "number" == typeof t)
        )
          for (o = e; o < n; ++o) this[o] = t;
        else {
          const i = u.isBuffer(t) ? t : u.from(t, r),
            s = i.length;
          if (0 === s)
            throw new TypeError(
              'The value "' + t + '" is invalid for argument "value"'
            );
          for (o = 0; o < n - e; ++o) this[o + e] = i[o % s];
        }
        return this;
      });
    const G = {};
    function W(t, e, n) {
      G[t] = class extends n {
        constructor() {
          super(),
            Object.defineProperty(this, "message", {
              value: e.apply(this, arguments),
              writable: !0,
              configurable: !0,
            }),
            (this.name = `${this.name} [${t}]`),
            this.stack,
            delete this.name;
        }
        get code() {
          return t;
        }
        set code(t) {
          Object.defineProperty(this, "code", {
            configurable: !0,
            enumerable: !0,
            value: t,
            writable: !0,
          });
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      };
    }
    function K(t) {
      let e = "",
        n = t.length;
      const r = "-" === t[0] ? 1 : 0;
      for (; n >= r + 4; n -= 3) e = `_${t.slice(n - 3, n)}${e}`;
      return `${t.slice(0, n)}${e}`;
    }
    function j(t, e, n, r, o, i) {
      if (t > n || t < e) {
        const n = "bigint" == typeof e ? "n" : "";
        let r;
        throw (
          ((r =
            0 === e || e === BigInt(0)
              ? `>= 0${n} and < 2${n} ** ${8 * (i + 1)}${n}`
              : `>= -(2${n} ** ${8 * (i + 1) - 1}${n}) and < 2 ** ${
                  8 * (i + 1) - 1
                }${n}`),
          new G.ERR_OUT_OF_RANGE("value", r, t))
        );
      }
      !(function (t, e, n) {
        H(e, "offset"),
          (void 0 !== t[e] && void 0 !== t[e + n]) || V(e, t.length - (n + 1));
      })(r, o, i);
    }
    function H(t, e) {
      if ("number" != typeof t)
        throw new G.ERR_INVALID_ARG_TYPE(e, "number", t);
    }
    function V(t, e, n) {
      if (Math.floor(t) !== t)
        throw (H(t, n), new G.ERR_OUT_OF_RANGE("offset", "an integer", t));
      if (e < 0) throw new G.ERR_BUFFER_OUT_OF_BOUNDS();
      throw new G.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${e}`, t);
    }
    W(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function (t) {
        return t
          ? `${t} is outside of buffer bounds`
          : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ),
      W(
        "ERR_INVALID_ARG_TYPE",
        function (t, e) {
          return `The "${t}" argument must be of type number. Received type ${typeof e}`;
        },
        TypeError
      ),
      W(
        "ERR_OUT_OF_RANGE",
        function (t, e, n) {
          let r = `The value of "${t}" is out of range.`,
            o = n;
          return (
            Number.isInteger(n) && Math.abs(n) > 2 ** 32
              ? (o = K(String(n)))
              : "bigint" == typeof n &&
                ((o = String(n)),
                (n > BigInt(2) ** BigInt(32) ||
                  n < -(BigInt(2) ** BigInt(32))) &&
                  (o = K(o)),
                (o += "n")),
            (r += ` It must be ${e}. Received ${o}`),
            r
          );
        },
        RangeError
      );
    const F = /[^+/0-9A-Za-z-_]/g;
    function Y(t, e) {
      let n;
      e = e || 1 / 0;
      const r = t.length;
      let o = null;
      const i = [];
      for (let s = 0; s < r; ++s) {
        if (((n = t.charCodeAt(s)), n > 55295 && n < 57344)) {
          if (!o) {
            if (n > 56319) {
              (e -= 3) > -1 && i.push(239, 191, 189);
              continue;
            }
            if (s + 1 === r) {
              (e -= 3) > -1 && i.push(239, 191, 189);
              continue;
            }
            o = n;
            continue;
          }
          if (n < 56320) {
            (e -= 3) > -1 && i.push(239, 191, 189), (o = n);
            continue;
          }
          n = 65536 + (((o - 55296) << 10) | (n - 56320));
        } else o && (e -= 3) > -1 && i.push(239, 191, 189);
        if (((o = null), n < 128)) {
          if ((e -= 1) < 0) break;
          i.push(n);
        } else if (n < 2048) {
          if ((e -= 2) < 0) break;
          i.push((n >> 6) | 192, (63 & n) | 128);
        } else if (n < 65536) {
          if ((e -= 3) < 0) break;
          i.push((n >> 12) | 224, ((n >> 6) & 63) | 128, (63 & n) | 128);
        } else {
          if (!(n < 1114112)) throw new Error("Invalid code point");
          if ((e -= 4) < 0) break;
          i.push(
            (n >> 18) | 240,
            ((n >> 12) & 63) | 128,
            ((n >> 6) & 63) | 128,
            (63 & n) | 128
          );
        }
      }
      return i;
    }
    function J(t) {
      return e.toByteArray(
        (function (t) {
          if ((t = (t = t.split("=")[0]).trim().replace(F, "")).length < 2)
            return "";
          for (; t.length % 4 != 0; ) t += "=";
          return t;
        })(t)
      );
    }
    function X(t, e, n, r) {
      let o;
      for (o = 0; o < r && !(o + n >= e.length || o >= t.length); ++o)
        e[o + n] = t[o];
      return o;
    }
    function $(t, e) {
      return (
        t instanceof e ||
        (null != t &&
          null != t.constructor &&
          null != t.constructor.name &&
          t.constructor.name === e.name)
      );
    }
    function Q(t) {
      return t != t;
    }
    const tt = (function () {
      const t = "0123456789abcdef",
        e = new Array(256);
      for (let n = 0; n < 16; ++n) {
        const r = 16 * n;
        for (let o = 0; o < 16; ++o) e[r + o] = t[n] + t[o];
      }
      return e;
    })();
    function et(t) {
      return "undefined" == typeof BigInt ? nt : t;
    }
    function nt() {
      throw new Error("BigInt not supported");
    }
  })(U);
  const J = U.Buffer,
    X = U.Buffer;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const $ =
    "object" == typeof globalThis && "crypto" in globalThis
      ? globalThis.crypto
      : void 0;
  function Q(t) {
    return (
      t instanceof Uint8Array ||
      (ArrayBuffer.isView(t) && "Uint8Array" === t.constructor.name)
    );
  }
  function tt(t) {
    if (!Number.isSafeInteger(t) || t < 0)
      throw new Error("positive integer expected, got " + t);
  }
  function et(t, ...e) {
    if (!Q(t)) throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(t.length))
      throw new Error(
        "Uint8Array expected of length " + e + ", got length=" + t.length
      );
  }
  function nt(t, e = !0) {
    if (t.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && t.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function rt(t, e) {
    et(t);
    const n = e.outputLen;
    if (t.length < n)
      throw new Error(
        "digestInto() expects output buffer of length at least " + n
      );
  }
  function ot(...t) {
    for (let e = 0; e < t.length; e++) t[e].fill(0);
  }
  function it(t) {
    return new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  function st(t, e) {
    return (t << (32 - e)) | (t >>> e);
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  function at(t) {
    return (
      ((t << 24) & 4278190080) |
      ((t << 8) & 16711680) |
      ((t >>> 8) & 65280) |
      ((t >>> 24) & 255)
    );
  }
  const ct = (() =>
      68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0])()
      ? (t) => t
      : function (t) {
          for (let e = 0; e < t.length; e++) t[e] = at(t[e]);
          return t;
        },
    ut = (() =>
      "function" == typeof Uint8Array.from([]).toHex &&
      "function" == typeof Uint8Array.fromHex)(),
    lt = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
  function ht(t) {
    if ((et(t), ut)) return t.toHex();
    let e = "";
    for (let n = 0; n < t.length; n++) e += lt[t[n]];
    return e;
  }
  const dt = 48,
    ft = 57,
    pt = 65,
    mt = 70,
    yt = 97,
    gt = 102;
  function wt(t) {
    return t >= dt && t <= ft
      ? t - dt
      : t >= pt && t <= mt
      ? t - (pt - 10)
      : t >= yt && t <= gt
      ? t - (yt - 10)
      : void 0;
  }
  function bt(t) {
    if ("string" != typeof t)
      throw new Error("hex string expected, got " + typeof t);
    if (ut) return Uint8Array.fromHex(t);
    const e = t.length,
      n = e / 2;
    if (e % 2)
      throw new Error("hex string expected, got unpadded hex of length " + e);
    const r = new Uint8Array(n);
    for (let o = 0, i = 0; o < n; o++, i += 2) {
      const e = wt(t.charCodeAt(i)),
        n = wt(t.charCodeAt(i + 1));
      if (void 0 === e || void 0 === n) {
        const e = t[i] + t[i + 1];
        throw new Error(
          'hex string expected, got non-hex character "' + e + '" at index ' + i
        );
      }
      r[o] = 16 * e + n;
    }
    return r;
  }
  function vt(t) {
    return (
      "string" == typeof t &&
        (t = (function (t) {
          if ("string" != typeof t) throw new Error("string expected");
          return new Uint8Array(new TextEncoder().encode(t));
        })(t)),
      et(t),
      t
    );
  }
  function _t(...t) {
    let e = 0;
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      et(n), (e += n.length);
    }
    const n = new Uint8Array(e);
    for (let r = 0, o = 0; r < t.length; r++) {
      const e = t[r];
      n.set(e, o), (o += e.length);
    }
    return n;
  }
  class kt {}
  function At(t) {
    const e = (e) => t().update(vt(e)).digest(),
      n = t();
    return (
      (e.outputLen = n.outputLen),
      (e.blockLen = n.blockLen),
      (e.create = () => t()),
      e
    );
  }
  function Et(t = 32) {
    if ($ && "function" == typeof $.getRandomValues)
      return $.getRandomValues(new Uint8Array(t));
    if ($ && "function" == typeof $.randomBytes)
      return Uint8Array.from($.randomBytes(t));
    throw new Error("crypto.getRandomValues must be defined");
  }
  function It(t, e, n) {
    return (t & e) ^ (~t & n);
  }
  function Ct(t, e, n) {
    return (t & e) ^ (t & n) ^ (e & n);
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  class St extends kt {
    constructor(t, e, n, r) {
      super(),
        (this.finished = !1),
        (this.length = 0),
        (this.pos = 0),
        (this.destroyed = !1),
        (this.blockLen = t),
        (this.outputLen = e),
        (this.padOffset = n),
        (this.isLE = r),
        (this.buffer = new Uint8Array(t)),
        (this.view = it(this.buffer));
    }
    update(t) {
      nt(this), et((t = vt(t)));
      const { view: e, buffer: n, blockLen: r } = this,
        o = t.length;
      for (let i = 0; i < o; ) {
        const s = Math.min(r - this.pos, o - i);
        if (s === r) {
          const e = it(t);
          for (; r <= o - i; i += r) this.process(e, i);
          continue;
        }
        n.set(t.subarray(i, i + s), this.pos),
          (this.pos += s),
          (i += s),
          this.pos === r && (this.process(e, 0), (this.pos = 0));
      }
      return (this.length += t.length), this.roundClean(), this;
    }
    digestInto(t) {
      nt(this), rt(t, this), (this.finished = !0);
      const { buffer: e, view: n, blockLen: r, isLE: o } = this;
      let { pos: i } = this;
      (e[i++] = 128),
        ot(this.buffer.subarray(i)),
        this.padOffset > r - i && (this.process(n, 0), (i = 0));
      for (let l = i; l < r; l++) e[l] = 0;
      !(function (t, e, n, r) {
        if ("function" == typeof t.setBigUint64) return t.setBigUint64(e, n, r);
        const o = BigInt(32),
          i = BigInt(4294967295),
          s = Number((n >> o) & i),
          a = Number(n & i),
          c = r ? 4 : 0,
          u = r ? 0 : 4;
        t.setUint32(e + c, s, r), t.setUint32(e + u, a, r);
      })(n, r - 8, BigInt(8 * this.length), o),
        this.process(n, 0);
      const s = it(t),
        a = this.outputLen;
      if (a % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
      const c = a / 4,
        u = this.get();
      if (c > u.length) throw new Error("_sha2: outputLen bigger than state");
      for (let l = 0; l < c; l++) s.setUint32(4 * l, u[l], o);
    }
    digest() {
      const { buffer: t, outputLen: e } = this;
      this.digestInto(t);
      const n = t.slice(0, e);
      return this.destroy(), n;
    }
    _cloneInto(t) {
      t || (t = new this.constructor()), t.set(...this.get());
      const {
        blockLen: e,
        buffer: n,
        length: r,
        finished: o,
        destroyed: i,
        pos: s,
      } = this;
      return (
        (t.destroyed = i),
        (t.finished = o),
        (t.length = r),
        (t.pos = s),
        r % e && t.buffer.set(n),
        t
      );
    }
    clone() {
      return this._cloneInto();
    }
  }
  const Bt = Uint32Array.from([
      1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
      528734635, 1541459225,
    ]),
    xt = Uint32Array.from([
      1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723,
      2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199,
      528734635, 4215389547, 1541459225, 327033209,
    ]);
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Tt = BigInt(2 ** 32 - 1),
    Rt = BigInt(32);
  function Ot(t, e = !1) {
    return e
      ? { h: Number(t & Tt), l: Number((t >> Rt) & Tt) }
      : { h: 0 | Number((t >> Rt) & Tt), l: 0 | Number(t & Tt) };
  }
  function Mt(t, e = !1) {
    const n = t.length;
    let r = new Uint32Array(n),
      o = new Uint32Array(n);
    for (let i = 0; i < n; i++) {
      const { h: n, l: s } = Ot(t[i], e);
      [r[i], o[i]] = [n, s];
    }
    return [r, o];
  }
  const Nt = (t, e, n) => t >>> n,
    Pt = (t, e, n) => (t << (32 - n)) | (e >>> n),
    Lt = (t, e, n) => (t >>> n) | (e << (32 - n)),
    zt = (t, e, n) => (t << (32 - n)) | (e >>> n),
    Dt = (t, e, n) => (t << (64 - n)) | (e >>> (n - 32)),
    Ut = (t, e, n) => (t >>> (n - 32)) | (e << (64 - n));
  function qt(t, e, n, r) {
    const o = (e >>> 0) + (r >>> 0);
    return { h: (t + n + ((o / 2 ** 32) | 0)) | 0, l: 0 | o };
  }
  const Gt = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0),
    Wt = (t, e, n, r) => (e + n + r + ((t / 2 ** 32) | 0)) | 0,
    Kt = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0),
    jt = (t, e, n, r, o) => (e + n + r + o + ((t / 2 ** 32) | 0)) | 0,
    Ht = (t, e, n, r, o) =>
      (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (o >>> 0),
    Vt = (t, e, n, r, o, i) => (e + n + r + o + i + ((t / 2 ** 32) | 0)) | 0;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Ft = Uint32Array.from([
      1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
      2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
      1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
      264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
      2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
      113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
      1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
      3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
      430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
      1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
      2428436474, 2756734187, 3204031479, 3329325298,
    ]),
    Yt = new Uint32Array(64);
  class Zt extends St {
    constructor(t = 32) {
      super(64, t, 8, !1),
        (this.A = 0 | Bt[0]),
        (this.B = 0 | Bt[1]),
        (this.C = 0 | Bt[2]),
        (this.D = 0 | Bt[3]),
        (this.E = 0 | Bt[4]),
        (this.F = 0 | Bt[5]),
        (this.G = 0 | Bt[6]),
        (this.H = 0 | Bt[7]);
    }
    get() {
      const { A: t, B: e, C: n, D: r, E: o, F: i, G: s, H: a } = this;
      return [t, e, n, r, o, i, s, a];
    }
    set(t, e, n, r, o, i, s, a) {
      (this.A = 0 | t),
        (this.B = 0 | e),
        (this.C = 0 | n),
        (this.D = 0 | r),
        (this.E = 0 | o),
        (this.F = 0 | i),
        (this.G = 0 | s),
        (this.H = 0 | a);
    }
    process(t, e) {
      for (let l = 0; l < 16; l++, e += 4) Yt[l] = t.getUint32(e, !1);
      for (let l = 16; l < 64; l++) {
        const t = Yt[l - 15],
          e = Yt[l - 2],
          n = st(t, 7) ^ st(t, 18) ^ (t >>> 3),
          r = st(e, 17) ^ st(e, 19) ^ (e >>> 10);
        Yt[l] = (r + Yt[l - 7] + n + Yt[l - 16]) | 0;
      }
      let { A: n, B: r, C: o, D: i, E: s, F: a, G: c, H: u } = this;
      for (let l = 0; l < 64; l++) {
        const t =
            (u +
              (st(s, 6) ^ st(s, 11) ^ st(s, 25)) +
              It(s, a, c) +
              Ft[l] +
              Yt[l]) |
            0,
          e = ((st(n, 2) ^ st(n, 13) ^ st(n, 22)) + Ct(n, r, o)) | 0;
        (u = c),
          (c = a),
          (a = s),
          (s = (i + t) | 0),
          (i = o),
          (o = r),
          (r = n),
          (n = (t + e) | 0);
      }
      (n = (n + this.A) | 0),
        (r = (r + this.B) | 0),
        (o = (o + this.C) | 0),
        (i = (i + this.D) | 0),
        (s = (s + this.E) | 0),
        (a = (a + this.F) | 0),
        (c = (c + this.G) | 0),
        (u = (u + this.H) | 0),
        this.set(n, r, o, i, s, a, c, u);
    }
    roundClean() {
      ot(Yt);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), ot(this.buffer);
    }
  }
  const Jt = (() =>
      Mt(
        [
          "0x428a2f98d728ae22",
          "0x7137449123ef65cd",
          "0xb5c0fbcfec4d3b2f",
          "0xe9b5dba58189dbbc",
          "0x3956c25bf348b538",
          "0x59f111f1b605d019",
          "0x923f82a4af194f9b",
          "0xab1c5ed5da6d8118",
          "0xd807aa98a3030242",
          "0x12835b0145706fbe",
          "0x243185be4ee4b28c",
          "0x550c7dc3d5ffb4e2",
          "0x72be5d74f27b896f",
          "0x80deb1fe3b1696b1",
          "0x9bdc06a725c71235",
          "0xc19bf174cf692694",
          "0xe49b69c19ef14ad2",
          "0xefbe4786384f25e3",
          "0x0fc19dc68b8cd5b5",
          "0x240ca1cc77ac9c65",
          "0x2de92c6f592b0275",
          "0x4a7484aa6ea6e483",
          "0x5cb0a9dcbd41fbd4",
          "0x76f988da831153b5",
          "0x983e5152ee66dfab",
          "0xa831c66d2db43210",
          "0xb00327c898fb213f",
          "0xbf597fc7beef0ee4",
          "0xc6e00bf33da88fc2",
          "0xd5a79147930aa725",
          "0x06ca6351e003826f",
          "0x142929670a0e6e70",
          "0x27b70a8546d22ffc",
          "0x2e1b21385c26c926",
          "0x4d2c6dfc5ac42aed",
          "0x53380d139d95b3df",
          "0x650a73548baf63de",
          "0x766a0abb3c77b2a8",
          "0x81c2c92e47edaee6",
          "0x92722c851482353b",
          "0xa2bfe8a14cf10364",
          "0xa81a664bbc423001",
          "0xc24b8b70d0f89791",
          "0xc76c51a30654be30",
          "0xd192e819d6ef5218",
          "0xd69906245565a910",
          "0xf40e35855771202a",
          "0x106aa07032bbd1b8",
          "0x19a4c116b8d2d0c8",
          "0x1e376c085141ab53",
          "0x2748774cdf8eeb99",
          "0x34b0bcb5e19b48a8",
          "0x391c0cb3c5c95a63",
          "0x4ed8aa4ae3418acb",
          "0x5b9cca4f7763e373",
          "0x682e6ff3d6b2b8a3",
          "0x748f82ee5defb2fc",
          "0x78a5636f43172f60",
          "0x84c87814a1f0ab72",
          "0x8cc702081a6439ec",
          "0x90befffa23631e28",
          "0xa4506cebde82bde9",
          "0xbef9a3f7b2c67915",
          "0xc67178f2e372532b",
          "0xca273eceea26619c",
          "0xd186b8c721c0c207",
          "0xeada7dd6cde0eb1e",
          "0xf57d4f7fee6ed178",
          "0x06f067aa72176fba",
          "0x0a637dc5a2c898a6",
          "0x113f9804bef90dae",
          "0x1b710b35131c471b",
          "0x28db77f523047d84",
          "0x32caab7b40c72493",
          "0x3c9ebe0a15c9bebc",
          "0x431d67c49c100d4c",
          "0x4cc5d4becb3e42b6",
          "0x597f299cfc657e2a",
          "0x5fcb6fab3ad6faec",
          "0x6c44198c4a475817",
        ].map((t) => BigInt(t))
      ))(),
    Xt = (() => Jt[0])(),
    $t = (() => Jt[1])(),
    Qt = new Uint32Array(80),
    te = new Uint32Array(80);
  class ee extends St {
    constructor(t = 64) {
      super(128, t, 16, !1),
        (this.Ah = 0 | xt[0]),
        (this.Al = 0 | xt[1]),
        (this.Bh = 0 | xt[2]),
        (this.Bl = 0 | xt[3]),
        (this.Ch = 0 | xt[4]),
        (this.Cl = 0 | xt[5]),
        (this.Dh = 0 | xt[6]),
        (this.Dl = 0 | xt[7]),
        (this.Eh = 0 | xt[8]),
        (this.El = 0 | xt[9]),
        (this.Fh = 0 | xt[10]),
        (this.Fl = 0 | xt[11]),
        (this.Gh = 0 | xt[12]),
        (this.Gl = 0 | xt[13]),
        (this.Hh = 0 | xt[14]),
        (this.Hl = 0 | xt[15]);
    }
    get() {
      const {
        Ah: t,
        Al: e,
        Bh: n,
        Bl: r,
        Ch: o,
        Cl: i,
        Dh: s,
        Dl: a,
        Eh: c,
        El: u,
        Fh: l,
        Fl: h,
        Gh: d,
        Gl: f,
        Hh: p,
        Hl: m,
      } = this;
      return [t, e, n, r, o, i, s, a, c, u, l, h, d, f, p, m];
    }
    set(t, e, n, r, o, i, s, a, c, u, l, h, d, f, p, m) {
      (this.Ah = 0 | t),
        (this.Al = 0 | e),
        (this.Bh = 0 | n),
        (this.Bl = 0 | r),
        (this.Ch = 0 | o),
        (this.Cl = 0 | i),
        (this.Dh = 0 | s),
        (this.Dl = 0 | a),
        (this.Eh = 0 | c),
        (this.El = 0 | u),
        (this.Fh = 0 | l),
        (this.Fl = 0 | h),
        (this.Gh = 0 | d),
        (this.Gl = 0 | f),
        (this.Hh = 0 | p),
        (this.Hl = 0 | m);
    }
    process(t, e) {
      for (let w = 0; w < 16; w++, e += 4)
        (Qt[w] = t.getUint32(e)), (te[w] = t.getUint32((e += 4)));
      for (let w = 16; w < 80; w++) {
        const t = 0 | Qt[w - 15],
          e = 0 | te[w - 15],
          n = Lt(t, e, 1) ^ Lt(t, e, 8) ^ Nt(t, 0, 7),
          r = zt(t, e, 1) ^ zt(t, e, 8) ^ Pt(t, e, 7),
          o = 0 | Qt[w - 2],
          i = 0 | te[w - 2],
          s = Lt(o, i, 19) ^ Dt(o, i, 61) ^ Nt(o, 0, 6),
          a = zt(o, i, 19) ^ Ut(o, i, 61) ^ Pt(o, i, 6),
          c = Kt(r, a, te[w - 7], te[w - 16]),
          u = jt(c, n, s, Qt[w - 7], Qt[w - 16]);
        (Qt[w] = 0 | u), (te[w] = 0 | c);
      }
      let {
        Ah: n,
        Al: r,
        Bh: o,
        Bl: i,
        Ch: s,
        Cl: a,
        Dh: c,
        Dl: u,
        Eh: l,
        El: h,
        Fh: d,
        Fl: f,
        Gh: p,
        Gl: m,
        Hh: y,
        Hl: g,
      } = this;
      for (let w = 0; w < 80; w++) {
        const t = Lt(l, h, 14) ^ Lt(l, h, 18) ^ Dt(l, h, 41),
          e = zt(l, h, 14) ^ zt(l, h, 18) ^ Ut(l, h, 41),
          b = (l & d) ^ (~l & p),
          v = Ht(g, e, (h & f) ^ (~h & m), $t[w], te[w]),
          _ = Vt(v, y, t, b, Xt[w], Qt[w]),
          k = 0 | v,
          A = Lt(n, r, 28) ^ Dt(n, r, 34) ^ Dt(n, r, 39),
          E = zt(n, r, 28) ^ Ut(n, r, 34) ^ Ut(n, r, 39),
          I = (n & o) ^ (n & s) ^ (o & s),
          C = (r & i) ^ (r & a) ^ (i & a);
        (y = 0 | p),
          (g = 0 | m),
          (p = 0 | d),
          (m = 0 | f),
          (d = 0 | l),
          (f = 0 | h),
          ({ h: l, l: h } = qt(0 | c, 0 | u, 0 | _, 0 | k)),
          (c = 0 | s),
          (u = 0 | a),
          (s = 0 | o),
          (a = 0 | i),
          (o = 0 | n),
          (i = 0 | r);
        const S = Gt(k, E, C);
        (n = Wt(S, _, A, I)), (r = 0 | S);
      }
      ({ h: n, l: r } = qt(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)),
        ({ h: o, l: i } = qt(0 | this.Bh, 0 | this.Bl, 0 | o, 0 | i)),
        ({ h: s, l: a } = qt(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a)),
        ({ h: c, l: u } = qt(0 | this.Dh, 0 | this.Dl, 0 | c, 0 | u)),
        ({ h: l, l: h } = qt(0 | this.Eh, 0 | this.El, 0 | l, 0 | h)),
        ({ h: d, l: f } = qt(0 | this.Fh, 0 | this.Fl, 0 | d, 0 | f)),
        ({ h: p, l: m } = qt(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | m)),
        ({ h: y, l: g } = qt(0 | this.Hh, 0 | this.Hl, 0 | y, 0 | g)),
        this.set(n, r, o, i, s, a, c, u, l, h, d, f, p, m, y, g);
    }
    roundClean() {
      ot(Qt, te);
    }
    destroy() {
      ot(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
  const ne = At(() => new Zt()),
    re = At(() => new ee());
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const oe = BigInt(0),
    ie = BigInt(1);
  function se(t, e) {
    if ("boolean" != typeof e)
      throw new Error(t + " boolean expected, got " + e);
  }
  function ae(t) {
    const e = t.toString(16);
    return 1 & e.length ? "0" + e : e;
  }
  function ce(t) {
    if ("string" != typeof t)
      throw new Error("hex string expected, got " + typeof t);
    return "" === t ? oe : BigInt("0x" + t);
  }
  function ue(t) {
    return ce(ht(t));
  }
  function le(t) {
    return et(t), ce(ht(Uint8Array.from(t).reverse()));
  }
  function he(t, e) {
    return bt(t.toString(16).padStart(2 * e, "0"));
  }
  function de(t, e) {
    return he(t, e).reverse();
  }
  function fe(t, e, n) {
    let r;
    if ("string" == typeof e)
      try {
        r = bt(e);
      } catch (i) {
        throw new Error(t + " must be hex string or Uint8Array, cause: " + i);
      }
    else {
      if (!Q(e)) throw new Error(t + " must be hex string or Uint8Array");
      r = Uint8Array.from(e);
    }
    const o = r.length;
    if ("number" == typeof n && o !== n)
      throw new Error(t + " of length " + n + " expected, got " + o);
    return r;
  }
  const pe = (t) => "bigint" == typeof t && oe <= t;
  function me(t, e, n, r) {
    if (
      !(function (t, e, n) {
        return pe(t) && pe(e) && pe(n) && e <= t && t < n;
      })(e, n, r)
    )
      throw new Error(
        "expected valid " + t + ": " + n + " <= n < " + r + ", got " + e
      );
  }
  const ye = (t) => (ie << BigInt(t)) - ie;
  function ge(t, e, n = {}) {
    if (!t || "object" != typeof t)
      throw new Error("expected valid options object");
    function r(e, n, r) {
      const o = t[e];
      if (r && void 0 === o) return;
      const i = typeof o;
      if (i !== n || null === o)
        throw new Error(`param "${e}" is invalid: expected ${n}, got ${i}`);
    }
    Object.entries(e).forEach(([t, e]) => r(t, e, !1)),
      Object.entries(n).forEach(([t, e]) => r(t, e, !0));
  }
  function we(t) {
    const e = new WeakMap();
    return (n, ...r) => {
      const o = e.get(n);
      if (void 0 !== o) return o;
      const i = t(n, ...r);
      return e.set(n, i), i;
    };
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const be = BigInt(0),
    ve = BigInt(1),
    _e = BigInt(2),
    ke = BigInt(3),
    Ae = BigInt(4),
    Ee = BigInt(5),
    Ie = BigInt(8);
  function Ce(t, e) {
    const n = t % e;
    return n >= be ? n : e + n;
  }
  function Se(t, e, n) {
    let r = t;
    for (; e-- > be; ) (r *= r), (r %= n);
    return r;
  }
  function Be(t, e) {
    if (t === be) throw new Error("invert: expected non-zero number");
    if (e <= be) throw new Error("invert: expected positive modulus, got " + e);
    let n = Ce(t, e),
      r = e,
      o = be,
      i = ve;
    for (; n !== be; ) {
      const t = r % n,
        e = o - i * (r / n);
      (r = n), (n = t), (o = i), (i = e);
    }
    if (r !== ve) throw new Error("invert: does not exist");
    return Ce(o, e);
  }
  function xe(t, e) {
    const n = (t.ORDER + ve) / Ae,
      r = t.pow(e, n);
    if (!t.eql(t.sqr(r), e)) throw new Error("Cannot find square root");
    return r;
  }
  function Te(t, e) {
    const n = (t.ORDER - Ee) / Ie,
      r = t.mul(e, _e),
      o = t.pow(r, n),
      i = t.mul(e, o),
      s = t.mul(t.mul(i, _e), o),
      a = t.mul(i, t.sub(s, t.ONE));
    if (!t.eql(t.sqr(a), e)) throw new Error("Cannot find square root");
    return a;
  }
  function Re(t) {
    return t % Ae === ke
      ? xe
      : t % Ie === Ee
      ? Te
      : (function (t) {
          if (t < BigInt(3))
            throw new Error("sqrt is not defined for small field");
          let e = t - ve,
            n = 0;
          for (; e % _e === be; ) (e /= _e), n++;
          let r = _e;
          const o = Pe(t);
          for (; 1 === Ne(o, r); )
            if (r++ > 1e3)
              throw new Error("Cannot find square root: probably non-prime P");
          if (1 === n) return xe;
          let i = o.pow(r, e);
          const s = (e + ve) / _e;
          return function (t, r) {
            if (t.is0(r)) return r;
            if (1 !== Ne(t, r)) throw new Error("Cannot find square root");
            let o = n,
              a = t.mul(t.ONE, i),
              c = t.pow(r, e),
              u = t.pow(r, s);
            for (; !t.eql(c, t.ONE); ) {
              if (t.is0(c)) return t.ZERO;
              let e = 1,
                n = t.sqr(c);
              for (; !t.eql(n, t.ONE); )
                if ((e++, (n = t.sqr(n)), e === o))
                  throw new Error("Cannot find square root");
              const r = ve << BigInt(o - e - 1),
                i = t.pow(a, r);
              (o = e), (a = t.sqr(i)), (c = t.mul(c, a)), (u = t.mul(u, i));
            }
            return u;
          };
        })(t);
  }
  const Oe = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN",
  ];
  function Me(t, e, n = !1) {
    const r = new Array(e.length).fill(n ? t.ZERO : void 0),
      o = e.reduce(
        (e, n, o) => (t.is0(n) ? e : ((r[o] = e), t.mul(e, n))),
        t.ONE
      ),
      i = t.inv(o);
    return (
      e.reduceRight(
        (e, n, o) => (t.is0(n) ? e : ((r[o] = t.mul(e, r[o])), t.mul(e, n))),
        i
      ),
      r
    );
  }
  function Ne(t, e) {
    const n = (t.ORDER - ve) / _e,
      r = t.pow(e, n),
      o = t.eql(r, t.ONE),
      i = t.eql(r, t.ZERO),
      s = t.eql(r, t.neg(t.ONE));
    if (!o && !i && !s) throw new Error("invalid Legendre symbol result");
    return o ? 1 : i ? 0 : -1;
  }
  function Pe(t, e, n = !1, r = {}) {
    if (t <= be) throw new Error("invalid field: expected ORDER > 0, got " + t);
    let o, i;
    if ("object" == typeof e && null != e) {
      if (r.sqrt || n) throw new Error("cannot specify opts in two arguments");
      const t = e;
      t.BITS && (o = t.BITS),
        t.sqrt && (i = t.sqrt),
        "boolean" == typeof t.isLE && (n = t.isLE);
    } else "number" == typeof e && (o = e), r.sqrt && (i = r.sqrt);
    const { nBitLength: s, nByteLength: a } = (function (t, e) {
      void 0 !== e && tt(e);
      const n = void 0 !== e ? e : t.toString(2).length;
      return { nBitLength: n, nByteLength: Math.ceil(n / 8) };
    })(t, o);
    if (a > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let c;
    const u = Object.freeze({
      ORDER: t,
      isLE: n,
      BITS: s,
      BYTES: a,
      MASK: ye(s),
      ZERO: be,
      ONE: ve,
      create: (e) => Ce(e, t),
      isValid: (e) => {
        if ("bigint" != typeof e)
          throw new Error(
            "invalid field element: expected bigint, got " + typeof e
          );
        return be <= e && e < t;
      },
      is0: (t) => t === be,
      isValidNot0: (t) => !u.is0(t) && u.isValid(t),
      isOdd: (t) => (t & ve) === ve,
      neg: (e) => Ce(-e, t),
      eql: (t, e) => t === e,
      sqr: (e) => Ce(e * e, t),
      add: (e, n) => Ce(e + n, t),
      sub: (e, n) => Ce(e - n, t),
      mul: (e, n) => Ce(e * n, t),
      pow: (t, e) =>
        (function (t, e, n) {
          if (n < be)
            throw new Error("invalid exponent, negatives unsupported");
          if (n === be) return t.ONE;
          if (n === ve) return e;
          let r = t.ONE,
            o = e;
          for (; n > be; )
            n & ve && (r = t.mul(r, o)), (o = t.sqr(o)), (n >>= ve);
          return r;
        })(u, t, e),
      div: (e, n) => Ce(e * Be(n, t), t),
      sqrN: (t) => t * t,
      addN: (t, e) => t + e,
      subN: (t, e) => t - e,
      mulN: (t, e) => t * e,
      inv: (e) => Be(e, t),
      sqrt: i || ((e) => (c || (c = Re(t)), c(u, e))),
      toBytes: (t) => (n ? de(t, a) : he(t, a)),
      fromBytes: (t) => {
        if (t.length !== a)
          throw new Error(
            "Field.fromBytes: expected " + a + " bytes, got " + t.length
          );
        return n ? le(t) : ue(t);
      },
      invertBatch: (t) => Me(u, t),
      cmov: (t, e, n) => (n ? e : t),
    });
    return Object.freeze(u);
  }
  function Le(t) {
    if ("bigint" != typeof t) throw new Error("field order must be bigint");
    const e = t.toString(2).length;
    return Math.ceil(e / 8);
  }
  function ze(t) {
    const e = Le(t);
    return e + Math.ceil(e / 2);
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const De = BigInt(0),
    Ue = BigInt(1);
  function qe(t, e) {
    const n = e.negate();
    return t ? n : e;
  }
  function Ge(t, e, n) {
    const r = "pz" === e ? (t) => t.pz : (t) => t.ez,
      o = Me(t.Fp, n.map(r));
    return n.map((t, e) => t.toAffine(o[e])).map(t.fromAffine);
  }
  function We(t, e) {
    if (!Number.isSafeInteger(t) || t <= 0 || t > e)
      throw new Error(
        "invalid window size, expected [1.." + e + "], got W=" + t
      );
  }
  function Ke(t, e) {
    We(t, e);
    const n = 2 ** t;
    return {
      windows: Math.ceil(e / t) + 1,
      windowSize: 2 ** (t - 1),
      mask: ye(t),
      maxNumber: n,
      shiftBy: BigInt(t),
    };
  }
  function je(t, e, n) {
    const { windowSize: r, mask: o, maxNumber: i, shiftBy: s } = n;
    let a = Number(t & o),
      c = t >> s;
    a > r && ((a -= i), (c += Ue));
    const u = e * r;
    return {
      nextN: c,
      offset: u + Math.abs(a) - 1,
      isZero: 0 === a,
      isNeg: a < 0,
      isNegF: e % 2 != 0,
      offsetF: u,
    };
  }
  const He = new WeakMap(),
    Ve = new WeakMap();
  function Fe(t) {
    return Ve.get(t) || 1;
  }
  function Ye(t) {
    if (t !== De) throw new Error("invalid wNAF");
  }
  function Ze(t, e) {
    return {
      constTimeNegate: qe,
      hasPrecomputes: (t) => 1 !== Fe(t),
      unsafeLadder(e, n, r = t.ZERO) {
        let o = e;
        for (; n > De; ) n & Ue && (r = r.add(o)), (o = o.double()), (n >>= Ue);
        return r;
      },
      precomputeWindow(t, n) {
        const { windows: r, windowSize: o } = Ke(n, e),
          i = [];
        let s = t,
          a = s;
        for (let e = 0; e < r; e++) {
          (a = s), i.push(a);
          for (let t = 1; t < o; t++) (a = a.add(s)), i.push(a);
          s = a.double();
        }
        return i;
      },
      wNAF(n, r, o) {
        let i = t.ZERO,
          s = t.BASE;
        const a = Ke(n, e);
        for (let t = 0; t < a.windows; t++) {
          const {
            nextN: e,
            offset: n,
            isZero: c,
            isNeg: u,
            isNegF: l,
            offsetF: h,
          } = je(o, t, a);
          (o = e), c ? (s = s.add(qe(l, r[h]))) : (i = i.add(qe(u, r[n])));
        }
        return Ye(o), { p: i, f: s };
      },
      wNAFUnsafe(n, r, o, i = t.ZERO) {
        const s = Ke(n, e);
        for (let t = 0; t < s.windows && o !== De; t++) {
          const { nextN: e, offset: n, isZero: a, isNeg: c } = je(o, t, s);
          if (((o = e), !a)) {
            const t = r[n];
            i = i.add(c ? t.negate() : t);
          }
        }
        return Ye(o), i;
      },
      getPrecomputes(t, e, n) {
        let r = He.get(e);
        return (
          r ||
            ((r = this.precomputeWindow(e, t)),
            1 !== t && ("function" == typeof n && (r = n(r)), He.set(e, r))),
          r
        );
      },
      wNAFCached(t, e, n) {
        const r = Fe(t);
        return this.wNAF(r, this.getPrecomputes(r, t, n), e);
      },
      wNAFCachedUnsafe(t, e, n, r) {
        const o = Fe(t);
        return 1 === o
          ? this.unsafeLadder(t, e, r)
          : this.wNAFUnsafe(o, this.getPrecomputes(o, t, n), e, r);
      },
      setWindowSize(t, n) {
        We(n, e), Ve.set(t, n), He.delete(t);
      },
    };
  }
  function Je(t, e, n, r) {
    !(function (t, e) {
      if (!Array.isArray(t)) throw new Error("array expected");
      t.forEach((t, n) => {
        if (!(t instanceof e)) throw new Error("invalid point at index " + n);
      });
    })(n, t),
      (function (t, e) {
        if (!Array.isArray(t)) throw new Error("array of scalars expected");
        t.forEach((t, n) => {
          if (!e.isValid(t)) throw new Error("invalid scalar at index " + n);
        });
      })(r, e);
    const o = n.length,
      i = r.length;
    if (o !== i)
      throw new Error("arrays of points and scalars must have equal length");
    const s = t.ZERO,
      a = (function (t) {
        let e;
        for (e = 0; t > oe; t >>= ie, e += 1);
        return e;
      })(BigInt(o));
    let c = 1;
    a > 12 ? (c = a - 3) : a > 4 ? (c = a - 2) : a > 0 && (c = 2);
    const u = ye(c),
      l = new Array(Number(u) + 1).fill(s);
    let h = s;
    for (let d = Math.floor((e.BITS - 1) / c) * c; d >= 0; d -= c) {
      l.fill(s);
      for (let e = 0; e < i; e++) {
        const t = r[e],
          o = Number((t >> BigInt(d)) & u);
        l[o] = l[o].add(n[e]);
      }
      let t = s;
      for (let e = l.length - 1, n = s; e > 0; e--)
        (n = n.add(l[e])), (t = t.add(n));
      if (((h = h.add(t)), 0 !== d)) for (let e = 0; e < c; e++) h = h.double();
    }
    return h;
  }
  function Xe(t, e) {
    if (e) {
      if (e.ORDER !== t)
        throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
      return (
        !(function (t) {
          return (
            ge(
              t,
              Oe.reduce((t, e) => ((t[e] = "function"), t), {
                ORDER: "bigint",
                MASK: "bigint",
                BYTES: "number",
                BITS: "number",
              })
            ),
            t
          );
        })(e),
        e
      );
    }
    return Pe(t);
  }
  function $e(t, e, n = {}) {
    if (!e || "object" != typeof e)
      throw new Error(`expected valid ${t} CURVE object`);
    for (const s of ["p", "n", "h"]) {
      const t = e[s];
      if (!("bigint" == typeof t && t > De))
        throw new Error(`CURVE.${s} must be positive bigint`);
    }
    const r = Xe(e.p, n.Fp),
      o = Xe(e.n, n.Fn),
      i = ["Gx", "Gy", "a", "weierstrass" === t ? "b" : "d"];
    for (const s of i)
      if (!r.isValid(e[s]))
        throw new Error(`CURVE.${s} must be valid field element of CURVE.Fp`);
    return { Fp: r, Fn: o };
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Qe = BigInt(0),
    tn = BigInt(1),
    en = BigInt(2),
    nn = BigInt(8),
    rn = { zip215: !0 };
  function on(t, e) {
    ge(
      e,
      { hash: "function" },
      {
        adjustScalarBytes: "function",
        randomBytes: "function",
        domain: "function",
        prehash: "function",
        mapToCurve: "function",
      }
    );
    const { prehash: n, hash: r } = e,
      { BASE: o, Fp: i, Fn: s } = t,
      a = s.ORDER,
      c = e.randomBytes || Et,
      u = e.adjustScalarBytes || ((t) => t),
      l =
        e.domain ||
        ((t, e, n) => {
          if ((se("phflag", n), e.length || n))
            throw new Error("Contexts/pre-hash are not supported");
          return t;
        });
    function h(t) {
      return s.create(t);
    }
    function d(t) {
      return h(le(t));
    }
    function f(t) {
      const {
          head: e,
          prefix: n,
          scalar: s,
        } = (function (t) {
          const e = i.BYTES;
          t = fe("private key", t, e);
          const n = fe("hashed private key", r(t), 2 * e),
            o = u(n.slice(0, e));
          return { head: o, prefix: n.slice(e, 2 * e), scalar: d(o) };
        })(t),
        a = o.multiply(s),
        c = a.toBytes();
      return { head: e, prefix: n, scalar: s, point: a, pointBytes: c };
    }
    function p(t = Uint8Array.of(), ...e) {
      const o = _t(...e);
      return d(r(l(o, fe("context", t), !!n)));
    }
    const m = rn;
    o.precompute(8);
    return {
      getPublicKey: function (t) {
        return f(t).pointBytes;
      },
      sign: function (t, e, r = {}) {
        (t = fe("message", t)), n && (t = n(t));
        const { prefix: s, scalar: c, pointBytes: u } = f(e),
          l = p(r.context, s, t),
          d = o.multiply(l).toBytes(),
          m = h(l + p(r.context, d, u, t) * c);
        me("signature.s", m, Qe, a);
        const y = i.BYTES;
        return fe("result", _t(d, de(m, y)), 2 * y);
      },
      verify: function (e, r, s, a = m) {
        const { context: c, zip215: u } = a,
          l = i.BYTES;
        (e = fe("signature", e, 2 * l)),
          (r = fe("message", r)),
          (s = fe("publicKey", s, l)),
          void 0 !== u && se("zip215", u),
          n && (r = n(r));
        const h = le(e.slice(l, 2 * l));
        let d, f, y;
        try {
          (d = t.fromHex(s, u)),
            (f = t.fromHex(e.slice(0, l), u)),
            (y = o.multiplyUnsafe(h));
        } catch (w) {
          return !1;
        }
        if (!u && d.isSmallOrder()) return !1;
        const g = p(c, f.toBytes(), d.toBytes(), r);
        return f.add(d.multiplyUnsafe(g)).subtract(y).clearCofactor().is0();
      },
      utils: {
        getExtendedPublicKey: f,
        randomPrivateKey: () => c(i.BYTES),
        precompute: (e = 8, n = t.BASE) => n.precompute(e, !1),
      },
      Point: t,
    };
  }
  function sn(t) {
    const {
        CURVE: e,
        curveOpts: n,
        eddsaOpts: r,
      } = (function (t) {
        const e = {
          a: t.a,
          d: t.d,
          p: t.Fp.ORDER,
          n: t.n,
          h: t.h,
          Gx: t.Gx,
          Gy: t.Gy,
        };
        return {
          CURVE: e,
          curveOpts: {
            Fp: t.Fp,
            Fn: Pe(e.n, t.nBitLength, !0),
            uvRatio: t.uvRatio,
          },
          eddsaOpts: {
            hash: t.hash,
            randomBytes: t.randomBytes,
            adjustScalarBytes: t.adjustScalarBytes,
            domain: t.domain,
            prehash: t.prehash,
            mapToCurve: t.mapToCurve,
          },
        };
      })(t),
      o = (function (t, e = {}) {
        const { Fp: n, Fn: r } = $e("edwards", t, e),
          { h: o, n: i } = t;
        ge(e, {}, { uvRatio: "function" });
        const s = en << (BigInt(8 * r.BYTES) - tn),
          a = (t) => n.create(t),
          c =
            e.uvRatio ||
            ((t, e) => {
              try {
                return { isValid: !0, value: n.sqrt(n.div(t, e)) };
              } catch (r) {
                return { isValid: !1, value: Qe };
              }
            });
        if (
          !(function (t, e, n, r) {
            const o = t.sqr(n),
              i = t.sqr(r),
              s = t.add(t.mul(e.a, o), i),
              a = t.add(t.ONE, t.mul(e.d, t.mul(o, i)));
            return t.eql(s, a);
          })(n, t, t.Gx, t.Gy)
        )
          throw new Error("bad curve params: generator point");
        function u(t, e, n = !1) {
          return me("coordinate " + t, e, n ? tn : Qe, s), e;
        }
        function l(t) {
          if (!(t instanceof f)) throw new Error("ExtendedPoint expected");
        }
        const h = we((t, e) => {
            const { ex: r, ey: o, ez: i } = t,
              s = t.is0();
            null == e && (e = s ? nn : n.inv(i));
            const c = a(r * e),
              u = a(o * e),
              l = a(i * e);
            if (s) return { x: Qe, y: tn };
            if (l !== tn) throw new Error("invZ was invalid");
            return { x: c, y: u };
          }),
          d = we((e) => {
            const { a: n, d: r } = t;
            if (e.is0()) throw new Error("bad point: ZERO");
            const { ex: o, ey: i, ez: s, et: c } = e,
              u = a(o * o),
              l = a(i * i),
              h = a(s * s),
              d = a(h * h),
              f = a(u * n);
            if (a(h * a(f + l)) !== a(d + a(r * a(u * l))))
              throw new Error("bad point: equation left != right (1)");
            if (a(o * i) !== a(s * c))
              throw new Error("bad point: equation left != right (2)");
            return !0;
          });
        class f {
          constructor(t, e, n, r) {
            (this.ex = u("x", t)),
              (this.ey = u("y", e)),
              (this.ez = u("z", n, !0)),
              (this.et = u("t", r)),
              Object.freeze(this);
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static fromAffine(t) {
            if (t instanceof f) throw new Error("extended point not allowed");
            const { x: e, y: n } = t || {};
            return u("x", e), u("y", n), new f(e, n, tn, a(e * n));
          }
          static normalizeZ(t) {
            return Ge(f, "ez", t);
          }
          static msm(t, e) {
            return Je(f, r, t, e);
          }
          _setWindowSize(t) {
            this.precompute(t);
          }
          precompute(t = 8, e = !0) {
            return p.setWindowSize(this, t), e || this.multiply(en), this;
          }
          assertValidity() {
            d(this);
          }
          equals(t) {
            l(t);
            const { ex: e, ey: n, ez: r } = this,
              { ex: o, ey: i, ez: s } = t,
              c = a(e * s),
              u = a(o * r),
              h = a(n * s),
              d = a(i * r);
            return c === u && h === d;
          }
          is0() {
            return this.equals(f.ZERO);
          }
          negate() {
            return new f(a(-this.ex), this.ey, this.ez, a(-this.et));
          }
          double() {
            const { a: e } = t,
              { ex: n, ey: r, ez: o } = this,
              i = a(n * n),
              s = a(r * r),
              c = a(en * a(o * o)),
              u = a(e * i),
              l = n + r,
              h = a(a(l * l) - i - s),
              d = u + s,
              p = d - c,
              m = u - s,
              y = a(h * p),
              g = a(d * m),
              w = a(h * m),
              b = a(p * d);
            return new f(y, g, b, w);
          }
          add(e) {
            l(e);
            const { a: n, d: r } = t,
              { ex: o, ey: i, ez: s, et: c } = this,
              { ex: u, ey: h, ez: d, et: p } = e,
              m = a(o * u),
              y = a(i * h),
              g = a(c * r * p),
              w = a(s * d),
              b = a((o + i) * (u + h) - m - y),
              v = w - g,
              _ = w + g,
              k = a(y - n * m),
              A = a(b * v),
              E = a(_ * k),
              I = a(b * k),
              C = a(v * _);
            return new f(A, E, C, I);
          }
          subtract(t) {
            return this.add(t.negate());
          }
          multiply(t) {
            const e = t;
            me("scalar", e, tn, i);
            const { p: n, f: r } = p.wNAFCached(this, e, f.normalizeZ);
            return f.normalizeZ([n, r])[0];
          }
          multiplyUnsafe(t, e = f.ZERO) {
            const n = t;
            return (
              me("scalar", n, Qe, i),
              n === Qe
                ? f.ZERO
                : this.is0() || n === tn
                ? this
                : p.wNAFCachedUnsafe(this, n, f.normalizeZ, e)
            );
          }
          isSmallOrder() {
            return this.multiplyUnsafe(o).is0();
          }
          isTorsionFree() {
            return p.wNAFCachedUnsafe(this, i).is0();
          }
          toAffine(t) {
            return h(this, t);
          }
          clearCofactor() {
            return o === tn ? this : this.multiplyUnsafe(o);
          }
          static fromBytes(t, e = !1) {
            return et(t), this.fromHex(t, e);
          }
          static fromHex(e, r = !1) {
            const { d: o, a: i } = t,
              u = n.BYTES;
            (e = fe("pointHex", e, u)), se("zip215", r);
            const l = e.slice(),
              h = e[u - 1];
            l[u - 1] = -129 & h;
            const d = le(l),
              p = r ? s : n.ORDER;
            me("pointHex.y", d, Qe, p);
            const m = a(d * d),
              y = a(m - tn),
              g = a(o * m - i);
            let { isValid: w, value: b } = c(y, g);
            if (!w) throw new Error("Point.fromHex: invalid y coordinate");
            const v = (b & tn) === tn,
              _ = !!(128 & h);
            if (!r && b === Qe && _)
              throw new Error("Point.fromHex: x=0 and x_0=1");
            return _ !== v && (b = a(-b)), f.fromAffine({ x: b, y: d });
          }
          static fromPrivateScalar(t) {
            return f.BASE.multiply(t);
          }
          toBytes() {
            const { x: t, y: e } = this.toAffine(),
              r = de(e, n.BYTES);
            return (r[r.length - 1] |= t & tn ? 128 : 0), r;
          }
          toRawBytes() {
            return this.toBytes();
          }
          toHex() {
            return ht(this.toBytes());
          }
          toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
          }
        }
        (f.BASE = new f(t.Gx, t.Gy, tn, a(t.Gx * t.Gy))),
          (f.ZERO = new f(Qe, tn, tn, Qe)),
          (f.Fp = n),
          (f.Fn = r);
        const p = Ze(f, 8 * r.BYTES);
        return f;
      })(e, n);
    return (function (t, e) {
      return Object.assign({}, e, { ExtendedPoint: e.Point, CURVE: t });
    })(t, on(o, r));
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    BigInt(0);
  const an = BigInt(1),
    cn = BigInt(2);
  BigInt(3);
  const un = BigInt(5),
    ln = BigInt(8),
    hn = {
      p: BigInt(
        "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"
      ),
      n: BigInt(
        "0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"
      ),
      h: ln,
      a: BigInt(
        "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"
      ),
      d: BigInt(
        "0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"
      ),
      Gx: BigInt(
        "0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"
      ),
      Gy: BigInt(
        "0x6666666666666666666666666666666666666666666666666666666666666658"
      ),
    };
  function dn(t) {
    return (t[0] &= 248), (t[31] &= 127), (t[31] |= 64), t;
  }
  const fn = BigInt(
    "19681161376707505956807079304988542015446066515923890162744021073123829784752"
  );
  function pn(t, e) {
    const n = hn.p,
      r = Ce(e * e * e, n),
      o = (function (t) {
        const e = BigInt(10),
          n = BigInt(20),
          r = BigInt(40),
          o = BigInt(80),
          i = hn.p,
          s = (((t * t) % i) * t) % i,
          a = (Se(s, cn, i) * s) % i,
          c = (Se(a, an, i) * t) % i,
          u = (Se(c, un, i) * c) % i,
          l = (Se(u, e, i) * u) % i,
          h = (Se(l, n, i) * l) % i,
          d = (Se(h, r, i) * h) % i,
          f = (Se(d, o, i) * d) % i,
          p = (Se(f, o, i) * d) % i,
          m = (Se(p, e, i) * u) % i;
        return { pow_p_5_8: (Se(m, cn, i) * t) % i, b2: s };
      })(t * Ce(r * r * e, n)).pow_p_5_8;
    let i = Ce(t * r * o, n);
    const s = Ce(e * i * i, n),
      a = i,
      c = Ce(i * fn, n),
      u = s === t,
      l = s === Ce(-t, n),
      h = s === Ce(-t * fn, n);
    return (
      u && (i = a),
      (l || h) && (i = c),
      (Ce(i, n) & ve) === ve && (i = Ce(-i, n)),
      { isValid: u || l, value: i }
    );
  }
  const mn = (() => Pe(hn.p, void 0, !0))(),
    yn = (() => ({
      ...hn,
      Fp: mn,
      hash: re,
      adjustScalarBytes: dn,
      uvRatio: pn,
    }))(),
    gn = (() => sn(yn))();
  function wn(t, e) {
    var n = In();
    return (
      (wn = function (e, r) {
        var o = n[(e -= 423)];
        if (void 0 === wn.kqbvdg) {
          var i = function (t) {
            for (
              var e, n, r = "", o = "", s = r + i, a = 0, c = 0;
              (n = t.charAt(c++));
              ~n && ((e = a % 4 ? 64 * e + n : n), a++ % 4)
                ? (r +=
                    s.charCodeAt(c + 10) - 10 != 0
                      ? String.fromCharCode(255 & (e >> ((-2 * a) & 6)))
                      : a)
                : 0
            )
              n =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  n
                );
            for (var u = 0, l = r.length; u < l; u++)
              o += "%" + ("00" + r.charCodeAt(u).toString(16)).slice(-2);
            return decodeURIComponent(o);
          };
          (wn.eujNsU = i), (t = arguments), (wn.kqbvdg = !![]);
        }
        var s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          var c = function (t) {
            (this.BWCRLO = t),
              (this.fLvWFQ = [1, 0, 0]),
              (this.agYvQy = function () {
                return "newState";
              }),
              (this.KBqhOV = "\\w+ *\\(\\) *{\\w+ *"),
              (this.ABHbRi = "['|\"].+['|\"];? *}");
          };
          (c.prototype.WiAYfx = function () {
            var t = new RegExp(this.KBqhOV + this.ABHbRi).test(
              this.agYvQy.toString()
            )
              ? --this.fLvWFQ[1]
              : --this.fLvWFQ[0];
            return this.sYgsuV(t);
          }),
            (c.prototype.sYgsuV = function (t) {
              return Boolean(~t) ? this.dyODZR(this.BWCRLO) : t;
            }),
            (c.prototype.dyODZR = function (t) {
              for (var e = 0, n = this.fLvWFQ.length; e < n; e++)
                this.fLvWFQ.push(Math.round(Math.random())),
                  (n = this.fLvWFQ.length);
              return t(this.fLvWFQ[0]);
            }),
            new c(wn).WiAYfx(),
            (o = wn.eujNsU(o)),
            (t[s] = o);
        }
        return o;
      }),
      wn(t, e)
    );
  }
  var bn = wn;
  !(function (t) {
    for (
      var e = 454,
        n = 455,
        r = 463,
        o = 434,
        i = 456,
        s = 431,
        a = 451,
        c = 423,
        u = wn,
        l = t();
      [];

    )
      try {
        if (
          723510 ===
          (-parseInt(u(e)) / 1) * (parseInt(u(n)) / 2) +
            (parseInt(u(r)) / 3) * (parseInt(u(442)) / 4) +
            (-parseInt(u(o)) / 5) * (-parseInt(u(i)) / 6) +
            parseInt(u(444)) / 7 +
            (parseInt(u(458)) / 8) * (-parseInt(u(s)) / 9) +
            (-parseInt(u(a)) / 10) * (-parseInt(u(c)) / 11) +
            -parseInt(u(427)) / 12
        )
          break;
        l.push(l.shift());
      } catch (h) {
        l.push(l.shift());
      }
  })(In);
  var vn = (function () {
      var t = !![];
      return function (e, n) {
        var r = t
          ? function () {
              if (n) {
                var t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    _n = vn(void 0, function () {
      var t = 436,
        e = 447,
        n = wn;
      return _n
        .toString()
        [n(t)](n(e) + "+$")
        [n(426)]()
        .constructor(_n)
        .search("(((.+)+)+)+$");
    });
  _n();
  var kn = (function () {
    var t = !![];
    return function (e, n) {
      var r = t
        ? function () {
            if (n) {
              var t = n.apply(e, arguments);
              return (n = null), t;
            }
          }
        : function () {};
      return (t = ![]), r;
    };
  })();
  function An(t) {
    var e = bn;
    return t &&
      t.__esModule &&
      Object.prototype[e(449) + e([440][0])][e(453)](t, "default")
      ? t.default
      : t;
  }
  function En(t) {
    var e = 446,
      n = 446,
      r = 452,
      o = 460,
      i = 432,
      s = 425,
      a = 433,
      c = 440,
      u = 459,
      l = 437,
      h = 441,
      d = bn,
      f = {
        kQIPG: function (t, e) {
          return t instanceof e;
        },
      };
    f.gXqQm = d(e);
    var p = f;
    if (Object.prototype[d(449) + d(440)].call(t, d(n))) return t;
    var m = t[d(445)];
    if (typeof m == d(r)) {
      var y = function t() {
        var e = d;
        return p[e(u)](this, t)
          ? Reflect.construct(m, arguments, this[e(l) + "r"])
          : m[e(h)](this, arguments);
      };
      y.prototype = m.prototype;
    } else y = {};
    var g = {};
    return (
      (g[d(429)] = !![]),
      Object.defineProperty(y, p[d(o)], g),
      Object[d(457)](t)[d(i)](function (e) {
        var n = d,
          r = Object["getOwnProp" + n(s) + n(a)](t, e);
        Object["defineProp" + n(c)](
          y,
          e,
          r.get
            ? r
            : {
                enumerable: !![],
                get: function () {
                  return t[e];
                },
              }
        );
      }),
      y
    );
  }
  function In() {
    var t = [
      "y2fSBa",
      "mJeZnZi2AhzOB1Dm",
      "mtb1uxzkzKS",
      "nJG1oda3ogDXtvfYsq",
      "A2v5CW",
      "ntq0ohfHtuXgAa",
      "A1fjueC",
      "z1HXuw0",
      "Bg9N",
      "CMv0DxjUicHMDq",
      "mteWodyYwgnPzvrS",
      "mtfbwNzrr0q",
      "vhLRuw8",
      "zxj0EurLC2nYAq",
      "Dg9tDhjPBMC",
      "ntCXmJG2nhfHuersCa",
      "ChjVDg90ExbL",
      "DMfSDwu",
      "C3bSAxq",
      "mta1otnuENnQyKO",
      "zM9YrwfJAa",
      "ChrVCG",
      "nuTxvNzVyG",
      "q3fxzMi",
      "C2vHCMnO",
      "y29UC3rYDwn0BW",
      "txvZsLa",
      "Dw5KzwzPBMvK",
      "zxj0Eq",
      "yxbWBhK",
      "odbVCwjczK4",
      "Aw5MBW",
      "ndKXnZmZouX2v3nZBW",
      "zgvMyxvSDa",
      "x19LC01VzhvSzq",
      "kcGOlISPkYKRkq",
      "DLztvKi",
      "AgfZt3DUuhjVCa",
      "ENj0wKi",
      "ndG1mtC5mgHMEvzjvq",
      "zNvUy3rPB24",
    ];
    return (In = function () {
      return t;
    })();
  }
  kn(void 0, function () {
    var t = 462,
      e = 461,
      n = 450,
      r = 435,
      o = 443,
      i = 430,
      s = 437,
      a = 428,
      c = wn,
      u = {};
    (u.fdIuf = c(t) + "nction() "),
      (u[c(438)] = '{}.constructor("return this")( )'),
      (u.qqeQC = c(e)),
      (u[c(n)] = "warn"),
      (u[c(r)] = c(o)),
      (u.lCGmb = "table");
    for (
      var l = u,
        h = (function () {
          var t;
          try {
            t = Function(l.fdIuf + l.MusJP + ");")();
          } catch (e) {
            t = window;
          }
          return t;
        })(),
        d = (h.console = h.console || {}),
        f = [l.qqeQC, l[c(n)], l.CqWfb, "error", "exception", l.lCGmb, "trace"],
        p = 0;
      p < f.length;
      p++
    )
      for (var m = "0|1|4|3|5|2"[c(i)]("|"), y = 0; []; ) {
        switch (m[y++]) {
          case "0":
            var g = kn[c(s) + "r"][c(a)].bind(kn);
            continue;
          case "1":
            var w = f[p];
            continue;
          case "2":
            d[w] = g;
            continue;
          case "3":
            g.__proto__ = kn.bind(kn);
            continue;
          case "4":
            var b = d[w] || g;
            continue;
          case "5":
            g.toString = b.toString.bind(b);
            continue;
        }
        break;
      }
  })(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    typeof globalThis !== bn(439)
      ? globalThis
      : typeof window !== bn(439)
      ? window
      : "undefined" != typeof global
      ? global
      : typeof self !== bn(439) && self;
  var Cn,
    Sn = { exports: {} },
    Bn = {};
  function xn() {
    return (
      Cn ||
        ((Cn = 1),
        (function (t) {
          Object.defineProperties(t, {
            __esModule: { value: !0 },
            [Symbol.toStringTag]: { value: "Module" },
          });
          for (
            var e = {},
              n = {
                byteLength: function (t) {
                  var e = c(t),
                    n = e[0],
                    r = e[1];
                  return (3 * (n + r)) / 4 - r;
                },
                toByteArray: function (t) {
                  var e,
                    n,
                    r = c(t),
                    s = r[0],
                    a = r[1],
                    u = new i(
                      (function (t, e, n) {
                        return (3 * (e + n)) / 4 - n;
                      })(0, s, a)
                    ),
                    l = 0,
                    h = a > 0 ? s - 4 : s;
                  for (n = 0; n < h; n += 4)
                    (e =
                      (o[t.charCodeAt(n)] << 18) |
                      (o[t.charCodeAt(n + 1)] << 12) |
                      (o[t.charCodeAt(n + 2)] << 6) |
                      o[t.charCodeAt(n + 3)]),
                      (u[l++] = (e >> 16) & 255),
                      (u[l++] = (e >> 8) & 255),
                      (u[l++] = 255 & e);
                  2 === a &&
                    ((e =
                      (o[t.charCodeAt(n)] << 2) |
                      (o[t.charCodeAt(n + 1)] >> 4)),
                    (u[l++] = 255 & e));
                  1 === a &&
                    ((e =
                      (o[t.charCodeAt(n)] << 10) |
                      (o[t.charCodeAt(n + 1)] << 4) |
                      (o[t.charCodeAt(n + 2)] >> 2)),
                    (u[l++] = (e >> 8) & 255),
                    (u[l++] = 255 & e));
                  return u;
                },
                fromByteArray: function (t) {
                  for (
                    var e,
                      n = t.length,
                      o = n % 3,
                      i = [],
                      s = 16383,
                      a = 0,
                      c = n - o;
                    a < c;
                    a += s
                  )
                    i.push(l(t, a, a + s > c ? c : a + s));
                  1 === o
                    ? ((e = t[n - 1]),
                      i.push(r[e >> 2] + r[(e << 4) & 63] + "=="))
                    : 2 === o &&
                      ((e = (t[n - 2] << 8) + t[n - 1]),
                      i.push(
                        r[e >> 10] + r[(e >> 4) & 63] + r[(e << 2) & 63] + "="
                      ));
                  return i.join("");
                },
              },
              r = [],
              o = [],
              i = "undefined" != typeof Uint8Array ? Uint8Array : Array,
              s =
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
              a = 0;
            a < 64;
            ++a
          )
            (r[a] = s[a]), (o[s.charCodeAt(a)] = a);
          function c(t) {
            var e = t.length;
            if (e % 4 > 0)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var n = t.indexOf("=");
            return -1 === n && (n = e), [n, n === e ? 0 : 4 - (n % 4)];
          }
          function u(t) {
            return (
              r[(t >> 18) & 63] +
              r[(t >> 12) & 63] +
              r[(t >> 6) & 63] +
              r[63 & t]
            );
          }
          function l(t, e, n) {
            for (var r, o = [], i = e; i < n; i += 3)
              (r =
                ((t[i] << 16) & 16711680) +
                ((t[i + 1] << 8) & 65280) +
                (255 & t[i + 2])),
                o.push(u(r));
            return o.join("");
          }
          (o["-".charCodeAt(0)] = 62), (o["_".charCodeAt(0)] = 63);
          var h = {
            read: function (t, e, n, r, o) {
              var i,
                s,
                a = 8 * o - r - 1,
                c = (1 << a) - 1,
                u = c >> 1,
                l = -7,
                h = n ? o - 1 : 0,
                d = n ? -1 : 1,
                f = t[e + h];
              for (
                h += d, i = f & ((1 << -l) - 1), f >>= -l, l += a;
                l > 0;
                i = 256 * i + t[e + h], h += d, l -= 8
              );
              for (
                s = i & ((1 << -l) - 1), i >>= -l, l += r;
                l > 0;
                s = 256 * s + t[e + h], h += d, l -= 8
              );
              if (0 === i) i = 1 - u;
              else {
                if (i === c) return s ? NaN : (1 / 0) * (f ? -1 : 1);
                (s += Math.pow(2, r)), (i -= u);
              }
              return (f ? -1 : 1) * s * Math.pow(2, i - r);
            },
            write: function (t, e, n, r, o, i) {
              var s,
                a,
                c,
                u = 8 * i - o - 1,
                l = (1 << u) - 1,
                h = l >> 1,
                d = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                f = r ? 0 : i - 1,
                p = r ? 1 : -1,
                m = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
              for (
                e = Math.abs(e),
                  isNaN(e) || e === 1 / 0
                    ? ((a = isNaN(e) ? 1 : 0), (s = l))
                    : ((s = Math.floor(Math.log(e) / Math.LN2)),
                      e * (c = Math.pow(2, -s)) < 1 && (s--, (c *= 2)),
                      (e += s + h >= 1 ? d / c : d * Math.pow(2, 1 - h)) * c >=
                        2 && (s++, (c /= 2)),
                      s + h >= l
                        ? ((a = 0), (s = l))
                        : s + h >= 1
                        ? ((a = (e * c - 1) * Math.pow(2, o)), (s += h))
                        : ((a = e * Math.pow(2, h - 1) * Math.pow(2, o)),
                          (s = 0)));
                o >= 8;
                t[n + f] = 255 & a, f += p, a /= 256, o -= 8
              );
              for (
                s = (s << o) | a, u += o;
                u > 0;
                t[n + f] = 255 & s, f += p, s /= 256, u -= 8
              );
              t[n + f - p] |= 128 * m;
            },
          };
          !(function (t) {
            const e = n,
              r = h,
              o =
                "function" == typeof Symbol && "function" == typeof Symbol.for
                  ? Symbol.for("nodejs.util.inspect.custom")
                  : null;
            (t.Buffer = l),
              (t.SlowBuffer = function (t) {
                +t != t && (t = 0);
                return l.alloc(+t);
              }),
              (t.INSPECT_MAX_BYTES = 50);
            const i = 2147483647;
            t.kMaxLength = i;
            const {
              Uint8Array: s,
              ArrayBuffer: a,
              SharedArrayBuffer: c,
            } = globalThis;
            function u(t) {
              if (t > i)
                throw new RangeError(
                  'The value "' + t + '" is invalid for option "size"'
                );
              const e = new s(t);
              return Object.setPrototypeOf(e, l.prototype), e;
            }
            function l(t, e, n) {
              if ("number" == typeof t) {
                if ("string" == typeof e)
                  throw new TypeError(
                    'The "string" argument must be of type string. Received type number'
                  );
                return p(t);
              }
              return d(t, e, n);
            }
            function d(t, e, n) {
              if ("string" == typeof t)
                return (function (t, e) {
                  ("string" == typeof e && "" !== e) || (e = "utf8");
                  if (!l.isEncoding(e))
                    throw new TypeError("Unknown encoding: " + e);
                  const n = 0 | w(t, e);
                  let r = u(n);
                  const o = r.write(t, e);
                  o !== n && (r = r.slice(0, o));
                  return r;
                })(t, e);
              if (a.isView(t))
                return (function (t) {
                  if ($(t, s)) {
                    const e = new s(t);
                    return y(e.buffer, e.byteOffset, e.byteLength);
                  }
                  return m(t);
                })(t);
              if (null == t)
                throw new TypeError(
                  "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                    typeof t
                );
              if ($(t, a) || (t && $(t.buffer, a))) return y(t, e, n);
              if (void 0 !== c && ($(t, c) || (t && $(t.buffer, c))))
                return y(t, e, n);
              if ("number" == typeof t)
                throw new TypeError(
                  'The "value" argument must not be of type number. Received type number'
                );
              const r = t.valueOf && t.valueOf();
              if (null != r && r !== t) return l.from(r, e, n);
              const o = (function (t) {
                if (l.isBuffer(t)) {
                  const e = 0 | g(t.length),
                    n = u(e);
                  return 0 === n.length || t.copy(n, 0, 0, e), n;
                }
                if (void 0 !== t.length)
                  return "number" != typeof t.length || Q(t.length)
                    ? u(0)
                    : m(t);
                if ("Buffer" === t.type && Array.isArray(t.data))
                  return m(t.data);
              })(t);
              if (o) return o;
              if (
                "undefined" != typeof Symbol &&
                null != Symbol.toPrimitive &&
                "function" == typeof t[Symbol.toPrimitive]
              )
                return l.from(t[Symbol.toPrimitive]("string"), e, n);
              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                  typeof t
              );
            }
            function f(t) {
              if ("number" != typeof t)
                throw new TypeError('"size" argument must be of type number');
              if (t < 0)
                throw new RangeError(
                  'The value "' + t + '" is invalid for option "size"'
                );
            }
            function p(t) {
              return f(t), u(t < 0 ? 0 : 0 | g(t));
            }
            function m(t) {
              const e = t.length < 0 ? 0 : 0 | g(t.length),
                n = u(e);
              for (let r = 0; r < e; r += 1) n[r] = 255 & t[r];
              return n;
            }
            function y(t, e, n) {
              if (e < 0 || t.byteLength < e)
                throw new RangeError('"offset" is outside of buffer bounds');
              if (t.byteLength < e + (n || 0))
                throw new RangeError('"length" is outside of buffer bounds');
              let r;
              return (
                (r =
                  void 0 === e && void 0 === n
                    ? new s(t)
                    : void 0 === n
                    ? new s(t, e)
                    : new s(t, e, n)),
                Object.setPrototypeOf(r, l.prototype),
                r
              );
            }
            function g(t) {
              if (t >= i)
                throw new RangeError(
                  "Attempt to allocate Buffer larger than maximum size: 0x" +
                    i.toString(16) +
                    " bytes"
                );
              return 0 | t;
            }
            function w(t, e) {
              if (l.isBuffer(t)) return t.length;
              if (a.isView(t) || $(t, a)) return t.byteLength;
              if ("string" != typeof t)
                throw new TypeError(
                  'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
                    typeof t
                );
              const n = t.length,
                r = arguments.length > 2 && !0 === arguments[2];
              if (!r && 0 === n) return 0;
              let o = !1;
              for (;;)
                switch (e) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return n;
                  case "utf8":
                  case "utf-8":
                    return Z(t).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return 2 * n;
                  case "hex":
                    return n >>> 1;
                  case "base64":
                    return J(t).length;
                  default:
                    if (o) return r ? -1 : Z(t).length;
                    (e = ("" + e).toLowerCase()), (o = !0);
                }
            }
            function b(t, e, n) {
              let r = !1;
              if (((void 0 === e || e < 0) && (e = 0), e > this.length))
                return "";
              if (
                ((void 0 === n || n > this.length) && (n = this.length), n <= 0)
              )
                return "";
              if ((n >>>= 0) <= (e >>>= 0)) return "";
              for (t || (t = "utf8"); ; )
                switch (t) {
                  case "hex":
                    return M(this, e, n);
                  case "utf8":
                  case "utf-8":
                    return x(this, e, n);
                  case "ascii":
                    return R(this, e, n);
                  case "latin1":
                  case "binary":
                    return O(this, e, n);
                  case "base64":
                    return B(this, e, n);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return N(this, e, n);
                  default:
                    if (r) throw new TypeError("Unknown encoding: " + t);
                    (t = (t + "").toLowerCase()), (r = !0);
                }
            }
            function v(t, e, n) {
              const r = t[e];
              (t[e] = t[n]), (t[n] = r);
            }
            function _(t, e, n, r, o) {
              if (0 === t.length) return -1;
              if (
                ("string" == typeof n
                  ? ((r = n), (n = 0))
                  : n > 2147483647
                  ? (n = 2147483647)
                  : n < -2147483648 && (n = -2147483648),
                Q((n = +n)) && (n = o ? 0 : t.length - 1),
                n < 0 && (n = t.length + n),
                n >= t.length)
              ) {
                if (o) return -1;
                n = t.length - 1;
              } else if (n < 0) {
                if (!o) return -1;
                n = 0;
              }
              if (("string" == typeof e && (e = l.from(e, r)), l.isBuffer(e)))
                return 0 === e.length ? -1 : k(t, e, n, r, o);
              if ("number" == typeof e)
                return (
                  (e &= 255),
                  "function" == typeof s.prototype.indexOf
                    ? o
                      ? s.prototype.indexOf.call(t, e, n)
                      : s.prototype.lastIndexOf.call(t, e, n)
                    : k(t, [e], n, r, o)
                );
              throw new TypeError("val must be string, number or Buffer");
            }
            function k(t, e, n, r, o) {
              let i,
                s = 1,
                a = t.length,
                c = e.length;
              if (
                void 0 !== r &&
                ("ucs2" === (r = String(r).toLowerCase()) ||
                  "ucs-2" === r ||
                  "utf16le" === r ||
                  "utf-16le" === r)
              ) {
                if (t.length < 2 || e.length < 2) return -1;
                (s = 2), (a /= 2), (c /= 2), (n /= 2);
              }
              function u(t, e) {
                return 1 === s ? t[e] : t.readUInt16BE(e * s);
              }
              if (o) {
                let r = -1;
                for (i = n; i < a; i++)
                  if (u(t, i) === u(e, -1 === r ? 0 : i - r)) {
                    if ((-1 === r && (r = i), i - r + 1 === c)) return r * s;
                  } else -1 !== r && (i -= i - r), (r = -1);
              } else
                for (n + c > a && (n = a - c), i = n; i >= 0; i--) {
                  let n = !0;
                  for (let r = 0; r < c; r++)
                    if (u(t, i + r) !== u(e, r)) {
                      n = !1;
                      break;
                    }
                  if (n) return i;
                }
              return -1;
            }
            function A(t, e, n, r) {
              n = Number(n) || 0;
              const o = t.length - n;
              r ? (r = Number(r)) > o && (r = o) : (r = o);
              const i = e.length;
              let s;
              for (r > i / 2 && (r = i / 2), s = 0; s < r; ++s) {
                const r = parseInt(e.substr(2 * s, 2), 16);
                if (Q(r)) return s;
                t[n + s] = r;
              }
              return s;
            }
            function E(t, e, n, r) {
              return X(Z(e, t.length - n), t, n, r);
            }
            function I(t, e, n, r) {
              return X(
                (function (t) {
                  const e = [];
                  for (let n = 0; n < t.length; ++n)
                    e.push(255 & t.charCodeAt(n));
                  return e;
                })(e),
                t,
                n,
                r
              );
            }
            function C(t, e, n, r) {
              return X(J(e), t, n, r);
            }
            function S(t, e, n, r) {
              return X(
                (function (t, e) {
                  let n, r, o;
                  const i = [];
                  for (let s = 0; s < t.length && !((e -= 2) < 0); ++s)
                    (n = t.charCodeAt(s)),
                      (r = n >> 8),
                      (o = n % 256),
                      i.push(o),
                      i.push(r);
                  return i;
                })(e, t.length - n),
                t,
                n,
                r
              );
            }
            function B(t, n, r) {
              return 0 === n && r === t.length
                ? e.fromByteArray(t)
                : e.fromByteArray(t.slice(n, r));
            }
            function x(t, e, n) {
              n = Math.min(t.length, n);
              const r = [];
              let o = e;
              for (; o < n; ) {
                const e = t[o];
                let i = null,
                  s = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;
                if (o + s <= n) {
                  let n, r, a, c;
                  switch (s) {
                    case 1:
                      e < 128 && (i = e);
                      break;
                    case 2:
                      (n = t[o + 1]),
                        128 == (192 & n) &&
                          ((c = ((31 & e) << 6) | (63 & n)),
                          c > 127 && (i = c));
                      break;
                    case 3:
                      (n = t[o + 1]),
                        (r = t[o + 2]),
                        128 == (192 & n) &&
                          128 == (192 & r) &&
                          ((c = ((15 & e) << 12) | ((63 & n) << 6) | (63 & r)),
                          c > 2047 && (c < 55296 || c > 57343) && (i = c));
                      break;
                    case 4:
                      (n = t[o + 1]),
                        (r = t[o + 2]),
                        (a = t[o + 3]),
                        128 == (192 & n) &&
                          128 == (192 & r) &&
                          128 == (192 & a) &&
                          ((c =
                            ((15 & e) << 18) |
                            ((63 & n) << 12) |
                            ((63 & r) << 6) |
                            (63 & a)),
                          c > 65535 && c < 1114112 && (i = c));
                  }
                }
                null === i
                  ? ((i = 65533), (s = 1))
                  : i > 65535 &&
                    ((i -= 65536),
                    r.push(((i >>> 10) & 1023) | 55296),
                    (i = 56320 | (1023 & i))),
                  r.push(i),
                  (o += s);
              }
              return (function (t) {
                const e = t.length;
                if (e <= T) return String.fromCharCode.apply(String, t);
                let n = "",
                  r = 0;
                for (; r < e; )
                  n += String.fromCharCode.apply(String, t.slice(r, (r += T)));
                return n;
              })(r);
            }
            (l.TYPED_ARRAY_SUPPORT = (function () {
              try {
                const t = new s(1),
                  e = {
                    foo: function () {
                      return 42;
                    },
                  };
                return (
                  Object.setPrototypeOf(e, s.prototype),
                  Object.setPrototypeOf(t, e),
                  42 === t.foo()
                );
              } catch (t) {
                return !1;
              }
            })()),
              l.TYPED_ARRAY_SUPPORT ||
                "undefined" == typeof console ||
                console.error,
              Object.defineProperty(l.prototype, "parent", {
                enumerable: !0,
                get: function () {
                  if (l.isBuffer(this)) return this.buffer;
                },
              }),
              Object.defineProperty(l.prototype, "offset", {
                enumerable: !0,
                get: function () {
                  if (l.isBuffer(this)) return this.byteOffset;
                },
              }),
              (l.poolSize = 8192),
              (l.from = function (t, e, n) {
                return d(t, e, n);
              }),
              Object.setPrototypeOf(l.prototype, s.prototype),
              Object.setPrototypeOf(l, s),
              (l.alloc = function (t, e, n) {
                return (function (t, e, n) {
                  return (
                    f(t),
                    t <= 0
                      ? u(t)
                      : void 0 !== e
                      ? "string" == typeof n
                        ? u(t).fill(e, n)
                        : u(t).fill(e)
                      : u(t)
                  );
                })(t, e, n);
              }),
              (l.allocUnsafe = function (t) {
                return p(t);
              }),
              (l.allocUnsafeSlow = function (t) {
                return p(t);
              }),
              (l.isBuffer = function (t) {
                return null != t && !0 === t._isBuffer && t !== l.prototype;
              }),
              (l.compare = function (t, e) {
                if (
                  ($(t, s) && (t = l.from(t, t.offset, t.byteLength)),
                  $(e, s) && (e = l.from(e, e.offset, e.byteLength)),
                  !l.isBuffer(t) || !l.isBuffer(e))
                )
                  throw new TypeError(
                    'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                  );
                if (t === e) return 0;
                let n = t.length,
                  r = e.length;
                for (let o = 0, i = Math.min(n, r); o < i; ++o)
                  if (t[o] !== e[o]) {
                    (n = t[o]), (r = e[o]);
                    break;
                  }
                return n < r ? -1 : r < n ? 1 : 0;
              }),
              (l.isEncoding = function (t) {
                switch (String(t).toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "latin1":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return !0;
                  default:
                    return !1;
                }
              }),
              (l.concat = function (t, e) {
                if (!Array.isArray(t))
                  throw new TypeError(
                    '"list" argument must be an Array of Buffers'
                  );
                if (0 === t.length) return l.alloc(0);
                let n;
                if (void 0 === e)
                  for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
                const r = l.allocUnsafe(e);
                let o = 0;
                for (n = 0; n < t.length; ++n) {
                  let e = t[n];
                  if ($(e, s))
                    o + e.length > r.length
                      ? (l.isBuffer(e) || (e = l.from(e)), e.copy(r, o))
                      : s.prototype.set.call(r, e, o);
                  else {
                    if (!l.isBuffer(e))
                      throw new TypeError(
                        '"list" argument must be an Array of Buffers'
                      );
                    e.copy(r, o);
                  }
                  o += e.length;
                }
                return r;
              }),
              (l.byteLength = w),
              (l.prototype._isBuffer = !0),
              (l.prototype.swap16 = function () {
                const t = this.length;
                if (t % 2 != 0)
                  throw new RangeError(
                    "Buffer size must be a multiple of 16-bits"
                  );
                for (let e = 0; e < t; e += 2) v(this, e, e + 1);
                return this;
              }),
              (l.prototype.swap32 = function () {
                const t = this.length;
                if (t % 4 != 0)
                  throw new RangeError(
                    "Buffer size must be a multiple of 32-bits"
                  );
                for (let e = 0; e < t; e += 4)
                  v(this, e, e + 3), v(this, e + 1, e + 2);
                return this;
              }),
              (l.prototype.swap64 = function () {
                const t = this.length;
                if (t % 8 != 0)
                  throw new RangeError(
                    "Buffer size must be a multiple of 64-bits"
                  );
                for (let e = 0; e < t; e += 8)
                  v(this, e, e + 7),
                    v(this, e + 1, e + 6),
                    v(this, e + 2, e + 5),
                    v(this, e + 3, e + 4);
                return this;
              }),
              (l.prototype.toString = function () {
                const t = this.length;
                return 0 === t
                  ? ""
                  : 0 === arguments.length
                  ? x(this, 0, t)
                  : b.apply(this, arguments);
              }),
              (l.prototype.toLocaleString = l.prototype.toString),
              (l.prototype.equals = function (t) {
                if (!l.isBuffer(t))
                  throw new TypeError("Argument must be a Buffer");
                return this === t || 0 === l.compare(this, t);
              }),
              (l.prototype.inspect = function () {
                let e = "";
                const n = t.INSPECT_MAX_BYTES;
                return (
                  (e = this.toString("hex", 0, n)
                    .replace(/(.{2})/g, "$1 ")
                    .trim()),
                  this.length > n && (e += " ... "),
                  "<Buffer " + e + ">"
                );
              }),
              o && (l.prototype[o] = l.prototype.inspect),
              (l.prototype.compare = function (t, e, n, r, o) {
                if (
                  ($(t, s) && (t = l.from(t, t.offset, t.byteLength)),
                  !l.isBuffer(t))
                )
                  throw new TypeError(
                    'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                      typeof t
                  );
                if (
                  (void 0 === e && (e = 0),
                  void 0 === n && (n = t ? t.length : 0),
                  void 0 === r && (r = 0),
                  void 0 === o && (o = this.length),
                  e < 0 || n > t.length || r < 0 || o > this.length)
                )
                  throw new RangeError("out of range index");
                if (r >= o && e >= n) return 0;
                if (r >= o) return -1;
                if (e >= n) return 1;
                if (this === t) return 0;
                let i = (o >>>= 0) - (r >>>= 0),
                  a = (n >>>= 0) - (e >>>= 0);
                const c = Math.min(i, a),
                  u = this.slice(r, o),
                  h = t.slice(e, n);
                for (let s = 0; s < c; ++s)
                  if (u[s] !== h[s]) {
                    (i = u[s]), (a = h[s]);
                    break;
                  }
                return i < a ? -1 : a < i ? 1 : 0;
              }),
              (l.prototype.includes = function (t, e, n) {
                return -1 !== this.indexOf(t, e, n);
              }),
              (l.prototype.indexOf = function (t, e, n) {
                return _(this, t, e, n, !0);
              }),
              (l.prototype.lastIndexOf = function (t, e, n) {
                return _(this, t, e, n, !1);
              }),
              (l.prototype.write = function (t, e, n, r) {
                if (void 0 === e) (r = "utf8"), (n = this.length), (e = 0);
                else if (void 0 === n && "string" == typeof e)
                  (r = e), (n = this.length), (e = 0);
                else {
                  if (!isFinite(e))
                    throw new Error(
                      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                    );
                  (e >>>= 0),
                    isFinite(n)
                      ? ((n >>>= 0), void 0 === r && (r = "utf8"))
                      : ((r = n), (n = void 0));
                }
                const o = this.length - e;
                if (
                  ((void 0 === n || n > o) && (n = o),
                  (t.length > 0 && (n < 0 || e < 0)) || e > this.length)
                )
                  throw new RangeError(
                    "Attempt to write outside buffer bounds"
                  );
                r || (r = "utf8");
                let i = !1;
                for (;;)
                  switch (r) {
                    case "hex":
                      return A(this, t, e, n);
                    case "utf8":
                    case "utf-8":
                      return E(this, t, e, n);
                    case "ascii":
                    case "latin1":
                    case "binary":
                      return I(this, t, e, n);
                    case "base64":
                      return C(this, t, e, n);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return S(this, t, e, n);
                    default:
                      if (i) throw new TypeError("Unknown encoding: " + r);
                      (r = ("" + r).toLowerCase()), (i = !0);
                  }
              }),
              (l.prototype.toJSON = function () {
                return {
                  type: "Buffer",
                  data: Array.prototype.slice.call(this._arr || this, 0),
                };
              });
            const T = 4096;
            function R(t, e, n) {
              let r = "";
              n = Math.min(t.length, n);
              for (let o = e; o < n; ++o) r += String.fromCharCode(127 & t[o]);
              return r;
            }
            function O(t, e, n) {
              let r = "";
              n = Math.min(t.length, n);
              for (let o = e; o < n; ++o) r += String.fromCharCode(t[o]);
              return r;
            }
            function M(t, e, n) {
              const r = t.length;
              (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r);
              let o = "";
              for (let i = e; i < n; ++i) o += tt[t[i]];
              return o;
            }
            function N(t, e, n) {
              const r = t.slice(e, n);
              let o = "";
              for (let i = 0; i < r.length - 1; i += 2)
                o += String.fromCharCode(r[i] + 256 * r[i + 1]);
              return o;
            }
            function P(t, e, n) {
              if (t % 1 != 0 || t < 0)
                throw new RangeError("offset is not uint");
              if (t + e > n)
                throw new RangeError("Trying to access beyond buffer length");
            }
            function L(t, e, n, r, o, i) {
              if (!l.isBuffer(t))
                throw new TypeError(
                  '"buffer" argument must be a Buffer instance'
                );
              if (e > o || e < i)
                throw new RangeError('"value" argument is out of bounds');
              if (n + r > t.length) throw new RangeError("Index out of range");
            }
            function z(t, e, n, r, o) {
              H(e, r, o, t, n, 7);
              let i = Number(e & BigInt(4294967295));
              (t[n++] = i),
                (i >>= 8),
                (t[n++] = i),
                (i >>= 8),
                (t[n++] = i),
                (i >>= 8),
                (t[n++] = i);
              let s = Number((e >> BigInt(32)) & BigInt(4294967295));
              return (
                (t[n++] = s),
                (s >>= 8),
                (t[n++] = s),
                (s >>= 8),
                (t[n++] = s),
                (s >>= 8),
                (t[n++] = s),
                n
              );
            }
            function D(t, e, n, r, o) {
              H(e, r, o, t, n, 7);
              let i = Number(e & BigInt(4294967295));
              (t[n + 7] = i),
                (i >>= 8),
                (t[n + 6] = i),
                (i >>= 8),
                (t[n + 5] = i),
                (i >>= 8),
                (t[n + 4] = i);
              let s = Number((e >> BigInt(32)) & BigInt(4294967295));
              return (
                (t[n + 3] = s),
                (s >>= 8),
                (t[n + 2] = s),
                (s >>= 8),
                (t[n + 1] = s),
                (s >>= 8),
                (t[n] = s),
                n + 8
              );
            }
            function U(t, e, n, r, o, i) {
              if (n + r > t.length) throw new RangeError("Index out of range");
              if (n < 0) throw new RangeError("Index out of range");
            }
            function q(t, e, n, o, i) {
              return (
                (e = +e),
                (n >>>= 0),
                i || U(t, 0, n, 4),
                r.write(t, e, n, o, 23, 4),
                n + 4
              );
            }
            function G(t, e, n, o, i) {
              return (
                (e = +e),
                (n >>>= 0),
                i || U(t, 0, n, 8),
                r.write(t, e, n, o, 52, 8),
                n + 8
              );
            }
            (l.prototype.slice = function (t, e) {
              const n = this.length;
              (t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
                (e = void 0 === e ? n : ~~e) < 0
                  ? (e += n) < 0 && (e = 0)
                  : e > n && (e = n),
                e < t && (e = t);
              const r = this.subarray(t, e);
              return Object.setPrototypeOf(r, l.prototype), r;
            }),
              (l.prototype.readUintLE = l.prototype.readUIntLE =
                function (t, e, n) {
                  (t >>>= 0), (e >>>= 0), n || P(t, e, this.length);
                  let r = this[t],
                    o = 1,
                    i = 0;
                  for (; ++i < e && (o *= 256); ) r += this[t + i] * o;
                  return r;
                }),
              (l.prototype.readUintBE = l.prototype.readUIntBE =
                function (t, e, n) {
                  (t >>>= 0), (e >>>= 0), n || P(t, e, this.length);
                  let r = this[t + --e],
                    o = 1;
                  for (; e > 0 && (o *= 256); ) r += this[t + --e] * o;
                  return r;
                }),
              (l.prototype.readUint8 = l.prototype.readUInt8 =
                function (t, e) {
                  return (t >>>= 0), e || P(t, 1, this.length), this[t];
                }),
              (l.prototype.readUint16LE = l.prototype.readUInt16LE =
                function (t, e) {
                  return (
                    (t >>>= 0),
                    e || P(t, 2, this.length),
                    this[t] | (this[t + 1] << 8)
                  );
                }),
              (l.prototype.readUint16BE = l.prototype.readUInt16BE =
                function (t, e) {
                  return (
                    (t >>>= 0),
                    e || P(t, 2, this.length),
                    (this[t] << 8) | this[t + 1]
                  );
                }),
              (l.prototype.readUint32LE = l.prototype.readUInt32LE =
                function (t, e) {
                  return (
                    (t >>>= 0),
                    e || P(t, 4, this.length),
                    (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
                      16777216 * this[t + 3]
                  );
                }),
              (l.prototype.readUint32BE = l.prototype.readUInt32BE =
                function (t, e) {
                  return (
                    (t >>>= 0),
                    e || P(t, 4, this.length),
                    16777216 * this[t] +
                      ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
                  );
                }),
              (l.prototype.readBigUInt64LE = et(function (t) {
                V((t >>>= 0), "offset");
                const e = this[t],
                  n = this[t + 7];
                (void 0 !== e && void 0 !== n) || F(t, this.length - 8);
                const r =
                    e +
                    256 * this[++t] +
                    65536 * this[++t] +
                    this[++t] * 2 ** 24,
                  o =
                    this[++t] +
                    256 * this[++t] +
                    65536 * this[++t] +
                    n * 2 ** 24;
                return BigInt(r) + (BigInt(o) << BigInt(32));
              })),
              (l.prototype.readBigUInt64BE = et(function (t) {
                V((t >>>= 0), "offset");
                const e = this[t],
                  n = this[t + 7];
                (void 0 !== e && void 0 !== n) || F(t, this.length - 8);
                const r =
                    e * 2 ** 24 +
                    65536 * this[++t] +
                    256 * this[++t] +
                    this[++t],
                  o =
                    this[++t] * 2 ** 24 +
                    65536 * this[++t] +
                    256 * this[++t] +
                    n;
                return (BigInt(r) << BigInt(32)) + BigInt(o);
              })),
              (l.prototype.readIntLE = function (t, e, n) {
                (t >>>= 0), (e >>>= 0), n || P(t, e, this.length);
                let r = this[t],
                  o = 1,
                  i = 0;
                for (; ++i < e && (o *= 256); ) r += this[t + i] * o;
                return (o *= 128), r >= o && (r -= Math.pow(2, 8 * e)), r;
              }),
              (l.prototype.readIntBE = function (t, e, n) {
                (t >>>= 0), (e >>>= 0), n || P(t, e, this.length);
                let r = e,
                  o = 1,
                  i = this[t + --r];
                for (; r > 0 && (o *= 256); ) i += this[t + --r] * o;
                return (o *= 128), i >= o && (i -= Math.pow(2, 8 * e)), i;
              }),
              (l.prototype.readInt8 = function (t, e) {
                return (
                  (t >>>= 0),
                  e || P(t, 1, this.length),
                  128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
                );
              }),
              (l.prototype.readInt16LE = function (t, e) {
                (t >>>= 0), e || P(t, 2, this.length);
                const n = this[t] | (this[t + 1] << 8);
                return 32768 & n ? 4294901760 | n : n;
              }),
              (l.prototype.readInt16BE = function (t, e) {
                (t >>>= 0), e || P(t, 2, this.length);
                const n = this[t + 1] | (this[t] << 8);
                return 32768 & n ? 4294901760 | n : n;
              }),
              (l.prototype.readInt32LE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || P(t, 4, this.length),
                  this[t] |
                    (this[t + 1] << 8) |
                    (this[t + 2] << 16) |
                    (this[t + 3] << 24)
                );
              }),
              (l.prototype.readInt32BE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || P(t, 4, this.length),
                  (this[t] << 24) |
                    (this[t + 1] << 16) |
                    (this[t + 2] << 8) |
                    this[t + 3]
                );
              }),
              (l.prototype.readBigInt64LE = et(function (t) {
                V((t >>>= 0), "offset");
                const e = this[t],
                  n = this[t + 7];
                (void 0 !== e && void 0 !== n) || F(t, this.length - 8);
                const r =
                  this[t + 4] +
                  256 * this[t + 5] +
                  65536 * this[t + 6] +
                  (n << 24);
                return (
                  (BigInt(r) << BigInt(32)) +
                  BigInt(
                    e +
                      256 * this[++t] +
                      65536 * this[++t] +
                      this[++t] * 2 ** 24
                  )
                );
              })),
              (l.prototype.readBigInt64BE = et(function (t) {
                V((t >>>= 0), "offset");
                const e = this[t],
                  n = this[t + 7];
                (void 0 !== e && void 0 !== n) || F(t, this.length - 8);
                const r =
                  (e << 24) + 65536 * this[++t] + 256 * this[++t] + this[++t];
                return (
                  (BigInt(r) << BigInt(32)) +
                  BigInt(
                    this[++t] * 2 ** 24 +
                      65536 * this[++t] +
                      256 * this[++t] +
                      n
                  )
                );
              })),
              (l.prototype.readFloatLE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || P(t, 4, this.length),
                  r.read(this, t, !0, 23, 4)
                );
              }),
              (l.prototype.readFloatBE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || P(t, 4, this.length),
                  r.read(this, t, !1, 23, 4)
                );
              }),
              (l.prototype.readDoubleLE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || P(t, 8, this.length),
                  r.read(this, t, !0, 52, 8)
                );
              }),
              (l.prototype.readDoubleBE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || P(t, 8, this.length),
                  r.read(this, t, !1, 52, 8)
                );
              }),
              (l.prototype.writeUintLE = l.prototype.writeUIntLE =
                function (t, e, n, r) {
                  if (((t = +t), (e >>>= 0), (n >>>= 0), !r)) {
                    L(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
                  }
                  let o = 1,
                    i = 0;
                  for (this[e] = 255 & t; ++i < n && (o *= 256); )
                    this[e + i] = (t / o) & 255;
                  return e + n;
                }),
              (l.prototype.writeUintBE = l.prototype.writeUIntBE =
                function (t, e, n, r) {
                  if (((t = +t), (e >>>= 0), (n >>>= 0), !r)) {
                    L(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
                  }
                  let o = n - 1,
                    i = 1;
                  for (this[e + o] = 255 & t; --o >= 0 && (i *= 256); )
                    this[e + o] = (t / i) & 255;
                  return e + n;
                }),
              (l.prototype.writeUint8 = l.prototype.writeUInt8 =
                function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || L(this, t, e, 1, 255, 0),
                    (this[e] = 255 & t),
                    e + 1
                  );
                }),
              (l.prototype.writeUint16LE = l.prototype.writeUInt16LE =
                function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || L(this, t, e, 2, 65535, 0),
                    (this[e] = 255 & t),
                    (this[e + 1] = t >>> 8),
                    e + 2
                  );
                }),
              (l.prototype.writeUint16BE = l.prototype.writeUInt16BE =
                function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || L(this, t, e, 2, 65535, 0),
                    (this[e] = t >>> 8),
                    (this[e + 1] = 255 & t),
                    e + 2
                  );
                }),
              (l.prototype.writeUint32LE = l.prototype.writeUInt32LE =
                function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || L(this, t, e, 4, 4294967295, 0),
                    (this[e + 3] = t >>> 24),
                    (this[e + 2] = t >>> 16),
                    (this[e + 1] = t >>> 8),
                    (this[e] = 255 & t),
                    e + 4
                  );
                }),
              (l.prototype.writeUint32BE = l.prototype.writeUInt32BE =
                function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || L(this, t, e, 4, 4294967295, 0),
                    (this[e] = t >>> 24),
                    (this[e + 1] = t >>> 16),
                    (this[e + 2] = t >>> 8),
                    (this[e + 3] = 255 & t),
                    e + 4
                  );
                }),
              (l.prototype.writeBigUInt64LE = et(function (t, e = 0) {
                return z(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
              })),
              (l.prototype.writeBigUInt64BE = et(function (t, e = 0) {
                return D(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
              })),
              (l.prototype.writeIntLE = function (t, e, n, r) {
                if (((t = +t), (e >>>= 0), !r)) {
                  const r = Math.pow(2, 8 * n - 1);
                  L(this, t, e, n, r - 1, -r);
                }
                let o = 0,
                  i = 1,
                  s = 0;
                for (this[e] = 255 & t; ++o < n && (i *= 256); )
                  t < 0 && 0 === s && 0 !== this[e + o - 1] && (s = 1),
                    (this[e + o] = (((t / i) | 0) - s) & 255);
                return e + n;
              }),
              (l.prototype.writeIntBE = function (t, e, n, r) {
                if (((t = +t), (e >>>= 0), !r)) {
                  const r = Math.pow(2, 8 * n - 1);
                  L(this, t, e, n, r - 1, -r);
                }
                let o = n - 1,
                  i = 1,
                  s = 0;
                for (this[e + o] = 255 & t; --o >= 0 && (i *= 256); )
                  t < 0 && 0 === s && 0 !== this[e + o + 1] && (s = 1),
                    (this[e + o] = (((t / i) | 0) - s) & 255);
                return e + n;
              }),
              (l.prototype.writeInt8 = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || L(this, t, e, 1, 127, -128),
                  t < 0 && (t = 255 + t + 1),
                  (this[e] = 255 & t),
                  e + 1
                );
              }),
              (l.prototype.writeInt16LE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || L(this, t, e, 2, 32767, -32768),
                  (this[e] = 255 & t),
                  (this[e + 1] = t >>> 8),
                  e + 2
                );
              }),
              (l.prototype.writeInt16BE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || L(this, t, e, 2, 32767, -32768),
                  (this[e] = t >>> 8),
                  (this[e + 1] = 255 & t),
                  e + 2
                );
              }),
              (l.prototype.writeInt32LE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || L(this, t, e, 4, 2147483647, -2147483648),
                  (this[e] = 255 & t),
                  (this[e + 1] = t >>> 8),
                  (this[e + 2] = t >>> 16),
                  (this[e + 3] = t >>> 24),
                  e + 4
                );
              }),
              (l.prototype.writeInt32BE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || L(this, t, e, 4, 2147483647, -2147483648),
                  t < 0 && (t = 4294967295 + t + 1),
                  (this[e] = t >>> 24),
                  (this[e + 1] = t >>> 16),
                  (this[e + 2] = t >>> 8),
                  (this[e + 3] = 255 & t),
                  e + 4
                );
              }),
              (l.prototype.writeBigInt64LE = et(function (t, e = 0) {
                return z(
                  this,
                  t,
                  e,
                  -BigInt("0x8000000000000000"),
                  BigInt("0x7fffffffffffffff")
                );
              })),
              (l.prototype.writeBigInt64BE = et(function (t, e = 0) {
                return D(
                  this,
                  t,
                  e,
                  -BigInt("0x8000000000000000"),
                  BigInt("0x7fffffffffffffff")
                );
              })),
              (l.prototype.writeFloatLE = function (t, e, n) {
                return q(this, t, e, !0, n);
              }),
              (l.prototype.writeFloatBE = function (t, e, n) {
                return q(this, t, e, !1, n);
              }),
              (l.prototype.writeDoubleLE = function (t, e, n) {
                return G(this, t, e, !0, n);
              }),
              (l.prototype.writeDoubleBE = function (t, e, n) {
                return G(this, t, e, !1, n);
              }),
              (l.prototype.copy = function (t, e, n, r) {
                if (!l.isBuffer(t))
                  throw new TypeError("argument should be a Buffer");
                if (
                  (n || (n = 0),
                  r || 0 === r || (r = this.length),
                  e >= t.length && (e = t.length),
                  e || (e = 0),
                  r > 0 && r < n && (r = n),
                  r === n)
                )
                  return 0;
                if (0 === t.length || 0 === this.length) return 0;
                if (e < 0) throw new RangeError("targetStart out of bounds");
                if (n < 0 || n >= this.length)
                  throw new RangeError("Index out of range");
                if (r < 0) throw new RangeError("sourceEnd out of bounds");
                r > this.length && (r = this.length),
                  t.length - e < r - n && (r = t.length - e + n);
                const o = r - n;
                return (
                  this === t && "function" == typeof s.prototype.copyWithin
                    ? this.copyWithin(e, n, r)
                    : s.prototype.set.call(t, this.subarray(n, r), e),
                  o
                );
              }),
              (l.prototype.fill = function (t, e, n, r) {
                if ("string" == typeof t) {
                  if (
                    ("string" == typeof e
                      ? ((r = e), (e = 0), (n = this.length))
                      : "string" == typeof n && ((r = n), (n = this.length)),
                    void 0 !== r && "string" != typeof r)
                  )
                    throw new TypeError("encoding must be a string");
                  if ("string" == typeof r && !l.isEncoding(r))
                    throw new TypeError("Unknown encoding: " + r);
                  if (1 === t.length) {
                    const e = t.charCodeAt(0);
                    (("utf8" === r && e < 128) || "latin1" === r) && (t = e);
                  }
                } else
                  "number" == typeof t
                    ? (t &= 255)
                    : "boolean" == typeof t && (t = Number(t));
                if (e < 0 || this.length < e || this.length < n)
                  throw new RangeError("Out of range index");
                if (n <= e) return this;
                let o;
                if (
                  ((e >>>= 0),
                  (n = void 0 === n ? this.length : n >>> 0),
                  t || (t = 0),
                  "number" == typeof t)
                )
                  for (o = e; o < n; ++o) this[o] = t;
                else {
                  const i = l.isBuffer(t) ? t : l.from(t, r),
                    s = i.length;
                  if (0 === s)
                    throw new TypeError(
                      'The value "' + t + '" is invalid for argument "value"'
                    );
                  for (o = 0; o < n - e; ++o) this[o + e] = i[o % s];
                }
                return this;
              });
            const W = {};
            function K(t, e, n) {
              W[t] = class extends n {
                constructor() {
                  super(),
                    Object.defineProperty(this, "message", {
                      value: e.apply(this, arguments),
                      writable: !0,
                      configurable: !0,
                    }),
                    (this.name = `${this.name} [${t}]`),
                    this.stack,
                    delete this.name;
                }
                get code() {
                  return t;
                }
                set code(t) {
                  Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: t,
                    writable: !0,
                  });
                }
                toString() {
                  return `${this.name} [${t}]: ${this.message}`;
                }
              };
            }
            function j(t) {
              let e = "",
                n = t.length;
              const r = "-" === t[0] ? 1 : 0;
              for (; n >= r + 4; n -= 3) e = `_${t.slice(n - 3, n)}${e}`;
              return `${t.slice(0, n)}${e}`;
            }
            function H(t, e, n, r, o, i) {
              if (t > n || t < e) {
                const n = "bigint" == typeof e ? "n" : "";
                let r;
                throw (
                  ((r =
                    0 === e || e === BigInt(0)
                      ? `>= 0${n} and < 2${n} ** ${8 * (i + 1)}${n}`
                      : `>= -(2${n} ** ${8 * (i + 1) - 1}${n}) and < 2 ** ${
                          8 * (i + 1) - 1
                        }${n}`),
                  new W.ERR_OUT_OF_RANGE("value", r, t))
                );
              }
              !(function (t, e, n) {
                V(e, "offset"),
                  (void 0 !== t[e] && void 0 !== t[e + n]) ||
                    F(e, t.length - (n + 1));
              })(r, o, i);
            }
            function V(t, e) {
              if ("number" != typeof t)
                throw new W.ERR_INVALID_ARG_TYPE(e, "number", t);
            }
            function F(t, e, n) {
              if (Math.floor(t) !== t)
                throw (
                  (V(t, n), new W.ERR_OUT_OF_RANGE("offset", "an integer", t))
                );
              if (e < 0) throw new W.ERR_BUFFER_OUT_OF_BOUNDS();
              throw new W.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${e}`, t);
            }
            K(
              "ERR_BUFFER_OUT_OF_BOUNDS",
              function (t) {
                return t
                  ? `${t} is outside of buffer bounds`
                  : "Attempt to access memory outside buffer bounds";
              },
              RangeError
            ),
              K(
                "ERR_INVALID_ARG_TYPE",
                function (t, e) {
                  return `The "${t}" argument must be of type number. Received type ${typeof e}`;
                },
                TypeError
              ),
              K(
                "ERR_OUT_OF_RANGE",
                function (t, e, n) {
                  let r = `The value of "${t}" is out of range.`,
                    o = n;
                  return (
                    Number.isInteger(n) && Math.abs(n) > 2 ** 32
                      ? (o = j(String(n)))
                      : "bigint" == typeof n &&
                        ((o = String(n)),
                        (n > BigInt(2) ** BigInt(32) ||
                          n < -(BigInt(2) ** BigInt(32))) &&
                          (o = j(o)),
                        (o += "n")),
                    (r += ` It must be ${e}. Received ${o}`),
                    r
                  );
                },
                RangeError
              );
            const Y = /[^+/0-9A-Za-z-_]/g;
            function Z(t, e) {
              let n;
              e = e || 1 / 0;
              const r = t.length;
              let o = null;
              const i = [];
              for (let s = 0; s < r; ++s) {
                if (((n = t.charCodeAt(s)), n > 55295 && n < 57344)) {
                  if (!o) {
                    if (n > 56319) {
                      (e -= 3) > -1 && i.push(239, 191, 189);
                      continue;
                    }
                    if (s + 1 === r) {
                      (e -= 3) > -1 && i.push(239, 191, 189);
                      continue;
                    }
                    o = n;
                    continue;
                  }
                  if (n < 56320) {
                    (e -= 3) > -1 && i.push(239, 191, 189), (o = n);
                    continue;
                  }
                  n = 65536 + (((o - 55296) << 10) | (n - 56320));
                } else o && (e -= 3) > -1 && i.push(239, 191, 189);
                if (((o = null), n < 128)) {
                  if ((e -= 1) < 0) break;
                  i.push(n);
                } else if (n < 2048) {
                  if ((e -= 2) < 0) break;
                  i.push((n >> 6) | 192, (63 & n) | 128);
                } else if (n < 65536) {
                  if ((e -= 3) < 0) break;
                  i.push(
                    (n >> 12) | 224,
                    ((n >> 6) & 63) | 128,
                    (63 & n) | 128
                  );
                } else {
                  if (!(n < 1114112)) throw new Error("Invalid code point");
                  if ((e -= 4) < 0) break;
                  i.push(
                    (n >> 18) | 240,
                    ((n >> 12) & 63) | 128,
                    ((n >> 6) & 63) | 128,
                    (63 & n) | 128
                  );
                }
              }
              return i;
            }
            function J(t) {
              return e.toByteArray(
                (function (t) {
                  if (
                    (t = (t = t.split("=")[0]).trim().replace(Y, "")).length < 2
                  )
                    return "";
                  for (; t.length % 4 != 0; ) t += "=";
                  return t;
                })(t)
              );
            }
            function X(t, e, n, r) {
              let o;
              for (o = 0; o < r && !(o + n >= e.length || o >= t.length); ++o)
                e[o + n] = t[o];
              return o;
            }
            function $(t, e) {
              return (
                t instanceof e ||
                (null != t &&
                  null != t.constructor &&
                  null != t.constructor.name &&
                  t.constructor.name === e.name)
              );
            }
            function Q(t) {
              return t != t;
            }
            const tt = (function () {
              const t = "0123456789abcdef",
                e = new Array(256);
              for (let n = 0; n < 16; ++n) {
                const r = 16 * n;
                for (let o = 0; o < 16; ++o) e[r + o] = t[n] + t[o];
              }
              return e;
            })();
            function et(t) {
              return "undefined" == typeof BigInt ? nt : t;
            }
            function nt() {
              throw new Error("BigInt not supported");
            }
          })(e);
          const d = e.Buffer;
          (t.Blob = e.Blob),
            (t.BlobOptions = e.BlobOptions),
            (t.Buffer = e.Buffer),
            (t.File = e.File),
            (t.FileOptions = e.FileOptions),
            (t.INSPECT_MAX_BYTES = e.INSPECT_MAX_BYTES),
            (t.SlowBuffer = e.SlowBuffer),
            (t.TranscodeEncoding = e.TranscodeEncoding),
            (t.atob = e.atob),
            (t.btoa = e.btoa),
            (t.constants = e.constants),
            (t.default = d),
            (t.isAscii = e.isAscii),
            (t.isUtf8 = e.isUtf8),
            (t.kMaxLength = e.kMaxLength),
            (t.kStringMaxLength = e.kStringMaxLength),
            (t.resolveObjectURL = e.resolveObjectURL),
            (t.transcode = e.transcode);
        })(Bn)),
      Bn
    );
  }
  var Tn,
    Rn = Sn.exports;
  function On() {
    return (
      Tn ||
        ((Tn = 1),
        (t = Sn),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        }),
        (function (t, e) {
          function n(t, e) {
            if (!t) throw new Error(e || "Assertion failed");
          }
          function r(t, e) {
            t.super_ = e;
            var n = function () {};
            (n.prototype = e.prototype),
              (t.prototype = new n()),
              (t.prototype.constructor = t);
          }
          function o(t, e, n) {
            if (o.isBN(t)) return t;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              null !== t &&
                (("le" !== e && "be" !== e) || ((n = e), (e = 10)),
                this._init(t || 0, e || 10, n || "be"));
          }
          var i;
          "object" == typeof t ? (t.exports = o) : (e.BN = o),
            (o.BN = o),
            (o.wordSize = 26);
          try {
            i =
              "undefined" != typeof window && void 0 !== window.Buffer
                ? window.Buffer
                : xn().Buffer;
          } catch (C) {}
          function s(t, e) {
            var r = t.charCodeAt(e);
            return r >= 48 && r <= 57
              ? r - 48
              : r >= 65 && r <= 70
              ? r - 55
              : r >= 97 && r <= 102
              ? r - 87
              : (n(!1, "Invalid character in " + t), void 0);
          }
          function a(t, e, n) {
            var r = s(t, n);
            return n - 1 >= e && (r |= s(t, n - 1) << 4), r;
          }
          function c(t, e, r, o) {
            for (
              var i = 0, s = 0, a = Math.min(t.length, r), c = e;
              c < a;
              c++
            ) {
              var u = t.charCodeAt(c) - 48;
              (i *= o),
                (s = u >= 49 ? u - 49 + 10 : u >= 17 ? u - 17 + 10 : u),
                n(u >= 0 && s < o, "Invalid character"),
                (i += s);
            }
            return i;
          }
          function u(t, e) {
            (t.words = e.words),
              (t.length = e.length),
              (t.negative = e.negative),
              (t.red = e.red);
          }
          if (
            ((o.isBN = function (t) {
              return (
                t instanceof o ||
                (null !== t &&
                  "object" == typeof t &&
                  t.constructor.wordSize === o.wordSize &&
                  Array.isArray(t.words))
              );
            }),
            (o.max = function (t, e) {
              return t.cmp(e) > 0 ? t : e;
            }),
            (o.min = function (t, e) {
              return t.cmp(e) < 0 ? t : e;
            }),
            (o.prototype._init = function (t, e, r) {
              if ("number" == typeof t) return this._initNumber(t, e, r);
              if ("object" == typeof t) return this._initArray(t, e, r);
              "hex" === e && (e = 16), n(e === (0 | e) && e >= 2 && e <= 36);
              var o = 0;
              "-" === (t = t.toString().replace(/\s+/g, ""))[0] &&
                (o++, (this.negative = 1)),
                o < t.length &&
                  (16 === e
                    ? this._parseHex(t, o, r)
                    : (this._parseBase(t, e, o),
                      "le" === r && this._initArray(this.toArray(), e, r)));
            }),
            (o.prototype._initNumber = function (t, e, r) {
              t < 0 && ((this.negative = 1), (t = -t)),
                t < 67108864
                  ? ((this.words = [67108863 & t]), (this.length = 1))
                  : t < 4503599627370496
                  ? ((this.words = [67108863 & t, (t / 67108864) & 67108863]),
                    (this.length = 2))
                  : (n(t < 9007199254740992),
                    (this.words = [67108863 & t, (t / 67108864) & 67108863, 1]),
                    (this.length = 3)),
                "le" === r && this._initArray(this.toArray(), e, r);
            }),
            (o.prototype._initArray = function (t, e, r) {
              if ((n("number" == typeof t.length), t.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(t.length / 3)),
                (this.words = new Array(this.length));
              for (var o = 0; o < this.length; o++) this.words[o] = 0;
              var i,
                s,
                a = 0;
              if ("be" === r)
                for (o = t.length - 1, i = 0; o >= 0; o -= 3)
                  (s = t[o] | (t[o - 1] << 8) | (t[o - 2] << 16)),
                    (this.words[i] |= (s << a) & 67108863),
                    (this.words[i + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), i++);
              else if ("le" === r)
                for (o = 0, i = 0; o < t.length; o += 3)
                  (s = t[o] | (t[o + 1] << 8) | (t[o + 2] << 16)),
                    (this.words[i] |= (s << a) & 67108863),
                    (this.words[i + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), i++);
              return this._strip();
            }),
            (o.prototype._parseHex = function (t, e, n) {
              (this.length = Math.ceil((t.length - e) / 6)),
                (this.words = new Array(this.length));
              for (var r = 0; r < this.length; r++) this.words[r] = 0;
              var o,
                i = 0,
                s = 0;
              if ("be" === n)
                for (r = t.length - 1; r >= e; r -= 2)
                  (o = a(t, e, r) << i),
                    (this.words[s] |= 67108863 & o),
                    i >= 18
                      ? ((i -= 18), (s += 1), (this.words[s] |= o >>> 26))
                      : (i += 8);
              else
                for (
                  r = (t.length - e) % 2 == 0 ? e + 1 : e;
                  r < t.length;
                  r += 2
                )
                  (o = a(t, e, r) << i),
                    (this.words[s] |= 67108863 & o),
                    i >= 18
                      ? ((i -= 18), (s += 1), (this.words[s] |= o >>> 26))
                      : (i += 8);
              this._strip();
            }),
            (o.prototype._parseBase = function (t, e, n) {
              (this.words = [0]), (this.length = 1);
              for (var r = 0, o = 1; o <= 67108863; o *= e) r++;
              r--, (o = (o / e) | 0);
              for (
                var i = t.length - n,
                  s = i % r,
                  a = Math.min(i, i - s) + n,
                  u = 0,
                  l = n;
                l < a;
                l += r
              )
                (u = c(t, l, l + r, e)),
                  this.imuln(o),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              if (0 !== s) {
                var h = 1;
                for (u = c(t, l, t.length, e), l = 0; l < s; l++) h *= e;
                this.imuln(h),
                  this.words[0] + u < 67108864
                    ? (this.words[0] += u)
                    : this._iaddn(u);
              }
              this._strip();
            }),
            (o.prototype.copy = function (t) {
              t.words = new Array(this.length);
              for (var e = 0; e < this.length; e++) t.words[e] = this.words[e];
              (t.length = this.length),
                (t.negative = this.negative),
                (t.red = this.red);
            }),
            (o.prototype._move = function (t) {
              u(t, this);
            }),
            (o.prototype.clone = function () {
              var t = new o(null);
              return this.copy(t), t;
            }),
            (o.prototype._expand = function (t) {
              for (; this.length < t; ) this.words[this.length++] = 0;
              return this;
            }),
            (o.prototype._strip = function () {
              for (; this.length > 1 && 0 === this.words[this.length - 1]; )
                this.length--;
              return this._normSign();
            }),
            (o.prototype._normSign = function () {
              return (
                1 === this.length && 0 === this.words[0] && (this.negative = 0),
                this
              );
            }),
            "undefined" != typeof Symbol && "function" == typeof Symbol.for)
          )
            try {
              o.prototype[Symbol.for("nodejs.util.inspect.custom")] = l;
            } catch (C) {
              o.prototype.inspect = l;
            }
          else o.prototype.inspect = l;
          function l() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
          }
          var h = [
              "",
              "0",
              "00",
              "000",
              "0000",
              "00000",
              "000000",
              "0000000",
              "00000000",
              "000000000",
              "0000000000",
              "00000000000",
              "000000000000",
              "0000000000000",
              "00000000000000",
              "000000000000000",
              "0000000000000000",
              "00000000000000000",
              "000000000000000000",
              "0000000000000000000",
              "00000000000000000000",
              "000000000000000000000",
              "0000000000000000000000",
              "00000000000000000000000",
              "000000000000000000000000",
              "0000000000000000000000000",
            ],
            d = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6,
              6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            f = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
              16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
              11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
              5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
              20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
              60466176,
            ];
          function p(t, e, n) {
            n.negative = e.negative ^ t.negative;
            var r = (t.length + e.length) | 0;
            (n.length = r), (r = (r - 1) | 0);
            var o = 0 | t.words[0],
              i = 0 | e.words[0],
              s = o * i,
              a = 67108863 & s,
              c = (s / 67108864) | 0;
            n.words[0] = a;
            for (var u = 1; u < r; u++) {
              for (
                var l = c >>> 26,
                  h = 67108863 & c,
                  d = Math.min(u, e.length - 1),
                  f = Math.max(0, u - t.length + 1);
                f <= d;
                f++
              ) {
                var p = (u - f) | 0;
                (l +=
                  ((s = (o = 0 | t.words[p]) * (i = 0 | e.words[f]) + h) /
                    67108864) |
                  0),
                  (h = 67108863 & s);
              }
              (n.words[u] = 0 | h), (c = 0 | l);
            }
            return 0 !== c ? (n.words[u] = 0 | c) : n.length--, n._strip();
          }
          (o.prototype.toString = function (t, e) {
            var r;
            if (((e = 0 | e || 1), 16 === (t = t || 10) || "hex" === t)) {
              r = "";
              for (var o = 0, i = 0, s = 0; s < this.length; s++) {
                var a = this.words[s],
                  c = (16777215 & ((a << o) | i)).toString(16);
                (i = (a >>> (24 - o)) & 16777215),
                  (o += 2) >= 26 && ((o -= 26), s--),
                  (r =
                    0 !== i || s !== this.length - 1
                      ? h[6 - c.length] + c + r
                      : c + r);
              }
              for (0 !== i && (r = i.toString(16) + r); r.length % e !== 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            if (t === (0 | t) && t >= 2 && t <= 36) {
              var u = d[t],
                l = f[t];
              r = "";
              var p = this.clone();
              for (p.negative = 0; !p.isZero(); ) {
                var m = p.modrn(l).toString(t);
                r = (p = p.idivn(l)).isZero() ? m + r : h[u - m.length] + m + r;
              }
              for (this.isZero() && (r = "0" + r); r.length % e !== 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            n(!1, "Base should be between 2 and 36");
          }),
            (o.prototype.toNumber = function () {
              var t = this.words[0];
              return (
                2 === this.length
                  ? (t += 67108864 * this.words[1])
                  : 3 === this.length && 1 === this.words[2]
                  ? (t += 4503599627370496 + 67108864 * this.words[1])
                  : this.length > 2 &&
                    n(!1, "Number can only safely store up to 53 bits"),
                0 !== this.negative ? -t : t
              );
            }),
            (o.prototype.toJSON = function () {
              return this.toString(16, 2);
            }),
            i &&
              (o.prototype.toBuffer = function (t, e) {
                return this.toArrayLike(i, t, e);
              }),
            (o.prototype.toArray = function (t, e) {
              return this.toArrayLike(Array, t, e);
            }),
            (o.prototype.toArrayLike = function (t, e, r) {
              this._strip();
              var o = this.byteLength(),
                i = r || Math.max(1, o);
              n(o <= i, "byte array longer than desired length"),
                n(i > 0, "Requested array length <= 0");
              var s = (function (t, e) {
                return t.allocUnsafe ? t.allocUnsafe(e) : new t(e);
              })(t, i);
              return this["_toArrayLike" + ("le" === e ? "LE" : "BE")](s, o), s;
            }),
            (o.prototype._toArrayLikeLE = function (t, e) {
              for (var n = 0, r = 0, o = 0, i = 0; o < this.length; o++) {
                var s = (this.words[o] << i) | r;
                (t[n++] = 255 & s),
                  n < t.length && (t[n++] = (s >> 8) & 255),
                  n < t.length && (t[n++] = (s >> 16) & 255),
                  6 === i
                    ? (n < t.length && (t[n++] = (s >> 24) & 255),
                      (r = 0),
                      (i = 0))
                    : ((r = s >>> 24), (i += 2));
              }
              if (n < t.length) for (t[n++] = r; n < t.length; ) t[n++] = 0;
            }),
            (o.prototype._toArrayLikeBE = function (t, e) {
              for (
                var n = t.length - 1, r = 0, o = 0, i = 0;
                o < this.length;
                o++
              ) {
                var s = (this.words[o] << i) | r;
                (t[n--] = 255 & s),
                  n >= 0 && (t[n--] = (s >> 8) & 255),
                  n >= 0 && (t[n--] = (s >> 16) & 255),
                  6 === i
                    ? (n >= 0 && (t[n--] = (s >> 24) & 255), (r = 0), (i = 0))
                    : ((r = s >>> 24), (i += 2));
              }
              if (n >= 0) for (t[n--] = r; n >= 0; ) t[n--] = 0;
            }),
            Math.clz32
              ? (o.prototype._countBits = function (t) {
                  return 32 - Math.clz32(t);
                })
              : (o.prototype._countBits = function (t) {
                  var e = t,
                    n = 0;
                  return (
                    e >= 4096 && ((n += 13), (e >>>= 13)),
                    e >= 64 && ((n += 7), (e >>>= 7)),
                    e >= 8 && ((n += 4), (e >>>= 4)),
                    e >= 2 && ((n += 2), (e >>>= 2)),
                    n + e
                  );
                }),
            (o.prototype._zeroBits = function (t) {
              if (0 === t) return 26;
              var e = t,
                n = 0;
              return (
                8191 & e || ((n += 13), (e >>>= 13)),
                127 & e || ((n += 7), (e >>>= 7)),
                15 & e || ((n += 4), (e >>>= 4)),
                3 & e || ((n += 2), (e >>>= 2)),
                1 & e || n++,
                n
              );
            }),
            (o.prototype.bitLength = function () {
              var t = this.words[this.length - 1],
                e = this._countBits(t);
              return 26 * (this.length - 1) + e;
            }),
            (o.prototype.zeroBits = function () {
              if (this.isZero()) return 0;
              for (var t = 0, e = 0; e < this.length; e++) {
                var n = this._zeroBits(this.words[e]);
                if (((t += n), 26 !== n)) break;
              }
              return t;
            }),
            (o.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (o.prototype.toTwos = function (t) {
              return 0 !== this.negative
                ? this.abs().inotn(t).iaddn(1)
                : this.clone();
            }),
            (o.prototype.fromTwos = function (t) {
              return this.testn(t - 1)
                ? this.notn(t).iaddn(1).ineg()
                : this.clone();
            }),
            (o.prototype.isNeg = function () {
              return 0 !== this.negative;
            }),
            (o.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (o.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (o.prototype.iuor = function (t) {
              for (; this.length < t.length; ) this.words[this.length++] = 0;
              for (var e = 0; e < t.length; e++)
                this.words[e] = this.words[e] | t.words[e];
              return this._strip();
            }),
            (o.prototype.ior = function (t) {
              return n(0 === (this.negative | t.negative)), this.iuor(t);
            }),
            (o.prototype.or = function (t) {
              return this.length > t.length
                ? this.clone().ior(t)
                : t.clone().ior(this);
            }),
            (o.prototype.uor = function (t) {
              return this.length > t.length
                ? this.clone().iuor(t)
                : t.clone().iuor(this);
            }),
            (o.prototype.iuand = function (t) {
              var e;
              e = this.length > t.length ? t : this;
              for (var n = 0; n < e.length; n++)
                this.words[n] = this.words[n] & t.words[n];
              return (this.length = e.length), this._strip();
            }),
            (o.prototype.iand = function (t) {
              return n(0 === (this.negative | t.negative)), this.iuand(t);
            }),
            (o.prototype.and = function (t) {
              return this.length > t.length
                ? this.clone().iand(t)
                : t.clone().iand(this);
            }),
            (o.prototype.uand = function (t) {
              return this.length > t.length
                ? this.clone().iuand(t)
                : t.clone().iuand(this);
            }),
            (o.prototype.iuxor = function (t) {
              var e, n;
              this.length > t.length
                ? ((e = this), (n = t))
                : ((e = t), (n = this));
              for (var r = 0; r < n.length; r++)
                this.words[r] = e.words[r] ^ n.words[r];
              if (this !== e)
                for (; r < e.length; r++) this.words[r] = e.words[r];
              return (this.length = e.length), this._strip();
            }),
            (o.prototype.ixor = function (t) {
              return n(0 === (this.negative | t.negative)), this.iuxor(t);
            }),
            (o.prototype.xor = function (t) {
              return this.length > t.length
                ? this.clone().ixor(t)
                : t.clone().ixor(this);
            }),
            (o.prototype.uxor = function (t) {
              return this.length > t.length
                ? this.clone().iuxor(t)
                : t.clone().iuxor(this);
            }),
            (o.prototype.inotn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = 0 | Math.ceil(t / 26),
                r = t % 26;
              this._expand(e), r > 0 && e--;
              for (var o = 0; o < e; o++)
                this.words[o] = 67108863 & ~this.words[o];
              return (
                r > 0 &&
                  (this.words[o] = ~this.words[o] & (67108863 >> (26 - r))),
                this._strip()
              );
            }),
            (o.prototype.notn = function (t) {
              return this.clone().inotn(t);
            }),
            (o.prototype.setn = function (t, e) {
              n("number" == typeof t && t >= 0);
              var r = (t / 26) | 0,
                o = t % 26;
              return (
                this._expand(r + 1),
                (this.words[r] = e
                  ? this.words[r] | (1 << o)
                  : this.words[r] & ~(1 << o)),
                this._strip()
              );
            }),
            (o.prototype.iadd = function (t) {
              var e, n, r;
              if (0 !== this.negative && 0 === t.negative)
                return (
                  (this.negative = 0),
                  (e = this.isub(t)),
                  (this.negative ^= 1),
                  this._normSign()
                );
              if (0 === this.negative && 0 !== t.negative)
                return (
                  (t.negative = 0),
                  (e = this.isub(t)),
                  (t.negative = 1),
                  e._normSign()
                );
              this.length > t.length
                ? ((n = this), (r = t))
                : ((n = t), (r = this));
              for (var o = 0, i = 0; i < r.length; i++)
                (e = (0 | n.words[i]) + (0 | r.words[i]) + o),
                  (this.words[i] = 67108863 & e),
                  (o = e >>> 26);
              for (; 0 !== o && i < n.length; i++)
                (e = (0 | n.words[i]) + o),
                  (this.words[i] = 67108863 & e),
                  (o = e >>> 26);
              if (((this.length = n.length), 0 !== o))
                (this.words[this.length] = o), this.length++;
              else if (n !== this)
                for (; i < n.length; i++) this.words[i] = n.words[i];
              return this;
            }),
            (o.prototype.add = function (t) {
              var e;
              return 0 !== t.negative && 0 === this.negative
                ? ((t.negative = 0), (e = this.sub(t)), (t.negative ^= 1), e)
                : 0 === t.negative && 0 !== this.negative
                ? ((this.negative = 0),
                  (e = t.sub(this)),
                  (this.negative = 1),
                  e)
                : this.length > t.length
                ? this.clone().iadd(t)
                : t.clone().iadd(this);
            }),
            (o.prototype.isub = function (t) {
              if (0 !== t.negative) {
                t.negative = 0;
                var e = this.iadd(t);
                return (t.negative = 1), e._normSign();
              }
              if (0 !== this.negative)
                return (
                  (this.negative = 0),
                  this.iadd(t),
                  (this.negative = 1),
                  this._normSign()
                );
              var n,
                r,
                o = this.cmp(t);
              if (0 === o)
                return (
                  (this.negative = 0),
                  (this.length = 1),
                  (this.words[0] = 0),
                  this
                );
              o > 0 ? ((n = this), (r = t)) : ((n = t), (r = this));
              for (var i = 0, s = 0; s < r.length; s++)
                (i = (e = (0 | n.words[s]) - (0 | r.words[s]) + i) >> 26),
                  (this.words[s] = 67108863 & e);
              for (; 0 !== i && s < n.length; s++)
                (i = (e = (0 | n.words[s]) + i) >> 26),
                  (this.words[s] = 67108863 & e);
              if (0 === i && s < n.length && n !== this)
                for (; s < n.length; s++) this.words[s] = n.words[s];
              return (
                (this.length = Math.max(this.length, s)),
                n !== this && (this.negative = 1),
                this._strip()
              );
            }),
            (o.prototype.sub = function (t) {
              return this.clone().isub(t);
            });
          var m = function (t, e, n) {
            var r,
              o,
              i,
              s = t.words,
              a = e.words,
              c = n.words,
              u = 0,
              l = 0 | s[0],
              h = 8191 & l,
              d = l >>> 13,
              f = 0 | s[1],
              p = 8191 & f,
              m = f >>> 13,
              y = 0 | s[2],
              g = 8191 & y,
              w = y >>> 13,
              b = 0 | s[3],
              v = 8191 & b,
              _ = b >>> 13,
              k = 0 | s[4],
              A = 8191 & k,
              E = k >>> 13,
              I = 0 | s[5],
              C = 8191 & I,
              S = I >>> 13,
              B = 0 | s[6],
              x = 8191 & B,
              T = B >>> 13,
              R = 0 | s[7],
              O = 8191 & R,
              M = R >>> 13,
              N = 0 | s[8],
              P = 8191 & N,
              L = N >>> 13,
              z = 0 | s[9],
              D = 8191 & z,
              U = z >>> 13,
              q = 0 | a[0],
              G = 8191 & q,
              W = q >>> 13,
              K = 0 | a[1],
              j = 8191 & K,
              H = K >>> 13,
              V = 0 | a[2],
              F = 8191 & V,
              Y = V >>> 13,
              Z = 0 | a[3],
              J = 8191 & Z,
              X = Z >>> 13,
              $ = 0 | a[4],
              Q = 8191 & $,
              tt = $ >>> 13,
              et = 0 | a[5],
              nt = 8191 & et,
              rt = et >>> 13,
              ot = 0 | a[6],
              it = 8191 & ot,
              st = ot >>> 13,
              at = 0 | a[7],
              ct = 8191 & at,
              ut = at >>> 13,
              lt = 0 | a[8],
              ht = 8191 & lt,
              dt = lt >>> 13,
              ft = 0 | a[9],
              pt = 8191 & ft,
              mt = ft >>> 13;
            (n.negative = t.negative ^ e.negative), (n.length = 19);
            var yt =
              (((u + (r = Math.imul(h, G))) | 0) +
                ((8191 & (o = ((o = Math.imul(h, W)) + Math.imul(d, G)) | 0)) <<
                  13)) |
              0;
            (u =
              ((((i = Math.imul(d, W)) + (o >>> 13)) | 0) + (yt >>> 26)) | 0),
              (yt &= 67108863),
              (r = Math.imul(p, G)),
              (o = ((o = Math.imul(p, W)) + Math.imul(m, G)) | 0),
              (i = Math.imul(m, W));
            var gt =
              (((u + (r = (r + Math.imul(h, j)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(h, H)) | 0) + Math.imul(d, j)) | 0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(d, H)) | 0) + (o >>> 13)) | 0) +
                (gt >>> 26)) |
              0),
              (gt &= 67108863),
              (r = Math.imul(g, G)),
              (o = ((o = Math.imul(g, W)) + Math.imul(w, G)) | 0),
              (i = Math.imul(w, W)),
              (r = (r + Math.imul(p, j)) | 0),
              (o = ((o = (o + Math.imul(p, H)) | 0) + Math.imul(m, j)) | 0),
              (i = (i + Math.imul(m, H)) | 0);
            var wt =
              (((u + (r = (r + Math.imul(h, F)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(h, Y)) | 0) + Math.imul(d, F)) | 0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(d, Y)) | 0) + (o >>> 13)) | 0) +
                (wt >>> 26)) |
              0),
              (wt &= 67108863),
              (r = Math.imul(v, G)),
              (o = ((o = Math.imul(v, W)) + Math.imul(_, G)) | 0),
              (i = Math.imul(_, W)),
              (r = (r + Math.imul(g, j)) | 0),
              (o = ((o = (o + Math.imul(g, H)) | 0) + Math.imul(w, j)) | 0),
              (i = (i + Math.imul(w, H)) | 0),
              (r = (r + Math.imul(p, F)) | 0),
              (o = ((o = (o + Math.imul(p, Y)) | 0) + Math.imul(m, F)) | 0),
              (i = (i + Math.imul(m, Y)) | 0);
            var bt =
              (((u + (r = (r + Math.imul(h, J)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(h, X)) | 0) + Math.imul(d, J)) | 0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(d, X)) | 0) + (o >>> 13)) | 0) +
                (bt >>> 26)) |
              0),
              (bt &= 67108863),
              (r = Math.imul(A, G)),
              (o = ((o = Math.imul(A, W)) + Math.imul(E, G)) | 0),
              (i = Math.imul(E, W)),
              (r = (r + Math.imul(v, j)) | 0),
              (o = ((o = (o + Math.imul(v, H)) | 0) + Math.imul(_, j)) | 0),
              (i = (i + Math.imul(_, H)) | 0),
              (r = (r + Math.imul(g, F)) | 0),
              (o = ((o = (o + Math.imul(g, Y)) | 0) + Math.imul(w, F)) | 0),
              (i = (i + Math.imul(w, Y)) | 0),
              (r = (r + Math.imul(p, J)) | 0),
              (o = ((o = (o + Math.imul(p, X)) | 0) + Math.imul(m, J)) | 0),
              (i = (i + Math.imul(m, X)) | 0);
            var vt =
              (((u + (r = (r + Math.imul(h, Q)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(h, tt)) | 0) + Math.imul(d, Q)) |
                    0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(d, tt)) | 0) + (o >>> 13)) | 0) +
                (vt >>> 26)) |
              0),
              (vt &= 67108863),
              (r = Math.imul(C, G)),
              (o = ((o = Math.imul(C, W)) + Math.imul(S, G)) | 0),
              (i = Math.imul(S, W)),
              (r = (r + Math.imul(A, j)) | 0),
              (o = ((o = (o + Math.imul(A, H)) | 0) + Math.imul(E, j)) | 0),
              (i = (i + Math.imul(E, H)) | 0),
              (r = (r + Math.imul(v, F)) | 0),
              (o = ((o = (o + Math.imul(v, Y)) | 0) + Math.imul(_, F)) | 0),
              (i = (i + Math.imul(_, Y)) | 0),
              (r = (r + Math.imul(g, J)) | 0),
              (o = ((o = (o + Math.imul(g, X)) | 0) + Math.imul(w, J)) | 0),
              (i = (i + Math.imul(w, X)) | 0),
              (r = (r + Math.imul(p, Q)) | 0),
              (o = ((o = (o + Math.imul(p, tt)) | 0) + Math.imul(m, Q)) | 0),
              (i = (i + Math.imul(m, tt)) | 0);
            var _t =
              (((u + (r = (r + Math.imul(h, nt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(h, rt)) | 0) + Math.imul(d, nt)) |
                    0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(d, rt)) | 0) + (o >>> 13)) | 0) +
                (_t >>> 26)) |
              0),
              (_t &= 67108863),
              (r = Math.imul(x, G)),
              (o = ((o = Math.imul(x, W)) + Math.imul(T, G)) | 0),
              (i = Math.imul(T, W)),
              (r = (r + Math.imul(C, j)) | 0),
              (o = ((o = (o + Math.imul(C, H)) | 0) + Math.imul(S, j)) | 0),
              (i = (i + Math.imul(S, H)) | 0),
              (r = (r + Math.imul(A, F)) | 0),
              (o = ((o = (o + Math.imul(A, Y)) | 0) + Math.imul(E, F)) | 0),
              (i = (i + Math.imul(E, Y)) | 0),
              (r = (r + Math.imul(v, J)) | 0),
              (o = ((o = (o + Math.imul(v, X)) | 0) + Math.imul(_, J)) | 0),
              (i = (i + Math.imul(_, X)) | 0),
              (r = (r + Math.imul(g, Q)) | 0),
              (o = ((o = (o + Math.imul(g, tt)) | 0) + Math.imul(w, Q)) | 0),
              (i = (i + Math.imul(w, tt)) | 0),
              (r = (r + Math.imul(p, nt)) | 0),
              (o = ((o = (o + Math.imul(p, rt)) | 0) + Math.imul(m, nt)) | 0),
              (i = (i + Math.imul(m, rt)) | 0);
            var kt =
              (((u + (r = (r + Math.imul(h, it)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(h, st)) | 0) + Math.imul(d, it)) |
                    0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(d, st)) | 0) + (o >>> 13)) | 0) +
                (kt >>> 26)) |
              0),
              (kt &= 67108863),
              (r = Math.imul(O, G)),
              (o = ((o = Math.imul(O, W)) + Math.imul(M, G)) | 0),
              (i = Math.imul(M, W)),
              (r = (r + Math.imul(x, j)) | 0),
              (o = ((o = (o + Math.imul(x, H)) | 0) + Math.imul(T, j)) | 0),
              (i = (i + Math.imul(T, H)) | 0),
              (r = (r + Math.imul(C, F)) | 0),
              (o = ((o = (o + Math.imul(C, Y)) | 0) + Math.imul(S, F)) | 0),
              (i = (i + Math.imul(S, Y)) | 0),
              (r = (r + Math.imul(A, J)) | 0),
              (o = ((o = (o + Math.imul(A, X)) | 0) + Math.imul(E, J)) | 0),
              (i = (i + Math.imul(E, X)) | 0),
              (r = (r + Math.imul(v, Q)) | 0),
              (o = ((o = (o + Math.imul(v, tt)) | 0) + Math.imul(_, Q)) | 0),
              (i = (i + Math.imul(_, tt)) | 0),
              (r = (r + Math.imul(g, nt)) | 0),
              (o = ((o = (o + Math.imul(g, rt)) | 0) + Math.imul(w, nt)) | 0),
              (i = (i + Math.imul(w, rt)) | 0),
              (r = (r + Math.imul(p, it)) | 0),
              (o = ((o = (o + Math.imul(p, st)) | 0) + Math.imul(m, it)) | 0),
              (i = (i + Math.imul(m, st)) | 0);
            var At =
              (((u + (r = (r + Math.imul(h, ct)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(h, ut)) | 0) + Math.imul(d, ct)) |
                    0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(d, ut)) | 0) + (o >>> 13)) | 0) +
                (At >>> 26)) |
              0),
              (At &= 67108863),
              (r = Math.imul(P, G)),
              (o = ((o = Math.imul(P, W)) + Math.imul(L, G)) | 0),
              (i = Math.imul(L, W)),
              (r = (r + Math.imul(O, j)) | 0),
              (o = ((o = (o + Math.imul(O, H)) | 0) + Math.imul(M, j)) | 0),
              (i = (i + Math.imul(M, H)) | 0),
              (r = (r + Math.imul(x, F)) | 0),
              (o = ((o = (o + Math.imul(x, Y)) | 0) + Math.imul(T, F)) | 0),
              (i = (i + Math.imul(T, Y)) | 0),
              (r = (r + Math.imul(C, J)) | 0),
              (o = ((o = (o + Math.imul(C, X)) | 0) + Math.imul(S, J)) | 0),
              (i = (i + Math.imul(S, X)) | 0),
              (r = (r + Math.imul(A, Q)) | 0),
              (o = ((o = (o + Math.imul(A, tt)) | 0) + Math.imul(E, Q)) | 0),
              (i = (i + Math.imul(E, tt)) | 0),
              (r = (r + Math.imul(v, nt)) | 0),
              (o = ((o = (o + Math.imul(v, rt)) | 0) + Math.imul(_, nt)) | 0),
              (i = (i + Math.imul(_, rt)) | 0),
              (r = (r + Math.imul(g, it)) | 0),
              (o = ((o = (o + Math.imul(g, st)) | 0) + Math.imul(w, it)) | 0),
              (i = (i + Math.imul(w, st)) | 0),
              (r = (r + Math.imul(p, ct)) | 0),
              (o = ((o = (o + Math.imul(p, ut)) | 0) + Math.imul(m, ct)) | 0),
              (i = (i + Math.imul(m, ut)) | 0);
            var Et =
              (((u + (r = (r + Math.imul(h, ht)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(h, dt)) | 0) + Math.imul(d, ht)) |
                    0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(d, dt)) | 0) + (o >>> 13)) | 0) +
                (Et >>> 26)) |
              0),
              (Et &= 67108863),
              (r = Math.imul(D, G)),
              (o = ((o = Math.imul(D, W)) + Math.imul(U, G)) | 0),
              (i = Math.imul(U, W)),
              (r = (r + Math.imul(P, j)) | 0),
              (o = ((o = (o + Math.imul(P, H)) | 0) + Math.imul(L, j)) | 0),
              (i = (i + Math.imul(L, H)) | 0),
              (r = (r + Math.imul(O, F)) | 0),
              (o = ((o = (o + Math.imul(O, Y)) | 0) + Math.imul(M, F)) | 0),
              (i = (i + Math.imul(M, Y)) | 0),
              (r = (r + Math.imul(x, J)) | 0),
              (o = ((o = (o + Math.imul(x, X)) | 0) + Math.imul(T, J)) | 0),
              (i = (i + Math.imul(T, X)) | 0),
              (r = (r + Math.imul(C, Q)) | 0),
              (o = ((o = (o + Math.imul(C, tt)) | 0) + Math.imul(S, Q)) | 0),
              (i = (i + Math.imul(S, tt)) | 0),
              (r = (r + Math.imul(A, nt)) | 0),
              (o = ((o = (o + Math.imul(A, rt)) | 0) + Math.imul(E, nt)) | 0),
              (i = (i + Math.imul(E, rt)) | 0),
              (r = (r + Math.imul(v, it)) | 0),
              (o = ((o = (o + Math.imul(v, st)) | 0) + Math.imul(_, it)) | 0),
              (i = (i + Math.imul(_, st)) | 0),
              (r = (r + Math.imul(g, ct)) | 0),
              (o = ((o = (o + Math.imul(g, ut)) | 0) + Math.imul(w, ct)) | 0),
              (i = (i + Math.imul(w, ut)) | 0),
              (r = (r + Math.imul(p, ht)) | 0),
              (o = ((o = (o + Math.imul(p, dt)) | 0) + Math.imul(m, ht)) | 0),
              (i = (i + Math.imul(m, dt)) | 0);
            var It =
              (((u + (r = (r + Math.imul(h, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(h, mt)) | 0) + Math.imul(d, pt)) |
                    0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(d, mt)) | 0) + (o >>> 13)) | 0) +
                (It >>> 26)) |
              0),
              (It &= 67108863),
              (r = Math.imul(D, j)),
              (o = ((o = Math.imul(D, H)) + Math.imul(U, j)) | 0),
              (i = Math.imul(U, H)),
              (r = (r + Math.imul(P, F)) | 0),
              (o = ((o = (o + Math.imul(P, Y)) | 0) + Math.imul(L, F)) | 0),
              (i = (i + Math.imul(L, Y)) | 0),
              (r = (r + Math.imul(O, J)) | 0),
              (o = ((o = (o + Math.imul(O, X)) | 0) + Math.imul(M, J)) | 0),
              (i = (i + Math.imul(M, X)) | 0),
              (r = (r + Math.imul(x, Q)) | 0),
              (o = ((o = (o + Math.imul(x, tt)) | 0) + Math.imul(T, Q)) | 0),
              (i = (i + Math.imul(T, tt)) | 0),
              (r = (r + Math.imul(C, nt)) | 0),
              (o = ((o = (o + Math.imul(C, rt)) | 0) + Math.imul(S, nt)) | 0),
              (i = (i + Math.imul(S, rt)) | 0),
              (r = (r + Math.imul(A, it)) | 0),
              (o = ((o = (o + Math.imul(A, st)) | 0) + Math.imul(E, it)) | 0),
              (i = (i + Math.imul(E, st)) | 0),
              (r = (r + Math.imul(v, ct)) | 0),
              (o = ((o = (o + Math.imul(v, ut)) | 0) + Math.imul(_, ct)) | 0),
              (i = (i + Math.imul(_, ut)) | 0),
              (r = (r + Math.imul(g, ht)) | 0),
              (o = ((o = (o + Math.imul(g, dt)) | 0) + Math.imul(w, ht)) | 0),
              (i = (i + Math.imul(w, dt)) | 0);
            var Ct =
              (((u + (r = (r + Math.imul(p, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(p, mt)) | 0) + Math.imul(m, pt)) |
                    0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(m, mt)) | 0) + (o >>> 13)) | 0) +
                (Ct >>> 26)) |
              0),
              (Ct &= 67108863),
              (r = Math.imul(D, F)),
              (o = ((o = Math.imul(D, Y)) + Math.imul(U, F)) | 0),
              (i = Math.imul(U, Y)),
              (r = (r + Math.imul(P, J)) | 0),
              (o = ((o = (o + Math.imul(P, X)) | 0) + Math.imul(L, J)) | 0),
              (i = (i + Math.imul(L, X)) | 0),
              (r = (r + Math.imul(O, Q)) | 0),
              (o = ((o = (o + Math.imul(O, tt)) | 0) + Math.imul(M, Q)) | 0),
              (i = (i + Math.imul(M, tt)) | 0),
              (r = (r + Math.imul(x, nt)) | 0),
              (o = ((o = (o + Math.imul(x, rt)) | 0) + Math.imul(T, nt)) | 0),
              (i = (i + Math.imul(T, rt)) | 0),
              (r = (r + Math.imul(C, it)) | 0),
              (o = ((o = (o + Math.imul(C, st)) | 0) + Math.imul(S, it)) | 0),
              (i = (i + Math.imul(S, st)) | 0),
              (r = (r + Math.imul(A, ct)) | 0),
              (o = ((o = (o + Math.imul(A, ut)) | 0) + Math.imul(E, ct)) | 0),
              (i = (i + Math.imul(E, ut)) | 0),
              (r = (r + Math.imul(v, ht)) | 0),
              (o = ((o = (o + Math.imul(v, dt)) | 0) + Math.imul(_, ht)) | 0),
              (i = (i + Math.imul(_, dt)) | 0);
            var St =
              (((u + (r = (r + Math.imul(g, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(g, mt)) | 0) + Math.imul(w, pt)) |
                    0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(w, mt)) | 0) + (o >>> 13)) | 0) +
                (St >>> 26)) |
              0),
              (St &= 67108863),
              (r = Math.imul(D, J)),
              (o = ((o = Math.imul(D, X)) + Math.imul(U, J)) | 0),
              (i = Math.imul(U, X)),
              (r = (r + Math.imul(P, Q)) | 0),
              (o = ((o = (o + Math.imul(P, tt)) | 0) + Math.imul(L, Q)) | 0),
              (i = (i + Math.imul(L, tt)) | 0),
              (r = (r + Math.imul(O, nt)) | 0),
              (o = ((o = (o + Math.imul(O, rt)) | 0) + Math.imul(M, nt)) | 0),
              (i = (i + Math.imul(M, rt)) | 0),
              (r = (r + Math.imul(x, it)) | 0),
              (o = ((o = (o + Math.imul(x, st)) | 0) + Math.imul(T, it)) | 0),
              (i = (i + Math.imul(T, st)) | 0),
              (r = (r + Math.imul(C, ct)) | 0),
              (o = ((o = (o + Math.imul(C, ut)) | 0) + Math.imul(S, ct)) | 0),
              (i = (i + Math.imul(S, ut)) | 0),
              (r = (r + Math.imul(A, ht)) | 0),
              (o = ((o = (o + Math.imul(A, dt)) | 0) + Math.imul(E, ht)) | 0),
              (i = (i + Math.imul(E, dt)) | 0);
            var Bt =
              (((u + (r = (r + Math.imul(v, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(v, mt)) | 0) + Math.imul(_, pt)) |
                    0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(_, mt)) | 0) + (o >>> 13)) | 0) +
                (Bt >>> 26)) |
              0),
              (Bt &= 67108863),
              (r = Math.imul(D, Q)),
              (o = ((o = Math.imul(D, tt)) + Math.imul(U, Q)) | 0),
              (i = Math.imul(U, tt)),
              (r = (r + Math.imul(P, nt)) | 0),
              (o = ((o = (o + Math.imul(P, rt)) | 0) + Math.imul(L, nt)) | 0),
              (i = (i + Math.imul(L, rt)) | 0),
              (r = (r + Math.imul(O, it)) | 0),
              (o = ((o = (o + Math.imul(O, st)) | 0) + Math.imul(M, it)) | 0),
              (i = (i + Math.imul(M, st)) | 0),
              (r = (r + Math.imul(x, ct)) | 0),
              (o = ((o = (o + Math.imul(x, ut)) | 0) + Math.imul(T, ct)) | 0),
              (i = (i + Math.imul(T, ut)) | 0),
              (r = (r + Math.imul(C, ht)) | 0),
              (o = ((o = (o + Math.imul(C, dt)) | 0) + Math.imul(S, ht)) | 0),
              (i = (i + Math.imul(S, dt)) | 0);
            var xt =
              (((u + (r = (r + Math.imul(A, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(A, mt)) | 0) + Math.imul(E, pt)) |
                    0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(E, mt)) | 0) + (o >>> 13)) | 0) +
                (xt >>> 26)) |
              0),
              (xt &= 67108863),
              (r = Math.imul(D, nt)),
              (o = ((o = Math.imul(D, rt)) + Math.imul(U, nt)) | 0),
              (i = Math.imul(U, rt)),
              (r = (r + Math.imul(P, it)) | 0),
              (o = ((o = (o + Math.imul(P, st)) | 0) + Math.imul(L, it)) | 0),
              (i = (i + Math.imul(L, st)) | 0),
              (r = (r + Math.imul(O, ct)) | 0),
              (o = ((o = (o + Math.imul(O, ut)) | 0) + Math.imul(M, ct)) | 0),
              (i = (i + Math.imul(M, ut)) | 0),
              (r = (r + Math.imul(x, ht)) | 0),
              (o = ((o = (o + Math.imul(x, dt)) | 0) + Math.imul(T, ht)) | 0),
              (i = (i + Math.imul(T, dt)) | 0);
            var Tt =
              (((u + (r = (r + Math.imul(C, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(C, mt)) | 0) + Math.imul(S, pt)) |
                    0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(S, mt)) | 0) + (o >>> 13)) | 0) +
                (Tt >>> 26)) |
              0),
              (Tt &= 67108863),
              (r = Math.imul(D, it)),
              (o = ((o = Math.imul(D, st)) + Math.imul(U, it)) | 0),
              (i = Math.imul(U, st)),
              (r = (r + Math.imul(P, ct)) | 0),
              (o = ((o = (o + Math.imul(P, ut)) | 0) + Math.imul(L, ct)) | 0),
              (i = (i + Math.imul(L, ut)) | 0),
              (r = (r + Math.imul(O, ht)) | 0),
              (o = ((o = (o + Math.imul(O, dt)) | 0) + Math.imul(M, ht)) | 0),
              (i = (i + Math.imul(M, dt)) | 0);
            var Rt =
              (((u + (r = (r + Math.imul(x, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(x, mt)) | 0) + Math.imul(T, pt)) |
                    0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(T, mt)) | 0) + (o >>> 13)) | 0) +
                (Rt >>> 26)) |
              0),
              (Rt &= 67108863),
              (r = Math.imul(D, ct)),
              (o = ((o = Math.imul(D, ut)) + Math.imul(U, ct)) | 0),
              (i = Math.imul(U, ut)),
              (r = (r + Math.imul(P, ht)) | 0),
              (o = ((o = (o + Math.imul(P, dt)) | 0) + Math.imul(L, ht)) | 0),
              (i = (i + Math.imul(L, dt)) | 0);
            var Ot =
              (((u + (r = (r + Math.imul(O, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(O, mt)) | 0) + Math.imul(M, pt)) |
                    0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(M, mt)) | 0) + (o >>> 13)) | 0) +
                (Ot >>> 26)) |
              0),
              (Ot &= 67108863),
              (r = Math.imul(D, ht)),
              (o = ((o = Math.imul(D, dt)) + Math.imul(U, ht)) | 0),
              (i = Math.imul(U, dt));
            var Mt =
              (((u + (r = (r + Math.imul(P, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(P, mt)) | 0) + Math.imul(L, pt)) |
                    0)) <<
                  13)) |
              0;
            (u =
              ((((i = (i + Math.imul(L, mt)) | 0) + (o >>> 13)) | 0) +
                (Mt >>> 26)) |
              0),
              (Mt &= 67108863);
            var Nt =
              (((u + (r = Math.imul(D, pt))) | 0) +
                ((8191 &
                  (o = ((o = Math.imul(D, mt)) + Math.imul(U, pt)) | 0)) <<
                  13)) |
              0;
            return (
              (u =
                ((((i = Math.imul(U, mt)) + (o >>> 13)) | 0) + (Nt >>> 26)) |
                0),
              (Nt &= 67108863),
              (c[0] = yt),
              (c[1] = gt),
              (c[2] = wt),
              (c[3] = bt),
              (c[4] = vt),
              (c[5] = _t),
              (c[6] = kt),
              (c[7] = At),
              (c[8] = Et),
              (c[9] = It),
              (c[10] = Ct),
              (c[11] = St),
              (c[12] = Bt),
              (c[13] = xt),
              (c[14] = Tt),
              (c[15] = Rt),
              (c[16] = Ot),
              (c[17] = Mt),
              (c[18] = Nt),
              0 !== u && ((c[19] = u), n.length++),
              n
            );
          };
          function y(t, e, n) {
            (n.negative = e.negative ^ t.negative),
              (n.length = t.length + e.length);
            for (var r = 0, o = 0, i = 0; i < n.length - 1; i++) {
              var s = o;
              o = 0;
              for (
                var a = 67108863 & r,
                  c = Math.min(i, e.length - 1),
                  u = Math.max(0, i - t.length + 1);
                u <= c;
                u++
              ) {
                var l = i - u,
                  h = (0 | t.words[l]) * (0 | e.words[u]),
                  d = 67108863 & h;
                (a = 67108863 & (d = (d + a) | 0)),
                  (o +=
                    (s =
                      ((s = (s + ((h / 67108864) | 0)) | 0) + (d >>> 26)) |
                      0) >>> 26),
                  (s &= 67108863);
              }
              (n.words[i] = a), (r = s), (s = o);
            }
            return 0 !== r ? (n.words[i] = r) : n.length--, n._strip();
          }
          function g(t, e, n) {
            return y(t, e, n);
          }
          Math.imul || (m = p),
            (o.prototype.mulTo = function (t, e) {
              var n = this.length + t.length;
              return 10 === this.length && 10 === t.length
                ? m(this, t, e)
                : n < 63
                ? p(this, t, e)
                : n < 1024
                ? y(this, t, e)
                : g(this, t, e);
            }),
            (o.prototype.mul = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), this.mulTo(t, e)
              );
            }),
            (o.prototype.mulf = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), g(this, t, e)
              );
            }),
            (o.prototype.imul = function (t) {
              return this.clone().mulTo(t, this);
            }),
            (o.prototype.imuln = function (t) {
              var e = t < 0;
              e && (t = -t), n("number" == typeof t), n(t < 67108864);
              for (var r = 0, o = 0; o < this.length; o++) {
                var i = (0 | this.words[o]) * t,
                  s = (67108863 & i) + (67108863 & r);
                (r >>= 26),
                  (r += (i / 67108864) | 0),
                  (r += s >>> 26),
                  (this.words[o] = 67108863 & s);
              }
              return (
                0 !== r && ((this.words[o] = r), this.length++),
                (this.length = 0 === t ? 1 : this.length),
                e ? this.ineg() : this
              );
            }),
            (o.prototype.muln = function (t) {
              return this.clone().imuln(t);
            }),
            (o.prototype.sqr = function () {
              return this.mul(this);
            }),
            (o.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (o.prototype.pow = function (t) {
              var e = (function (t) {
                for (
                  var e = new Array(t.bitLength()), n = 0;
                  n < e.length;
                  n++
                ) {
                  var r = (n / 26) | 0,
                    o = n % 26;
                  e[n] = (t.words[r] >>> o) & 1;
                }
                return e;
              })(t);
              if (0 === e.length) return new o(1);
              for (
                var n = this, r = 0;
                r < e.length && 0 === e[r];
                r++, n = n.sqr()
              );
              if (++r < e.length)
                for (var i = n.sqr(); r < e.length; r++, i = i.sqr())
                  0 !== e[r] && (n = n.mul(i));
              return n;
            }),
            (o.prototype.iushln = function (t) {
              n("number" == typeof t && t >= 0);
              var e,
                r = t % 26,
                o = (t - r) / 26,
                i = (67108863 >>> (26 - r)) << (26 - r);
              if (0 !== r) {
                var s = 0;
                for (e = 0; e < this.length; e++) {
                  var a = this.words[e] & i,
                    c = ((0 | this.words[e]) - a) << r;
                  (this.words[e] = c | s), (s = a >>> (26 - r));
                }
                s && ((this.words[e] = s), this.length++);
              }
              if (0 !== o) {
                for (e = this.length - 1; e >= 0; e--)
                  this.words[e + o] = this.words[e];
                for (e = 0; e < o; e++) this.words[e] = 0;
                this.length += o;
              }
              return this._strip();
            }),
            (o.prototype.ishln = function (t) {
              return n(0 === this.negative), this.iushln(t);
            }),
            (o.prototype.iushrn = function (t, e, r) {
              var o;
              n("number" == typeof t && t >= 0),
                (o = e ? (e - (e % 26)) / 26 : 0);
              var i = t % 26,
                s = Math.min((t - i) / 26, this.length),
                a = 67108863 ^ ((67108863 >>> i) << i),
                c = r;
              if (((o -= s), (o = Math.max(0, o)), c)) {
                for (var u = 0; u < s; u++) c.words[u] = this.words[u];
                c.length = s;
              }
              if (0 === s);
              else if (this.length > s)
                for (this.length -= s, u = 0; u < this.length; u++)
                  this.words[u] = this.words[u + s];
              else (this.words[0] = 0), (this.length = 1);
              var l = 0;
              for (u = this.length - 1; u >= 0 && (0 !== l || u >= o); u--) {
                var h = 0 | this.words[u];
                (this.words[u] = (l << (26 - i)) | (h >>> i)), (l = h & a);
              }
              return (
                c && 0 !== l && (c.words[c.length++] = l),
                0 === this.length && ((this.words[0] = 0), (this.length = 1)),
                this._strip()
              );
            }),
            (o.prototype.ishrn = function (t, e, r) {
              return n(0 === this.negative), this.iushrn(t, e, r);
            }),
            (o.prototype.shln = function (t) {
              return this.clone().ishln(t);
            }),
            (o.prototype.ushln = function (t) {
              return this.clone().iushln(t);
            }),
            (o.prototype.shrn = function (t) {
              return this.clone().ishrn(t);
            }),
            (o.prototype.ushrn = function (t) {
              return this.clone().iushrn(t);
            }),
            (o.prototype.testn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26,
                o = 1 << e;
              return !(this.length <= r || !(this.words[r] & o));
            }),
            (o.prototype.imaskn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26;
              if (
                (n(
                  0 === this.negative,
                  "imaskn works only with positive numbers"
                ),
                this.length <= r)
              )
                return this;
              if (
                (0 !== e && r++,
                (this.length = Math.min(r, this.length)),
                0 !== e)
              ) {
                var o = 67108863 ^ ((67108863 >>> e) << e);
                this.words[this.length - 1] &= o;
              }
              return this._strip();
            }),
            (o.prototype.maskn = function (t) {
              return this.clone().imaskn(t);
            }),
            (o.prototype.iaddn = function (t) {
              return (
                n("number" == typeof t),
                n(t < 67108864),
                t < 0
                  ? this.isubn(-t)
                  : 0 !== this.negative
                  ? 1 === this.length && (0 | this.words[0]) <= t
                    ? ((this.words[0] = t - (0 | this.words[0])),
                      (this.negative = 0),
                      this)
                    : ((this.negative = 0),
                      this.isubn(t),
                      (this.negative = 1),
                      this)
                  : this._iaddn(t)
              );
            }),
            (o.prototype._iaddn = function (t) {
              this.words[0] += t;
              for (var e = 0; e < this.length && this.words[e] >= 67108864; e++)
                (this.words[e] -= 67108864),
                  e === this.length - 1
                    ? (this.words[e + 1] = 1)
                    : this.words[e + 1]++;
              return (this.length = Math.max(this.length, e + 1)), this;
            }),
            (o.prototype.isubn = function (t) {
              if ((n("number" == typeof t), n(t < 67108864), t < 0))
                return this.iaddn(-t);
              if (0 !== this.negative)
                return (
                  (this.negative = 0), this.iaddn(t), (this.negative = 1), this
                );
              if (
                ((this.words[0] -= t), 1 === this.length && this.words[0] < 0)
              )
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var e = 0; e < this.length && this.words[e] < 0; e++)
                  (this.words[e] += 67108864), (this.words[e + 1] -= 1);
              return this._strip();
            }),
            (o.prototype.addn = function (t) {
              return this.clone().iaddn(t);
            }),
            (o.prototype.subn = function (t) {
              return this.clone().isubn(t);
            }),
            (o.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (o.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (o.prototype._ishlnsubmul = function (t, e, r) {
              var o,
                i,
                s = t.length + r;
              this._expand(s);
              var a = 0;
              for (o = 0; o < t.length; o++) {
                i = (0 | this.words[o + r]) + a;
                var c = (0 | t.words[o]) * e;
                (a = ((i -= 67108863 & c) >> 26) - ((c / 67108864) | 0)),
                  (this.words[o + r] = 67108863 & i);
              }
              for (; o < this.length - r; o++)
                (a = (i = (0 | this.words[o + r]) + a) >> 26),
                  (this.words[o + r] = 67108863 & i);
              if (0 === a) return this._strip();
              for (n(-1 === a), a = 0, o = 0; o < this.length; o++)
                (a = (i = -(0 | this.words[o]) + a) >> 26),
                  (this.words[o] = 67108863 & i);
              return (this.negative = 1), this._strip();
            }),
            (o.prototype._wordDiv = function (t, e) {
              var n = (this.length, t.length),
                r = this.clone(),
                i = t,
                s = 0 | i.words[i.length - 1];
              0 != (n = 26 - this._countBits(s)) &&
                ((i = i.ushln(n)),
                r.iushln(n),
                (s = 0 | i.words[i.length - 1]));
              var a,
                c = r.length - i.length;
              if ("mod" !== e) {
                ((a = new o(null)).length = c + 1),
                  (a.words = new Array(a.length));
                for (var u = 0; u < a.length; u++) a.words[u] = 0;
              }
              var l = r.clone()._ishlnsubmul(i, 1, c);
              0 === l.negative && ((r = l), a && (a.words[c] = 1));
              for (var h = c - 1; h >= 0; h--) {
                var d =
                  67108864 * (0 | r.words[i.length + h]) +
                  (0 | r.words[i.length + h - 1]);
                for (
                  d = Math.min((d / s) | 0, 67108863), r._ishlnsubmul(i, d, h);
                  0 !== r.negative;

                )
                  d--,
                    (r.negative = 0),
                    r._ishlnsubmul(i, 1, h),
                    r.isZero() || (r.negative ^= 1);
                a && (a.words[h] = d);
              }
              return (
                a && a._strip(),
                r._strip(),
                "div" !== e && 0 !== n && r.iushrn(n),
                { div: a || null, mod: r }
              );
            }),
            (o.prototype.divmod = function (t, e, r) {
              return (
                n(!t.isZero()),
                this.isZero()
                  ? { div: new o(0), mod: new o(0) }
                  : 0 !== this.negative && 0 === t.negative
                  ? ((a = this.neg().divmod(t, e)),
                    "mod" !== e && (i = a.div.neg()),
                    "div" !== e &&
                      ((s = a.mod.neg()), r && 0 !== s.negative && s.iadd(t)),
                    { div: i, mod: s })
                  : 0 === this.negative && 0 !== t.negative
                  ? ((a = this.divmod(t.neg(), e)),
                    "mod" !== e && (i = a.div.neg()),
                    { div: i, mod: a.mod })
                  : 0 !== (this.negative & t.negative)
                  ? ((a = this.neg().divmod(t.neg(), e)),
                    "div" !== e &&
                      ((s = a.mod.neg()), r && 0 !== s.negative && s.isub(t)),
                    { div: a.div, mod: s })
                  : t.length > this.length || this.cmp(t) < 0
                  ? { div: new o(0), mod: this }
                  : 1 === t.length
                  ? "div" === e
                    ? { div: this.divn(t.words[0]), mod: null }
                    : "mod" === e
                    ? { div: null, mod: new o(this.modrn(t.words[0])) }
                    : {
                        div: this.divn(t.words[0]),
                        mod: new o(this.modrn(t.words[0])),
                      }
                  : this._wordDiv(t, e)
              );
              var i, s, a;
            }),
            (o.prototype.div = function (t) {
              return this.divmod(t, "div", !1).div;
            }),
            (o.prototype.mod = function (t) {
              return this.divmod(t, "mod", !1).mod;
            }),
            (o.prototype.umod = function (t) {
              return this.divmod(t, "mod", !0).mod;
            }),
            (o.prototype.divRound = function (t) {
              var e = this.divmod(t);
              if (e.mod.isZero()) return e.div;
              var n = 0 !== e.div.negative ? e.mod.isub(t) : e.mod,
                r = t.ushrn(1),
                o = t.andln(1),
                i = n.cmp(r);
              return i < 0 || (1 === o && 0 === i)
                ? e.div
                : 0 !== e.div.negative
                ? e.div.isubn(1)
                : e.div.iaddn(1);
            }),
            (o.prototype.modrn = function (t) {
              var e = t < 0;
              e && (t = -t), n(t <= 67108863);
              for (
                var r = (1 << 26) % t, o = 0, i = this.length - 1;
                i >= 0;
                i--
              )
                o = (r * o + (0 | this.words[i])) % t;
              return e ? -o : o;
            }),
            (o.prototype.modn = function (t) {
              return this.modrn(t);
            }),
            (o.prototype.idivn = function (t) {
              var e = t < 0;
              e && (t = -t), n(t <= 67108863);
              for (var r = 0, o = this.length - 1; o >= 0; o--) {
                var i = (0 | this.words[o]) + 67108864 * r;
                (this.words[o] = (i / t) | 0), (r = i % t);
              }
              return this._strip(), e ? this.ineg() : this;
            }),
            (o.prototype.divn = function (t) {
              return this.clone().idivn(t);
            }),
            (o.prototype.egcd = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i = new o(1),
                  s = new o(0),
                  a = new o(0),
                  c = new o(1),
                  u = 0;
                e.isEven() && r.isEven();

              )
                e.iushrn(1), r.iushrn(1), ++u;
              for (var l = r.clone(), h = e.clone(); !e.isZero(); ) {
                for (
                  var d = 0, f = 1;
                  0 === (e.words[0] & f) && d < 26;
                  ++d, f <<= 1
                );
                if (d > 0)
                  for (e.iushrn(d); d-- > 0; )
                    (i.isOdd() || s.isOdd()) && (i.iadd(l), s.isub(h)),
                      i.iushrn(1),
                      s.iushrn(1);
                for (
                  var p = 0, m = 1;
                  0 === (r.words[0] & m) && p < 26;
                  ++p, m <<= 1
                );
                if (p > 0)
                  for (r.iushrn(p); p-- > 0; )
                    (a.isOdd() || c.isOdd()) && (a.iadd(l), c.isub(h)),
                      a.iushrn(1),
                      c.iushrn(1);
                e.cmp(r) >= 0
                  ? (e.isub(r), i.isub(a), s.isub(c))
                  : (r.isub(e), a.isub(i), c.isub(s));
              }
              return { a: a, b: c, gcd: r.iushln(u) };
            }),
            (o.prototype._invmp = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i, s = new o(1), a = new o(0), c = r.clone();
                e.cmpn(1) > 0 && r.cmpn(1) > 0;

              ) {
                for (
                  var u = 0, l = 1;
                  0 === (e.words[0] & l) && u < 26;
                  ++u, l <<= 1
                );
                if (u > 0)
                  for (e.iushrn(u); u-- > 0; )
                    s.isOdd() && s.iadd(c), s.iushrn(1);
                for (
                  var h = 0, d = 1;
                  0 === (r.words[0] & d) && h < 26;
                  ++h, d <<= 1
                );
                if (h > 0)
                  for (r.iushrn(h); h-- > 0; )
                    a.isOdd() && a.iadd(c), a.iushrn(1);
                e.cmp(r) >= 0 ? (e.isub(r), s.isub(a)) : (r.isub(e), a.isub(s));
              }
              return (i = 0 === e.cmpn(1) ? s : a).cmpn(0) < 0 && i.iadd(t), i;
            }),
            (o.prototype.gcd = function (t) {
              if (this.isZero()) return t.abs();
              if (t.isZero()) return this.abs();
              var e = this.clone(),
                n = t.clone();
              (e.negative = 0), (n.negative = 0);
              for (var r = 0; e.isEven() && n.isEven(); r++)
                e.iushrn(1), n.iushrn(1);
              for (;;) {
                for (; e.isEven(); ) e.iushrn(1);
                for (; n.isEven(); ) n.iushrn(1);
                var o = e.cmp(n);
                if (o < 0) {
                  var i = e;
                  (e = n), (n = i);
                } else if (0 === o || 0 === n.cmpn(1)) break;
                e.isub(n);
              }
              return n.iushln(r);
            }),
            (o.prototype.invm = function (t) {
              return this.egcd(t).a.umod(t);
            }),
            (o.prototype.isEven = function () {
              return !(1 & this.words[0]);
            }),
            (o.prototype.isOdd = function () {
              return !(1 & ~this.words[0]);
            }),
            (o.prototype.andln = function (t) {
              return this.words[0] & t;
            }),
            (o.prototype.bincn = function (t) {
              n("number" == typeof t);
              var e = t % 26,
                r = (t - e) / 26,
                o = 1 << e;
              if (this.length <= r)
                return this._expand(r + 1), (this.words[r] |= o), this;
              for (var i = o, s = r; 0 !== i && s < this.length; s++) {
                var a = 0 | this.words[s];
                (i = (a += i) >>> 26), (a &= 67108863), (this.words[s] = a);
              }
              return 0 !== i && ((this.words[s] = i), this.length++), this;
            }),
            (o.prototype.isZero = function () {
              return 1 === this.length && 0 === this.words[0];
            }),
            (o.prototype.cmpn = function (t) {
              var e,
                r = t < 0;
              if (0 !== this.negative && !r) return -1;
              if (0 === this.negative && r) return 1;
              if ((this._strip(), this.length > 1)) e = 1;
              else {
                r && (t = -t), n(t <= 67108863, "Number is too big");
                var o = 0 | this.words[0];
                e = o === t ? 0 : o < t ? -1 : 1;
              }
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.cmp = function (t) {
              if (0 !== this.negative && 0 === t.negative) return -1;
              if (0 === this.negative && 0 !== t.negative) return 1;
              var e = this.ucmp(t);
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.ucmp = function (t) {
              if (this.length > t.length) return 1;
              if (this.length < t.length) return -1;
              for (var e = 0, n = this.length - 1; n >= 0; n--) {
                var r = 0 | this.words[n],
                  o = 0 | t.words[n];
                if (r !== o) {
                  r < o ? (e = -1) : r > o && (e = 1);
                  break;
                }
              }
              return e;
            }),
            (o.prototype.gtn = function (t) {
              return 1 === this.cmpn(t);
            }),
            (o.prototype.gt = function (t) {
              return 1 === this.cmp(t);
            }),
            (o.prototype.gten = function (t) {
              return this.cmpn(t) >= 0;
            }),
            (o.prototype.gte = function (t) {
              return this.cmp(t) >= 0;
            }),
            (o.prototype.ltn = function (t) {
              return -1 === this.cmpn(t);
            }),
            (o.prototype.lt = function (t) {
              return -1 === this.cmp(t);
            }),
            (o.prototype.lten = function (t) {
              return this.cmpn(t) <= 0;
            }),
            (o.prototype.lte = function (t) {
              return this.cmp(t) <= 0;
            }),
            (o.prototype.eqn = function (t) {
              return 0 === this.cmpn(t);
            }),
            (o.prototype.eq = function (t) {
              return 0 === this.cmp(t);
            }),
            (o.red = function (t) {
              return new E(t);
            }),
            (o.prototype.toRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                n(0 === this.negative, "red works only with positives"),
                t.convertTo(this)._forceRed(t)
              );
            }),
            (o.prototype.fromRed = function () {
              return (
                n(
                  this.red,
                  "fromRed works only with numbers in reduction context"
                ),
                this.red.convertFrom(this)
              );
            }),
            (o.prototype._forceRed = function (t) {
              return (this.red = t), this;
            }),
            (o.prototype.forceRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                this._forceRed(t)
              );
            }),
            (o.prototype.redAdd = function (t) {
              return (
                n(this.red, "redAdd works only with red numbers"),
                this.red.add(this, t)
              );
            }),
            (o.prototype.redIAdd = function (t) {
              return (
                n(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, t)
              );
            }),
            (o.prototype.redSub = function (t) {
              return (
                n(this.red, "redSub works only with red numbers"),
                this.red.sub(this, t)
              );
            }),
            (o.prototype.redISub = function (t) {
              return (
                n(this.red, "redISub works only with red numbers"),
                this.red.isub(this, t)
              );
            }),
            (o.prototype.redShl = function (t) {
              return (
                n(this.red, "redShl works only with red numbers"),
                this.red.shl(this, t)
              );
            }),
            (o.prototype.redMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.mul(this, t)
              );
            }),
            (o.prototype.redIMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.imul(this, t)
              );
            }),
            (o.prototype.redSqr = function () {
              return (
                n(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (o.prototype.redISqr = function () {
              return (
                n(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (o.prototype.redSqrt = function () {
              return (
                n(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (o.prototype.redInvm = function () {
              return (
                n(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (o.prototype.redNeg = function () {
              return (
                n(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (o.prototype.redPow = function (t) {
              return (
                n(this.red && !t.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, t)
              );
            });
          var w = { k256: null, p224: null, p192: null, p25519: null };
          function b(t, e) {
            (this.name = t),
              (this.p = new o(e, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new o(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          function v() {
            b.call(
              this,
              "k256",
              "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
            );
          }
          function _() {
            b.call(
              this,
              "p224",
              "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
            );
          }
          function k() {
            b.call(
              this,
              "p192",
              "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
            );
          }
          function A() {
            b.call(
              this,
              "25519",
              "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
            );
          }
          function E(t) {
            if ("string" == typeof t) {
              var e = o._prime(t);
              (this.m = e.p), (this.prime = e);
            } else
              n(t.gtn(1), "modulus must be greater than 1"),
                (this.m = t),
                (this.prime = null);
          }
          function I(t) {
            E.call(this, t),
              (this.shift = this.m.bitLength()),
              this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new o(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          (b.prototype._tmp = function () {
            var t = new o(null);
            return (t.words = new Array(Math.ceil(this.n / 13))), t;
          }),
            (b.prototype.ireduce = function (t) {
              var e,
                n = t;
              do {
                this.split(n, this.tmp),
                  (e = (n = (n = this.imulK(n)).iadd(this.tmp)).bitLength());
              } while (e > this.n);
              var r = e < this.n ? -1 : n.ucmp(this.p);
              return (
                0 === r
                  ? ((n.words[0] = 0), (n.length = 1))
                  : r > 0
                  ? n.isub(this.p)
                  : void 0 !== n.strip
                  ? n.strip()
                  : n._strip(),
                n
              );
            }),
            (b.prototype.split = function (t, e) {
              t.iushrn(this.n, 0, e);
            }),
            (b.prototype.imulK = function (t) {
              return t.imul(this.k);
            }),
            r(v, b),
            (v.prototype.split = function (t, e) {
              for (
                var n = 4194303, r = Math.min(t.length, 9), o = 0;
                o < r;
                o++
              )
                e.words[o] = t.words[o];
              if (((e.length = r), t.length <= 9))
                return (t.words[0] = 0), (t.length = 1), void 0;
              var i = t.words[9];
              for (e.words[e.length++] = i & n, o = 10; o < t.length; o++) {
                var s = 0 | t.words[o];
                (t.words[o - 10] = ((s & n) << 4) | (i >>> 22)), (i = s);
              }
              (i >>>= 22),
                (t.words[o - 10] = i),
                0 === i && t.length > 10 ? (t.length -= 10) : (t.length -= 9);
            }),
            (v.prototype.imulK = function (t) {
              (t.words[t.length] = 0),
                (t.words[t.length + 1] = 0),
                (t.length += 2);
              for (var e = 0, n = 0; n < t.length; n++) {
                var r = 0 | t.words[n];
                (e += 977 * r),
                  (t.words[n] = 67108863 & e),
                  (e = 64 * r + ((e / 67108864) | 0));
              }
              return (
                0 === t.words[t.length - 1] &&
                  (t.length--, 0 === t.words[t.length - 1] && t.length--),
                t
              );
            }),
            r(_, b),
            r(k, b),
            r(A, b),
            (A.prototype.imulK = function (t) {
              for (var e = 0, n = 0; n < t.length; n++) {
                var r = 19 * (0 | t.words[n]) + e,
                  o = 67108863 & r;
                (r >>>= 26), (t.words[n] = o), (e = r);
              }
              return 0 !== e && (t.words[t.length++] = e), t;
            }),
            (o._prime = function (t) {
              if (w[t]) return w[t];
              var e;
              if ("k256" === t) e = new v();
              else if ("p224" === t) e = new _();
              else if ("p192" === t) e = new k();
              else {
                if ("p25519" !== t) throw new Error("Unknown prime " + t);
                e = new A();
              }
              return (w[t] = e), e;
            }),
            (E.prototype._verify1 = function (t) {
              n(0 === t.negative, "red works only with positives"),
                n(t.red, "red works only with red numbers");
            }),
            (E.prototype._verify2 = function (t, e) {
              n(
                0 === (t.negative | e.negative),
                "red works only with positives"
              ),
                n(t.red && t.red === e.red, "red works only with red numbers");
            }),
            (E.prototype.imod = function (t) {
              return this.prime
                ? this.prime.ireduce(t)._forceRed(this)
                : (u(t, t.umod(this.m)._forceRed(this)), t);
            }),
            (E.prototype.neg = function (t) {
              return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
            }),
            (E.prototype.add = function (t, e) {
              this._verify2(t, e);
              var n = t.add(e);
              return n.cmp(this.m) >= 0 && n.isub(this.m), n._forceRed(this);
            }),
            (E.prototype.iadd = function (t, e) {
              this._verify2(t, e);
              var n = t.iadd(e);
              return n.cmp(this.m) >= 0 && n.isub(this.m), n;
            }),
            (E.prototype.sub = function (t, e) {
              this._verify2(t, e);
              var n = t.sub(e);
              return n.cmpn(0) < 0 && n.iadd(this.m), n._forceRed(this);
            }),
            (E.prototype.isub = function (t, e) {
              this._verify2(t, e);
              var n = t.isub(e);
              return n.cmpn(0) < 0 && n.iadd(this.m), n;
            }),
            (E.prototype.shl = function (t, e) {
              return this._verify1(t), this.imod(t.ushln(e));
            }),
            (E.prototype.imul = function (t, e) {
              return this._verify2(t, e), this.imod(t.imul(e));
            }),
            (E.prototype.mul = function (t, e) {
              return this._verify2(t, e), this.imod(t.mul(e));
            }),
            (E.prototype.isqr = function (t) {
              return this.imul(t, t.clone());
            }),
            (E.prototype.sqr = function (t) {
              return this.mul(t, t);
            }),
            (E.prototype.sqrt = function (t) {
              if (t.isZero()) return t.clone();
              var e = this.m.andln(3);
              if ((n(e % 2 == 1), 3 === e)) {
                var r = this.m.add(new o(1)).iushrn(2);
                return this.pow(t, r);
              }
              for (
                var i = this.m.subn(1), s = 0;
                !i.isZero() && 0 === i.andln(1);

              )
                s++, i.iushrn(1);
              n(!i.isZero());
              var a = new o(1).toRed(this),
                c = a.redNeg(),
                u = this.m.subn(1).iushrn(1),
                l = this.m.bitLength();
              for (
                l = new o(2 * l * l).toRed(this);
                0 !== this.pow(l, u).cmp(c);

              )
                l.redIAdd(c);
              for (
                var h = this.pow(l, i),
                  d = this.pow(t, i.addn(1).iushrn(1)),
                  f = this.pow(t, i),
                  p = s;
                0 !== f.cmp(a);

              ) {
                for (var m = f, y = 0; 0 !== m.cmp(a); y++) m = m.redSqr();
                n(y < p);
                var g = this.pow(h, new o(1).iushln(p - y - 1));
                (d = d.redMul(g)), (h = g.redSqr()), (f = f.redMul(h)), (p = y);
              }
              return d;
            }),
            (E.prototype.invm = function (t) {
              var e = t._invmp(this.m);
              return 0 !== e.negative
                ? ((e.negative = 0), this.imod(e).redNeg())
                : this.imod(e);
            }),
            (E.prototype.pow = function (t, e) {
              if (e.isZero()) return new o(1).toRed(this);
              if (0 === e.cmpn(1)) return t.clone();
              var n = new Array(16);
              (n[0] = new o(1).toRed(this)), (n[1] = t);
              for (var r = 2; r < n.length; r++) n[r] = this.mul(n[r - 1], t);
              var i = n[0],
                s = 0,
                a = 0,
                c = e.bitLength() % 26;
              for (0 === c && (c = 26), r = e.length - 1; r >= 0; r--) {
                for (var u = e.words[r], l = c - 1; l >= 0; l--) {
                  var h = (u >> l) & 1;
                  i !== n[0] && (i = this.sqr(i)),
                    0 !== h || 0 !== s
                      ? ((s <<= 1),
                        (s |= h),
                        (4 === ++a || (0 === r && 0 === l)) &&
                          ((i = this.mul(i, n[s])), (a = 0), (s = 0)))
                      : (a = 0);
                }
                c = 26;
              }
              return i;
            }),
            (E.prototype.convertTo = function (t) {
              var e = t.umod(this.m);
              return e === t ? e.clone() : e;
            }),
            (E.prototype.convertFrom = function (t) {
              var e = t.clone();
              return (e.red = null), e;
            }),
            (o.mont = function (t) {
              return new I(t);
            }),
            r(I, E),
            (I.prototype.convertTo = function (t) {
              return this.imod(t.ushln(this.shift));
            }),
            (I.prototype.convertFrom = function (t) {
              var e = this.imod(t.mul(this.rinv));
              return (e.red = null), e;
            }),
            (I.prototype.imul = function (t, e) {
              if (t.isZero() || e.isZero())
                return (t.words[0] = 0), (t.length = 1), t;
              var n = t.imul(e),
                r = n
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                o = n.isub(r).iushrn(this.shift),
                i = o;
              return (
                o.cmp(this.m) >= 0
                  ? (i = o.isub(this.m))
                  : o.cmpn(0) < 0 && (i = o.iadd(this.m)),
                i._forceRed(this)
              );
            }),
            (I.prototype.mul = function (t, e) {
              if (t.isZero() || e.isZero()) return new o(0)._forceRed(this);
              var n = t.mul(e),
                r = n
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = n.isub(r).iushrn(this.shift),
                s = i;
              return (
                i.cmp(this.m) >= 0
                  ? (s = i.isub(this.m))
                  : i.cmpn(0) < 0 && (s = i.iadd(this.m)),
                s._forceRed(this)
              );
            }),
            (I.prototype.invm = function (t) {
              return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this);
            });
        })(t, Rn)),
      Sn.exports
    );
    var t;
  }
  const Mn = An(On());
  var Nn,
    Pn,
    Ln,
    zn,
    Dn,
    Un = { exports: {} };
  function qn() {
    return (
      Nn ||
        ((Nn = 1),
        (function (t, e) {
          window.skCrypt = function (t) {
            return function () {
              return t;
            };
          };
          var n = xn(),
            r = n.Buffer;
          function o(t, e) {
            for (var n in t) e[n] = t[n];
          }
          function i(t, e, n) {
            return r(t, e, n);
          }
          r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow
            ? (t.exports = n)
            : (o(n, e), (e.Buffer = i)),
            (i.prototype = Object.create(r.prototype)),
            o(r, i),
            (i.from = function (t, e, n) {
              if ("number" == typeof t)
                throw new TypeError("Argument must not be a number");
              return r(t, e, n);
            }),
            (i.alloc = function (t, e, n) {
              if ("number" != typeof t)
                throw new TypeError("Argument must be a number");
              var o = r(t);
              return (
                void 0 !== e
                  ? "string" == typeof n
                    ? o.fill(e, n)
                    : o.fill(e)
                  : o.fill(0),
                o
              );
            }),
            (i.allocUnsafe = function (t) {
              if ("number" != typeof t)
                throw new TypeError("Argument must be a number");
              return r(t);
            }),
            (i.allocUnsafeSlow = function (t) {
              if ("number" != typeof t)
                throw new TypeError("Argument must be a number");
              return n.SlowBuffer(t);
            });
        })(Un, Un.exports)),
      Un.exports
    );
  }
  var Gn = (function () {
    if (Dn) return zn;
    (Dn = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      });
    var t = (function () {
      if (Ln) return Pn;
      (Ln = 1),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        });
      var t = qn().Buffer;
      return (Pn = function (e) {
        if (e.length >= 255) throw new TypeError("Alphabet too long");
        for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
        for (var o = 0; o < e.length; o++) {
          var i = e.charAt(o),
            s = i.charCodeAt(0);
          if (255 !== n[s]) throw new TypeError(i + " is ambiguous");
          n[s] = o;
        }
        var a = e.length,
          c = e.charAt(0),
          u = Math.log(a) / Math.log(256),
          l = Math.log(256) / Math.log(a);
        function h(e) {
          if ("string" != typeof e) throw new TypeError("Expected String");
          if (0 === e.length) return t.alloc(0);
          for (var r = 0, o = 0, i = 0; e[r] === c; ) o++, r++;
          for (
            var s = ((e.length - r) * u + 1) >>> 0, l = new Uint8Array(s);
            r < e.length;

          ) {
            var h = e.charCodeAt(r);
            if (h > 255) return;
            var d = n[h];
            if (255 === d) return;
            for (var f = 0, p = s - 1; (0 !== d || f < i) && -1 !== p; p--, f++)
              (d += (a * l[p]) >>> 0),
                (l[p] = d % 256 >>> 0),
                (d = (d / 256) >>> 0);
            if (0 !== d) throw new Error("Non-zero carry");
            (i = f), r++;
          }
          for (var m = s - i; m !== s && 0 === l[m]; ) m++;
          var y = t.allocUnsafe(o + (s - m));
          y.fill(0, 0, o);
          for (var g = o; m !== s; ) y[g++] = l[m++];
          return y;
        }
        return {
          encode: function (n) {
            if (
              ((Array.isArray(n) || n instanceof Uint8Array) && (n = t.from(n)),
              !t.isBuffer(n))
            )
              throw new TypeError("Expected Buffer");
            if (0 === n.length) return "";
            for (var r = 0, o = 0, i = 0, s = n.length; i !== s && 0 === n[i]; )
              i++, r++;
            for (
              var u = ((s - i) * l + 1) >>> 0, h = new Uint8Array(u);
              i !== s;

            ) {
              for (
                var d = n[i], f = 0, p = u - 1;
                (0 !== d || f < o) && -1 !== p;
                p--, f++
              )
                (d += (256 * h[p]) >>> 0),
                  (h[p] = d % a >>> 0),
                  (d = (d / a) >>> 0);
              if (0 !== d) throw new Error("Non-zero carry");
              (o = f), i++;
            }
            for (var m = u - o; m !== u && 0 === h[m]; ) m++;
            for (var y = c.repeat(r); m < u; ++m) y += e.charAt(h[m]);
            return y;
          },
          decodeUnsafe: h,
          decode: function (t) {
            var e = h(t);
            if (e) return e;
            throw new Error("Non-base" + a + " character");
          },
        };
      });
    })();
    return (zn = t(
      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    ));
  })();
  const Wn = An(Gn);
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Kn = ne;
  var jn,
    Hn,
    Vn,
    Fn,
    Yn = {};
  function Zn() {
    if (Fn) return Vn;
    (Fn = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      });
    var t = (function () {
      if (Hn) return jn;
      (Hn = 1),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        });
      var t = qn().Buffer;
      return (jn = function (e) {
        if (e.length >= 255) throw new TypeError("Alphabet too long");
        for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
        for (var o = 0; o < e.length; o++) {
          var i = e.charAt(o),
            s = i.charCodeAt(0);
          if (255 !== n[s]) throw new TypeError(i + " is ambiguous");
          n[s] = o;
        }
        var a = e.length,
          c = e.charAt(0),
          u = Math.log(a) / Math.log(256),
          l = Math.log(256) / Math.log(a);
        function h(e) {
          if ("string" != typeof e) throw new TypeError("Expected String");
          if (0 === e.length) return t.alloc(0);
          for (var r = 0, o = 0, i = 0; e[r] === c; ) o++, r++;
          for (
            var s = ((e.length - r) * u + 1) >>> 0, l = new Uint8Array(s);
            r < e.length;

          ) {
            var h = e.charCodeAt(r);
            if (h > 255) return;
            var d = n[h];
            if (255 === d) return;
            for (var f = 0, p = s - 1; (0 !== d || f < i) && -1 !== p; p--, f++)
              (d += (a * l[p]) >>> 0),
                (l[p] = d % 256 >>> 0),
                (d = (d / 256) >>> 0);
            if (0 !== d) throw new Error("Non-zero carry");
            (i = f), r++;
          }
          for (var m = s - i; m !== s && 0 === l[m]; ) m++;
          var y = t.allocUnsafe(o + (s - m));
          y.fill(0, 0, o);
          for (var g = o; m !== s; ) y[g++] = l[m++];
          return y;
        }
        return {
          encode: function (n) {
            if (
              ((Array.isArray(n) || n instanceof Uint8Array) && (n = t.from(n)),
              !t.isBuffer(n))
            )
              throw new TypeError("Expected Buffer");
            if (0 === n.length) return "";
            for (var r = 0, o = 0, i = 0, s = n.length; i !== s && 0 === n[i]; )
              i++, r++;
            for (
              var u = ((s - i) * l + 1) >>> 0, h = new Uint8Array(u);
              i !== s;

            ) {
              for (
                var d = n[i], f = 0, p = u - 1;
                (0 !== d || f < o) && -1 !== p;
                p--, f++
              )
                (d += (256 * h[p]) >>> 0),
                  (h[p] = d % a >>> 0),
                  (d = (d / a) >>> 0);
              if (0 !== d) throw new Error("Non-zero carry");
              (o = f), i++;
            }
            for (var m = u - o; m !== u && 0 === h[m]; ) m++;
            for (var y = c.repeat(r); m < u; ++m) y += e.charAt(h[m]);
            return y;
          },
          decodeUnsafe: h,
          decode: function (t) {
            var e = h(t);
            if (e) return e;
            throw new Error("Non-base" + a + " character");
          },
        };
      });
    })();
    return (Vn = t(
      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    ));
  }
  function Jn(t, e, n) {
    return e <= t && t <= n;
  }
  function Xn(t) {
    if (void 0 === t) return {};
    if (t === Object(t)) return t;
    throw TypeError("Could not convert argument to dictionary");
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  function $n(t) {
    this.tokens = [].slice.call(t);
  }
  $n.prototype = {
    endOfStream: function () {
      return !this.tokens.length;
    },
    read: function () {
      return this.tokens.length ? this.tokens.shift() : -1;
    },
    prepend: function (t) {
      if (Array.isArray(t))
        for (var e = t; e.length; ) this.tokens.unshift(e.pop());
      else this.tokens.unshift(t);
    },
    push: function (t) {
      if (Array.isArray(t))
        for (var e = t; e.length; ) this.tokens.push(e.shift());
      else this.tokens.push(t);
    },
  };
  var Qn = -1;
  function tr(t, e) {
    if (t) throw TypeError("Decoder error");
    return e || 65533;
  }
  var er = "utf-8";
  function nr(t, e) {
    if (!(this instanceof nr)) return new nr(t, e);
    if ((t = void 0 !== t ? String(t).toLowerCase() : er) !== er)
      throw new Error("Encoding not supported. Only utf-8 is supported");
    (e = Xn(e)),
      (this._streaming = !1),
      (this._BOMseen = !1),
      (this._decoder = null),
      (this._fatal = Boolean(e.fatal)),
      (this._ignoreBOM = Boolean(e.ignoreBOM)),
      Object.defineProperty(this, "encoding", { value: "utf-8" }),
      Object.defineProperty(this, "fatal", { value: this._fatal }),
      Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
  }
  function rr(t, e) {
    if (!(this instanceof rr)) return new rr(t, e);
    if ((t = void 0 !== t ? String(t).toLowerCase() : er) !== er)
      throw new Error("Encoding not supported. Only utf-8 is supported");
    (e = Xn(e)),
      (this._streaming = !1),
      (this._encoder = null),
      (this._options = { fatal: Boolean(e.fatal) }),
      Object.defineProperty(this, "encoding", { value: "utf-8" });
  }
  function or(t) {
    var e = t.fatal,
      n = 0,
      r = 0,
      o = 0,
      i = 128,
      s = 191;
    this.handler = function (t, a) {
      if (-1 === a && 0 !== o) return (o = 0), tr(e);
      if (-1 === a) return Qn;
      if (0 === o) {
        if (Jn(a, 0, 127)) return a;
        if (Jn(a, 194, 223)) (o = 1), (n = a - 192);
        else if (Jn(a, 224, 239))
          224 === a && (i = 160),
            237 === a && (s = 159),
            (o = 2),
            (n = a - 224);
        else {
          if (!Jn(a, 240, 244)) return tr(e);
          240 === a && (i = 144),
            244 === a && (s = 143),
            (o = 3),
            (n = a - 240);
        }
        return (n <<= 6 * o), null;
      }
      if (!Jn(a, i, s))
        return (n = o = r = 0), (i = 128), (s = 191), t.prepend(a), tr(e);
      if (
        ((i = 128),
        (s = 191),
        (n += (a - 128) << (6 * (o - (r += 1)))),
        r !== o)
      )
        return null;
      var c = n;
      return (n = o = r = 0), c;
    };
  }
  function ir(t) {
    t.fatal,
      (this.handler = function (t, e) {
        if (-1 === e) return Qn;
        if (Jn(e, 0, 127)) return e;
        var n, r;
        Jn(e, 128, 2047)
          ? ((n = 1), (r = 192))
          : Jn(e, 2048, 65535)
          ? ((n = 2), (r = 224))
          : Jn(e, 65536, 1114111) && ((n = 3), (r = 240));
        for (var o = [(e >> (6 * n)) + r]; n > 0; ) {
          var i = e >> (6 * (n - 1));
          o.push(128 | (63 & i)), (n -= 1);
        }
        return o;
      });
  }
  (nr.prototype = {
    decode: function (t, e) {
      var n;
      (n =
        "object" == typeof t && t instanceof ArrayBuffer
          ? new Uint8Array(t)
          : "object" == typeof t &&
            "buffer" in t &&
            t.buffer instanceof ArrayBuffer
          ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
          : new Uint8Array(0)),
        (e = Xn(e)),
        this._streaming ||
          ((this._decoder = new or({ fatal: this._fatal })),
          (this._BOMseen = !1)),
        (this._streaming = Boolean(e.stream));
      for (
        var r, o = new $n(n), i = [];
        !o.endOfStream() && (r = this._decoder.handler(o, o.read())) !== Qn;

      )
        null !== r && (Array.isArray(r) ? i.push.apply(i, r) : i.push(r));
      if (!this._streaming) {
        do {
          if ((r = this._decoder.handler(o, o.read())) === Qn) break;
          null !== r && (Array.isArray(r) ? i.push.apply(i, r) : i.push(r));
        } while (!o.endOfStream());
        this._decoder = null;
      }
      return (
        i.length &&
          (-1 === ["utf-8"].indexOf(this.encoding) ||
            this._ignoreBOM ||
            this._BOMseen ||
            (65279 === i[0]
              ? ((this._BOMseen = !0), i.shift())
              : (this._BOMseen = !0))),
        (function (t) {
          for (var e = "", n = 0; n < t.length; ++n) {
            var r = t[n];
            r <= 65535
              ? (e += String.fromCharCode(r))
              : ((r -= 65536),
                (e += String.fromCharCode(
                  55296 + (r >> 10),
                  56320 + (1023 & r)
                )));
          }
          return e;
        })(i)
      );
    },
  }),
    (rr.prototype = {
      encode: function (t, e) {
        (t = t ? String(t) : ""),
          (e = Xn(e)),
          this._streaming || (this._encoder = new ir(this._options)),
          (this._streaming = Boolean(e.stream));
        for (
          var n,
            r = [],
            o = new $n(
              (function (t) {
                for (var e = String(t), n = e.length, r = 0, o = []; r < n; ) {
                  var i = e.charCodeAt(r);
                  if (i < 55296 || i > 57343) o.push(i);
                  else if (56320 <= i && i <= 57343) o.push(65533);
                  else if (55296 <= i && i <= 56319)
                    if (r === n - 1) o.push(65533);
                    else {
                      var s = t.charCodeAt(r + 1);
                      if (56320 <= s && s <= 57343) {
                        var a = 1023 & i,
                          c = 1023 & s;
                        o.push(65536 + (a << 10) + c), (r += 1);
                      } else o.push(65533);
                    }
                  r += 1;
                }
                return o;
              })(t)
            );
          !o.endOfStream() && (n = this._encoder.handler(o, o.read())) !== Qn;

        )
          Array.isArray(n) ? r.push.apply(r, n) : r.push(n);
        if (!this._streaming) {
          for (; (n = this._encoder.handler(o, o.read())) !== Qn; )
            Array.isArray(n) ? r.push.apply(r, n) : r.push(n);
          this._encoder = null;
        }
        return new Uint8Array(r);
      },
    });
  const sr = En(
    Object.freeze(
      Object.defineProperty(
        { __proto__: null, TextDecoder: nr, TextEncoder: rr },
        Symbol.toStringTag,
        { value: "Module" }
      )
    )
  );
  var ar;
  var cr,
    ur = (function () {
      if (ar) return Yn;
      (ar = 1),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        });
      var t =
          (Yn && Yn.__createBinding) ||
          (Object.create
            ? function (t, e, n, r) {
                void 0 === r && (r = n),
                  Object.defineProperty(t, r, {
                    enumerable: !0,
                    get: function () {
                      return e[n];
                    },
                  });
              }
            : function (t, e, n, r) {
                void 0 === r && (r = n), (t[r] = e[n]);
              }),
        e =
          (Yn && Yn.__setModuleDefault) ||
          (Object.create
            ? function (t, e) {
                Object.defineProperty(t, "default", {
                  enumerable: !0,
                  value: e,
                });
              }
            : function (t, e) {
                t.default = e;
              }),
        n =
          (Yn && Yn.__decorate) ||
          function (t, e, n, r) {
            var o,
              i = arguments.length,
              s =
                i < 3
                  ? e
                  : null === r
                  ? (r = Object.getOwnPropertyDescriptor(e, n))
                  : r;
            if (
              "object" == typeof Reflect &&
              "function" == typeof Reflect.decorate
            )
              s = Reflect.decorate(t, e, n, r);
            else
              for (var a = t.length - 1; a >= 0; a--)
                (o = t[a]) &&
                  (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
            return i > 3 && s && Object.defineProperty(e, n, s), s;
          },
        r =
          (Yn && Yn.__importStar) ||
          function (n) {
            if (n && n.__esModule) return n;
            var r = {};
            if (null != n)
              for (var o in n)
                "default" !== o &&
                  Object.hasOwnProperty.call(n, o) &&
                  t(r, n, o);
            return e(r, n), r;
          },
        o =
          (Yn && Yn.__importDefault) ||
          function (t) {
            return t && t.__esModule ? t : { default: t };
          };
      Object.defineProperty(Yn, "__esModule", { value: !0 }),
        (Yn.deserializeUnchecked =
          Yn.deserialize =
          Yn.serialize =
          Yn.BinaryReader =
          Yn.BinaryWriter =
          Yn.BorshError =
          Yn.baseDecode =
          Yn.baseEncode =
            void 0);
      const i = o(On()),
        s = o(Zn()),
        a = r(sr),
        c = new (
          "function" != typeof TextDecoder ? a.TextDecoder : TextDecoder
        )("utf-8", { fatal: !0 });
      (Yn.baseEncode = function (t) {
        return (
          "string" == typeof t && (t = J.from(t, "utf8")),
          s.default.encode(J.from(t))
        );
      }),
        (Yn.baseDecode = function (t) {
          return J.from(s.default.decode(t));
        });
      const u = 1024;
      class l extends Error {
        constructor(t) {
          super(t), (this.fieldPath = []), (this.originalMessage = t);
        }
        addToFieldPath(t) {
          this.fieldPath.splice(0, 0, t),
            (this.message =
              this.originalMessage + ": " + this.fieldPath.join("."));
        }
      }
      Yn.BorshError = l;
      class h {
        constructor() {
          (this.buf = J.alloc(u)), (this.length = 0);
        }
        maybeResize() {
          this.buf.length < 16 + this.length &&
            (this.buf = J.concat([this.buf, J.alloc(u)]));
        }
        writeU8(t) {
          this.maybeResize(),
            this.buf.writeUInt8(t, this.length),
            (this.length += 1);
        }
        writeU16(t) {
          this.maybeResize(),
            this.buf.writeUInt16LE(t, this.length),
            (this.length += 2);
        }
        writeU32(t) {
          this.maybeResize(),
            this.buf.writeUInt32LE(t, this.length),
            (this.length += 4);
        }
        writeU64(t) {
          this.maybeResize(),
            this.writeBuffer(J.from(new i.default(t).toArray("le", 8)));
        }
        writeU128(t) {
          this.maybeResize(),
            this.writeBuffer(J.from(new i.default(t).toArray("le", 16)));
        }
        writeU256(t) {
          this.maybeResize(),
            this.writeBuffer(J.from(new i.default(t).toArray("le", 32)));
        }
        writeU512(t) {
          this.maybeResize(),
            this.writeBuffer(J.from(new i.default(t).toArray("le", 64)));
        }
        writeBuffer(t) {
          (this.buf = J.concat([
            J.from(this.buf.subarray(0, this.length)),
            t,
            J.alloc(u),
          ])),
            (this.length += t.length);
        }
        writeString(t) {
          this.maybeResize();
          const e = J.from(t, "utf8");
          this.writeU32(e.length), this.writeBuffer(e);
        }
        writeFixedArray(t) {
          this.writeBuffer(J.from(t));
        }
        writeArray(t, e) {
          this.maybeResize(), this.writeU32(t.length);
          for (const n of t) this.maybeResize(), e(n);
        }
        toArray() {
          return this.buf.subarray(0, this.length);
        }
      }
      function d(t, e, n) {
        const r = n.value;
        n.value = function (...t) {
          try {
            return r.apply(this, t);
          } catch (e) {
            if (e instanceof RangeError) {
              const t = e.code;
              if (
                ["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(t) >= 0
              )
                throw new l("Reached the end of buffer when deserializing");
            }
            throw e;
          }
        };
      }
      Yn.BinaryWriter = h;
      class f {
        constructor(t) {
          (this.buf = t), (this.offset = 0);
        }
        readU8() {
          const t = this.buf.readUInt8(this.offset);
          return (this.offset += 1), t;
        }
        readU16() {
          const t = this.buf.readUInt16LE(this.offset);
          return (this.offset += 2), t;
        }
        readU32() {
          const t = this.buf.readUInt32LE(this.offset);
          return (this.offset += 4), t;
        }
        readU64() {
          const t = this.readBuffer(8);
          return new i.default(t, "le");
        }
        readU128() {
          const t = this.readBuffer(16);
          return new i.default(t, "le");
        }
        readU256() {
          const t = this.readBuffer(32);
          return new i.default(t, "le");
        }
        readU512() {
          const t = this.readBuffer(64);
          return new i.default(t, "le");
        }
        readBuffer(t) {
          if (this.offset + t > this.buf.length)
            throw new l(`Expected buffer length ${t} isn't within bounds`);
          const e = this.buf.slice(this.offset, this.offset + t);
          return (this.offset += t), e;
        }
        readString() {
          const t = this.readU32(),
            e = this.readBuffer(t);
          try {
            return c.decode(e);
          } catch (n) {
            throw new l(`Error decoding UTF-8 string: ${n}`);
          }
        }
        readFixedArray(t) {
          return new Uint8Array(this.readBuffer(t));
        }
        readArray(t) {
          const e = this.readU32(),
            n = Array();
          for (let r = 0; r < e; ++r) n.push(t());
          return n;
        }
      }
      function p(t) {
        return t.charAt(0).toUpperCase() + t.slice(1);
      }
      function m(t, e, n, r, o) {
        try {
          if ("string" == typeof r) o[`write${p(r)}`](n);
          else if (r instanceof Array)
            if ("number" == typeof r[0]) {
              if (n.length !== r[0])
                throw new l(
                  `Expecting byte array of length ${r[0]}, but got ${n.length} bytes`
                );
              o.writeFixedArray(n);
            } else if (2 === r.length && "number" == typeof r[1]) {
              if (n.length !== r[1])
                throw new l(
                  `Expecting byte array of length ${r[1]}, but got ${n.length} bytes`
                );
              for (let e = 0; e < r[1]; e++) m(t, null, n[e], r[0], o);
            } else
              o.writeArray(n, (n) => {
                m(t, e, n, r[0], o);
              });
          else if (void 0 !== r.kind)
            switch (r.kind) {
              case "option":
                null == n
                  ? o.writeU8(0)
                  : (o.writeU8(1), m(t, e, n, r.type, o));
                break;
              case "map":
                o.writeU32(n.size),
                  n.forEach((n, i) => {
                    m(t, e, i, r.key, o), m(t, e, n, r.value, o);
                  });
                break;
              default:
                throw new l(`FieldType ${r} unrecognized`);
            }
          else y(t, n, o);
        } catch (i) {
          throw (i instanceof l && i.addToFieldPath(e), i);
        }
      }
      function y(t, e, n) {
        if ("function" == typeof e.borshSerialize)
          return e.borshSerialize(n), void 0;
        const r = t.get(e.constructor);
        if (!r) throw new l(`Class ${e.constructor.name} is missing in schema`);
        if ("struct" === r.kind)
          r.fields.map(([r, o]) => {
            m(t, r, e[r], o, n);
          });
        else {
          if ("enum" !== r.kind)
            throw new l(
              `Unexpected schema kind: ${r.kind} for ${e.constructor.name}`
            );
          {
            const o = e[r.field];
            for (let i = 0; i < r.values.length; ++i) {
              const [s, a] = r.values[i];
              if (s === o) {
                n.writeU8(i), m(t, s, e[s], a, n);
                break;
              }
            }
          }
        }
      }
      function g(t, e, n, r) {
        try {
          if ("string" == typeof n) return r[`read${p(n)}`]();
          if (n instanceof Array) {
            if ("number" == typeof n[0]) return r.readFixedArray(n[0]);
            if ("number" == typeof n[1]) {
              const e = [];
              for (let o = 0; o < n[1]; o++) e.push(g(t, null, n[0], r));
              return e;
            }
            return r.readArray(() => g(t, e, n[0], r));
          }
          if ("option" === n.kind) {
            return r.readU8() ? g(t, e, n.type, r) : void 0;
          }
          if ("map" === n.kind) {
            let o = new Map();
            const i = r.readU32();
            for (let s = 0; s < i; s++) {
              const i = g(t, e, n.key, r),
                s = g(t, e, n.value, r);
              o.set(i, s);
            }
            return o;
          }
          return w(t, n, r);
        } catch (o) {
          throw (o instanceof l && o.addToFieldPath(e), o);
        }
      }
      function w(t, e, n) {
        if ("function" == typeof e.borshDeserialize)
          return e.borshDeserialize(n);
        const r = t.get(e);
        if (!r) throw new l(`Class ${e.name} is missing in schema`);
        if ("struct" === r.kind) {
          const r = {};
          for (const [o, i] of t.get(e).fields) r[o] = g(t, o, i, n);
          return new e(r);
        }
        if ("enum" === r.kind) {
          const o = n.readU8();
          if (o >= r.values.length)
            throw new l(`Enum index: ${o} is out of range`);
          const [i, s] = r.values[o],
            a = g(t, i, s, n);
          return new e({ [i]: a });
        }
        throw new l(
          `Unexpected schema kind: ${r.kind} for ${e.constructor.name}`
        );
      }
      return (
        n([d], f.prototype, "readU8", null),
        n([d], f.prototype, "readU16", null),
        n([d], f.prototype, "readU32", null),
        n([d], f.prototype, "readU64", null),
        n([d], f.prototype, "readU128", null),
        n([d], f.prototype, "readU256", null),
        n([d], f.prototype, "readU512", null),
        n([d], f.prototype, "readString", null),
        n([d], f.prototype, "readFixedArray", null),
        n([d], f.prototype, "readArray", null),
        (Yn.BinaryReader = f),
        (Yn.serialize = function (t, e, n = h) {
          const r = new n();
          return y(t, e, r), r.toArray();
        }),
        (Yn.deserialize = function (t, e, n, r = f) {
          const o = new r(n),
            i = w(t, e, o);
          if (o.offset < n.length)
            throw new l(
              `Unexpected ${n.length - o.offset} bytes after deserialized data`
            );
          return i;
        }),
        (Yn.deserializeUnchecked = function (t, e, n, r = f) {
          return w(t, e, new r(n));
        }),
        Yn
      );
    })(),
    lr = {};
  var hr = (function () {
    if (cr) return lr;
    (cr = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      }),
      Object.defineProperty(lr, "__esModule", { value: !0 }),
      (lr.s16 =
        lr.s8 =
        lr.nu64be =
        lr.u48be =
        lr.u40be =
        lr.u32be =
        lr.u24be =
        lr.u16be =
        lr.nu64 =
        lr.u48 =
        lr.u40 =
        lr.u32 =
        lr.u24 =
        lr.u16 =
        lr.u8 =
        lr.offset =
        lr.greedy =
        lr.Constant =
        lr.UTF8 =
        lr.CString =
        lr.Blob =
        lr.Boolean =
        lr.BitField =
        lr.BitStructure =
        lr.VariantLayout =
        lr.Union =
        lr.UnionLayoutDiscriminator =
        lr.UnionDiscriminator =
        lr.Structure =
        lr.Sequence =
        lr.DoubleBE =
        lr.Double =
        lr.FloatBE =
        lr.Float =
        lr.NearInt64BE =
        lr.NearInt64 =
        lr.NearUInt64BE =
        lr.NearUInt64 =
        lr.IntBE =
        lr.Int =
        lr.UIntBE =
        lr.UInt =
        lr.OffsetLayout =
        lr.GreedyCount =
        lr.ExternalLayout =
        lr.bindConstructorLayout =
        lr.nameWithProperty =
        lr.Layout =
        lr.uint8ArrayToBuffer =
        lr.checkUint8Array =
          void 0),
      (lr.constant =
        lr.utf8 =
        lr.cstr =
        lr.blob =
        lr.unionLayoutDiscriminator =
        lr.union =
        lr.seq =
        lr.bits =
        lr.struct =
        lr.f64be =
        lr.f64 =
        lr.f32be =
        lr.f32 =
        lr.ns64be =
        lr.s48be =
        lr.s40be =
        lr.s32be =
        lr.s24be =
        lr.s16be =
        lr.ns64 =
        lr.s48 =
        lr.s40 =
        lr.s32 =
        lr.s24 =
          void 0);
    const t = xn();
    function e(t) {
      if (!(t instanceof Uint8Array))
        throw new TypeError("b must be a Uint8Array");
    }
    function n(n) {
      return e(n), t.Buffer.from(n.buffer, n.byteOffset, n.length);
    }
    (lr.checkUint8Array = e), (lr.uint8ArrayToBuffer = n);
    class r {
      constructor(t, e) {
        if (!Number.isInteger(t))
          throw new TypeError("span must be an integer");
        (this.span = t), (this.property = e);
      }
      makeDestinationObject() {
        return {};
      }
      getSpan(t, e) {
        if (0 > this.span) throw new RangeError("indeterminate span");
        return this.span;
      }
      replicate(t) {
        const e = Object.create(this.constructor.prototype);
        return Object.assign(e, this), (e.property = t), e;
      }
      fromArray(t) {}
    }
    function o(t, e) {
      return e.property ? t + "[" + e.property + "]" : t;
    }
    (lr.Layout = r),
      (lr.nameWithProperty = o),
      (lr.bindConstructorLayout = function (t, e) {
        if ("function" != typeof t)
          throw new TypeError("Class must be constructor");
        if (Object.prototype.hasOwnProperty.call(t, "layout_"))
          throw new Error("Class is already bound to a layout");
        if (!(e && e instanceof r))
          throw new TypeError("layout must be a Layout");
        if (Object.prototype.hasOwnProperty.call(e, "boundConstructor_"))
          throw new Error("layout is already bound to a constructor");
        (t.layout_ = e),
          (e.boundConstructor_ = t),
          (e.makeDestinationObject = () => new t()),
          Object.defineProperty(t.prototype, "encode", {
            value(t, n) {
              return e.encode(this, t, n);
            },
            writable: !0,
          }),
          Object.defineProperty(t, "decode", {
            value: (t, n) => e.decode(t, n),
            writable: !0,
          });
      });
    class i extends r {
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    }
    lr.ExternalLayout = i;
    class s extends i {
      constructor(t = 1, e) {
        if (!Number.isInteger(t) || 0 >= t)
          throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, e), (this.elementSpan = t);
      }
      isCount() {
        return !0;
      }
      decode(t, n = 0) {
        e(t);
        const r = t.length - n;
        return Math.floor(r / this.elementSpan);
      }
      encode(t, e, n) {
        return 0;
      }
    }
    lr.GreedyCount = s;
    class a extends i {
      constructor(t, e = 0, n) {
        if (!(t instanceof r)) throw new TypeError("layout must be a Layout");
        if (!Number.isInteger(e))
          throw new TypeError("offset must be integer or undefined");
        super(t.span, n || t.property), (this.layout = t), (this.offset = e);
      }
      isCount() {
        return this.layout instanceof c || this.layout instanceof u;
      }
      decode(t, e = 0) {
        return this.layout.decode(t, e + this.offset);
      }
      encode(t, e, n = 0) {
        return this.layout.encode(t, e, n + this.offset);
      }
    }
    lr.OffsetLayout = a;
    class c extends r {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e = 0) {
        return n(t).readUIntLE(e, this.span);
      }
      encode(t, e, r = 0) {
        return n(e).writeUIntLE(t, r, this.span), this.span;
      }
    }
    lr.UInt = c;
    class u extends r {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e = 0) {
        return n(t).readUIntBE(e, this.span);
      }
      encode(t, e, r = 0) {
        return n(e).writeUIntBE(t, r, this.span), this.span;
      }
    }
    lr.UIntBE = u;
    class l extends r {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e = 0) {
        return n(t).readIntLE(e, this.span);
      }
      encode(t, e, r = 0) {
        return n(e).writeIntLE(t, r, this.span), this.span;
      }
    }
    lr.Int = l;
    class h extends r {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e = 0) {
        return n(t).readIntBE(e, this.span);
      }
      encode(t, e, r = 0) {
        return n(e).writeIntBE(t, r, this.span), this.span;
      }
    }
    lr.IntBE = h;
    const d = Math.pow(2, 32);
    function f(t) {
      const e = Math.floor(t / d);
      return { hi32: e, lo32: t - e * d };
    }
    function p(t, e) {
      return t * d + e;
    }
    class m extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        const r = n(t),
          o = r.readUInt32LE(e);
        return p(r.readUInt32LE(e + 4), o);
      }
      encode(t, e, r = 0) {
        const o = f(t),
          i = n(e);
        return i.writeUInt32LE(o.lo32, r), i.writeUInt32LE(o.hi32, r + 4), 8;
      }
    }
    lr.NearUInt64 = m;
    class y extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        const r = n(t);
        return p(r.readUInt32BE(e), r.readUInt32BE(e + 4));
      }
      encode(t, e, r = 0) {
        const o = f(t),
          i = n(e);
        return i.writeUInt32BE(o.hi32, r), i.writeUInt32BE(o.lo32, r + 4), 8;
      }
    }
    lr.NearUInt64BE = y;
    class g extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        const r = n(t),
          o = r.readUInt32LE(e);
        return p(r.readInt32LE(e + 4), o);
      }
      encode(t, e, r = 0) {
        const o = f(t),
          i = n(e);
        return i.writeUInt32LE(o.lo32, r), i.writeInt32LE(o.hi32, r + 4), 8;
      }
    }
    lr.NearInt64 = g;
    class w extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        const r = n(t);
        return p(r.readInt32BE(e), r.readUInt32BE(e + 4));
      }
      encode(t, e, r = 0) {
        const o = f(t),
          i = n(e);
        return i.writeInt32BE(o.hi32, r), i.writeUInt32BE(o.lo32, r + 4), 8;
      }
    }
    lr.NearInt64BE = w;
    class b extends r {
      constructor(t) {
        super(4, t);
      }
      decode(t, e = 0) {
        return n(t).readFloatLE(e);
      }
      encode(t, e, r = 0) {
        return n(e).writeFloatLE(t, r), 4;
      }
    }
    lr.Float = b;
    class v extends r {
      constructor(t) {
        super(4, t);
      }
      decode(t, e = 0) {
        return n(t).readFloatBE(e);
      }
      encode(t, e, r = 0) {
        return n(e).writeFloatBE(t, r), 4;
      }
    }
    lr.FloatBE = v;
    class _ extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        return n(t).readDoubleLE(e);
      }
      encode(t, e, r = 0) {
        return n(e).writeDoubleLE(t, r), 8;
      }
    }
    lr.Double = _;
    class k extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        return n(t).readDoubleBE(e);
      }
      encode(t, e, r = 0) {
        return n(e).writeDoubleBE(t, r), 8;
      }
    }
    lr.DoubleBE = k;
    class A extends r {
      constructor(t, e, n) {
        if (!(t instanceof r))
          throw new TypeError("elementLayout must be a Layout");
        if (
          !((e instanceof i && e.isCount()) || (Number.isInteger(e) && 0 <= e))
        )
          throw new TypeError(
            "count must be non-negative integer or an unsigned integer ExternalLayout"
          );
        let o = -1;
        !(e instanceof i) && 0 < t.span && (o = e * t.span),
          super(o, n),
          (this.elementLayout = t),
          (this.count = e);
      }
      getSpan(t, e = 0) {
        if (0 <= this.span) return this.span;
        let n = 0,
          r = this.count;
        if (
          (r instanceof i && (r = r.decode(t, e)), 0 < this.elementLayout.span)
        )
          n = r * this.elementLayout.span;
        else {
          let o = 0;
          for (; o < r; ) (n += this.elementLayout.getSpan(t, e + n)), ++o;
        }
        return n;
      }
      decode(t, e = 0) {
        const n = [];
        let r = 0,
          o = this.count;
        for (o instanceof i && (o = o.decode(t, e)); r < o; )
          n.push(this.elementLayout.decode(t, e)),
            (e += this.elementLayout.getSpan(t, e)),
            (r += 1);
        return n;
      }
      encode(t, e, n = 0) {
        const r = this.elementLayout,
          o = t.reduce((t, o) => t + r.encode(o, e, n + t), 0);
        return this.count instanceof i && this.count.encode(t.length, e, n), o;
      }
    }
    lr.Sequence = A;
    class E extends r {
      constructor(t, e, n) {
        if (!Array.isArray(t) || !t.reduce((t, e) => t && e instanceof r, !0))
          throw new TypeError("fields must be array of Layout instances");
        "boolean" == typeof e && void 0 === n && ((n = e), (e = void 0));
        for (const r of t)
          if (0 > r.span && void 0 === r.property)
            throw new Error(
              "fields cannot contain unnamed variable-length layout"
            );
        let o = -1;
        try {
          o = t.reduce((t, e) => t + e.getSpan(), 0);
        } catch (i) {}
        super(o, e), (this.fields = t), (this.decodePrefixes = !!n);
      }
      getSpan(t, e = 0) {
        if (0 <= this.span) return this.span;
        let n = 0;
        try {
          n = this.fields.reduce((n, r) => {
            const o = r.getSpan(t, e);
            return (e += o), n + o;
          }, 0);
        } catch (r) {
          throw new RangeError("indeterminate span");
        }
        return n;
      }
      decode(t, n = 0) {
        e(t);
        const r = this.makeDestinationObject();
        for (const e of this.fields)
          if (
            (void 0 !== e.property && (r[e.property] = e.decode(t, n)),
            (n += e.getSpan(t, n)),
            this.decodePrefixes && t.length === n)
          )
            break;
        return r;
      }
      encode(t, e, n = 0) {
        const r = n;
        let o = 0,
          i = 0;
        for (const s of this.fields) {
          let r = s.span;
          if (((i = 0 < r ? r : 0), void 0 !== s.property)) {
            const o = t[s.property];
            void 0 !== o &&
              ((i = s.encode(o, e, n)), 0 > r && (r = s.getSpan(e, n)));
          }
          (o = n), (n += r);
        }
        return o + i - r;
      }
      fromArray(t) {
        const e = this.makeDestinationObject();
        for (const n of this.fields)
          void 0 !== n.property && 0 < t.length && (e[n.property] = t.shift());
        return e;
      }
      layoutFor(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        for (const e of this.fields) if (e.property === t) return e;
      }
      offsetOf(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        let e = 0;
        for (const n of this.fields) {
          if (n.property === t) return e;
          0 > n.span ? (e = -1) : 0 <= e && (e += n.span);
        }
      }
    }
    lr.Structure = E;
    class I {
      constructor(t) {
        this.property = t;
      }
      decode(t, e) {
        throw new Error("UnionDiscriminator is abstract");
      }
      encode(t, e, n) {
        throw new Error("UnionDiscriminator is abstract");
      }
    }
    lr.UnionDiscriminator = I;
    class C extends I {
      constructor(t, e) {
        if (!(t instanceof i && t.isCount()))
          throw new TypeError(
            "layout must be an unsigned integer ExternalLayout"
          );
        super(e || t.property || "variant"), (this.layout = t);
      }
      decode(t, e) {
        return this.layout.decode(t, e);
      }
      encode(t, e, n) {
        return this.layout.encode(t, e, n);
      }
    }
    lr.UnionLayoutDiscriminator = C;
    class S extends r {
      constructor(t, e, n) {
        let o;
        if (t instanceof c || t instanceof u) o = new C(new a(t));
        else if (t instanceof i && t.isCount()) o = new C(t);
        else {
          if (!(t instanceof I))
            throw new TypeError(
              "discr must be a UnionDiscriminator or an unsigned integer layout"
            );
          o = t;
        }
        if ((void 0 === e && (e = null), !(null === e || e instanceof r)))
          throw new TypeError("defaultLayout must be null or a Layout");
        if (null !== e) {
          if (0 > e.span)
            throw new Error("defaultLayout must have constant span");
          void 0 === e.property && (e = e.replicate("content"));
        }
        let s = -1;
        e &&
          ((s = e.span),
          0 <= s && (t instanceof c || t instanceof u) && (s += o.layout.span)),
          super(s, n),
          (this.discriminator = o),
          (this.usesPrefixDiscriminator = t instanceof c || t instanceof u),
          (this.defaultLayout = e),
          (this.registry = {});
        let l = this.defaultGetSourceVariant.bind(this);
        (this.getSourceVariant = function (t) {
          return l(t);
        }),
          (this.configGetSourceVariant = function (t) {
            l = t.bind(this);
          });
      }
      getSpan(t, e = 0) {
        if (0 <= this.span) return this.span;
        const n = this.getVariant(t, e);
        if (!n)
          throw new Error("unable to determine span for unrecognized variant");
        return n.getSpan(t, e);
      }
      defaultGetSourceVariant(t) {
        if (
          Object.prototype.hasOwnProperty.call(t, this.discriminator.property)
        ) {
          if (
            this.defaultLayout &&
            this.defaultLayout.property &&
            Object.prototype.hasOwnProperty.call(t, this.defaultLayout.property)
          )
            return;
          const e = this.registry[t[this.discriminator.property]];
          if (
            e &&
            (!e.layout ||
              (e.property &&
                Object.prototype.hasOwnProperty.call(t, e.property)))
          )
            return e;
        } else
          for (const e in this.registry) {
            const n = this.registry[e];
            if (
              n.property &&
              Object.prototype.hasOwnProperty.call(t, n.property)
            )
              return n;
          }
        throw new Error("unable to infer src variant");
      }
      decode(t, e = 0) {
        let n;
        const r = this.discriminator,
          o = r.decode(t, e),
          i = this.registry[o];
        if (void 0 === i) {
          const i = this.defaultLayout;
          let s = 0;
          this.usesPrefixDiscriminator && (s = r.layout.span),
            (n = this.makeDestinationObject()),
            (n[r.property] = o),
            (n[i.property] = i.decode(t, e + s));
        } else n = i.decode(t, e);
        return n;
      }
      encode(t, e, n = 0) {
        const r = this.getSourceVariant(t);
        if (void 0 === r) {
          const r = this.discriminator,
            o = this.defaultLayout;
          let i = 0;
          return (
            this.usesPrefixDiscriminator && (i = r.layout.span),
            r.encode(t[r.property], e, n),
            i + o.encode(t[o.property], e, n + i)
          );
        }
        return r.encode(t, e, n);
      }
      addVariant(t, e, n) {
        const r = new B(this, t, e, n);
        return (this.registry[t] = r), r;
      }
      getVariant(t, e = 0) {
        let n;
        return (
          (n = t instanceof Uint8Array ? this.discriminator.decode(t, e) : t),
          this.registry[n]
        );
      }
    }
    lr.Union = S;
    class B extends r {
      constructor(t, e, n, o) {
        if (!(t instanceof S)) throw new TypeError("union must be a Union");
        if (!Number.isInteger(e) || 0 > e)
          throw new TypeError("variant must be a (non-negative) integer");
        if (
          ("string" == typeof n && void 0 === o && ((o = n), (n = null)), n)
        ) {
          if (!(n instanceof r)) throw new TypeError("layout must be a Layout");
          if (
            null !== t.defaultLayout &&
            0 <= n.span &&
            n.span > t.defaultLayout.span
          )
            throw new Error("variant span exceeds span of containing union");
          if ("string" != typeof o)
            throw new TypeError("variant must have a String property");
        }
        let i = t.span;
        0 > t.span &&
          ((i = n ? n.span : 0),
          0 <= i &&
            t.usesPrefixDiscriminator &&
            (i += t.discriminator.layout.span)),
          super(i, o),
          (this.union = t),
          (this.variant = e),
          (this.layout = n || null);
      }
      getSpan(t, e = 0) {
        if (0 <= this.span) return this.span;
        let n = 0;
        this.union.usesPrefixDiscriminator &&
          (n = this.union.discriminator.layout.span);
        let r = 0;
        return this.layout && (r = this.layout.getSpan(t, e + n)), n + r;
      }
      decode(t, e = 0) {
        const n = this.makeDestinationObject();
        if (this !== this.union.getVariant(t, e))
          throw new Error("variant mismatch");
        let r = 0;
        return (
          this.union.usesPrefixDiscriminator &&
            (r = this.union.discriminator.layout.span),
          this.layout
            ? (n[this.property] = this.layout.decode(t, e + r))
            : this.property
            ? (n[this.property] = !0)
            : this.union.usesPrefixDiscriminator &&
              (n[this.union.discriminator.property] = this.variant),
          n
        );
      }
      encode(t, e, n = 0) {
        let r = 0;
        if (
          (this.union.usesPrefixDiscriminator &&
            (r = this.union.discriminator.layout.span),
          this.layout &&
            !Object.prototype.hasOwnProperty.call(t, this.property))
        )
          throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, e, n);
        let o = r;
        if (
          this.layout &&
          (this.layout.encode(t[this.property], e, n + r),
          (o += this.layout.getSpan(e, n + r)),
          0 <= this.union.span && o > this.union.span)
        )
          throw new Error("encoded variant overruns containing union");
        return o;
      }
      fromArray(t) {
        if (this.layout) return this.layout.fromArray(t);
      }
    }
    function x(t) {
      return 0 > t && (t += 4294967296), t;
    }
    lr.VariantLayout = B;
    class T extends r {
      constructor(t, e, n) {
        if (!(t instanceof c || t instanceof u))
          throw new TypeError("word must be a UInt or UIntBE layout");
        if (
          ("string" == typeof e && void 0 === n && ((n = e), (e = !1)),
          4 < t.span)
        )
          throw new RangeError("word cannot exceed 32 bits");
        super(t.span, n), (this.word = t), (this.msb = !!e), (this.fields = []);
        let r = 0;
        (this._packedSetValue = function (t) {
          return (r = x(t)), this;
        }),
          (this._packedGetValue = function () {
            return r;
          });
      }
      decode(t, e = 0) {
        const n = this.makeDestinationObject(),
          r = this.word.decode(t, e);
        this._packedSetValue(r);
        for (const o of this.fields)
          void 0 !== o.property && (n[o.property] = o.decode(t));
        return n;
      }
      encode(t, e, n = 0) {
        const r = this.word.decode(e, n);
        this._packedSetValue(r);
        for (const o of this.fields)
          if (void 0 !== o.property) {
            const e = t[o.property];
            void 0 !== e && o.encode(e);
          }
        return this.word.encode(this._packedGetValue(), e, n);
      }
      addField(t, e) {
        const n = new R(this, t, e);
        return this.fields.push(n), n;
      }
      addBoolean(t) {
        const e = new O(this, t);
        return this.fields.push(e), e;
      }
      fieldFor(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        for (const e of this.fields) if (e.property === t) return e;
      }
    }
    lr.BitStructure = T;
    class R {
      constructor(t, e, n) {
        if (!(t instanceof T))
          throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(e) || 0 >= e)
          throw new TypeError("bits must be positive integer");
        const r = 8 * t.span,
          o = t.fields.reduce((t, e) => t + e.bits, 0);
        if (e + o > r)
          throw new Error(
            "bits too long for span remainder (" +
              (r - o) +
              " of " +
              r +
              " remain)"
          );
        (this.container = t),
          (this.bits = e),
          (this.valueMask = (1 << e) - 1),
          32 === e && (this.valueMask = 4294967295),
          (this.start = o),
          this.container.msb && (this.start = r - o - e),
          (this.wordMask = x(this.valueMask << this.start)),
          (this.property = n);
      }
      decode(t, e) {
        return (
          x(this.container._packedGetValue() & this.wordMask) >>> this.start
        );
      }
      encode(t) {
        if (
          "number" != typeof t ||
          !Number.isInteger(t) ||
          t !== x(t & this.valueMask)
        )
          throw new TypeError(
            o("BitField.encode", this) +
              " value must be integer not exceeding " +
              this.valueMask
          );
        const e = this.container._packedGetValue(),
          n = x(t << this.start);
        this.container._packedSetValue(x(e & ~this.wordMask) | n);
      }
    }
    lr.BitField = R;
    class O extends R {
      constructor(t, e) {
        super(t, 1, e);
      }
      decode(t, e) {
        return !!super.decode(t, e);
      }
      encode(t) {
        "boolean" == typeof t && (t = +t), super.encode(t);
      }
    }
    lr.Boolean = O;
    class M extends r {
      constructor(t, e) {
        if (
          !((t instanceof i && t.isCount()) || (Number.isInteger(t) && 0 <= t))
        )
          throw new TypeError(
            "length must be positive integer or an unsigned integer ExternalLayout"
          );
        let n = -1;
        t instanceof i || (n = t), super(n, e), (this.length = t);
      }
      getSpan(t, e) {
        let n = this.span;
        return 0 > n && (n = this.length.decode(t, e)), n;
      }
      decode(t, e = 0) {
        let r = this.span;
        return 0 > r && (r = this.length.decode(t, e)), n(t).slice(e, e + r);
      }
      encode(t, e, r) {
        let s = this.length;
        if (
          (this.length instanceof i && (s = t.length),
          !(t instanceof Uint8Array && s === t.length))
        )
          throw new TypeError(
            o("Blob.encode", this) +
              " requires (length " +
              s +
              ") Uint8Array as src"
          );
        if (r + s > e.length)
          throw new RangeError("encoding overruns Uint8Array");
        const a = n(t);
        return (
          n(e).write(a.toString("hex"), r, s, "hex"),
          this.length instanceof i && this.length.encode(s, e, r),
          s
        );
      }
    }
    lr.Blob = M;
    class N extends r {
      constructor(t) {
        super(-1, t);
      }
      getSpan(t, n = 0) {
        e(t);
        let r = n;
        for (; r < t.length && 0 !== t[r]; ) r += 1;
        return 1 + r - n;
      }
      decode(t, e = 0) {
        const r = this.getSpan(t, e);
        return n(t)
          .slice(e, e + r - 1)
          .toString("utf-8");
      }
      encode(e, r, o = 0) {
        "string" != typeof e && (e = String(e));
        const i = t.Buffer.from(e, "utf8"),
          s = i.length;
        if (o + s > r.length) throw new RangeError("encoding overruns Buffer");
        const a = n(r);
        return i.copy(a, o), (a[o + s] = 0), s + 1;
      }
    }
    lr.CString = N;
    class P extends r {
      constructor(t, e) {
        if (
          ("string" == typeof t && void 0 === e && ((e = t), (t = void 0)),
          void 0 === t)
        )
          t = -1;
        else if (!Number.isInteger(t))
          throw new TypeError("maxSpan must be an integer");
        super(-1, e), (this.maxSpan = t);
      }
      getSpan(t, n = 0) {
        return e(t), t.length - n;
      }
      decode(t, e = 0) {
        const r = this.getSpan(t, e);
        if (0 <= this.maxSpan && this.maxSpan < r)
          throw new RangeError("text length exceeds maxSpan");
        return n(t)
          .slice(e, e + r)
          .toString("utf-8");
      }
      encode(e, r, o = 0) {
        "string" != typeof e && (e = String(e));
        const i = t.Buffer.from(e, "utf8"),
          s = i.length;
        if (0 <= this.maxSpan && this.maxSpan < s)
          throw new RangeError("text length exceeds maxSpan");
        if (o + s > r.length) throw new RangeError("encoding overruns Buffer");
        return i.copy(n(r), o), s;
      }
    }
    lr.UTF8 = P;
    class L extends r {
      constructor(t, e) {
        super(0, e), (this.value = t);
      }
      decode(t, e) {
        return this.value;
      }
      encode(t, e, n) {
        return 0;
      }
    }
    return (
      (lr.Constant = L),
      (lr.greedy = (t, e) => new s(t, e)),
      (lr.offset = (t, e, n) => new a(t, e, n)),
      (lr.u8 = (t) => new c(1, t)),
      (lr.u16 = (t) => new c(2, t)),
      (lr.u24 = (t) => new c(3, t)),
      (lr.u32 = (t) => new c(4, t)),
      (lr.u40 = (t) => new c(5, t)),
      (lr.u48 = (t) => new c(6, t)),
      (lr.nu64 = (t) => new m(t)),
      (lr.u16be = (t) => new u(2, t)),
      (lr.u24be = (t) => new u(3, t)),
      (lr.u32be = (t) => new u(4, t)),
      (lr.u40be = (t) => new u(5, t)),
      (lr.u48be = (t) => new u(6, t)),
      (lr.nu64be = (t) => new y(t)),
      (lr.s8 = (t) => new l(1, t)),
      (lr.s16 = (t) => new l(2, t)),
      (lr.s24 = (t) => new l(3, t)),
      (lr.s32 = (t) => new l(4, t)),
      (lr.s40 = (t) => new l(5, t)),
      (lr.s48 = (t) => new l(6, t)),
      (lr.ns64 = (t) => new g(t)),
      (lr.s16be = (t) => new h(2, t)),
      (lr.s24be = (t) => new h(3, t)),
      (lr.s32be = (t) => new h(4, t)),
      (lr.s40be = (t) => new h(5, t)),
      (lr.s48be = (t) => new h(6, t)),
      (lr.ns64be = (t) => new w(t)),
      (lr.f32 = (t) => new b(t)),
      (lr.f32be = (t) => new v(t)),
      (lr.f64 = (t) => new _(t)),
      (lr.f64be = (t) => new k(t)),
      (lr.struct = (t, e, n) => new E(t, e, n)),
      (lr.bits = (t, e, n) => new T(t, e, n)),
      (lr.seq = (t, e, n) => new A(t, e, n)),
      (lr.union = (t, e, n) => new S(t, e, n)),
      (lr.unionLayoutDiscriminator = (t, e) => new C(t, e)),
      (lr.blob = (t, e) => new M(t, e)),
      (lr.cstr = (t) => new N(t)),
      (lr.utf8 = (t, e) => new P(t, e)),
      (lr.constant = (t, e) => new L(t, e)),
      lr
    );
  })();
  function dr(t) {
    if (Array.isArray(t)) {
      return "%5B" + t.map(dr).join("%2C%20") + "%5D";
    }
    return "bigint" == typeof t
      ? `${t}n`
      : encodeURIComponent(
          String(null != t && null === Object.getPrototypeOf(t) ? { ...t } : t)
        );
  }
  function fr([t, e]) {
    return `${t}=${dr(e)}`;
  }
  function pr(t, e = {}) {
    {
      let n = `Solana error #${t}; Decode this error by running \`npx @solana/errors decode -- ${t}`;
      return (
        Object.keys(e).length &&
          (n += ` '${(function (t) {
            const e = Object.entries(t).map(fr).join("&");
            return btoa(e);
          })(e)}'`),
        `${n}\``
      );
    }
  }
  var mr = class extends Error {
    constructor(...[t, n]) {
      let r, o;
      if (n) {
        const { cause: t, ...e } = n;
        t && (o = { cause: t }), Object.keys(e).length > 0 && (r = e);
      }
      super(pr(t, r), o),
        e(this, "cause", this.cause),
        e(this, "context"),
        (this.context = { __code: t, ...r }),
        (this.name = "SolanaError");
    }
  };
  function yr(t) {
    return "fixedSize" in t && "number" == typeof t.fixedSize;
  }
  function gr(t) {
    return 1 !== (null == t ? void 0 : t.endian);
  }
  function wr(t) {
    return (
      (e = {
        fixedSize: t.size,
        write(e, n, r) {
          t.range &&
            !(function (t, e, n, r) {
              if (r < e || r > n)
                throw new mr(8078011, {
                  codecDescription: t,
                  max: n,
                  min: e,
                  value: r,
                });
            })(t.name, t.range[0], t.range[1], e);
          const o = new ArrayBuffer(t.size);
          return (
            t.set(new DataView(o), e, gr(t.config)),
            n.set(new Uint8Array(o), r),
            r + t.size
          );
        },
      }),
      Object.freeze({
        ...e,
        encode: (t) => {
          const n = new Uint8Array(
            (function (t, e) {
              return "fixedSize" in e ? e.fixedSize : e.getSizeFromValue(t);
            })(t, e)
          );
          return e.write(t, n, 0), n;
        },
      })
    );
    var e;
  }
  function br(t) {
    return (
      (e = {
        fixedSize: t.size,
        read(e, n = 0) {
          !(function (t, e, n = 0) {
            if (e.length - n <= 0)
              throw new mr(8078e3, { codecDescription: t });
          })(t.name, e, n),
            (function (t, e, n, r = 0) {
              const o = n.length - r;
              if (o < e)
                throw new mr(8078001, {
                  bytesLength: o,
                  codecDescription: t,
                  expected: e,
                });
            })(t.name, t.size, e, n);
          const r = new DataView(
            (function (t, e, n) {
              const r = t.byteOffset + (e ?? 0),
                o = n ?? t.byteLength;
              return t.buffer.slice(r, r + o);
            })(e, n, t.size)
          );
          return [t.get(r, gr(t.config)), n + t.size];
        },
      }),
      Object.freeze({ ...e, decode: (t, n = 0) => e.read(t, n)[0] })
    );
    var e;
  }
  var vr = (t = {}) =>
      wr({
        config: t,
        name: "u64",
        range: [0n, BigInt("0xffffffffffffffff")],
        set: (t, e, n) => t.setBigUint64(0, BigInt(e), n),
        size: 8,
      }),
    _r = (t = {}) =>
      (function (t, e) {
        if (yr(t) !== yr(e)) throw new mr(8078004);
        if (yr(t) && yr(e) && t.fixedSize !== e.fixedSize)
          throw new mr(8078005, {
            decoderFixedSize: e.fixedSize,
            encoderFixedSize: t.fixedSize,
          });
        if (!yr(t) && !yr(e) && t.maxSize !== e.maxSize)
          throw new mr(8078006, {
            decoderMaxSize: e.maxSize,
            encoderMaxSize: t.maxSize,
          });
        return {
          ...e,
          ...t,
          decode: e.decode,
          encode: t.encode,
          read: e.read,
          write: t.write,
        };
      })(
        vr(t),
        ((t = {}) =>
          br({
            config: t,
            get: (t, e) => t.getBigUint64(0, e),
            name: "u64",
            size: 8,
          }))(t)
      );
  let kr = class extends TypeError {
    constructor(t, e) {
      let n;
      const { message: r, explanation: o, ...i } = t,
        { path: s } = t,
        a = 0 === s.length ? r : `At path: ${s.join(".")} -- ${r}`;
      super(o ?? a),
        null != o && (this.cause = a),
        Object.assign(this, i),
        (this.name = this.constructor.name),
        (this.failures = () => n ?? (n = [t, ...e()]));
    }
  };
  function Ar(t) {
    return "object" == typeof t && null != t;
  }
  function Er(t) {
    return Ar(t) && !Array.isArray(t);
  }
  function Ir(t) {
    return "symbol" == typeof t
      ? t.toString()
      : "string" == typeof t
      ? JSON.stringify(t)
      : `${t}`;
  }
  function Cr(t, e, n, r) {
    if (!0 === t) return;
    !1 === t ? (t = {}) : "string" == typeof t && (t = { message: t });
    const { path: o, branch: i } = e,
      { type: s } = n,
      {
        refinement: a,
        message: c = `Expected a value of type \`${s}\`${
          a ? ` with refinement \`${a}\`` : ""
        }, but received: \`${Ir(r)}\``,
      } = t;
    return {
      value: r,
      type: s,
      refinement: a,
      key: o[o.length - 1],
      path: o,
      branch: i,
      ...t,
      message: c,
    };
  }
  function* Sr(t, e, n, r) {
    var o;
    (Ar((o = t)) && "function" == typeof o[Symbol.iterator]) || (t = [t]);
    for (const i of t) {
      const t = Cr(i, e, n, r);
      t && (yield t);
    }
  }
  function* Br(t, e, n = {}) {
    const { path: r = [], branch: o = [t], coerce: i = !1, mask: s = !1 } = n,
      a = { path: r, branch: o, mask: s };
    i && (t = e.coercer(t, a));
    let c = "valid";
    for (const u of e.validator(t, a))
      (u.explanation = n.message), (c = "not_valid"), yield [u, void 0];
    for (let [u, l, h] of e.entries(t, a)) {
      const e = Br(l, h, {
        path: void 0 === u ? r : [...r, u],
        branch: void 0 === u ? o : [...o, l],
        coerce: i,
        mask: s,
        message: n.message,
      });
      for (const n of e)
        n[0]
          ? ((c = null != n[0].refinement ? "not_refined" : "not_valid"),
            yield [n[0], void 0])
          : i &&
            ((l = n[1]),
            void 0 === u
              ? (t = l)
              : t instanceof Map
              ? t.set(u, l)
              : t instanceof Set
              ? t.add(l)
              : Ar(t) && (void 0 !== l || u in t) && (t[u] = l));
    }
    if ("not_valid" !== c)
      for (const u of e.refiner(t, a))
        (u.explanation = n.message), (c = "not_refined"), yield [u, void 0];
    "valid" === c && (yield [void 0, t]);
  }
  let xr = class {
    constructor(t) {
      const {
        type: e,
        schema: n,
        validator: r,
        refiner: o,
        coercer: i = (t) => t,
        entries: s = function* () {},
      } = t;
      (this.type = e),
        (this.schema = n),
        (this.entries = s),
        (this.coercer = i),
        (this.validator = r ? (t, e) => Sr(r(t, e), e, this, t) : () => []),
        (this.refiner = o ? (t, e) => Sr(o(t, e), e, this, t) : () => []);
    }
    assert(t, e) {
      return Tr(t, this, e);
    }
    create(t, e) {
      return Rr(t, this, e);
    }
    is(t) {
      return Or(t, this);
    }
    mask(t, e) {
      return (function (t, e, n) {
        const r = Mr(t, e, { coerce: !0, mask: !0, message: n });
        if (r[0]) throw r[0];
        return r[1];
      })(t, this, e);
    }
    validate(t, e = {}) {
      return Mr(t, this, e);
    }
  };
  function Tr(t, e, n) {
    const r = Mr(t, e, { message: n });
    if (r[0]) throw r[0];
  }
  function Rr(t, e, n) {
    const r = Mr(t, e, { coerce: !0, message: n });
    if (r[0]) throw r[0];
    return r[1];
  }
  function Or(t, e) {
    return !Mr(t, e)[0];
  }
  function Mr(t, e, n = {}) {
    const r = Br(t, e, n),
      o = (function (t) {
        const { done: e, value: n } = t.next();
        return e ? void 0 : n;
      })(r);
    if (o[0]) {
      return [
        new kr(o[0], function* () {
          for (const t of r) t[0] && (yield t[0]);
        }),
        void 0,
      ];
    }
    return [void 0, o[1]];
  }
  function Nr(t, e) {
    return new xr({ type: t, schema: null, validator: e });
  }
  function Pr(t) {
    return new xr({
      type: "array",
      schema: t,
      *entries(e) {
        if (t && Array.isArray(e))
          for (const [n, r] of e.entries()) yield [n, r, t];
      },
      coercer: (t) => (Array.isArray(t) ? t.slice() : t),
      validator: (t) =>
        Array.isArray(t) || `Expected an array value, but received: ${Ir(t)}`,
    });
  }
  function Lr() {
    return Nr("boolean", (t) => "boolean" == typeof t);
  }
  function zr(t) {
    return Nr(
      "instance",
      (e) =>
        e instanceof t ||
        `Expected a \`${t.name}\` instance, but received: ${Ir(e)}`
    );
  }
  function Dr(t) {
    const e = Ir(t),
      n = typeof t;
    return new xr({
      type: "literal",
      schema: "string" === n || "number" === n || "boolean" === n ? t : null,
      validator: (n) =>
        n === t || `Expected the literal \`${e}\`, but received: ${Ir(n)}`,
    });
  }
  function Ur(t) {
    return new xr({
      ...t,
      validator: (e, n) => null === e || t.validator(e, n),
      refiner: (e, n) => null === e || t.refiner(e, n),
    });
  }
  function qr() {
    return Nr(
      "number",
      (t) =>
        ("number" == typeof t && !isNaN(t)) ||
        `Expected a number, but received: ${Ir(t)}`
    );
  }
  function Gr(t) {
    return new xr({
      ...t,
      validator: (e, n) => void 0 === e || t.validator(e, n),
      refiner: (e, n) => void 0 === e || t.refiner(e, n),
    });
  }
  function Wr(t, e) {
    return new xr({
      type: "record",
      schema: null,
      *entries(n) {
        if (Ar(n))
          for (const r in n) {
            const o = n[r];
            yield [r, r, t], yield [r, o, e];
          }
      },
      validator: (t) => Er(t) || `Expected an object, but received: ${Ir(t)}`,
      coercer: (t) => (Er(t) ? { ...t } : t),
    });
  }
  function Kr() {
    return Nr(
      "string",
      (t) => "string" == typeof t || `Expected a string, but received: ${Ir(t)}`
    );
  }
  function jr(t) {
    const e = Nr("never", () => !1);
    return new xr({
      type: "tuple",
      schema: null,
      *entries(n) {
        if (Array.isArray(n)) {
          const r = Math.max(t.length, n.length);
          for (let o = 0; o < r; o++) yield [o, n[o], t[o] || e];
        }
      },
      validator: (t) =>
        Array.isArray(t) || `Expected an array, but received: ${Ir(t)}`,
      coercer: (t) => (Array.isArray(t) ? t.slice() : t),
    });
  }
  function Hr(t) {
    const e = Object.keys(t);
    return new xr({
      type: "type",
      schema: t,
      *entries(n) {
        if (Ar(n)) for (const r of e) yield [r, n[r], t[r]];
      },
      validator: (t) => Er(t) || `Expected an object, but received: ${Ir(t)}`,
      coercer: (t) => (Er(t) ? { ...t } : t),
    });
  }
  function Vr(t) {
    const e = t.map((t) => t.type).join(" | ");
    return new xr({
      type: "union",
      schema: null,
      coercer(e, n) {
        for (const r of t) {
          const [t, o] = r.validate(e, { coerce: !0, mask: n.mask });
          if (!t) return o;
        }
        return e;
      },
      validator(n, r) {
        const o = [];
        for (const e of t) {
          const [...t] = Br(n, e, r),
            [i] = t;
          if (!i[0]) return [];
          for (const [e] of t) e && o.push(e);
        }
        return [
          `Expected the value to satisfy a union of \`${e}\`, but received: ${Ir(
            n
          )}`,
          ...o,
        ];
      },
    });
  }
  function Fr() {
    return Nr("unknown", () => !0);
  }
  function Yr(t, e, n) {
    return new xr({
      ...t,
      coercer: (r, o) => (Or(r, e) ? t.coercer(n(r, o), o) : t.coercer(r, o)),
    });
  }
  var Zr;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  var Jr = new Uint8Array(16);
  function Xr() {
    if (
      !Zr &&
      !(Zr =
        ("undefined" != typeof crypto &&
          crypto.getRandomValues &&
          crypto.getRandomValues.bind(crypto)) ||
        ("undefined" != typeof msCrypto &&
          "function" == typeof msCrypto.getRandomValues &&
          msCrypto.getRandomValues.bind(msCrypto)))
    )
      throw new Error(
        "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"
      );
    return Zr(Jr);
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const $r =
    /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function Qr(t) {
    return "string" == typeof t && $r.test(t);
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  for (var to, eo, no = [], ro = 0; ro < 256; ++ro)
    no.push((ro + 256).toString(16).substr(1));
  function oo(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
      n = (
        no[t[e + 0]] +
        no[t[e + 1]] +
        no[t[e + 2]] +
        no[t[e + 3]] +
        "-" +
        no[t[e + 4]] +
        no[t[e + 5]] +
        "-" +
        no[t[e + 6]] +
        no[t[e + 7]] +
        "-" +
        no[t[e + 8]] +
        no[t[e + 9]] +
        "-" +
        no[t[e + 10]] +
        no[t[e + 11]] +
        no[t[e + 12]] +
        no[t[e + 13]] +
        no[t[e + 14]] +
        no[t[e + 15]]
      ).toLowerCase();
    if (!Qr(n)) throw TypeError("Stringified UUID is invalid");
    return n;
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  var io = 0,
    so = 0;
  function ao(t) {
    if (!Qr(t)) throw TypeError("Invalid UUID");
    var e,
      n = new Uint8Array(16);
    return (
      (n[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24),
      (n[1] = (e >>> 16) & 255),
      (n[2] = (e >>> 8) & 255),
      (n[3] = 255 & e),
      (n[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8),
      (n[5] = 255 & e),
      (n[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8),
      (n[7] = 255 & e),
      (n[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8),
      (n[9] = 255 & e),
      (n[10] = ((e = parseInt(t.slice(24, 36), 16)) / 1099511627776) & 255),
      (n[11] = (e / 4294967296) & 255),
      (n[12] = (e >>> 24) & 255),
      (n[13] = (e >>> 16) & 255),
      (n[14] = (e >>> 8) & 255),
      (n[15] = 255 & e),
      n
    );
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  function co(t, e, n) {
    function r(t, r, o, i) {
      if (
        ("string" == typeof t &&
          (t = (function (t) {
            t = unescape(encodeURIComponent(t));
            for (var e = [], n = 0; n < t.length; ++n) e.push(t.charCodeAt(n));
            return e;
          })(t)),
        "string" == typeof r && (r = ao(r)),
        16 !== r.length)
      )
        throw TypeError(
          "Namespace must be array-like (16 iterable integer values, 0-255)"
        );
      var s = new Uint8Array(16 + t.length);
      if (
        (s.set(r),
        s.set(t, r.length),
        ((s = n(s))[6] = (15 & s[6]) | e),
        (s[8] = (63 & s[8]) | 128),
        o)
      ) {
        i = i || 0;
        for (var a = 0; a < 16; ++a) o[i + a] = s[a];
        return o;
      }
      return oo(s);
    }
    try {
      r.name = t;
    } catch (o) {}
    return (
      (r.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8"),
      (r.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8"),
      r
    );
  }
  function uo(t) {
    return 14 + (((t + 64) >>> 9) << 4) + 1;
  }
  function lo(t, e) {
    var n = (65535 & t) + (65535 & e);
    return (((t >> 16) + (e >> 16) + (n >> 16)) << 16) | (65535 & n);
  }
  function ho(t, e, n, r, o, i) {
    return lo(((s = lo(lo(e, t), lo(r, i))) << (a = o)) | (s >>> (32 - a)), n);
    var s, a;
  }
  function fo(t, e, n, r, o, i, s) {
    return ho((e & n) | (~e & r), t, e, o, i, s);
  }
  function po(t, e, n, r, o, i, s) {
    return ho((e & r) | (n & ~r), t, e, o, i, s);
  }
  function mo(t, e, n, r, o, i, s) {
    return ho(e ^ n ^ r, t, e, o, i, s);
  }
  function yo(t, e, n, r, o, i, s) {
    return ho(n ^ (e | ~r), t, e, o, i, s);
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  var go = co("v3", 48, function (t) {
    if ("string" == typeof t) {
      var e = unescape(encodeURIComponent(t));
      t = new Uint8Array(e.length);
      for (var n = 0; n < e.length; ++n) t[n] = e.charCodeAt(n);
    }
    return (function (t) {
      for (
        var e = [], n = 32 * t.length, r = "0123456789abcdef", o = 0;
        o < n;
        o += 8
      ) {
        var i = (t[o >> 5] >>> o % 32) & 255,
          s = parseInt(r.charAt((i >>> 4) & 15) + r.charAt(15 & i), 16);
        e.push(s);
      }
      return e;
    })(
      (function (t, e) {
        (t[e >> 5] |= 128 << e % 32), (t[uo(e) - 1] = e);
        for (
          var n = 1732584193,
            r = -271733879,
            o = -1732584194,
            i = 271733878,
            s = 0;
          s < t.length;
          s += 16
        ) {
          var a = n,
            c = r,
            u = o,
            l = i;
          (n = fo(n, r, o, i, t[s], 7, -680876936)),
            (i = fo(i, n, r, o, t[s + 1], 12, -389564586)),
            (o = fo(o, i, n, r, t[s + 2], 17, 606105819)),
            (r = fo(r, o, i, n, t[s + 3], 22, -1044525330)),
            (n = fo(n, r, o, i, t[s + 4], 7, -176418897)),
            (i = fo(i, n, r, o, t[s + 5], 12, 1200080426)),
            (o = fo(o, i, n, r, t[s + 6], 17, -1473231341)),
            (r = fo(r, o, i, n, t[s + 7], 22, -45705983)),
            (n = fo(n, r, o, i, t[s + 8], 7, 1770035416)),
            (i = fo(i, n, r, o, t[s + 9], 12, -1958414417)),
            (o = fo(o, i, n, r, t[s + 10], 17, -42063)),
            (r = fo(r, o, i, n, t[s + 11], 22, -1990404162)),
            (n = fo(n, r, o, i, t[s + 12], 7, 1804603682)),
            (i = fo(i, n, r, o, t[s + 13], 12, -40341101)),
            (o = fo(o, i, n, r, t[s + 14], 17, -1502002290)),
            (n = po(
              n,
              (r = fo(r, o, i, n, t[s + 15], 22, 1236535329)),
              o,
              i,
              t[s + 1],
              5,
              -165796510
            )),
            (i = po(i, n, r, o, t[s + 6], 9, -1069501632)),
            (o = po(o, i, n, r, t[s + 11], 14, 643717713)),
            (r = po(r, o, i, n, t[s], 20, -373897302)),
            (n = po(n, r, o, i, t[s + 5], 5, -701558691)),
            (i = po(i, n, r, o, t[s + 10], 9, 38016083)),
            (o = po(o, i, n, r, t[s + 15], 14, -660478335)),
            (r = po(r, o, i, n, t[s + 4], 20, -405537848)),
            (n = po(n, r, o, i, t[s + 9], 5, 568446438)),
            (i = po(i, n, r, o, t[s + 14], 9, -1019803690)),
            (o = po(o, i, n, r, t[s + 3], 14, -187363961)),
            (r = po(r, o, i, n, t[s + 8], 20, 1163531501)),
            (n = po(n, r, o, i, t[s + 13], 5, -1444681467)),
            (i = po(i, n, r, o, t[s + 2], 9, -51403784)),
            (o = po(o, i, n, r, t[s + 7], 14, 1735328473)),
            (n = mo(
              n,
              (r = po(r, o, i, n, t[s + 12], 20, -1926607734)),
              o,
              i,
              t[s + 5],
              4,
              -378558
            )),
            (i = mo(i, n, r, o, t[s + 8], 11, -2022574463)),
            (o = mo(o, i, n, r, t[s + 11], 16, 1839030562)),
            (r = mo(r, o, i, n, t[s + 14], 23, -35309556)),
            (n = mo(n, r, o, i, t[s + 1], 4, -1530992060)),
            (i = mo(i, n, r, o, t[s + 4], 11, 1272893353)),
            (o = mo(o, i, n, r, t[s + 7], 16, -155497632)),
            (r = mo(r, o, i, n, t[s + 10], 23, -1094730640)),
            (n = mo(n, r, o, i, t[s + 13], 4, 681279174)),
            (i = mo(i, n, r, o, t[s], 11, -358537222)),
            (o = mo(o, i, n, r, t[s + 3], 16, -722521979)),
            (r = mo(r, o, i, n, t[s + 6], 23, 76029189)),
            (n = mo(n, r, o, i, t[s + 9], 4, -640364487)),
            (i = mo(i, n, r, o, t[s + 12], 11, -421815835)),
            (o = mo(o, i, n, r, t[s + 15], 16, 530742520)),
            (n = yo(
              n,
              (r = mo(r, o, i, n, t[s + 2], 23, -995338651)),
              o,
              i,
              t[s],
              6,
              -198630844
            )),
            (i = yo(i, n, r, o, t[s + 7], 10, 1126891415)),
            (o = yo(o, i, n, r, t[s + 14], 15, -1416354905)),
            (r = yo(r, o, i, n, t[s + 5], 21, -57434055)),
            (n = yo(n, r, o, i, t[s + 12], 6, 1700485571)),
            (i = yo(i, n, r, o, t[s + 3], 10, -1894986606)),
            (o = yo(o, i, n, r, t[s + 10], 15, -1051523)),
            (r = yo(r, o, i, n, t[s + 1], 21, -2054922799)),
            (n = yo(n, r, o, i, t[s + 8], 6, 1873313359)),
            (i = yo(i, n, r, o, t[s + 15], 10, -30611744)),
            (o = yo(o, i, n, r, t[s + 6], 15, -1560198380)),
            (r = yo(r, o, i, n, t[s + 13], 21, 1309151649)),
            (n = yo(n, r, o, i, t[s + 4], 6, -145523070)),
            (i = yo(i, n, r, o, t[s + 11], 10, -1120210379)),
            (o = yo(o, i, n, r, t[s + 2], 15, 718787259)),
            (r = yo(r, o, i, n, t[s + 9], 21, -343485551)),
            (n = lo(n, a)),
            (r = lo(r, c)),
            (o = lo(o, u)),
            (i = lo(i, l));
        }
        return [n, r, o, i];
      })(
        (function (t) {
          if (0 === t.length) return [];
          for (
            var e = 8 * t.length, n = new Uint32Array(uo(e)), r = 0;
            r < e;
            r += 8
          )
            n[r >> 5] |= (255 & t[r / 8]) << r % 32;
          return n;
        })(t),
        8 * t.length
      )
    );
  });
  function wo(t, e, n, r) {
    switch (t) {
      case 0:
        return (e & n) ^ (~e & r);
      case 1:
      case 3:
        return e ^ n ^ r;
      case 2:
        return (e & n) ^ (e & r) ^ (n & r);
    }
  }
  function bo(t, e) {
    return (t << e) | (t >>> (32 - e));
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  var vo = co("v5", 80, function (t) {
    var e = [1518500249, 1859775393, 2400959708, 3395469782],
      n = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if ("string" == typeof t) {
      var r = unescape(encodeURIComponent(t));
      t = [];
      for (var o = 0; o < r.length; ++o) t.push(r.charCodeAt(o));
    } else Array.isArray(t) || (t = Array.prototype.slice.call(t));
    t.push(128);
    for (
      var i = t.length / 4 + 2, s = Math.ceil(i / 16), a = new Array(s), c = 0;
      c < s;
      ++c
    ) {
      for (var u = new Uint32Array(16), l = 0; l < 16; ++l)
        u[l] =
          (t[64 * c + 4 * l] << 24) |
          (t[64 * c + 4 * l + 1] << 16) |
          (t[64 * c + 4 * l + 2] << 8) |
          t[64 * c + 4 * l + 3];
      a[c] = u;
    }
    (a[s - 1][14] = (8 * (t.length - 1)) / Math.pow(2, 32)),
      (a[s - 1][14] = Math.floor(a[s - 1][14])),
      (a[s - 1][15] = (8 * (t.length - 1)) & 4294967295);
    for (var h = 0; h < s; ++h) {
      for (var d = new Uint32Array(80), f = 0; f < 16; ++f) d[f] = a[h][f];
      for (var p = 16; p < 80; ++p)
        d[p] = bo(d[p - 3] ^ d[p - 8] ^ d[p - 14] ^ d[p - 16], 1);
      for (
        var m = n[0], y = n[1], g = n[2], w = n[3], b = n[4], v = 0;
        v < 80;
        ++v
      ) {
        var _ = Math.floor(v / 20),
          k = (bo(m, 5) + wo(_, y, g, w) + b + e[_] + d[v]) >>> 0;
        (b = w), (w = g), (g = bo(y, 30) >>> 0), (y = m), (m = k);
      }
      (n[0] = (n[0] + m) >>> 0),
        (n[1] = (n[1] + y) >>> 0),
        (n[2] = (n[2] + g) >>> 0),
        (n[3] = (n[3] + w) >>> 0),
        (n[4] = (n[4] + b) >>> 0);
    }
    return [
      (n[0] >> 24) & 255,
      (n[0] >> 16) & 255,
      (n[0] >> 8) & 255,
      255 & n[0],
      (n[1] >> 24) & 255,
      (n[1] >> 16) & 255,
      (n[1] >> 8) & 255,
      255 & n[1],
      (n[2] >> 24) & 255,
      (n[2] >> 16) & 255,
      (n[2] >> 8) & 255,
      255 & n[2],
      (n[3] >> 24) & 255,
      (n[3] >> 16) & 255,
      (n[3] >> 8) & 255,
      255 & n[3],
      (n[4] >> 24) & 255,
      (n[4] >> 16) & 255,
      (n[4] >> 8) & 255,
      255 & n[4],
    ];
  });
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const _o = En(
    Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          NIL: "00000000-0000-0000-0000-000000000000",
          parse: ao,
          stringify: oo,
          v1: function (t, e, n) {
            var r = (e && n) || 0,
              o = e || new Array(16),
              i = (t = t || {}).node || to,
              s = void 0 !== t.clockseq ? t.clockseq : eo;
            if (null == i || null == s) {
              var a = t.random || (t.rng || Xr)();
              null == i && (i = to = [1 | a[0], a[1], a[2], a[3], a[4], a[5]]),
                null == s && (s = eo = 16383 & ((a[6] << 8) | a[7]));
            }
            var c = void 0 !== t.msecs ? t.msecs : Date.now(),
              u = void 0 !== t.nsecs ? t.nsecs : so + 1,
              l = c - io + (u - so) / 1e4;
            if (
              (l < 0 && void 0 === t.clockseq && (s = (s + 1) & 16383),
              (l < 0 || c > io) && void 0 === t.nsecs && (u = 0),
              u >= 1e4)
            )
              throw new Error(
                "uuid.v1(): Can't create more than 10M uuids/sec"
              );
            (io = c), (so = u), (eo = s);
            var h = (1e4 * (268435455 & (c += 122192928e5)) + u) % 4294967296;
            (o[r++] = (h >>> 24) & 255),
              (o[r++] = (h >>> 16) & 255),
              (o[r++] = (h >>> 8) & 255),
              (o[r++] = 255 & h);
            var d = ((c / 4294967296) * 1e4) & 268435455;
            (o[r++] = (d >>> 8) & 255),
              (o[r++] = 255 & d),
              (o[r++] = ((d >>> 24) & 15) | 16),
              (o[r++] = (d >>> 16) & 255),
              (o[r++] = (s >>> 8) | 128),
              (o[r++] = 255 & s);
            for (var f = 0; f < 6; ++f) o[r + f] = i[f];
            return e || oo(o);
          },
          v3: go,
          v4: function (t, e, n) {
            var r = (t = t || {}).random || (t.rng || Xr)();
            if (((r[6] = (15 & r[6]) | 64), (r[8] = (63 & r[8]) | 128), e)) {
              n = n || 0;
              for (var o = 0; o < 16; ++o) e[n + o] = r[o];
              return e;
            }
            return oo(r);
          },
          v5: vo,
          validate: Qr,
          version: function (t) {
            if (!Qr(t)) throw TypeError("Invalid UUID");
            return parseInt(t.substr(14, 1), 16);
          },
        },
        Symbol.toStringTag,
        { value: "Module" }
      )
    )
  );
  var ko, Ao, Eo, Io;
  const Co = An(
    (function () {
      if (Io) return Eo;
      (Io = 1),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        });
      const t = _o.v4,
        e = (function () {
          if (Ao) return ko;
          (Ao = 1),
            (window.skCrypt = function (t) {
              return function () {
                return t;
              };
            });
          const t = _o.v4;
          return (ko = function (e, n, r, o) {
            if ("string" != typeof e)
              throw new TypeError(e + " must be a string");
            const i = "number" == typeof (o = o || {}).version ? o.version : 2;
            if (1 !== i && 2 !== i) throw new TypeError(i + " must be 1 or 2");
            const s = { method: e };
            if ((2 === i && (s.jsonrpc = "2.0"), n)) {
              if ("object" != typeof n && !Array.isArray(n))
                throw new TypeError(n + " must be an object, array or omitted");
              s.params = n;
            }
            if (void 0 === r) {
              const e =
                "function" == typeof o.generator
                  ? o.generator
                  : function () {
                      return t();
                    };
              s.id = e(s, o);
            } else
              2 === i && null === r
                ? o.notificationIdNull && (s.id = null)
                : (s.id = r);
            return s;
          });
        })(),
        n = function (e, r) {
          if (!(this instanceof n)) return new n(e, r);
          r || (r = {}),
            (this.options = {
              reviver: void 0 !== r.reviver ? r.reviver : null,
              replacer: void 0 !== r.replacer ? r.replacer : null,
              generator:
                void 0 !== r.generator
                  ? r.generator
                  : function () {
                      return t();
                    },
              version: void 0 !== r.version ? r.version : 2,
              notificationIdNull:
                "boolean" == typeof r.notificationIdNull &&
                r.notificationIdNull,
            }),
            (this.callServer = e);
        };
      return (
        (Eo = n),
        (n.prototype.request = function (t, n, r, o) {
          const i = this;
          let s = null;
          const a = Array.isArray(t) && "function" == typeof n;
          if (1 === this.options.version && a)
            throw new TypeError("JSON-RPC 1.0 does not support batching");
          if (a || (!a && t && "object" == typeof t && "function" == typeof n))
            (o = n), (s = t);
          else {
            "function" == typeof r && ((o = r), (r = void 0));
            const i = "function" == typeof o;
            try {
              s = e(t, n, r, {
                generator: this.options.generator,
                version: this.options.version,
                notificationIdNull: this.options.notificationIdNull,
              });
            } catch (u) {
              if (i) return o(u);
              throw u;
            }
            if (!i) return s;
          }
          let c;
          try {
            c = JSON.stringify(s, this.options.replacer);
          } catch (u) {
            return o(u);
          }
          return (
            this.callServer(c, function (t, e) {
              i._parseResponse(t, e, o);
            }),
            s
          );
        }),
        (n.prototype._parseResponse = function (t, e, n) {
          if (t) return n(t), void 0;
          if (!e) return n();
          let r;
          try {
            r = JSON.parse(e, this.options.reviver);
          } catch (o) {
            return n(o);
          }
          if (3 === n.length) {
            if (Array.isArray(r)) {
              const t = function (t) {
                  return void 0 !== t.error;
                },
                e = function (e) {
                  return !t(e);
                };
              return n(null, r.filter(t), r.filter(e));
            }
            return n(null, r.error, r.result);
          }
          n(null, r);
        }),
        Eo
      );
    })()
  );
  var So,
    Bo = { exports: {} };
  var xo =
    (So ||
      ((So = 1),
      (function (t) {
        window.skCrypt = function (t) {
          return function () {
            return t;
          };
        };
        var e = Object.prototype.hasOwnProperty,
          n = "~";
        function r() {}
        function o(t, e, n) {
          (this.fn = t), (this.context = e), (this.once = n || !1);
        }
        function i(t, e, r, i, s) {
          if ("function" != typeof r)
            throw new TypeError("The listener must be a function");
          var a = new o(r, i || t, s),
            c = n ? n + e : e;
          return (
            t._events[c]
              ? t._events[c].fn
                ? (t._events[c] = [t._events[c], a])
                : t._events[c].push(a)
              : ((t._events[c] = a), t._eventsCount++),
            t
          );
        }
        function s(t, e) {
          0 === --t._eventsCount ? (t._events = new r()) : delete t._events[e];
        }
        function a() {
          (this._events = new r()), (this._eventsCount = 0);
        }
        Object.create &&
          ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1)),
          (a.prototype.eventNames = function () {
            var t,
              r,
              o = [];
            if (0 === this._eventsCount) return o;
            for (r in (t = this._events))
              e.call(t, r) && o.push(n ? r.slice(1) : r);
            return Object.getOwnPropertySymbols
              ? o.concat(Object.getOwnPropertySymbols(t))
              : o;
          }),
          (a.prototype.listeners = function (t) {
            var e = n ? n + t : t,
              r = this._events[e];
            if (!r) return [];
            if (r.fn) return [r.fn];
            for (var o = 0, i = r.length, s = new Array(i); o < i; o++)
              s[o] = r[o].fn;
            return s;
          }),
          (a.prototype.listenerCount = function (t) {
            var e = n ? n + t : t,
              r = this._events[e];
            return r ? (r.fn ? 1 : r.length) : 0;
          }),
          (a.prototype.emit = function (t, e, r, o, i, s) {
            var a = n ? n + t : t;
            if (!this._events[a]) return !1;
            var c,
              u,
              l = this._events[a],
              h = arguments.length;
            if (l.fn) {
              switch ((l.once && this.removeListener(t, l.fn, void 0, !0), h)) {
                case 1:
                  return l.fn.call(l.context), !0;
                case 2:
                  return l.fn.call(l.context, e), !0;
                case 3:
                  return l.fn.call(l.context, e, r), !0;
                case 4:
                  return l.fn.call(l.context, e, r, o), !0;
                case 5:
                  return l.fn.call(l.context, e, r, o, i), !0;
                case 6:
                  return l.fn.call(l.context, e, r, o, i, s), !0;
              }
              for (u = 1, c = new Array(h - 1); u < h; u++)
                c[u - 1] = arguments[u];
              l.fn.apply(l.context, c);
            } else {
              var d,
                f = l.length;
              for (u = 0; u < f; u++)
                switch (
                  (l[u].once && this.removeListener(t, l[u].fn, void 0, !0), h)
                ) {
                  case 1:
                    l[u].fn.call(l[u].context);
                    break;
                  case 2:
                    l[u].fn.call(l[u].context, e);
                    break;
                  case 3:
                    l[u].fn.call(l[u].context, e, r);
                    break;
                  case 4:
                    l[u].fn.call(l[u].context, e, r, o);
                    break;
                  default:
                    if (!c)
                      for (d = 1, c = new Array(h - 1); d < h; d++)
                        c[d - 1] = arguments[d];
                    l[u].fn.apply(l[u].context, c);
                }
            }
            return !0;
          }),
          (a.prototype.on = function (t, e, n) {
            return i(this, t, e, n, !1);
          }),
          (a.prototype.once = function (t, e, n) {
            return i(this, t, e, n, !0);
          }),
          (a.prototype.removeListener = function (t, e, r, o) {
            var i = n ? n + t : t;
            if (!this._events[i]) return this;
            if (!e) return s(this, i), this;
            var a = this._events[i];
            if (a.fn)
              a.fn !== e ||
                (o && !a.once) ||
                (r && a.context !== r) ||
                s(this, i);
            else {
              for (var c = 0, u = [], l = a.length; c < l; c++)
                (a[c].fn !== e ||
                  (o && !a[c].once) ||
                  (r && a[c].context !== r)) &&
                  u.push(a[c]);
              u.length
                ? (this._events[i] = 1 === u.length ? u[0] : u)
                : s(this, i);
            }
            return this;
          }),
          (a.prototype.removeAllListeners = function (t) {
            var e;
            return (
              t
                ? ((e = n ? n + t : t), this._events[e] && s(this, e))
                : ((this._events = new r()), (this._eventsCount = 0)),
              this
            );
          }),
          (a.prototype.off = a.prototype.removeListener),
          (a.prototype.addListener = a.prototype.on),
          (a.prefixed = n),
          (a.EventEmitter = a),
          (t.exports = a);
      })(Bo)),
    Bo.exports);
  const To = An(xo);
  var Ro = class extends To {
    constructor(t, n, r) {
      super(),
        e(this, "socket"),
        (this.socket = new window.WebSocket(t, r)),
        (this.socket.onopen = () => this.emit("open")),
        (this.socket.onmessage = (t) => this.emit("message", t.data)),
        (this.socket.onerror = (t) => this.emit("error", t)),
        (this.socket.onclose = (t) => {
          this.emit("close", t.code, t.reason);
        });
    }
    send(t, e, n) {
      const r = n || e;
      try {
        this.socket.send(t), r();
      } catch (o) {
        r(o);
      }
    }
    close(t, e) {
      this.socket.close(t, e);
    }
    addEventListener(t, e, n) {
      this.socket.addEventListener(t, e, n);
    }
  };
  var Oo = class {
      encode(t) {
        return JSON.stringify(t);
      }
      decode(t) {
        return JSON.parse(t);
      }
    },
    Mo = class extends To {
      constructor(
        t,
        n = "ws://localhost:8080",
        {
          autoconnect: r = !0,
          reconnect: o = !0,
          reconnect_interval: i = 1e3,
          max_reconnects: s = 5,
          ...a
        } = {},
        c,
        u
      ) {
        super(),
          e(this, "address"),
          e(this, "rpc_id"),
          e(this, "queue"),
          e(this, "options"),
          e(this, "autoconnect"),
          e(this, "ready"),
          e(this, "reconnect"),
          e(this, "reconnect_timer_id"),
          e(this, "reconnect_interval"),
          e(this, "max_reconnects"),
          e(this, "rest_options"),
          e(this, "current_reconnects"),
          e(this, "generate_request_id"),
          e(this, "socket"),
          e(this, "webSocketFactory"),
          e(this, "dataPack"),
          (this.webSocketFactory = t),
          (this.queue = {}),
          (this.rpc_id = 0),
          (this.address = n),
          (this.autoconnect = r),
          (this.ready = !1),
          (this.reconnect = o),
          (this.reconnect_timer_id = void 0),
          (this.reconnect_interval = i),
          (this.max_reconnects = s),
          (this.rest_options = a),
          (this.current_reconnects = 0),
          (this.generate_request_id =
            c ||
            (() =>
              "number" == typeof this.rpc_id
                ? ++this.rpc_id
                : Number(this.rpc_id) + 1)),
          (this.dataPack = u || new Oo()),
          this.autoconnect &&
            this._connect(this.address, {
              autoconnect: this.autoconnect,
              reconnect: this.reconnect,
              reconnect_interval: this.reconnect_interval,
              max_reconnects: this.max_reconnects,
              ...this.rest_options,
            });
      }
      connect() {
        this.socket ||
          this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options,
          });
      }
      call(t, e, n, r) {
        return (
          r || "object" != typeof n || ((r = n), (n = null)),
          new Promise((o, i) => {
            if (!this.ready) return i(new Error("socket not ready"));
            const s = this.generate_request_id(t, e),
              a = { jsonrpc: "2.0", method: t, params: e || void 0, id: s };
            this.socket.send(this.dataPack.encode(a), r, (t) => {
              if (t) return i(t);
              (this.queue[s] = { promise: [o, i] }),
                n &&
                  (this.queue[s].timeout = setTimeout(() => {
                    delete this.queue[s], i(new Error("reply timeout"));
                  }, n));
            });
          })
        );
      }
      async login(t) {
        const e = await this.call("rpc.login", t);
        if (!e) throw new Error("authentication failed");
        return e;
      }
      async listMethods() {
        return await this.call("__listMethods");
      }
      notify(t, e) {
        return new Promise((n, r) => {
          if (!this.ready) return r(new Error("socket not ready"));
          const o = { jsonrpc: "2.0", method: t, params: e };
          this.socket.send(this.dataPack.encode(o), (t) => {
            if (t) return r(t);
            n();
          });
        });
      }
      async subscribe(t) {
        "string" == typeof t && (t = [t]);
        const e = await this.call("rpc.on", t);
        if ("string" == typeof t && "ok" !== e[t])
          throw new Error(
            "Failed subscribing to an event '" + t + "' with: " + e[t]
          );
        return e;
      }
      async unsubscribe(t) {
        "string" == typeof t && (t = [t]);
        const e = await this.call("rpc.off", t);
        if ("string" == typeof t && "ok" !== e[t])
          throw new Error("Failed unsubscribing from an event with: " + e);
        return e;
      }
      close(t, e) {
        this.socket.close(t || 1e3, e);
      }
      setAutoReconnect(t) {
        this.reconnect = t;
      }
      setReconnectInterval(t) {
        this.reconnect_interval = t;
      }
      setMaxReconnects(t) {
        this.max_reconnects = t;
      }
      _connect(t, e) {
        clearTimeout(this.reconnect_timer_id),
          (this.socket = this.webSocketFactory(t, e)),
          this.socket.addEventListener("open", () => {
            (this.ready = !0), this.emit("open"), (this.current_reconnects = 0);
          }),
          this.socket.addEventListener("message", ({ data: t }) => {
            t instanceof ArrayBuffer && (t = X.from(t).toString());
            try {
              t = this.dataPack.decode(t);
            } catch (e) {
              return;
            }
            if (t.notification && this.listeners(t.notification).length) {
              if (!Object.keys(t.params).length)
                return this.emit(t.notification);
              const e = [t.notification];
              if (t.params.constructor === Object) e.push(t.params);
              else
                for (let n = 0; n < t.params.length; n++) e.push(t.params[n]);
              return Promise.resolve().then(() => {
                this.emit.apply(this, e);
              });
            }
            if (!this.queue[t.id])
              return t.method
                ? Promise.resolve().then(() => {
                    this.emit(t.method, null == t ? void 0 : t.params);
                  })
                : void 0;
            "error" in t == "result" in t &&
              this.queue[t.id].promise[1](
                new Error(
                  'Server response malformed. Response must include either "result" or "error", but not both.'
                )
              ),
              this.queue[t.id].timeout &&
                clearTimeout(this.queue[t.id].timeout),
              t.error
                ? this.queue[t.id].promise[1](t.error)
                : this.queue[t.id].promise[0](t.result),
              delete this.queue[t.id];
          }),
          this.socket.addEventListener("error", (t) => this.emit("error", t)),
          this.socket.addEventListener("close", ({ code: n, reason: r }) => {
            this.ready && setTimeout(() => this.emit("close", n, r), 0),
              (this.ready = !1),
              (this.socket = void 0),
              1e3 !== n &&
                (this.current_reconnects++,
                this.reconnect &&
                  (this.max_reconnects > this.current_reconnects ||
                    0 === this.max_reconnects) &&
                  (this.reconnect_timer_id = setTimeout(
                    () => this._connect(t, e),
                    this.reconnect_interval
                  )));
          });
      }
    };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const No = BigInt(0),
    Po = BigInt(1),
    Lo = BigInt(2),
    zo = BigInt(7),
    Do = BigInt(256),
    Uo = BigInt(113),
    qo = [],
    Go = [],
    Wo = [];
  for (let fy = 0, py = Po, my = 1, yy = 0; fy < 24; fy++) {
    ([my, yy] = [yy, (2 * my + 3 * yy) % 5]),
      qo.push(2 * (5 * yy + my)),
      Go.push((((fy + 1) * (fy + 2)) / 2) % 64);
    let t = No;
    for (let e = 0; e < 7; e++)
      (py = ((py << Po) ^ ((py >> zo) * Uo)) % Do),
        py & Lo && (t ^= Po << ((Po << BigInt(e)) - Po));
    Wo.push(t);
  }
  const Ko = Mt(Wo, !0),
    jo = Ko[0],
    Ho = Ko[1],
    Vo = (t, e, n) =>
      n > 32
        ? ((t, e, n) => (e << (n - 32)) | (t >>> (64 - n)))(t, e, n)
        : ((t, e, n) => (t << n) | (e >>> (32 - n)))(t, e, n),
    Fo = (t, e, n) =>
      n > 32
        ? ((t, e, n) => (t << (n - 32)) | (e >>> (64 - n)))(t, e, n)
        : ((t, e, n) => (e << n) | (t >>> (32 - n)))(t, e, n);
  class Yo extends kt {
    constructor(t, e, n, r = !1, o = 24) {
      if (
        (super(),
        (this.pos = 0),
        (this.posOut = 0),
        (this.finished = !1),
        (this.destroyed = !1),
        (this.enableXOF = !1),
        (this.blockLen = t),
        (this.suffix = e),
        (this.outputLen = n),
        (this.enableXOF = r),
        (this.rounds = o),
        tt(n),
        !(0 < t && t < 200))
      )
        throw new Error("only keccak-f1600 function is supported");
      var i;
      (this.state = new Uint8Array(200)),
        (this.state32 =
          ((i = this.state),
          new Uint32Array(
            i.buffer,
            i.byteOffset,
            Math.floor(i.byteLength / 4)
          )));
    }
    clone() {
      return this._cloneInto();
    }
    keccak() {
      ct(this.state32),
        (function (t, e = 24) {
          const n = new Uint32Array(10);
          for (let r = 24 - e; r < 24; r++) {
            for (let r = 0; r < 10; r++)
              n[r] = t[r] ^ t[r + 10] ^ t[r + 20] ^ t[r + 30] ^ t[r + 40];
            for (let r = 0; r < 10; r += 2) {
              const e = (r + 8) % 10,
                o = (r + 2) % 10,
                i = n[o],
                s = n[o + 1],
                a = Vo(i, s, 1) ^ n[e],
                c = Fo(i, s, 1) ^ n[e + 1];
              for (let n = 0; n < 50; n += 10)
                (t[r + n] ^= a), (t[r + n + 1] ^= c);
            }
            let e = t[2],
              o = t[3];
            for (let n = 0; n < 24; n++) {
              const r = Go[n],
                i = Vo(e, o, r),
                s = Fo(e, o, r),
                a = qo[n];
              (e = t[a]), (o = t[a + 1]), (t[a] = i), (t[a + 1] = s);
            }
            for (let r = 0; r < 50; r += 10) {
              for (let e = 0; e < 10; e++) n[e] = t[r + e];
              for (let e = 0; e < 10; e++)
                t[r + e] ^= ~n[(e + 2) % 10] & n[(e + 4) % 10];
            }
            (t[0] ^= jo[r]), (t[1] ^= Ho[r]);
          }
          ot(n);
        })(this.state32, this.rounds),
        ct(this.state32),
        (this.posOut = 0),
        (this.pos = 0);
    }
    update(t) {
      nt(this), et((t = vt(t)));
      const { blockLen: e, state: n } = this,
        r = t.length;
      for (let o = 0; o < r; ) {
        const i = Math.min(e - this.pos, r - o);
        for (let e = 0; e < i; e++) n[this.pos++] ^= t[o++];
        this.pos === e && this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished) return;
      this.finished = !0;
      const { state: t, suffix: e, pos: n, blockLen: r } = this;
      (t[n] ^= e),
        128 & e && n === r - 1 && this.keccak(),
        (t[r - 1] ^= 128),
        this.keccak();
    }
    writeInto(t) {
      nt(this, !1), et(t), this.finish();
      const e = this.state,
        { blockLen: n } = this;
      for (let r = 0, o = t.length; r < o; ) {
        this.posOut >= n && this.keccak();
        const i = Math.min(n - this.posOut, o - r);
        t.set(e.subarray(this.posOut, this.posOut + i), r),
          (this.posOut += i),
          (r += i);
      }
      return t;
    }
    xofInto(t) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(t);
    }
    xof(t) {
      return tt(t), this.xofInto(new Uint8Array(t));
    }
    digestInto(t) {
      if ((rt(t, this), this.finished))
        throw new Error("digest() was already called");
      return this.writeInto(t), this.destroy(), t;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      (this.destroyed = !0), ot(this.state);
    }
    _cloneInto(t) {
      const {
        blockLen: e,
        suffix: n,
        outputLen: r,
        rounds: o,
        enableXOF: i,
      } = this;
      return (
        t || (t = new Yo(e, n, r, i, o)),
        t.state32.set(this.state32),
        (t.pos = this.pos),
        (t.posOut = this.posOut),
        (t.finished = this.finished),
        (t.rounds = o),
        (t.suffix = n),
        (t.outputLen = r),
        (t.enableXOF = i),
        (t.destroyed = this.destroyed),
        t
      );
    }
  }
  const Zo = (() => {
    return (t = 1), (e = 136), (n = 32), At(() => new Yo(e, t, n));
    var t, e, n;
  })();
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  class Jo extends kt {
    constructor(t, e) {
      super(),
        (this.finished = !1),
        (this.destroyed = !1),
        (function (t) {
          if ("function" != typeof t || "function" != typeof t.create)
            throw new Error("Hash should be wrapped by utils.createHasher");
          tt(t.outputLen), tt(t.blockLen);
        })(t);
      const n = vt(e);
      if (((this.iHash = t.create()), "function" != typeof this.iHash.update))
        throw new Error("Expected instance of class which extends utils.Hash");
      (this.blockLen = this.iHash.blockLen),
        (this.outputLen = this.iHash.outputLen);
      const r = this.blockLen,
        o = new Uint8Array(r);
      o.set(n.length > r ? t.create().update(n).digest() : n);
      for (let i = 0; i < o.length; i++) o[i] ^= 54;
      this.iHash.update(o), (this.oHash = t.create());
      for (let i = 0; i < o.length; i++) o[i] ^= 106;
      this.oHash.update(o), ot(o);
    }
    update(t) {
      return nt(this), this.iHash.update(t), this;
    }
    digestInto(t) {
      nt(this),
        et(t, this.outputLen),
        (this.finished = !0),
        this.iHash.digestInto(t),
        this.oHash.update(t),
        this.oHash.digestInto(t),
        this.destroy();
    }
    digest() {
      const t = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(t), t;
    }
    _cloneInto(t) {
      t || (t = Object.create(Object.getPrototypeOf(this), {}));
      const {
        oHash: e,
        iHash: n,
        finished: r,
        destroyed: o,
        blockLen: i,
        outputLen: s,
      } = this;
      return (
        t,
        (t.finished = r),
        (t.destroyed = o),
        (t.blockLen = i),
        (t.outputLen = s),
        (t.oHash = e._cloneInto(t.oHash)),
        (t.iHash = n._cloneInto(t.iHash)),
        t
      );
    }
    clone() {
      return this._cloneInto();
    }
    destroy() {
      (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
    }
  }
  const Xo = (t, e, n) => new Jo(t, e).update(n).digest();
  function $o(t) {
    void 0 !== t.lowS && se("lowS", t.lowS),
      void 0 !== t.prehash && se("prehash", t.prehash);
  }
  (Xo.create = (t, e) => new Jo(t, e)),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  class Qo extends Error {
    constructor(t = "") {
      super(t);
    }
  }
  const ti = {
      Err: Qo,
      _tlv: {
        encode: (t, e) => {
          const { Err: n } = ti;
          if (t < 0 || t > 256) throw new n("tlv.encode: wrong tag");
          if (1 & e.length) throw new n("tlv.encode: unpadded data");
          const r = e.length / 2,
            o = ae(r);
          if ((o.length / 2) & 128)
            throw new n("tlv.encode: long form length too big");
          const i = r > 127 ? ae((o.length / 2) | 128) : "";
          return ae(t) + i + o + e;
        },
        decode(t, e) {
          const { Err: n } = ti;
          let r = 0;
          if (t < 0 || t > 256) throw new n("tlv.encode: wrong tag");
          if (e.length < 2 || e[r++] !== t)
            throw new n("tlv.decode: wrong tlv");
          const o = e[r++];
          let i = 0;
          if (!!(128 & o)) {
            const t = 127 & o;
            if (!t)
              throw new n("tlv.decode(long): indefinite length not supported");
            if (t > 4) throw new n("tlv.decode(long): byte length is too big");
            const s = e.subarray(r, r + t);
            if (s.length !== t)
              throw new n("tlv.decode: length bytes not complete");
            if (0 === s[0]) throw new n("tlv.decode(long): zero leftmost byte");
            for (const e of s) i = (i << 8) | e;
            if (((r += t), i < 128))
              throw new n("tlv.decode(long): not minimal encoding");
          } else i = o;
          const s = e.subarray(r, r + i);
          if (s.length !== i) throw new n("tlv.decode: wrong value length");
          return { v: s, l: e.subarray(r + i) };
        },
      },
      _int: {
        encode(t) {
          const { Err: e } = ti;
          if (t < ei) throw new e("integer: negative integers are not allowed");
          let n = ae(t);
          if ((8 & Number.parseInt(n[0], 16) && (n = "00" + n), 1 & n.length))
            throw new e("unexpected DER parsing assertion: unpadded hex");
          return n;
        },
        decode(t) {
          const { Err: e } = ti;
          if (128 & t[0]) throw new e("invalid signature integer: negative");
          if (0 === t[0] && !(128 & t[1]))
            throw new e("invalid signature integer: unnecessary leading zero");
          return ue(t);
        },
      },
      toSig(t) {
        const { Err: e, _int: n, _tlv: r } = ti,
          o = fe("signature", t),
          { v: i, l: s } = r.decode(48, o);
        if (s.length)
          throw new e("invalid signature: left bytes after parsing");
        const { v: a, l: c } = r.decode(2, i),
          { v: u, l: l } = r.decode(2, c);
        if (l.length)
          throw new e("invalid signature: left bytes after parsing");
        return { r: n.decode(a), s: n.decode(u) };
      },
      hexFromSig(t) {
        const { _tlv: e, _int: n } = ti,
          r = e.encode(2, n.encode(t.r)) + e.encode(2, n.encode(t.s));
        return e.encode(48, r);
      },
    },
    ei = BigInt(0),
    ni = BigInt(1),
    ri = BigInt(2),
    oi = BigInt(3),
    ii = BigInt(4);
  function si(t, e, n) {
    const { BYTES: r } = t;
    return function (o) {
      let i;
      if ("bigint" == typeof o) i = o;
      else {
        let n = fe("private key", o);
        if (e) {
          if (!e.includes(2 * n.length)) throw new Error("invalid private key");
          const t = new Uint8Array(r);
          t.set(n, t.length - n.length), (n = t);
        }
        try {
          i = t.fromBytes(n);
        } catch (s) {
          throw new Error(
            `invalid private key: expected ui8a of size ${r}, got ${typeof o}`
          );
        }
      }
      if ((n && (i = t.create(i)), !t.isValidNot0(i)))
        throw new Error("invalid private key: out of range [1..N-1]");
      return i;
    };
  }
  function ai(t, e = {}) {
    const { Fp: n, Fn: r } = $e("weierstrass", t, e),
      { h: o, n: i } = t;
    ge(
      e,
      {},
      {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean",
      }
    );
    const { endo: s } = e;
    if (
      s &&
      (!n.is0(t.a) ||
        "bigint" != typeof s.beta ||
        "function" != typeof s.splitScalar)
    )
      throw new Error(
        'invalid endo: expected "beta": bigint and "splitScalar": function'
      );
    function a() {
      if (!n.isOdd)
        throw new Error(
          "compression is not supported: Field does not have .isOdd()"
        );
    }
    const c =
        e.toBytes ||
        function (t, e, r) {
          const { x: o, y: i } = e.toAffine(),
            s = n.toBytes(o);
          if ((se("isCompressed", r), r)) {
            a();
            return _t(ci(!n.isOdd(i)), s);
          }
          return _t(Uint8Array.of(4), s, n.toBytes(i));
        },
      u =
        e.fromBytes ||
        function (t) {
          et(t);
          const e = n.BYTES,
            r = e + 1,
            o = 2 * e + 1,
            i = t.length,
            s = t[0],
            c = t.subarray(1);
          if (i !== r || (2 !== s && 3 !== s)) {
            if (i === o && 4 === s) {
              const t = n.fromBytes(c.subarray(0 * e, 1 * e)),
                r = n.fromBytes(c.subarray(1 * e, 2 * e));
              if (!h(t, r)) throw new Error("bad point: is not on curve");
              return { x: t, y: r };
            }
            throw new Error(
              `bad point: got length ${i}, expected compressed=${r} or uncompressed=${o}`
            );
          }
          {
            const t = n.fromBytes(c);
            if (!n.isValid(t))
              throw new Error("bad point: is not on curve, wrong x");
            const e = l(t);
            let r;
            try {
              r = n.sqrt(e);
            } catch (u) {
              const t = u instanceof Error ? ": " + u.message : "";
              throw new Error("bad point: is not on curve, sqrt error" + t);
            }
            a();
            return !(1 & ~s) !== n.isOdd(r) && (r = n.neg(r)), { x: t, y: r };
          }
        },
      l = (function (t, e, n) {
        return function (r) {
          const o = t.sqr(r),
            i = t.mul(o, r);
          return t.add(t.add(i, t.mul(r, e)), n);
        };
      })(n, t.a, t.b);
    function h(t, e) {
      const r = n.sqr(e),
        o = l(t);
      return n.eql(r, o);
    }
    if (!h(t.Gx, t.Gy)) throw new Error("bad curve params: generator point");
    const d = n.mul(n.pow(t.a, oi), ii),
      f = n.mul(n.sqr(t.b), BigInt(27));
    if (n.is0(n.add(d, f))) throw new Error("bad curve params: a or b");
    function p(t, e, r = !1) {
      if (!n.isValid(e) || (r && n.is0(e)))
        throw new Error(`bad point coordinate ${t}`);
      return e;
    }
    function m(t) {
      if (!(t instanceof b)) throw new Error("ProjectivePoint expected");
    }
    const y = we((t, e) => {
        const { px: r, py: o, pz: i } = t;
        if (n.eql(i, n.ONE)) return { x: r, y: o };
        const s = t.is0();
        null == e && (e = s ? n.ONE : n.inv(i));
        const a = n.mul(r, e),
          c = n.mul(o, e),
          u = n.mul(i, e);
        if (s) return { x: n.ZERO, y: n.ZERO };
        if (!n.eql(u, n.ONE)) throw new Error("invZ was invalid");
        return { x: a, y: c };
      }),
      g = we((t) => {
        if (t.is0()) {
          if (e.allowInfinityPoint && !n.is0(t.py)) return;
          throw new Error("bad point: ZERO");
        }
        const { x: r, y: o } = t.toAffine();
        if (!n.isValid(r) || !n.isValid(o))
          throw new Error("bad point: x or y not field elements");
        if (!h(r, o)) throw new Error("bad point: equation left != right");
        if (!t.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
        return !0;
      });
    function w(t, e, r, o, i) {
      return (
        (r = new b(n.mul(r.px, t), r.py, r.pz)),
        (e = qe(o, e)),
        (r = qe(i, r)),
        e.add(r)
      );
    }
    class b {
      constructor(t, e, n) {
        (this.px = p("x", t)),
          (this.py = p("y", e, !0)),
          (this.pz = p("z", n)),
          Object.freeze(this);
      }
      static fromAffine(t) {
        const { x: e, y: r } = t || {};
        if (!t || !n.isValid(e) || !n.isValid(r))
          throw new Error("invalid affine point");
        if (t instanceof b) throw new Error("projective point not allowed");
        return n.is0(e) && n.is0(r) ? b.ZERO : new b(e, r, n.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(t) {
        return Ge(b, "pz", t);
      }
      static fromBytes(t) {
        return et(t), b.fromHex(t);
      }
      static fromHex(t) {
        const e = b.fromAffine(u(fe("pointHex", t)));
        return e.assertValidity(), e;
      }
      static fromPrivateKey(t) {
        const n = si(r, e.allowedPrivateKeyLengths, e.wrapPrivateKey);
        return b.BASE.multiply(n(t));
      }
      static msm(t, e) {
        return Je(b, r, t, e);
      }
      precompute(t = 8, e = !0) {
        return _.setWindowSize(this, t), e || this.multiply(oi), this;
      }
      _setWindowSize(t) {
        this.precompute(t);
      }
      assertValidity() {
        g(this);
      }
      hasEvenY() {
        const { y: t } = this.toAffine();
        if (!n.isOdd) throw new Error("Field doesn't support isOdd");
        return !n.isOdd(t);
      }
      equals(t) {
        m(t);
        const { px: e, py: r, pz: o } = this,
          { px: i, py: s, pz: a } = t,
          c = n.eql(n.mul(e, a), n.mul(i, o)),
          u = n.eql(n.mul(r, a), n.mul(s, o));
        return c && u;
      }
      negate() {
        return new b(this.px, n.neg(this.py), this.pz);
      }
      double() {
        const { a: e, b: r } = t,
          o = n.mul(r, oi),
          { px: i, py: s, pz: a } = this;
        let c = n.ZERO,
          u = n.ZERO,
          l = n.ZERO,
          h = n.mul(i, i),
          d = n.mul(s, s),
          f = n.mul(a, a),
          p = n.mul(i, s);
        return (
          (p = n.add(p, p)),
          (l = n.mul(i, a)),
          (l = n.add(l, l)),
          (c = n.mul(e, l)),
          (u = n.mul(o, f)),
          (u = n.add(c, u)),
          (c = n.sub(d, u)),
          (u = n.add(d, u)),
          (u = n.mul(c, u)),
          (c = n.mul(p, c)),
          (l = n.mul(o, l)),
          (f = n.mul(e, f)),
          (p = n.sub(h, f)),
          (p = n.mul(e, p)),
          (p = n.add(p, l)),
          (l = n.add(h, h)),
          (h = n.add(l, h)),
          (h = n.add(h, f)),
          (h = n.mul(h, p)),
          (u = n.add(u, h)),
          (f = n.mul(s, a)),
          (f = n.add(f, f)),
          (h = n.mul(f, p)),
          (c = n.sub(c, h)),
          (l = n.mul(f, d)),
          (l = n.add(l, l)),
          (l = n.add(l, l)),
          new b(c, u, l)
        );
      }
      add(e) {
        m(e);
        const { px: r, py: o, pz: i } = this,
          { px: s, py: a, pz: c } = e;
        let u = n.ZERO,
          l = n.ZERO,
          h = n.ZERO;
        const d = t.a,
          f = n.mul(t.b, oi);
        let p = n.mul(r, s),
          y = n.mul(o, a),
          g = n.mul(i, c),
          w = n.add(r, o),
          v = n.add(s, a);
        (w = n.mul(w, v)),
          (v = n.add(p, y)),
          (w = n.sub(w, v)),
          (v = n.add(r, i));
        let _ = n.add(s, c);
        return (
          (v = n.mul(v, _)),
          (_ = n.add(p, g)),
          (v = n.sub(v, _)),
          (_ = n.add(o, i)),
          (u = n.add(a, c)),
          (_ = n.mul(_, u)),
          (u = n.add(y, g)),
          (_ = n.sub(_, u)),
          (h = n.mul(d, v)),
          (u = n.mul(f, g)),
          (h = n.add(u, h)),
          (u = n.sub(y, h)),
          (h = n.add(y, h)),
          (l = n.mul(u, h)),
          (y = n.add(p, p)),
          (y = n.add(y, p)),
          (g = n.mul(d, g)),
          (v = n.mul(f, v)),
          (y = n.add(y, g)),
          (g = n.sub(p, g)),
          (g = n.mul(d, g)),
          (v = n.add(v, g)),
          (p = n.mul(y, v)),
          (l = n.add(l, p)),
          (p = n.mul(_, v)),
          (u = n.mul(w, u)),
          (u = n.sub(u, p)),
          (p = n.mul(w, y)),
          (h = n.mul(_, h)),
          (h = n.add(h, p)),
          new b(u, l, h)
        );
      }
      subtract(t) {
        return this.add(t.negate());
      }
      is0() {
        return this.equals(b.ZERO);
      }
      multiply(t) {
        const { endo: n } = e;
        if (!r.isValidNot0(t)) throw new Error("invalid scalar: out of range");
        let o, i;
        const s = (t) => _.wNAFCached(this, t, b.normalizeZ);
        if (n) {
          const { k1neg: e, k1: r, k2neg: a, k2: c } = n.splitScalar(t),
            { p: u, f: l } = s(r),
            { p: h, f: d } = s(c);
          (i = l.add(d)), (o = w(n.beta, u, h, e, a));
        } else {
          const { p: e, f: n } = s(t);
          (o = e), (i = n);
        }
        return b.normalizeZ([o, i])[0];
      }
      multiplyUnsafe(t) {
        const { endo: n } = e,
          o = this;
        if (!r.isValid(t)) throw new Error("invalid scalar: out of range");
        if (t === ei || o.is0()) return b.ZERO;
        if (t === ni) return o;
        if (_.hasPrecomputes(this)) return this.multiply(t);
        if (n) {
          const { k1neg: e, k1: r, k2neg: i, k2: s } = n.splitScalar(t),
            { p1: a, p2: c } = (function (t, e, n, r) {
              let o = e,
                i = t.ZERO,
                s = t.ZERO;
              for (; n > De || r > De; )
                n & Ue && (i = i.add(o)),
                  r & Ue && (s = s.add(o)),
                  (o = o.double()),
                  (n >>= Ue),
                  (r >>= Ue);
              return { p1: i, p2: s };
            })(b, o, r, s);
          return w(n.beta, a, c, e, i);
        }
        return _.wNAFCachedUnsafe(o, t);
      }
      multiplyAndAddUnsafe(t, e, n) {
        const r = this.multiplyUnsafe(e).add(t.multiplyUnsafe(n));
        return r.is0() ? void 0 : r;
      }
      toAffine(t) {
        return y(this, t);
      }
      isTorsionFree() {
        const { isTorsionFree: t } = e;
        return o === ni || (t ? t(b, this) : _.wNAFCachedUnsafe(this, i).is0());
      }
      clearCofactor() {
        const { clearCofactor: t } = e;
        return o === ni ? this : t ? t(b, this) : this.multiplyUnsafe(o);
      }
      toBytes(t = !0) {
        return se("isCompressed", t), this.assertValidity(), c(b, this, t);
      }
      toRawBytes(t = !0) {
        return this.toBytes(t);
      }
      toHex(t = !0) {
        return ht(this.toBytes(t));
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
    }
    (b.BASE = new b(t.Gx, t.Gy, n.ONE)),
      (b.ZERO = new b(n.ZERO, n.ONE, n.ZERO)),
      (b.Fp = n),
      (b.Fn = r);
    const v = r.BITS,
      _ = Ze(b, e.endo ? Math.ceil(v / 2) : v);
    return b;
  }
  function ci(t) {
    return Uint8Array.of(t ? 2 : 3);
  }
  function ui(t, e, n = {}) {
    ge(
      e,
      { hash: "function" },
      {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function",
      }
    );
    const r = e.randomBytes || Et,
      o = e.hmac || ((t, ...n) => Xo(e.hash, t, _t(...n))),
      { Fp: i, Fn: s } = t,
      { ORDER: a, BITS: c } = s;
    function u(t) {
      return t > a >> ni;
    }
    function l(t, e) {
      if (!s.isValidNot0(e))
        throw new Error(`invalid signature ${t}: out of range 1..CURVE.n`);
    }
    class h {
      constructor(t, e, n) {
        l("r", t),
          l("s", e),
          (this.r = t),
          (this.s = e),
          null != n && (this.recovery = n),
          Object.freeze(this);
      }
      static fromCompact(t) {
        const e = s.BYTES,
          n = fe("compactSignature", t, 2 * e);
        return new h(
          s.fromBytes(n.subarray(0, e)),
          s.fromBytes(n.subarray(e, 2 * e))
        );
      }
      static fromDER(t) {
        const { r: e, s: n } = ti.toSig(fe("DER", t));
        return new h(e, n);
      }
      assertValidity() {}
      addRecoveryBit(t) {
        return new h(this.r, this.s, t);
      }
      recoverPublicKey(e) {
        const n = i.ORDER,
          { r: r, s: o, recovery: c } = this;
        if (null == c || ![0, 1, 2, 3].includes(c))
          throw new Error("recovery id invalid");
        if (a * ri < n && c > 1)
          throw new Error("recovery id is ambiguous for h>1 curve");
        const u = 2 === c || 3 === c ? r + a : r;
        if (!i.isValid(u)) throw new Error("recovery id 2 or 3 invalid");
        const l = i.toBytes(u),
          h = t.fromHex(_t(ci(!(1 & c)), l)),
          d = s.inv(u),
          f = y(fe("msgHash", e)),
          p = s.create(-f * d),
          m = s.create(o * d),
          g = t.BASE.multiplyUnsafe(p).add(h.multiplyUnsafe(m));
        if (g.is0()) throw new Error("point at infinify");
        return g.assertValidity(), g;
      }
      hasHighS() {
        return u(this.s);
      }
      normalizeS() {
        return this.hasHighS()
          ? new h(this.r, s.neg(this.s), this.recovery)
          : this;
      }
      toBytes(t) {
        if ("compact" === t) return _t(s.toBytes(this.r), s.toBytes(this.s));
        if ("der" === t) return bt(ti.hexFromSig(this));
        throw new Error("invalid format");
      }
      toDERRawBytes() {
        return this.toBytes("der");
      }
      toDERHex() {
        return ht(this.toBytes("der"));
      }
      toCompactRawBytes() {
        return this.toBytes("compact");
      }
      toCompactHex() {
        return ht(this.toBytes("compact"));
      }
    }
    const d = si(s, n.allowedPrivateKeyLengths, n.wrapPrivateKey),
      f = {
        isValidPrivateKey(t) {
          try {
            return d(t), !0;
          } catch (e) {
            return !1;
          }
        },
        normPrivateKeyToScalar: d,
        randomPrivateKey: () => {
          const t = a;
          return (function (t, e, n = !1) {
            const r = t.length,
              o = Le(e),
              i = ze(e);
            if (r < 16 || r < i || r > 1024)
              throw new Error(
                "expected " + i + "-1024 bytes of input, got " + r
              );
            const s = Ce(n ? le(t) : ue(t), e - ve) + ve;
            return n ? de(s, o) : he(s, o);
          })(r(ze(t)), t);
        },
        precompute: (e = 8, n = t.BASE) => n.precompute(e, !1),
      };
    function p(e) {
      if ("bigint" == typeof e) return !1;
      if (e instanceof t) return !0;
      const r = fe("key", e).length,
        o = i.BYTES,
        a = o + 1,
        c = 2 * o + 1;
      return n.allowedPrivateKeyLengths || s.BYTES === a
        ? void 0
        : r === a || r === c;
    }
    const m =
        e.bits2int ||
        function (t) {
          if (t.length > 8192) throw new Error("input is too large");
          const e = ue(t),
            n = 8 * t.length - c;
          return n > 0 ? e >> BigInt(n) : e;
        },
      y =
        e.bits2int_modN ||
        function (t) {
          return s.create(m(t));
        },
      g = ye(c);
    function w(t) {
      return me("num < 2^" + c, t, ei, g), s.toBytes(t);
    }
    function b(n, o, a = v) {
      if (["recovered", "canonical"].some((t) => t in a))
        throw new Error("sign() legacy options not supported");
      const { hash: c } = e;
      let { lowS: l, prehash: f, extraEntropy: p } = a;
      null == l && (l = !0),
        (n = fe("msgHash", n)),
        $o(a),
        f && (n = fe("prehashed msgHash", c(n)));
      const g = y(n),
        b = d(o),
        _ = [w(b), w(g)];
      if (null != p && !1 !== p) {
        const t = !0 === p ? r(i.BYTES) : p;
        _.push(fe("extraEntropy", t));
      }
      const k = _t(..._),
        A = g;
      return {
        seed: k,
        k2sig: function (e) {
          const n = m(e);
          if (!s.isValidNot0(n)) return;
          const r = s.inv(n),
            o = t.BASE.multiply(n).toAffine(),
            i = s.create(o.x);
          if (i === ei) return;
          const a = s.create(r * s.create(A + i * b));
          if (a === ei) return;
          let c = (o.x === i ? 0 : 2) | Number(o.y & ni),
            d = a;
          return (
            l &&
              u(a) &&
              ((d = (function (t) {
                return u(t) ? s.neg(t) : t;
              })(a)),
              (c ^= 1)),
            new h(i, d, c)
          );
        },
      };
    }
    const v = { lowS: e.lowS, prehash: !1 },
      _ = { lowS: e.lowS, prehash: !1 };
    return (
      t.BASE.precompute(8),
      Object.freeze({
        getPublicKey: function (e, n = !0) {
          return t.fromPrivateKey(e).toBytes(n);
        },
        getSharedSecret: function (e, n, r = !0) {
          if (!0 === p(e)) throw new Error("first arg must be private key");
          if (!1 === p(n)) throw new Error("second arg must be public key");
          return t.fromHex(n).multiply(d(e)).toBytes(r);
        },
        sign: function (t, n, r = v) {
          const { seed: i, k2sig: a } = b(t, n, r);
          return (function (t, e, n) {
            if ("number" != typeof t || t < 2)
              throw new Error("hashLen must be a number");
            if ("number" != typeof e || e < 2)
              throw new Error("qByteLen must be a number");
            if ("function" != typeof n)
              throw new Error("hmacFn must be a function");
            const r = (t) => new Uint8Array(t),
              o = (t) => Uint8Array.of(t);
            let i = r(t),
              s = r(t),
              a = 0;
            const c = () => {
                i.fill(1), s.fill(0), (a = 0);
              },
              u = (...t) => n(s, i, ...t),
              l = (t = r(0)) => {
                (s = u(o(0), t)),
                  (i = u()),
                  0 !== t.length && ((s = u(o(1), t)), (i = u()));
              },
              h = () => {
                if (a++ >= 1e3) throw new Error("drbg: tried 1000 values");
                let t = 0;
                const n = [];
                for (; t < e; ) {
                  i = u();
                  const e = i.slice();
                  n.push(e), (t += i.length);
                }
                return _t(...n);
              };
            return (t, e) => {
              let n;
              for (c(), l(t); !(n = e(h())); ) l();
              return c(), n;
            };
          })(
            e.hash.outputLen,
            s.BYTES,
            o
          )(i, a);
        },
        verify: function (n, r, o, i = _) {
          const a = n;
          (r = fe("msgHash", r)), (o = fe("publicKey", o)), $o(i);
          const { lowS: c, prehash: u, format: l } = i;
          if ("strict" in i)
            throw new Error("options.strict was renamed to lowS");
          if (void 0 !== l && !["compact", "der", "js"].includes(l))
            throw new Error('format must be "compact", "der" or "js"');
          const d = "string" == typeof a || Q(a),
            f =
              !d &&
              !l &&
              "object" == typeof a &&
              null !== a &&
              "bigint" == typeof a.r &&
              "bigint" == typeof a.s;
          if (!d && !f)
            throw new Error(
              "invalid signature, expected Uint8Array, hex string or Signature instance"
            );
          let p, m;
          try {
            if (f) {
              if (void 0 !== l && "js" !== l) throw new Error("invalid format");
              p = new h(a.r, a.s);
            }
            if (d) {
              try {
                "compact" !== l && (p = h.fromDER(a));
              } catch (I) {
                if (!(I instanceof ti.Err)) throw I;
              }
              p || "der" === l || (p = h.fromCompact(a));
            }
            m = t.fromHex(o);
          } catch (C) {
            return !1;
          }
          if (!p) return !1;
          if (c && p.hasHighS()) return !1;
          u && (r = e.hash(r));
          const { r: g, s: w } = p,
            b = y(r),
            v = s.inv(w),
            k = s.create(b * v),
            A = s.create(g * v),
            E = t.BASE.multiplyUnsafe(k).add(m.multiplyUnsafe(A));
          return !E.is0() && s.create(E.x) === g;
        },
        utils: f,
        Point: t,
        Signature: h,
      })
    );
  }
  function li(t) {
    const { CURVE: e, curveOpts: n } = (function (t) {
      const e = {
        a: t.a,
        b: t.b,
        p: t.Fp.ORDER,
        n: t.n,
        h: t.h,
        Gx: t.Gx,
        Gy: t.Gy,
      };
      return {
        CURVE: e,
        curveOpts: {
          Fp: t.Fp,
          Fn: Pe(e.n, t.nBitLength),
          allowedPrivateKeyLengths: t.allowedPrivateKeyLengths,
          allowInfinityPoint: t.allowInfinityPoint,
          endo: t.endo,
          wrapPrivateKey: t.wrapPrivateKey,
          isTorsionFree: t.isTorsionFree,
          clearCofactor: t.clearCofactor,
          fromBytes: t.fromBytes,
          toBytes: t.toBytes,
        },
      };
    })(t);
    return {
      CURVE: e,
      curveOpts: n,
      ecdsaOpts: {
        hash: t.hash,
        hmac: t.hmac,
        randomBytes: t.randomBytes,
        lowS: t.lowS,
        bits2int: t.bits2int,
        bits2int_modN: t.bits2int_modN,
      },
    };
  }
  function hi(t) {
    const { CURVE: e, curveOpts: n, ecdsaOpts: r } = li(t);
    return (function (t, e) {
      return Object.assign({}, e, { ProjectivePoint: e.Point, CURVE: t });
    })(t, ui(ai(e, n), r, n));
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const di = {
    p: BigInt(
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
    ),
    n: BigInt(
      "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
    ),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt(
      "0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
    ),
    Gy: BigInt(
      "0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
    ),
  };
  BigInt(0);
  const fi = BigInt(1),
    pi = BigInt(2),
    mi = (t, e) => (t + e / pi) / e;
  const yi = Pe(di.p, void 0, void 0, {
      sqrt: function (t) {
        const e = di.p,
          n = BigInt(3),
          r = BigInt(6),
          o = BigInt(11),
          i = BigInt(22),
          s = BigInt(23),
          a = BigInt(44),
          c = BigInt(88),
          u = (t * t * t) % e,
          l = (u * u * t) % e,
          h = (Se(l, n, e) * l) % e,
          d = (Se(h, n, e) * l) % e,
          f = (Se(d, pi, e) * u) % e,
          p = (Se(f, o, e) * f) % e,
          m = (Se(p, i, e) * p) % e,
          y = (Se(m, a, e) * m) % e,
          g = (Se(y, c, e) * y) % e,
          w = (Se(g, a, e) * m) % e,
          b = (Se(w, n, e) * l) % e,
          v = (Se(b, s, e) * p) % e,
          _ = (Se(v, r, e) * u) % e,
          k = Se(_, pi, e);
        if (!yi.eql(yi.sqr(k), t)) throw new Error("Cannot find square root");
        return k;
      },
    }),
    gi = (function (t, e) {
      const n = (e) => hi({ ...t, hash: e });
      return { ...n(e), create: n };
    })(
      {
        ...di,
        Fp: yi,
        lowS: !0,
        endo: {
          beta: BigInt(
            "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
          ),
          splitScalar: (t) => {
            const e = di.n,
              n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
              r = -fi * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
              o = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
              i = n,
              s = BigInt("0x100000000000000000000000000000000"),
              a = mi(i * t, e),
              c = mi(-r * t, e);
            let u = Ce(t - a * n - c * o, e),
              l = Ce(-a * r - c * i, e);
            const h = u > s,
              d = l > s;
            if ((h && (u = e - u), d && (l = e - l), u > s || l > s))
              throw new Error("splitScalar: Endomorphism failed, k=" + t);
            return { k1neg: h, k1: u, k2neg: d, k2: l };
          },
        },
      },
      ne
    );
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const wi = gn.utils.randomPrivateKey,
    bi = () => {
      const t = gn.utils.randomPrivateKey(),
        e = vi(t),
        n = new Uint8Array(64);
      return n.set(t), n.set(e, 32), { publicKey: e, secretKey: n };
    },
    vi = gn.getPublicKey;
  function _i(t) {
    try {
      return gn.ExtendedPoint.fromHex(t), !0;
    } catch {
      return !1;
    }
  }
  const ki = (t, e) => gn.sign(t, e.slice(0, 32)),
    Ai = gn.verify,
    Ei = (t) =>
      X.isBuffer(t)
        ? t
        : t instanceof Uint8Array
        ? X.from(t.buffer, t.byteOffset, t.byteLength)
        : X.from(t);
  let Ii = class {
    constructor(t) {
      Object.assign(this, t);
    }
    encode() {
      return X.from(ur.serialize(Ci, this));
    }
    static decode(t) {
      return ur.deserialize(Ci, this, t);
    }
    static decodeUnchecked(t) {
      return ur.deserializeUnchecked(Ci, this, t);
    }
  };
  const Ci = new Map();
  var Si;
  const Bi = 32;
  let xi = 1;
  class Ti extends Ii {
    constructor(t) {
      if (
        (super({}),
        (this._bn = void 0),
        (function (t) {
          return void 0 !== t._bn;
        })(t))
      )
        this._bn = t._bn;
      else {
        if ("string" == typeof t) {
          const e = Wn.decode(t);
          if (e.length != Bi) throw new Error("Invalid public key input");
          this._bn = new Mn(e);
        } else this._bn = new Mn(t);
        if (this._bn.byteLength() > Bi)
          throw new Error("Invalid public key input");
      }
    }
    static unique() {
      const t = new Ti(xi);
      return (xi += 1), new Ti(t.toBuffer());
    }
    equals(t) {
      return this._bn.eq(t._bn);
    }
    toBase58() {
      return Wn.encode(this.toBytes());
    }
    toJSON() {
      return this.toBase58();
    }
    toBytes() {
      const t = this.toBuffer();
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    }
    toBuffer() {
      const t = this._bn.toArrayLike(X);
      if (t.length === Bi) return t;
      const e = X.alloc(32);
      return t.copy(e, 32 - t.length), e;
    }
    get [Symbol.toStringTag]() {
      return `PublicKey(${this.toString()})`;
    }
    toString() {
      return this.toBase58();
    }
    static async createWithSeed(t, e, n) {
      const r = X.concat([t.toBuffer(), X.from(e), n.toBuffer()]),
        o = Kn(r);
      return new Ti(o);
    }
    static createProgramAddressSync(t, e) {
      let n = X.alloc(0);
      t.forEach(function (t) {
        if (t.length > 32) throw new TypeError("Max seed length exceeded");
        n = X.concat([n, Ei(t)]);
      }),
        (n = X.concat([n, e.toBuffer(), X.from("ProgramDerivedAddress")]));
      const r = Kn(n);
      if (_i(r))
        throw new Error("Invalid seeds, address must fall off the curve");
      return new Ti(r);
    }
    static async createProgramAddress(t, e) {
      return this.createProgramAddressSync(t, e);
    }
    static findProgramAddressSync(t, e) {
      let n,
        r = 255;
      for (; 0 != r; ) {
        try {
          const o = t.concat(X.from([r]));
          n = this.createProgramAddressSync(o, e);
        } catch (o) {
          if (o instanceof TypeError) throw o;
          r--;
          continue;
        }
        return [n, r];
      }
      throw new Error("Unable to find a viable program address nonce");
    }
    static async findProgramAddress(t, e) {
      return this.findProgramAddressSync(t, e);
    }
    static isOnCurve(t) {
      return _i(new Ti(t).toBytes());
    }
  }
  (Si = Ti),
    (Ti.default = new Si("11111111111111111111111111111111")),
    Ci.set(Ti, { kind: "struct", fields: [["_bn", "u256"]] });
  const Ri = new Ti("BPFLoader1111111111111111111111111111111111"),
    Oi = 1232,
    Mi = 127;
  class Ni extends Error {
    constructor(t) {
      super(`Signature ${t} has expired: block height exceeded.`),
        (this.signature = void 0),
        (this.signature = t);
    }
  }
  Object.defineProperty(Ni.prototype, "name", {
    value: "TransactionExpiredBlockheightExceededError",
  });
  class Pi extends Error {
    constructor(t, e) {
      super(
        `Transaction was not confirmed in ${e.toFixed(
          2
        )} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`
      ),
        (this.signature = void 0),
        (this.signature = t);
    }
  }
  Object.defineProperty(Pi.prototype, "name", {
    value: "TransactionExpiredTimeoutError",
  });
  class Li extends Error {
    constructor(t) {
      super(`Signature ${t} has expired: the nonce is no longer valid.`),
        (this.signature = void 0),
        (this.signature = t);
    }
  }
  Object.defineProperty(Li.prototype, "name", {
    value: "TransactionExpiredNonceInvalidError",
  });
  class zi {
    constructor(t, e) {
      (this.staticAccountKeys = void 0),
        (this.accountKeysFromLookups = void 0),
        (this.staticAccountKeys = t),
        (this.accountKeysFromLookups = e);
    }
    keySegments() {
      const t = [this.staticAccountKeys];
      return (
        this.accountKeysFromLookups &&
          (t.push(this.accountKeysFromLookups.writable),
          t.push(this.accountKeysFromLookups.readonly)),
        t
      );
    }
    get(t) {
      for (const e of this.keySegments()) {
        if (t < e.length) return e[t];
        t -= e.length;
      }
    }
    get length() {
      return this.keySegments().flat().length;
    }
    compileInstructions(t) {
      if (this.length > 256)
        throw new Error(
          "Account index overflow encountered during compilation"
        );
      const e = new Map();
      this.keySegments()
        .flat()
        .forEach((t, n) => {
          e.set(t.toBase58(), n);
        });
      const n = (t) => {
        const n = e.get(t.toBase58());
        if (void 0 === n)
          throw new Error(
            "Encountered an unknown instruction account key during compilation"
          );
        return n;
      };
      return t.map((t) => ({
        programIdIndex: n(t.programId),
        accountKeyIndexes: t.keys.map((t) => n(t.pubkey)),
        data: t.data,
      }));
    }
  }
  const Di = (t = "publicKey") => hr.blob(32, t),
    Ui = (t = "signature") => hr.blob(64, t),
    qi = (t = "string") => {
      const e = hr.struct(
          [
            hr.u32("length"),
            hr.u32("lengthPadding"),
            hr.blob(hr.offset(hr.u32(), -8), "chars"),
          ],
          t
        ),
        n = e.decode.bind(e),
        r = e.encode.bind(e),
        o = e;
      return (
        (o.decode = (t, e) => n(t, e).chars.toString()),
        (o.encode = (t, e, n) => {
          const o = { chars: X.from(t, "utf8") };
          return r(o, e, n);
        }),
        (o.alloc = (t) =>
          hr.u32().span + hr.u32().span + X.from(t, "utf8").length),
        o
      );
    };
  function Gi(t, e) {
    const n = (t) => {
      if (t.span >= 0) return t.span;
      if ("function" == typeof t.alloc) return t.alloc(e[t.property]);
      if ("count" in t && "elementLayout" in t) {
        const r = e[t.property];
        if (Array.isArray(r)) return r.length * n(t.elementLayout);
      } else if ("fields" in t) return Gi({ layout: t }, e[t.property]);
      return 0;
    };
    let r = 0;
    return (
      t.layout.fields.forEach((t) => {
        r += n(t);
      }),
      r
    );
  }
  function Wi(t) {
    let e = 0,
      n = 0;
    for (;;) {
      let r = t.shift();
      if (((e |= (127 & r) << (7 * n)), (n += 1), !(128 & r))) break;
    }
    return e;
  }
  function Ki(t, e) {
    let n = e;
    for (;;) {
      let e = 127 & n;
      if (((n >>= 7), 0 == n)) {
        t.push(e);
        break;
      }
      (e |= 128), t.push(e);
    }
  }
  function ji(t, e) {
    if (!t) throw new Error(e || "Assertion failed");
  }
  class Hi {
    constructor(t, e) {
      (this.payer = void 0),
        (this.keyMetaMap = void 0),
        (this.payer = t),
        (this.keyMetaMap = e);
    }
    static compile(t, e) {
      const n = new Map(),
        r = (t) => {
          const e = t.toBase58();
          let r = n.get(e);
          return (
            void 0 === r &&
              ((r = { isSigner: !1, isWritable: !1, isInvoked: !1 }),
              n.set(e, r)),
            r
          );
        },
        o = r(e);
      (o.isSigner = !0), (o.isWritable = !0);
      for (const i of t) {
        r(i.programId).isInvoked = !0;
        for (const t of i.keys) {
          const e = r(t.pubkey);
          e.isSigner || (e.isSigner = t.isSigner),
            e.isWritable || (e.isWritable = t.isWritable);
        }
      }
      return new Hi(e, n);
    }
    getMessageComponents() {
      const t = [...this.keyMetaMap.entries()];
      ji(t.length <= 256, "Max static account keys length exceeded");
      const e = t.filter(([, t]) => t.isSigner && t.isWritable),
        n = t.filter(([, t]) => t.isSigner && !t.isWritable),
        r = t.filter(([, t]) => !t.isSigner && t.isWritable),
        o = t.filter(([, t]) => !t.isSigner && !t.isWritable),
        i = {
          numRequiredSignatures: e.length + n.length,
          numReadonlySignedAccounts: n.length,
          numReadonlyUnsignedAccounts: o.length,
        };
      {
        ji(e.length > 0, "Expected at least one writable signer key");
        const [t] = e[0];
        ji(
          t === this.payer.toBase58(),
          "Expected first writable signer key to be the fee payer"
        );
      }
      return [
        i,
        [
          ...e.map(([t]) => new Ti(t)),
          ...n.map(([t]) => new Ti(t)),
          ...r.map(([t]) => new Ti(t)),
          ...o.map(([t]) => new Ti(t)),
        ],
      ];
    }
    extractTableLookup(t) {
      const [e, n] = this.drainKeysFoundInLookupTable(
          t.state.addresses,
          (t) => !t.isSigner && !t.isInvoked && t.isWritable
        ),
        [r, o] = this.drainKeysFoundInLookupTable(
          t.state.addresses,
          (t) => !t.isSigner && !t.isInvoked && !t.isWritable
        );
      if (0 !== e.length || 0 !== r.length)
        return [
          { accountKey: t.key, writableIndexes: e, readonlyIndexes: r },
          { writable: n, readonly: o },
        ];
    }
    drainKeysFoundInLookupTable(t, e) {
      const n = new Array(),
        r = new Array();
      for (const [o, i] of this.keyMetaMap.entries())
        if (e(i)) {
          const e = new Ti(o),
            i = t.findIndex((t) => t.equals(e));
          i >= 0 &&
            (ji(i < 256, "Max lookup table index exceeded"),
            n.push(i),
            r.push(e),
            this.keyMetaMap.delete(o));
        }
      return [n, r];
    }
  }
  const Vi = "Reached end of buffer unexpectedly";
  function Fi(t) {
    if (0 === t.length) throw new Error(Vi);
    return t.shift();
  }
  function Yi(t, ...e) {
    const [n] = e;
    if (2 === e.length ? n + (e[1] ?? 0) > t.length : n >= t.length)
      throw new Error(Vi);
    return t.splice(...e);
  }
  class Zi {
    constructor(t) {
      (this.header = void 0),
        (this.accountKeys = void 0),
        (this.recentBlockhash = void 0),
        (this.instructions = void 0),
        (this.indexToProgramIds = new Map()),
        (this.header = t.header),
        (this.accountKeys = t.accountKeys.map((t) => new Ti(t))),
        (this.recentBlockhash = t.recentBlockhash),
        (this.instructions = t.instructions),
        this.instructions.forEach((t) =>
          this.indexToProgramIds.set(
            t.programIdIndex,
            this.accountKeys[t.programIdIndex]
          )
        );
    }
    get version() {
      return "legacy";
    }
    get staticAccountKeys() {
      return this.accountKeys;
    }
    get compiledInstructions() {
      return this.instructions.map((t) => ({
        programIdIndex: t.programIdIndex,
        accountKeyIndexes: t.accounts,
        data: Wn.decode(t.data),
      }));
    }
    get addressTableLookups() {
      return [];
    }
    getAccountKeys() {
      return new zi(this.staticAccountKeys);
    }
    static compile(t) {
      const e = Hi.compile(t.instructions, t.payerKey),
        [n, r] = e.getMessageComponents(),
        o = new zi(r)
          .compileInstructions(t.instructions)
          .map((t) => ({
            programIdIndex: t.programIdIndex,
            accounts: t.accountKeyIndexes,
            data: Wn.encode(t.data),
          }));
      return new Zi({
        header: n,
        accountKeys: r,
        recentBlockhash: t.recentBlockhash,
        instructions: o,
      });
    }
    isAccountSigner(t) {
      return t < this.header.numRequiredSignatures;
    }
    isAccountWritable(t) {
      const e = this.header.numRequiredSignatures;
      if (t >= this.header.numRequiredSignatures) {
        return (
          t - e <
          this.accountKeys.length - e - this.header.numReadonlyUnsignedAccounts
        );
      }
      return t < e - this.header.numReadonlySignedAccounts;
    }
    isProgramId(t) {
      return this.indexToProgramIds.has(t);
    }
    programIds() {
      return [...this.indexToProgramIds.values()];
    }
    nonProgramIds() {
      return this.accountKeys.filter((t, e) => !this.isProgramId(e));
    }
    serialize() {
      const t = this.accountKeys.length;
      let e = [];
      Ki(e, t);
      const n = this.instructions.map((t) => {
        const { accounts: e, programIdIndex: n } = t,
          r = Array.from(Wn.decode(t.data));
        let o = [];
        Ki(o, e.length);
        let i = [];
        return (
          Ki(i, r.length),
          {
            programIdIndex: n,
            keyIndicesCount: X.from(o),
            keyIndices: e,
            dataLength: X.from(i),
            data: r,
          }
        );
      });
      let r = [];
      Ki(r, n.length);
      let o = X.alloc(Oi);
      X.from(r).copy(o);
      let i = r.length;
      n.forEach((t) => {
        const e = hr
          .struct([
            hr.u8("programIdIndex"),
            hr.blob(t.keyIndicesCount.length, "keyIndicesCount"),
            hr.seq(hr.u8("keyIndex"), t.keyIndices.length, "keyIndices"),
            hr.blob(t.dataLength.length, "dataLength"),
            hr.seq(hr.u8("userdatum"), t.data.length, "data"),
          ])
          .encode(t, o, i);
        i += e;
      }),
        (o = o.slice(0, i));
      const s = hr.struct([
          hr.blob(1, "numRequiredSignatures"),
          hr.blob(1, "numReadonlySignedAccounts"),
          hr.blob(1, "numReadonlyUnsignedAccounts"),
          hr.blob(e.length, "keyCount"),
          hr.seq(Di("key"), t, "keys"),
          Di("recentBlockhash"),
        ]),
        a = {
          numRequiredSignatures: X.from([this.header.numRequiredSignatures]),
          numReadonlySignedAccounts: X.from([
            this.header.numReadonlySignedAccounts,
          ]),
          numReadonlyUnsignedAccounts: X.from([
            this.header.numReadonlyUnsignedAccounts,
          ]),
          keyCount: X.from(e),
          keys: this.accountKeys.map((t) => Ei(t.toBytes())),
          recentBlockhash: Wn.decode(this.recentBlockhash),
        };
      let c = X.alloc(2048);
      const u = s.encode(a, c);
      return o.copy(c, u), c.slice(0, u + o.length);
    }
    static from(t) {
      let e = [...t];
      const n = Fi(e);
      if (n !== (n & Mi))
        throw new Error(
          "Versioned messages must be deserialized with VersionedMessage.deserialize()"
        );
      const r = Fi(e),
        o = Fi(e),
        i = Wi(e);
      let s = [];
      for (let h = 0; h < i; h++) {
        const t = Yi(e, 0, Bi);
        s.push(new Ti(X.from(t)));
      }
      const a = Yi(e, 0, Bi),
        c = Wi(e);
      let u = [];
      for (let h = 0; h < c; h++) {
        const t = Fi(e),
          n = Yi(e, 0, Wi(e)),
          r = Yi(e, 0, Wi(e)),
          o = Wn.encode(X.from(r));
        u.push({ programIdIndex: t, accounts: n, data: o });
      }
      const l = {
        header: {
          numRequiredSignatures: n,
          numReadonlySignedAccounts: r,
          numReadonlyUnsignedAccounts: o,
        },
        recentBlockhash: Wn.encode(X.from(a)),
        accountKeys: s,
        instructions: u,
      };
      return new Zi(l);
    }
  }
  class Ji {
    constructor(t) {
      (this.header = void 0),
        (this.staticAccountKeys = void 0),
        (this.recentBlockhash = void 0),
        (this.compiledInstructions = void 0),
        (this.addressTableLookups = void 0),
        (this.header = t.header),
        (this.staticAccountKeys = t.staticAccountKeys),
        (this.recentBlockhash = t.recentBlockhash),
        (this.compiledInstructions = t.compiledInstructions),
        (this.addressTableLookups = t.addressTableLookups);
    }
    get version() {
      return 0;
    }
    get numAccountKeysFromLookups() {
      let t = 0;
      for (const e of this.addressTableLookups)
        t += e.readonlyIndexes.length + e.writableIndexes.length;
      return t;
    }
    getAccountKeys(t) {
      let e;
      if (t && "accountKeysFromLookups" in t && t.accountKeysFromLookups) {
        if (
          this.numAccountKeysFromLookups !=
          t.accountKeysFromLookups.writable.length +
            t.accountKeysFromLookups.readonly.length
        )
          throw new Error(
            "Failed to get account keys because of a mismatch in the number of account keys from lookups"
          );
        e = t.accountKeysFromLookups;
      } else if (
        t &&
        "addressLookupTableAccounts" in t &&
        t.addressLookupTableAccounts
      )
        e = this.resolveAddressTableLookups(t.addressLookupTableAccounts);
      else if (this.addressTableLookups.length > 0)
        throw new Error(
          "Failed to get account keys because address table lookups were not resolved"
        );
      return new zi(this.staticAccountKeys, e);
    }
    isAccountSigner(t) {
      return t < this.header.numRequiredSignatures;
    }
    isAccountWritable(t) {
      const e = this.header.numRequiredSignatures,
        n = this.staticAccountKeys.length;
      if (t >= n) {
        return (
          t - n <
          this.addressTableLookups.reduce(
            (t, e) => t + e.writableIndexes.length,
            0
          )
        );
      }
      if (t >= this.header.numRequiredSignatures) {
        return t - e < n - e - this.header.numReadonlyUnsignedAccounts;
      }
      return t < e - this.header.numReadonlySignedAccounts;
    }
    resolveAddressTableLookups(t) {
      const e = { writable: [], readonly: [] };
      for (const n of this.addressTableLookups) {
        const r = t.find((t) => t.key.equals(n.accountKey));
        if (!r)
          throw new Error(
            `Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`
          );
        for (const t of n.writableIndexes) {
          if (!(t < r.state.addresses.length))
            throw new Error(
              `Failed to find address for index ${t} in address lookup table ${n.accountKey.toBase58()}`
            );
          e.writable.push(r.state.addresses[t]);
        }
        for (const t of n.readonlyIndexes) {
          if (!(t < r.state.addresses.length))
            throw new Error(
              `Failed to find address for index ${t} in address lookup table ${n.accountKey.toBase58()}`
            );
          e.readonly.push(r.state.addresses[t]);
        }
      }
      return e;
    }
    static compile(t) {
      const e = Hi.compile(t.instructions, t.payerKey),
        n = new Array(),
        r = { writable: new Array(), readonly: new Array() },
        o = t.addressLookupTableAccounts || [];
      for (const c of o) {
        const t = e.extractTableLookup(c);
        if (void 0 !== t) {
          const [e, { writable: o, readonly: i }] = t;
          n.push(e), r.writable.push(...o), r.readonly.push(...i);
        }
      }
      const [i, s] = e.getMessageComponents(),
        a = new zi(s, r).compileInstructions(t.instructions);
      return new Ji({
        header: i,
        staticAccountKeys: s,
        recentBlockhash: t.recentBlockhash,
        compiledInstructions: a,
        addressTableLookups: n,
      });
    }
    serialize() {
      const t = Array();
      Ki(t, this.staticAccountKeys.length);
      const e = this.serializeInstructions(),
        n = Array();
      Ki(n, this.compiledInstructions.length);
      const r = this.serializeAddressTableLookups(),
        o = Array();
      Ki(o, this.addressTableLookups.length);
      const i = hr.struct([
          hr.u8("prefix"),
          hr.struct(
            [
              hr.u8("numRequiredSignatures"),
              hr.u8("numReadonlySignedAccounts"),
              hr.u8("numReadonlyUnsignedAccounts"),
            ],
            "header"
          ),
          hr.blob(t.length, "staticAccountKeysLength"),
          hr.seq(Di(), this.staticAccountKeys.length, "staticAccountKeys"),
          Di("recentBlockhash"),
          hr.blob(n.length, "instructionsLength"),
          hr.blob(e.length, "serializedInstructions"),
          hr.blob(o.length, "addressTableLookupsLength"),
          hr.blob(r.length, "serializedAddressTableLookups"),
        ]),
        s = new Uint8Array(Oi),
        a = i.encode(
          {
            prefix: 128,
            header: this.header,
            staticAccountKeysLength: new Uint8Array(t),
            staticAccountKeys: this.staticAccountKeys.map((t) => t.toBytes()),
            recentBlockhash: Wn.decode(this.recentBlockhash),
            instructionsLength: new Uint8Array(n),
            serializedInstructions: e,
            addressTableLookupsLength: new Uint8Array(o),
            serializedAddressTableLookups: r,
          },
          s
        );
      return s.slice(0, a);
    }
    serializeInstructions() {
      let t = 0;
      const e = new Uint8Array(Oi);
      for (const n of this.compiledInstructions) {
        const r = Array();
        Ki(r, n.accountKeyIndexes.length);
        const o = Array();
        Ki(o, n.data.length);
        t += hr
          .struct([
            hr.u8("programIdIndex"),
            hr.blob(r.length, "encodedAccountKeyIndexesLength"),
            hr.seq(hr.u8(), n.accountKeyIndexes.length, "accountKeyIndexes"),
            hr.blob(o.length, "encodedDataLength"),
            hr.blob(n.data.length, "data"),
          ])
          .encode(
            {
              programIdIndex: n.programIdIndex,
              encodedAccountKeyIndexesLength: new Uint8Array(r),
              accountKeyIndexes: n.accountKeyIndexes,
              encodedDataLength: new Uint8Array(o),
              data: n.data,
            },
            e,
            t
          );
      }
      return e.slice(0, t);
    }
    serializeAddressTableLookups() {
      let t = 0;
      const e = new Uint8Array(Oi);
      for (const n of this.addressTableLookups) {
        const r = Array();
        Ki(r, n.writableIndexes.length);
        const o = Array();
        Ki(o, n.readonlyIndexes.length);
        t += hr
          .struct([
            Di("accountKey"),
            hr.blob(r.length, "encodedWritableIndexesLength"),
            hr.seq(hr.u8(), n.writableIndexes.length, "writableIndexes"),
            hr.blob(o.length, "encodedReadonlyIndexesLength"),
            hr.seq(hr.u8(), n.readonlyIndexes.length, "readonlyIndexes"),
          ])
          .encode(
            {
              accountKey: n.accountKey.toBytes(),
              encodedWritableIndexesLength: new Uint8Array(r),
              writableIndexes: n.writableIndexes,
              encodedReadonlyIndexesLength: new Uint8Array(o),
              readonlyIndexes: n.readonlyIndexes,
            },
            e,
            t
          );
      }
      return e.slice(0, t);
    }
    static deserialize(t) {
      let e = [...t];
      const n = Fi(e),
        r = n & Mi;
      ji(n !== r, "Expected versioned message but received legacy message");
      ji(
        0 === r,
        `Expected versioned message with version 0 but found version ${r}`
      );
      const o = {
          numRequiredSignatures: Fi(e),
          numReadonlySignedAccounts: Fi(e),
          numReadonlyUnsignedAccounts: Fi(e),
        },
        i = [],
        s = Wi(e);
      for (let d = 0; d < s; d++) i.push(new Ti(Yi(e, 0, Bi)));
      const a = Wn.encode(Yi(e, 0, Bi)),
        c = Wi(e),
        u = [];
      for (let d = 0; d < c; d++) {
        const t = Fi(e),
          n = Yi(e, 0, Wi(e)),
          r = Wi(e),
          o = new Uint8Array(Yi(e, 0, r));
        u.push({ programIdIndex: t, accountKeyIndexes: n, data: o });
      }
      const l = Wi(e),
        h = [];
      for (let d = 0; d < l; d++) {
        const t = new Ti(Yi(e, 0, Bi)),
          n = Yi(e, 0, Wi(e)),
          r = Yi(e, 0, Wi(e));
        h.push({ accountKey: t, writableIndexes: n, readonlyIndexes: r });
      }
      return new Ji({
        header: o,
        staticAccountKeys: i,
        recentBlockhash: a,
        compiledInstructions: u,
        addressTableLookups: h,
      });
    }
  }
  const Xi = {
    deserializeMessageVersion(t) {
      const e = t[0],
        n = e & Mi;
      return n === e ? "legacy" : n;
    },
    deserialize: (t) => {
      const e = Xi.deserializeMessageVersion(t);
      if ("legacy" === e) return Zi.from(t);
      if (0 === e) return Ji.deserialize(t);
      throw new Error(
        `Transaction message version ${e} deserialization is not supported`
      );
    },
  };
  let $i = (function (t) {
    return (
      (t[(t.BLOCKHEIGHT_EXCEEDED = 0)] = "BLOCKHEIGHT_EXCEEDED"),
      (t[(t.PROCESSED = 1)] = "PROCESSED"),
      (t[(t.TIMED_OUT = 2)] = "TIMED_OUT"),
      (t[(t.NONCE_INVALID = 3)] = "NONCE_INVALID"),
      t
    );
  })({});
  const Qi = X.alloc(64).fill(0);
  class ts {
    constructor(t) {
      (this.keys = void 0),
        (this.programId = void 0),
        (this.data = X.alloc(0)),
        (this.programId = t.programId),
        (this.keys = t.keys),
        t.data && (this.data = t.data);
    }
    toJSON() {
      return {
        keys: this.keys.map(({ pubkey: t, isSigner: e, isWritable: n }) => ({
          pubkey: t.toJSON(),
          isSigner: e,
          isWritable: n,
        })),
        programId: this.programId.toJSON(),
        data: [...this.data],
      };
    }
  }
  class es {
    get signature() {
      return this.signatures.length > 0 ? this.signatures[0].signature : null;
    }
    constructor(t) {
      if (
        ((this.signatures = []),
        (this.feePayer = void 0),
        (this.instructions = []),
        (this.recentBlockhash = void 0),
        (this.lastValidBlockHeight = void 0),
        (this.nonceInfo = void 0),
        (this.minNonceContextSlot = void 0),
        (this._message = void 0),
        (this._json = void 0),
        t)
      )
        if (
          (t.feePayer && (this.feePayer = t.feePayer),
          t.signatures && (this.signatures = t.signatures),
          Object.prototype.hasOwnProperty.call(t, "nonceInfo"))
        ) {
          const { minContextSlot: e, nonceInfo: n } = t;
          (this.minNonceContextSlot = e), (this.nonceInfo = n);
        } else if (
          Object.prototype.hasOwnProperty.call(t, "lastValidBlockHeight")
        ) {
          const { blockhash: e, lastValidBlockHeight: n } = t;
          (this.recentBlockhash = e), (this.lastValidBlockHeight = n);
        } else {
          const { recentBlockhash: e, nonceInfo: n } = t;
          n && (this.nonceInfo = n), (this.recentBlockhash = e);
        }
    }
    toJSON() {
      return {
        recentBlockhash: this.recentBlockhash || null,
        feePayer: this.feePayer ? this.feePayer.toJSON() : null,
        nonceInfo: this.nonceInfo
          ? {
              nonce: this.nonceInfo.nonce,
              nonceInstruction: this.nonceInfo.nonceInstruction.toJSON(),
            }
          : null,
        instructions: this.instructions.map((t) => t.toJSON()),
        signers: this.signatures.map(({ publicKey: t }) => t.toJSON()),
      };
    }
    add(...t) {
      if (0 === t.length) throw new Error("No instructions");
      return (
        t.forEach((t) => {
          "instructions" in t
            ? (this.instructions = this.instructions.concat(t.instructions))
            : "data" in t && "programId" in t && "keys" in t
            ? this.instructions.push(t)
            : this.instructions.push(new ts(t));
        }),
        this
      );
    }
    compileMessage() {
      if (
        this._message &&
        JSON.stringify(this.toJSON()) === JSON.stringify(this._json)
      )
        return this._message;
      let t, e, n;
      if (
        (this.nonceInfo
          ? ((t = this.nonceInfo.nonce),
            (e =
              this.instructions[0] != this.nonceInfo.nonceInstruction
                ? [this.nonceInfo.nonceInstruction, ...this.instructions]
                : this.instructions))
          : ((t = this.recentBlockhash), (e = this.instructions)),
        !t)
      )
        throw new Error("Transaction recentBlockhash required");
      if ((e.length < 1, 0, this.feePayer)) n = this.feePayer;
      else {
        if (!(this.signatures.length > 0 && this.signatures[0].publicKey))
          throw new Error("Transaction fee payer required");
        n = this.signatures[0].publicKey;
      }
      for (let p = 0; p < e.length; p++)
        if (void 0 === e[p].programId)
          throw new Error(
            `Transaction instruction index ${p} has undefined program id`
          );
      const r = [],
        o = [];
      e.forEach((t) => {
        t.keys.forEach((t) => {
          o.push({ ...t });
        });
        const e = t.programId.toString();
        r.includes(e) || r.push(e);
      }),
        r.forEach((t) => {
          o.push({ pubkey: new Ti(t), isSigner: !1, isWritable: !1 });
        });
      const i = [];
      o.forEach((t) => {
        const e = t.pubkey.toString(),
          n = i.findIndex((t) => t.pubkey.toString() === e);
        n > -1
          ? ((i[n].isWritable = i[n].isWritable || t.isWritable),
            (i[n].isSigner = i[n].isSigner || t.isSigner))
          : i.push(t);
      }),
        i.sort(function (t, e) {
          if (t.isSigner !== e.isSigner) return t.isSigner ? -1 : 1;
          if (t.isWritable !== e.isWritable) return t.isWritable ? -1 : 1;
          return t.pubkey
            .toBase58()
            .localeCompare(e.pubkey.toBase58(), "en", {
              localeMatcher: "best fit",
              usage: "sort",
              sensitivity: "variant",
              ignorePunctuation: !1,
              numeric: !1,
              caseFirst: "lower",
            });
        });
      const s = i.findIndex((t) => t.pubkey.equals(n));
      if (s > -1) {
        const [t] = i.splice(s, 1);
        (t.isSigner = !0), (t.isWritable = !0), i.unshift(t);
      } else i.unshift({ pubkey: n, isSigner: !0, isWritable: !0 });
      for (const p of this.signatures) {
        const t = i.findIndex((t) => t.pubkey.equals(p.publicKey));
        if (!(t > -1))
          throw new Error(`unknown signer: ${p.publicKey.toString()}`);
        i[t].isSigner || (i[t].isSigner = !0);
      }
      let a = 0,
        c = 0,
        u = 0;
      const l = [],
        h = [];
      i.forEach(({ pubkey: t, isSigner: e, isWritable: n }) => {
        e
          ? (l.push(t.toString()), (a += 1), n || (c += 1))
          : (h.push(t.toString()), n || (u += 1));
      });
      const d = l.concat(h),
        f = e.map((t) => {
          const { data: e, programId: n } = t;
          return {
            programIdIndex: d.indexOf(n.toString()),
            accounts: t.keys.map((t) => d.indexOf(t.pubkey.toString())),
            data: Wn.encode(e),
          };
        });
      return (
        f.forEach((t) => {
          ji(t.programIdIndex >= 0), t.accounts.forEach((t) => ji(t >= 0));
        }),
        new Zi({
          header: {
            numRequiredSignatures: a,
            numReadonlySignedAccounts: c,
            numReadonlyUnsignedAccounts: u,
          },
          accountKeys: d,
          recentBlockhash: t,
          instructions: f,
        })
      );
    }
    _compile() {
      const t = this.compileMessage(),
        e = t.accountKeys.slice(0, t.header.numRequiredSignatures);
      if (this.signatures.length === e.length) {
        if (this.signatures.every((t, n) => e[n].equals(t.publicKey))) return t;
      }
      return (
        (this.signatures = e.map((t) => ({ signature: null, publicKey: t }))), t
      );
    }
    serializeMessage() {
      return this._compile().serialize();
    }
    async getEstimatedFee(t) {
      return (await t.getFeeForMessage(this.compileMessage())).value;
    }
    setSigners(...t) {
      if (0 === t.length) throw new Error("No signers");
      const e = new Set();
      this.signatures = t
        .filter((t) => {
          const n = t.toString();
          return !e.has(n) && (e.add(n), !0);
        })
        .map((t) => ({ signature: null, publicKey: t }));
    }
    sign(...t) {
      if (0 === t.length) throw new Error("No signers");
      const e = new Set(),
        n = [];
      for (const o of t) {
        const t = o.publicKey.toString();
        e.has(t) || (e.add(t), n.push(o));
      }
      this.signatures = n.map((t) => ({
        signature: null,
        publicKey: t.publicKey,
      }));
      const r = this._compile();
      this._partialSign(r, ...n);
    }
    partialSign(...t) {
      if (0 === t.length) throw new Error("No signers");
      const e = new Set(),
        n = [];
      for (const o of t) {
        const t = o.publicKey.toString();
        e.has(t) || (e.add(t), n.push(o));
      }
      const r = this._compile();
      this._partialSign(r, ...n);
    }
    _partialSign(t, ...e) {
      const n = t.serialize();
      e.forEach((t) => {
        const e = ki(n, t.secretKey);
        this._addSignature(t.publicKey, Ei(e));
      });
    }
    addSignature(t, e) {
      this._compile(), this._addSignature(t, e);
    }
    _addSignature(t, e) {
      ji(64 === e.length);
      const n = this.signatures.findIndex((e) => t.equals(e.publicKey));
      if (n < 0) throw new Error(`unknown signer: ${t.toString()}`);
      this.signatures[n].signature = X.from(e);
    }
    verifySignatures(t = !0) {
      return !this._getMessageSignednessErrors(this.serializeMessage(), t);
    }
    _getMessageSignednessErrors(t, e) {
      const n = {};
      for (const { signature: r, publicKey: o } of this.signatures)
        null === r
          ? e && (n.missing || (n.missing = [])).push(o)
          : Ai(r, t, o.toBytes()) || (n.invalid || (n.invalid = [])).push(o);
      return n.invalid || n.missing ? n : void 0;
    }
    serialize(t) {
      const { requireAllSignatures: e, verifySignatures: n } = Object.assign(
          { requireAllSignatures: !0, verifySignatures: !0 },
          t
        ),
        r = this.serializeMessage();
      if (n) {
        const t = this._getMessageSignednessErrors(r, e);
        if (t) {
          let e = "Signature verification failed.";
          throw (
            (t.invalid &&
              (e += `\nInvalid signature for public key${
                1 === t.invalid.length ? "" : "(s)"
              } [\`${t.invalid.map((t) => t.toBase58()).join("`, `")}\`].`),
            t.missing &&
              (e += `\nMissing signature for public key${
                1 === t.missing.length ? "" : "(s)"
              } [\`${t.missing.map((t) => t.toBase58()).join("`, `")}\`].`),
            new Error(e))
          );
        }
      }
      return this._serialize(r);
    }
    _serialize(t) {
      const { signatures: e } = this,
        n = [];
      Ki(n, e.length);
      const r = n.length + 64 * e.length + t.length,
        o = X.alloc(r);
      return (
        ji(e.length < 256),
        X.from(n).copy(o, 0),
        e.forEach(({ signature: t }, e) => {
          null !== t &&
            (ji(64 === t.length, "signature has invalid length"),
            X.from(t).copy(o, n.length + 64 * e));
        }),
        t.copy(o, n.length + 64 * e.length),
        ji(o.length <= Oi, `Transaction too large: ${o.length} > 1232`),
        o
      );
    }
    get keys() {
      return (
        ji(1 === this.instructions.length),
        this.instructions[0].keys.map((t) => t.pubkey)
      );
    }
    get programId() {
      return ji(1 === this.instructions.length), this.instructions[0].programId;
    }
    get data() {
      return ji(1 === this.instructions.length), this.instructions[0].data;
    }
    static from(t) {
      let e = [...t];
      const n = Wi(e);
      let r = [];
      for (let o = 0; o < n; o++) {
        const t = Yi(e, 0, 64);
        r.push(Wn.encode(X.from(t)));
      }
      return es.populate(Zi.from(e), r);
    }
    static populate(t, e = []) {
      const n = new es();
      return (
        (n.recentBlockhash = t.recentBlockhash),
        t.header.numRequiredSignatures > 0 && (n.feePayer = t.accountKeys[0]),
        e.forEach((e, r) => {
          const o = {
            signature: e == Wn.encode(Qi) ? null : Wn.decode(e),
            publicKey: t.accountKeys[r],
          };
          n.signatures.push(o);
        }),
        t.instructions.forEach((e) => {
          const r = e.accounts.map((e) => {
            const r = t.accountKeys[e];
            return {
              pubkey: r,
              isSigner:
                n.signatures.some(
                  (t) => t.publicKey.toString() === r.toString()
                ) || t.isAccountSigner(e),
              isWritable: t.isAccountWritable(e),
            };
          });
          n.instructions.push(
            new ts({
              keys: r,
              programId: t.accountKeys[e.programIdIndex],
              data: Wn.decode(e.data),
            })
          );
        }),
        (n._message = t),
        (n._json = n.toJSON()),
        n
      );
    }
  }
  class ns {
    constructor(t) {
      (this.payerKey = void 0),
        (this.instructions = void 0),
        (this.recentBlockhash = void 0),
        (this.payerKey = t.payerKey),
        (this.instructions = t.instructions),
        (this.recentBlockhash = t.recentBlockhash);
    }
    static decompile(t, e) {
      const { header: n, compiledInstructions: r, recentBlockhash: o } = t,
        {
          numRequiredSignatures: i,
          numReadonlySignedAccounts: s,
          numReadonlyUnsignedAccounts: a,
        } = n,
        c = i - s;
      ji(c > 0, "Message header is invalid");
      const u = t.staticAccountKeys.length - i - a;
      ji(u >= 0, "Message header is invalid");
      const l = t.getAccountKeys(e),
        h = l.get(0);
      if (void 0 === h)
        throw new Error(
          "Failed to decompile message because no account keys were found"
        );
      const d = [];
      for (const f of r) {
        const t = [];
        for (const r of f.accountKeyIndexes) {
          const e = l.get(r);
          if (void 0 === e)
            throw new Error(`Failed to find key for account key index ${r}`);
          let o;
          (o =
            r < i
              ? r < c
              : r < l.staticAccountKeys.length
              ? r - i < u
              : r - l.staticAccountKeys.length <
                l.accountKeysFromLookups.writable.length),
            t.push({
              pubkey: e,
              isSigner: r < n.numRequiredSignatures,
              isWritable: o,
            });
        }
        const e = l.get(f.programIdIndex);
        if (void 0 === e)
          throw new Error(
            `Failed to find program id for program id index ${f.programIdIndex}`
          );
        d.push(new ts({ programId: e, data: Ei(f.data), keys: t }));
      }
      return new ns({ payerKey: h, instructions: d, recentBlockhash: o });
    }
    compileToLegacyMessage() {
      return Zi.compile({
        payerKey: this.payerKey,
        recentBlockhash: this.recentBlockhash,
        instructions: this.instructions,
      });
    }
    compileToV0Message(t) {
      return Ji.compile({
        payerKey: this.payerKey,
        recentBlockhash: this.recentBlockhash,
        instructions: this.instructions,
        addressLookupTableAccounts: t,
      });
    }
  }
  class rs {
    get version() {
      return this.message.version;
    }
    constructor(t, e) {
      if (((this.signatures = void 0), (this.message = void 0), void 0 !== e))
        ji(
          e.length === t.header.numRequiredSignatures,
          "Expected signatures length to be equal to the number of required signatures"
        ),
          (this.signatures = e);
      else {
        const e = [];
        for (let n = 0; n < t.header.numRequiredSignatures; n++)
          e.push(new Uint8Array(64));
        this.signatures = e;
      }
      this.message = t;
    }
    serialize() {
      const t = this.message.serialize(),
        e = Array();
      Ki(e, this.signatures.length);
      const n = hr.struct([
          hr.blob(e.length, "encodedSignaturesLength"),
          hr.seq(Ui(), this.signatures.length, "signatures"),
          hr.blob(t.length, "serializedMessage"),
        ]),
        r = new Uint8Array(2048),
        o = n.encode(
          {
            encodedSignaturesLength: new Uint8Array(e),
            signatures: this.signatures,
            serializedMessage: t,
          },
          r
        );
      return r.slice(0, o);
    }
    static deserialize(t) {
      let e = [...t];
      const n = [],
        r = Wi(e);
      for (let i = 0; i < r; i++) n.push(new Uint8Array(Yi(e, 0, 64)));
      const o = Xi.deserialize(new Uint8Array(e));
      return new rs(o, n);
    }
    sign(t) {
      const e = this.message.serialize(),
        n = this.message.staticAccountKeys.slice(
          0,
          this.message.header.numRequiredSignatures
        );
      for (const r of t) {
        const t = n.findIndex((t) => t.equals(r.publicKey));
        ji(t >= 0, `Cannot sign with non signer key ${r.publicKey.toBase58()}`),
          (this.signatures[t] = ki(e, r.secretKey));
      }
    }
    addSignature(t, e) {
      ji(64 === e.byteLength, "Signature must be 64 bytes long");
      const n = this.message.staticAccountKeys
        .slice(0, this.message.header.numRequiredSignatures)
        .findIndex((e) => e.equals(t));
      ji(
        n >= 0,
        `Can not add signature; \`${t.toBase58()}\` is not required to sign this transaction`
      ),
        (this.signatures[n] = e);
    }
  }
  const os = new Ti("SysvarC1ock11111111111111111111111111111111"),
    is = new Ti("SysvarEpochSchedu1e111111111111111111111111"),
    ss = new Ti("Sysvar1nstructions1111111111111111111111111"),
    as = new Ti("SysvarRecentB1ockHashes11111111111111111111"),
    cs = new Ti("SysvarRent111111111111111111111111111111111"),
    us = new Ti("SysvarRewards111111111111111111111111111111"),
    ls = new Ti("SysvarS1otHashes111111111111111111111111111"),
    hs = new Ti("SysvarS1otHistory11111111111111111111111111"),
    ds = new Ti("SysvarStakeHistory1111111111111111111111111");
  class fs extends Error {
    constructor({ action: t, signature: e, transactionMessage: n, logs: r }) {
      const o = r ? `Logs: \n${JSON.stringify(r.slice(-10), null, 2)}. ` : "",
        i =
          "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
      let s;
      switch (t) {
        case "send":
          s = `Transaction ${e} resulted in an error. \n${n}. ` + o + i;
          break;
        case "simulate":
          s = `Simulation failed. \nMessage: ${n}. \n` + o + i;
          break;
        default:
          s = `Unknown action '${t}'`;
      }
      super(s),
        (this.signature = void 0),
        (this.transactionMessage = void 0),
        (this.transactionLogs = void 0),
        (this.signature = e),
        (this.transactionMessage = n),
        (this.transactionLogs = r || void 0);
    }
    get transactionError() {
      return {
        message: this.transactionMessage,
        logs: Array.isArray(this.transactionLogs)
          ? this.transactionLogs
          : void 0,
      };
    }
    get logs() {
      const t = this.transactionLogs;
      if (null == t || "object" != typeof t || !("then" in t)) return t;
    }
    async getLogs(t) {
      return (
        Array.isArray(this.transactionLogs) ||
          (this.transactionLogs = new Promise((e, n) => {
            t.getTransaction(this.signature)
              .then((t) => {
                if (t && t.meta && t.meta.logMessages) {
                  const n = t.meta.logMessages;
                  (this.transactionLogs = n), e(n);
                } else n(new Error("Log messages not found"));
              })
              .catch(n);
          })),
        await this.transactionLogs
      );
    }
  }
  class ps extends Error {
    constructor({ code: t, message: e, data: n }, r) {
      super(null != r ? `${r}: ${e}` : e),
        (this.code = void 0),
        (this.data = void 0),
        (this.code = t),
        (this.data = n),
        (this.name = "SolanaJSONRPCError");
    }
  }
  async function ms(t, e, n, r) {
    const o = r && {
        skipPreflight: r.skipPreflight,
        preflightCommitment: r.preflightCommitment || r.commitment,
        maxRetries: r.maxRetries,
        minContextSlot: r.minContextSlot,
      },
      i = await t.sendTransaction(e, n, o);
    let s;
    if (null != e.recentBlockhash && null != e.lastValidBlockHeight)
      s = (
        await t.confirmTransaction(
          {
            abortSignal: null == r ? void 0 : r.abortSignal,
            signature: i,
            blockhash: e.recentBlockhash,
            lastValidBlockHeight: e.lastValidBlockHeight,
          },
          r && r.commitment
        )
      ).value;
    else if (null != e.minNonceContextSlot && null != e.nonceInfo) {
      const { nonceInstruction: n } = e.nonceInfo,
        o = n.keys[0].pubkey;
      s = (
        await t.confirmTransaction(
          {
            abortSignal: null == r ? void 0 : r.abortSignal,
            minContextSlot: e.minNonceContextSlot,
            nonceAccountPubkey: o,
            nonceValue: e.nonceInfo.nonce,
            signature: i,
          },
          r && r.commitment
        )
      ).value;
    } else
      null != (null == r ? void 0 : r.abortSignal),
        0,
        (s = (await t.confirmTransaction(i, r && r.commitment)).value);
    if (s.err) {
      if (null != i)
        throw new fs({
          action: "send",
          signature: i,
          transactionMessage: `Status: (${JSON.stringify(s)})`,
        });
      throw new Error(`Transaction ${i} failed (${JSON.stringify(s)})`);
    }
    return i;
  }
  function ys(t) {
    return new Promise((e) => setTimeout(e, t));
  }
  function gs(t, e) {
    const n = t.layout.span >= 0 ? t.layout.span : Gi(t, e),
      r = X.alloc(n),
      o = Object.assign({ instruction: t.index }, e);
    return t.layout.encode(o, r), r;
  }
  function ws(t, e) {
    let n;
    try {
      n = t.layout.decode(e);
    } catch (r) {
      throw new Error("invalid instruction; " + r);
    }
    if (n.instruction !== t.index)
      throw new Error(
        `invalid instruction; instruction index mismatch ${n.instruction} != ${t.index}`
      );
    return n;
  }
  const bs = hr.nu64("lamportsPerSignature"),
    vs = hr.struct([
      hr.u32("version"),
      hr.u32("state"),
      Di("authorizedPubkey"),
      Di("nonce"),
      hr.struct([bs], "feeCalculator"),
    ]),
    _s = vs.span;
  class ks {
    constructor(t) {
      (this.authorizedPubkey = void 0),
        (this.nonce = void 0),
        (this.feeCalculator = void 0),
        (this.authorizedPubkey = t.authorizedPubkey),
        (this.nonce = t.nonce),
        (this.feeCalculator = t.feeCalculator);
    }
    static fromAccountData(t) {
      const e = vs.decode(Ei(t), 0);
      return new ks({
        authorizedPubkey: new Ti(e.authorizedPubkey),
        nonce: new Ti(e.nonce).toString(),
        feeCalculator: e.feeCalculator,
      });
    }
  }
  function As(t) {
    const e = hr.blob(8, t),
      n = e.decode.bind(e),
      r = e.encode.bind(e),
      o = e,
      i = _r();
    return (
      (o.decode = (t, e) => {
        const r = n(t, e);
        return i.decode(r);
      }),
      (o.encode = (t, e, n) => {
        const o = i.encode(t);
        return r(o, e, n);
      }),
      o
    );
  }
  const Es = Object.freeze({
    Create: {
      index: 0,
      layout: hr.struct([
        hr.u32("instruction"),
        hr.ns64("lamports"),
        hr.ns64("space"),
        Di("programId"),
      ]),
    },
    Assign: {
      index: 1,
      layout: hr.struct([hr.u32("instruction"), Di("programId")]),
    },
    Transfer: {
      index: 2,
      layout: hr.struct([hr.u32("instruction"), As("lamports")]),
    },
    CreateWithSeed: {
      index: 3,
      layout: hr.struct([
        hr.u32("instruction"),
        Di("base"),
        qi("seed"),
        hr.ns64("lamports"),
        hr.ns64("space"),
        Di("programId"),
      ]),
    },
    AdvanceNonceAccount: {
      index: 4,
      layout: hr.struct([hr.u32("instruction")]),
    },
    WithdrawNonceAccount: {
      index: 5,
      layout: hr.struct([hr.u32("instruction"), hr.ns64("lamports")]),
    },
    InitializeNonceAccount: {
      index: 6,
      layout: hr.struct([hr.u32("instruction"), Di("authorized")]),
    },
    AuthorizeNonceAccount: {
      index: 7,
      layout: hr.struct([hr.u32("instruction"), Di("authorized")]),
    },
    Allocate: {
      index: 8,
      layout: hr.struct([hr.u32("instruction"), hr.ns64("space")]),
    },
    AllocateWithSeed: {
      index: 9,
      layout: hr.struct([
        hr.u32("instruction"),
        Di("base"),
        qi("seed"),
        hr.ns64("space"),
        Di("programId"),
      ]),
    },
    AssignWithSeed: {
      index: 10,
      layout: hr.struct([
        hr.u32("instruction"),
        Di("base"),
        qi("seed"),
        Di("programId"),
      ]),
    },
    TransferWithSeed: {
      index: 11,
      layout: hr.struct([
        hr.u32("instruction"),
        As("lamports"),
        qi("seed"),
        Di("programId"),
      ]),
    },
    UpgradeNonceAccount: {
      index: 12,
      layout: hr.struct([hr.u32("instruction")]),
    },
  });
  class Is {
    constructor() {}
    static createAccount(t) {
      const e = gs(Es.Create, {
        lamports: t.lamports,
        space: t.space,
        programId: Ei(t.programId.toBuffer()),
      });
      return new ts({
        keys: [
          { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
          { pubkey: t.newAccountPubkey, isSigner: !0, isWritable: !0 },
        ],
        programId: this.programId,
        data: e,
      });
    }
    static transfer(t) {
      let e, n;
      if ("basePubkey" in t) {
        (e = gs(Es.TransferWithSeed, {
          lamports: BigInt(t.lamports),
          seed: t.seed,
          programId: Ei(t.programId.toBuffer()),
        })),
          (n = [
            { pubkey: t.fromPubkey, isSigner: !1, isWritable: !0 },
            { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
            { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
          ]);
      } else {
        (e = gs(Es.Transfer, { lamports: BigInt(t.lamports) })),
          (n = [
            { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
            { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
          ]);
      }
      return new ts({ keys: n, programId: this.programId, data: e });
    }
    static assign(t) {
      let e, n;
      if ("basePubkey" in t) {
        (e = gs(Es.AssignWithSeed, {
          base: Ei(t.basePubkey.toBuffer()),
          seed: t.seed,
          programId: Ei(t.programId.toBuffer()),
        })),
          (n = [
            { pubkey: t.accountPubkey, isSigner: !1, isWritable: !0 },
            { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
          ]);
      } else {
        (e = gs(Es.Assign, { programId: Ei(t.programId.toBuffer()) })),
          (n = [{ pubkey: t.accountPubkey, isSigner: !0, isWritable: !0 }]);
      }
      return new ts({ keys: n, programId: this.programId, data: e });
    }
    static createAccountWithSeed(t) {
      const e = gs(Es.CreateWithSeed, {
        base: Ei(t.basePubkey.toBuffer()),
        seed: t.seed,
        lamports: t.lamports,
        space: t.space,
        programId: Ei(t.programId.toBuffer()),
      });
      let n = [
        { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
        { pubkey: t.newAccountPubkey, isSigner: !1, isWritable: !0 },
      ];
      return (
        t.basePubkey.equals(t.fromPubkey) ||
          n.push({ pubkey: t.basePubkey, isSigner: !0, isWritable: !1 }),
        new ts({ keys: n, programId: this.programId, data: e })
      );
    }
    static createNonceAccount(t) {
      const e = new es();
      "basePubkey" in t && "seed" in t
        ? e.add(
            Is.createAccountWithSeed({
              fromPubkey: t.fromPubkey,
              newAccountPubkey: t.noncePubkey,
              basePubkey: t.basePubkey,
              seed: t.seed,
              lamports: t.lamports,
              space: _s,
              programId: this.programId,
            })
          )
        : e.add(
            Is.createAccount({
              fromPubkey: t.fromPubkey,
              newAccountPubkey: t.noncePubkey,
              lamports: t.lamports,
              space: _s,
              programId: this.programId,
            })
          );
      const n = {
        noncePubkey: t.noncePubkey,
        authorizedPubkey: t.authorizedPubkey,
      };
      return e.add(this.nonceInitialize(n)), e;
    }
    static nonceInitialize(t) {
      const e = gs(Es.InitializeNonceAccount, {
          authorized: Ei(t.authorizedPubkey.toBuffer()),
        }),
        n = {
          keys: [
            { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
            { pubkey: as, isSigner: !1, isWritable: !1 },
            { pubkey: cs, isSigner: !1, isWritable: !1 },
          ],
          programId: this.programId,
          data: e,
        };
      return new ts(n);
    }
    static nonceAdvance(t) {
      const e = gs(Es.AdvanceNonceAccount),
        n = {
          keys: [
            { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
            { pubkey: as, isSigner: !1, isWritable: !1 },
            { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
          ],
          programId: this.programId,
          data: e,
        };
      return new ts(n);
    }
    static nonceWithdraw(t) {
      const e = gs(Es.WithdrawNonceAccount, { lamports: t.lamports });
      return new ts({
        keys: [
          { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: as, isSigner: !1, isWritable: !1 },
          { pubkey: cs, isSigner: !1, isWritable: !1 },
          { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: e,
      });
    }
    static nonceAuthorize(t) {
      const e = gs(Es.AuthorizeNonceAccount, {
        authorized: Ei(t.newAuthorizedPubkey.toBuffer()),
      });
      return new ts({
        keys: [
          { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: e,
      });
    }
    static allocate(t) {
      let e, n;
      if ("basePubkey" in t) {
        (e = gs(Es.AllocateWithSeed, {
          base: Ei(t.basePubkey.toBuffer()),
          seed: t.seed,
          space: t.space,
          programId: Ei(t.programId.toBuffer()),
        })),
          (n = [
            { pubkey: t.accountPubkey, isSigner: !1, isWritable: !0 },
            { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
          ]);
      } else {
        (e = gs(Es.Allocate, { space: t.space })),
          (n = [{ pubkey: t.accountPubkey, isSigner: !0, isWritable: !0 }]);
      }
      return new ts({ keys: n, programId: this.programId, data: e });
    }
  }
  Is.programId = new Ti("11111111111111111111111111111111");
  class Cs {
    constructor() {}
    static getMinNumSignatures(t) {
      return 2 * (Math.ceil(t / Cs.chunkSize) + 1 + 1);
    }
    static async load(t, e, n, r, o) {
      {
        const i = await t.getMinimumBalanceForRentExemption(o.length),
          s = await t.getAccountInfo(n.publicKey, "confirmed");
        let a = null;
        if (null !== s) {
          if (s.executable) return void 0, !1;
          s.data.length !== o.length &&
            ((a = a || new es()),
            a.add(
              Is.allocate({ accountPubkey: n.publicKey, space: o.length })
            )),
            s.owner.equals(r) ||
              ((a = a || new es()),
              a.add(Is.assign({ accountPubkey: n.publicKey, programId: r }))),
            s.lamports < i &&
              ((a = a || new es()),
              a.add(
                Is.transfer({
                  fromPubkey: e.publicKey,
                  toPubkey: n.publicKey,
                  lamports: i - s.lamports,
                })
              ));
        } else
          a = new es().add(
            Is.createAccount({
              fromPubkey: e.publicKey,
              newAccountPubkey: n.publicKey,
              lamports: i > 0 ? i : 1,
              space: o.length,
              programId: r,
            })
          );
        null !== a && (await ms(t, a, [e, n], { commitment: "confirmed" }));
      }
      const i = hr.struct([
          hr.u32("instruction"),
          hr.u32("offset"),
          hr.u32("bytesLength"),
          hr.u32("bytesLengthPadding"),
          hr.seq(hr.u8("byte"), hr.offset(hr.u32(), -8), "bytes"),
        ]),
        s = Cs.chunkSize;
      let a = 0,
        c = o,
        u = [];
      for (; c.length > 0; ) {
        const o = c.slice(0, s),
          l = X.alloc(s + 16);
        i.encode(
          {
            instruction: 0,
            offset: a,
            bytes: o,
            bytesLength: 0,
            bytesLengthPadding: 0,
          },
          l
        );
        const h = new es().add({
          keys: [{ pubkey: n.publicKey, isSigner: !0, isWritable: !0 }],
          programId: r,
          data: l,
        });
        if (
          (u.push(ms(t, h, [e, n], { commitment: "confirmed" })),
          t._rpcEndpoint.includes("solana.com"))
        ) {
          const t = 4;
          await ys(1e3 / t);
        }
        (a += s), (c = c.slice(s));
      }
      await Promise.all(u);
      {
        const o = hr.struct([hr.u32("instruction")]),
          i = X.alloc(o.span);
        o.encode({ instruction: 1 }, i);
        const s = new es().add({
            keys: [
              { pubkey: n.publicKey, isSigner: !0, isWritable: !0 },
              { pubkey: cs, isSigner: !1, isWritable: !1 },
            ],
            programId: r,
            data: i,
          }),
          a = "processed",
          c = await t.sendTransaction(s, [e, n], { preflightCommitment: a }),
          { context: u, value: l } = await t.confirmTransaction(
            {
              signature: c,
              lastValidBlockHeight: s.lastValidBlockHeight,
              blockhash: s.recentBlockhash,
            },
            a
          );
        if (l.err)
          throw new Error(`Transaction ${c} failed (${JSON.stringify(l)})`);
        for (;;) {
          try {
            if ((await t.getSlot({ commitment: a })) > u.slot) break;
          } catch {}
          await new Promise((t) => setTimeout(t, Math.round(200)));
        }
      }
      return !0;
    }
  }
  Cs.chunkSize = 932;
  const Ss = new Ti("BPFLoader2111111111111111111111111111111111");
  var Bs, xs;
  var Ts = (function (t) {
    return t &&
      t.__esModule &&
      Object.prototype.hasOwnProperty.call(t, "default")
      ? t.default
      : t;
  })(
    (function () {
      if (xs) return Bs;
      xs = 1;
      var t = Object.prototype.toString,
        e =
          Object.keys ||
          function (t) {
            var e = [];
            for (var n in t) e.push(n);
            return e;
          };
      function n(r, o) {
        var i, s, a, c, u, l, h;
        if (!0 === r) return "true";
        if (!1 === r) return "false";
        switch (typeof r) {
          case "object":
            if (null === r) return null;
            if (r.toJSON && "function" == typeof r.toJSON)
              return n(r.toJSON(), o);
            if ("[object Array]" === (h = t.call(r))) {
              for (a = "[", s = r.length - 1, i = 0; i < s; i++)
                a += n(r[i], !0) + ",";
              return s > -1 && (a += n(r[i], !0)), a + "]";
            }
            if ("[object Object]" === h) {
              for (s = (c = e(r).sort()).length, a = "", i = 0; i < s; )
                void 0 !== (l = n(r[(u = c[i])], !1)) &&
                  (a && (a += ","), (a += JSON.stringify(u) + ":" + l)),
                  i++;
              return "{" + a + "}";
            }
            return JSON.stringify(r);
          case "function":
          case "undefined":
            return o ? null : void 0;
          case "string":
            return JSON.stringify(r);
          default:
            return isFinite(r) ? r : null;
        }
      }
      return (Bs = function (t) {
        var e = n(t, !1);
        if (void 0 !== e) return "" + e;
      });
    })()
  );
  function Rs(t) {
    let e = 0;
    for (; t > 1; ) (t /= 2), e++;
    return e;
  }
  class Os {
    constructor(t, e, n, r, o) {
      (this.slotsPerEpoch = void 0),
        (this.leaderScheduleSlotOffset = void 0),
        (this.warmup = void 0),
        (this.firstNormalEpoch = void 0),
        (this.firstNormalSlot = void 0),
        (this.slotsPerEpoch = t),
        (this.leaderScheduleSlotOffset = e),
        (this.warmup = n),
        (this.firstNormalEpoch = r),
        (this.firstNormalSlot = o);
    }
    getEpoch(t) {
      return this.getEpochAndSlotIndex(t)[0];
    }
    getEpochAndSlotIndex(t) {
      if (t < this.firstNormalSlot) {
        const n =
          Rs(
            0 === (e = t + 32 + 1)
              ? 1
              : (e--,
                (e |= e >> 1),
                (e |= e >> 2),
                (e |= e >> 4),
                (e |= e >> 8),
                (e |= e >> 16),
                1 + (e |= e >> 32))
          ) -
          Rs(32) -
          1;
        return [n, t - (this.getSlotsInEpoch(n) - 32)];
      }
      {
        const e = t - this.firstNormalSlot,
          n = Math.floor(e / this.slotsPerEpoch);
        return [this.firstNormalEpoch + n, e % this.slotsPerEpoch];
      }
      var e;
    }
    getFirstSlotInEpoch(t) {
      return t <= this.firstNormalEpoch
        ? 32 * (Math.pow(2, t) - 1)
        : (t - this.firstNormalEpoch) * this.slotsPerEpoch +
            this.firstNormalSlot;
    }
    getLastSlotInEpoch(t) {
      return this.getFirstSlotInEpoch(t) + this.getSlotsInEpoch(t) - 1;
    }
    getSlotsInEpoch(t) {
      return t < this.firstNormalEpoch
        ? Math.pow(2, t + Rs(32))
        : this.slotsPerEpoch;
    }
  }
  var Ms = globalThis.fetch;
  class Ns extends Mo {
    constructor(t, e, n) {
      super(
        (t) => {
          const n = (function (t, e) {
            return new Ro(t, e);
          })(t, {
            autoconnect: !0,
            max_reconnects: 5,
            reconnect: !0,
            reconnect_interval: 1e3,
            ...e,
          });
          return (this.underlyingSocket = "socket" in n ? n.socket : n), n;
        },
        t,
        e,
        n
      ),
        (this.underlyingSocket = void 0);
    }
    call(...t) {
      var e;
      const n = null == (e = this.underlyingSocket) ? void 0 : e.readyState;
      return 1 === n
        ? super.call(...t)
        : Promise.reject(
            new Error(
              "Tried to call a JSON-RPC method `" +
                t[0] +
                "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " +
                n +
                ")"
            )
          );
    }
    notify(...t) {
      var e;
      const n = null == (e = this.underlyingSocket) ? void 0 : e.readyState;
      return 1 === n
        ? super.notify(...t)
        : Promise.reject(
            new Error(
              "Tried to send a JSON-RPC notification `" +
                t[0] +
                "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " +
                n +
                ")"
            )
          );
    }
  }
  class Ps {
    constructor(t) {
      (this.key = void 0),
        (this.state = void 0),
        (this.key = t.key),
        (this.state = t.state);
    }
    isActive() {
      const t = BigInt("0xffffffffffffffff");
      return this.state.deactivationSlot === t;
    }
    static deserialize(t) {
      const e = (function (t, e) {
          let n;
          try {
            n = t.layout.decode(e);
          } catch (r) {
            throw new Error("invalid instruction; " + r);
          }
          if (n.typeIndex !== t.index)
            throw new Error(
              `invalid account data; account type mismatch ${n.typeIndex} != ${t.index}`
            );
          return n;
        })(Ls, t),
        n = t.length - 56;
      ji(n >= 0, "lookup table is invalid"),
        ji(n % 32 == 0, "lookup table is invalid");
      const r = n / 32,
        { addresses: o } = hr
          .struct([hr.seq(Di(), r, "addresses")])
          .decode(t.slice(56));
      return {
        deactivationSlot: e.deactivationSlot,
        lastExtendedSlot: e.lastExtendedSlot,
        lastExtendedSlotStartIndex: e.lastExtendedStartIndex,
        authority: 0 !== e.authority.length ? new Ti(e.authority[0]) : void 0,
        addresses: o.map((t) => new Ti(t)),
      };
    }
  }
  const Ls = {
      index: 1,
      layout: hr.struct([
        hr.u32("typeIndex"),
        As("deactivationSlot"),
        hr.nu64("lastExtendedSlot"),
        hr.u8("lastExtendedStartIndex"),
        hr.u8(),
        hr.seq(Di(), hr.offset(hr.u8(), -1), "authority"),
      ]),
    },
    zs = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
  const Ds = Yr(zr(Ti), Kr(), (t) => new Ti(t)),
    Us = jr([Kr(), Dr("base64")]),
    qs = Yr(zr(X), Us, (t) => X.from(t[0], "base64"));
  function Gs(t) {
    let e, n;
    if ("string" == typeof t) e = t;
    else if (t) {
      const { commitment: r, ...o } = t;
      (e = r), (n = o);
    }
    return { commitment: e, config: n };
  }
  function Ws(t) {
    return t.map((t) =>
      "memcmp" in t
        ? {
            ...t,
            memcmp: { ...t.memcmp, encoding: t.memcmp.encoding ?? "base58" },
          }
        : t
    );
  }
  function Ks(t) {
    return Vr([
      Hr({ jsonrpc: Dr("2.0"), id: Kr(), result: t }),
      Hr({
        jsonrpc: Dr("2.0"),
        id: Kr(),
        error: Hr({ code: Fr(), message: Kr(), data: Gr(Nr("any", () => !0)) }),
      }),
    ]);
  }
  const js = Ks(Fr());
  function Hs(t) {
    return Yr(Ks(t), js, (e) =>
      "error" in e ? e : { ...e, result: Rr(e.result, t) }
    );
  }
  function Vs(t) {
    return Hs(Hr({ context: Hr({ slot: qr() }), value: t }));
  }
  function Fs(t) {
    return Hr({ context: Hr({ slot: qr() }), value: t });
  }
  function Ys(t, e) {
    return 0 === t
      ? new Ji({
          header: e.header,
          staticAccountKeys: e.accountKeys.map((t) => new Ti(t)),
          recentBlockhash: e.recentBlockhash,
          compiledInstructions: e.instructions.map((t) => ({
            programIdIndex: t.programIdIndex,
            accountKeyIndexes: t.accounts,
            data: Wn.decode(t.data),
          })),
          addressTableLookups: e.addressTableLookups,
        })
      : new Zi(e);
  }
  const Zs = Hr({
      foundation: qr(),
      foundationTerm: qr(),
      initial: qr(),
      taper: qr(),
      terminal: qr(),
    }),
    Js = Hs(
      Pr(
        Ur(
          Hr({
            epoch: qr(),
            effectiveSlot: qr(),
            amount: qr(),
            postBalance: qr(),
            commission: Gr(Ur(qr())),
          })
        )
      )
    ),
    Xs = Pr(Hr({ slot: qr(), prioritizationFee: qr() })),
    $s = Hr({ total: qr(), validator: qr(), foundation: qr(), epoch: qr() }),
    Qs = Hr({
      epoch: qr(),
      slotIndex: qr(),
      slotsInEpoch: qr(),
      absoluteSlot: qr(),
      blockHeight: Gr(qr()),
      transactionCount: Gr(qr()),
    }),
    ta = Hr({
      slotsPerEpoch: qr(),
      leaderScheduleSlotOffset: qr(),
      warmup: Lr(),
      firstNormalEpoch: qr(),
      firstNormalSlot: qr(),
    }),
    ea = Wr(Kr(), Pr(qr())),
    na = Ur(Vr([Hr({}), Kr()])),
    ra = Hr({ err: na }),
    oa = Dr("receivedSignature"),
    ia = Hr({ "solana-core": Kr(), "feature-set": Gr(qr()) }),
    sa = Hr({ program: Kr(), programId: Ds, parsed: Fr() }),
    aa = Hr({ programId: Ds, accounts: Pr(Ds), data: Kr() }),
    ca = Vs(
      Hr({
        err: Ur(Vr([Hr({}), Kr()])),
        logs: Ur(Pr(Kr())),
        accounts: Gr(
          Ur(
            Pr(
              Ur(
                Hr({
                  executable: Lr(),
                  owner: Kr(),
                  lamports: qr(),
                  data: Pr(Kr()),
                  rentEpoch: Gr(qr()),
                })
              )
            )
          )
        ),
        unitsConsumed: Gr(qr()),
        returnData: Gr(
          Ur(Hr({ programId: Kr(), data: jr([Kr(), Dr("base64")]) }))
        ),
        innerInstructions: Gr(
          Ur(Pr(Hr({ index: qr(), instructions: Pr(Vr([sa, aa])) })))
        ),
      })
    ),
    ua = Vs(
      Hr({
        byIdentity: Wr(Kr(), Pr(qr())),
        range: Hr({ firstSlot: qr(), lastSlot: qr() }),
      })
    );
  const la = Hs(Zs),
    ha = Hs($s),
    da = Hs(Xs),
    fa = Hs(Qs),
    pa = Hs(ta),
    ma = Hs(ea),
    ya = Hs(qr()),
    ga = Vs(
      Hr({
        total: qr(),
        circulating: qr(),
        nonCirculating: qr(),
        nonCirculatingAccounts: Pr(Ds),
      })
    ),
    wa = Hr({
      amount: Kr(),
      uiAmount: Ur(qr()),
      decimals: qr(),
      uiAmountString: Gr(Kr()),
    }),
    ba = Vs(
      Pr(
        Hr({
          address: Ds,
          amount: Kr(),
          uiAmount: Ur(qr()),
          decimals: qr(),
          uiAmountString: Gr(Kr()),
        })
      )
    ),
    va = Vs(
      Pr(
        Hr({
          pubkey: Ds,
          account: Hr({
            executable: Lr(),
            owner: Ds,
            lamports: qr(),
            data: qs,
            rentEpoch: qr(),
          }),
        })
      )
    ),
    _a = Hr({ program: Kr(), parsed: Fr(), space: qr() }),
    ka = Vs(
      Pr(
        Hr({
          pubkey: Ds,
          account: Hr({
            executable: Lr(),
            owner: Ds,
            lamports: qr(),
            data: _a,
            rentEpoch: qr(),
          }),
        })
      )
    ),
    Aa = Vs(Pr(Hr({ lamports: qr(), address: Ds }))),
    Ea = Hr({
      executable: Lr(),
      owner: Ds,
      lamports: qr(),
      data: qs,
      rentEpoch: qr(),
    }),
    Ia = Hr({ pubkey: Ds, account: Ea }),
    Ca = Yr(Vr([zr(X), _a]), Vr([Us, _a]), (t) =>
      Array.isArray(t) ? Rr(t, qs) : t
    ),
    Sa = Hr({
      executable: Lr(),
      owner: Ds,
      lamports: qr(),
      data: Ca,
      rentEpoch: qr(),
    }),
    Ba = Hr({ pubkey: Ds, account: Sa }),
    xa = Hr({
      state: Vr([
        Dr("active"),
        Dr("inactive"),
        Dr("activating"),
        Dr("deactivating"),
      ]),
      active: qr(),
      inactive: qr(),
    }),
    Ta = Hs(
      Pr(
        Hr({
          signature: Kr(),
          slot: qr(),
          err: na,
          memo: Ur(Kr()),
          blockTime: Gr(Ur(qr())),
        })
      )
    ),
    Ra = Hs(
      Pr(
        Hr({
          signature: Kr(),
          slot: qr(),
          err: na,
          memo: Ur(Kr()),
          blockTime: Gr(Ur(qr())),
        })
      )
    ),
    Oa = Hr({ subscription: qr(), result: Fs(Ea) }),
    Ma = Hr({ pubkey: Ds, account: Ea }),
    Na = Hr({ subscription: qr(), result: Fs(Ma) }),
    Pa = Hr({ parent: qr(), slot: qr(), root: qr() }),
    La = Hr({ subscription: qr(), result: Pa }),
    za = Vr([
      Hr({
        type: Vr([
          Dr("firstShredReceived"),
          Dr("completed"),
          Dr("optimisticConfirmation"),
          Dr("root"),
        ]),
        slot: qr(),
        timestamp: qr(),
      }),
      Hr({
        type: Dr("createdBank"),
        parent: qr(),
        slot: qr(),
        timestamp: qr(),
      }),
      Hr({
        type: Dr("frozen"),
        slot: qr(),
        timestamp: qr(),
        stats: Hr({
          numTransactionEntries: qr(),
          numSuccessfulTransactions: qr(),
          numFailedTransactions: qr(),
          maxTransactionsPerEntry: qr(),
        }),
      }),
      Hr({ type: Dr("dead"), slot: qr(), timestamp: qr(), err: Kr() }),
    ]),
    Da = Hr({ subscription: qr(), result: za }),
    Ua = Hr({ subscription: qr(), result: Fs(Vr([ra, oa])) }),
    qa = Hr({ subscription: qr(), result: qr() }),
    Ga = Hr({
      pubkey: Kr(),
      gossip: Ur(Kr()),
      tpu: Ur(Kr()),
      rpc: Ur(Kr()),
      version: Ur(Kr()),
    }),
    Wa = Hr({
      votePubkey: Kr(),
      nodePubkey: Kr(),
      activatedStake: qr(),
      epochVoteAccount: Lr(),
      epochCredits: Pr(jr([qr(), qr(), qr()])),
      commission: qr(),
      lastVote: qr(),
      rootSlot: Ur(qr()),
    }),
    Ka = Hs(Hr({ current: Pr(Wa), delinquent: Pr(Wa) })),
    ja = Vr([Dr("processed"), Dr("confirmed"), Dr("finalized")]),
    Ha = Hr({
      slot: qr(),
      confirmations: Ur(qr()),
      err: na,
      confirmationStatus: Gr(ja),
    }),
    Va = Vs(Pr(Ur(Ha))),
    Fa = Hs(qr()),
    Ya = Hr({
      accountKey: Ds,
      writableIndexes: Pr(qr()),
      readonlyIndexes: Pr(qr()),
    }),
    Za = Hr({
      signatures: Pr(Kr()),
      message: Hr({
        accountKeys: Pr(Kr()),
        header: Hr({
          numRequiredSignatures: qr(),
          numReadonlySignedAccounts: qr(),
          numReadonlyUnsignedAccounts: qr(),
        }),
        instructions: Pr(
          Hr({ accounts: Pr(qr()), data: Kr(), programIdIndex: qr() })
        ),
        recentBlockhash: Kr(),
        addressTableLookups: Gr(Pr(Ya)),
      }),
    }),
    Ja = Hr({
      pubkey: Ds,
      signer: Lr(),
      writable: Lr(),
      source: Gr(Vr([Dr("transaction"), Dr("lookupTable")])),
    }),
    Xa = Hr({ accountKeys: Pr(Ja), signatures: Pr(Kr()) }),
    $a = Hr({ parsed: Fr(), program: Kr(), programId: Ds }),
    Qa = Hr({ accounts: Pr(Ds), data: Kr(), programId: Ds }),
    tc = Yr(
      Vr([Qa, $a]),
      Vr([
        Hr({ parsed: Fr(), program: Kr(), programId: Kr() }),
        Hr({ accounts: Pr(Kr()), data: Kr(), programId: Kr() }),
      ]),
      (t) => Rr(t, "accounts" in t ? Qa : $a)
    ),
    ec = Hr({
      signatures: Pr(Kr()),
      message: Hr({
        accountKeys: Pr(Ja),
        instructions: Pr(tc),
        recentBlockhash: Kr(),
        addressTableLookups: Gr(Ur(Pr(Ya))),
      }),
    }),
    nc = Hr({
      accountIndex: qr(),
      mint: Kr(),
      owner: Gr(Kr()),
      programId: Gr(Kr()),
      uiTokenAmount: wa,
    }),
    rc = Hr({ writable: Pr(Ds), readonly: Pr(Ds) }),
    oc = Hr({
      err: na,
      fee: qr(),
      innerInstructions: Gr(
        Ur(
          Pr(
            Hr({
              index: qr(),
              instructions: Pr(
                Hr({ accounts: Pr(qr()), data: Kr(), programIdIndex: qr() })
              ),
            })
          )
        )
      ),
      preBalances: Pr(qr()),
      postBalances: Pr(qr()),
      logMessages: Gr(Ur(Pr(Kr()))),
      preTokenBalances: Gr(Ur(Pr(nc))),
      postTokenBalances: Gr(Ur(Pr(nc))),
      loadedAddresses: Gr(rc),
      computeUnitsConsumed: Gr(qr()),
    }),
    ic = Hr({
      err: na,
      fee: qr(),
      innerInstructions: Gr(Ur(Pr(Hr({ index: qr(), instructions: Pr(tc) })))),
      preBalances: Pr(qr()),
      postBalances: Pr(qr()),
      logMessages: Gr(Ur(Pr(Kr()))),
      preTokenBalances: Gr(Ur(Pr(nc))),
      postTokenBalances: Gr(Ur(Pr(nc))),
      loadedAddresses: Gr(rc),
      computeUnitsConsumed: Gr(qr()),
    }),
    sc = Vr([Dr(0), Dr("legacy")]),
    ac = Hr({
      pubkey: Kr(),
      lamports: qr(),
      postBalance: Ur(qr()),
      rewardType: Ur(Kr()),
      commission: Gr(Ur(qr())),
    }),
    cc = Hs(
      Ur(
        Hr({
          blockhash: Kr(),
          previousBlockhash: Kr(),
          parentSlot: qr(),
          transactions: Pr(
            Hr({ transaction: Za, meta: Ur(oc), version: Gr(sc) })
          ),
          rewards: Gr(Pr(ac)),
          blockTime: Ur(qr()),
          blockHeight: Ur(qr()),
        })
      )
    ),
    uc = Hs(
      Ur(
        Hr({
          blockhash: Kr(),
          previousBlockhash: Kr(),
          parentSlot: qr(),
          rewards: Gr(Pr(ac)),
          blockTime: Ur(qr()),
          blockHeight: Ur(qr()),
        })
      )
    ),
    lc = Hs(
      Ur(
        Hr({
          blockhash: Kr(),
          previousBlockhash: Kr(),
          parentSlot: qr(),
          transactions: Pr(
            Hr({ transaction: Xa, meta: Ur(oc), version: Gr(sc) })
          ),
          rewards: Gr(Pr(ac)),
          blockTime: Ur(qr()),
          blockHeight: Ur(qr()),
        })
      )
    ),
    hc = Hs(
      Ur(
        Hr({
          blockhash: Kr(),
          previousBlockhash: Kr(),
          parentSlot: qr(),
          transactions: Pr(
            Hr({ transaction: ec, meta: Ur(ic), version: Gr(sc) })
          ),
          rewards: Gr(Pr(ac)),
          blockTime: Ur(qr()),
          blockHeight: Ur(qr()),
        })
      )
    ),
    dc = Hs(
      Ur(
        Hr({
          blockhash: Kr(),
          previousBlockhash: Kr(),
          parentSlot: qr(),
          transactions: Pr(
            Hr({ transaction: Xa, meta: Ur(ic), version: Gr(sc) })
          ),
          rewards: Gr(Pr(ac)),
          blockTime: Ur(qr()),
          blockHeight: Ur(qr()),
        })
      )
    ),
    fc = Hs(
      Ur(
        Hr({
          blockhash: Kr(),
          previousBlockhash: Kr(),
          parentSlot: qr(),
          rewards: Gr(Pr(ac)),
          blockTime: Ur(qr()),
          blockHeight: Ur(qr()),
        })
      )
    ),
    pc = Hs(
      Ur(
        Hr({
          blockhash: Kr(),
          previousBlockhash: Kr(),
          parentSlot: qr(),
          transactions: Pr(Hr({ transaction: Za, meta: Ur(oc) })),
          rewards: Gr(Pr(ac)),
          blockTime: Ur(qr()),
        })
      )
    ),
    mc = Hs(
      Ur(
        Hr({
          blockhash: Kr(),
          previousBlockhash: Kr(),
          parentSlot: qr(),
          signatures: Pr(Kr()),
          blockTime: Ur(qr()),
        })
      )
    ),
    yc = Hs(
      Ur(
        Hr({
          slot: qr(),
          meta: Ur(oc),
          blockTime: Gr(Ur(qr())),
          transaction: Za,
          version: Gr(sc),
        })
      )
    ),
    gc = Hs(
      Ur(
        Hr({
          slot: qr(),
          transaction: ec,
          meta: Ur(ic),
          blockTime: Gr(Ur(qr())),
          version: Gr(sc),
        })
      )
    ),
    wc = Vs(Hr({ blockhash: Kr(), lastValidBlockHeight: qr() })),
    bc = Vs(Lr()),
    vc = Hs(
      Pr(
        Hr({
          slot: qr(),
          numTransactions: qr(),
          numSlots: qr(),
          samplePeriodSecs: qr(),
        })
      )
    ),
    _c = Vs(Ur(Hr({ feeCalculator: Hr({ lamportsPerSignature: qr() }) }))),
    kc = Hs(Kr()),
    Ac = Hs(Kr()),
    Ec = Hr({ err: na, logs: Pr(Kr()), signature: Kr() }),
    Ic = Hr({ result: Fs(Ec), subscription: qr() }),
    Cc = { "solana-client": "js/1.0.0-maintenance" };
  class Sc {
    constructor(t, e) {
      let n, r, o, i, s, a;
      var c;
      (this._commitment = void 0),
        (this._confirmTransactionInitialTimeout = void 0),
        (this._rpcEndpoint = void 0),
        (this._rpcWsEndpoint = void 0),
        (this._rpcClient = void 0),
        (this._rpcRequest = void 0),
        (this._rpcBatchRequest = void 0),
        (this._rpcWebSocket = void 0),
        (this._rpcWebSocketConnected = !1),
        (this._rpcWebSocketHeartbeat = null),
        (this._rpcWebSocketIdleTimeout = null),
        (this._rpcWebSocketGeneration = 0),
        (this._disableBlockhashCaching = !1),
        (this._pollingBlockhash = !1),
        (this._blockhashInfo = {
          latestBlockhash: null,
          lastFetch: 0,
          transactionSignatures: [],
          simulatedSignatures: [],
        }),
        (this._nextClientSubscriptionId = 0),
        (this._subscriptionDisposeFunctionsByClientSubscriptionId = {}),
        (this._subscriptionHashByClientSubscriptionId = {}),
        (this._subscriptionStateChangeCallbacksByHash = {}),
        (this._subscriptionCallbacksByServerSubscriptionId = {}),
        (this._subscriptionsByHash = {}),
        (this._subscriptionsAutoDisposedByRpc = new Set()),
        (this.getBlockHeight = (() => {
          const t = {};
          return async (e) => {
            const { commitment: n, config: r } = Gs(e),
              o = this._buildArgs([], n, void 0, r),
              i = Ts(o);
            return (
              (t[i] =
                t[i] ??
                (async () => {
                  try {
                    const t = Rr(
                      await this._rpcRequest("getBlockHeight", o),
                      Hs(qr())
                    );
                    if ("error" in t)
                      throw new ps(
                        t.error,
                        "failed to get block height information"
                      );
                    return t.result;
                  } finally {
                    delete t[i];
                  }
                })()),
              await t[i]
            );
          };
        })()),
        e && "string" == typeof e
          ? (this._commitment = e)
          : e &&
            ((this._commitment = e.commitment),
            (this._confirmTransactionInitialTimeout =
              e.confirmTransactionInitialTimeout),
            (n = e.wsEndpoint),
            (r = e.httpHeaders),
            (o = e.fetch),
            (i = e.fetchMiddleware),
            (s = e.disableRetryOnRateLimit),
            (a = e.httpAgent)),
        (this._rpcEndpoint = (function (t) {
          if (!1 === /^https?:/.test(t))
            throw new TypeError(
              "Endpoint URL must start with `http:` or `https:`."
            );
          return t;
        })(t)),
        (this._rpcWsEndpoint =
          n ||
          (function (t) {
            const e = t.match(zs);
            if (null == e)
              throw TypeError(`Failed to validate endpoint URL \`${t}\``);
            const [n, r, o, i] = e,
              s = t.startsWith("https:") ? "wss:" : "ws:",
              a = null == o ? null : parseInt(o.slice(1), 10);
            return `${s}//${r}${null == a ? "" : `:${a + 1}`}${i}`;
          })(t)),
        (this._rpcClient = (function (t, e, n, r, o, i) {
          const s = n || Ms;
          let a;
          return (
            null != i,
            0,
            r &&
              (a = async (t, e) => {
                const n = await new Promise((n, o) => {
                  try {
                    r(t, e, (t, e) => n([t, e]));
                  } catch (i) {
                    o(i);
                  }
                });
                return await s(...n);
              }),
            new Co(async (n, r) => {
              const i = {
                method: "POST",
                body: n,
                agent: void 0,
                headers: Object.assign(
                  { "Content-Type": "application/json" },
                  e || {},
                  Cc
                ),
              };
              try {
                let e,
                  n = 5,
                  c = 500;
                for (
                  ;
                  (e = a ? await a(t, i) : await s(t, i)),
                    429 === e.status && !0 !== o && ((n -= 1), 0 !== n);

                )
                  void 0, await ys(c), (c *= 2);
                const u = await e.text();
                e.ok
                  ? r(null, u)
                  : r(new Error(`${e.status} ${e.statusText}: ${u}`));
              } catch (c) {
                c instanceof Error && r(c);
              }
            }, {})
          );
        })(t, r, o, i, s, a)),
        (this._rpcRequest =
          ((c = this._rpcClient),
          (t, e) =>
            new Promise((n, r) => {
              c.request(t, e, (t, e) => {
                if (t) return r(t), void 0;
                n(e);
              });
            }))),
        (this._rpcBatchRequest = (function (t) {
          return (e) =>
            new Promise((n, r) => {
              0 === e.length && n([]);
              const o = e.map((e) => t.request(e.methodName, e.args));
              t.request(o, (t, e) => {
                if (t) return r(t), void 0;
                n(e);
              });
            });
        })(this._rpcClient)),
        (this._rpcWebSocket = new Ns(this._rpcWsEndpoint, {
          autoconnect: !1,
          max_reconnects: 1 / 0,
        })),
        this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)),
        this._rpcWebSocket.on("error", this._wsOnError.bind(this)),
        this._rpcWebSocket.on("close", this._wsOnClose.bind(this)),
        this._rpcWebSocket.on(
          "accountNotification",
          this._wsOnAccountNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "programNotification",
          this._wsOnProgramAccountNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "slotNotification",
          this._wsOnSlotNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "slotsUpdatesNotification",
          this._wsOnSlotUpdatesNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "signatureNotification",
          this._wsOnSignatureNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "rootNotification",
          this._wsOnRootNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "logsNotification",
          this._wsOnLogsNotification.bind(this)
        );
    }
    get commitment() {
      return this._commitment;
    }
    get rpcEndpoint() {
      return this._rpcEndpoint;
    }
    async getBalanceAndContext(t, e) {
      const { commitment: n, config: r } = Gs(e),
        o = this._buildArgs([t.toBase58()], n, void 0, r),
        i = Rr(await this._rpcRequest("getBalance", o), Vs(qr()));
      if ("error" in i)
        throw new ps(i.error, `failed to get balance for ${t.toBase58()}`);
      return i.result;
    }
    async getBalance(t, e) {
      return await this.getBalanceAndContext(t, e)
        .then((t) => t.value)
        .catch((e) => {
          throw new Error(
            "failed to get balance of account " + t.toBase58() + ": " + e
          );
        });
    }
    async getBlockTime(t) {
      const e = Rr(await this._rpcRequest("getBlockTime", [t]), Hs(Ur(qr())));
      if ("error" in e)
        throw new ps(e.error, `failed to get block time for slot ${t}`);
      return e.result;
    }
    async getMinimumLedgerSlot() {
      const t = Rr(await this._rpcRequest("minimumLedgerSlot", []), Hs(qr()));
      if ("error" in t)
        throw new ps(t.error, "failed to get minimum ledger slot");
      return t.result;
    }
    async getFirstAvailableBlock() {
      const t = Rr(await this._rpcRequest("getFirstAvailableBlock", []), ya);
      if ("error" in t)
        throw new ps(t.error, "failed to get first available block");
      return t.result;
    }
    async getSupply(t) {
      let e = {};
      e =
        "string" == typeof t
          ? { commitment: t }
          : t
          ? { ...t, commitment: (t && t.commitment) || this.commitment }
          : { commitment: this.commitment };
      const n = Rr(await this._rpcRequest("getSupply", [e]), ga);
      if ("error" in n) throw new ps(n.error, "failed to get supply");
      return n.result;
    }
    async getTokenSupply(t, e) {
      const n = this._buildArgs([t.toBase58()], e),
        r = Rr(await this._rpcRequest("getTokenSupply", n), Vs(wa));
      if ("error" in r) throw new ps(r.error, "failed to get token supply");
      return r.result;
    }
    async getTokenAccountBalance(t, e) {
      const n = this._buildArgs([t.toBase58()], e),
        r = Rr(await this._rpcRequest("getTokenAccountBalance", n), Vs(wa));
      if ("error" in r)
        throw new ps(r.error, "failed to get token account balance");
      return r.result;
    }
    async getTokenAccountsByOwner(t, e, n) {
      const { commitment: r, config: o } = Gs(n);
      let i = [t.toBase58()];
      "mint" in e
        ? i.push({ mint: e.mint.toBase58() })
        : i.push({ programId: e.programId.toBase58() });
      const s = this._buildArgs(i, r, "base64", o),
        a = Rr(await this._rpcRequest("getTokenAccountsByOwner", s), va);
      if ("error" in a)
        throw new ps(
          a.error,
          `failed to get token accounts owned by account ${t.toBase58()}`
        );
      return a.result;
    }
    async getParsedTokenAccountsByOwner(t, e, n) {
      let r = [t.toBase58()];
      "mint" in e
        ? r.push({ mint: e.mint.toBase58() })
        : r.push({ programId: e.programId.toBase58() });
      const o = this._buildArgs(r, n, "jsonParsed"),
        i = Rr(await this._rpcRequest("getTokenAccountsByOwner", o), ka);
      if ("error" in i)
        throw new ps(
          i.error,
          `failed to get token accounts owned by account ${t.toBase58()}`
        );
      return i.result;
    }
    async getLargestAccounts(t) {
      const e = { ...t, commitment: (t && t.commitment) || this.commitment },
        n = e.filter || e.commitment ? [e] : [],
        r = Rr(await this._rpcRequest("getLargestAccounts", n), Aa);
      if ("error" in r) throw new ps(r.error, "failed to get largest accounts");
      return r.result;
    }
    async getTokenLargestAccounts(t, e) {
      const n = this._buildArgs([t.toBase58()], e),
        r = Rr(await this._rpcRequest("getTokenLargestAccounts", n), ba);
      if ("error" in r)
        throw new ps(r.error, "failed to get token largest accounts");
      return r.result;
    }
    async getAccountInfoAndContext(t, e) {
      const { commitment: n, config: r } = Gs(e),
        o = this._buildArgs([t.toBase58()], n, "base64", r),
        i = Rr(await this._rpcRequest("getAccountInfo", o), Vs(Ur(Ea)));
      if ("error" in i)
        throw new ps(
          i.error,
          `failed to get info about account ${t.toBase58()}`
        );
      return i.result;
    }
    async getParsedAccountInfo(t, e) {
      const { commitment: n, config: r } = Gs(e),
        o = this._buildArgs([t.toBase58()], n, "jsonParsed", r),
        i = Rr(await this._rpcRequest("getAccountInfo", o), Vs(Ur(Sa)));
      if ("error" in i)
        throw new ps(
          i.error,
          `failed to get info about account ${t.toBase58()}`
        );
      return i.result;
    }
    async getAccountInfo(t, e) {
      try {
        return (await this.getAccountInfoAndContext(t, e)).value;
      } catch (n) {
        throw new Error(
          "failed to get info about account " + t.toBase58() + ": " + n
        );
      }
    }
    async getMultipleParsedAccounts(t, e) {
      const { commitment: n, config: r } = Gs(e),
        o = t.map((t) => t.toBase58()),
        i = this._buildArgs([o], n, "jsonParsed", r),
        s = Rr(
          await this._rpcRequest("getMultipleAccounts", i),
          Vs(Pr(Ur(Sa)))
        );
      if ("error" in s)
        throw new ps(s.error, `failed to get info for accounts ${o}`);
      return s.result;
    }
    async getMultipleAccountsInfoAndContext(t, e) {
      const { commitment: n, config: r } = Gs(e),
        o = t.map((t) => t.toBase58()),
        i = this._buildArgs([o], n, "base64", r),
        s = Rr(
          await this._rpcRequest("getMultipleAccounts", i),
          Vs(Pr(Ur(Ea)))
        );
      if ("error" in s)
        throw new ps(s.error, `failed to get info for accounts ${o}`);
      return s.result;
    }
    async getMultipleAccountsInfo(t, e) {
      return (await this.getMultipleAccountsInfoAndContext(t, e)).value;
    }
    async getStakeActivation(t, e, n) {
      const { commitment: r, config: o } = Gs(e),
        i = this._buildArgs([t.toBase58()], r, void 0, {
          ...o,
          epoch: null != n ? n : null == o ? void 0 : o.epoch,
        }),
        s = Rr(await this._rpcRequest("getStakeActivation", i), Hs(xa));
      if ("error" in s)
        throw new ps(s.error, `failed to get Stake Activation ${t.toBase58()}`);
      return s.result;
    }
    async getProgramAccounts(t, e) {
      const { commitment: n, config: r } = Gs(e),
        { encoding: o, ...i } = r || {},
        s = this._buildArgs([t.toBase58()], n, o || "base64", {
          ...i,
          ...(i.filters ? { filters: Ws(i.filters) } : null),
        }),
        a = await this._rpcRequest("getProgramAccounts", s),
        c = Pr(Ia),
        u = !0 === i.withContext ? Rr(a, Vs(c)) : Rr(a, Hs(c));
      if ("error" in u)
        throw new ps(
          u.error,
          `failed to get accounts owned by program ${t.toBase58()}`
        );
      return u.result;
    }
    async getParsedProgramAccounts(t, e) {
      const { commitment: n, config: r } = Gs(e),
        o = this._buildArgs([t.toBase58()], n, "jsonParsed", r),
        i = Rr(await this._rpcRequest("getProgramAccounts", o), Hs(Pr(Ba)));
      if ("error" in i)
        throw new ps(
          i.error,
          `failed to get accounts owned by program ${t.toBase58()}`
        );
      return i.result;
    }
    async confirmTransaction(t, e) {
      var n;
      let r, o;
      if ("string" == typeof t) r = t;
      else {
        const e = t;
        if (null == (n = e.abortSignal) ? void 0 : n.aborted)
          return Promise.reject(e.abortSignal.reason);
        r = e.signature;
      }
      try {
        o = Wn.decode(r);
      } catch (i) {
        throw new Error("signature must be base58 encoded: " + r);
      }
      return (
        ji(64 === o.length, "signature has invalid length"),
        "string" == typeof t
          ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
              commitment: e || this.commitment,
              signature: r,
            })
          : "lastValidBlockHeight" in t
          ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
              commitment: e || this.commitment,
              strategy: t,
            })
          : await this.confirmTransactionUsingDurableNonceStrategy({
              commitment: e || this.commitment,
              strategy: t,
            })
      );
    }
    getCancellationPromise(t) {
      return new Promise((e, n) => {
        null != t &&
          (t.aborted
            ? n(t.reason)
            : t.addEventListener("abort", () => {
                n(t.reason);
              }));
      });
    }
    getTransactionConfirmationPromise({ commitment: t, signature: e }) {
      let n,
        r,
        o = !1;
      return {
        abortConfirmation: () => {
          r && (r(), (r = void 0)),
            null != n && (this.removeSignatureListener(n), (n = void 0));
        },
        confirmationPromise: new Promise((i, s) => {
          try {
            n = this.onSignature(
              e,
              (t, e) => {
                n = void 0;
                const r = { context: e, value: t };
                i({ __type: $i.PROCESSED, response: r });
              },
              t
            );
            const a = new Promise((t) => {
              null == n
                ? t()
                : (r = this._onSubscriptionStateChange(n, (e) => {
                    "subscribed" === e && t();
                  }));
            });
            (async () => {
              if ((await a, o)) return;
              const n = await this.getSignatureStatus(e);
              if (o) return;
              if (null == n) return;
              const { context: r, value: c } = n;
              if (null != c)
                if (null == c ? void 0 : c.err) s(c.err);
                else {
                  switch (t) {
                    case "confirmed":
                    case "single":
                    case "singleGossip":
                      if ("processed" === c.confirmationStatus) return;
                      break;
                    case "finalized":
                    case "max":
                    case "root":
                      if (
                        "processed" === c.confirmationStatus ||
                        "confirmed" === c.confirmationStatus
                      )
                        return;
                  }
                  (o = !0),
                    i({
                      __type: $i.PROCESSED,
                      response: { context: r, value: c },
                    });
                }
            })();
          } catch (a) {
            s(a);
          }
        }),
      };
    }
    async confirmTransactionUsingBlockHeightExceedanceStrategy({
      commitment: t,
      strategy: { abortSignal: e, lastValidBlockHeight: n, signature: r },
    }) {
      let o = !1;
      const i = new Promise((e) => {
          const r = async () => {
            try {
              return await this.getBlockHeight(t);
            } catch (e) {
              return -1;
            }
          };
          (async () => {
            let t = await r();
            if (!o) {
              for (; t <= n; ) {
                if ((await ys(1e3), o)) return;
                if (((t = await r()), o)) return;
              }
              e({ __type: $i.BLOCKHEIGHT_EXCEEDED });
            }
          })();
        }),
        { abortConfirmation: s, confirmationPromise: a } =
          this.getTransactionConfirmationPromise({
            commitment: t,
            signature: r,
          }),
        c = this.getCancellationPromise(e);
      let u;
      try {
        const t = await Promise.race([c, a, i]);
        if (t.__type !== $i.PROCESSED) throw new Ni(r);
        u = t.response;
      } finally {
        (o = !0), s();
      }
      return u;
    }
    async confirmTransactionUsingDurableNonceStrategy({
      commitment: t,
      strategy: {
        abortSignal: e,
        minContextSlot: n,
        nonceAccountPubkey: r,
        nonceValue: o,
        signature: i,
      },
    }) {
      let s = !1;
      const a = new Promise((e) => {
          let i = o,
            a = null;
          const c = async () => {
            try {
              const { context: e, value: o } = await this.getNonceAndContext(
                r,
                { commitment: t, minContextSlot: n }
              );
              return (a = e.slot), null == o ? void 0 : o.nonce;
            } catch (e) {
              return i;
            }
          };
          (async () => {
            if (((i = await c()), !s))
              for (;;) {
                if (o !== i)
                  return (
                    e({
                      __type: $i.NONCE_INVALID,
                      slotInWhichNonceDidAdvance: a,
                    }),
                    void 0
                  );
                if ((await ys(2e3), s)) return;
                if (((i = await c()), s)) return;
              }
          })();
        }),
        { abortConfirmation: c, confirmationPromise: u } =
          this.getTransactionConfirmationPromise({
            commitment: t,
            signature: i,
          }),
        l = this.getCancellationPromise(e);
      let h;
      try {
        const e = await Promise.race([l, u, a]);
        if (e.__type === $i.PROCESSED) h = e.response;
        else {
          let r;
          for (;;) {
            const t = await this.getSignatureStatus(i);
            if (null == t) break;
            if (!(t.context.slot < (e.slotInWhichNonceDidAdvance ?? n))) {
              r = t;
              break;
            }
            await ys(400);
          }
          if (!(null == r ? void 0 : r.value)) throw new Li(i);
          {
            const e = t || "finalized",
              { confirmationStatus: n } = r.value;
            switch (e) {
              case "processed":
              case "recent":
                if ("processed" !== n && "confirmed" !== n && "finalized" !== n)
                  throw new Li(i);
                break;
              case "confirmed":
              case "single":
              case "singleGossip":
                if ("confirmed" !== n && "finalized" !== n) throw new Li(i);
                break;
              case "finalized":
              case "max":
              case "root":
                if ("finalized" !== n) throw new Li(i);
            }
            h = { context: r.context, value: { err: r.value.err } };
          }
        }
      } finally {
        (s = !0), c();
      }
      return h;
    }
    async confirmTransactionUsingLegacyTimeoutStrategy({
      commitment: t,
      signature: e,
    }) {
      let n;
      const r = new Promise((e) => {
          let r = this._confirmTransactionInitialTimeout || 6e4;
          switch (t) {
            case "processed":
            case "recent":
            case "single":
            case "confirmed":
            case "singleGossip":
              r = this._confirmTransactionInitialTimeout || 3e4;
          }
          n = setTimeout(() => e({ __type: $i.TIMED_OUT, timeoutMs: r }), r);
        }),
        { abortConfirmation: o, confirmationPromise: i } =
          this.getTransactionConfirmationPromise({
            commitment: t,
            signature: e,
          });
      let s;
      try {
        const t = await Promise.race([i, r]);
        if (t.__type !== $i.PROCESSED) throw new Pi(e, t.timeoutMs / 1e3);
        s = t.response;
      } finally {
        clearTimeout(n), o();
      }
      return s;
    }
    async getClusterNodes() {
      const t = Rr(await this._rpcRequest("getClusterNodes", []), Hs(Pr(Ga)));
      if ("error" in t) throw new ps(t.error, "failed to get cluster nodes");
      return t.result;
    }
    async getVoteAccounts(t) {
      const e = this._buildArgs([], t),
        n = Rr(await this._rpcRequest("getVoteAccounts", e), Ka);
      if ("error" in n) throw new ps(n.error, "failed to get vote accounts");
      return n.result;
    }
    async getSlot(t) {
      const { commitment: e, config: n } = Gs(t),
        r = this._buildArgs([], e, void 0, n),
        o = Rr(await this._rpcRequest("getSlot", r), Hs(qr()));
      if ("error" in o) throw new ps(o.error, "failed to get slot");
      return o.result;
    }
    async getSlotLeader(t) {
      const { commitment: e, config: n } = Gs(t),
        r = this._buildArgs([], e, void 0, n),
        o = Rr(await this._rpcRequest("getSlotLeader", r), Hs(Kr()));
      if ("error" in o) throw new ps(o.error, "failed to get slot leader");
      return o.result;
    }
    async getSlotLeaders(t, e) {
      const n = [t, e],
        r = Rr(await this._rpcRequest("getSlotLeaders", n), Hs(Pr(Ds)));
      if ("error" in r) throw new ps(r.error, "failed to get slot leaders");
      return r.result;
    }
    async getSignatureStatus(t, e) {
      const { context: n, value: r } = await this.getSignatureStatuses([t], e);
      ji(1 === r.length);
      return { context: n, value: r[0] };
    }
    async getSignatureStatuses(t, e) {
      const n = [t];
      e && n.push(e);
      const r = Rr(await this._rpcRequest("getSignatureStatuses", n), Va);
      if ("error" in r) throw new ps(r.error, "failed to get signature status");
      return r.result;
    }
    async getTransactionCount(t) {
      const { commitment: e, config: n } = Gs(t),
        r = this._buildArgs([], e, void 0, n),
        o = Rr(await this._rpcRequest("getTransactionCount", r), Hs(qr()));
      if ("error" in o)
        throw new ps(o.error, "failed to get transaction count");
      return o.result;
    }
    async getTotalSupply(t) {
      return (
        await this.getSupply({
          commitment: t,
          excludeNonCirculatingAccountsList: !0,
        })
      ).value.total;
    }
    async getInflationGovernor(t) {
      const e = this._buildArgs([], t),
        n = Rr(await this._rpcRequest("getInflationGovernor", e), la);
      if ("error" in n) throw new ps(n.error, "failed to get inflation");
      return n.result;
    }
    async getInflationReward(t, e, n) {
      const { commitment: r, config: o } = Gs(n),
        i = this._buildArgs([t.map((t) => t.toBase58())], r, void 0, {
          ...o,
          epoch: null != e ? e : null == o ? void 0 : o.epoch,
        }),
        s = Rr(await this._rpcRequest("getInflationReward", i), Js);
      if ("error" in s) throw new ps(s.error, "failed to get inflation reward");
      return s.result;
    }
    async getInflationRate() {
      const t = Rr(await this._rpcRequest("getInflationRate", []), ha);
      if ("error" in t) throw new ps(t.error, "failed to get inflation rate");
      return t.result;
    }
    async getEpochInfo(t) {
      const { commitment: e, config: n } = Gs(t),
        r = this._buildArgs([], e, void 0, n),
        o = Rr(await this._rpcRequest("getEpochInfo", r), fa);
      if ("error" in o) throw new ps(o.error, "failed to get epoch info");
      return o.result;
    }
    async getEpochSchedule() {
      const t = Rr(await this._rpcRequest("getEpochSchedule", []), pa);
      if ("error" in t) throw new ps(t.error, "failed to get epoch schedule");
      const e = t.result;
      return new Os(
        e.slotsPerEpoch,
        e.leaderScheduleSlotOffset,
        e.warmup,
        e.firstNormalEpoch,
        e.firstNormalSlot
      );
    }
    async getLeaderSchedule() {
      const t = Rr(await this._rpcRequest("getLeaderSchedule", []), ma);
      if ("error" in t) throw new ps(t.error, "failed to get leader schedule");
      return t.result;
    }
    async getMinimumBalanceForRentExemption(t, e) {
      const n = this._buildArgs([t], e),
        r = Rr(
          await this._rpcRequest("getMinimumBalanceForRentExemption", n),
          Fa
        );
      return "error" in r ? (void 0, 0) : r.result;
    }
    async getRecentBlockhashAndContext(t) {
      const {
        context: e,
        value: { blockhash: n },
      } = await this.getLatestBlockhashAndContext(t);
      return {
        context: e,
        value: {
          blockhash: n,
          feeCalculator: {
            get lamportsPerSignature() {
              throw new Error(
                "The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message."
              );
            },
            toJSON: () => ({}),
          },
        },
      };
    }
    async getRecentPerformanceSamples(t) {
      const e = Rr(
        await this._rpcRequest("getRecentPerformanceSamples", t ? [t] : []),
        vc
      );
      if ("error" in e)
        throw new ps(e.error, "failed to get recent performance samples");
      return e.result;
    }
    async getFeeCalculatorForBlockhash(t, e) {
      const n = this._buildArgs([t], e),
        r = Rr(await this._rpcRequest("getFeeCalculatorForBlockhash", n), _c);
      if ("error" in r) throw new ps(r.error, "failed to get fee calculator");
      const { context: o, value: i } = r.result;
      return { context: o, value: null !== i ? i.feeCalculator : null };
    }
    async getFeeForMessage(t, e) {
      const n = Ei(t.serialize()).toString("base64"),
        r = this._buildArgs([n], e),
        o = Rr(await this._rpcRequest("getFeeForMessage", r), Vs(Ur(qr())));
      if ("error" in o) throw new ps(o.error, "failed to get fee for message");
      if (null === o.result) throw new Error("invalid blockhash");
      return o.result;
    }
    async getRecentPrioritizationFees(t) {
      var e;
      const n =
          null == (e = null == t ? void 0 : t.lockedWritableAccounts)
            ? void 0
            : e.map((t) => t.toBase58()),
        r = (null == n ? void 0 : n.length) ? [n] : [],
        o = Rr(await this._rpcRequest("getRecentPrioritizationFees", r), da);
      if ("error" in o)
        throw new ps(o.error, "failed to get recent prioritization fees");
      return o.result;
    }
    async getRecentBlockhash(t) {
      try {
        return (await this.getRecentBlockhashAndContext(t)).value;
      } catch (e) {
        throw new Error("failed to get recent blockhash: " + e);
      }
    }
    async getLatestBlockhash(t) {
      try {
        return (await this.getLatestBlockhashAndContext(t)).value;
      } catch (e) {
        throw new Error("failed to get recent blockhash: " + e);
      }
    }
    async getLatestBlockhashAndContext(t) {
      const { commitment: e, config: n } = Gs(t),
        r = this._buildArgs([], e, void 0, n),
        o = Rr(await this._rpcRequest("getLatestBlockhash", r), wc);
      if ("error" in o) throw new ps(o.error, "failed to get latest blockhash");
      return o.result;
    }
    async isBlockhashValid(t, e) {
      const { commitment: n, config: r } = Gs(e),
        o = this._buildArgs([t], n, void 0, r),
        i = Rr(await this._rpcRequest("isBlockhashValid", o), bc);
      if ("error" in i)
        throw new ps(
          i.error,
          "failed to determine if the blockhash `" + t + "`is valid"
        );
      return i.result;
    }
    async getVersion() {
      const t = Rr(await this._rpcRequest("getVersion", []), Hs(ia));
      if ("error" in t) throw new ps(t.error, "failed to get version");
      return t.result;
    }
    async getGenesisHash() {
      const t = Rr(await this._rpcRequest("getGenesisHash", []), Hs(Kr()));
      if ("error" in t) throw new ps(t.error, "failed to get genesis hash");
      return t.result;
    }
    async getBlock(t, e) {
      const { commitment: n, config: r } = Gs(e),
        o = this._buildArgsAtLeastConfirmed([t], n, void 0, r),
        i = await this._rpcRequest("getBlock", o);
      try {
        switch (null == r ? void 0 : r.transactionDetails) {
          case "accounts": {
            const t = Rr(i, lc);
            if ("error" in t) throw t.error;
            return t.result;
          }
          case "none": {
            const t = Rr(i, uc);
            if ("error" in t) throw t.error;
            return t.result;
          }
          default: {
            const t = Rr(i, cc);
            if ("error" in t) throw t.error;
            const { result: e } = t;
            return e
              ? {
                  ...e,
                  transactions: e.transactions.map(
                    ({ transaction: t, meta: e, version: n }) => ({
                      meta: e,
                      transaction: { ...t, message: Ys(n, t.message) },
                      version: n,
                    })
                  ),
                }
              : null;
          }
        }
      } catch (s) {
        throw new ps(s, "failed to get confirmed block");
      }
    }
    async getParsedBlock(t, e) {
      const { commitment: n, config: r } = Gs(e),
        o = this._buildArgsAtLeastConfirmed([t], n, "jsonParsed", r),
        i = await this._rpcRequest("getBlock", o);
      try {
        switch (null == r ? void 0 : r.transactionDetails) {
          case "accounts": {
            const t = Rr(i, dc);
            if ("error" in t) throw t.error;
            return t.result;
          }
          case "none": {
            const t = Rr(i, fc);
            if ("error" in t) throw t.error;
            return t.result;
          }
          default: {
            const t = Rr(i, hc);
            if ("error" in t) throw t.error;
            return t.result;
          }
        }
      } catch (s) {
        throw new ps(s, "failed to get block");
      }
    }
    async getBlockProduction(t) {
      let e, n;
      if ("string" == typeof t) n = t;
      else if (t) {
        const { commitment: r, ...o } = t;
        (n = r), (e = o);
      }
      const r = this._buildArgs([], n, "base64", e),
        o = Rr(await this._rpcRequest("getBlockProduction", r), ua);
      if ("error" in o)
        throw new ps(o.error, "failed to get block production information");
      return o.result;
    }
    async getTransaction(t, e) {
      const { commitment: n, config: r } = Gs(e),
        o = this._buildArgsAtLeastConfirmed([t], n, void 0, r),
        i = Rr(await this._rpcRequest("getTransaction", o), yc);
      if ("error" in i) throw new ps(i.error, "failed to get transaction");
      const s = i.result;
      return s
        ? {
            ...s,
            transaction: {
              ...s.transaction,
              message: Ys(s.version, s.transaction.message),
            },
          }
        : s;
    }
    async getParsedTransaction(t, e) {
      const { commitment: n, config: r } = Gs(e),
        o = this._buildArgsAtLeastConfirmed([t], n, "jsonParsed", r),
        i = Rr(await this._rpcRequest("getTransaction", o), gc);
      if ("error" in i) throw new ps(i.error, "failed to get transaction");
      return i.result;
    }
    async getParsedTransactions(t, e) {
      const { commitment: n, config: r } = Gs(e),
        o = t.map((t) => ({
          methodName: "getTransaction",
          args: this._buildArgsAtLeastConfirmed([t], n, "jsonParsed", r),
        }));
      return (await this._rpcBatchRequest(o)).map((t) => {
        const e = Rr(t, gc);
        if ("error" in e) throw new ps(e.error, "failed to get transactions");
        return e.result;
      });
    }
    async getTransactions(t, e) {
      const { commitment: n, config: r } = Gs(e),
        o = t.map((t) => ({
          methodName: "getTransaction",
          args: this._buildArgsAtLeastConfirmed([t], n, void 0, r),
        }));
      return (await this._rpcBatchRequest(o)).map((t) => {
        const e = Rr(t, yc);
        if ("error" in e) throw new ps(e.error, "failed to get transactions");
        const n = e.result;
        return n
          ? {
              ...n,
              transaction: {
                ...n.transaction,
                message: Ys(n.version, n.transaction.message),
              },
            }
          : n;
      });
    }
    async getConfirmedBlock(t, e) {
      const n = this._buildArgsAtLeastConfirmed([t], e),
        r = Rr(await this._rpcRequest("getBlock", n), pc);
      if ("error" in r) throw new ps(r.error, "failed to get confirmed block");
      const o = r.result;
      if (!o) throw new Error("Confirmed block " + t + " not found");
      const i = {
        ...o,
        transactions: o.transactions.map(({ transaction: t, meta: e }) => {
          const n = new Zi(t.message);
          return { meta: e, transaction: { ...t, message: n } };
        }),
      };
      return {
        ...i,
        transactions: i.transactions.map(({ transaction: t, meta: e }) => ({
          meta: e,
          transaction: es.populate(t.message, t.signatures),
        })),
      };
    }
    async getBlocks(t, e, n) {
      const r = this._buildArgsAtLeastConfirmed(void 0 !== e ? [t, e] : [t], n),
        o = Rr(await this._rpcRequest("getBlocks", r), Hs(Pr(qr())));
      if ("error" in o) throw new ps(o.error, "failed to get blocks");
      return o.result;
    }
    async getBlockSignatures(t, e) {
      const n = this._buildArgsAtLeastConfirmed([t], e, void 0, {
          transactionDetails: "signatures",
          rewards: !1,
        }),
        r = Rr(await this._rpcRequest("getBlock", n), mc);
      if ("error" in r) throw new ps(r.error, "failed to get block");
      const o = r.result;
      if (!o) throw new Error("Block " + t + " not found");
      return o;
    }
    async getConfirmedBlockSignatures(t, e) {
      const n = this._buildArgsAtLeastConfirmed([t], e, void 0, {
          transactionDetails: "signatures",
          rewards: !1,
        }),
        r = Rr(await this._rpcRequest("getBlock", n), mc);
      if ("error" in r) throw new ps(r.error, "failed to get confirmed block");
      const o = r.result;
      if (!o) throw new Error("Confirmed block " + t + " not found");
      return o;
    }
    async getConfirmedTransaction(t, e) {
      const n = this._buildArgsAtLeastConfirmed([t], e),
        r = Rr(await this._rpcRequest("getTransaction", n), yc);
      if ("error" in r) throw new ps(r.error, "failed to get transaction");
      const o = r.result;
      if (!o) return o;
      const i = new Zi(o.transaction.message),
        s = o.transaction.signatures;
      return { ...o, transaction: es.populate(i, s) };
    }
    async getParsedConfirmedTransaction(t, e) {
      const n = this._buildArgsAtLeastConfirmed([t], e, "jsonParsed"),
        r = Rr(await this._rpcRequest("getTransaction", n), gc);
      if ("error" in r)
        throw new ps(r.error, "failed to get confirmed transaction");
      return r.result;
    }
    async getParsedConfirmedTransactions(t, e) {
      const n = t.map((t) => ({
        methodName: "getTransaction",
        args: this._buildArgsAtLeastConfirmed([t], e, "jsonParsed"),
      }));
      return (await this._rpcBatchRequest(n)).map((t) => {
        const e = Rr(t, gc);
        if ("error" in e)
          throw new ps(e.error, "failed to get confirmed transactions");
        return e.result;
      });
    }
    async getConfirmedSignaturesForAddress(t, e, n) {
      let r = {},
        o = await this.getFirstAvailableBlock();
      for (; !("until" in r) && !(--e <= 0 || e < o); )
        try {
          const t = await this.getConfirmedBlockSignatures(e, "finalized");
          t.signatures.length > 0 &&
            (r.until = t.signatures[t.signatures.length - 1].toString());
        } catch (s) {
          if (s instanceof Error && s.message.includes("skipped")) continue;
          throw s;
        }
      let i = await this.getSlot("finalized");
      for (; !("before" in r || ++n > i); )
        try {
          const t = await this.getConfirmedBlockSignatures(n);
          t.signatures.length > 0 &&
            (r.before = t.signatures[t.signatures.length - 1].toString());
        } catch (s) {
          if (s instanceof Error && s.message.includes("skipped")) continue;
          throw s;
        }
      return (await this.getConfirmedSignaturesForAddress2(t, r)).map(
        (t) => t.signature
      );
    }
    async getConfirmedSignaturesForAddress2(t, e, n) {
      const r = this._buildArgsAtLeastConfirmed([t.toBase58()], n, void 0, e),
        o = Rr(
          await this._rpcRequest("getConfirmedSignaturesForAddress2", r),
          Ta
        );
      if ("error" in o)
        throw new ps(o.error, "failed to get confirmed signatures for address");
      return o.result;
    }
    async getSignaturesForAddress(t, e, n) {
      const r = this._buildArgsAtLeastConfirmed([t.toBase58()], n, void 0, e),
        o = Rr(await this._rpcRequest("getSignaturesForAddress", r), Ra);
      if ("error" in o)
        throw new ps(o.error, "failed to get signatures for address");
      return o.result;
    }
    async getAddressLookupTable(t, e) {
      const { context: n, value: r } = await this.getAccountInfoAndContext(
        t,
        e
      );
      let o = null;
      return (
        null !== r && (o = new Ps({ key: t, state: Ps.deserialize(r.data) })),
        { context: n, value: o }
      );
    }
    async getNonceAndContext(t, e) {
      const { context: n, value: r } = await this.getAccountInfoAndContext(
        t,
        e
      );
      let o = null;
      return (
        null !== r && (o = ks.fromAccountData(r.data)), { context: n, value: o }
      );
    }
    async getNonce(t, e) {
      return await this.getNonceAndContext(t, e)
        .then((t) => t.value)
        .catch((e) => {
          throw new Error(
            "failed to get nonce for account " + t.toBase58() + ": " + e
          );
        });
    }
    async requestAirdrop(t, e) {
      const n = Rr(
        await this._rpcRequest("requestAirdrop", [t.toBase58(), e]),
        kc
      );
      if ("error" in n)
        throw new ps(n.error, `airdrop to ${t.toBase58()} failed`);
      return n.result;
    }
    async _blockhashWithExpiryBlockHeight(t) {
      if (!t) {
        for (; this._pollingBlockhash; ) await ys(100);
        const t = Date.now() - this._blockhashInfo.lastFetch >= 3e4;
        if (null !== this._blockhashInfo.latestBlockhash && !t)
          return this._blockhashInfo.latestBlockhash;
      }
      return await this._pollNewBlockhash();
    }
    async _pollNewBlockhash() {
      this._pollingBlockhash = !0;
      try {
        const t = Date.now(),
          e = this._blockhashInfo.latestBlockhash,
          n = e ? e.blockhash : null;
        for (let r = 0; r < 50; r++) {
          const t = await this.getLatestBlockhash("finalized");
          if (n !== t.blockhash)
            return (
              (this._blockhashInfo = {
                latestBlockhash: t,
                lastFetch: Date.now(),
                transactionSignatures: [],
                simulatedSignatures: [],
              }),
              t
            );
          await ys(200);
        }
        throw new Error(
          `Unable to obtain a new blockhash after ${Date.now() - t}ms`
        );
      } finally {
        this._pollingBlockhash = !1;
      }
    }
    async getStakeMinimumDelegation(t) {
      const { commitment: e, config: n } = Gs(t),
        r = this._buildArgs([], e, "base64", n),
        o = Rr(
          await this._rpcRequest("getStakeMinimumDelegation", r),
          Vs(qr())
        );
      if ("error" in o)
        throw new ps(o.error, "failed to get stake minimum delegation");
      return o.result;
    }
    async simulateTransaction(t, e, n) {
      if ("message" in t) {
        const r = t.serialize(),
          o = X.from(r).toString("base64");
        if (Array.isArray(e) || void 0 !== n)
          throw new Error("Invalid arguments");
        const i = e || {};
        (i.encoding = "base64"),
          "commitment" in i || (i.commitment = this.commitment),
          e &&
            "object" == typeof e &&
            "innerInstructions" in e &&
            (i.innerInstructions = e.innerInstructions);
        const s = [o, i],
          a = Rr(await this._rpcRequest("simulateTransaction", s), ca);
        if ("error" in a)
          throw new Error("failed to simulate transaction: " + a.error.message);
        return a.result;
      }
      let r;
      if (t instanceof es) {
        let e = t;
        (r = new es()),
          (r.feePayer = e.feePayer),
          (r.instructions = t.instructions),
          (r.nonceInfo = e.nonceInfo),
          (r.signatures = e.signatures);
      } else (r = es.populate(t)), (r._message = r._json = void 0);
      if (void 0 !== e && !Array.isArray(e))
        throw new Error("Invalid arguments");
      const o = e;
      if (r.nonceInfo && o) r.sign(...o);
      else {
        let t = this._disableBlockhashCaching;
        for (;;) {
          const e = await this._blockhashWithExpiryBlockHeight(t);
          if (
            ((r.lastValidBlockHeight = e.lastValidBlockHeight),
            (r.recentBlockhash = e.blockhash),
            !o)
          )
            break;
          if ((r.sign(...o), !r.signature)) throw new Error("!signature");
          const n = r.signature.toString("base64");
          if (
            !this._blockhashInfo.simulatedSignatures.includes(n) &&
            !this._blockhashInfo.transactionSignatures.includes(n)
          ) {
            this._blockhashInfo.simulatedSignatures.push(n);
            break;
          }
          t = !0;
        }
      }
      const i = r._compile(),
        s = i.serialize(),
        a = r._serialize(s).toString("base64"),
        c = { encoding: "base64", commitment: this.commitment };
      if (n) {
        const t = (Array.isArray(n) ? n : i.nonProgramIds()).map((t) =>
          t.toBase58()
        );
        c.accounts = { encoding: "base64", addresses: t };
      }
      o && (c.sigVerify = !0),
        e &&
          "object" == typeof e &&
          "innerInstructions" in e &&
          (c.innerInstructions = e.innerInstructions);
      const u = [a, c],
        l = Rr(await this._rpcRequest("simulateTransaction", u), ca);
      if ("error" in l) {
        let t;
        if (
          "data" in l.error &&
          ((t = l.error.data.logs), t && Array.isArray(t))
        ) {
          const e = "\n    ";
          t.join(e);
          void 0;
        }
        throw new fs({
          action: "simulate",
          signature: "",
          transactionMessage: l.error.message,
          logs: t,
        });
      }
      return l.result;
    }
    async sendTransaction(t, e, n) {
      if ("version" in t) {
        if (e && Array.isArray(e)) throw new Error("Invalid arguments");
        const n = t.serialize();
        return await this.sendRawTransaction(n, e);
      }
      if (void 0 === e || !Array.isArray(e))
        throw new Error("Invalid arguments");
      const r = e;
      if (t.nonceInfo) t.sign(...r);
      else {
        let e = this._disableBlockhashCaching;
        for (;;) {
          const n = await this._blockhashWithExpiryBlockHeight(e);
          if (
            ((t.lastValidBlockHeight = n.lastValidBlockHeight),
            (t.recentBlockhash = n.blockhash),
            t.sign(...r),
            !t.signature)
          )
            throw new Error("!signature");
          const o = t.signature.toString("base64");
          if (!this._blockhashInfo.transactionSignatures.includes(o)) {
            this._blockhashInfo.transactionSignatures.push(o);
            break;
          }
          e = !0;
        }
      }
      const o = t.serialize();
      return await this.sendRawTransaction(o, n);
    }
    async sendRawTransaction(t, e) {
      const n = Ei(t).toString("base64");
      return await this.sendEncodedTransaction(n, e);
    }
    async sendEncodedTransaction(t, e) {
      const n = { encoding: "base64" },
        r = e && e.skipPreflight,
        o =
          !0 === r
            ? "processed"
            : (e && e.preflightCommitment) || this.commitment;
      e && null != e.maxRetries && (n.maxRetries = e.maxRetries),
        e && null != e.minContextSlot && (n.minContextSlot = e.minContextSlot),
        r && (n.skipPreflight = r),
        o && (n.preflightCommitment = o);
      const i = [t, n],
        s = Rr(await this._rpcRequest("sendTransaction", i), Ac);
      if ("error" in s) {
        let t;
        throw (
          ("data" in s.error && (t = s.error.data.logs),
          new fs({
            action: r ? "send" : "simulate",
            signature: "",
            transactionMessage: s.error.message,
            logs: t,
          }))
        );
      }
      return s.result;
    }
    _wsOnOpen() {
      (this._rpcWebSocketConnected = !0),
        (this._rpcWebSocketHeartbeat = setInterval(() => {
          (async () => {
            try {
              await this._rpcWebSocket.notify("ping");
            } catch {}
          })();
        }, 5e3)),
        this._updateSubscriptions();
    }
    _wsOnError(t) {
      this._rpcWebSocketConnected = !1;
    }
    _wsOnClose(t) {
      if (
        ((this._rpcWebSocketConnected = !1),
        (this._rpcWebSocketGeneration =
          (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER),
        this._rpcWebSocketIdleTimeout &&
          (clearTimeout(this._rpcWebSocketIdleTimeout),
          (this._rpcWebSocketIdleTimeout = null)),
        this._rpcWebSocketHeartbeat &&
          (clearInterval(this._rpcWebSocketHeartbeat),
          (this._rpcWebSocketHeartbeat = null)),
        1e3 === t)
      )
        return this._updateSubscriptions(), void 0;
      (this._subscriptionCallbacksByServerSubscriptionId = {}),
        Object.entries(this._subscriptionsByHash).forEach(([t, e]) => {
          this._setSubscription(t, { ...e, state: "pending" });
        });
    }
    _setSubscription(t, e) {
      var n;
      const r = null == (n = this._subscriptionsByHash[t]) ? void 0 : n.state;
      if (((this._subscriptionsByHash[t] = e), r !== e.state)) {
        const n = this._subscriptionStateChangeCallbacksByHash[t];
        n &&
          n.forEach((t) => {
            try {
              t(e.state);
            } catch {}
          });
      }
    }
    _onSubscriptionStateChange(t, e) {
      var n;
      const r = this._subscriptionHashByClientSubscriptionId[t];
      if (null == r) return () => {};
      const o =
        (n = this._subscriptionStateChangeCallbacksByHash)[r] ||
        (n[r] = new Set());
      return (
        o.add(e),
        () => {
          o.delete(e),
            0 === o.size &&
              delete this._subscriptionStateChangeCallbacksByHash[r];
        }
      );
    }
    async _updateSubscriptions() {
      if (0 === Object.keys(this._subscriptionsByHash).length)
        return (
          this._rpcWebSocketConnected &&
            ((this._rpcWebSocketConnected = !1),
            (this._rpcWebSocketIdleTimeout = setTimeout(() => {
              this._rpcWebSocketIdleTimeout = null;
              try {
                this._rpcWebSocket.close();
              } catch (t) {
                t instanceof Error, 0;
              }
            }, 500))),
          void 0
        );
      if (
        (null !== this._rpcWebSocketIdleTimeout &&
          (clearTimeout(this._rpcWebSocketIdleTimeout),
          (this._rpcWebSocketIdleTimeout = null),
          (this._rpcWebSocketConnected = !0)),
        !this._rpcWebSocketConnected)
      )
        return this._rpcWebSocket.connect(), void 0;
      const t = this._rpcWebSocketGeneration,
        e = () => t === this._rpcWebSocketGeneration;
      await Promise.all(
        Object.keys(this._subscriptionsByHash).map(async (t) => {
          const n = this._subscriptionsByHash[t];
          if (void 0 !== n)
            switch (n.state) {
              case "pending":
              case "unsubscribed":
                if (0 === n.callbacks.size)
                  return (
                    delete this._subscriptionsByHash[t],
                    "unsubscribed" === n.state &&
                      delete this._subscriptionCallbacksByServerSubscriptionId[
                        n.serverSubscriptionId
                      ],
                    await this._updateSubscriptions(),
                    void 0
                  );
                await (async () => {
                  const { args: r, method: o } = n;
                  try {
                    this._setSubscription(t, { ...n, state: "subscribing" });
                    const e = await this._rpcWebSocket.call(o, r);
                    this._setSubscription(t, {
                      ...n,
                      serverSubscriptionId: e,
                      state: "subscribed",
                    }),
                      (this._subscriptionCallbacksByServerSubscriptionId[e] =
                        n.callbacks),
                      await this._updateSubscriptions();
                  } catch (i) {
                    if ((void 0, !e())) return;
                    this._setSubscription(t, { ...n, state: "pending" }),
                      await this._updateSubscriptions();
                  }
                })();
                break;
              case "subscribed":
                0 === n.callbacks.size &&
                  (await (async () => {
                    const { serverSubscriptionId: r, unsubscribeMethod: o } = n;
                    if (this._subscriptionsAutoDisposedByRpc.has(r))
                      this._subscriptionsAutoDisposedByRpc.delete(r);
                    else {
                      this._setSubscription(t, {
                        ...n,
                        state: "unsubscribing",
                      }),
                        this._setSubscription(t, {
                          ...n,
                          state: "unsubscribing",
                        });
                      try {
                        await this._rpcWebSocket.call(o, [r]);
                      } catch (i) {
                        if ((i instanceof Error, 0, !e())) return;
                        return (
                          this._setSubscription(t, {
                            ...n,
                            state: "subscribed",
                          }),
                          await this._updateSubscriptions(),
                          void 0
                        );
                      }
                    }
                    this._setSubscription(t, { ...n, state: "unsubscribed" }),
                      await this._updateSubscriptions();
                  })());
            }
        })
      );
    }
    _handleServerNotification(t, e) {
      const n = this._subscriptionCallbacksByServerSubscriptionId[t];
      void 0 !== n &&
        n.forEach((t) => {
          try {
            t(...e);
          } catch (n) {
            void 0;
          }
        });
    }
    _wsOnAccountNotification(t) {
      const { result: e, subscription: n } = Rr(t, Oa);
      this._handleServerNotification(n, [e.value, e.context]);
    }
    _makeSubscription(t, e) {
      const n = this._nextClientSubscriptionId++,
        r = Ts([t.method, e]),
        o = this._subscriptionsByHash[r];
      return (
        void 0 === o
          ? (this._subscriptionsByHash[r] = {
              ...t,
              args: e,
              callbacks: new Set([t.callback]),
              state: "pending",
            })
          : o.callbacks.add(t.callback),
        (this._subscriptionHashByClientSubscriptionId[n] = r),
        (this._subscriptionDisposeFunctionsByClientSubscriptionId[n] =
          async () => {
            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],
              delete this._subscriptionHashByClientSubscriptionId[n];
            const e = this._subscriptionsByHash[r];
            ji(
              void 0 !== e,
              `Could not find a \`Subscription\` when tearing down client subscription #${n}`
            ),
              e.callbacks.delete(t.callback),
              await this._updateSubscriptions();
          }),
        this._updateSubscriptions(),
        n
      );
    }
    onAccountChange(t, e, n) {
      const { commitment: r, config: o } = Gs(n),
        i = this._buildArgs(
          [t.toBase58()],
          r || this._commitment || "finalized",
          "base64",
          o
        );
      return this._makeSubscription(
        {
          callback: e,
          method: "accountSubscribe",
          unsubscribeMethod: "accountUnsubscribe",
        },
        i
      );
    }
    async removeAccountChangeListener(t) {
      await this._unsubscribeClientSubscription(t, "account change");
    }
    _wsOnProgramAccountNotification(t) {
      const { result: e, subscription: n } = Rr(t, Na);
      this._handleServerNotification(n, [
        { accountId: e.value.pubkey, accountInfo: e.value.account },
        e.context,
      ]);
    }
    onProgramAccountChange(t, e, n, r) {
      const { commitment: o, config: i } = Gs(n),
        s = this._buildArgs(
          [t.toBase58()],
          o || this._commitment || "finalized",
          "base64",
          i || (r ? { filters: Ws(r) } : void 0)
        );
      return this._makeSubscription(
        {
          callback: e,
          method: "programSubscribe",
          unsubscribeMethod: "programUnsubscribe",
        },
        s
      );
    }
    async removeProgramAccountChangeListener(t) {
      await this._unsubscribeClientSubscription(t, "program account change");
    }
    onLogs(t, e, n) {
      const r = this._buildArgs(
        ["object" == typeof t ? { mentions: [t.toString()] } : t],
        n || this._commitment || "finalized"
      );
      return this._makeSubscription(
        {
          callback: e,
          method: "logsSubscribe",
          unsubscribeMethod: "logsUnsubscribe",
        },
        r
      );
    }
    async removeOnLogsListener(t) {
      await this._unsubscribeClientSubscription(t, "logs");
    }
    _wsOnLogsNotification(t) {
      const { result: e, subscription: n } = Rr(t, Ic);
      this._handleServerNotification(n, [e.value, e.context]);
    }
    _wsOnSlotNotification(t) {
      const { result: e, subscription: n } = Rr(t, La);
      this._handleServerNotification(n, [e]);
    }
    onSlotChange(t) {
      return this._makeSubscription(
        {
          callback: t,
          method: "slotSubscribe",
          unsubscribeMethod: "slotUnsubscribe",
        },
        []
      );
    }
    async removeSlotChangeListener(t) {
      await this._unsubscribeClientSubscription(t, "slot change");
    }
    _wsOnSlotUpdatesNotification(t) {
      const { result: e, subscription: n } = Rr(t, Da);
      this._handleServerNotification(n, [e]);
    }
    onSlotUpdate(t) {
      return this._makeSubscription(
        {
          callback: t,
          method: "slotsUpdatesSubscribe",
          unsubscribeMethod: "slotsUpdatesUnsubscribe",
        },
        []
      );
    }
    async removeSlotUpdateListener(t) {
      await this._unsubscribeClientSubscription(t, "slot update");
    }
    async _unsubscribeClientSubscription(t, e) {
      const n = this._subscriptionDisposeFunctionsByClientSubscriptionId[t];
      n ? await n() : void 0;
    }
    _buildArgs(t, e, n, r) {
      const o = e || this._commitment;
      if (o || n || r) {
        let e = {};
        n && (e.encoding = n),
          o && (e.commitment = o),
          r && (e = Object.assign(e, r)),
          t.push(e);
      }
      return t;
    }
    _buildArgsAtLeastConfirmed(t, e, n, r) {
      const o = e || this._commitment;
      if (o && !["confirmed", "finalized"].includes(o))
        throw new Error(
          "Using Connection with default commitment: `" +
            this._commitment +
            "`, but method requires at least `confirmed`"
        );
      return this._buildArgs(t, e, n, r);
    }
    _wsOnSignatureNotification(t) {
      const { result: e, subscription: n } = Rr(t, Ua);
      "receivedSignature" !== e.value &&
        this._subscriptionsAutoDisposedByRpc.add(n),
        this._handleServerNotification(
          n,
          "receivedSignature" === e.value
            ? [{ type: "received" }, e.context]
            : [{ type: "status", result: e.value }, e.context]
        );
    }
    onSignature(t, e, n) {
      const r = this._buildArgs([t], n || this._commitment || "finalized"),
        o = this._makeSubscription(
          {
            callback: (t, n) => {
              if ("status" === t.type) {
                e(t.result, n);
                try {
                  this.removeSignatureListener(o);
                } catch (r) {}
              }
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe",
          },
          r
        );
      return o;
    }
    onSignatureWithOptions(t, e, n) {
      const { commitment: r, ...o } = {
          ...n,
          commitment: (n && n.commitment) || this._commitment || "finalized",
        },
        i = this._buildArgs([t], r, void 0, o),
        s = this._makeSubscription(
          {
            callback: (t, n) => {
              e(t, n);
              try {
                this.removeSignatureListener(s);
              } catch (r) {}
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe",
          },
          i
        );
      return s;
    }
    async removeSignatureListener(t) {
      await this._unsubscribeClientSubscription(t, "signature result");
    }
    _wsOnRootNotification(t) {
      const { result: e, subscription: n } = Rr(t, qa);
      this._handleServerNotification(n, [e]);
    }
    onRootChange(t) {
      return this._makeSubscription(
        {
          callback: t,
          method: "rootSubscribe",
          unsubscribeMethod: "rootUnsubscribe",
        },
        []
      );
    }
    async removeRootChangeListener(t) {
      await this._unsubscribeClientSubscription(t, "root change");
    }
  }
  class Bc {
    constructor(t) {
      (this._keypair = void 0), (this._keypair = t ?? bi());
    }
    static generate() {
      return new Bc(bi());
    }
    static fromSecretKey(t, e) {
      if (64 !== t.byteLength) throw new Error("bad secret key size");
      const n = t.slice(32, 64);
      if (!e || !e.skipValidation) {
        const e = t.slice(0, 32),
          r = vi(e);
        for (let t = 0; t < 32; t++)
          if (n[t] !== r[t]) throw new Error("provided secretKey is invalid");
      }
      return new Bc({ publicKey: n, secretKey: t });
    }
    static fromSeed(t) {
      const e = vi(t),
        n = new Uint8Array(64);
      return n.set(t), n.set(e, 32), new Bc({ publicKey: e, secretKey: n });
    }
    get publicKey() {
      return new Ti(this._keypair.publicKey);
    }
    get secretKey() {
      return new Uint8Array(this._keypair.secretKey);
    }
  }
  const xc = Object.freeze({
    CreateLookupTable: {
      index: 0,
      layout: hr.struct([
        hr.u32("instruction"),
        As("recentSlot"),
        hr.u8("bumpSeed"),
      ]),
    },
    FreezeLookupTable: { index: 1, layout: hr.struct([hr.u32("instruction")]) },
    ExtendLookupTable: {
      index: 2,
      layout: hr.struct([
        hr.u32("instruction"),
        As(),
        hr.seq(Di(), hr.offset(hr.u32(), -8), "addresses"),
      ]),
    },
    DeactivateLookupTable: {
      index: 3,
      layout: hr.struct([hr.u32("instruction")]),
    },
    CloseLookupTable: { index: 4, layout: hr.struct([hr.u32("instruction")]) },
  });
  class Tc {
    constructor() {}
    static createLookupTable(t) {
      const [e, n] = Ti.findProgramAddressSync(
          [t.authority.toBuffer(), vr().encode(t.recentSlot)],
          this.programId
        ),
        r = gs(xc.CreateLookupTable, {
          recentSlot: BigInt(t.recentSlot),
          bumpSeed: n,
        }),
        o = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: t.authority, isSigner: !0, isWritable: !1 },
          { pubkey: t.payer, isSigner: !0, isWritable: !0 },
          { pubkey: Is.programId, isSigner: !1, isWritable: !1 },
        ];
      return [new ts({ programId: this.programId, keys: o, data: r }), e];
    }
    static freezeLookupTable(t) {
      const e = gs(xc.FreezeLookupTable),
        n = [
          { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
          { pubkey: t.authority, isSigner: !0, isWritable: !1 },
        ];
      return new ts({ programId: this.programId, keys: n, data: e });
    }
    static extendLookupTable(t) {
      const e = gs(xc.ExtendLookupTable, {
          addresses: t.addresses.map((t) => t.toBytes()),
        }),
        n = [
          { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
          { pubkey: t.authority, isSigner: !0, isWritable: !1 },
        ];
      return (
        t.payer &&
          n.push(
            { pubkey: t.payer, isSigner: !0, isWritable: !0 },
            { pubkey: Is.programId, isSigner: !1, isWritable: !1 }
          ),
        new ts({ programId: this.programId, keys: n, data: e })
      );
    }
    static deactivateLookupTable(t) {
      const e = gs(xc.DeactivateLookupTable),
        n = [
          { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
          { pubkey: t.authority, isSigner: !0, isWritable: !1 },
        ];
      return new ts({ programId: this.programId, keys: n, data: e });
    }
    static closeLookupTable(t) {
      const e = gs(xc.CloseLookupTable),
        n = [
          { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
          { pubkey: t.authority, isSigner: !0, isWritable: !1 },
          { pubkey: t.recipient, isSigner: !1, isWritable: !0 },
        ];
      return new ts({ programId: this.programId, keys: n, data: e });
    }
  }
  Tc.programId = new Ti("AddressLookupTab1e1111111111111111111111111");
  const Rc = Object.freeze({
    RequestUnits: {
      index: 0,
      layout: hr.struct([
        hr.u8("instruction"),
        hr.u32("units"),
        hr.u32("additionalFee"),
      ]),
    },
    RequestHeapFrame: {
      index: 1,
      layout: hr.struct([hr.u8("instruction"), hr.u32("bytes")]),
    },
    SetComputeUnitLimit: {
      index: 2,
      layout: hr.struct([hr.u8("instruction"), hr.u32("units")]),
    },
    SetComputeUnitPrice: {
      index: 3,
      layout: hr.struct([hr.u8("instruction"), As("microLamports")]),
    },
  });
  class Oc {
    constructor() {}
    static requestUnits(t) {
      const e = gs(Rc.RequestUnits, t);
      return new ts({ keys: [], programId: this.programId, data: e });
    }
    static requestHeapFrame(t) {
      const e = gs(Rc.RequestHeapFrame, t);
      return new ts({ keys: [], programId: this.programId, data: e });
    }
    static setComputeUnitLimit(t) {
      const e = gs(Rc.SetComputeUnitLimit, t);
      return new ts({ keys: [], programId: this.programId, data: e });
    }
    static setComputeUnitPrice(t) {
      const e = gs(Rc.SetComputeUnitPrice, {
        microLamports: BigInt(t.microLamports),
      });
      return new ts({ keys: [], programId: this.programId, data: e });
    }
  }
  Oc.programId = new Ti("ComputeBudget111111111111111111111111111111");
  const Mc = hr.struct([
    hr.u8("numSignatures"),
    hr.u8("padding"),
    hr.u16("signatureOffset"),
    hr.u16("signatureInstructionIndex"),
    hr.u16("publicKeyOffset"),
    hr.u16("publicKeyInstructionIndex"),
    hr.u16("messageDataOffset"),
    hr.u16("messageDataSize"),
    hr.u16("messageInstructionIndex"),
  ]);
  class Nc {
    constructor() {}
    static createInstructionWithPublicKey(t) {
      const { publicKey: e, message: n, signature: r, instructionIndex: o } = t;
      ji(
        32 === e.length,
        `Public Key must be 32 bytes but received ${e.length} bytes`
      ),
        ji(
          64 === r.length,
          `Signature must be 64 bytes but received ${r.length} bytes`
        );
      const i = Mc.span,
        s = i + e.length,
        a = s + r.length,
        c = X.alloc(a + n.length),
        u = null == o ? 65535 : o;
      return (
        Mc.encode(
          {
            numSignatures: 1,
            padding: 0,
            signatureOffset: s,
            signatureInstructionIndex: u,
            publicKeyOffset: i,
            publicKeyInstructionIndex: u,
            messageDataOffset: a,
            messageDataSize: n.length,
            messageInstructionIndex: u,
          },
          c
        ),
        c.fill(e, i),
        c.fill(r, s),
        c.fill(n, a),
        new ts({ keys: [], programId: Nc.programId, data: c })
      );
    }
    static createInstructionWithPrivateKey(t) {
      const { privateKey: e, message: n, instructionIndex: r } = t;
      ji(
        64 === e.length,
        `Private key must be 64 bytes but received ${e.length} bytes`
      );
      try {
        const t = Bc.fromSecretKey(e),
          o = t.publicKey.toBytes(),
          i = ki(n, t.secretKey);
        return this.createInstructionWithPublicKey({
          publicKey: o,
          message: n,
          signature: i,
          instructionIndex: r,
        });
      } catch (o) {
        throw new Error(`Error creating instruction; ${o}`);
      }
    }
  }
  Nc.programId = new Ti("Ed25519SigVerify111111111111111111111111111");
  gi.utils.isValidPrivateKey;
  const Pc = gi.getPublicKey,
    Lc = hr.struct([
      hr.u8("numSignatures"),
      hr.u16("signatureOffset"),
      hr.u8("signatureInstructionIndex"),
      hr.u16("ethAddressOffset"),
      hr.u8("ethAddressInstructionIndex"),
      hr.u16("messageDataOffset"),
      hr.u16("messageDataSize"),
      hr.u8("messageInstructionIndex"),
      hr.blob(20, "ethAddress"),
      hr.blob(64, "signature"),
      hr.u8("recoveryId"),
    ]);
  class zc {
    constructor() {}
    static publicKeyToEthAddress(t) {
      ji(
        64 === t.length,
        `Public key must be 64 bytes but received ${t.length} bytes`
      );
      try {
        return X.from(Zo(Ei(t))).slice(-20);
      } catch (e) {
        throw new Error(`Error constructing Ethereum address: ${e}`);
      }
    }
    static createInstructionWithPublicKey(t) {
      const {
        publicKey: e,
        message: n,
        signature: r,
        recoveryId: o,
        instructionIndex: i,
      } = t;
      return zc.createInstructionWithEthAddress({
        ethAddress: zc.publicKeyToEthAddress(e),
        message: n,
        signature: r,
        recoveryId: o,
        instructionIndex: i,
      });
    }
    static createInstructionWithEthAddress(t) {
      const {
        ethAddress: e,
        message: n,
        signature: r,
        recoveryId: o,
        instructionIndex: i = 0,
      } = t;
      let s;
      (s =
        "string" == typeof e
          ? e.startsWith("0x")
            ? X.from(e.substr(2), "hex")
            : X.from(e, "hex")
          : e),
        ji(
          20 === s.length,
          `Address must be 20 bytes but received ${s.length} bytes`
        );
      const a = 12 + s.length,
        c = a + r.length + 1,
        u = X.alloc(Lc.span + n.length);
      return (
        Lc.encode(
          {
            numSignatures: 1,
            signatureOffset: a,
            signatureInstructionIndex: i,
            ethAddressOffset: 12,
            ethAddressInstructionIndex: i,
            messageDataOffset: c,
            messageDataSize: n.length,
            messageInstructionIndex: i,
            signature: Ei(r),
            ethAddress: Ei(s),
            recoveryId: o,
          },
          u
        ),
        u.fill(Ei(n), Lc.span),
        new ts({ keys: [], programId: zc.programId, data: u })
      );
    }
    static createInstructionWithPrivateKey(t) {
      const { privateKey: e, message: n, instructionIndex: r } = t;
      ji(
        32 === e.length,
        `Private key must be 32 bytes but received ${e.length} bytes`
      );
      try {
        const t = Ei(e),
          o = Pc(t, !1).slice(1),
          i = X.from(Zo(Ei(n))),
          [s, a] = ((t, e) => {
            const n = gi.sign(t, e);
            return [n.toCompactRawBytes(), n.recovery];
          })(i, t);
        return this.createInstructionWithPublicKey({
          publicKey: o,
          message: n,
          signature: s,
          recoveryId: a,
          instructionIndex: r,
        });
      } catch (o) {
        throw new Error(`Error creating instruction; ${o}`);
      }
    }
  }
  var Dc;
  zc.programId = new Ti("KeccakSecp256k11111111111111111111111111111");
  const Uc = new Ti("StakeConfig11111111111111111111111111111111");
  class qc {
    constructor(t, e) {
      (this.staker = void 0),
        (this.withdrawer = void 0),
        (this.staker = t),
        (this.withdrawer = e);
    }
  }
  class Gc {
    constructor(t, e, n) {
      (this.unixTimestamp = void 0),
        (this.epoch = void 0),
        (this.custodian = void 0),
        (this.unixTimestamp = t),
        (this.epoch = e),
        (this.custodian = n);
    }
  }
  (Dc = Gc), (Gc.default = new Dc(0, 0, Ti.default));
  const Wc = Object.freeze({
      Initialize: {
        index: 0,
        layout: hr.struct([
          hr.u32("instruction"),
          ((t = "authorized") =>
            hr.struct([Di("staker"), Di("withdrawer")], t))(),
          ((t = "lockup") =>
            hr.struct(
              [hr.ns64("unixTimestamp"), hr.ns64("epoch"), Di("custodian")],
              t
            ))(),
        ]),
      },
      Authorize: {
        index: 1,
        layout: hr.struct([
          hr.u32("instruction"),
          Di("newAuthorized"),
          hr.u32("stakeAuthorizationType"),
        ]),
      },
      Delegate: { index: 2, layout: hr.struct([hr.u32("instruction")]) },
      Split: {
        index: 3,
        layout: hr.struct([hr.u32("instruction"), hr.ns64("lamports")]),
      },
      Withdraw: {
        index: 4,
        layout: hr.struct([hr.u32("instruction"), hr.ns64("lamports")]),
      },
      Deactivate: { index: 5, layout: hr.struct([hr.u32("instruction")]) },
      Merge: { index: 7, layout: hr.struct([hr.u32("instruction")]) },
      AuthorizeWithSeed: {
        index: 8,
        layout: hr.struct([
          hr.u32("instruction"),
          Di("newAuthorized"),
          hr.u32("stakeAuthorizationType"),
          qi("authoritySeed"),
          Di("authorityOwner"),
        ]),
      },
    }),
    Kc = Object.freeze({ Staker: { index: 0 }, Withdrawer: { index: 1 } });
  class jc {
    constructor() {}
    static initialize(t) {
      const { stakePubkey: e, authorized: n, lockup: r } = t,
        o = r || Gc.default,
        i = gs(Wc.Initialize, {
          authorized: {
            staker: Ei(n.staker.toBuffer()),
            withdrawer: Ei(n.withdrawer.toBuffer()),
          },
          lockup: {
            unixTimestamp: o.unixTimestamp,
            epoch: o.epoch,
            custodian: Ei(o.custodian.toBuffer()),
          },
        }),
        s = {
          keys: [
            { pubkey: e, isSigner: !1, isWritable: !0 },
            { pubkey: cs, isSigner: !1, isWritable: !1 },
          ],
          programId: this.programId,
          data: i,
        };
      return new ts(s);
    }
    static createAccountWithSeed(t) {
      const e = new es();
      e.add(
        Is.createAccountWithSeed({
          fromPubkey: t.fromPubkey,
          newAccountPubkey: t.stakePubkey,
          basePubkey: t.basePubkey,
          seed: t.seed,
          lamports: t.lamports,
          space: this.space,
          programId: this.programId,
        })
      );
      const { stakePubkey: n, authorized: r, lockup: o } = t;
      return e.add(
        this.initialize({ stakePubkey: n, authorized: r, lockup: o })
      );
    }
    static createAccount(t) {
      const e = new es();
      e.add(
        Is.createAccount({
          fromPubkey: t.fromPubkey,
          newAccountPubkey: t.stakePubkey,
          lamports: t.lamports,
          space: this.space,
          programId: this.programId,
        })
      );
      const { stakePubkey: n, authorized: r, lockup: o } = t;
      return e.add(
        this.initialize({ stakePubkey: n, authorized: r, lockup: o })
      );
    }
    static delegate(t) {
      const { stakePubkey: e, authorizedPubkey: n, votePubkey: r } = t,
        o = gs(Wc.Delegate);
      return new es().add({
        keys: [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: r, isSigner: !1, isWritable: !1 },
          { pubkey: os, isSigner: !1, isWritable: !1 },
          { pubkey: ds, isSigner: !1, isWritable: !1 },
          { pubkey: Uc, isSigner: !1, isWritable: !1 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: o,
      });
    }
    static authorize(t) {
      const {
          stakePubkey: e,
          authorizedPubkey: n,
          newAuthorizedPubkey: r,
          stakeAuthorizationType: o,
          custodianPubkey: i,
        } = t,
        s = gs(Wc.Authorize, {
          newAuthorized: Ei(r.toBuffer()),
          stakeAuthorizationType: o.index,
        }),
        a = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: os, isSigner: !1, isWritable: !0 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ];
      return (
        i && a.push({ pubkey: i, isSigner: !0, isWritable: !1 }),
        new es().add({ keys: a, programId: this.programId, data: s })
      );
    }
    static authorizeWithSeed(t) {
      const {
          stakePubkey: e,
          authorityBase: n,
          authoritySeed: r,
          authorityOwner: o,
          newAuthorizedPubkey: i,
          stakeAuthorizationType: s,
          custodianPubkey: a,
        } = t,
        c = gs(Wc.AuthorizeWithSeed, {
          newAuthorized: Ei(i.toBuffer()),
          stakeAuthorizationType: s.index,
          authoritySeed: r,
          authorityOwner: Ei(o.toBuffer()),
        }),
        u = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
          { pubkey: os, isSigner: !1, isWritable: !1 },
        ];
      return (
        a && u.push({ pubkey: a, isSigner: !0, isWritable: !1 }),
        new es().add({ keys: u, programId: this.programId, data: c })
      );
    }
    static splitInstruction(t) {
      const {
          stakePubkey: e,
          authorizedPubkey: n,
          splitStakePubkey: r,
          lamports: o,
        } = t,
        i = gs(Wc.Split, { lamports: o });
      return new ts({
        keys: [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: r, isSigner: !1, isWritable: !0 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: i,
      });
    }
    static split(t, e) {
      const n = new es();
      return (
        n.add(
          Is.createAccount({
            fromPubkey: t.authorizedPubkey,
            newAccountPubkey: t.splitStakePubkey,
            lamports: e,
            space: this.space,
            programId: this.programId,
          })
        ),
        n.add(this.splitInstruction(t))
      );
    }
    static splitWithSeed(t, e) {
      const {
          stakePubkey: n,
          authorizedPubkey: r,
          splitStakePubkey: o,
          basePubkey: i,
          seed: s,
          lamports: a,
        } = t,
        c = new es();
      return (
        c.add(
          Is.allocate({
            accountPubkey: o,
            basePubkey: i,
            seed: s,
            space: this.space,
            programId: this.programId,
          })
        ),
        e &&
          e > 0 &&
          c.add(
            Is.transfer({
              fromPubkey: t.authorizedPubkey,
              toPubkey: o,
              lamports: e,
            })
          ),
        c.add(
          this.splitInstruction({
            stakePubkey: n,
            authorizedPubkey: r,
            splitStakePubkey: o,
            lamports: a,
          })
        )
      );
    }
    static merge(t) {
      const { stakePubkey: e, sourceStakePubKey: n, authorizedPubkey: r } = t,
        o = gs(Wc.Merge);
      return new es().add({
        keys: [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: n, isSigner: !1, isWritable: !0 },
          { pubkey: os, isSigner: !1, isWritable: !1 },
          { pubkey: ds, isSigner: !1, isWritable: !1 },
          { pubkey: r, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: o,
      });
    }
    static withdraw(t) {
      const {
          stakePubkey: e,
          authorizedPubkey: n,
          toPubkey: r,
          lamports: o,
          custodianPubkey: i,
        } = t,
        s = gs(Wc.Withdraw, { lamports: o }),
        a = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: r, isSigner: !1, isWritable: !0 },
          { pubkey: os, isSigner: !1, isWritable: !1 },
          { pubkey: ds, isSigner: !1, isWritable: !1 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ];
      return (
        i && a.push({ pubkey: i, isSigner: !0, isWritable: !1 }),
        new es().add({ keys: a, programId: this.programId, data: s })
      );
    }
    static deactivate(t) {
      const { stakePubkey: e, authorizedPubkey: n } = t,
        r = gs(Wc.Deactivate);
      return new es().add({
        keys: [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: os, isSigner: !1, isWritable: !1 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: r,
      });
    }
  }
  (jc.programId = new Ti("Stake11111111111111111111111111111111111111")),
    (jc.space = 200);
  class Hc {
    constructor(t, e, n, r) {
      (this.nodePubkey = void 0),
        (this.authorizedVoter = void 0),
        (this.authorizedWithdrawer = void 0),
        (this.commission = void 0),
        (this.nodePubkey = t),
        (this.authorizedVoter = e),
        (this.authorizedWithdrawer = n),
        (this.commission = r);
    }
  }
  const Vc = Object.freeze({
      InitializeAccount: {
        index: 0,
        layout: hr.struct([
          hr.u32("instruction"),
          ((t = "voteInit") =>
            hr.struct(
              [
                Di("nodePubkey"),
                Di("authorizedVoter"),
                Di("authorizedWithdrawer"),
                hr.u8("commission"),
              ],
              t
            ))(),
        ]),
      },
      Authorize: {
        index: 1,
        layout: hr.struct([
          hr.u32("instruction"),
          Di("newAuthorized"),
          hr.u32("voteAuthorizationType"),
        ]),
      },
      Withdraw: {
        index: 3,
        layout: hr.struct([hr.u32("instruction"), hr.ns64("lamports")]),
      },
      UpdateValidatorIdentity: {
        index: 4,
        layout: hr.struct([hr.u32("instruction")]),
      },
      AuthorizeWithSeed: {
        index: 10,
        layout: hr.struct([
          hr.u32("instruction"),
          ((t = "voteAuthorizeWithSeedArgs") =>
            hr.struct(
              [
                hr.u32("voteAuthorizationType"),
                Di("currentAuthorityDerivedKeyOwnerPubkey"),
                qi("currentAuthorityDerivedKeySeed"),
                Di("newAuthorized"),
              ],
              t
            ))(),
        ]),
      },
    }),
    Fc = Object.freeze({ Voter: { index: 0 }, Withdrawer: { index: 1 } });
  class Yc {
    constructor() {}
    static initializeAccount(t) {
      const { votePubkey: e, nodePubkey: n, voteInit: r } = t,
        o = gs(Vc.InitializeAccount, {
          voteInit: {
            nodePubkey: Ei(r.nodePubkey.toBuffer()),
            authorizedVoter: Ei(r.authorizedVoter.toBuffer()),
            authorizedWithdrawer: Ei(r.authorizedWithdrawer.toBuffer()),
            commission: r.commission,
          },
        }),
        i = {
          keys: [
            { pubkey: e, isSigner: !1, isWritable: !0 },
            { pubkey: cs, isSigner: !1, isWritable: !1 },
            { pubkey: os, isSigner: !1, isWritable: !1 },
            { pubkey: n, isSigner: !0, isWritable: !1 },
          ],
          programId: this.programId,
          data: o,
        };
      return new ts(i);
    }
    static createAccount(t) {
      const e = new es();
      return (
        e.add(
          Is.createAccount({
            fromPubkey: t.fromPubkey,
            newAccountPubkey: t.votePubkey,
            lamports: t.lamports,
            space: this.space,
            programId: this.programId,
          })
        ),
        e.add(
          this.initializeAccount({
            votePubkey: t.votePubkey,
            nodePubkey: t.voteInit.nodePubkey,
            voteInit: t.voteInit,
          })
        )
      );
    }
    static authorize(t) {
      const {
          votePubkey: e,
          authorizedPubkey: n,
          newAuthorizedPubkey: r,
          voteAuthorizationType: o,
        } = t,
        i = gs(Vc.Authorize, {
          newAuthorized: Ei(r.toBuffer()),
          voteAuthorizationType: o.index,
        }),
        s = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: os, isSigner: !1, isWritable: !1 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ];
      return new es().add({ keys: s, programId: this.programId, data: i });
    }
    static authorizeWithSeed(t) {
      const {
          currentAuthorityDerivedKeyBasePubkey: e,
          currentAuthorityDerivedKeyOwnerPubkey: n,
          currentAuthorityDerivedKeySeed: r,
          newAuthorizedPubkey: o,
          voteAuthorizationType: i,
          votePubkey: s,
        } = t,
        a = gs(Vc.AuthorizeWithSeed, {
          voteAuthorizeWithSeedArgs: {
            currentAuthorityDerivedKeyOwnerPubkey: Ei(n.toBuffer()),
            currentAuthorityDerivedKeySeed: r,
            newAuthorized: Ei(o.toBuffer()),
            voteAuthorizationType: i.index,
          },
        }),
        c = [
          { pubkey: s, isSigner: !1, isWritable: !0 },
          { pubkey: os, isSigner: !1, isWritable: !1 },
          { pubkey: e, isSigner: !0, isWritable: !1 },
        ];
      return new es().add({ keys: c, programId: this.programId, data: a });
    }
    static withdraw(t) {
      const {
          votePubkey: e,
          authorizedWithdrawerPubkey: n,
          lamports: r,
          toPubkey: o,
        } = t,
        i = gs(Vc.Withdraw, { lamports: r }),
        s = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: o, isSigner: !1, isWritable: !0 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ];
      return new es().add({ keys: s, programId: this.programId, data: i });
    }
    static safeWithdraw(t, e, n) {
      if (t.lamports > e - n)
        throw new Error(
          "Withdraw will leave vote account with insufficient funds."
        );
      return Yc.withdraw(t);
    }
    static updateValidatorIdentity(t) {
      const { votePubkey: e, authorizedWithdrawerPubkey: n, nodePubkey: r } = t,
        o = gs(Vc.UpdateValidatorIdentity),
        i = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: r, isSigner: !0, isWritable: !1 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ];
      return new es().add({ keys: i, programId: this.programId, data: o });
    }
  }
  (Yc.programId = new Ti("Vote111111111111111111111111111111111111111")),
    (Yc.space = 3762);
  const Zc = new Ti("Va1idator1nfo111111111111111111111111111111"),
    Jc = Hr({
      name: Kr(),
      website: Gr(Kr()),
      details: Gr(Kr()),
      iconUrl: Gr(Kr()),
      keybaseUsername: Gr(Kr()),
    });
  class Xc {
    constructor(t, e) {
      (this.key = void 0),
        (this.info = void 0),
        (this.key = t),
        (this.info = e);
    }
    static fromConfigData(t) {
      let e = [...t];
      if (2 !== Wi(e)) return null;
      const n = [];
      for (let r = 0; r < 2; r++) {
        const t = new Ti(Yi(e, 0, Bi)),
          r = 1 === Fi(e);
        n.push({ publicKey: t, isSigner: r });
      }
      if (n[0].publicKey.equals(Zc) && n[1].isSigner) {
        const t = qi().decode(X.from(e)),
          r = JSON.parse(t);
        return Tr(r, Jc), new Xc(n[1].publicKey, r);
      }
      return null;
    }
  }
  const $c = new Ti("Vote111111111111111111111111111111111111111"),
    Qc = hr.struct([
      Di("nodePubkey"),
      Di("authorizedWithdrawer"),
      hr.u8("commission"),
      hr.nu64(),
      hr.seq(
        hr.struct([hr.nu64("slot"), hr.u32("confirmationCount")]),
        hr.offset(hr.u32(), -8),
        "votes"
      ),
      hr.u8("rootSlotValid"),
      hr.nu64("rootSlot"),
      hr.nu64(),
      hr.seq(
        hr.struct([hr.nu64("epoch"), Di("authorizedVoter")]),
        hr.offset(hr.u32(), -8),
        "authorizedVoters"
      ),
      hr.struct(
        [
          hr.seq(
            hr.struct([
              Di("authorizedPubkey"),
              hr.nu64("epochOfLastAuthorizedSwitch"),
              hr.nu64("targetEpoch"),
            ]),
            32,
            "buf"
          ),
          hr.nu64("idx"),
          hr.u8("isEmpty"),
        ],
        "priorVoters"
      ),
      hr.nu64(),
      hr.seq(
        hr.struct([
          hr.nu64("epoch"),
          hr.nu64("credits"),
          hr.nu64("prevCredits"),
        ]),
        hr.offset(hr.u32(), -8),
        "epochCredits"
      ),
      hr.struct([hr.nu64("slot"), hr.nu64("timestamp")], "lastTimestamp"),
    ]);
  class tu {
    constructor(t) {
      (this.nodePubkey = void 0),
        (this.authorizedWithdrawer = void 0),
        (this.commission = void 0),
        (this.rootSlot = void 0),
        (this.votes = void 0),
        (this.authorizedVoters = void 0),
        (this.priorVoters = void 0),
        (this.epochCredits = void 0),
        (this.lastTimestamp = void 0),
        (this.nodePubkey = t.nodePubkey),
        (this.authorizedWithdrawer = t.authorizedWithdrawer),
        (this.commission = t.commission),
        (this.rootSlot = t.rootSlot),
        (this.votes = t.votes),
        (this.authorizedVoters = t.authorizedVoters),
        (this.priorVoters = t.priorVoters),
        (this.epochCredits = t.epochCredits),
        (this.lastTimestamp = t.lastTimestamp);
    }
    static fromAccountData(t) {
      const e = Qc.decode(Ei(t), 4);
      let n = e.rootSlot;
      return (
        e.rootSlotValid || (n = null),
        new tu({
          nodePubkey: new Ti(e.nodePubkey),
          authorizedWithdrawer: new Ti(e.authorizedWithdrawer),
          commission: e.commission,
          votes: e.votes,
          rootSlot: n,
          authorizedVoters: e.authorizedVoters.map(eu),
          priorVoters: ru(e.priorVoters),
          epochCredits: e.epochCredits,
          lastTimestamp: e.lastTimestamp,
        })
      );
    }
  }
  function eu({ authorizedVoter: t, epoch: e }) {
    return { epoch: e, authorizedVoter: new Ti(t) };
  }
  function nu({
    authorizedPubkey: t,
    epochOfLastAuthorizedSwitch: e,
    targetEpoch: n,
  }) {
    return {
      authorizedPubkey: new Ti(t),
      epochOfLastAuthorizedSwitch: e,
      targetEpoch: n,
    };
  }
  function ru({ buf: t, idx: e, isEmpty: n }) {
    return n ? [] : [...t.slice(e + 1).map(nu), ...t.slice(0, e).map(nu)];
  }
  const ou = {
    http: {
      devnet: "http://api.devnet.solana.com",
      testnet: "http://api.testnet.solana.com",
      "mainnet-beta": "http://api.mainnet-beta.solana.com/",
    },
    https: {
      devnet: "https://api.devnet.solana.com",
      testnet: "https://api.testnet.solana.com",
      "mainnet-beta": "https://api.mainnet-beta.solana.com/",
    },
  };
  const iu = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Account: class {
          constructor(t) {
            if (((this._publicKey = void 0), (this._secretKey = void 0), t)) {
              const e = Ei(t);
              if (64 !== t.length) throw new Error("bad secret key size");
              (this._publicKey = e.slice(32, 64)),
                (this._secretKey = e.slice(0, 32));
            } else
              (this._secretKey = Ei(wi())),
                (this._publicKey = Ei(vi(this._secretKey)));
          }
          get publicKey() {
            return new Ti(this._publicKey);
          }
          get secretKey() {
            return X.concat([this._secretKey, this._publicKey], 64);
          }
        },
        AddressLookupTableAccount: Ps,
        AddressLookupTableInstruction: class {
          constructor() {}
          static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = hr.u32("instruction").decode(t.data);
            let n;
            for (const [r, o] of Object.entries(xc))
              if (o.index == e) {
                n = r;
                break;
              }
            if (!n)
              throw new Error(
                "Invalid Instruction. Should be a LookupTable Instruction"
              );
            return n;
          }
          static decodeCreateLookupTable(t) {
            this.checkProgramId(t.programId), this.checkKeysLength(t.keys, 4);
            const { recentSlot: e } = ws(xc.CreateLookupTable, t.data);
            return {
              authority: t.keys[1].pubkey,
              payer: t.keys[2].pubkey,
              recentSlot: Number(e),
            };
          }
          static decodeExtendLookupTable(t) {
            if ((this.checkProgramId(t.programId), t.keys.length < 2))
              throw new Error(
                `invalid instruction; found ${t.keys.length} keys, expected at least 2`
              );
            const { addresses: e } = ws(xc.ExtendLookupTable, t.data);
            return {
              lookupTable: t.keys[0].pubkey,
              authority: t.keys[1].pubkey,
              payer: t.keys.length > 2 ? t.keys[2].pubkey : void 0,
              addresses: e.map((t) => new Ti(t)),
            };
          }
          static decodeCloseLookupTable(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeysLength(t.keys, 3),
              {
                lookupTable: t.keys[0].pubkey,
                authority: t.keys[1].pubkey,
                recipient: t.keys[2].pubkey,
              }
            );
          }
          static decodeFreezeLookupTable(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeysLength(t.keys, 2),
              { lookupTable: t.keys[0].pubkey, authority: t.keys[1].pubkey }
            );
          }
          static decodeDeactivateLookupTable(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeysLength(t.keys, 2),
              { lookupTable: t.keys[0].pubkey, authority: t.keys[1].pubkey }
            );
          }
          static checkProgramId(t) {
            if (!t.equals(Tc.programId))
              throw new Error(
                "invalid instruction; programId is not AddressLookupTable Program"
              );
          }
          static checkKeysLength(t, e) {
            if (t.length < e)
              throw new Error(
                `invalid instruction; found ${t.length} keys, expected at least ${e}`
              );
          }
        },
        AddressLookupTableProgram: Tc,
        Authorized: qc,
        BLOCKHASH_CACHE_TIMEOUT_MS: 3e4,
        BPF_LOADER_DEPRECATED_PROGRAM_ID: Ri,
        BPF_LOADER_PROGRAM_ID: Ss,
        BpfLoader: class {
          static getMinNumSignatures(t) {
            return Cs.getMinNumSignatures(t);
          }
          static load(t, e, n, r, o) {
            return Cs.load(t, e, n, o, r);
          }
        },
        COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: Rc,
        ComputeBudgetInstruction: class {
          constructor() {}
          static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = hr.u8("instruction").decode(t.data);
            let n;
            for (const [r, o] of Object.entries(Rc))
              if (o.index == e) {
                n = r;
                break;
              }
            if (!n)
              throw new Error(
                "Instruction type incorrect; not a ComputeBudgetInstruction"
              );
            return n;
          }
          static decodeRequestUnits(t) {
            this.checkProgramId(t.programId);
            const { units: e, additionalFee: n } = ws(Rc.RequestUnits, t.data);
            return { units: e, additionalFee: n };
          }
          static decodeRequestHeapFrame(t) {
            this.checkProgramId(t.programId);
            const { bytes: e } = ws(Rc.RequestHeapFrame, t.data);
            return { bytes: e };
          }
          static decodeSetComputeUnitLimit(t) {
            this.checkProgramId(t.programId);
            const { units: e } = ws(Rc.SetComputeUnitLimit, t.data);
            return { units: e };
          }
          static decodeSetComputeUnitPrice(t) {
            this.checkProgramId(t.programId);
            const { microLamports: e } = ws(Rc.SetComputeUnitPrice, t.data);
            return { microLamports: e };
          }
          static checkProgramId(t) {
            if (!t.equals(Oc.programId))
              throw new Error(
                "invalid instruction; programId is not ComputeBudgetProgram"
              );
          }
        },
        ComputeBudgetProgram: Oc,
        Connection: Sc,
        Ed25519Program: Nc,
        Enum: class extends Ii {
          constructor(t) {
            if ((super(t), (this.enum = ""), 1 !== Object.keys(t).length))
              throw new Error("Enum can only take single value");
            Object.keys(t).map((t) => {
              this.enum = t;
            });
          }
        },
        EpochSchedule: Os,
        FeeCalculatorLayout: bs,
        Keypair: Bc,
        LAMPORTS_PER_SOL: 1e9,
        LOOKUP_TABLE_INSTRUCTION_LAYOUTS: xc,
        Loader: Cs,
        Lockup: Gc,
        MAX_SEED_LENGTH: 32,
        Message: Zi,
        MessageAccountKeys: zi,
        MessageV0: Ji,
        NONCE_ACCOUNT_LENGTH: _s,
        NonceAccount: ks,
        PACKET_DATA_SIZE: Oi,
        PUBLIC_KEY_LENGTH: Bi,
        PublicKey: Ti,
        SIGNATURE_LENGTH_IN_BYTES: 64,
        SOLANA_SCHEMA: Ci,
        STAKE_CONFIG_ID: Uc,
        STAKE_INSTRUCTION_LAYOUTS: Wc,
        SYSTEM_INSTRUCTION_LAYOUTS: Es,
        SYSVAR_CLOCK_PUBKEY: os,
        SYSVAR_EPOCH_SCHEDULE_PUBKEY: is,
        SYSVAR_INSTRUCTIONS_PUBKEY: ss,
        SYSVAR_RECENT_BLOCKHASHES_PUBKEY: as,
        SYSVAR_RENT_PUBKEY: cs,
        SYSVAR_REWARDS_PUBKEY: us,
        SYSVAR_SLOT_HASHES_PUBKEY: ls,
        SYSVAR_SLOT_HISTORY_PUBKEY: hs,
        SYSVAR_STAKE_HISTORY_PUBKEY: ds,
        Secp256k1Program: zc,
        SendTransactionError: fs,
        SolanaJSONRPCError: ps,
        SolanaJSONRPCErrorCode: {
          JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
          JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
          JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:
            -32003,
          JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
          JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
          JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:
            -32006,
          JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
          JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
          JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
          JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
          JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
          JSON_RPC_SCAN_ERROR: -32012,
          JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
          JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
          JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
          JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016,
        },
        StakeAuthorizationLayout: Kc,
        StakeInstruction: class {
          constructor() {}
          static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = hr.u32("instruction").decode(t.data);
            let n;
            for (const [r, o] of Object.entries(Wc))
              if (o.index == e) {
                n = r;
                break;
              }
            if (!n)
              throw new Error(
                "Instruction type incorrect; not a StakeInstruction"
              );
            return n;
          }
          static decodeInitialize(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const { authorized: e, lockup: n } = ws(Wc.Initialize, t.data);
            return {
              stakePubkey: t.keys[0].pubkey,
              authorized: new qc(new Ti(e.staker), new Ti(e.withdrawer)),
              lockup: new Gc(n.unixTimestamp, n.epoch, new Ti(n.custodian)),
            };
          }
          static decodeDelegate(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeyLength(t.keys, 6),
              ws(Wc.Delegate, t.data),
              {
                stakePubkey: t.keys[0].pubkey,
                votePubkey: t.keys[1].pubkey,
                authorizedPubkey: t.keys[5].pubkey,
              }
            );
          }
          static decodeAuthorize(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const { newAuthorized: e, stakeAuthorizationType: n } = ws(
                Wc.Authorize,
                t.data
              ),
              r = {
                stakePubkey: t.keys[0].pubkey,
                authorizedPubkey: t.keys[2].pubkey,
                newAuthorizedPubkey: new Ti(e),
                stakeAuthorizationType: { index: n },
              };
            return (
              t.keys.length > 3 && (r.custodianPubkey = t.keys[3].pubkey), r
            );
          }
          static decodeAuthorizeWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const {
                newAuthorized: e,
                stakeAuthorizationType: n,
                authoritySeed: r,
                authorityOwner: o,
              } = ws(Wc.AuthorizeWithSeed, t.data),
              i = {
                stakePubkey: t.keys[0].pubkey,
                authorityBase: t.keys[1].pubkey,
                authoritySeed: r,
                authorityOwner: new Ti(o),
                newAuthorizedPubkey: new Ti(e),
                stakeAuthorizationType: { index: n },
              };
            return (
              t.keys.length > 3 && (i.custodianPubkey = t.keys[3].pubkey), i
            );
          }
          static decodeSplit(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const { lamports: e } = ws(Wc.Split, t.data);
            return {
              stakePubkey: t.keys[0].pubkey,
              splitStakePubkey: t.keys[1].pubkey,
              authorizedPubkey: t.keys[2].pubkey,
              lamports: e,
            };
          }
          static decodeMerge(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeyLength(t.keys, 3),
              ws(Wc.Merge, t.data),
              {
                stakePubkey: t.keys[0].pubkey,
                sourceStakePubKey: t.keys[1].pubkey,
                authorizedPubkey: t.keys[4].pubkey,
              }
            );
          }
          static decodeWithdraw(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 5);
            const { lamports: e } = ws(Wc.Withdraw, t.data),
              n = {
                stakePubkey: t.keys[0].pubkey,
                toPubkey: t.keys[1].pubkey,
                authorizedPubkey: t.keys[4].pubkey,
                lamports: e,
              };
            return (
              t.keys.length > 5 && (n.custodianPubkey = t.keys[5].pubkey), n
            );
          }
          static decodeDeactivate(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeyLength(t.keys, 3),
              ws(Wc.Deactivate, t.data),
              {
                stakePubkey: t.keys[0].pubkey,
                authorizedPubkey: t.keys[2].pubkey,
              }
            );
          }
          static checkProgramId(t) {
            if (!t.equals(jc.programId))
              throw new Error(
                "invalid instruction; programId is not StakeProgram"
              );
          }
          static checkKeyLength(t, e) {
            if (t.length < e)
              throw new Error(
                `invalid instruction; found ${t.length} keys, expected at least ${e}`
              );
          }
        },
        StakeProgram: jc,
        Struct: Ii,
        SystemInstruction: class {
          constructor() {}
          static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = hr.u32("instruction").decode(t.data);
            let n;
            for (const [r, o] of Object.entries(Es))
              if (o.index == e) {
                n = r;
                break;
              }
            if (!n)
              throw new Error(
                "Instruction type incorrect; not a SystemInstruction"
              );
            return n;
          }
          static decodeCreateAccount(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const {
              lamports: e,
              space: n,
              programId: r,
            } = ws(Es.Create, t.data);
            return {
              fromPubkey: t.keys[0].pubkey,
              newAccountPubkey: t.keys[1].pubkey,
              lamports: e,
              space: n,
              programId: new Ti(r),
            };
          }
          static decodeTransfer(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const { lamports: e } = ws(Es.Transfer, t.data);
            return {
              fromPubkey: t.keys[0].pubkey,
              toPubkey: t.keys[1].pubkey,
              lamports: e,
            };
          }
          static decodeTransferWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const {
              lamports: e,
              seed: n,
              programId: r,
            } = ws(Es.TransferWithSeed, t.data);
            return {
              fromPubkey: t.keys[0].pubkey,
              basePubkey: t.keys[1].pubkey,
              toPubkey: t.keys[2].pubkey,
              lamports: e,
              seed: n,
              programId: new Ti(r),
            };
          }
          static decodeAllocate(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
            const { space: e } = ws(Es.Allocate, t.data);
            return { accountPubkey: t.keys[0].pubkey, space: e };
          }
          static decodeAllocateWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
            const {
              base: e,
              seed: n,
              space: r,
              programId: o,
            } = ws(Es.AllocateWithSeed, t.data);
            return {
              accountPubkey: t.keys[0].pubkey,
              basePubkey: new Ti(e),
              seed: n,
              space: r,
              programId: new Ti(o),
            };
          }
          static decodeAssign(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
            const { programId: e } = ws(Es.Assign, t.data);
            return { accountPubkey: t.keys[0].pubkey, programId: new Ti(e) };
          }
          static decodeAssignWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
            const {
              base: e,
              seed: n,
              programId: r,
            } = ws(Es.AssignWithSeed, t.data);
            return {
              accountPubkey: t.keys[0].pubkey,
              basePubkey: new Ti(e),
              seed: n,
              programId: new Ti(r),
            };
          }
          static decodeCreateWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const {
              base: e,
              seed: n,
              lamports: r,
              space: o,
              programId: i,
            } = ws(Es.CreateWithSeed, t.data);
            return {
              fromPubkey: t.keys[0].pubkey,
              newAccountPubkey: t.keys[1].pubkey,
              basePubkey: new Ti(e),
              seed: n,
              lamports: r,
              space: o,
              programId: new Ti(i),
            };
          }
          static decodeNonceInitialize(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const { authorized: e } = ws(Es.InitializeNonceAccount, t.data);
            return {
              noncePubkey: t.keys[0].pubkey,
              authorizedPubkey: new Ti(e),
            };
          }
          static decodeNonceAdvance(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeyLength(t.keys, 3),
              ws(Es.AdvanceNonceAccount, t.data),
              {
                noncePubkey: t.keys[0].pubkey,
                authorizedPubkey: t.keys[2].pubkey,
              }
            );
          }
          static decodeNonceWithdraw(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 5);
            const { lamports: e } = ws(Es.WithdrawNonceAccount, t.data);
            return {
              noncePubkey: t.keys[0].pubkey,
              toPubkey: t.keys[1].pubkey,
              authorizedPubkey: t.keys[4].pubkey,
              lamports: e,
            };
          }
          static decodeNonceAuthorize(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const { authorized: e } = ws(Es.AuthorizeNonceAccount, t.data);
            return {
              noncePubkey: t.keys[0].pubkey,
              authorizedPubkey: t.keys[1].pubkey,
              newAuthorizedPubkey: new Ti(e),
            };
          }
          static checkProgramId(t) {
            if (!t.equals(Is.programId))
              throw new Error(
                "invalid instruction; programId is not SystemProgram"
              );
          }
          static checkKeyLength(t, e) {
            if (t.length < e)
              throw new Error(
                `invalid instruction; found ${t.length} keys, expected at least ${e}`
              );
          }
        },
        SystemProgram: Is,
        Transaction: es,
        TransactionExpiredBlockheightExceededError: Ni,
        TransactionExpiredNonceInvalidError: Li,
        TransactionExpiredTimeoutError: Pi,
        TransactionInstruction: ts,
        TransactionMessage: ns,
        TransactionStatus: $i,
        VALIDATOR_INFO_KEY: Zc,
        VERSION_PREFIX_MASK: Mi,
        VOTE_PROGRAM_ID: $c,
        ValidatorInfo: Xc,
        VersionedMessage: Xi,
        VersionedTransaction: rs,
        VoteAccount: tu,
        VoteAuthorizationLayout: Fc,
        VoteInit: Hc,
        VoteInstruction: class {
          constructor() {}
          static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = hr.u32("instruction").decode(t.data);
            let n;
            for (const [r, o] of Object.entries(Vc))
              if (o.index == e) {
                n = r;
                break;
              }
            if (!n)
              throw new Error(
                "Instruction type incorrect; not a VoteInstruction"
              );
            return n;
          }
          static decodeInitializeAccount(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 4);
            const { voteInit: e } = ws(Vc.InitializeAccount, t.data);
            return {
              votePubkey: t.keys[0].pubkey,
              nodePubkey: t.keys[3].pubkey,
              voteInit: new Hc(
                new Ti(e.nodePubkey),
                new Ti(e.authorizedVoter),
                new Ti(e.authorizedWithdrawer),
                e.commission
              ),
            };
          }
          static decodeAuthorize(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const { newAuthorized: e, voteAuthorizationType: n } = ws(
              Vc.Authorize,
              t.data
            );
            return {
              votePubkey: t.keys[0].pubkey,
              authorizedPubkey: t.keys[2].pubkey,
              newAuthorizedPubkey: new Ti(e),
              voteAuthorizationType: { index: n },
            };
          }
          static decodeAuthorizeWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const {
              voteAuthorizeWithSeedArgs: {
                currentAuthorityDerivedKeyOwnerPubkey: e,
                currentAuthorityDerivedKeySeed: n,
                newAuthorized: r,
                voteAuthorizationType: o,
              },
            } = ws(Vc.AuthorizeWithSeed, t.data);
            return {
              currentAuthorityDerivedKeyBasePubkey: t.keys[2].pubkey,
              currentAuthorityDerivedKeyOwnerPubkey: new Ti(e),
              currentAuthorityDerivedKeySeed: n,
              newAuthorizedPubkey: new Ti(r),
              voteAuthorizationType: { index: o },
              votePubkey: t.keys[0].pubkey,
            };
          }
          static decodeWithdraw(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const { lamports: e } = ws(Vc.Withdraw, t.data);
            return {
              votePubkey: t.keys[0].pubkey,
              authorizedWithdrawerPubkey: t.keys[2].pubkey,
              lamports: e,
              toPubkey: t.keys[1].pubkey,
            };
          }
          static checkProgramId(t) {
            if (!t.equals(Yc.programId))
              throw new Error(
                "invalid instruction; programId is not VoteProgram"
              );
          }
          static checkKeyLength(t, e) {
            if (t.length < e)
              throw new Error(
                `invalid instruction; found ${t.length} keys, expected at least ${e}`
              );
          }
        },
        VoteProgram: Yc,
        clusterApiUrl: function (t, e) {
          const n = !1 === e ? "http" : "https";
          if (!t) return ou[n].devnet;
          const r = ou[n][t];
          if (!r) throw new Error(`Unknown ${n} cluster: ${t}`);
          return r;
        },
        sendAndConfirmRawTransaction: async function (t, e, n, r) {
          let o, i;
          (n &&
            Object.prototype.hasOwnProperty.call(n, "lastValidBlockHeight")) ||
          (n && Object.prototype.hasOwnProperty.call(n, "nonceValue"))
            ? ((o = n), (i = r))
            : (i = n);
          const s = i && {
              skipPreflight: i.skipPreflight,
              preflightCommitment: i.preflightCommitment || i.commitment,
              minContextSlot: i.minContextSlot,
            },
            a = await t.sendRawTransaction(e, s),
            c = i && i.commitment,
            u = o ? t.confirmTransaction(o, c) : t.confirmTransaction(a, c),
            l = (await u).value;
          if (l.err) {
            if (null != a)
              throw new fs({
                action: (null == s ? void 0 : s.skipPreflight)
                  ? "send"
                  : "simulate",
                signature: a,
                transactionMessage: `Status: (${JSON.stringify(l)})`,
              });
            throw new Error(
              `Raw transaction ${a} failed (${JSON.stringify(l)})`
            );
          }
          return a;
        },
        sendAndConfirmTransaction: ms,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const su = new Ti("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
    au = new Ti("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
    cu = new Ti("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
    uu = new Ti("So11111111111111111111111111111111111111112");
  new Ti("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
  const lu = (t) => ({ decode: t.decode.bind(t), encode: t.encode.bind(t) });
  var hu,
    du = {};
  var fu =
    (hu ||
      ((hu = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      }),
      Object.defineProperty(du, "__esModule", { value: !0 }),
      (du.toBigIntLE = function (t) {
        {
          const e = J.from(t);
          e.reverse();
          const n = e.toString("hex");
          return 0 === n.length ? BigInt(0) : BigInt(`0x${n}`);
        }
      }),
      (du.toBigIntBE = function (t) {
        {
          const e = t.toString("hex");
          return 0 === e.length ? BigInt(0) : BigInt(`0x${e}`);
        }
      }),
      (du.toBufferLE = function (t, e) {
        {
          const n = t.toString(16),
            r = J.from(n.padStart(2 * e, "0").slice(0, 2 * e), "hex");
          return r.reverse(), r;
        }
      }),
      (du.toBufferBE = function (t, e) {
        {
          const n = t.toString(16);
          return J.from(n.padStart(2 * e, "0").slice(0, 2 * e), "hex");
        }
      })),
    du);
  const pu =
    ((mu = 8),
    (t) => {
      const e = hr.blob(mu, t),
        { encode: n, decode: r } = lu(e),
        o = e;
      return (
        (o.decode = (t, e) => {
          const n = r(t, e);
          return fu.toBigIntLE(J.from(n));
        }),
        (o.encode = (t, e, r) => {
          const o = fu.toBufferLE(t, mu);
          return n(o, e, r);
        }),
        o
      );
    });
  var mu;
  const yu = (t) => {
      const e = hr.u8(t),
        { encode: n, decode: r } = lu(e),
        o = e;
      return (
        (o.decode = (t, e) => !!r(t, e)),
        (o.encode = (t, e, r) => {
          const o = Number(t);
          return n(o, e, r);
        }),
        o
      );
    },
    gu = (t) => {
      const e = hr.blob(32, t),
        { encode: n, decode: r } = lu(e),
        o = e;
      return (
        (o.decode = (t, e) => {
          const n = r(t, e);
          return new Ti(n);
        }),
        (o.encode = (t, e, r) => {
          const o = t.toBuffer();
          return n(o, e, r);
        }),
        o
      );
    };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  class wu extends Error {
    constructor(t) {
      super(t);
    }
  }
  class bu extends wu {
    constructor() {
      super(...arguments), (this.name = "TokenAccountNotFoundError");
    }
  }
  class vu extends wu {
    constructor() {
      super(...arguments), (this.name = "TokenInvalidAccountError");
    }
  }
  class _u extends wu {
    constructor() {
      super(...arguments), (this.name = "TokenInvalidAccountOwnerError");
    }
  }
  class ku extends wu {
    constructor() {
      super(...arguments), (this.name = "TokenInvalidAccountSizeError");
    }
  }
  class Au extends wu {
    constructor() {
      super(...arguments), (this.name = "TokenOwnerOffCurveError");
    }
  }
  var Eu, Iu, Cu, Su;
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    ((Iu = Eu || (Eu = {}))[(Iu.InitializeMint = 0)] = "InitializeMint"),
    (Iu[(Iu.InitializeAccount = 1)] = "InitializeAccount"),
    (Iu[(Iu.InitializeMultisig = 2)] = "InitializeMultisig"),
    (Iu[(Iu.Transfer = 3)] = "Transfer"),
    (Iu[(Iu.Approve = 4)] = "Approve"),
    (Iu[(Iu.Revoke = 5)] = "Revoke"),
    (Iu[(Iu.SetAuthority = 6)] = "SetAuthority"),
    (Iu[(Iu.MintTo = 7)] = "MintTo"),
    (Iu[(Iu.Burn = 8)] = "Burn"),
    (Iu[(Iu.CloseAccount = 9)] = "CloseAccount"),
    (Iu[(Iu.FreezeAccount = 10)] = "FreezeAccount"),
    (Iu[(Iu.ThawAccount = 11)] = "ThawAccount"),
    (Iu[(Iu.TransferChecked = 12)] = "TransferChecked"),
    (Iu[(Iu.ApproveChecked = 13)] = "ApproveChecked"),
    (Iu[(Iu.MintToChecked = 14)] = "MintToChecked"),
    (Iu[(Iu.BurnChecked = 15)] = "BurnChecked"),
    (Iu[(Iu.InitializeAccount2 = 16)] = "InitializeAccount2"),
    (Iu[(Iu.SyncNative = 17)] = "SyncNative"),
    (Iu[(Iu.InitializeAccount3 = 18)] = "InitializeAccount3"),
    (Iu[(Iu.InitializeMultisig2 = 19)] = "InitializeMultisig2"),
    (Iu[(Iu.InitializeMint2 = 20)] = "InitializeMint2"),
    (Iu[(Iu.GetAccountDataSize = 21)] = "GetAccountDataSize"),
    (Iu[(Iu.InitializeImmutableOwner = 22)] = "InitializeImmutableOwner"),
    (Iu[(Iu.AmountToUiAmount = 23)] = "AmountToUiAmount"),
    (Iu[(Iu.UiAmountToAmount = 24)] = "UiAmountToAmount"),
    (Iu[(Iu.InitializeMintCloseAuthority = 25)] =
      "InitializeMintCloseAuthority"),
    (Iu[(Iu.TransferFeeExtension = 26)] = "TransferFeeExtension"),
    (Iu[(Iu.ConfidentialTransferExtension = 27)] =
      "ConfidentialTransferExtension"),
    (Iu[(Iu.DefaultAccountStateExtension = 28)] =
      "DefaultAccountStateExtension"),
    (Iu[(Iu.Reallocate = 29)] = "Reallocate"),
    (Iu[(Iu.MemoTransferExtension = 30)] = "MemoTransferExtension"),
    (Iu[(Iu.CreateNativeMint = 31)] = "CreateNativeMint"),
    (Iu[(Iu.InitializeNonTransferableMint = 32)] =
      "InitializeNonTransferableMint"),
    (Iu[(Iu.InterestBearingMintExtension = 33)] =
      "InterestBearingMintExtension"),
    (Iu[(Iu.CpiGuardExtension = 34)] = "CpiGuardExtension"),
    (Iu[(Iu.InitializePermanentDelegate = 35)] = "InitializePermanentDelegate"),
    (Iu[(Iu.TransferHookExtension = 36)] = "TransferHookExtension"),
    (Iu[(Iu.MetadataPointerExtension = 39)] = "MetadataPointerExtension"),
    (Iu[(Iu.GroupPointerExtension = 40)] = "GroupPointerExtension"),
    (Iu[(Iu.GroupMemberPointerExtension = 41)] = "GroupMemberPointerExtension"),
    (Iu[(Iu.ScaledUiAmountExtension = 43)] = "ScaledUiAmountExtension"),
    (Iu[(Iu.PausableExtension = 44)] = "PausableExtension"),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    ((Su = Cu || (Cu = {}))[(Su.Uninitialized = 0)] = "Uninitialized"),
    (Su[(Su.Mint = 1)] = "Mint"),
    (Su[(Su.Account = 2)] = "Account");
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Bu = hr.struct([
    hr.u8("m"),
    hr.u8("n"),
    yu("isInitialized"),
    gu("signer1"),
    gu("signer2"),
    gu("signer3"),
    gu("signer4"),
    gu("signer5"),
    gu("signer6"),
    gu("signer7"),
    gu("signer8"),
    gu("signer9"),
    gu("signer10"),
    gu("signer11"),
  ]).span;
  var xu, Tu;
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    ((Tu = xu || (xu = {}))[(Tu.Uninitialized = 0)] = "Uninitialized"),
    (Tu[(Tu.Initialized = 1)] = "Initialized"),
    (Tu[(Tu.Frozen = 2)] = "Frozen");
  const Ru = hr.struct([
      gu("mint"),
      gu("owner"),
      pu("amount"),
      hr.u32("delegateOption"),
      gu("delegate"),
      hr.u8("state"),
      hr.u32("isNativeOption"),
      pu("isNative"),
      pu("delegatedAmount"),
      hr.u32("closeAuthorityOption"),
      gu("closeAuthority"),
    ]),
    Ou = Ru.span;
  async function Mu(t, e, n, r = su) {
    return (function (t, e, n = su) {
      if (!e) throw new bu();
      if (!e.owner.equals(n)) throw new _u();
      if (e.data.length < Ou) throw new ku();
      const r = Ru.decode(e.data.slice(0, Ou));
      let o = J.alloc(0);
      if (e.data.length > Ou) {
        if (e.data.length === Bu) throw new ku();
        if (e.data[Ou] != Cu.Account) throw new vu();
        o = e.data.slice(Ou + 1);
      }
      return {
        address: t,
        mint: r.mint,
        owner: r.owner,
        amount: r.amount,
        delegate: r.delegateOption ? r.delegate : null,
        delegatedAmount: r.delegatedAmount,
        isInitialized: r.state !== xu.Uninitialized,
        isFrozen: r.state === xu.Frozen,
        isNative: !!r.isNativeOption,
        rentExemptReserve: r.isNativeOption ? r.isNative : null,
        closeAuthority: r.closeAuthorityOption ? r.closeAuthority : null,
        tlvData: o,
      };
    })(e, await t.getAccountInfo(e, n), r);
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  function Nu(t, e, n = !1, r = su, o = cu) {
    if (!n && !Ti.isOnCurve(e.toBuffer())) throw new Au();
    const [i] = Ti.findProgramAddressSync(
      [e.toBuffer(), r.toBuffer(), t.toBuffer()],
      o
    );
    return i;
  }
  hr.struct([
    hr.u32("mintAuthorityOption"),
    gu("mintAuthority"),
    pu("supply"),
    hr.u8("decimals"),
    yu("isInitialized"),
    hr.u32("freezeAuthorityOption"),
    gu("freezeAuthority"),
  ]).span,
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const Pu = hr.struct([hr.u8("instruction")]);
  function Lu(t, e, n, r = [], o = su) {
    const i = (function (t, e, n) {
        if (n.length) {
          t.push({ pubkey: e, isSigner: !1, isWritable: !1 });
          for (const e of n)
            t.push({
              pubkey: e instanceof Ti ? e : e.publicKey,
              isSigner: !0,
              isWritable: !1,
            });
        } else t.push({ pubkey: e, isSigner: !0, isWritable: !1 });
        return t;
      })(
        [
          { pubkey: t, isSigner: !1, isWritable: !0 },
          { pubkey: e, isSigner: !1, isWritable: !0 },
        ],
        n,
        r
      ),
      s = J.alloc(Pu.span);
    return (
      Pu.encode({ instruction: Eu.CloseAccount }, s),
      new ts({ keys: i, programId: o, data: s })
    );
  }
  function zu(t, e, n, r, o = su, i = cu) {
    return (function (t, e, n, r, o, i = su, s = cu) {
      const a = [
        { pubkey: t, isSigner: !0, isWritable: !0 },
        { pubkey: e, isSigner: !1, isWritable: !0 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !1 },
        { pubkey: Is.programId, isSigner: !1, isWritable: !1 },
        { pubkey: i, isSigner: !1, isWritable: !1 },
      ];
      return new ts({ keys: a, programId: s, data: o });
    })(t, e, n, r, J.from([1]), o, i);
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const Du = hr.struct([hr.u8("instruction")]);
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Uu = globalThis || self;
  var qu, Gu, Wu, Ku;
  var ju = (function () {
    if (Ku) return Wu;
    (Ku = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      });
    var t = (function () {
      if (Gu) return qu;
      (Gu = 1),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        });
      var t = qn().Buffer;
      return (
        (qu = function (e) {
          if (e.length >= 255) throw new TypeError("Alphabet too long");
          for (var n = new Uint8Array(256), r = 0; r < n.length; r++)
            n[r] = 255;
          for (var o = 0; o < e.length; o++) {
            var i = e.charAt(o),
              s = i.charCodeAt(0);
            if (255 !== n[s]) throw new TypeError(i + " is ambiguous");
            n[s] = o;
          }
          var a = e.length,
            c = e.charAt(0),
            u = Math.log(a) / Math.log(256),
            l = Math.log(256) / Math.log(a);
          function h(e) {
            if ("string" != typeof e) throw new TypeError("Expected String");
            if (0 === e.length) return t.alloc(0);
            for (var r = 0, o = 0, i = 0; e[r] === c; ) o++, r++;
            for (
              var s = ((e.length - r) * u + 1) >>> 0, l = new Uint8Array(s);
              r < e.length;

            ) {
              var h = e.charCodeAt(r);
              if (h > 255) return;
              var d = n[h];
              if (255 === d) return;
              for (
                var f = 0, p = s - 1;
                (0 !== d || f < i) && -1 !== p;
                p--, f++
              )
                (d += (a * l[p]) >>> 0),
                  (l[p] = d % 256 >>> 0),
                  (d = (d / 256) >>> 0);
              if (0 !== d) throw new Error("Non-zero carry");
              (i = f), r++;
            }
            for (var m = s - i; m !== s && 0 === l[m]; ) m++;
            var y = t.allocUnsafe(o + (s - m));
            y.fill(0, 0, o);
            for (var g = o; m !== s; ) y[g++] = l[m++];
            return y;
          }
          return {
            encode: function (n) {
              if (
                ((Array.isArray(n) || n instanceof Uint8Array) &&
                  (n = t.from(n)),
                !t.isBuffer(n))
              )
                throw new TypeError("Expected Buffer");
              if (0 === n.length) return "";
              for (
                var r = 0, o = 0, i = 0, s = n.length;
                i !== s && 0 === n[i];

              )
                i++, r++;
              for (
                var u = ((s - i) * l + 1) >>> 0, h = new Uint8Array(u);
                i !== s;

              ) {
                for (
                  var d = n[i], f = 0, p = u - 1;
                  (0 !== d || f < o) && -1 !== p;
                  p--, f++
                )
                  (d += (256 * h[p]) >>> 0),
                    (h[p] = d % a >>> 0),
                    (d = (d / a) >>> 0);
                if (0 !== d) throw new Error("Non-zero carry");
                (o = f), i++;
              }
              for (var m = u - o; m !== u && 0 === h[m]; ) m++;
              for (var y = c.repeat(r); m < u; ++m) y += e.charAt(h[m]);
              return y;
            },
            decodeUnsafe: h,
            decode: function (t) {
              var e = h(t);
              if (e) return e;
              throw new Error("Non-base" + a + " character");
            },
          };
        }),
        qu
      );
    })();
    return (Wu = t(
      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    ));
  })();
  const Hu = An(ju);
  var Vu,
    Fu = { exports: {} };
  const Yu = An(
    (function () {
      if (Vu) return Fu.exports;
      (Vu = 1),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        });
      const t = /[\p{Lu}]/u,
        e = /[\p{Ll}]/u,
        n = /^[\p{Lu}](?![\p{Lu}])/gu,
        r = /([\p{Alpha}\p{N}_]|$)/u,
        o = /[_.\- ]+/,
        i = new RegExp("^" + o.source),
        s = new RegExp(o.source + r.source, "gu"),
        a = new RegExp("\\d+" + r.source, "gu"),
        c = (r, o) => {
          if ("string" != typeof r && !Array.isArray(r))
            throw new TypeError("Expected the input to be `string | string[]`");
          if (
            ((o = { pascalCase: !1, preserveConsecutiveUppercase: !1, ...o }),
            0 ===
              (r = Array.isArray(r)
                ? r
                    .map((t) => t.trim())
                    .filter((t) => t.length)
                    .join("-")
                : r.trim()).length)
          )
            return "";
          const c =
              !1 === o.locale
                ? (t) => t.toLowerCase()
                : (t) => t.toLocaleLowerCase(o.locale),
            u =
              !1 === o.locale
                ? (t) => t.toUpperCase()
                : (t) => t.toLocaleUpperCase(o.locale);
          if (1 === r.length) return o.pascalCase ? u(r) : c(r);
          return (
            r !== c(r) &&
              (r = ((n, r, o) => {
                let i = !1,
                  s = !1,
                  a = !1;
                for (let c = 0; c < n.length; c++) {
                  const u = n[c];
                  i && t.test(u)
                    ? ((n = n.slice(0, c) + "-" + n.slice(c)),
                      (i = !1),
                      (a = s),
                      (s = !0),
                      c++)
                    : s && a && e.test(u)
                    ? ((n = n.slice(0, c - 1) + "-" + n.slice(c - 1)),
                      (a = s),
                      (s = !1),
                      (i = !0))
                    : ((i = r(u) === u && o(u) !== u),
                      (a = s),
                      (s = o(u) === u && r(u) !== u));
                }
                return n;
              })(r, c, u)),
            (r = r.replace(i, "")),
            (r = o.preserveConsecutiveUppercase
              ? ((t, e) => ((n.lastIndex = 0), t.replace(n, (t) => e(t))))(r, c)
              : c(r)),
            o.pascalCase && (r = u(r.charAt(0)) + r.slice(1)),
            ((t, e) => (
              (s.lastIndex = 0),
              (a.lastIndex = 0),
              t.replace(s, (t, n) => e(n)).replace(a, (t) => e(t))
            ))(r, u)
          );
        };
      return (Fu.exports = c), (Fu.exports.default = c), Fu.exports;
    })()
  );
  var Zu,
    Ju = {},
    Xu = {};
  function $u() {
    if (Zu) return Xu;
    (Zu = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      });
    class t {
      constructor(t, e) {
        if (!Number.isInteger(t))
          throw new TypeError("span must be an integer");
        (this.span = t), (this.property = e);
      }
      makeDestinationObject() {
        return {};
      }
      decode(t, e) {
        throw new Error("Layout is abstract");
      }
      encode(t, e, n) {
        throw new Error("Layout is abstract");
      }
      getSpan(t, e) {
        if (0 > this.span) throw new RangeError("indeterminate span");
        return this.span;
      }
      replicate(t) {
        const e = Object.create(this.constructor.prototype);
        return Object.assign(e, this), (e.property = t), e;
      }
      fromArray(t) {}
    }
    function e(t, e) {
      return e.property ? t + "[" + e.property + "]" : t;
    }
    (Xu.Layout = t),
      (Xu.nameWithProperty = e),
      (Xu.bindConstructorLayout = function (e, n) {
        if ("function" != typeof e)
          throw new TypeError("Class must be constructor");
        if (e.hasOwnProperty("layout_"))
          throw new Error("Class is already bound to a layout");
        if (!(n && n instanceof t))
          throw new TypeError("layout must be a Layout");
        if (n.hasOwnProperty("boundConstructor_"))
          throw new Error("layout is already bound to a constructor");
        (e.layout_ = n),
          (n.boundConstructor_ = e),
          (n.makeDestinationObject = () => new e()),
          Object.defineProperty(e.prototype, "encode", {
            value: function (t, e) {
              return n.encode(this, t, e);
            },
            writable: !0,
          }),
          Object.defineProperty(e, "decode", {
            value: function (t, e) {
              return n.decode(t, e);
            },
            writable: !0,
          });
      });
    class n extends t {
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    }
    class r extends n {
      constructor(t, e) {
        if ((void 0 === t && (t = 1), !Number.isInteger(t) || 0 >= t))
          throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, e), (this.elementSpan = t);
      }
      isCount() {
        return !0;
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        const n = t.length - e;
        return Math.floor(n / this.elementSpan);
      }
      encode(t, e, n) {
        return 0;
      }
    }
    class o extends n {
      constructor(e, n, r) {
        if (!(e instanceof t)) throw new TypeError("layout must be a Layout");
        if (void 0 === n) n = 0;
        else if (!Number.isInteger(n))
          throw new TypeError("offset must be integer or undefined");
        super(e.span, r || e.property), (this.layout = e), (this.offset = n);
      }
      isCount() {
        return this.layout instanceof i || this.layout instanceof s;
      }
      decode(t, e) {
        return void 0 === e && (e = 0), this.layout.decode(t, e + this.offset);
      }
      encode(t, e, n) {
        return (
          void 0 === n && (n = 0), this.layout.encode(t, e, n + this.offset)
        );
      }
    }
    class i extends t {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readUIntLE(e, this.span);
      }
      encode(t, e, n) {
        return (
          void 0 === n && (n = 0), e.writeUIntLE(t, n, this.span), this.span
        );
      }
    }
    class s extends t {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readUIntBE(e, this.span);
      }
      encode(t, e, n) {
        return (
          void 0 === n && (n = 0), e.writeUIntBE(t, n, this.span), this.span
        );
      }
    }
    class a extends t {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readIntLE(e, this.span);
      }
      encode(t, e, n) {
        return (
          void 0 === n && (n = 0), e.writeIntLE(t, n, this.span), this.span
        );
      }
    }
    class c extends t {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readIntBE(e, this.span);
      }
      encode(t, e, n) {
        return (
          void 0 === n && (n = 0), e.writeIntBE(t, n, this.span), this.span
        );
      }
    }
    const u = Math.pow(2, 32);
    function l(t) {
      const e = Math.floor(t / u);
      return { hi32: e, lo32: t - e * u };
    }
    function h(t, e) {
      return t * u + e;
    }
    class d extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        const n = t.readUInt32LE(e);
        return h(t.readUInt32LE(e + 4), n);
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = l(t);
        return e.writeUInt32LE(r.lo32, n), e.writeUInt32LE(r.hi32, n + 4), 8;
      }
    }
    class f extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        return h(t.readUInt32BE(e), t.readUInt32BE(e + 4));
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = l(t);
        return e.writeUInt32BE(r.hi32, n), e.writeUInt32BE(r.lo32, n + 4), 8;
      }
    }
    class p extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        const n = t.readUInt32LE(e);
        return h(t.readInt32LE(e + 4), n);
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = l(t);
        return e.writeUInt32LE(r.lo32, n), e.writeInt32LE(r.hi32, n + 4), 8;
      }
    }
    class m extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        return h(t.readInt32BE(e), t.readUInt32BE(e + 4));
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = l(t);
        return e.writeInt32BE(r.hi32, n), e.writeUInt32BE(r.lo32, n + 4), 8;
      }
    }
    class y extends t {
      constructor(t) {
        super(4, t);
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readFloatLE(e);
      }
      encode(t, e, n) {
        return void 0 === n && (n = 0), e.writeFloatLE(t, n), 4;
      }
    }
    class g extends t {
      constructor(t) {
        super(4, t);
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readFloatBE(e);
      }
      encode(t, e, n) {
        return void 0 === n && (n = 0), e.writeFloatBE(t, n), 4;
      }
    }
    class w extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readDoubleLE(e);
      }
      encode(t, e, n) {
        return void 0 === n && (n = 0), e.writeDoubleLE(t, n), 8;
      }
    }
    class b extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readDoubleBE(e);
      }
      encode(t, e, n) {
        return void 0 === n && (n = 0), e.writeDoubleBE(t, n), 8;
      }
    }
    class v extends t {
      constructor(e, r, o) {
        if (!(e instanceof t))
          throw new TypeError("elementLayout must be a Layout");
        if (
          !((r instanceof n && r.isCount()) || (Number.isInteger(r) && 0 <= r))
        )
          throw new TypeError(
            "count must be non-negative integer or an unsigned integer ExternalLayout"
          );
        let i = -1;
        !(r instanceof n) && 0 < e.span && (i = r * e.span),
          super(i, o),
          (this.elementLayout = e),
          (this.count = r);
      }
      getSpan(t, e) {
        if (0 <= this.span) return this.span;
        void 0 === e && (e = 0);
        let r = 0,
          o = this.count;
        if (
          (o instanceof n && (o = o.decode(t, e)), 0 < this.elementLayout.span)
        )
          r = o * this.elementLayout.span;
        else {
          let n = 0;
          for (; n < o; ) (r += this.elementLayout.getSpan(t, e + r)), ++n;
        }
        return r;
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        const r = [];
        let o = 0,
          i = this.count;
        for (i instanceof n && (i = i.decode(t, e)); o < i; )
          r.push(this.elementLayout.decode(t, e)),
            (e += this.elementLayout.getSpan(t, e)),
            (o += 1);
        return r;
      }
      encode(t, e, r) {
        void 0 === r && (r = 0);
        const o = this.elementLayout,
          i = t.reduce((t, n) => t + o.encode(n, e, r + t), 0);
        return this.count instanceof n && this.count.encode(t.length, e, r), i;
      }
    }
    class _ extends t {
      constructor(e, n, r) {
        if (!Array.isArray(e) || !e.reduce((e, n) => e && n instanceof t, !0))
          throw new TypeError("fields must be array of Layout instances");
        "boolean" == typeof n && void 0 === r && ((r = n), (n = void 0));
        for (const t of e)
          if (0 > t.span && void 0 === t.property)
            throw new Error(
              "fields cannot contain unnamed variable-length layout"
            );
        let o = -1;
        try {
          o = e.reduce((t, e) => t + e.getSpan(), 0);
        } catch (i) {}
        super(o, n), (this.fields = e), (this.decodePrefixes = !!r);
      }
      getSpan(t, e) {
        if (0 <= this.span) return this.span;
        void 0 === e && (e = 0);
        let n = 0;
        try {
          n = this.fields.reduce((n, r) => {
            const o = r.getSpan(t, e);
            return (e += o), n + o;
          }, 0);
        } catch (r) {
          throw new RangeError("indeterminate span");
        }
        return n;
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        const n = this.makeDestinationObject();
        for (const r of this.fields)
          if (
            (void 0 !== r.property && (n[r.property] = r.decode(t, e)),
            (e += r.getSpan(t, e)),
            this.decodePrefixes && t.length === e)
          )
            break;
        return n;
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = n;
        let o = 0,
          i = 0;
        for (const s of this.fields) {
          let r = s.span;
          if (((i = 0 < r ? r : 0), void 0 !== s.property)) {
            const o = t[s.property];
            void 0 !== o &&
              ((i = s.encode(o, e, n)), 0 > r && (r = s.getSpan(e, n)));
          }
          (o = n), (n += r);
        }
        return o + i - r;
      }
      fromArray(t) {
        const e = this.makeDestinationObject();
        for (const n of this.fields)
          void 0 !== n.property && 0 < t.length && (e[n.property] = t.shift());
        return e;
      }
      layoutFor(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        for (const e of this.fields) if (e.property === t) return e;
      }
      offsetOf(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        let e = 0;
        for (const n of this.fields) {
          if (n.property === t) return e;
          0 > n.span ? (e = -1) : 0 <= e && (e += n.span);
        }
      }
    }
    class k {
      constructor(t) {
        this.property = t;
      }
      decode() {
        throw new Error("UnionDiscriminator is abstract");
      }
      encode() {
        throw new Error("UnionDiscriminator is abstract");
      }
    }
    class A extends k {
      constructor(t, e) {
        if (!(t instanceof n && t.isCount()))
          throw new TypeError(
            "layout must be an unsigned integer ExternalLayout"
          );
        super(e || t.property || "variant"), (this.layout = t);
      }
      decode(t, e) {
        return this.layout.decode(t, e);
      }
      encode(t, e, n) {
        return this.layout.encode(t, e, n);
      }
    }
    class E extends t {
      constructor(e, r, a) {
        const c = e instanceof i || e instanceof s;
        if (c) e = new A(new o(e));
        else if (e instanceof n && e.isCount()) e = new A(e);
        else if (!(e instanceof k))
          throw new TypeError(
            "discr must be a UnionDiscriminator or an unsigned integer layout"
          );
        if ((void 0 === r && (r = null), !(null === r || r instanceof t)))
          throw new TypeError("defaultLayout must be null or a Layout");
        if (null !== r) {
          if (0 > r.span)
            throw new Error("defaultLayout must have constant span");
          void 0 === r.property && (r = r.replicate("content"));
        }
        let u = -1;
        r && ((u = r.span), 0 <= u && c && (u += e.layout.span)),
          super(u, a),
          (this.discriminator = e),
          (this.usesPrefixDiscriminator = c),
          (this.defaultLayout = r),
          (this.registry = {});
        let l = this.defaultGetSourceVariant.bind(this);
        (this.getSourceVariant = function (t) {
          return l(t);
        }),
          (this.configGetSourceVariant = function (t) {
            l = t.bind(this);
          });
      }
      getSpan(t, e) {
        if (0 <= this.span) return this.span;
        void 0 === e && (e = 0);
        const n = this.getVariant(t, e);
        if (!n)
          throw new Error("unable to determine span for unrecognized variant");
        return n.getSpan(t, e);
      }
      defaultGetSourceVariant(t) {
        if (t.hasOwnProperty(this.discriminator.property)) {
          if (
            this.defaultLayout &&
            t.hasOwnProperty(this.defaultLayout.property)
          )
            return;
          const e = this.registry[t[this.discriminator.property]];
          if (e && (!e.layout || t.hasOwnProperty(e.property))) return e;
        } else
          for (const e in this.registry) {
            const n = this.registry[e];
            if (t.hasOwnProperty(n.property)) return n;
          }
        throw new Error("unable to infer src variant");
      }
      decode(t, e) {
        let n;
        void 0 === e && (e = 0);
        const r = this.discriminator,
          o = r.decode(t, e);
        let i = this.registry[o];
        if (void 0 === i) {
          let s = 0;
          (i = this.defaultLayout),
            this.usesPrefixDiscriminator && (s = r.layout.span),
            (n = this.makeDestinationObject()),
            (n[r.property] = o),
            (n[i.property] = this.defaultLayout.decode(t, e + s));
        } else n = i.decode(t, e);
        return n;
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = this.getSourceVariant(t);
        if (void 0 === r) {
          const r = this.discriminator,
            o = this.defaultLayout;
          let i = 0;
          return (
            this.usesPrefixDiscriminator && (i = r.layout.span),
            r.encode(t[r.property], e, n),
            i + o.encode(t[o.property], e, n + i)
          );
        }
        return r.encode(t, e, n);
      }
      addVariant(t, e, n) {
        const r = new I(this, t, e, n);
        return (this.registry[t] = r), r;
      }
      getVariant(t, e) {
        let n = t;
        return (
          J.isBuffer(t) &&
            (void 0 === e && (e = 0), (n = this.discriminator.decode(t, e))),
          this.registry[n]
        );
      }
    }
    class I extends t {
      constructor(e, n, r, o) {
        if (!(e instanceof E)) throw new TypeError("union must be a Union");
        if (!Number.isInteger(n) || 0 > n)
          throw new TypeError("variant must be a (non-negative) integer");
        if (
          ("string" == typeof r && void 0 === o && ((o = r), (r = null)), r)
        ) {
          if (!(r instanceof t)) throw new TypeError("layout must be a Layout");
          if (
            null !== e.defaultLayout &&
            0 <= r.span &&
            r.span > e.defaultLayout.span
          )
            throw new Error("variant span exceeds span of containing union");
          if ("string" != typeof o)
            throw new TypeError("variant must have a String property");
        }
        let i = e.span;
        0 > e.span &&
          ((i = r ? r.span : 0),
          0 <= i &&
            e.usesPrefixDiscriminator &&
            (i += e.discriminator.layout.span)),
          super(i, o),
          (this.union = e),
          (this.variant = n),
          (this.layout = r || null);
      }
      getSpan(t, e) {
        if (0 <= this.span) return this.span;
        void 0 === e && (e = 0);
        let n = 0;
        return (
          this.union.usesPrefixDiscriminator &&
            (n = this.union.discriminator.layout.span),
          n + this.layout.getSpan(t, e + n)
        );
      }
      decode(t, e) {
        const n = this.makeDestinationObject();
        if ((void 0 === e && (e = 0), this !== this.union.getVariant(t, e)))
          throw new Error("variant mismatch");
        let r = 0;
        return (
          this.union.usesPrefixDiscriminator &&
            (r = this.union.discriminator.layout.span),
          this.layout
            ? (n[this.property] = this.layout.decode(t, e + r))
            : this.property
            ? (n[this.property] = !0)
            : this.union.usesPrefixDiscriminator &&
              (n[this.union.discriminator.property] = this.variant),
          n
        );
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        let r = 0;
        if (
          (this.union.usesPrefixDiscriminator &&
            (r = this.union.discriminator.layout.span),
          this.layout && !t.hasOwnProperty(this.property))
        )
          throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, e, n);
        let o = r;
        if (
          this.layout &&
          (this.layout.encode(t[this.property], e, n + r),
          (o += this.layout.getSpan(e, n + r)),
          0 <= this.union.span && o > this.union.span)
        )
          throw new Error("encoded variant overruns containing union");
        return o;
      }
      fromArray(t) {
        if (this.layout) return this.layout.fromArray(t);
      }
    }
    function C(t) {
      return 0 > t && (t += 4294967296), t;
    }
    class S extends t {
      constructor(t, e, n) {
        if (!(t instanceof i || t instanceof s))
          throw new TypeError("word must be a UInt or UIntBE layout");
        if (
          ("string" == typeof e && void 0 === n && ((n = e), (e = void 0)),
          4 < t.span)
        )
          throw new RangeError("word cannot exceed 32 bits");
        super(t.span, n), (this.word = t), (this.msb = !!e), (this.fields = []);
        let r = 0;
        (this._packedSetValue = function (t) {
          return (r = C(t)), this;
        }),
          (this._packedGetValue = function () {
            return r;
          });
      }
      decode(t, e) {
        const n = this.makeDestinationObject();
        void 0 === e && (e = 0);
        const r = this.word.decode(t, e);
        this._packedSetValue(r);
        for (const o of this.fields)
          void 0 !== o.property && (n[o.property] = o.decode(r));
        return n;
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = this.word.decode(e, n);
        this._packedSetValue(r);
        for (const o of this.fields)
          if (void 0 !== o.property) {
            const e = t[o.property];
            void 0 !== e && o.encode(e);
          }
        return this.word.encode(this._packedGetValue(), e, n);
      }
      addField(t, e) {
        const n = new B(this, t, e);
        return this.fields.push(n), n;
      }
      addBoolean(t) {
        const e = new x(this, t);
        return this.fields.push(e), e;
      }
      fieldFor(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        for (const e of this.fields) if (e.property === t) return e;
      }
    }
    class B {
      constructor(t, e, n) {
        if (!(t instanceof S))
          throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(e) || 0 >= e)
          throw new TypeError("bits must be positive integer");
        const r = 8 * t.span,
          o = t.fields.reduce((t, e) => t + e.bits, 0);
        if (e + o > r)
          throw new Error(
            "bits too long for span remainder (" +
              (r - o) +
              " of " +
              r +
              " remain)"
          );
        (this.container = t),
          (this.bits = e),
          (this.valueMask = (1 << e) - 1),
          32 === e && (this.valueMask = 4294967295),
          (this.start = o),
          this.container.msb && (this.start = r - o - e),
          (this.wordMask = C(this.valueMask << this.start)),
          (this.property = n);
      }
      decode() {
        return (
          C(this.container._packedGetValue() & this.wordMask) >>> this.start
        );
      }
      encode(t) {
        if (!Number.isInteger(t) || t !== C(t & this.valueMask))
          throw new TypeError(
            e("BitField.encode", this) +
              " value must be integer not exceeding " +
              this.valueMask
          );
        const n = this.container._packedGetValue(),
          r = C(t << this.start);
        this.container._packedSetValue(C(n & ~this.wordMask) | r);
      }
    }
    class x extends B {
      constructor(t, e) {
        super(t, 1, e);
      }
      decode(t, e) {
        return !!B.prototype.decode.call(this, t, e);
      }
      encode(t) {
        return (
          "boolean" == typeof t && (t = +t), B.prototype.encode.call(this, t)
        );
      }
    }
    class T extends t {
      constructor(t, e) {
        if (
          !((t instanceof n && t.isCount()) || (Number.isInteger(t) && 0 <= t))
        )
          throw new TypeError(
            "length must be positive integer or an unsigned integer ExternalLayout"
          );
        let r = -1;
        t instanceof n || (r = t), super(r, e), (this.length = t);
      }
      getSpan(t, e) {
        let n = this.span;
        return 0 > n && (n = this.length.decode(t, e)), n;
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        let n = this.span;
        return 0 > n && (n = this.length.decode(t, e)), t.slice(e, e + n);
      }
      encode(t, r, o) {
        let i = this.length;
        if (
          (this.length instanceof n && (i = t.length),
          !J.isBuffer(t) || i !== t.length)
        )
          throw new TypeError(
            e("Blob.encode", this) +
              " requires (length " +
              i +
              ") Buffer as src"
          );
        if (o + i > r.length) throw new RangeError("encoding overruns Buffer");
        return (
          r.write(t.toString("hex"), o, i, "hex"),
          this.length instanceof n && this.length.encode(i, r, o),
          i
        );
      }
    }
    class R extends t {
      constructor(t) {
        super(-1, t);
      }
      getSpan(t, e) {
        if (!J.isBuffer(t)) throw new TypeError("b must be a Buffer");
        void 0 === e && (e = 0);
        let n = e;
        for (; n < t.length && 0 !== t[n]; ) n += 1;
        return 1 + n - e;
      }
      decode(t, e, n) {
        void 0 === e && (e = 0);
        let r = this.getSpan(t, e);
        return t.slice(e, e + r - 1).toString("utf-8");
      }
      encode(t, e, n) {
        void 0 === n && (n = 0), "string" != typeof t && (t = t.toString());
        const r = new J(t, "utf8"),
          o = r.length;
        if (n + o > e.length) throw new RangeError("encoding overruns Buffer");
        return r.copy(e, n), (e[n + o] = 0), o + 1;
      }
    }
    class O extends t {
      constructor(t, e) {
        if (
          ("string" == typeof t && void 0 === e && ((e = t), (t = void 0)),
          void 0 === t)
        )
          t = -1;
        else if (!Number.isInteger(t))
          throw new TypeError("maxSpan must be an integer");
        super(-1, e), (this.maxSpan = t);
      }
      getSpan(t, e) {
        if (!J.isBuffer(t)) throw new TypeError("b must be a Buffer");
        return void 0 === e && (e = 0), t.length - e;
      }
      decode(t, e, n) {
        void 0 === e && (e = 0);
        let r = this.getSpan(t, e);
        if (0 <= this.maxSpan && this.maxSpan < r)
          throw new RangeError("text length exceeds maxSpan");
        return t.slice(e, e + r).toString("utf-8");
      }
      encode(t, e, n) {
        void 0 === n && (n = 0), "string" != typeof t && (t = t.toString());
        const r = new J(t, "utf8"),
          o = r.length;
        if (0 <= this.maxSpan && this.maxSpan < o)
          throw new RangeError("text length exceeds maxSpan");
        if (n + o > e.length) throw new RangeError("encoding overruns Buffer");
        return r.copy(e, n), o;
      }
    }
    class M extends t {
      constructor(t, e) {
        super(0, e), (this.value = t);
      }
      decode(t, e, n) {
        return this.value;
      }
      encode(t, e, n) {
        return 0;
      }
    }
    return (
      (Xu.ExternalLayout = n),
      (Xu.GreedyCount = r),
      (Xu.OffsetLayout = o),
      (Xu.UInt = i),
      (Xu.UIntBE = s),
      (Xu.Int = a),
      (Xu.IntBE = c),
      (Xu.Float = y),
      (Xu.FloatBE = g),
      (Xu.Double = w),
      (Xu.DoubleBE = b),
      (Xu.Sequence = v),
      (Xu.Structure = _),
      (Xu.UnionDiscriminator = k),
      (Xu.UnionLayoutDiscriminator = A),
      (Xu.Union = E),
      (Xu.VariantLayout = I),
      (Xu.BitStructure = S),
      (Xu.BitField = B),
      (Xu.Boolean = x),
      (Xu.Blob = T),
      (Xu.CString = R),
      (Xu.UTF8 = O),
      (Xu.Constant = M),
      (Xu.greedy = (t, e) => new r(t, e)),
      (Xu.offset = (t, e, n) => new o(t, e, n)),
      (Xu.u8 = (t) => new i(1, t)),
      (Xu.u16 = (t) => new i(2, t)),
      (Xu.u24 = (t) => new i(3, t)),
      (Xu.u32 = (t) => new i(4, t)),
      (Xu.u40 = (t) => new i(5, t)),
      (Xu.u48 = (t) => new i(6, t)),
      (Xu.nu64 = (t) => new d(t)),
      (Xu.u16be = (t) => new s(2, t)),
      (Xu.u24be = (t) => new s(3, t)),
      (Xu.u32be = (t) => new s(4, t)),
      (Xu.u40be = (t) => new s(5, t)),
      (Xu.u48be = (t) => new s(6, t)),
      (Xu.nu64be = (t) => new f(t)),
      (Xu.s8 = (t) => new a(1, t)),
      (Xu.s16 = (t) => new a(2, t)),
      (Xu.s24 = (t) => new a(3, t)),
      (Xu.s32 = (t) => new a(4, t)),
      (Xu.s40 = (t) => new a(5, t)),
      (Xu.s48 = (t) => new a(6, t)),
      (Xu.ns64 = (t) => new p(t)),
      (Xu.s16be = (t) => new c(2, t)),
      (Xu.s24be = (t) => new c(3, t)),
      (Xu.s32be = (t) => new c(4, t)),
      (Xu.s40be = (t) => new c(5, t)),
      (Xu.s48be = (t) => new c(6, t)),
      (Xu.ns64be = (t) => new m(t)),
      (Xu.f32 = (t) => new y(t)),
      (Xu.f32be = (t) => new g(t)),
      (Xu.f64 = (t) => new w(t)),
      (Xu.f64be = (t) => new b(t)),
      (Xu.struct = (t, e, n) => new _(t, e, n)),
      (Xu.bits = (t, e, n) => new S(t, e, n)),
      (Xu.seq = (t, e, n) => new v(t, e, n)),
      (Xu.union = (t, e, n) => new E(t, e, n)),
      (Xu.unionLayoutDiscriminator = (t, e) => new A(t, e)),
      (Xu.blob = (t, e) => new T(t, e)),
      (Xu.cstr = (t) => new R(t)),
      (Xu.utf8 = (t, e) => new O(t, e)),
      (Xu.const = (t, e) => new M(t, e)),
      Xu
    );
  }
  const Qu = En(iu);
  var tl;
  var el =
    (tl ||
      ((tl = 1),
      (function (t) {
        window.skCrypt = function (t) {
          return function () {
            return t;
          };
        };
        var e =
          (Ju && Ju.__importDefault) ||
          function (t) {
            return t && t.__esModule ? t : { default: t };
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.struct =
            t.f64 =
            t.f32 =
            t.i32 =
            t.u32 =
            t.i16 =
            t.u16 =
            t.i8 =
            t.u8 =
              void 0),
          (t.u64 = a),
          (t.i64 = function (t) {
            return new s(8, !0, t);
          }),
          (t.u128 = function (t) {
            return new s(16, !1, t);
          }),
          (t.i128 = function (t) {
            return new s(16, !0, t);
          }),
          (t.u256 = function (t) {
            return new s(32, !1, t);
          }),
          (t.i256 = function (t) {
            return new s(32, !0, t);
          }),
          (t.publicKey = function (t) {
            return new c(
              (0, n.blob)(32),
              (t) => new r.PublicKey(t),
              (t) => t.toBuffer(),
              t
            );
          }),
          (t.option = function (t, e) {
            return new u(t, e);
          }),
          (t.bool = function (t) {
            return new c((0, n.u8)(), l, h, t);
          }),
          (t.vec = function (t, e) {
            const r = (0, n.u32)("length"),
              o = (0, n.struct)([
                r,
                (0, n.seq)(t, (0, n.offset)(r, -r.span), "values"),
              ]);
            return new c(
              o,
              ({ values: t }) => t,
              (t) => ({ values: t }),
              e
            );
          }),
          (t.tagged = function (t, e, r) {
            const o = (0, n.struct)([a("tag"), e.replicate("data")]);
            return new c(
              o,
              function ({ tag: e, data: n }) {
                if (!e.eq(t))
                  throw new Error(
                    "Invalid tag, expected: " +
                      t.toString("hex") +
                      ", got: " +
                      e.toString("hex")
                  );
                return n;
              },
              (e) => ({ tag: t, data: e }),
              r
            );
          }),
          (t.vecU8 = d),
          (t.str = function (t) {
            return new c(
              d(),
              (t) => t.toString("utf-8"),
              (t) => J.from(t, "utf-8"),
              t
            );
          }),
          (t.rustEnum = function (t, e, r) {
            const o = (0, n.union)(null != r ? r : (0, n.u8)(), e);
            return t.forEach((t, e) => o.addVariant(e, t, t.property)), o;
          }),
          (t.array = function (t, e, r) {
            const o = (0, n.struct)([(0, n.seq)(t, e, "values")]);
            return new c(
              o,
              ({ values: t }) => t,
              (t) => ({ values: t }),
              r
            );
          }),
          (t.map = function (t, e, r) {
            const o = (0, n.u32)("length"),
              i = (0, n.struct)([
                o,
                (0, n.seq)(new f(t, e), (0, n.offset)(o, -o.span), "values"),
              ]);
            return new c(
              i,
              ({ values: t }) => new Map(t),
              (t) => ({ values: Array.from(t.entries()) }),
              r
            );
          });
        const n = $u(),
          r = Qu,
          o = e(On());
        var i = $u();
        Object.defineProperty(t, "u8", {
          enumerable: !0,
          get: function () {
            return i.u8;
          },
        }),
          Object.defineProperty(t, "i8", {
            enumerable: !0,
            get: function () {
              return i.s8;
            },
          }),
          Object.defineProperty(t, "u16", {
            enumerable: !0,
            get: function () {
              return i.u16;
            },
          }),
          Object.defineProperty(t, "i16", {
            enumerable: !0,
            get: function () {
              return i.s16;
            },
          }),
          Object.defineProperty(t, "u32", {
            enumerable: !0,
            get: function () {
              return i.u32;
            },
          }),
          Object.defineProperty(t, "i32", {
            enumerable: !0,
            get: function () {
              return i.s32;
            },
          }),
          Object.defineProperty(t, "f32", {
            enumerable: !0,
            get: function () {
              return i.f32;
            },
          }),
          Object.defineProperty(t, "f64", {
            enumerable: !0,
            get: function () {
              return i.f64;
            },
          }),
          Object.defineProperty(t, "struct", {
            enumerable: !0,
            get: function () {
              return i.struct;
            },
          });
        class s extends n.Layout {
          constructor(t, e, r) {
            super(t, r), (this.blob = (0, n.blob)(t)), (this.signed = e);
          }
          decode(t, e = 0) {
            const n = new o.default(this.blob.decode(t, e), 10, "le");
            return this.signed ? n.fromTwos(8 * this.span).clone() : n;
          }
          encode(t, e, n = 0) {
            return (
              this.signed && (t = t.toTwos(8 * this.span)),
              this.blob.encode(t.toArrayLike(J, "le", this.span), e, n)
            );
          }
        }
        function a(t) {
          return new s(8, !1, t);
        }
        class c extends n.Layout {
          constructor(t, e, n, r) {
            super(t.span, r),
              (this.layout = t),
              (this.decoder = e),
              (this.encoder = n);
          }
          decode(t, e) {
            return this.decoder(this.layout.decode(t, e));
          }
          encode(t, e, n) {
            return this.layout.encode(this.encoder(t), e, n);
          }
          getSpan(t, e) {
            return this.layout.getSpan(t, e);
          }
        }
        class u extends n.Layout {
          constructor(t, e) {
            super(-1, e), (this.layout = t), (this.discriminator = (0, n.u8)());
          }
          encode(t, e, n = 0) {
            return null == t
              ? this.discriminator.encode(0, e, n)
              : (this.discriminator.encode(1, e, n),
                this.layout.encode(t, e, n + 1) + 1);
          }
          decode(t, e = 0) {
            const n = this.discriminator.decode(t, e);
            if (0 === n) return null;
            if (1 === n) return this.layout.decode(t, e + 1);
            throw new Error("Invalid option " + this.property);
          }
          getSpan(t, e = 0) {
            const n = this.discriminator.decode(t, e);
            if (0 === n) return 1;
            if (1 === n) return this.layout.getSpan(t, e + 1) + 1;
            throw new Error("Invalid option " + this.property);
          }
        }
        function l(t) {
          if (0 === t) return !1;
          if (1 === t) return !0;
          throw new Error("Invalid bool: " + t);
        }
        function h(t) {
          return t ? 1 : 0;
        }
        function d(t) {
          const e = (0, n.u32)("length"),
            r = (0, n.struct)([
              e,
              (0, n.blob)((0, n.offset)(e, -e.span), "data"),
            ]);
          return new c(
            r,
            ({ data: t }) => t,
            (t) => ({ data: t }),
            t
          );
        }
        class f extends n.Layout {
          constructor(t, e, n) {
            super(t.span + e.span, n),
              (this.keyLayout = t),
              (this.valueLayout = e);
          }
          decode(t, e) {
            return (
              (e = e || 0),
              [
                this.keyLayout.decode(t, e),
                this.valueLayout.decode(t, e + this.keyLayout.getSpan(t, e)),
              ]
            );
          }
          encode(t, e, n) {
            n = n || 0;
            const r = this.keyLayout.encode(t[0], e, n);
            return r + this.valueLayout.encode(t[1], e, n + r);
          }
          getSpan(t, e) {
            return (
              this.keyLayout.getSpan(t, e) + this.valueLayout.getSpan(t, e)
            );
          }
        }
      })(Ju)),
    Ju);
  function nl(t) {
    let e = t.length;
    for (; --e >= 0; ) t[e] = 0;
  }
  nl(new Array(576));
  nl(new Array(60));
  nl(new Array(512));
  nl(new Array(256));
  nl(new Array(29));
  nl(new Array(30));
  var rl = (t, e, n, r) => {
    let o = 65535 & t,
      i = (t >>> 16) & 65535,
      s = 0;
    for (; 0 !== n; ) {
      (s = n > 2e3 ? 2e3 : n), (n -= s);
      do {
        (o = (o + e[r++]) | 0), (i = (i + o) | 0);
      } while (--s);
      (o %= 65521), (i %= 65521);
    }
    return o | (i << 16);
  };
  const ol = new Uint32Array(
    (() => {
      let t,
        e = [];
      for (var n = 0; n < 256; n++) {
        t = n;
        for (var r = 0; r < 8; r++)
          t = 1 & t ? 3988292384 ^ (t >>> 1) : t >>> 1;
        e[n] = t;
      }
      return e;
    })()
  );
  var il = (t, e, n, r) => {
      const o = ol,
        i = r + n;
      t ^= -1;
      for (let s = r; s < i; s++) t = (t >>> 8) ^ o[255 & (t ^ e[s])];
      return -1 ^ t;
    },
    sl = {
      2: "need dictionary",
      1: "stream end",
      0: "",
      "-1": "file error",
      "-2": "stream error",
      "-3": "data error",
      "-4": "insufficient memory",
      "-5": "buffer error",
      "-6": "incompatible version",
    },
    al = {
      Z_NO_FLUSH: 0,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_DEFLATED: 8,
    };
  const cl = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
  var ul = function (t) {
      const e = Array.prototype.slice.call(arguments, 1);
      for (; e.length; ) {
        const n = e.shift();
        if (n) {
          if ("object" != typeof n)
            throw new TypeError(n + "must be non-object");
          for (const e in n) cl(n, e) && (t[e] = n[e]);
        }
      }
      return t;
    },
    ll = (t) => {
      let e = 0;
      for (let r = 0, o = t.length; r < o; r++) e += t[r].length;
      const n = new Uint8Array(e);
      for (let r = 0, o = 0, i = t.length; r < i; r++) {
        let e = t[r];
        n.set(e, o), (o += e.length);
      }
      return n;
    };
  let hl = !0;
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (dy) {
    hl = !1;
  }
  const dl = new Uint8Array(256);
  for (let fy = 0; fy < 256; fy++)
    dl[fy] =
      fy >= 252
        ? 6
        : fy >= 248
        ? 5
        : fy >= 240
        ? 4
        : fy >= 224
        ? 3
        : fy >= 192
        ? 2
        : 1;
  dl[254] = dl[254] = 1;
  var fl = (t) => {
      if ("function" == typeof TextEncoder && TextEncoder.prototype.encode)
        return new TextEncoder().encode(t);
      let e,
        n,
        r,
        o,
        i,
        s = t.length,
        a = 0;
      for (o = 0; o < s; o++)
        (n = t.charCodeAt(o)),
          55296 == (64512 & n) &&
            o + 1 < s &&
            ((r = t.charCodeAt(o + 1)),
            56320 == (64512 & r) &&
              ((n = 65536 + ((n - 55296) << 10) + (r - 56320)), o++)),
          (a += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4);
      for (e = new Uint8Array(a), i = 0, o = 0; i < a; o++)
        (n = t.charCodeAt(o)),
          55296 == (64512 & n) &&
            o + 1 < s &&
            ((r = t.charCodeAt(o + 1)),
            56320 == (64512 & r) &&
              ((n = 65536 + ((n - 55296) << 10) + (r - 56320)), o++)),
          n < 128
            ? (e[i++] = n)
            : n < 2048
            ? ((e[i++] = 192 | (n >>> 6)), (e[i++] = 128 | (63 & n)))
            : n < 65536
            ? ((e[i++] = 224 | (n >>> 12)),
              (e[i++] = 128 | ((n >>> 6) & 63)),
              (e[i++] = 128 | (63 & n)))
            : ((e[i++] = 240 | (n >>> 18)),
              (e[i++] = 128 | ((n >>> 12) & 63)),
              (e[i++] = 128 | ((n >>> 6) & 63)),
              (e[i++] = 128 | (63 & n)));
      return e;
    },
    pl = (t, e) => {
      const n = e || t.length;
      if ("function" == typeof TextDecoder && TextDecoder.prototype.decode)
        return new TextDecoder().decode(t.subarray(0, e));
      let r, o;
      const i = new Array(2 * n);
      for (o = 0, r = 0; r < n; ) {
        let e = t[r++];
        if (e < 128) {
          i[o++] = e;
          continue;
        }
        let s = dl[e];
        if (s > 4) (i[o++] = 65533), (r += s - 1);
        else {
          for (e &= 2 === s ? 31 : 3 === s ? 15 : 7; s > 1 && r < n; )
            (e = (e << 6) | (63 & t[r++])), s--;
          s > 1
            ? (i[o++] = 65533)
            : e < 65536
            ? (i[o++] = e)
            : ((e -= 65536),
              (i[o++] = 55296 | ((e >> 10) & 1023)),
              (i[o++] = 56320 | (1023 & e)));
        }
      }
      return ((t, e) => {
        if (e < 65534 && t.subarray && hl)
          return String.fromCharCode.apply(
            null,
            t.length === e ? t : t.subarray(0, e)
          );
        let n = "";
        for (let r = 0; r < e; r++) n += String.fromCharCode(t[r]);
        return n;
      })(i, o);
    },
    ml = (t, e) => {
      (e = e || t.length) > t.length && (e = t.length);
      let n = e - 1;
      for (; n >= 0 && 128 == (192 & t[n]); ) n--;
      return n < 0 || 0 === n ? e : n + dl[t[n]] > e ? n : e;
    };
  var yl = function () {
    (this.input = null),
      (this.next_in = 0),
      (this.avail_in = 0),
      (this.total_in = 0),
      (this.output = null),
      (this.next_out = 0),
      (this.avail_out = 0),
      (this.total_out = 0),
      (this.msg = ""),
      (this.state = null),
      (this.data_type = 2),
      (this.adler = 0);
  };
  const gl = 16209;
  var wl = function (t, e) {
    let n, r, o, i, s, a, c, u, l, h, d, f, p, m, y, g, w, b, v, _, k, A, E, I;
    const C = t.state;
    (n = t.next_in),
      (E = t.input),
      (r = n + (t.avail_in - 5)),
      (o = t.next_out),
      (I = t.output),
      (i = o - (e - t.avail_out)),
      (s = o + (t.avail_out - 257)),
      (a = C.dmax),
      (c = C.wsize),
      (u = C.whave),
      (l = C.wnext),
      (h = C.window),
      (d = C.hold),
      (f = C.bits),
      (p = C.lencode),
      (m = C.distcode),
      (y = (1 << C.lenbits) - 1),
      (g = (1 << C.distbits) - 1);
    t: do {
      f < 15 && ((d += E[n++] << f), (f += 8), (d += E[n++] << f), (f += 8)),
        (w = p[d & y]);
      e: for (;;) {
        if (
          ((b = w >>> 24),
          (d >>>= b),
          (f -= b),
          (b = (w >>> 16) & 255),
          0 === b)
        )
          I[o++] = 65535 & w;
        else {
          if (!(16 & b)) {
            if (64 & b) {
              if (32 & b) {
                C.mode = 16191;
                break t;
              }
              (t.msg = "invalid literal/length code"), (C.mode = gl);
              break t;
            }
            w = p[(65535 & w) + (d & ((1 << b) - 1))];
            continue e;
          }
          for (
            v = 65535 & w,
              b &= 15,
              b &&
                (f < b && ((d += E[n++] << f), (f += 8)),
                (v += d & ((1 << b) - 1)),
                (d >>>= b),
                (f -= b)),
              f < 15 &&
                ((d += E[n++] << f), (f += 8), (d += E[n++] << f), (f += 8)),
              w = m[d & g];
            ;

          ) {
            if (
              ((b = w >>> 24),
              (d >>>= b),
              (f -= b),
              (b = (w >>> 16) & 255),
              16 & b)
            ) {
              if (
                ((_ = 65535 & w),
                (b &= 15),
                f < b &&
                  ((d += E[n++] << f),
                  (f += 8),
                  f < b && ((d += E[n++] << f), (f += 8))),
                (_ += d & ((1 << b) - 1)),
                _ > a)
              ) {
                (t.msg = "invalid distance too far back"), (C.mode = gl);
                break t;
              }
              if (((d >>>= b), (f -= b), (b = o - i), _ > b)) {
                if (((b = _ - b), b > u && C.sane)) {
                  (t.msg = "invalid distance too far back"), (C.mode = gl);
                  break t;
                }
                if (((k = 0), (A = h), 0 === l)) {
                  if (((k += c - b), b < v)) {
                    v -= b;
                    do {
                      I[o++] = h[k++];
                    } while (--b);
                    (k = o - _), (A = I);
                  }
                } else if (l < b) {
                  if (((k += c + l - b), (b -= l), b < v)) {
                    v -= b;
                    do {
                      I[o++] = h[k++];
                    } while (--b);
                    if (((k = 0), l < v)) {
                      (b = l), (v -= b);
                      do {
                        I[o++] = h[k++];
                      } while (--b);
                      (k = o - _), (A = I);
                    }
                  }
                } else if (((k += l - b), b < v)) {
                  v -= b;
                  do {
                    I[o++] = h[k++];
                  } while (--b);
                  (k = o - _), (A = I);
                }
                for (; v > 2; )
                  (I[o++] = A[k++]),
                    (I[o++] = A[k++]),
                    (I[o++] = A[k++]),
                    (v -= 3);
                v && ((I[o++] = A[k++]), v > 1 && (I[o++] = A[k++]));
              } else {
                k = o - _;
                do {
                  (I[o++] = I[k++]),
                    (I[o++] = I[k++]),
                    (I[o++] = I[k++]),
                    (v -= 3);
                } while (v > 2);
                v && ((I[o++] = I[k++]), v > 1 && (I[o++] = I[k++]));
              }
              break;
            }
            if (64 & b) {
              (t.msg = "invalid distance code"), (C.mode = gl);
              break t;
            }
            w = m[(65535 & w) + (d & ((1 << b) - 1))];
          }
        }
        break;
      }
    } while (n < r && o < s);
    (v = f >> 3),
      (n -= v),
      (f -= v << 3),
      (d &= (1 << f) - 1),
      (t.next_in = n),
      (t.next_out = o),
      (t.avail_in = n < r ? r - n + 5 : 5 - (n - r)),
      (t.avail_out = o < s ? s - o + 257 : 257 - (o - s)),
      (C.hold = d),
      (C.bits = f);
  };
  const bl = 15,
    vl = new Uint16Array([
      3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
      67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0,
    ]),
    _l = new Uint8Array([
      16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19,
      19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78,
    ]),
    kl = new Uint16Array([
      1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,
      769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0,
    ]),
    Al = new Uint8Array([
      16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23,
      24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64,
    ]);
  var El = (t, e, n, r, o, i, s, a) => {
    const c = a.bits;
    let u,
      l,
      h,
      d,
      f,
      p,
      m = 0,
      y = 0,
      g = 0,
      w = 0,
      b = 0,
      v = 0,
      _ = 0,
      k = 0,
      A = 0,
      E = 0,
      I = null;
    const C = new Uint16Array(16),
      S = new Uint16Array(16);
    let B,
      x,
      T,
      R = null;
    for (m = 0; m <= bl; m++) C[m] = 0;
    for (y = 0; y < r; y++) C[e[n + y]]++;
    for (b = c, w = bl; w >= 1 && 0 === C[w]; w--);
    if ((b > w && (b = w), 0 === w))
      return (o[i++] = 20971520), (o[i++] = 20971520), (a.bits = 1), 0;
    for (g = 1; g < w && 0 === C[g]; g++);
    for (b < g && (b = g), k = 1, m = 1; m <= bl; m++)
      if (((k <<= 1), (k -= C[m]), k < 0)) return -1;
    if (k > 0 && (0 === t || 1 !== w)) return -1;
    for (S[1] = 0, m = 1; m < bl; m++) S[m + 1] = S[m] + C[m];
    for (y = 0; y < r; y++) 0 !== e[n + y] && (s[S[e[n + y]]++] = y);
    if (
      (0 === t
        ? ((I = R = s), (p = 20))
        : 1 === t
        ? ((I = vl), (R = _l), (p = 257))
        : ((I = kl), (R = Al), (p = 0)),
      (E = 0),
      (y = 0),
      (m = g),
      (f = i),
      (v = b),
      (_ = 0),
      (h = -1),
      (A = 1 << b),
      (d = A - 1),
      (1 === t && A > 852) || (2 === t && A > 592))
    )
      return 1;
    for (;;) {
      (B = m - _),
        s[y] + 1 < p
          ? ((x = 0), (T = s[y]))
          : s[y] >= p
          ? ((x = R[s[y] - p]), (T = I[s[y] - p]))
          : ((x = 96), (T = 0)),
        (u = 1 << (m - _)),
        (l = 1 << v),
        (g = l);
      do {
        (l -= u), (o[f + (E >> _) + l] = (B << 24) | (x << 16) | T);
      } while (0 !== l);
      for (u = 1 << (m - 1); E & u; ) u >>= 1;
      if ((0 !== u ? ((E &= u - 1), (E += u)) : (E = 0), y++, 0 === --C[m])) {
        if (m === w) break;
        m = e[n + s[y]];
      }
      if (m > b && (E & d) !== h) {
        for (
          0 === _ && (_ = b), f += g, v = m - _, k = 1 << v;
          v + _ < w && ((k -= C[v + _]), !(k <= 0));

        )
          v++, (k <<= 1);
        if (((A += 1 << v), (1 === t && A > 852) || (2 === t && A > 592)))
          return 1;
        (h = E & d), (o[h] = (b << 24) | (v << 16) | (f - i));
      }
    }
    return (
      0 !== E && (o[f + E] = ((m - _) << 24) | (64 << 16)), (a.bits = b), 0
    );
  };
  const {
      Z_FINISH: Il,
      Z_BLOCK: Cl,
      Z_TREES: Sl,
      Z_OK: Bl,
      Z_STREAM_END: xl,
      Z_NEED_DICT: Tl,
      Z_STREAM_ERROR: Rl,
      Z_DATA_ERROR: Ol,
      Z_MEM_ERROR: Ml,
      Z_BUF_ERROR: Nl,
      Z_DEFLATED: Pl,
    } = al,
    Ll = 16180,
    zl = 16190,
    Dl = 16191,
    Ul = 16192,
    ql = 16194,
    Gl = 16199,
    Wl = 16200,
    Kl = 16206,
    jl = 16209,
    Hl = (t) =>
      ((t >>> 24) & 255) +
      ((t >>> 8) & 65280) +
      ((65280 & t) << 8) +
      ((255 & t) << 24);
  function Vl() {
    (this.strm = null),
      (this.mode = 0),
      (this.last = !1),
      (this.wrap = 0),
      (this.havedict = !1),
      (this.flags = 0),
      (this.dmax = 0),
      (this.check = 0),
      (this.total = 0),
      (this.head = null),
      (this.wbits = 0),
      (this.wsize = 0),
      (this.whave = 0),
      (this.wnext = 0),
      (this.window = null),
      (this.hold = 0),
      (this.bits = 0),
      (this.length = 0),
      (this.offset = 0),
      (this.extra = 0),
      (this.lencode = null),
      (this.distcode = null),
      (this.lenbits = 0),
      (this.distbits = 0),
      (this.ncode = 0),
      (this.nlen = 0),
      (this.ndist = 0),
      (this.have = 0),
      (this.next = null),
      (this.lens = new Uint16Array(320)),
      (this.work = new Uint16Array(288)),
      (this.lendyn = null),
      (this.distdyn = null),
      (this.sane = 0),
      (this.back = 0),
      (this.was = 0);
  }
  const Fl = (t) => {
      if (!t) return 1;
      const e = t.state;
      return !e || e.strm !== t || e.mode < Ll || e.mode > 16211 ? 1 : 0;
    },
    Yl = (t) => {
      if (Fl(t)) return Rl;
      const e = t.state;
      return (
        (t.total_in = t.total_out = e.total = 0),
        (t.msg = ""),
        e.wrap && (t.adler = 1 & e.wrap),
        (e.mode = Ll),
        (e.last = 0),
        (e.havedict = 0),
        (e.flags = -1),
        (e.dmax = 32768),
        (e.head = null),
        (e.hold = 0),
        (e.bits = 0),
        (e.lencode = e.lendyn = new Int32Array(852)),
        (e.distcode = e.distdyn = new Int32Array(592)),
        (e.sane = 1),
        (e.back = -1),
        Bl
      );
    },
    Zl = (t) => {
      if (Fl(t)) return Rl;
      const e = t.state;
      return (e.wsize = 0), (e.whave = 0), (e.wnext = 0), Yl(t);
    },
    Jl = (t, e) => {
      let n;
      if (Fl(t)) return Rl;
      const r = t.state;
      return (
        e < 0 ? ((n = 0), (e = -e)) : ((n = 5 + (e >> 4)), e < 48 && (e &= 15)),
        e && (e < 8 || e > 15)
          ? Rl
          : (null !== r.window && r.wbits !== e && (r.window = null),
            (r.wrap = n),
            (r.wbits = e),
            Zl(t))
      );
    },
    Xl = (t, e) => {
      if (!t) return Rl;
      const n = new Vl();
      (t.state = n), (n.strm = t), (n.window = null), (n.mode = Ll);
      const r = Jl(t, e);
      return r !== Bl && (t.state = null), r;
    };
  let $l,
    Ql,
    th = !0;
  const eh = (t) => {
      if (th) {
        ($l = new Int32Array(512)), (Ql = new Int32Array(32));
        let e = 0;
        for (; e < 144; ) t.lens[e++] = 8;
        for (; e < 256; ) t.lens[e++] = 9;
        for (; e < 280; ) t.lens[e++] = 7;
        for (; e < 288; ) t.lens[e++] = 8;
        for (El(1, t.lens, 0, 288, $l, 0, t.work, { bits: 9 }), e = 0; e < 32; )
          t.lens[e++] = 5;
        El(2, t.lens, 0, 32, Ql, 0, t.work, { bits: 5 }), (th = !1);
      }
      (t.lencode = $l), (t.lenbits = 9), (t.distcode = Ql), (t.distbits = 5);
    },
    nh = (t, e, n, r) => {
      let o;
      const i = t.state;
      return (
        null === i.window &&
          ((i.wsize = 1 << i.wbits),
          (i.wnext = 0),
          (i.whave = 0),
          (i.window = new Uint8Array(i.wsize))),
        r >= i.wsize
          ? (i.window.set(e.subarray(n - i.wsize, n), 0),
            (i.wnext = 0),
            (i.whave = i.wsize))
          : ((o = i.wsize - i.wnext),
            o > r && (o = r),
            i.window.set(e.subarray(n - r, n - r + o), i.wnext),
            (r -= o)
              ? (i.window.set(e.subarray(n - r, n), 0),
                (i.wnext = r),
                (i.whave = i.wsize))
              : ((i.wnext += o),
                i.wnext === i.wsize && (i.wnext = 0),
                i.whave < i.wsize && (i.whave += o))),
        0
      );
    };
  var rh = {
    inflateReset: Zl,
    inflateReset2: Jl,
    inflateResetKeep: Yl,
    inflateInit: (t) => Xl(t, 15),
    inflateInit2: Xl,
    inflate: (t, e) => {
      let n,
        r,
        o,
        i,
        s,
        a,
        c,
        u,
        l,
        h,
        d,
        f,
        p,
        m,
        y,
        g,
        w,
        b,
        v,
        _,
        k,
        A,
        E = 0;
      const I = new Uint8Array(4);
      let C, S;
      const B = new Uint8Array([
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
      ]);
      if (Fl(t) || !t.output || (!t.input && 0 !== t.avail_in)) return Rl;
      (n = t.state),
        n.mode === Dl && (n.mode = Ul),
        (s = t.next_out),
        (o = t.output),
        (c = t.avail_out),
        (i = t.next_in),
        (r = t.input),
        (a = t.avail_in),
        (u = n.hold),
        (l = n.bits),
        (h = a),
        (d = c),
        (A = Bl);
      t: for (;;)
        switch (n.mode) {
          case Ll:
            if (0 === n.wrap) {
              n.mode = Ul;
              break;
            }
            for (; l < 16; ) {
              if (0 === a) break t;
              a--, (u += r[i++] << l), (l += 8);
            }
            if (2 & n.wrap && 35615 === u) {
              0 === n.wbits && (n.wbits = 15),
                (n.check = 0),
                (I[0] = 255 & u),
                (I[1] = (u >>> 8) & 255),
                (n.check = il(n.check, I, 2, 0)),
                (u = 0),
                (l = 0),
                (n.mode = 16181);
              break;
            }
            if (
              (n.head && (n.head.done = !1),
              !(1 & n.wrap) || (((255 & u) << 8) + (u >> 8)) % 31)
            ) {
              (t.msg = "incorrect header check"), (n.mode = jl);
              break;
            }
            if ((15 & u) !== Pl) {
              (t.msg = "unknown compression method"), (n.mode = jl);
              break;
            }
            if (
              ((u >>>= 4),
              (l -= 4),
              (k = 8 + (15 & u)),
              0 === n.wbits && (n.wbits = k),
              k > 15 || k > n.wbits)
            ) {
              (t.msg = "invalid window size"), (n.mode = jl);
              break;
            }
            (n.dmax = 1 << n.wbits),
              (n.flags = 0),
              (t.adler = n.check = 1),
              (n.mode = 512 & u ? 16189 : Dl),
              (u = 0),
              (l = 0);
            break;
          case 16181:
            for (; l < 16; ) {
              if (0 === a) break t;
              a--, (u += r[i++] << l), (l += 8);
            }
            if (((n.flags = u), (255 & n.flags) !== Pl)) {
              (t.msg = "unknown compression method"), (n.mode = jl);
              break;
            }
            if (57344 & n.flags) {
              (t.msg = "unknown header flags set"), (n.mode = jl);
              break;
            }
            n.head && (n.head.text = (u >> 8) & 1),
              512 & n.flags &&
                4 & n.wrap &&
                ((I[0] = 255 & u),
                (I[1] = (u >>> 8) & 255),
                (n.check = il(n.check, I, 2, 0))),
              (u = 0),
              (l = 0),
              (n.mode = 16182);
          case 16182:
            for (; l < 32; ) {
              if (0 === a) break t;
              a--, (u += r[i++] << l), (l += 8);
            }
            n.head && (n.head.time = u),
              512 & n.flags &&
                4 & n.wrap &&
                ((I[0] = 255 & u),
                (I[1] = (u >>> 8) & 255),
                (I[2] = (u >>> 16) & 255),
                (I[3] = (u >>> 24) & 255),
                (n.check = il(n.check, I, 4, 0))),
              (u = 0),
              (l = 0),
              (n.mode = 16183);
          case 16183:
            for (; l < 16; ) {
              if (0 === a) break t;
              a--, (u += r[i++] << l), (l += 8);
            }
            n.head && ((n.head.xflags = 255 & u), (n.head.os = u >> 8)),
              512 & n.flags &&
                4 & n.wrap &&
                ((I[0] = 255 & u),
                (I[1] = (u >>> 8) & 255),
                (n.check = il(n.check, I, 2, 0))),
              (u = 0),
              (l = 0),
              (n.mode = 16184);
          case 16184:
            if (1024 & n.flags) {
              for (; l < 16; ) {
                if (0 === a) break t;
                a--, (u += r[i++] << l), (l += 8);
              }
              (n.length = u),
                n.head && (n.head.extra_len = u),
                512 & n.flags &&
                  4 & n.wrap &&
                  ((I[0] = 255 & u),
                  (I[1] = (u >>> 8) & 255),
                  (n.check = il(n.check, I, 2, 0))),
                (u = 0),
                (l = 0);
            } else n.head && (n.head.extra = null);
            n.mode = 16185;
          case 16185:
            if (
              1024 & n.flags &&
              ((f = n.length),
              f > a && (f = a),
              f &&
                (n.head &&
                  ((k = n.head.extra_len - n.length),
                  n.head.extra ||
                    (n.head.extra = new Uint8Array(n.head.extra_len)),
                  n.head.extra.set(r.subarray(i, i + f), k)),
                512 & n.flags && 4 & n.wrap && (n.check = il(n.check, r, f, i)),
                (a -= f),
                (i += f),
                (n.length -= f)),
              n.length)
            )
              break t;
            (n.length = 0), (n.mode = 16186);
          case 16186:
            if (2048 & n.flags) {
              if (0 === a) break t;
              f = 0;
              do {
                (k = r[i + f++]),
                  n.head &&
                    k &&
                    n.length < 65536 &&
                    (n.head.name += String.fromCharCode(k));
              } while (k && f < a);
              if (
                (512 & n.flags &&
                  4 & n.wrap &&
                  (n.check = il(n.check, r, f, i)),
                (a -= f),
                (i += f),
                k)
              )
                break t;
            } else n.head && (n.head.name = null);
            (n.length = 0), (n.mode = 16187);
          case 16187:
            if (4096 & n.flags) {
              if (0 === a) break t;
              f = 0;
              do {
                (k = r[i + f++]),
                  n.head &&
                    k &&
                    n.length < 65536 &&
                    (n.head.comment += String.fromCharCode(k));
              } while (k && f < a);
              if (
                (512 & n.flags &&
                  4 & n.wrap &&
                  (n.check = il(n.check, r, f, i)),
                (a -= f),
                (i += f),
                k)
              )
                break t;
            } else n.head && (n.head.comment = null);
            n.mode = 16188;
          case 16188:
            if (512 & n.flags) {
              for (; l < 16; ) {
                if (0 === a) break t;
                a--, (u += r[i++] << l), (l += 8);
              }
              if (4 & n.wrap && u !== (65535 & n.check)) {
                (t.msg = "header crc mismatch"), (n.mode = jl);
                break;
              }
              (u = 0), (l = 0);
            }
            n.head && ((n.head.hcrc = (n.flags >> 9) & 1), (n.head.done = !0)),
              (t.adler = n.check = 0),
              (n.mode = Dl);
            break;
          case 16189:
            for (; l < 32; ) {
              if (0 === a) break t;
              a--, (u += r[i++] << l), (l += 8);
            }
            (t.adler = n.check = Hl(u)), (u = 0), (l = 0), (n.mode = zl);
          case zl:
            if (0 === n.havedict)
              return (
                (t.next_out = s),
                (t.avail_out = c),
                (t.next_in = i),
                (t.avail_in = a),
                (n.hold = u),
                (n.bits = l),
                Tl
              );
            (t.adler = n.check = 1), (n.mode = Dl);
          case Dl:
            if (e === Cl || e === Sl) break t;
          case Ul:
            if (n.last) {
              (u >>>= 7 & l), (l -= 7 & l), (n.mode = Kl);
              break;
            }
            for (; l < 3; ) {
              if (0 === a) break t;
              a--, (u += r[i++] << l), (l += 8);
            }
            switch (((n.last = 1 & u), (u >>>= 1), (l -= 1), 3 & u)) {
              case 0:
                n.mode = 16193;
                break;
              case 1:
                if ((eh(n), (n.mode = Gl), e === Sl)) {
                  (u >>>= 2), (l -= 2);
                  break t;
                }
                break;
              case 2:
                n.mode = 16196;
                break;
              case 3:
                (t.msg = "invalid block type"), (n.mode = jl);
            }
            (u >>>= 2), (l -= 2);
            break;
          case 16193:
            for (u >>>= 7 & l, l -= 7 & l; l < 32; ) {
              if (0 === a) break t;
              a--, (u += r[i++] << l), (l += 8);
            }
            if ((65535 & u) != ((u >>> 16) ^ 65535)) {
              (t.msg = "invalid stored block lengths"), (n.mode = jl);
              break;
            }
            if (
              ((n.length = 65535 & u),
              (u = 0),
              (l = 0),
              (n.mode = ql),
              e === Sl)
            )
              break t;
          case ql:
            n.mode = 16195;
          case 16195:
            if (((f = n.length), f)) {
              if ((f > a && (f = a), f > c && (f = c), 0 === f)) break t;
              o.set(r.subarray(i, i + f), s),
                (a -= f),
                (i += f),
                (c -= f),
                (s += f),
                (n.length -= f);
              break;
            }
            n.mode = Dl;
            break;
          case 16196:
            for (; l < 14; ) {
              if (0 === a) break t;
              a--, (u += r[i++] << l), (l += 8);
            }
            if (
              ((n.nlen = 257 + (31 & u)),
              (u >>>= 5),
              (l -= 5),
              (n.ndist = 1 + (31 & u)),
              (u >>>= 5),
              (l -= 5),
              (n.ncode = 4 + (15 & u)),
              (u >>>= 4),
              (l -= 4),
              n.nlen > 286 || n.ndist > 30)
            ) {
              (t.msg = "too many length or distance symbols"), (n.mode = jl);
              break;
            }
            (n.have = 0), (n.mode = 16197);
          case 16197:
            for (; n.have < n.ncode; ) {
              for (; l < 3; ) {
                if (0 === a) break t;
                a--, (u += r[i++] << l), (l += 8);
              }
              (n.lens[B[n.have++]] = 7 & u), (u >>>= 3), (l -= 3);
            }
            for (; n.have < 19; ) n.lens[B[n.have++]] = 0;
            if (
              ((n.lencode = n.lendyn),
              (n.lenbits = 7),
              (C = { bits: n.lenbits }),
              (A = El(0, n.lens, 0, 19, n.lencode, 0, n.work, C)),
              (n.lenbits = C.bits),
              A)
            ) {
              (t.msg = "invalid code lengths set"), (n.mode = jl);
              break;
            }
            (n.have = 0), (n.mode = 16198);
          case 16198:
            for (; n.have < n.nlen + n.ndist; ) {
              for (
                ;
                (E = n.lencode[u & ((1 << n.lenbits) - 1)]),
                  (y = E >>> 24),
                  (g = (E >>> 16) & 255),
                  (w = 65535 & E),
                  !(y <= l);

              ) {
                if (0 === a) break t;
                a--, (u += r[i++] << l), (l += 8);
              }
              if (w < 16) (u >>>= y), (l -= y), (n.lens[n.have++] = w);
              else {
                if (16 === w) {
                  for (S = y + 2; l < S; ) {
                    if (0 === a) break t;
                    a--, (u += r[i++] << l), (l += 8);
                  }
                  if (((u >>>= y), (l -= y), 0 === n.have)) {
                    (t.msg = "invalid bit length repeat"), (n.mode = jl);
                    break;
                  }
                  (k = n.lens[n.have - 1]),
                    (f = 3 + (3 & u)),
                    (u >>>= 2),
                    (l -= 2);
                } else if (17 === w) {
                  for (S = y + 3; l < S; ) {
                    if (0 === a) break t;
                    a--, (u += r[i++] << l), (l += 8);
                  }
                  (u >>>= y),
                    (l -= y),
                    (k = 0),
                    (f = 3 + (7 & u)),
                    (u >>>= 3),
                    (l -= 3);
                } else {
                  for (S = y + 7; l < S; ) {
                    if (0 === a) break t;
                    a--, (u += r[i++] << l), (l += 8);
                  }
                  (u >>>= y),
                    (l -= y),
                    (k = 0),
                    (f = 11 + (127 & u)),
                    (u >>>= 7),
                    (l -= 7);
                }
                if (n.have + f > n.nlen + n.ndist) {
                  (t.msg = "invalid bit length repeat"), (n.mode = jl);
                  break;
                }
                for (; f--; ) n.lens[n.have++] = k;
              }
            }
            if (n.mode === jl) break;
            if (0 === n.lens[256]) {
              (t.msg = "invalid code -- missing end-of-block"), (n.mode = jl);
              break;
            }
            if (
              ((n.lenbits = 9),
              (C = { bits: n.lenbits }),
              (A = El(1, n.lens, 0, n.nlen, n.lencode, 0, n.work, C)),
              (n.lenbits = C.bits),
              A)
            ) {
              (t.msg = "invalid literal/lengths set"), (n.mode = jl);
              break;
            }
            if (
              ((n.distbits = 6),
              (n.distcode = n.distdyn),
              (C = { bits: n.distbits }),
              (A = El(2, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, C)),
              (n.distbits = C.bits),
              A)
            ) {
              (t.msg = "invalid distances set"), (n.mode = jl);
              break;
            }
            if (((n.mode = Gl), e === Sl)) break t;
          case Gl:
            n.mode = Wl;
          case Wl:
            if (a >= 6 && c >= 258) {
              (t.next_out = s),
                (t.avail_out = c),
                (t.next_in = i),
                (t.avail_in = a),
                (n.hold = u),
                (n.bits = l),
                wl(t, d),
                (s = t.next_out),
                (o = t.output),
                (c = t.avail_out),
                (i = t.next_in),
                (r = t.input),
                (a = t.avail_in),
                (u = n.hold),
                (l = n.bits),
                n.mode === Dl && (n.back = -1);
              break;
            }
            for (
              n.back = 0;
              (E = n.lencode[u & ((1 << n.lenbits) - 1)]),
                (y = E >>> 24),
                (g = (E >>> 16) & 255),
                (w = 65535 & E),
                !(y <= l);

            ) {
              if (0 === a) break t;
              a--, (u += r[i++] << l), (l += 8);
            }
            if (g && !(240 & g)) {
              for (
                b = y, v = g, _ = w;
                (E = n.lencode[_ + ((u & ((1 << (b + v)) - 1)) >> b)]),
                  (y = E >>> 24),
                  (g = (E >>> 16) & 255),
                  (w = 65535 & E),
                  !(b + y <= l);

              ) {
                if (0 === a) break t;
                a--, (u += r[i++] << l), (l += 8);
              }
              (u >>>= b), (l -= b), (n.back += b);
            }
            if (
              ((u >>>= y), (l -= y), (n.back += y), (n.length = w), 0 === g)
            ) {
              n.mode = 16205;
              break;
            }
            if (32 & g) {
              (n.back = -1), (n.mode = Dl);
              break;
            }
            if (64 & g) {
              (t.msg = "invalid literal/length code"), (n.mode = jl);
              break;
            }
            (n.extra = 15 & g), (n.mode = 16201);
          case 16201:
            if (n.extra) {
              for (S = n.extra; l < S; ) {
                if (0 === a) break t;
                a--, (u += r[i++] << l), (l += 8);
              }
              (n.length += u & ((1 << n.extra) - 1)),
                (u >>>= n.extra),
                (l -= n.extra),
                (n.back += n.extra);
            }
            (n.was = n.length), (n.mode = 16202);
          case 16202:
            for (
              ;
              (E = n.distcode[u & ((1 << n.distbits) - 1)]),
                (y = E >>> 24),
                (g = (E >>> 16) & 255),
                (w = 65535 & E),
                !(y <= l);

            ) {
              if (0 === a) break t;
              a--, (u += r[i++] << l), (l += 8);
            }
            if (!(240 & g)) {
              for (
                b = y, v = g, _ = w;
                (E = n.distcode[_ + ((u & ((1 << (b + v)) - 1)) >> b)]),
                  (y = E >>> 24),
                  (g = (E >>> 16) & 255),
                  (w = 65535 & E),
                  !(b + y <= l);

              ) {
                if (0 === a) break t;
                a--, (u += r[i++] << l), (l += 8);
              }
              (u >>>= b), (l -= b), (n.back += b);
            }
            if (((u >>>= y), (l -= y), (n.back += y), 64 & g)) {
              (t.msg = "invalid distance code"), (n.mode = jl);
              break;
            }
            (n.offset = w), (n.extra = 15 & g), (n.mode = 16203);
          case 16203:
            if (n.extra) {
              for (S = n.extra; l < S; ) {
                if (0 === a) break t;
                a--, (u += r[i++] << l), (l += 8);
              }
              (n.offset += u & ((1 << n.extra) - 1)),
                (u >>>= n.extra),
                (l -= n.extra),
                (n.back += n.extra);
            }
            if (n.offset > n.dmax) {
              (t.msg = "invalid distance too far back"), (n.mode = jl);
              break;
            }
            n.mode = 16204;
          case 16204:
            if (0 === c) break t;
            if (((f = d - c), n.offset > f)) {
              if (((f = n.offset - f), f > n.whave && n.sane)) {
                (t.msg = "invalid distance too far back"), (n.mode = jl);
                break;
              }
              f > n.wnext
                ? ((f -= n.wnext), (p = n.wsize - f))
                : (p = n.wnext - f),
                f > n.length && (f = n.length),
                (m = n.window);
            } else (m = o), (p = s - n.offset), (f = n.length);
            f > c && (f = c), (c -= f), (n.length -= f);
            do {
              o[s++] = m[p++];
            } while (--f);
            0 === n.length && (n.mode = Wl);
            break;
          case 16205:
            if (0 === c) break t;
            (o[s++] = n.length), c--, (n.mode = Wl);
            break;
          case Kl:
            if (n.wrap) {
              for (; l < 32; ) {
                if (0 === a) break t;
                a--, (u |= r[i++] << l), (l += 8);
              }
              if (
                ((d -= c),
                (t.total_out += d),
                (n.total += d),
                4 & n.wrap &&
                  d &&
                  (t.adler = n.check =
                    n.flags
                      ? il(n.check, o, d, s - d)
                      : rl(n.check, o, d, s - d)),
                (d = c),
                4 & n.wrap && (n.flags ? u : Hl(u)) !== n.check)
              ) {
                (t.msg = "incorrect data check"), (n.mode = jl);
                break;
              }
              (u = 0), (l = 0);
            }
            n.mode = 16207;
          case 16207:
            if (n.wrap && n.flags) {
              for (; l < 32; ) {
                if (0 === a) break t;
                a--, (u += r[i++] << l), (l += 8);
              }
              if (4 & n.wrap && u !== (4294967295 & n.total)) {
                (t.msg = "incorrect length check"), (n.mode = jl);
                break;
              }
              (u = 0), (l = 0);
            }
            n.mode = 16208;
          case 16208:
            A = xl;
            break t;
          case jl:
            A = Ol;
            break t;
          case 16210:
            return Ml;
          default:
            return Rl;
        }
      return (
        (t.next_out = s),
        (t.avail_out = c),
        (t.next_in = i),
        (t.avail_in = a),
        (n.hold = u),
        (n.bits = l),
        (n.wsize ||
          (d !== t.avail_out && n.mode < jl && (n.mode < Kl || e !== Il))) &&
          nh(t, t.output, t.next_out, d - t.avail_out),
        (h -= t.avail_in),
        (d -= t.avail_out),
        (t.total_in += h),
        (t.total_out += d),
        (n.total += d),
        4 & n.wrap &&
          d &&
          (t.adler = n.check =
            n.flags
              ? il(n.check, o, d, t.next_out - d)
              : rl(n.check, o, d, t.next_out - d)),
        (t.data_type =
          n.bits +
          (n.last ? 64 : 0) +
          (n.mode === Dl ? 128 : 0) +
          (n.mode === Gl || n.mode === ql ? 256 : 0)),
        ((0 === h && 0 === d) || e === Il) && A === Bl && (A = Nl),
        A
      );
    },
    inflateEnd: (t) => {
      if (Fl(t)) return Rl;
      let e = t.state;
      return e.window && (e.window = null), (t.state = null), Bl;
    },
    inflateGetHeader: (t, e) => {
      if (Fl(t)) return Rl;
      const n = t.state;
      return 2 & n.wrap ? ((n.head = e), (e.done = !1), Bl) : Rl;
    },
    inflateSetDictionary: (t, e) => {
      const n = e.length;
      let r, o, i;
      return Fl(t)
        ? Rl
        : ((r = t.state),
          0 !== r.wrap && r.mode !== zl
            ? Rl
            : r.mode === zl && ((o = 1), (o = rl(o, e, n, 0)), o !== r.check)
            ? Ol
            : ((i = nh(t, e, n, n)),
              i ? ((r.mode = 16210), Ml) : ((r.havedict = 1), Bl)));
    },
    inflateInfo: "pako inflate (from Nodeca project)",
  };
  var oh = function () {
    (this.text = 0),
      (this.time = 0),
      (this.xflags = 0),
      (this.os = 0),
      (this.extra = null),
      (this.extra_len = 0),
      (this.name = ""),
      (this.comment = ""),
      (this.hcrc = 0),
      (this.done = !1);
  };
  const ih = Object.prototype.toString,
    {
      Z_NO_FLUSH: sh,
      Z_FINISH: ah,
      Z_OK: ch,
      Z_STREAM_END: uh,
      Z_NEED_DICT: lh,
      Z_STREAM_ERROR: hh,
      Z_DATA_ERROR: dh,
      Z_MEM_ERROR: fh,
    } = al;
  function ph(t) {
    this.options = ul({ chunkSize: 65536, windowBits: 15, to: "" }, t || {});
    const e = this.options;
    e.raw &&
      e.windowBits >= 0 &&
      e.windowBits < 16 &&
      ((e.windowBits = -e.windowBits),
      0 === e.windowBits && (e.windowBits = -15)),
      !(e.windowBits >= 0 && e.windowBits < 16) ||
        (t && t.windowBits) ||
        (e.windowBits += 32),
      e.windowBits > 15 &&
        e.windowBits < 48 &&
        (15 & e.windowBits || (e.windowBits |= 15)),
      (this.err = 0),
      (this.msg = ""),
      (this.ended = !1),
      (this.chunks = []),
      (this.strm = new yl()),
      (this.strm.avail_out = 0);
    let n = rh.inflateInit2(this.strm, e.windowBits);
    if (n !== ch) throw new Error(sl[n]);
    if (
      ((this.header = new oh()),
      rh.inflateGetHeader(this.strm, this.header),
      e.dictionary &&
        ("string" == typeof e.dictionary
          ? (e.dictionary = fl(e.dictionary))
          : "[object ArrayBuffer]" === ih.call(e.dictionary) &&
            (e.dictionary = new Uint8Array(e.dictionary)),
        e.raw &&
          ((n = rh.inflateSetDictionary(this.strm, e.dictionary)), n !== ch)))
    )
      throw new Error(sl[n]);
  }
  (ph.prototype.push = function (t, e) {
    const n = this.strm,
      r = this.options.chunkSize,
      o = this.options.dictionary;
    let i, s, a;
    if (this.ended) return !1;
    for (
      s = e === ~~e ? e : !0 === e ? ah : sh,
        "[object ArrayBuffer]" === ih.call(t)
          ? (n.input = new Uint8Array(t))
          : (n.input = t),
        n.next_in = 0,
        n.avail_in = n.input.length;
      ;

    ) {
      for (
        0 === n.avail_out &&
          ((n.output = new Uint8Array(r)), (n.next_out = 0), (n.avail_out = r)),
          i = rh.inflate(n, s),
          i === lh &&
            o &&
            ((i = rh.inflateSetDictionary(n, o)),
            i === ch ? (i = rh.inflate(n, s)) : i === dh && (i = lh));
        n.avail_in > 0 && i === uh && n.state.wrap > 0 && 0 !== t[n.next_in];

      )
        rh.inflateReset(n), (i = rh.inflate(n, s));
      switch (i) {
        case hh:
        case dh:
        case lh:
        case fh:
          return this.onEnd(i), (this.ended = !0), !1;
      }
      if (((a = n.avail_out), n.next_out && (0 === n.avail_out || i === uh)))
        if ("string" === this.options.to) {
          let t = ml(n.output, n.next_out),
            e = n.next_out - t,
            o = pl(n.output, t);
          (n.next_out = e),
            (n.avail_out = r - e),
            e && n.output.set(n.output.subarray(t, t + e), 0),
            this.onData(o);
        } else
          this.onData(
            n.output.length === n.next_out
              ? n.output
              : n.output.subarray(0, n.next_out)
          );
      if (i !== ch || 0 !== a) {
        if (i === uh)
          return (
            (i = rh.inflateEnd(this.strm)), this.onEnd(i), (this.ended = !0), !0
          );
        if (0 === n.avail_in) break;
      }
    }
    return !0;
  }),
    (ph.prototype.onData = function (t) {
      this.chunks.push(t);
    }),
    (ph.prototype.onEnd = function (t) {
      t === ch &&
        ("string" === this.options.to
          ? (this.result = this.chunks.join(""))
          : (this.result = ll(this.chunks))),
        (this.chunks = []),
        (this.err = t),
        (this.msg = this.strm.msg);
    });
  var mh = {
    inflate: function (t, e) {
      const n = new ph(e);
      if ((n.push(t), n.err)) throw n.msg || sl[n.err];
      return n.result;
    },
  };
  const { inflate: yh } = mh;
  var gh,
    wh = yh,
    bh = { exports: {} };
  var vh =
    (gh ||
      ((gh = 1),
      (function (t) {
        window.skCrypt = function (t) {
          return function () {
            return t;
          };
        };
        var e = Object.prototype.hasOwnProperty,
          n = "~";
        function r() {}
        function o(t, e, n) {
          (this.fn = t), (this.context = e), (this.once = n || !1);
        }
        function i(t, e, r, i, s) {
          if ("function" != typeof r)
            throw new TypeError("The listener must be a function");
          var a = new o(r, i || t, s),
            c = n ? n + e : e;
          return (
            t._events[c]
              ? t._events[c].fn
                ? (t._events[c] = [t._events[c], a])
                : t._events[c].push(a)
              : ((t._events[c] = a), t._eventsCount++),
            t
          );
        }
        function s(t, e) {
          0 === --t._eventsCount ? (t._events = new r()) : delete t._events[e];
        }
        function a() {
          (this._events = new r()), (this._eventsCount = 0);
        }
        Object.create &&
          ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1)),
          (a.prototype.eventNames = function () {
            var t,
              r,
              o = [];
            if (0 === this._eventsCount) return o;
            for (r in (t = this._events))
              e.call(t, r) && o.push(n ? r.slice(1) : r);
            return Object.getOwnPropertySymbols
              ? o.concat(Object.getOwnPropertySymbols(t))
              : o;
          }),
          (a.prototype.listeners = function (t) {
            var e = n ? n + t : t,
              r = this._events[e];
            if (!r) return [];
            if (r.fn) return [r.fn];
            for (var o = 0, i = r.length, s = new Array(i); o < i; o++)
              s[o] = r[o].fn;
            return s;
          }),
          (a.prototype.listenerCount = function (t) {
            var e = n ? n + t : t,
              r = this._events[e];
            return r ? (r.fn ? 1 : r.length) : 0;
          }),
          (a.prototype.emit = function (t, e, r, o, i, s) {
            var a = n ? n + t : t;
            if (!this._events[a]) return !1;
            var c,
              u,
              l = this._events[a],
              h = arguments.length;
            if (l.fn) {
              switch ((l.once && this.removeListener(t, l.fn, void 0, !0), h)) {
                case 1:
                  return l.fn.call(l.context), !0;
                case 2:
                  return l.fn.call(l.context, e), !0;
                case 3:
                  return l.fn.call(l.context, e, r), !0;
                case 4:
                  return l.fn.call(l.context, e, r, o), !0;
                case 5:
                  return l.fn.call(l.context, e, r, o, i), !0;
                case 6:
                  return l.fn.call(l.context, e, r, o, i, s), !0;
              }
              for (u = 1, c = new Array(h - 1); u < h; u++)
                c[u - 1] = arguments[u];
              l.fn.apply(l.context, c);
            } else {
              var d,
                f = l.length;
              for (u = 0; u < f; u++)
                switch (
                  (l[u].once && this.removeListener(t, l[u].fn, void 0, !0), h)
                ) {
                  case 1:
                    l[u].fn.call(l[u].context);
                    break;
                  case 2:
                    l[u].fn.call(l[u].context, e);
                    break;
                  case 3:
                    l[u].fn.call(l[u].context, e, r);
                    break;
                  case 4:
                    l[u].fn.call(l[u].context, e, r, o);
                    break;
                  default:
                    if (!c)
                      for (d = 1, c = new Array(h - 1); d < h; d++)
                        c[d - 1] = arguments[d];
                    l[u].fn.apply(l[u].context, c);
                }
            }
            return !0;
          }),
          (a.prototype.on = function (t, e, n) {
            return i(this, t, e, n, !1);
          }),
          (a.prototype.once = function (t, e, n) {
            return i(this, t, e, n, !0);
          }),
          (a.prototype.removeListener = function (t, e, r, o) {
            var i = n ? n + t : t;
            if (!this._events[i]) return this;
            if (!e) return s(this, i), this;
            var a = this._events[i];
            if (a.fn)
              a.fn !== e ||
                (o && !a.once) ||
                (r && a.context !== r) ||
                s(this, i);
            else {
              for (var c = 0, u = [], l = a.length; c < l; c++)
                (a[c].fn !== e ||
                  (o && !a[c].once) ||
                  (r && a[c].context !== r)) &&
                  u.push(a[c]);
              u.length
                ? (this._events[i] = 1 === u.length ? u[0] : u)
                : s(this, i);
            }
            return this;
          }),
          (a.prototype.removeAllListeners = function (t) {
            var e;
            return (
              t
                ? ((e = n ? n + t : t), this._events[e] && s(this, e))
                : ((this._events = new r()), (this._eventsCount = 0)),
              this
            );
          }),
          (a.prototype.off = a.prototype.removeListener),
          (a.prototype.addListener = a.prototype.on),
          (a.prefixed = n),
          (a.EventEmitter = a),
          (t.exports = a);
      })(bh)),
    bh.exports);
  const _h = An(vh);
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const kh = (t) => "version" in t;
  function Ah(t) {
    return Hu.encode(t);
  }
  function Eh(t) {
    return X.from(t, "base64");
  }
  function Ih(t) {
    return "accounts" in t;
  }
  const Ch = el.struct([el.publicKey("authority"), el.vecU8("data")]);
  function Sh(t, e, n, r) {
    return (null == t ? void 0 : t.length) ? (t[0].name ? n(t) : r(t)) : e();
  }
  function Bh(t, ...e) {
    if (t.args.length != e.length) throw new Error("Invalid argument length");
    const n = {};
    let r = 0;
    return (
      t.args.forEach((t) => {
        (n[t.name] = e[r]), (r += 1);
      }),
      n
    );
  }
  function xh(t, e = {}) {
    t.forEach((t) => {
      if (Ih(t)) xh(t.accounts, e[t.name]);
      else if (!e[t.name])
        throw new Error(`Account \`${t.name}\` not provided.`);
    });
  }
  function Th(t) {
    return t instanceof Ti ? t : new Ti(t);
  }
  class Rh extends TypeError {
    constructor(t, e) {
      let n;
      const { message: r, ...o } = t,
        { path: i } = t;
      super(0 === i.length ? r : "At path: " + i.join(".") + " -- " + r),
        (this.value = void 0),
        (this.key = void 0),
        (this.type = void 0),
        (this.refinement = void 0),
        (this.path = void 0),
        (this.branch = void 0),
        (this.failures = void 0),
        Object.assign(this, o),
        (this.name = this.constructor.name),
        (this.failures = () => {
          var r;
          return null != (r = n) ? r : (n = [t, ...e()]);
        });
    }
  }
  function Oh(t) {
    return "object" == typeof t && null != t;
  }
  function Mh(t) {
    return "string" == typeof t ? JSON.stringify(t) : "" + t;
  }
  function Nh(t, e, n, r) {
    if (!0 === t) return;
    !1 === t ? (t = {}) : "string" == typeof t && (t = { message: t });
    const { path: o, branch: i } = e,
      { type: s } = n,
      {
        refinement: a,
        message: c = "Expected a value of type `" +
          s +
          "`" +
          (a ? " with refinement `" + a + "`" : "") +
          ", but received: `" +
          Mh(r) +
          "`",
      } = t;
    return {
      value: r,
      type: s,
      refinement: a,
      key: o[o.length - 1],
      path: o,
      branch: i,
      ...t,
      message: c,
    };
  }
  function* Ph(t, e, n, r) {
    var o;
    (Oh((o = t)) && "function" == typeof o[Symbol.iterator]) || (t = [t]);
    for (const i of t) {
      const t = Nh(i, e, n, r);
      t && (yield t);
    }
  }
  function* Lh(t, e, n) {
    void 0 === n && (n = {});
    const { path: r = [], branch: o = [t], coerce: i = !1, mask: s = !1 } = n,
      a = { path: r, branch: o };
    if (
      i &&
      ((t = e.coercer(t, a)),
      s && "type" !== e.type && Oh(e.schema) && Oh(t) && !Array.isArray(t))
    )
      for (const u in t) void 0 === e.schema[u] && delete t[u];
    let c = !0;
    for (const u of e.validator(t, a)) (c = !1), yield [u, void 0];
    for (let [u, l, h] of e.entries(t, a)) {
      const e = Lh(l, h, {
        path: void 0 === u ? r : [...r, u],
        branch: void 0 === u ? o : [...o, l],
        coerce: i,
        mask: s,
      });
      for (const n of e)
        n[0]
          ? ((c = !1), yield [n[0], void 0])
          : i &&
            ((l = n[1]),
            void 0 === u
              ? (t = l)
              : t instanceof Map
              ? t.set(u, l)
              : t instanceof Set
              ? t.add(l)
              : Oh(t) && (t[u] = l));
    }
    if (c) for (const u of e.refiner(t, a)) (c = !1), yield [u, void 0];
    c && (yield [void 0, t]);
  }
  class zh {
    constructor(t) {
      (this.TYPE = void 0),
        (this.type = void 0),
        (this.schema = void 0),
        (this.coercer = void 0),
        (this.validator = void 0),
        (this.refiner = void 0),
        (this.entries = void 0);
      const {
        type: e,
        schema: n,
        validator: r,
        refiner: o,
        coercer: i = (t) => t,
        entries: s = function* () {},
      } = t;
      (this.type = e),
        (this.schema = n),
        (this.entries = s),
        (this.coercer = i),
        (this.validator = r ? (t, e) => Ph(r(t, e), e, this, t) : () => []),
        (this.refiner = o ? (t, e) => Ph(o(t, e), e, this, t) : () => []);
    }
    assert(t) {
      return (function (t, e) {
        const n = qh(t, e);
        if (n[0]) throw n[0];
      })(t, this);
    }
    create(t) {
      return Dh(t, this);
    }
    is(t) {
      return Uh(t, this);
    }
    mask(t) {
      return (function (t, e) {
        const n = qh(t, e, { coerce: !0, mask: !0 });
        if (n[0]) throw n[0];
        return n[1];
      })(t, this);
    }
    validate(t, e) {
      return void 0 === e && (e = {}), qh(t, this, e);
    }
  }
  function Dh(t, e) {
    const n = qh(t, e, { coerce: !0 });
    if (n[0]) throw n[0];
    return n[1];
  }
  function Uh(t, e) {
    return !qh(t, e)[0];
  }
  function qh(t, e, n) {
    void 0 === n && (n = {});
    const r = Lh(t, e, n),
      o = (function (t) {
        const { done: e, value: n } = t.next();
        return e ? void 0 : n;
      })(r);
    if (o[0]) {
      return [
        new Rh(o[0], function* () {
          for (const t of r) t[0] && (yield t[0]);
        }),
        void 0,
      ];
    }
    return [void 0, o[1]];
  }
  function Gh(t, e) {
    return new zh({ type: t, schema: null, validator: e });
  }
  function Wh(t) {
    return new zh({
      type: "array",
      schema: t,
      *entries(e) {
        if (t && Array.isArray(e))
          for (const [n, r] of e.entries()) yield [n, r, t];
      },
      coercer: (t) => (Array.isArray(t) ? t.slice() : t),
      validator: (t) =>
        Array.isArray(t) || "Expected an array value, but received: " + Mh(t),
    });
  }
  function Kh(t) {
    const e = Mh(t);
    return new zh({
      type: "literal",
      schema: t,
      validator: (n) =>
        n === t || "Expected the literal `" + e + "`, but received: " + Mh(n),
    });
  }
  function jh(t) {
    return new zh({
      ...t,
      validator: (e, n) => null === e || t.validator(e, n),
      refiner: (e, n) => null === e || t.refiner(e, n),
    });
  }
  function Hh() {
    return Gh(
      "number",
      (t) =>
        ("number" == typeof t && !isNaN(t)) ||
        "Expected a number, but received: " + Mh(t)
    );
  }
  function Vh(t) {
    return new zh({
      ...t,
      validator: (e, n) => void 0 === e || t.validator(e, n),
      refiner: (e, n) => void 0 === e || t.refiner(e, n),
    });
  }
  function Fh() {
    return Gh(
      "string",
      (t) => "string" == typeof t || "Expected a string, but received: " + Mh(t)
    );
  }
  function Yh(t) {
    const e = Object.keys(t);
    return new zh({
      type: "type",
      schema: t,
      *entries(n) {
        if (Oh(n)) for (const r of e) yield [r, n[r], t[r]];
      },
      validator: (t) => Oh(t) || "Expected an object, but received: " + Mh(t),
    });
  }
  function Zh(t) {
    const e = t.map((t) => t.type).join(" | ");
    return new zh({
      type: "union",
      schema: null,
      coercer: (e, n) =>
        (
          t.find((t) => {
            const [n] = t.validate(e, { coerce: !0 });
            return !n;
          }) || Jh()
        ).coercer(e, n),
      validator(n, r) {
        const o = [];
        for (const e of t) {
          const [...t] = Lh(n, e, r),
            [i] = t;
          if (!i[0]) return [];
          for (const [e] of t) e && o.push(e);
        }
        return [
          "Expected the value to satisfy a union of `" +
            e +
            "`, but received: " +
            Mh(n),
          ...o,
        ];
      },
    });
  }
  function Jh() {
    return Gh("unknown", () => !0);
  }
  async function Xh(t, e, n) {
    if (e.length <= 99) return await $h(t, e, n);
    {
      const i =
        ((r = e),
        (o = 99),
        Array.apply(0, new Array(Math.ceil(r.length / o))).map((t, e) =>
          r.slice(e * o, (e + 1) * o)
        ));
      return (await Promise.all(i.map((e) => $h(t, e, n)))).flat();
    }
    var r, o;
  }
  async function $h(t, e, n) {
    const r = null != n ? n : t.commitment,
      { value: o, context: i } = await t.getMultipleAccountsInfoAndContext(
        e,
        r
      );
    return o.map((t, n) =>
      null === t ? null : { publicKey: e[n], account: t, context: i }
    );
  }
  function Qh(t) {
    return (
      (e = ed(t)),
      (n = td),
      (r = (e) => ("error" in e ? e : { ...e, result: Dh(e.result, t) })),
      new zh({
        ...e,
        coercer: (t, o) => (Uh(t, n) ? e.coercer(r(t, o), o) : e.coercer(t, o)),
      })
    );
    var e, n, r;
  }
  const td = ed(Jh());
  function ed(t) {
    return Zh([
      Yh({ jsonrpc: Kh("2.0"), id: Fh(), result: t }),
      Yh({
        jsonrpc: Kh("2.0"),
        id: Fh(),
        error: Yh({ code: Jh(), message: Fh(), data: Vh(Gh("any", () => !0)) }),
      }),
    ]);
  }
  const nd =
    ((rd = Yh({
      err: jh(Zh([Yh({}), Fh()])),
      logs: jh(Wh(Fh())),
      accounts: Vh(
        jh(
          Wh(
            jh(
              Yh({
                executable: Gh("boolean", (t) => "boolean" == typeof t),
                owner: Fh(),
                lamports: Hh(),
                data: Wh(Fh()),
                rentEpoch: Vh(Hh()),
              })
            )
          )
        )
      ),
      unitsConsumed: Vh(Hh()),
    })),
    Qh(Yh({ context: Yh({ slot: Hh() }), value: rd })));
  var rd;
  class od {
    constructor(t, e, n = od.defaultOptions()) {
      (this.connection = t),
        (this.wallet = e),
        (this.opts = n),
        (this.publicKey = null == e ? void 0 : e.publicKey);
    }
    static defaultOptions() {
      return { preflightCommitment: "processed", commitment: "processed" };
    }
    static local(t, e = od.defaultOptions()) {
      throw new Error("Provider local is not available on browser.");
    }
    static env() {
      throw new Error("Provider env is not available on browser.");
    }
    async sendAndConfirm(t, e, n) {
      var r, o, i, s;
      if ((void 0 === n && (n = this.opts), kh(t))) e && t.sign(e);
      else if (
        ((t.feePayer =
          null !== (r = t.feePayer) && void 0 !== r
            ? r
            : this.wallet.publicKey),
        (t.recentBlockhash = (
          await this.connection.getLatestBlockhash(n.preflightCommitment)
        ).blockhash),
        e)
      )
        for (const u of e) t.partialSign(u);
      const a = (t = await this.wallet.signTransaction(t)).serialize();
      try {
        return await sd(this.connection, a, n);
      } catch (c) {
        if (c instanceof ad) {
          const e = Ah(
              kh(t)
                ? (null === (o = t.signatures) || void 0 === o
                    ? void 0
                    : o[0]) || new Uint8Array()
                : null !== (i = t.signature) && void 0 !== i
                ? i
                : new Uint8Array()
            ),
            n = kh(t) ? 0 : void 0,
            r = await this.connection.getTransaction(e, {
              commitment: "confirmed",
              maxSupportedTransactionVersion: n,
            });
          if (r) {
            const t =
              null === (s = r.meta) || void 0 === s ? void 0 : s.logMessages;
            throw t ? new fs(c.message, t) : c;
          }
          throw c;
        }
        throw c;
      }
    }
    async sendAll(t, e) {
      var n, r, o;
      void 0 === e && (e = this.opts);
      const i = (
        await this.connection.getLatestBlockhash(e.preflightCommitment)
      ).blockhash;
      let s = t.map((t) => {
        var e, n;
        if (kh(t.tx)) {
          let e = t.tx;
          return t.signers && e.sign(t.signers), e;
        }
        {
          let r = t.tx,
            o = null !== (e = t.signers) && void 0 !== e ? e : [];
          return (
            (r.feePayer =
              null !== (n = r.feePayer) && void 0 !== n
                ? n
                : this.wallet.publicKey),
            (r.recentBlockhash = i),
            o.forEach((t) => {
              r.partialSign(t);
            }),
            r
          );
        }
      });
      const a = await this.wallet.signAllTransactions(s),
        c = [];
      for (let l = 0; l < s.length; l += 1) {
        const t = a[l],
          i = t.serialize();
        try {
          c.push(await sd(this.connection, i, e));
        } catch (u) {
          if (u instanceof ad) {
            const e = Ah(
                kh(t)
                  ? (null === (n = t.signatures) || void 0 === n
                      ? void 0
                      : n[0]) || new Uint8Array()
                  : null !== (r = t.signature) && void 0 !== r
                  ? r
                  : new Uint8Array()
              ),
              i = kh(t) ? 0 : void 0,
              s = await this.connection.getTransaction(e, {
                commitment: "confirmed",
                maxSupportedTransactionVersion: i,
              });
            if (s) {
              const t =
                null === (o = s.meta) || void 0 === o ? void 0 : o.logMessages;
              throw t ? new fs(u.message, t) : u;
            }
            throw u;
          }
          throw u;
        }
      }
      return c;
    }
    async simulate(t, e, n, r) {
      let o,
        i = (
          await this.connection.getLatestBlockhash(
            null != n ? n : this.connection.commitment
          )
        ).blockhash;
      if (
        (kh(t)
          ? (e &&
              e.length > 0 &&
              (t.sign(e), (t = await this.wallet.signTransaction(t))),
            (o = await this.connection.simulateTransaction(t, {
              commitment: n,
            })))
          : ((t.feePayer = t.feePayer || this.wallet.publicKey),
            (t.recentBlockhash = i),
            e && e.length > 0 && (t = await this.wallet.signTransaction(t)),
            (o = await (async function (t, e, n, r, o) {
              var i;
              n && n.length > 0 && e.sign(...n);
              const s = e._compile(),
                a = s.serialize(),
                c = e._serialize(a).toString("base64"),
                u = {
                  encoding: "base64",
                  commitment: null != r ? r : t.commitment,
                };
              if (o) {
                const t = (Array.isArray(o) ? o : s.nonProgramIds()).map((t) =>
                  t.toBase58()
                );
                u.accounts = { encoding: "base64", addresses: t };
              }
              n && n.length > 0 && (u.sigVerify = !0);
              const l = [c, u],
                h = Dh(await t._rpcRequest("simulateTransaction", l), nd);
              if ("error" in h) {
                let t;
                if (
                  "data" in h.error &&
                  ((t =
                    null === (i = h.error.data) || void 0 === i
                      ? void 0
                      : i.logs),
                  t && Array.isArray(t))
                ) {
                  const e = "\n    ";
                  t.join(e);
                }
                throw new fs(
                  "failed to simulate transaction: " + h.error.message,
                  t
                );
              }
              return h.result;
            })(this.connection, t, e, n, r))),
        o.value.err)
      )
        throw new id(o.value);
      return o.value;
    }
  }
  class id extends Error {
    constructor(t, e) {
      super(e), (this.simulationResponse = t);
    }
  }
  async function sd(t, e, n) {
    const r = n
      ? {
          skipPreflight: n.skipPreflight,
          preflightCommitment: n.preflightCommitment || n.commitment,
          maxRetries: n.maxRetries,
          minContextSlot: n.minContextSlot,
        }
      : {};
    let o;
    const i = Date.now();
    for (; Date.now() - i < 6e4; )
      try {
        const i = await t.sendRawTransaction(e, r);
        if (null == n ? void 0 : n.blockhash)
          if (0 === r.maxRetries) {
            const e = AbortSignal.timeout(15e3);
            o = (
              await t.confirmTransaction(
                { abortSignal: e, signature: i, ...n.blockhash },
                n && n.commitment
              )
            ).value;
          } else
            o = (
              await t.confirmTransaction(
                { signature: i, ...n.blockhash },
                n && n.commitment
              )
            ).value;
        else o = (await t.confirmTransaction(i, n && n.commitment)).value;
        if (o.err)
          throw new ad(`Raw transaction ${i} failed (${JSON.stringify(o)})`);
        return i;
      } catch (s) {
        if ("TimeoutError" === s.name) continue;
        throw s;
      }
    throw Error("Transaction failed to confirm in 60s");
  }
  class ad extends Error {
    constructor(t) {
      super(t);
    }
  }
  function cd() {
    return od.local();
  }
  var ud =
      "undefined" != typeof globalThis
        ? globalThis
        : "undefined" != typeof window
        ? window
        : void 0 !== Uu
        ? Uu
        : "undefined" != typeof self
        ? self
        : {},
    ld = {};
  Object.defineProperty(ld, "__esModule", { value: !0 });
  var hd =
      (ld.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED =
      ld.ANCHOR_ERROR__REQUIRE_VIOLATED =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION =
      ld.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM =
      ld.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM =
      ld.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE =
      ld.ANCHOR_ERROR__CONSTRAINT_SPACE =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY =
      ld.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY =
      ld.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER =
      ld.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT =
      ld.ANCHOR_ERROR__CONSTRAINT_ZERO =
      ld.ANCHOR_ERROR__CONSTRAINT_ADDRESS =
      ld.ANCHOR_ERROR__CONSTRAINT_CLOSE =
      ld.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT =
      ld.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED =
      ld.ANCHOR_ERROR__CONSTRAINT_STATE =
      ld.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE =
      ld.ANCHOR_ERROR__CONSTRAINT_SEEDS =
      ld.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT =
      ld.ANCHOR_ERROR__CONSTRAINT_OWNER =
      ld.ANCHOR_ERROR__CONSTRAINT_RAW =
      ld.ANCHOR_ERROR__CONSTRAINT_SIGNER =
      ld.ANCHOR_ERROR__CONSTRAINT_HAS_ONE =
      ld.ANCHOR_ERROR__CONSTRAINT_MUT =
      ld.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB =
      ld.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY =
      ld.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM =
      ld.ANCHOR_ERROR__IDL_INSTRUCTION_STUB =
      ld.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE =
      ld.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE =
      ld.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND =
      ld.ANCHOR_ERROR__INSTRUCTION_MISSING =
        void 0),
    dd =
      (ld.ANCHOR_ERROR__DEPRECATED =
      ld.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION =
      ld.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT =
      ld.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH =
      ld.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS =
      ld.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT =
      ld.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH =
      ld.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT =
      ld.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA =
      ld.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED =
      ld.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED =
      ld.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER =
      ld.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE =
      ld.ANCHOR_ERROR__INVALID_PROGRAM_ID =
      ld.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM =
      ld.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE =
      ld.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS =
      ld.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE =
      ld.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE =
      ld.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH =
      ld.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND =
      ld.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET =
      ld.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED =
      ld.ANCHOR_ERROR__REQUIRE_GT_VIOLATED =
      ld.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED =
      ld.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED =
      ld.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED =
        void 0),
    fd = (ld.ANCHOR_ERROR__INSTRUCTION_MISSING = 100),
    pd = (ld.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = 101),
    md = (ld.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = 102),
    yd = (ld.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = 103),
    gd = (ld.ANCHOR_ERROR__IDL_INSTRUCTION_STUB = 1e3),
    wd = (ld.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = 1001),
    bd = (ld.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = 1002),
    vd = (ld.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = 1500),
    _d = (ld.ANCHOR_ERROR__CONSTRAINT_MUT = 2e3),
    kd = (ld.ANCHOR_ERROR__CONSTRAINT_HAS_ONE = 2001),
    Ad = (ld.ANCHOR_ERROR__CONSTRAINT_SIGNER = 2002),
    Ed = (ld.ANCHOR_ERROR__CONSTRAINT_RAW = 2003),
    Id = (ld.ANCHOR_ERROR__CONSTRAINT_OWNER = 2004),
    Cd = (ld.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = 2005),
    Sd = (ld.ANCHOR_ERROR__CONSTRAINT_SEEDS = 2006),
    Bd = (ld.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = 2007),
    xd = (ld.ANCHOR_ERROR__CONSTRAINT_STATE = 2008),
    Td = (ld.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = 2009),
    Rd = (ld.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = 2010),
    Od = (ld.ANCHOR_ERROR__CONSTRAINT_CLOSE = 2011),
    Md = (ld.ANCHOR_ERROR__CONSTRAINT_ADDRESS = 2012),
    Nd = (ld.ANCHOR_ERROR__CONSTRAINT_ZERO = 2013),
    Pd = (ld.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = 2014),
    Ld = (ld.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = 2015),
    zd = (ld.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = 2016),
    Dd = (ld.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = 2017),
    Ud = (ld.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = 2018),
    qd = (ld.ANCHOR_ERROR__CONSTRAINT_SPACE = 2019),
    Gd = (ld.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = 2020),
    Wd = (ld.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = 2021),
    Kd = (ld.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = 2022),
    jd = (ld.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = 2023),
    Hd = (ld.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = 2024),
    Vd =
      (ld.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = 2025),
    Fd =
      (ld.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = 2026),
    Yd =
      (ld.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = 2027),
    Zd =
      (ld.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = 2028),
    Jd =
      (ld.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = 2029),
    Xd = (ld.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = 2030),
    $d =
      (ld.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = 2031),
    Qd =
      (ld.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = 2032),
    tf = (ld.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = 2033),
    ef =
      (ld.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = 2034),
    nf = (ld.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = 2035),
    rf =
      (ld.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = 2036),
    of = (ld.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = 2037),
    sf =
      (ld.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = 2038),
    af =
      (ld.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = 2039),
    cf = (ld.ANCHOR_ERROR__REQUIRE_VIOLATED = 2500);
  hd = ld.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = 2501;
  var uf = (ld.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = 2502),
    lf = (ld.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = 2503),
    hf = (ld.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = 2504),
    df = (ld.ANCHOR_ERROR__REQUIRE_GT_VIOLATED = 2505),
    ff = (ld.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = 2506),
    pf = (ld.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = 3e3),
    mf = (ld.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = 3001),
    yf = (ld.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = 3002),
    gf = (ld.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = 3003),
    wf = (ld.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = 3004),
    bf = (ld.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = 3005),
    vf = (ld.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = 3006),
    _f = (ld.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = 3007),
    kf = (ld.ANCHOR_ERROR__INVALID_PROGRAM_ID = 3008),
    Af = (ld.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = 3009),
    Ef = (ld.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = 3010),
    If = (ld.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = 3011),
    Cf = (ld.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = 3012),
    Sf = (ld.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = 3013),
    Bf = (ld.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = 3014),
    xf = (ld.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = 3015),
    Tf = (ld.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = 3016),
    Rf = (ld.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = 3017),
    Of = (ld.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = 4100),
    Mf = (ld.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = 4101),
    Nf = (ld.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = 4102);
  dd = ld.ANCHOR_ERROR__DEPRECATED = 5e3;
  const Pf = new Map();
  function Lf(t) {
    return void 0 !== Pf.get(t);
  }
  class zf extends Error {
    constructor(t) {
      super(t), (this.name = "IdlError");
    }
  }
  class Df {
    constructor(t) {
      this.stack = t;
    }
    static parse(t) {
      var e;
      const n = /^Program (\w*) invoke/,
        r = /^Program \w* success/,
        o = [];
      for (let i = 0; i < t.length; i++) {
        if (r.exec(t[i])) {
          o.pop();
          continue;
        }
        const s = null === (e = n.exec(t[i])) || void 0 === e ? void 0 : e[1];
        s && o.push(new Ti(s));
      }
      return new Df(o);
    }
  }
  class Uf extends Error {
    constructor(t, e, n, r, o, i) {
      super(n.join("\n").replace("Program log: ", "")),
        (this.errorLogs = n),
        (this.logs = r),
        (this.error = {
          errorCode: t,
          errorMessage: e,
          comparedValues: i,
          origin: o,
        }),
        (this._programErrorStack = Df.parse(r));
    }
    static parse(t) {
      if (!t) return null;
      const e = t.findIndex((t) => t.startsWith("Program log: AnchorError"));
      if (-1 === e) return null;
      const n = t[e],
        r = [n];
      let o;
      if (e + 1 < t.length)
        if ("Program log: Left:" === t[e + 1]) {
          const n = /^Program log: (.*)$/,
            i = n.exec(t[e + 2])[1],
            s = n.exec(t[e + 4])[1];
          (o = [new Ti(i), new Ti(s)]), r.push(...t.slice(e + 1, e + 5));
        } else if (t[e + 1].startsWith("Program log: Left:")) {
          const n = /^Program log: (Left|Right): (.*)$/,
            i = n.exec(t[e + 1])[2],
            s = n.exec(t[e + 2])[2];
          r.push(...t.slice(e + 1, e + 3)), (o = [i, s]);
        }
      const i =
          /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(
            n
          ),
        s =
          /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(
            n
          ),
        a =
          /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(
            n
          );
      if (i) {
        const [e, n, s] = i.slice(1, 4),
          a = { code: e, number: parseInt(n) };
        return new Uf(a, s, r, t, void 0, o);
      }
      if (s) {
        const [e, n, i, a, c] = s.slice(1, 6),
          u = { code: i, number: parseInt(a) },
          l = { file: e, line: parseInt(n) };
        return new Uf(u, c, r, t, l, o);
      }
      if (a) {
        const [e, n, i, s] = a.slice(1, 5),
          c = e,
          u = { code: n, number: parseInt(i) };
        return new Uf(u, s, r, t, c, o);
      }
      return null;
    }
    get program() {
      return this._programErrorStack.stack[
        this._programErrorStack.stack.length - 1
      ];
    }
    get programErrorStack() {
      return this._programErrorStack.stack;
    }
    toString() {
      return this.message;
    }
  }
  class qf extends Error {
    constructor(t, e, n) {
      super(),
        (this.code = t),
        (this.msg = e),
        (this.logs = n),
        n && (this._programErrorStack = Df.parse(n));
    }
    static parse(t, e) {
      const n = t.toString();
      let r, o;
      if (n.includes("custom program error:")) {
        let t = n.split("custom program error: ");
        if (2 !== t.length) return null;
        r = t[1];
      } else {
        const t = n.match(/"Custom":([0-9]+)}/g);
        if (!t || t.length > 1) return null;
        r = t[0].match(/([0-9]+)/g)[0];
      }
      try {
        o = parseInt(r);
      } catch (s) {
        return null;
      }
      let i = e.get(o);
      return void 0 !== i
        ? new qf(o, i, t.logs)
        : ((i = Kf.get(o)), void 0 !== i ? new qf(o, i, t.logs) : null);
    }
    get program() {
      var t;
      return null === (t = this._programErrorStack) || void 0 === t
        ? void 0
        : t.stack[this._programErrorStack.stack.length - 1];
    }
    get programErrorStack() {
      var t;
      return null === (t = this._programErrorStack) || void 0 === t
        ? void 0
        : t.stack;
    }
    toString() {
      return this.msg;
    }
  }
  function Gf(t, e) {
    Lf("debug-logs"), 0;
    const n = Uf.parse(t.logs);
    if (n) return n;
    const r = qf.parse(t, e);
    if (r) return r;
    if (t.logs) {
      const e = {
        get: function (e, n) {
          return "programErrorStack" === n
            ? e.programErrorStack.stack
            : "program" === n
            ? e.programErrorStack.stack[t.programErrorStack.stack.length - 1]
            : Reflect.get(...arguments);
        },
      };
      return (t.programErrorStack = Df.parse(t.logs)), new Proxy(t, e);
    }
    return t;
  }
  const Wf = {
      InstructionMissing: fd,
      InstructionFallbackNotFound: pd,
      InstructionDidNotDeserialize: md,
      InstructionDidNotSerialize: yd,
      IdlInstructionStub: gd,
      IdlInstructionInvalidProgram: wd,
      IdlAccountNotEmpty: bd,
      EventInstructionStub: vd,
      ConstraintMut: _d,
      ConstraintHasOne: kd,
      ConstraintSigner: Ad,
      ConstraintRaw: Ed,
      ConstraintOwner: Id,
      ConstraintRentExempt: Cd,
      ConstraintSeeds: Sd,
      ConstraintExecutable: Bd,
      ConstraintState: xd,
      ConstraintAssociated: Td,
      ConstraintAssociatedInit: Rd,
      ConstraintClose: Od,
      ConstraintAddress: Md,
      ConstraintZero: Nd,
      ConstraintTokenMint: Pd,
      ConstraintTokenOwner: Ld,
      ConstraintMintMintAuthority: zd,
      ConstraintMintFreezeAuthority: Dd,
      ConstraintMintDecimals: Ud,
      ConstraintSpace: qd,
      ConstraintAccountIsNone: Gd,
      ConstraintTokenTokenProgram: Wd,
      ConstraintMintTokenProgram: Kd,
      ConstraintAssociatedTokenTokenProgram: jd,
      ConstraintMintGroupPointerExtension: Hd,
      ConstraintMintGroupPointerExtensionAuthority: Vd,
      ConstraintMintGroupPointerExtensionGroupAddress: Fd,
      ConstraintMintGroupMemberPointerExtension: Yd,
      ConstraintMintGroupMemberPointerExtensionAuthority: Zd,
      ConstraintMintGroupMemberPointerExtensionMemberAddress: Jd,
      ConstraintMintMetadataPointerExtension: Xd,
      ConstraintMintMetadataPointerExtensionAuthority: $d,
      ConstraintMintMetadataPointerExtensionMetadataAddress: Qd,
      ConstraintMintCloseAuthorityExtension: tf,
      ConstraintMintCloseAuthorityExtensionAuthority: ef,
      ConstraintMintPermanentDelegateExtension: nf,
      ConstraintMintPermanentDelegateExtensionDelegate: rf,
      ConstraintMintTransferHookExtension: of,
      ConstraintMintTransferHookExtensionAuthority: sf,
      ConstraintMintTransferHookExtensionProgramId: af,
      RequireViolated: cf,
      RequireEqViolated: hd,
      RequireKeysEqViolated: uf,
      RequireNeqViolated: lf,
      RequireKeysNeqViolated: hf,
      RequireGtViolated: df,
      RequireGteViolated: ff,
      AccountDiscriminatorAlreadySet: pf,
      AccountDiscriminatorNotFound: mf,
      AccountDiscriminatorMismatch: yf,
      AccountDidNotDeserialize: gf,
      AccountDidNotSerialize: wf,
      AccountNotEnoughKeys: bf,
      AccountNotMutable: vf,
      AccountOwnedByWrongProgram: _f,
      InvalidProgramId: kf,
      InvalidProgramExecutable: Af,
      AccountNotSigner: Ef,
      AccountNotSystemOwned: If,
      AccountNotInitialized: Cf,
      AccountNotProgramData: Sf,
      AccountNotAssociatedTokenAccount: Bf,
      AccountSysvarMismatch: xf,
      AccountReallocExceedsLimit: Tf,
      AccountDuplicateReallocs: Rf,
      DeclaredProgramIdMismatch: Of,
      TryingToInitPayerAsProgramAccount: Mf,
      InvalidNumericConversion: Nf,
      Deprecated: dd,
    },
    Kf = new Map([
      [Wf.InstructionMissing, "Instruction discriminator not provided"],
      [Wf.InstructionFallbackNotFound, "Fallback functions are not supported"],
      [
        Wf.InstructionDidNotDeserialize,
        "The program could not deserialize the given instruction",
      ],
      [
        Wf.InstructionDidNotSerialize,
        "The program could not serialize the given instruction",
      ],
      [
        Wf.IdlInstructionStub,
        "The program was compiled without idl instructions",
      ],
      [
        Wf.IdlInstructionInvalidProgram,
        "The transaction was given an invalid program for the IDL instruction",
      ],
      [
        Wf.IdlAccountNotEmpty,
        "IDL account must be empty in order to resize, try closing first",
      ],
      [
        Wf.EventInstructionStub,
        "The program was compiled without `event-cpi` feature",
      ],
      [Wf.ConstraintMut, "A mut constraint was violated"],
      [Wf.ConstraintHasOne, "A has one constraint was violated"],
      [Wf.ConstraintSigner, "A signer constraint was violated"],
      [Wf.ConstraintRaw, "A raw constraint was violated"],
      [Wf.ConstraintOwner, "An owner constraint was violated"],
      [Wf.ConstraintRentExempt, "A rent exemption constraint was violated"],
      [Wf.ConstraintSeeds, "A seeds constraint was violated"],
      [Wf.ConstraintExecutable, "An executable constraint was violated"],
      [
        Wf.ConstraintState,
        "Deprecated Error, feel free to replace with something else",
      ],
      [Wf.ConstraintAssociated, "An associated constraint was violated"],
      [
        Wf.ConstraintAssociatedInit,
        "An associated init constraint was violated",
      ],
      [Wf.ConstraintClose, "A close constraint was violated"],
      [Wf.ConstraintAddress, "An address constraint was violated"],
      [Wf.ConstraintZero, "Expected zero account discriminant"],
      [Wf.ConstraintTokenMint, "A token mint constraint was violated"],
      [Wf.ConstraintTokenOwner, "A token owner constraint was violated"],
      [
        Wf.ConstraintMintMintAuthority,
        "A mint mint authority constraint was violated",
      ],
      [
        Wf.ConstraintMintFreezeAuthority,
        "A mint freeze authority constraint was violated",
      ],
      [Wf.ConstraintMintDecimals, "A mint decimals constraint was violated"],
      [Wf.ConstraintSpace, "A space constraint was violated"],
      [
        Wf.ConstraintAccountIsNone,
        "A required account for the constraint is None",
      ],
      [
        Wf.ConstraintTokenTokenProgram,
        "A token account token program constraint was violated",
      ],
      [
        Wf.ConstraintMintTokenProgram,
        "A mint token program constraint was violated",
      ],
      [
        Wf.ConstraintAssociatedTokenTokenProgram,
        "An associated token account token program constraint was violated",
      ],
      [
        Wf.ConstraintMintGroupPointerExtension,
        "A group pointer extension constraint was violated",
      ],
      [
        Wf.ConstraintMintGroupPointerExtensionAuthority,
        "A group pointer extension authority constraint was violated",
      ],
      [
        Wf.ConstraintMintGroupPointerExtensionGroupAddress,
        "A group pointer extension group address constraint was violated",
      ],
      [
        Wf.ConstraintMintGroupMemberPointerExtension,
        "A group member pointer extension constraint was violated",
      ],
      [
        Wf.ConstraintMintGroupMemberPointerExtensionAuthority,
        "A group member pointer extension authority constraint was violated",
      ],
      [
        Wf.ConstraintMintGroupMemberPointerExtensionMemberAddress,
        "A group member pointer extension group address constraint was violated",
      ],
      [
        Wf.ConstraintMintMetadataPointerExtension,
        "A metadata pointer extension constraint was violated",
      ],
      [
        Wf.ConstraintMintMetadataPointerExtensionAuthority,
        "A metadata pointer extension authority constraint was violated",
      ],
      [
        Wf.ConstraintMintMetadataPointerExtensionMetadataAddress,
        "A metadata pointer extension metadata address constraint was violated",
      ],
      [
        Wf.ConstraintMintCloseAuthorityExtension,
        "A close authority constraint was violated",
      ],
      [
        Wf.ConstraintMintCloseAuthorityExtensionAuthority,
        "A close authority extension authority constraint was violated",
      ],
      [
        Wf.ConstraintMintPermanentDelegateExtension,
        "A permanent delegate extension constraint was violated",
      ],
      [
        Wf.ConstraintMintPermanentDelegateExtensionDelegate,
        "A permanent delegate extension delegate constraint was violated",
      ],
      [
        Wf.ConstraintMintTransferHookExtension,
        "A transfer hook extension constraint was violated",
      ],
      [
        Wf.ConstraintMintTransferHookExtensionAuthority,
        "A transfer hook extension authority constraint was violated",
      ],
      [
        Wf.ConstraintMintTransferHookExtensionProgramId,
        "A transfer hook extension transfer hook program id constraint was violated",
      ],
      [Wf.RequireViolated, "A require expression was violated"],
      [Wf.RequireEqViolated, "A require_eq expression was violated"],
      [Wf.RequireKeysEqViolated, "A require_keys_eq expression was violated"],
      [Wf.RequireNeqViolated, "A require_neq expression was violated"],
      [Wf.RequireKeysNeqViolated, "A require_keys_neq expression was violated"],
      [Wf.RequireGtViolated, "A require_gt expression was violated"],
      [Wf.RequireGteViolated, "A require_gte expression was violated"],
      [
        Wf.AccountDiscriminatorAlreadySet,
        "The account discriminator was already set on this account",
      ],
      [
        Wf.AccountDiscriminatorNotFound,
        "No discriminator was found on the account",
      ],
      [
        Wf.AccountDiscriminatorMismatch,
        "Account discriminator did not match what was expected",
      ],
      [Wf.AccountDidNotDeserialize, "Failed to deserialize the account"],
      [Wf.AccountDidNotSerialize, "Failed to serialize the account"],
      [
        Wf.AccountNotEnoughKeys,
        "Not enough account keys given to the instruction",
      ],
      [Wf.AccountNotMutable, "The given account is not mutable"],
      [
        Wf.AccountOwnedByWrongProgram,
        "The given account is owned by a different program than expected",
      ],
      [Wf.InvalidProgramId, "Program ID was not as expected"],
      [Wf.InvalidProgramExecutable, "Program account is not executable"],
      [Wf.AccountNotSigner, "The given account did not sign"],
      [
        Wf.AccountNotSystemOwned,
        "The given account is not owned by the system program",
      ],
      [
        Wf.AccountNotInitialized,
        "The program expected this account to be already initialized",
      ],
      [
        Wf.AccountNotProgramData,
        "The given account is not a program data account",
      ],
      [
        Wf.AccountNotAssociatedTokenAccount,
        "The given account is not the associated token account",
      ],
      [
        Wf.AccountSysvarMismatch,
        "The given public key does not match the required sysvar",
      ],
      [
        Wf.AccountReallocExceedsLimit,
        "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit",
      ],
      [
        Wf.AccountDuplicateReallocs,
        "The account was duplicated for more than one reallocation",
      ],
      [
        Wf.DeclaredProgramIdMismatch,
        "The declared program id does not match the actual program id",
      ],
      [
        Wf.TryingToInitPayerAsProgramAccount,
        "You cannot/should not initialize the payer account as a program account",
      ],
      [
        Wf.InvalidNumericConversion,
        "The program could not perform the numeric conversion, out of range integral type conversion attempted",
      ],
      [
        Wf.Deprecated,
        "The API being used is deprecated and should no longer be used",
      ],
    ]);
  class jf {
    static fieldLayout(t, e = [], n) {
      const r = t.name;
      switch (t.type) {
        case "bool":
          return el.bool(r);
        case "u8":
          return el.u8(r);
        case "i8":
          return el.i8(r);
        case "u16":
          return el.u16(r);
        case "i16":
          return el.i16(r);
        case "u32":
          return el.u32(r);
        case "i32":
          return el.i32(r);
        case "f32":
          return el.f32(r);
        case "u64":
          return el.u64(r);
        case "i64":
          return el.i64(r);
        case "f64":
          return el.f64(r);
        case "u128":
          return el.u128(r);
        case "i128":
          return el.i128(r);
        case "u256":
          return el.u256(r);
        case "i256":
          return el.i256(r);
        case "bytes":
          return el.vecU8(r);
        case "string":
          return el.str(r);
        case "pubkey":
          return el.publicKey(r);
        default:
          if ("option" in t.type)
            return el.option(jf.fieldLayout({ type: t.type.option }, e, n), r);
          if ("vec" in t.type)
            return el.vec(jf.fieldLayout({ type: t.type.vec }, e, n), r);
          if ("array" in t.type) {
            let [o, i] = t.type.array;
            return (
              (i = jf.resolveArrayLen(i, n)),
              el.array(jf.fieldLayout({ type: o }, e, n), i, r)
            );
          }
          if ("defined" in t.type) {
            if (!e) throw new zf("User defined types not provided");
            const o = t.type.defined.name,
              i = e.find((t) => t.name === o);
            if (!i) throw new zf(`Type not found: ${t.name}`);
            return jf.typeDefLayout({
              typeDef: i,
              types: e,
              genericArgs: null != n ? n : t.type.defined.generics,
              name: r,
            });
          }
          if ("generic" in t.type) {
            const r = null == n ? void 0 : n.at(0);
            if ("type" !== (null == r ? void 0 : r.kind))
              throw new zf(`Invalid generic field: ${t.name}`);
            return jf.fieldLayout({ ...t, type: r.type }, e);
          }
          throw new zf(`Not yet implemented: ${JSON.stringify(t.type)}`);
      }
    }
    static typeDefLayout({ typeDef: t, types: e, name: n, genericArgs: r }) {
      switch (t.type.kind) {
        case "struct": {
          const o = Sh(
            t.type.fields,
            () => [],
            (n) =>
              n.map((n) => {
                const o = r
                  ? jf.resolveGenericArgs({
                      type: n.type,
                      typeDef: t,
                      genericArgs: r,
                    })
                  : r;
                return jf.fieldLayout(n, e, o);
              }),
            (n) =>
              n.map((n, o) => {
                const i = r
                  ? jf.resolveGenericArgs({
                      type: n,
                      typeDef: t,
                      genericArgs: r,
                    })
                  : r;
                return jf.fieldLayout({ name: o.toString(), type: n }, e, i);
              })
          );
          return el.struct(o, n);
        }
        case "enum": {
          const o = t.type.variants.map((n) => {
            const o = Sh(
              n.fields,
              () => [],
              (n) =>
                n.map((n) => {
                  const o = r
                    ? jf.resolveGenericArgs({
                        type: n.type,
                        typeDef: t,
                        genericArgs: r,
                      })
                    : r;
                  return jf.fieldLayout(n, e, o);
                }),
              (n) =>
                n.map((n, o) => {
                  const i = r
                    ? jf.resolveGenericArgs({
                        type: n,
                        typeDef: t,
                        genericArgs: r,
                      })
                    : r;
                  return jf.fieldLayout({ name: o.toString(), type: n }, e, i);
                })
            );
            return el.struct(o, n.name);
          });
          return void 0 !== n ? el.rustEnum(o).replicate(n) : el.rustEnum(o, n);
        }
        case "type":
          return jf.fieldLayout({ type: t.type.alias, name: n }, e);
      }
    }
    static typeSize(t, e, n) {
      var r;
      switch (t) {
        case "bool":
        case "u8":
        case "i8":
        case "bytes":
        case "string":
          return 1;
        case "i16":
        case "u16":
          return 2;
        case "u32":
        case "i32":
        case "f32":
          return 4;
        case "u64":
        case "i64":
        case "f64":
          return 8;
        case "u128":
        case "i128":
          return 16;
        case "u256":
        case "i256":
        case "pubkey":
          return 32;
        default:
          if ("option" in t) return 1 + jf.typeSize(t.option, e, n);
          if ("coption" in t) return 4 + jf.typeSize(t.coption, e, n);
          if ("vec" in t) return 1;
          if ("array" in t) {
            let [r, o] = t.array;
            return (o = jf.resolveArrayLen(o, n)), jf.typeSize(r, e, n) * o;
          }
          if ("defined" in t) {
            const o =
              null === (r = e.types) || void 0 === r
                ? void 0
                : r.find((e) => e.name === t.defined.name);
            if (!o) throw new zf(`Type not found: ${JSON.stringify(t)}`);
            const i = (r) => {
              const i = null != n ? n : t.defined.generics,
                s = i
                  ? jf.resolveGenericArgs({
                      type: r,
                      typeDef: o,
                      genericArgs: i,
                    })
                  : i;
              return jf.typeSize(r, e, s);
            };
            switch (o.type.kind) {
              case "struct":
                return Sh(
                  o.type.fields,
                  () => [0],
                  (t) => t.map((t) => i(t.type)),
                  (t) => t.map((t) => i(t))
                ).reduce((t, e) => t + e, 0);
              case "enum": {
                const t = o.type.variants.map((t) =>
                  Sh(
                    t.fields,
                    () => [0],
                    (t) => t.map((t) => i(t.type)),
                    (t) => t.map((t) => i(t))
                  ).reduce((t, e) => t + e, 0)
                );
                return Math.max(...t) + 1;
              }
              case "type":
                return jf.typeSize(o.type.alias, e, n);
            }
          }
          if ("generic" in t) {
            const r = null == n ? void 0 : n.at(0);
            if ("type" !== (null == r ? void 0 : r.kind))
              throw new zf(`Invalid generic: ${t.generic}`);
            return jf.typeSize(r.type, e, n);
          }
          throw new Error(`Invalid type ${JSON.stringify(t)}`);
      }
    }
    static resolveArrayLen(t, e) {
      if ("number" == typeof t) return t;
      if (e) {
        const n = e.find((t) => "const" === t.kind);
        "const" === (null == n ? void 0 : n.kind) && (t = +n.value);
      }
      if ("number" != typeof t)
        throw new zf("Generic array length did not resolve");
      return t;
    }
    static resolveGenericArgs({
      type: t,
      typeDef: e,
      genericArgs: n,
      isDefined: r,
    }) {
      if ("object" != typeof t) return null;
      for (const o in e.generics) {
        const i = e.generics[o];
        if ("generic" in t && i.name === t.generic) return [n[o]];
        if ("option" in t) {
          const o = jf.resolveGenericArgs({
            type: t.option,
            typeDef: e,
            genericArgs: n,
            isDefined: r,
          });
          if (!o || !r) return o;
          if ("type" === o[0].kind)
            return [{ kind: "type", type: { option: o[0].type } }];
        }
        if ("vec" in t) {
          const o = jf.resolveGenericArgs({
            type: t.vec,
            typeDef: e,
            genericArgs: n,
            isDefined: r,
          });
          if (!o || !r) return o;
          if ("type" === o[0].kind)
            return [{ kind: "type", type: { vec: o[0].type } }];
        }
        if ("array" in t) {
          const [s, a] = t.array,
            c = "object" == typeof a,
            u =
              jf.resolveGenericArgs({
                type: s,
                typeDef: e,
                genericArgs: n,
                isDefined: r,
              }) || [];
          if (c) {
            const t = e.generics.findIndex((t) => t.name === a.generic);
            -1 !== t && u.push(n[t]);
          }
          if (u.length > 0) {
            if (!r) return u;
            if ("type" === u[0].kind && "const" === u[1].kind)
              return [
                { kind: "type", type: { array: [u[0].type, +u[1].value] } },
              ];
          }
          if (c && i.name === a.generic) {
            const t = n[o];
            return r ? [{ kind: "type", type: { array: [s, +t.value] } }] : [t];
          }
          return null;
        }
        if ("defined" in t)
          return t.defined.generics
            ? t.defined.generics
                .flatMap((t) => {
                  switch (t.kind) {
                    case "type":
                      return jf.resolveGenericArgs({
                        type: t.type,
                        typeDef: e,
                        genericArgs: n,
                        isDefined: !0,
                      });
                    case "const":
                      return [t];
                  }
                })
                .filter((t) => null !== t)
            : null;
      }
      return null;
    }
  }
  class Hf {
    constructor(t) {
      this.idl = t;
      const e = t.instructions.map((e) => {
        const n = e.name,
          r = e.args.map((e) => jf.fieldLayout(e, t.types)),
          o = el.struct(r, n);
        return [n, { discriminator: e.discriminator, layout: o }];
      });
      this.ixLayouts = new Map(e);
    }
    encode(t, e) {
      const n = X.alloc(1e3),
        r = this.ixLayouts.get(t);
      if (!r) throw new Error(`Unknown method: ${t}`);
      const o = r.layout.encode(e, n),
        i = n.slice(0, o);
      return X.concat([X.from(r.discriminator), i]);
    }
    decode(t, e = "hex") {
      "string" == typeof t &&
        (t = "hex" === e ? X.from(t, "hex") : Hu.decode(t));
      for (const [n, r] of this.ixLayouts) {
        const e = t.subarray(0, r.discriminator.length);
        if (e.equals(X.from(r.discriminator)))
          return { name: n, data: r.layout.decode(t.subarray(e.length)) };
      }
      return null;
    }
    format(t, e) {
      return Vf.format(t, e, this.idl);
    }
  }
  class Vf {
    static format(t, e, n) {
      const r = n.instructions.find((e) => t.name === e.name);
      if (!r) return void 0, null;
      const o = r.args.map((e) => ({
          name: e.name,
          type: Vf.formatIdlType(e.type),
          data: Vf.formatIdlData(e, t.data[e.name], n.types),
        })),
        i = Vf.flattenIdlAccounts(r.accounts);
      return {
        args: o,
        accounts: e.map((t, e) =>
          e < i.length ? { name: i[e].name, ...t } : { name: void 0, ...t }
        ),
      };
    }
    static formatIdlType(t) {
      if ("string" == typeof t) return t;
      if ("option" in t) return `Option<${this.formatIdlType(t.option)}>`;
      if ("coption" in t) return `COption<${this.formatIdlType(t.coption)}>`;
      if ("vec" in t) return `Vec<${this.formatIdlType(t.vec)}>`;
      if ("array" in t) return `Array<${t.array[0]}; ${t.array[1]}>`;
      if ("defined" in t) {
        const e = t.defined.name;
        if (t.defined.generics) {
          return `${e}<${t.defined.generics
            .map((t) => {
              switch (t.kind) {
                case "type":
                  return Vf.formatIdlType(t.type);
                case "const":
                  return t.value;
              }
            })
            .join(", ")}>`;
        }
        return e;
      }
      throw new Error(`Unknown IDL type: ${t}`);
    }
    static formatIdlData(t, e, n) {
      if ("string" == typeof t.type) return e.toString();
      if ("vec" in t.type)
        return (
          "[" +
          e
            .map((e) =>
              this.formatIdlData({ name: "", type: t.type.vec }, e, n)
            )
            .join(", ") +
          "]"
        );
      if ("option" in t.type)
        return null === e
          ? "null"
          : this.formatIdlData({ name: "", type: t.type.option }, e, n);
      if ("defined" in t.type) {
        if (!n) throw new Error("User defined types not provided");
        const r = t.type.defined.name,
          o = n.find((t) => t.name === r);
        if (!o) throw new Error(`Type not found: ${r}`);
        return Vf.formatIdlDataDefined(o, e, n);
      }
      return "unknown";
    }
    static formatIdlDataDefined(t, e, n) {
      switch (t.type.kind) {
        case "struct":
          return (
            "{ " +
            Sh(
              t.type.fields,
              () => "",
              (t) =>
                Object.entries(e)
                  .map(([e, r]) => {
                    const o = t.find((t) => t.name === e);
                    if (!o) throw new Error(`Field not found: ${e}`);
                    return e + ": " + Vf.formatIdlData(o, r, n);
                  })
                  .join(", "),
              (t) =>
                Object.entries(e)
                  .map(
                    ([e, r]) =>
                      e +
                      ": " +
                      Vf.formatIdlData({ name: "", type: t[e] }, r, n)
                  )
                  .join(", ")
            ) +
            " }"
          );
        case "enum": {
          const r = Object.keys(e)[0],
            o = t.type.variants.find((t) => t.name === r);
          if (!o) throw new Error(`Unable to find variant: ${r}`);
          const i = e[r];
          return Sh(
            o.fields,
            () => r,
            (t) => {
              const e = Object.keys(i)
                .map((e) => {
                  const r = i[e],
                    o = t.find((t) => t.name === e);
                  if (!o) throw new Error(`Field not found: ${e}`);
                  return e + ": " + Vf.formatIdlData(o, r, n);
                })
                .join(", ");
              return `${r} { ${e} }`;
            },
            (t) => {
              const e = Object.entries(i)
                .map(
                  ([e, r]) =>
                    e + ": " + Vf.formatIdlData({ name: "", type: t[e] }, r, n)
                )
                .join(", ");
              return `${r} { ${e} }`;
            }
          );
        }
        case "type":
          return Vf.formatIdlType(t.type.alias);
      }
    }
    static flattenIdlAccounts(t, e) {
      return t
        .map((t) => {
          const n = (function (t) {
            const e = t.replace(/([A-Z])/g, " $1");
            return e.charAt(0).toUpperCase() + e.slice(1);
          })(t.name);
          if (t.hasOwnProperty("accounts")) {
            const r = e ? `${e} > ${n}` : n;
            return Vf.flattenIdlAccounts(t.accounts, r);
          }
          return { ...t, name: e ? `${e} > ${n}` : n };
        })
        .flat();
    }
  }
  class Ff {
    constructor(t) {
      if (((this.idl = t), !t.accounts))
        return (this.accountLayouts = new Map()), void 0;
      const e = t.types;
      if (!e) throw new Error("Accounts require `idl.types`");
      const n = t.accounts.map((t) => {
        const n = e.find((e) => e.name === t.name);
        if (!n) throw new Error(`Account not found: ${t.name}`);
        return [
          t.name,
          {
            discriminator: t.discriminator,
            layout: jf.typeDefLayout({ typeDef: n, types: e }),
          },
        ];
      });
      this.accountLayouts = new Map(n);
    }
    async encode(t, e) {
      const n = X.alloc(1e3),
        r = this.accountLayouts.get(t);
      if (!r) throw new Error(`Unknown account: ${t}`);
      const o = r.layout.encode(e, n),
        i = n.slice(0, o),
        s = this.accountDiscriminator(t);
      return X.concat([s, i]);
    }
    decode(t, e) {
      const n = this.accountDiscriminator(t);
      if (n.compare(e.slice(0, n.length)))
        throw new Error("Invalid account discriminator");
      return this.decodeUnchecked(t, e);
    }
    decodeAny(t) {
      for (const [e, n] of this.accountLayouts) {
        if (
          t.subarray(0, n.discriminator.length).equals(X.from(n.discriminator))
        )
          return this.decodeUnchecked(e, t);
      }
      throw new Error("Account not found");
    }
    decodeUnchecked(t, e) {
      const n = this.accountDiscriminator(t),
        r = e.subarray(n.length),
        o = this.accountLayouts.get(t);
      if (!o) throw new Error(`Unknown account: ${t}`);
      return o.layout.decode(r);
    }
    memcmp(t, e) {
      const n = this.accountDiscriminator(t);
      return { offset: 0, bytes: Hu.encode(e ? X.concat([n, e]) : n) };
    }
    size(t) {
      return (
        this.accountDiscriminator(t).length +
        jf.typeSize({ defined: { name: t } }, this.idl)
      );
    }
    accountDiscriminator(t) {
      var e;
      const n =
        null === (e = this.idl.accounts) || void 0 === e
          ? void 0
          : e.find((e) => e.name === t);
      if (!n) throw new Error(`Account not found: ${t}`);
      return X.from(n.discriminator);
    }
  }
  class Yf {
    constructor(t) {
      if (!t.events) return (this.layouts = new Map()), void 0;
      const e = t.types;
      if (!e) throw new Error("Events require `idl.types`");
      const n = t.events.map((t) => {
        const n = e.find((e) => e.name === t.name);
        if (!n) throw new Error(`Event not found: ${t.name}`);
        return [
          t.name,
          {
            discriminator: t.discriminator,
            layout: jf.typeDefLayout({ typeDef: n, types: e }),
          },
        ];
      });
      this.layouts = new Map(n);
    }
    decode(t) {
      let e;
      try {
        e = Eh(t);
      } catch (n) {
        return null;
      }
      for (const [r, o] of this.layouts) {
        const t = e.subarray(0, o.discriminator.length);
        if (t.equals(X.from(o.discriminator)))
          return { name: r, data: o.layout.decode(e.subarray(t.length)) };
      }
      return null;
    }
  }
  class Zf {
    constructor(t) {
      const e = t.types;
      if (!e) return (this.typeLayouts = new Map()), void 0;
      const n = e
        .filter((t) => !t.generics)
        .map((t) => [t.name, jf.typeDefLayout({ typeDef: t, types: e })]);
      this.typeLayouts = new Map(n);
    }
    encode(t, e) {
      const n = X.alloc(1e3),
        r = this.typeLayouts.get(t);
      if (!r) throw new Error(`Unknown type: ${t}`);
      const o = r.encode(e, n);
      return n.slice(0, o);
    }
    decode(t, e) {
      const n = this.typeLayouts.get(t);
      if (!n) throw new Error(`Unknown type: ${t}`);
      return n.decode(e);
    }
  }
  class Jf {
    constructor(t) {
      (this.instruction = new Hf(t)),
        (this.accounts = new Ff(t)),
        (this.events = new Yf(t)),
        (this.types = new Zf(t));
    }
  }
  class Xf {
    constructor(t, e) {
      if (!Number.isInteger(t)) throw new TypeError("span must be an integer");
      (this.span = t), (this.property = e);
    }
    makeDestinationObject() {
      return {};
    }
    decode(t, e) {
      throw new Error("Layout is abstract");
    }
    encode(t, e, n) {
      throw new Error("Layout is abstract");
    }
    getSpan(t, e) {
      if (0 > this.span) throw new RangeError("indeterminate span");
      return this.span;
    }
    replicate(t) {
      const e = Object.create(this.constructor.prototype);
      return Object.assign(e, this), (e.property = t), e;
    }
    fromArray(t) {}
  }
  var $f = Xf;
  class Qf extends Xf {
    isCount() {
      throw new Error("ExternalLayout is abstract");
    }
  }
  class tp extends Qf {
    constructor(t, e, n) {
      if (!(t instanceof Xf)) throw new TypeError("layout must be a Layout");
      if (void 0 === e) e = 0;
      else if (!Number.isInteger(e))
        throw new TypeError("offset must be integer or undefined");
      super(t.span, n || t.property), (this.layout = t), (this.offset = e);
    }
    isCount() {
      return this.layout instanceof ep || this.layout instanceof np;
    }
    decode(t, e) {
      return void 0 === e && (e = 0), this.layout.decode(t, e + this.offset);
    }
    encode(t, e, n) {
      return void 0 === n && (n = 0), this.layout.encode(t, e, n + this.offset);
    }
  }
  class ep extends Xf {
    constructor(t, e) {
      if ((super(t, e), 6 < this.span))
        throw new RangeError("span must not exceed 6 bytes");
    }
    decode(t, e) {
      return void 0 === e && (e = 0), t.readUIntLE(e, this.span);
    }
    encode(t, e, n) {
      return void 0 === n && (n = 0), e.writeUIntLE(t, n, this.span), this.span;
    }
  }
  class np extends Xf {
    constructor(t, e) {
      if ((super(t, e), 6 < this.span))
        throw new RangeError("span must not exceed 6 bytes");
    }
    decode(t, e) {
      return void 0 === e && (e = 0), t.readUIntBE(e, this.span);
    }
    encode(t, e, n) {
      return void 0 === n && (n = 0), e.writeUIntBE(t, n, this.span), this.span;
    }
  }
  const rp = Math.pow(2, 32);
  function op(t) {
    const e = Math.floor(t / rp);
    return { hi32: e, lo32: t - e * rp };
  }
  function ip(t, e) {
    return t * rp + e;
  }
  class sp extends Xf {
    constructor(t) {
      super(8, t);
    }
    decode(t, e) {
      void 0 === e && (e = 0);
      const n = t.readUInt32LE(e);
      return ip(t.readUInt32LE(e + 4), n);
    }
    encode(t, e, n) {
      void 0 === n && (n = 0);
      const r = op(t);
      return e.writeUInt32LE(r.lo32, n), e.writeUInt32LE(r.hi32, n + 4), 8;
    }
  }
  class ap extends Xf {
    constructor(t) {
      super(8, t);
    }
    decode(t, e) {
      void 0 === e && (e = 0);
      const n = t.readUInt32LE(e);
      return ip(t.readInt32LE(e + 4), n);
    }
    encode(t, e, n) {
      void 0 === n && (n = 0);
      const r = op(t);
      return e.writeUInt32LE(r.lo32, n), e.writeInt32LE(r.hi32, n + 4), 8;
    }
  }
  class cp extends Xf {
    constructor(t, e, n) {
      if (!Array.isArray(t) || !t.reduce((t, e) => t && e instanceof Xf, !0))
        throw new TypeError("fields must be array of Layout instances");
      "boolean" == typeof e && void 0 === n && ((n = e), (e = void 0));
      for (const i of t)
        if (0 > i.span && void 0 === i.property)
          throw new Error(
            "fields cannot contain unnamed variable-length layout"
          );
      let r = -1;
      try {
        r = t.reduce((t, e) => t + e.getSpan(), 0);
      } catch (o) {}
      super(r, e), (this.fields = t), (this.decodePrefixes = !!n);
    }
    getSpan(t, e) {
      if (0 <= this.span) return this.span;
      void 0 === e && (e = 0);
      let n = 0;
      try {
        n = this.fields.reduce((n, r) => {
          const o = r.getSpan(t, e);
          return (e += o), n + o;
        }, 0);
      } catch (r) {
        throw new RangeError("indeterminate span");
      }
      return n;
    }
    decode(t, e) {
      void 0 === e && (e = 0);
      const n = this.makeDestinationObject();
      for (const r of this.fields)
        if (
          (void 0 !== r.property && (n[r.property] = r.decode(t, e)),
          (e += r.getSpan(t, e)),
          this.decodePrefixes && t.length === e)
        )
          break;
      return n;
    }
    encode(t, e, n) {
      void 0 === n && (n = 0);
      const r = n;
      let o = 0,
        i = 0;
      for (const s of this.fields) {
        let r = s.span;
        if (((i = 0 < r ? r : 0), void 0 !== s.property)) {
          const o = t[s.property];
          void 0 !== o &&
            ((i = s.encode(o, e, n)), 0 > r && (r = s.getSpan(e, n)));
        }
        (o = n), (n += r);
      }
      return o + i - r;
    }
    fromArray(t) {
      const e = this.makeDestinationObject();
      for (const n of this.fields)
        void 0 !== n.property && 0 < t.length && (e[n.property] = t.shift());
      return e;
    }
    layoutFor(t) {
      if ("string" != typeof t) throw new TypeError("property must be string");
      for (const e of this.fields) if (e.property === t) return e;
    }
    offsetOf(t) {
      if ("string" != typeof t) throw new TypeError("property must be string");
      let e = 0;
      for (const n of this.fields) {
        if (n.property === t) return e;
        0 > n.span ? (e = -1) : 0 <= e && (e += n.span);
      }
    }
  }
  class up {
    constructor(t) {
      this.property = t;
    }
    decode() {
      throw new Error("UnionDiscriminator is abstract");
    }
    encode() {
      throw new Error("UnionDiscriminator is abstract");
    }
  }
  class lp extends up {
    constructor(t, e) {
      if (!(t instanceof Qf && t.isCount()))
        throw new TypeError(
          "layout must be an unsigned integer ExternalLayout"
        );
      super(e || t.property || "variant"), (this.layout = t);
    }
    decode(t, e) {
      return this.layout.decode(t, e);
    }
    encode(t, e, n) {
      return this.layout.encode(t, e, n);
    }
  }
  class hp extends Xf {
    constructor(t, e, n) {
      const r = t instanceof ep || t instanceof np;
      if (r) t = new lp(new tp(t));
      else if (t instanceof Qf && t.isCount()) t = new lp(t);
      else if (!(t instanceof up))
        throw new TypeError(
          "discr must be a UnionDiscriminator or an unsigned integer layout"
        );
      if ((void 0 === e && (e = null), !(null === e || e instanceof Xf)))
        throw new TypeError("defaultLayout must be null or a Layout");
      if (null !== e) {
        if (0 > e.span)
          throw new Error("defaultLayout must have constant span");
        void 0 === e.property && (e = e.replicate("content"));
      }
      let o = -1;
      e && ((o = e.span), 0 <= o && r && (o += t.layout.span)),
        super(o, n),
        (this.discriminator = t),
        (this.usesPrefixDiscriminator = r),
        (this.defaultLayout = e),
        (this.registry = {});
      let i = this.defaultGetSourceVariant.bind(this);
      (this.getSourceVariant = function (t) {
        return i(t);
      }),
        (this.configGetSourceVariant = function (t) {
          i = t.bind(this);
        });
    }
    getSpan(t, e) {
      if (0 <= this.span) return this.span;
      void 0 === e && (e = 0);
      const n = this.getVariant(t, e);
      if (!n)
        throw new Error("unable to determine span for unrecognized variant");
      return n.getSpan(t, e);
    }
    defaultGetSourceVariant(t) {
      if (t.hasOwnProperty(this.discriminator.property)) {
        if (this.defaultLayout && t.hasOwnProperty(this.defaultLayout.property))
          return;
        const e = this.registry[t[this.discriminator.property]];
        if (e && (!e.layout || t.hasOwnProperty(e.property))) return e;
      } else
        for (const e in this.registry) {
          const n = this.registry[e];
          if (t.hasOwnProperty(n.property)) return n;
        }
      throw new Error("unable to infer src variant");
    }
    decode(t, e) {
      let n;
      void 0 === e && (e = 0);
      const r = this.discriminator,
        o = r.decode(t, e);
      let i = this.registry[o];
      if (void 0 === i) {
        let s = 0;
        (i = this.defaultLayout),
          this.usesPrefixDiscriminator && (s = r.layout.span),
          (n = this.makeDestinationObject()),
          (n[r.property] = o),
          (n[i.property] = this.defaultLayout.decode(t, e + s));
      } else n = i.decode(t, e);
      return n;
    }
    encode(t, e, n) {
      void 0 === n && (n = 0);
      const r = this.getSourceVariant(t);
      if (void 0 === r) {
        const r = this.discriminator,
          o = this.defaultLayout;
        let i = 0;
        return (
          this.usesPrefixDiscriminator && (i = r.layout.span),
          r.encode(t[r.property], e, n),
          i + o.encode(t[o.property], e, n + i)
        );
      }
      return r.encode(t, e, n);
    }
    addVariant(t, e, n) {
      const r = new dp(this, t, e, n);
      return (this.registry[t] = r), r;
    }
    getVariant(t, e) {
      let n = t;
      return (
        J.isBuffer(t) &&
          (void 0 === e && (e = 0), (n = this.discriminator.decode(t, e))),
        this.registry[n]
      );
    }
  }
  class dp extends Xf {
    constructor(t, e, n, r) {
      if (!(t instanceof hp)) throw new TypeError("union must be a Union");
      if (!Number.isInteger(e) || 0 > e)
        throw new TypeError("variant must be a (non-negative) integer");
      if (("string" == typeof n && void 0 === r && ((r = n), (n = null)), n)) {
        if (!(n instanceof Xf)) throw new TypeError("layout must be a Layout");
        if (
          null !== t.defaultLayout &&
          0 <= n.span &&
          n.span > t.defaultLayout.span
        )
          throw new Error("variant span exceeds span of containing union");
        if ("string" != typeof r)
          throw new TypeError("variant must have a String property");
      }
      let o = t.span;
      0 > t.span &&
        ((o = n ? n.span : 0),
        0 <= o &&
          t.usesPrefixDiscriminator &&
          (o += t.discriminator.layout.span)),
        super(o, r),
        (this.union = t),
        (this.variant = e),
        (this.layout = n || null);
    }
    getSpan(t, e) {
      if (0 <= this.span) return this.span;
      void 0 === e && (e = 0);
      let n = 0;
      return (
        this.union.usesPrefixDiscriminator &&
          (n = this.union.discriminator.layout.span),
        n + this.layout.getSpan(t, e + n)
      );
    }
    decode(t, e) {
      const n = this.makeDestinationObject();
      if ((void 0 === e && (e = 0), this !== this.union.getVariant(t, e)))
        throw new Error("variant mismatch");
      let r = 0;
      return (
        this.union.usesPrefixDiscriminator &&
          (r = this.union.discriminator.layout.span),
        this.layout
          ? (n[this.property] = this.layout.decode(t, e + r))
          : this.property
          ? (n[this.property] = !0)
          : this.union.usesPrefixDiscriminator &&
            (n[this.union.discriminator.property] = this.variant),
        n
      );
    }
    encode(t, e, n) {
      void 0 === n && (n = 0);
      let r = 0;
      if (
        (this.union.usesPrefixDiscriminator &&
          (r = this.union.discriminator.layout.span),
        this.layout && !t.hasOwnProperty(this.property))
      )
        throw new TypeError("variant lacks property " + this.property);
      this.union.discriminator.encode(this.variant, e, n);
      let o = r;
      if (
        this.layout &&
        (this.layout.encode(t[this.property], e, n + r),
        (o += this.layout.getSpan(e, n + r)),
        0 <= this.union.span && o > this.union.span)
      )
        throw new Error("encoded variant overruns containing union");
      return o;
    }
    fromArray(t) {
      if (this.layout) return this.layout.fromArray(t);
    }
  }
  class fp extends Xf {
    constructor(t, e) {
      if (
        !((t instanceof Qf && t.isCount()) || (Number.isInteger(t) && 0 <= t))
      )
        throw new TypeError(
          "length must be positive integer or an unsigned integer ExternalLayout"
        );
      let n = -1;
      t instanceof Qf || (n = t), super(n, e), (this.length = t);
    }
    getSpan(t, e) {
      let n = this.span;
      return 0 > n && (n = this.length.decode(t, e)), n;
    }
    decode(t, e) {
      void 0 === e && (e = 0);
      let n = this.span;
      return 0 > n && (n = this.length.decode(t, e)), t.slice(e, e + n);
    }
    encode(t, e, n) {
      let r = this.length;
      if (
        (this.length instanceof Qf && (r = t.length),
        !J.isBuffer(t) || r !== t.length)
      )
        throw new TypeError(
          ((o = "Blob.encode"),
          ((i = this).property ? o + "[" + i.property + "]" : o) +
            " requires (length " +
            r +
            ") Buffer as src")
        );
      var o, i;
      if (n + r > e.length) throw new RangeError("encoding overruns Buffer");
      return (
        e.write(t.toString("hex"), n, r, "hex"),
        this.length instanceof Qf && this.length.encode(r, e, n),
        r
      );
    }
  }
  var pp = (t, e, n) => new tp(t, e, n),
    mp = (t) => new ep(4, t),
    yp = (t) => new ap(t),
    gp = (t, e, n) => new cp(t, e, n),
    wp = (t, e, n) => new hp(t, e, n),
    bp = (t, e) => new fp(t, e);
  class vp extends $f {
    constructor(t) {
      super(-1, t),
        (this.property = t),
        (this.layout = gp(
          [mp("length"), mp("lengthPadding"), bp(pp(mp(), -8), "chars")],
          this.property
        ));
    }
    encode(t, e, n = 0) {
      if (null == t) return this.layout.span;
      const r = { chars: J.from(t, "utf8") };
      return this.layout.encode(r, e, n);
    }
    decode(t, e = 0) {
      return this.layout.decode(t, e).chars.toString();
    }
    getSpan(t, e = 0) {
      return (
        mp().span +
        mp().span +
        new Mn(new Uint8Array(t).slice(e, e + 4), 10, "le").toNumber()
      );
    }
  }
  function _p(t) {
    return new vp(t);
  }
  function kp(t) {
    return bp(32, t);
  }
  const Ap = wp(mp("instruction"));
  Ap.addVariant(
    0,
    gp([yp("lamports"), yp("space"), kp("owner")]),
    "createAccount"
  ),
    Ap.addVariant(1, gp([kp("owner")]), "assign"),
    Ap.addVariant(2, gp([yp("lamports")]), "transfer"),
    Ap.addVariant(
      3,
      gp([kp("base"), _p("seed"), yp("lamports"), yp("space"), kp("owner")]),
      "createAccountWithSeed"
    ),
    Ap.addVariant(4, gp([kp("authorized")]), "advanceNonceAccount"),
    Ap.addVariant(5, gp([yp("lamports")]), "withdrawNonceAccount"),
    Ap.addVariant(6, gp([kp("authorized")]), "initializeNonceAccount"),
    Ap.addVariant(7, gp([kp("authorized")]), "authorizeNonceAccount"),
    Ap.addVariant(8, gp([yp("space")]), "allocate"),
    Ap.addVariant(
      9,
      gp([kp("base"), _p("seed"), yp("space"), kp("owner")]),
      "allocateWithSeed"
    ),
    Ap.addVariant(
      10,
      gp([kp("base"), _p("seed"), kp("owner")]),
      "assignWithSeed"
    ),
    Ap.addVariant(
      11,
      gp([yp("lamports"), _p("seed"), kp("owner")]),
      "transferWithSeed"
    ),
    Math.max(...Object.values(Ap.registry).map((t) => t.span));
  class Ep extends $f {
    constructor(t, e, n, r) {
      super(t.span, r),
        (this.layout = t),
        (this.decoder = e),
        (this.encoder = n);
    }
    decode(t, e) {
      return this.decoder(this.layout.decode(t, e));
    }
    encode(t, e, n) {
      return this.layout.encode(this.encoder(t), e, n);
    }
    getSpan(t, e) {
      return this.layout.getSpan(t, e);
    }
  }
  function Ip(t) {
    return new Ep(
      bp(32),
      (t) => new Ti(t),
      (t) => t.toBuffer(),
      t
    );
  }
  var Cp;
  gp([
    mp("version"),
    mp("state"),
    Ip("authorizedPubkey"),
    Ip("nonce"),
    gp([((Cp = "lamportsPerSignature"), new sp(Cp))], "feeCalculator"),
  ]),
    new Ti("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
    new Ti("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
  var Sp = { exports: {} };
  !(function (t, e) {
    var n,
      r = "undefined" != typeof self ? self : ud,
      o = (function () {
        function t() {
          (this.fetch = !1), (this.DOMException = r.DOMException);
        }
        return (t.prototype = r), new t();
      })();
    (n = o),
      void !(function (t) {
        var e = "URLSearchParams" in n,
          r = "Symbol" in n && "iterator" in Symbol,
          o =
            "FileReader" in n &&
            "Blob" in n &&
            (function () {
              try {
                return new Blob(), !0;
              } catch (t) {
                return !1;
              }
            })(),
          i = "FormData" in n,
          s = "ArrayBuffer" in n;
        if (s)
          var a = [
              "[object Int8Array]",
              "[object Uint8Array]",
              "[object Uint8ClampedArray]",
              "[object Int16Array]",
              "[object Uint16Array]",
              "[object Int32Array]",
              "[object Uint32Array]",
              "[object Float32Array]",
              "[object Float64Array]",
            ],
            c =
              ArrayBuffer.isView ||
              function (t) {
                return t && a.indexOf(Object.prototype.toString.call(t)) > -1;
              };
        function u(t) {
          if (
            ("string" != typeof t && (t = String(t)),
            /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(t))
          )
            throw new TypeError("Invalid character in header field name");
          return t.toLowerCase();
        }
        function l(t) {
          return "string" != typeof t && (t = String(t)), t;
        }
        function h(t) {
          var e = {
            next: function () {
              var e = t.shift();
              return { done: void 0 === e, value: e };
            },
          };
          return (
            r &&
              (e[Symbol.iterator] = function () {
                return e;
              }),
            e
          );
        }
        function d(t) {
          (this.map = {}),
            t instanceof d
              ? t.forEach(function (t, e) {
                  this.append(e, t);
                }, this)
              : Array.isArray(t)
              ? t.forEach(function (t) {
                  this.append(t[0], t[1]);
                }, this)
              : t &&
                Object.getOwnPropertyNames(t).forEach(function (e) {
                  this.append(e, t[e]);
                }, this);
        }
        function f(t) {
          if (t.bodyUsed) return Promise.reject(new TypeError("Already read"));
          t.bodyUsed = !0;
        }
        function p(t) {
          return new Promise(function (e, n) {
            (t.onload = function () {
              e(t.result);
            }),
              (t.onerror = function () {
                n(t.error);
              });
          });
        }
        function m(t) {
          var e = new FileReader(),
            n = p(e);
          return e.readAsArrayBuffer(t), n;
        }
        function y(t) {
          if (t.slice) return t.slice(0);
          var e = new Uint8Array(t.byteLength);
          return e.set(new Uint8Array(t)), e.buffer;
        }
        function g() {
          return (
            (this.bodyUsed = !1),
            (this._initBody = function (t) {
              var n;
              (this._bodyInit = t),
                t
                  ? "string" == typeof t
                    ? (this._bodyText = t)
                    : o && Blob.prototype.isPrototypeOf(t)
                    ? (this._bodyBlob = t)
                    : i && FormData.prototype.isPrototypeOf(t)
                    ? (this._bodyFormData = t)
                    : e && URLSearchParams.prototype.isPrototypeOf(t)
                    ? (this._bodyText = t.toString())
                    : s && o && (n = t) && DataView.prototype.isPrototypeOf(n)
                    ? ((this._bodyArrayBuffer = y(t.buffer)),
                      (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                    : s && (ArrayBuffer.prototype.isPrototypeOf(t) || c(t))
                    ? (this._bodyArrayBuffer = y(t))
                    : (this._bodyText = t = Object.prototype.toString.call(t))
                  : (this._bodyText = ""),
                this.headers.get("content-type") ||
                  ("string" == typeof t
                    ? this.headers.set(
                        "content-type",
                        "text/plain;charset=UTF-8"
                      )
                    : this._bodyBlob && this._bodyBlob.type
                    ? this.headers.set("content-type", this._bodyBlob.type)
                    : e &&
                      URLSearchParams.prototype.isPrototypeOf(t) &&
                      this.headers.set(
                        "content-type",
                        "application/x-www-form-urlencoded;charset=UTF-8"
                      ));
            }),
            o &&
              ((this.blob = function () {
                var t = f(this);
                if (t) return t;
                if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                if (this._bodyArrayBuffer)
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                if (this._bodyFormData)
                  throw new Error("could not read FormData body as blob");
                return Promise.resolve(new Blob([this._bodyText]));
              }),
              (this.arrayBuffer = function () {
                return this._bodyArrayBuffer
                  ? f(this) || Promise.resolve(this._bodyArrayBuffer)
                  : this.blob().then(m);
              })),
            (this.text = function () {
              var t,
                e,
                n,
                r = f(this);
              if (r) return r;
              if (this._bodyBlob)
                return (
                  (t = this._bodyBlob),
                  (e = new FileReader()),
                  (n = p(e)),
                  e.readAsText(t),
                  n
                );
              if (this._bodyArrayBuffer)
                return Promise.resolve(
                  (function (t) {
                    for (
                      var e = new Uint8Array(t), n = new Array(e.length), r = 0;
                      r < e.length;
                      r++
                    )
                      n[r] = String.fromCharCode(e[r]);
                    return n.join("");
                  })(this._bodyArrayBuffer)
                );
              if (this._bodyFormData)
                throw new Error("could not read FormData body as text");
              return Promise.resolve(this._bodyText);
            }),
            i &&
              (this.formData = function () {
                return this.text().then(v);
              }),
            (this.json = function () {
              return this.text().then(JSON.parse);
            }),
            this
          );
        }
        (d.prototype.append = function (t, e) {
          (t = u(t)), (e = l(e));
          var n = this.map[t];
          this.map[t] = n ? n + ", " + e : e;
        }),
          (d.prototype.delete = function (t) {
            delete this.map[u(t)];
          }),
          (d.prototype.get = function (t) {
            return (t = u(t)), this.has(t) ? this.map[t] : null;
          }),
          (d.prototype.has = function (t) {
            return this.map.hasOwnProperty(u(t));
          }),
          (d.prototype.set = function (t, e) {
            this.map[u(t)] = l(e);
          }),
          (d.prototype.forEach = function (t, e) {
            for (var n in this.map)
              this.map.hasOwnProperty(n) && t.call(e, this.map[n], n, this);
          }),
          (d.prototype.keys = function () {
            var t = [];
            return (
              this.forEach(function (e, n) {
                t.push(n);
              }),
              h(t)
            );
          }),
          (d.prototype.values = function () {
            var t = [];
            return (
              this.forEach(function (e) {
                t.push(e);
              }),
              h(t)
            );
          }),
          (d.prototype.entries = function () {
            var t = [];
            return (
              this.forEach(function (e, n) {
                t.push([n, e]);
              }),
              h(t)
            );
          }),
          r && (d.prototype[Symbol.iterator] = d.prototype.entries);
        var w = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function b(t, e) {
          var n,
            r,
            o = (e = e || {}).body;
          if (t instanceof b) {
            if (t.bodyUsed) throw new TypeError("Already read");
            (this.url = t.url),
              (this.credentials = t.credentials),
              e.headers || (this.headers = new d(t.headers)),
              (this.method = t.method),
              (this.mode = t.mode),
              (this.signal = t.signal),
              o ||
                null == t._bodyInit ||
                ((o = t._bodyInit), (t.bodyUsed = !0));
          } else this.url = String(t);
          if (
            ((this.credentials =
              e.credentials || this.credentials || "same-origin"),
            (!e.headers && this.headers) || (this.headers = new d(e.headers)),
            (this.method =
              ((n = e.method || this.method || "GET"),
              (r = n.toUpperCase()),
              w.indexOf(r) > -1 ? r : n)),
            (this.mode = e.mode || this.mode || null),
            (this.signal = e.signal || this.signal),
            (this.referrer = null),
            ("GET" === this.method || "HEAD" === this.method) && o)
          )
            throw new TypeError("Body not allowed for GET or HEAD requests");
          this._initBody(o);
        }
        function v(t) {
          var e = new FormData();
          return (
            t
              .trim()
              .split("&")
              .forEach(function (t) {
                if (t) {
                  var n = t.split("="),
                    r = n.shift().replace(/\+/g, " "),
                    o = n.join("=").replace(/\+/g, " ");
                  e.append(decodeURIComponent(r), decodeURIComponent(o));
                }
              }),
            e
          );
        }
        function _(t, e) {
          e || (e = {}),
            (this.type = "default"),
            (this.status = void 0 === e.status ? 200 : e.status),
            (this.ok = this.status >= 200 && this.status < 300),
            (this.statusText = "statusText" in e ? e.statusText : "OK"),
            (this.headers = new d(e.headers)),
            (this.url = e.url || ""),
            this._initBody(t);
        }
        (b.prototype.clone = function () {
          return new b(this, { body: this._bodyInit });
        }),
          g.call(b.prototype),
          g.call(_.prototype),
          (_.prototype.clone = function () {
            return new _(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new d(this.headers),
              url: this.url,
            });
          }),
          (_.error = function () {
            var t = new _(null, { status: 0, statusText: "" });
            return (t.type = "error"), t;
          });
        var k = [301, 302, 303, 307, 308];
        (_.redirect = function (t, e) {
          if (-1 === k.indexOf(e)) throw new RangeError("Invalid status code");
          return new _(null, { status: e, headers: { location: t } });
        }),
          (t.DOMException = n.DOMException);
        try {
          new t.DOMException();
        } catch (E) {
          (t.DOMException = function (t, e) {
            (this.message = t), (this.name = e);
            var n = Error(t);
            this.stack = n.stack;
          }),
            (t.DOMException.prototype = Object.create(Error.prototype)),
            (t.DOMException.prototype.constructor = t.DOMException);
        }
        function A(e, n) {
          return new Promise(function (r, i) {
            var s = new b(e, n);
            if (s.signal && s.signal.aborted)
              return i(new t.DOMException("Aborted", "AbortError"));
            var a = new XMLHttpRequest();
            function c() {
              a.abort();
            }
            (a.onload = function () {
              var t,
                e,
                n = {
                  status: a.status,
                  statusText: a.statusText,
                  headers:
                    ((t = a.getAllResponseHeaders() || ""),
                    (e = new d()),
                    t
                      .replace(/\r?\n[\t ]+/g, " ")
                      .split(/\r?\n/)
                      .forEach(function (t) {
                        var n = t.split(":"),
                          r = n.shift().trim();
                        if (r) {
                          var o = n.join(":").trim();
                          e.append(r, o);
                        }
                      }),
                    e),
                };
              n.url =
                "responseURL" in a
                  ? a.responseURL
                  : n.headers.get("X-Request-URL");
              var o = "response" in a ? a.response : a.responseText;
              r(new _(o, n));
            }),
              (a.onerror = function () {
                i(new TypeError("Network request failed"));
              }),
              (a.ontimeout = function () {
                i(new TypeError("Network request failed"));
              }),
              (a.onabort = function () {
                i(new t.DOMException("Aborted", "AbortError"));
              }),
              a.open(s.method, s.url, !0),
              "include" === s.credentials
                ? (a.withCredentials = !0)
                : "omit" === s.credentials && (a.withCredentials = !1),
              "responseType" in a && o && (a.responseType = "blob"),
              s.headers.forEach(function (t, e) {
                a.setRequestHeader(e, t);
              }),
              s.signal &&
                (s.signal.addEventListener("abort", c),
                (a.onreadystatechange = function () {
                  4 === a.readyState &&
                    s.signal.removeEventListener("abort", c);
                })),
              a.send(void 0 === s._bodyInit ? null : s._bodyInit);
          });
        }
        return (
          (A.polyfill = !0),
          n.fetch ||
            ((n.fetch = A), (n.Headers = d), (n.Request = b), (n.Response = _)),
          (t.Headers = d),
          (t.Request = b),
          (t.Response = _),
          (t.fetch = A),
          Object.defineProperty(t, "__esModule", { value: !0 }),
          t
        );
      })({}),
      (o.fetch.ponyfill = !0),
      delete o.fetch.polyfill;
    var i = o;
    ((e = i.fetch).default = i.fetch),
      (e.fetch = i.fetch),
      (e.Headers = i.Headers),
      (e.Request = i.Request),
      (e.Response = i.Response),
      (t.exports = e);
  })(Sp, Sp.exports),
    el.rustEnum(
      [
        el.struct([], "uninitialized"),
        el.struct([el.option(el.publicKey(), "authorityAddress")], "buffer"),
        el.struct([el.publicKey("programdataAddress")], "program"),
        el.struct(
          [
            el.u64("slot"),
            el.option(el.publicKey(), "upgradeAuthorityAddress"),
          ],
          "programData"
        ),
      ],
      void 0,
      el.u32()
    );
  const Bp = "Program log: ",
    xp = "Program data: ";
  class Tp {
    constructor(t, e, n) {
      (this._programId = t),
        (this._provider = e),
        (this._eventParser = new Rp(t, n)),
        (this._eventCallbacks = new Map()),
        (this._eventListeners = new Map()),
        (this._listenerIdCount = 0);
    }
    addEventListener(t, e, n) {
      var r;
      let o = this._listenerIdCount;
      return (
        (this._listenerIdCount += 1),
        this._eventListeners.has(t) || this._eventListeners.set(t, []),
        this._eventListeners.set(
          t,
          (null !== (r = this._eventListeners.get(t)) && void 0 !== r
            ? r
            : []
          ).concat(o)
        ),
        this._eventCallbacks.set(o, [t, e]),
        void 0 !== this._onLogsSubscriptionId ||
          (this._onLogsSubscriptionId = this._provider.connection.onLogs(
            this._programId,
            (t, e) => {
              if (!t.err)
                for (const n of this._eventParser.parseLogs(t.logs)) {
                  const r = this._eventListeners.get(n.name);
                  r &&
                    r.forEach((r) => {
                      const o = this._eventCallbacks.get(r);
                      if (o) {
                        const [, r] = o;
                        r(n.data, e.slot, t.signature);
                      }
                    });
                }
            },
            n
          )),
        o
      );
    }
    async removeEventListener(t) {
      const e = this._eventCallbacks.get(t);
      if (!e) throw new Error(`Event listener ${t} doesn't exist!`);
      const [n] = e;
      let r = this._eventListeners.get(n);
      if (!r) throw new Error(`Event listeners don't exist for ${n}!`);
      if (
        (this._eventCallbacks.delete(t),
        (r = r.filter((e) => e !== t)),
        this._eventListeners.set(n, r),
        0 === r.length && this._eventListeners.delete(n),
        0 === this._eventCallbacks.size)
      ) {
        if (0 !== this._eventListeners.size)
          throw new Error(
            `Expected event listeners size to be 0 but got ${this._eventListeners.size}`
          );
        void 0 !== this._onLogsSubscriptionId &&
          (await this._provider.connection.removeOnLogsListener(
            this._onLogsSubscriptionId
          ),
          (this._onLogsSubscriptionId = void 0));
      }
    }
  }
  class Rp {
    constructor(t, e) {
      (this.coder = e), (this.programId = t);
    }
    *parseLogs(t, e = !1) {
      const n = new Mp(t),
        r = new Op();
      let o = n.next();
      for (; null !== o; ) {
        let [t, i, s] = this.handleLog(r, o, e);
        t && (yield t), i && r.push(i), s && r.pop(), (o = n.next());
      }
    }
    handleLog(t, e, n) {
      return t.stack.length > 0 && t.program() === this.programId.toString()
        ? this.handleProgramLog(e, n)
        : [null, ...this.handleSystemLog(e)];
    }
    handleProgramLog(t, e) {
      if (t.startsWith(Bp) || t.startsWith(xp)) {
        const n = t.startsWith(Bp) ? t.slice(13) : t.slice(14),
          r = this.coder.events.decode(n);
        if (e && null === r) throw new Error(`Unable to decode event ${n}`);
        return [r, null, !1];
      }
      return [null, ...this.handleSystemLog(t)];
    }
    handleSystemLog(t) {
      const e = t.split(":")[0];
      return null !== e.match(/^Program (.*) success/g)
        ? [null, !0]
        : e.startsWith(`Program ${this.programId.toString()} invoke`)
        ? [this.programId.toString(), !1]
        : e.includes("invoke")
        ? ["cpi", !1]
        : [null, !1];
    }
  }
  class Op {
    constructor() {
      this.stack = [];
    }
    program() {
      if (!this.stack.length)
        throw new Error("Expected the stack to have elements");
      return this.stack[this.stack.length - 1];
    }
    push(t) {
      this.stack.push(t);
    }
    pop() {
      if (!this.stack.length)
        throw new Error("Expected the stack to have elements");
      this.stack.pop();
    }
  }
  class Mp {
    constructor(t) {
      this.logs = t;
    }
    next() {
      if (0 === this.logs.length) return null;
      let t = this.logs[0];
      return (this.logs = this.logs.slice(1)), t;
    }
  }
  function Np(t, e) {
    var n, r;
    let o = {};
    const i = t.args ? t.args.length : 0;
    if (e.length > i) {
      if (e.length !== i + 1)
        throw new Error(
          `provided too many arguments ${e} to instruction ${
            null == t ? void 0 : t.name
          } expecting: ${
            null !==
              (r =
                null === (n = t.args) || void 0 === n
                  ? void 0
                  : n.map((t) => t.name)) && void 0 !== r
              ? r
              : []
          }`
        );
      o = e.pop();
    }
    return [e, o];
  }
  class Pp {
    static build(t, e, n) {
      if ("_inner" === t.name) throw new zf("the _inner name is reserved");
      const r = (...o) => {
        const [i, s] = Np(t, [...o]);
        xh(t.accounts, s.accounts), (function () {})(t, ...o);
        const a = r.accounts(s.accounts);
        return (
          void 0 !== s.remainingAccounts && a.push(...s.remainingAccounts),
          Lf("debug-logs"),
          new ts({ keys: a, programId: n, data: e(t.name, Bh(t, ...i)) })
        );
      };
      return (
        (r.accounts = (e) => Pp.accountsArray(e, t.accounts, n, t.name)), r
      );
    }
    static accountsArray(t, e, n, r) {
      return t
        ? e
            .map((e) => {
              if (Ih(e)) {
                const o = t[e.name];
                return Pp.accountsArray(o, e.accounts, n, r).flat();
              }
              let o;
              try {
                o = Th(t[e.name]);
              } catch (s) {
                throw new Error(
                  `Wrong input type for account "${
                    e.name
                  }" in the instruction accounts object${
                    void 0 !== r ? ' for instruction "' + r + '"' : ""
                  }. Expected PublicKey or string.`
                );
              }
              const i = e.optional && o.equals(n);
              return {
                pubkey: o,
                isWritable: Boolean(e.writable && !i),
                isSigner: Boolean(e.signer && !i),
              };
            })
            .flat()
        : [];
    }
  }
  class Lp {
    static build(t, e) {
      return (...n) => {
        var r, o, i;
        const [, s] = Np(t, [...n]),
          a = new es();
        if (s.preInstructions && s.instructions)
          throw new Error("instructions is deprecated, use preInstructions");
        return (
          null === (r = s.preInstructions) || void 0 === r
            ? void 0
            : r.forEach((t) => a.add(t)),
          null === (o = s.instructions) ||
            void 0 === o ||
            o.forEach((t) => a.add(t)),
          a.add(e(...n)),
          null === (i = s.postInstructions) ||
            void 0 === i ||
            i.forEach((t) => a.add(t)),
          a
        );
      };
    }
  }
  class zp {
    static build(t, e, n, r) {
      return async (...o) => {
        var i;
        const s = e(...o),
          [, a] = Np(t, [...o]);
        if (void 0 === r.sendAndConfirm)
          throw new Error(
            "This function requires 'Provider.sendAndConfirm' to be implemented."
          );
        try {
          return await r.sendAndConfirm(
            s,
            null !== (i = a.signers) && void 0 !== i ? i : [],
            a.options
          );
        } catch (c) {
          throw Gf(c, n);
        }
      };
    }
  }
  class Dp {
    static build(t, e, n, r) {
      var o;
      return (null !== (o = t.accounts) && void 0 !== o ? o : []).reduce(
        (o, i) => ((o[i.name] = new Up(t, i, n, r, e)), o),
        {}
      );
    }
  }
  class Up {
    get size() {
      return this._size;
    }
    get programId() {
      return this._programId;
    }
    get provider() {
      return this._provider;
    }
    get coder() {
      return this._coder;
    }
    constructor(t, e, n, r, o) {
      (this._idlAccount = e),
        (this._programId = n),
        (this._provider = null != r ? r : cd()),
        (this._coder = null != o ? o : new Jf(t)),
        (this._size = this._coder.accounts.size(e.name));
    }
    async fetchNullable(t, e) {
      const { data: n } = await this.fetchNullableAndContext(t, e);
      return n;
    }
    async fetchNullableAndContext(t, e) {
      const n = await this.getAccountInfoAndContext(t, e),
        { value: r, context: o } = n;
      return {
        data:
          r && 0 !== r.data.length
            ? this._coder.accounts.decode(this._idlAccount.name, r.data)
            : null,
        context: o,
      };
    }
    async fetch(t, e) {
      const { data: n } = await this.fetchNullableAndContext(t, e);
      if (null === n)
        throw new Error(
          `Account does not exist or has no data ${t.toString()}`
        );
      return n;
    }
    async fetchAndContext(t, e) {
      const { data: n, context: r } = await this.fetchNullableAndContext(t, e);
      if (null === n) throw new Error(`Account does not exist ${t.toString()}`);
      return { data: n, context: r };
    }
    async fetchMultiple(t, e) {
      return (await this.fetchMultipleAndContext(t, e)).map((t) =>
        t ? t.data : null
      );
    }
    async fetchMultipleAndContext(t, e) {
      return (
        await Xh(
          this._provider.connection,
          t.map((t) => Th(t)),
          e
        )
      ).map((t) => {
        if (null == t) return null;
        const { account: e, context: n } = t;
        return {
          data: this._coder.accounts.decode(this._idlAccount.name, e.data),
          context: n,
        };
      });
    }
    async all(t) {
      const e = this.coder.accounts.memcmp(
          this._idlAccount.name,
          t instanceof J ? t : void 0
        ),
        n = [];
      return (
        null != (null == e ? void 0 : e.offset) &&
          null != (null == e ? void 0 : e.bytes) &&
          n.push({ memcmp: { offset: e.offset, bytes: e.bytes } }),
        null != (null == e ? void 0 : e.dataSize) &&
          n.push({ dataSize: e.dataSize }),
        (
          await this._provider.connection.getProgramAccounts(this._programId, {
            commitment: this._provider.connection.commitment,
            filters: [...n, ...(Array.isArray(t) ? t : [])],
          })
        ).map(({ pubkey: t, account: e }) => ({
          publicKey: t,
          account: this._coder.accounts.decode(this._idlAccount.name, e.data),
        }))
      );
    }
    subscribe(t, e) {
      const n = qp.get(t.toString());
      if (n) return n.ee;
      const r = new _h();
      t = Th(t);
      const o = this._provider.connection.onAccountChange(
        t,
        (t) => {
          const e = this._coder.accounts.decode(this._idlAccount.name, t.data);
          r.emit("change", e);
        },
        e
      );
      return qp.set(t.toString(), { ee: r, listener: o }), r;
    }
    async unsubscribe(t) {
      let e = qp.get(t.toString());
      if (!e) return void 0, void 0;
      qp &&
        (await this._provider.connection
          .removeAccountChangeListener(e.listener)
          .then(() => {
            qp.delete(t.toString());
          })
          .catch(console.error));
    }
    async createInstruction(t, e) {
      const n = this.size;
      if (void 0 === this._provider.publicKey)
        throw new Error(
          "This function requires the Provider interface implementor to have a 'publicKey' field."
        );
      return Is.createAccount({
        fromPubkey: this._provider.publicKey,
        newAccountPubkey: t.publicKey,
        space: null != e ? e : n,
        lamports:
          await this._provider.connection.getMinimumBalanceForRentExemption(
            null != e ? e : n
          ),
        programId: this._programId,
      });
    }
    async getAccountInfo(t, e) {
      return await this._provider.connection.getAccountInfo(Th(t), e);
    }
    async getAccountInfoAndContext(t, e) {
      return await this._provider.connection.getAccountInfoAndContext(Th(t), e);
    }
  }
  const qp = new Map();
  class Gp {
    static build(t, e, n, r, o, i, s) {
      return async (...a) => {
        var c;
        const u = e(...a),
          [, l] = Np(t, [...a]);
        let h;
        if (void 0 === r.simulate)
          throw new Error(
            "This function requires 'Provider.simulate' to be implemented."
          );
        try {
          h = await r.simulate(
            u,
            l.signers,
            null === (c = l.options) || void 0 === c ? void 0 : c.commitment
          );
        } catch (p) {
          throw Gf(p, n);
        }
        if (void 0 === h) throw new Error("Unable to simulate transaction");
        const d = h.logs;
        if (!d) throw new Error("Simulated logs not found");
        const f = [];
        if (s.events) {
          let t = new Rp(i, o);
          for (const e of t.parseLogs(d)) f.push(e);
        }
        return { events: f, raw: d };
      };
    }
  }
  function Wp(t) {
    return new Hp(
      bp(8),
      (t) => Fp.fromBuffer(t),
      (t) => t.toBuffer(),
      t
    );
  }
  function Kp(t) {
    return new Hp(
      bp(32),
      (t) => new Ti(t),
      (t) => t.toBuffer(),
      t
    );
  }
  function jp(t, e) {
    return new Vp(t, e);
  }
  class Hp extends $f {
    constructor(t, e, n, r) {
      super(t.span, r),
        (this.layout = t),
        (this.decoder = e),
        (this.encoder = n);
    }
    decode(t, e) {
      return this.decoder(this.layout.decode(t, e));
    }
    encode(t, e, n) {
      return this.layout.encode(this.encoder(t), e, n);
    }
    getSpan(t, e) {
      return this.layout.getSpan(t, e);
    }
  }
  class Vp extends $f {
    constructor(t, e) {
      super(-1, e), (this.layout = t), (this.discriminator = mp());
    }
    encode(t, e, n = 0) {
      return null == t
        ? this.layout.span + this.discriminator.encode(0, e, n)
        : (this.discriminator.encode(1, e, n),
          this.layout.encode(t, e, n + 4) + 4);
    }
    decode(t, e = 0) {
      const n = this.discriminator.decode(t, e);
      if (0 === n) return null;
      if (1 === n) return this.layout.decode(t, e + 4);
      throw new Error("Invalid coption " + this.layout.property);
    }
    getSpan(t, e = 0) {
      return this.layout.getSpan(t, e + 4) + 4;
    }
  }
  class Fp extends Mn {
    toBuffer() {
      const t = super.toArray().reverse(),
        e = J.from(t);
      if (8 === e.length) return e;
      if (e.length >= 8) throw new Error("u64 too large");
      const n = J.alloc(8);
      return e.copy(n), n;
    }
    static fromBuffer(t) {
      if (8 !== t.length) throw new Error(`Invalid buffer length: ${t.length}`);
      return new Fp(
        [...t]
          .reverse()
          .map((t) => `00${t.toString(16)}`.slice(-2))
          .join(""),
        16
      );
    }
  }
  const Yp = gp([
    Kp("mint"),
    Kp("owner"),
    Wp("amount"),
    jp(Kp(), "delegate"),
    (() => {
      const t = wp(((t) => new ep(1, t))("discriminator"), null, "state");
      return (
        t.addVariant(0, gp([]), "uninitialized"),
        t.addVariant(1, gp([]), "initialized"),
        t.addVariant(2, gp([]), "frozen"),
        t
      );
    })(),
    jp(Wp(), "isNative"),
    Wp("delegatedAmount"),
    jp(Kp(), "closeAuthority"),
  ]);
  class Zp {
    constructor(t, e, n, r, o, i, s, a) {
      (this._args = t),
        (this._accounts = e),
        (this._provider = n),
        (this._programId = r),
        (this._idlIx = o),
        (this._idlTypes = s),
        (this._customResolver = a),
        (this._accountStore = new Jp(n, i, r));
    }
    args(t) {
      this._args = t;
    }
    async resolve() {
      this.resolveEventCpi(this._idlIx.accounts),
        this.resolveConst(this._idlIx.accounts);
      let t = 0;
      for (
        ;
        (await this.resolvePdasAndRelations(this._idlIx.accounts)) +
          (await this.resolveCustom()) >
        0;

      )
        if ((t++, 16 === t)) {
          const t = (e) =>
              Ih(e)
                ? e.accounts.some(t)
                : !!(e.address || e.pda || e.relations),
            e = (t, n = [], r = []) => {
              for (const o of t)
                Ih(o)
                  ? r.push(...e(o.accounts, [...n, o.name]))
                  : r.push([...n, o.name]);
              return r;
            },
            n = this._idlIx.accounts.filter(t),
            r = e(n)
              .filter((t) => !this.get(t))
              .map((t) => t.reduce((t, e) => t + "." + e))
              .map((t) => `\`${t}\``)
              .join(", ");
          throw new Error(
            [
              "Reached maximum depth for account resolution.",
              `Unresolved accounts: ${r}`,
            ].join(" ")
          );
        }
    }
    resolveOptionals(t) {
      Object.assign(
        this._accounts,
        this.resolveOptionalsHelper(t, this._idlIx.accounts)
      );
    }
    get(t) {
      const e = t.reduce((t, e) => t && t[e], this._accounts);
      if (e && e.toBase58) return e;
    }
    set(t, e) {
      let n = this._accounts;
      t.forEach((r, o) => {
        var i;
        o === t.length - 1 && (n[r] = e),
          (n[r] = null !== (i = n[r]) && void 0 !== i ? i : {}),
          (n = n[r]);
      });
    }
    resolveOptionalsHelper(t, e) {
      const n = {};
      for (const r of e) {
        const e = r.name,
          o = t[e];
        void 0 !== o &&
          ($p(o)
            ? Ih(r)
              ? (n[e] = this.resolveOptionalsHelper(o, r.accounts))
              : (n[e] = Qp(o))
            : null !== o
            ? (n[e] = Th(o))
            : r.optional && (n[e] = this._programId));
      }
      return n;
    }
    async resolveCustom() {
      if (this._customResolver) {
        const { accounts: t, resolved: e } = await this._customResolver({
          args: this._args,
          accounts: this._accounts,
          provider: this._provider,
          programId: this._programId,
          idlIx: this._idlIx,
        });
        return (this._accounts = t), e;
      }
      return 0;
    }
    resolveEventCpi(t, e = []) {
      for (const n in t) {
        const r = t[n];
        Ih(r) && this.resolveEventCpi(r.accounts, [...e, r.name]);
        const o = +n + 1;
        if (o === t.length) return;
        const i = t[n].name,
          s = t[o].name;
        if ("eventAuthority" === i && "program" === s) {
          const t = [...e, i],
            n = [...e, s];
          return (
            this.get(t) ||
              this.set(
                t,
                Ti.findProgramAddressSync(
                  [J.from("__event_authority")],
                  this._programId
                )[0]
              ),
            this.get(n) || this.set(n, this._programId),
            void 0
          );
        }
      }
    }
    resolveConst(t, e = []) {
      for (const n of t) {
        const t = n.name;
        if (Ih(n)) this.resolveConst(n.accounts, [...e, t]);
        else {
          const r = n;
          if ((r.signer || r.address) && !this.get([...e, t])) {
            if (r.signer) {
              if (!this._provider.publicKey)
                throw new Error(
                  "This function requires the `Provider` interface implementor to have a `publicKey` field."
                );
              this.set([...e, t], this._provider.publicKey);
            }
            r.address && this.set([...e, t], Th(r.address));
          }
        }
      }
    }
    async resolvePdasAndRelations(t, e = []) {
      let n = 0;
      for (const r of t) {
        const t = r.name;
        if (Ih(r))
          n += await this.resolvePdasAndRelations(r.accounts, [...e, t]);
        else {
          const o = r;
          if ((o.pda || o.relations) && !this.get([...e, t])) {
            n++;
            try {
              if (o.pda) {
                const n = await Promise.all(
                  o.pda.seeds.map((t) => this.toBuffer(t, e))
                );
                if (n.some((t) => !t)) continue;
                const r = await this.parseProgramId(o, e),
                  [i] = Ti.findProgramAddressSync(n, r);
                this.set([...e, t], i);
              }
            } catch {}
            try {
              if (o.relations) {
                const n = this.get([...e, o.relations[0]]);
                if (n) {
                  const r = await this._accountStore.fetchAccount({
                    publicKey: n,
                  });
                  this.set([...e, t], r[t]);
                }
              }
            } catch {}
          }
        }
      }
      return n;
    }
    async parseProgramId(t, e = []) {
      var n;
      if (!(null === (n = t.pda) || void 0 === n ? void 0 : n.program))
        return this._programId;
      const r = await this.toBuffer(t.pda.program, e);
      if (!r) throw new Error(`Program seed not resolved: ${t.name}`);
      return new Ti(r);
    }
    async toBuffer(t, e = []) {
      switch (t.kind) {
        case "const":
          return this.toBufferConst(t);
        case "arg":
          return await this.toBufferArg(t);
        case "account":
          return await this.toBufferAccount(t, e);
        default:
          throw new Error(`Unexpected seed: ${t}`);
      }
    }
    toBufferConst(t) {
      return this.toBufferValue("bytes", t.value);
    }
    async toBufferArg(t) {
      const [e, ...n] = t.path.split("."),
        r = this._idlIx.args.findIndex((t) => t.name === e);
      if (-1 === r) throw new Error(`Unable to find argument for seed: ${e}`);
      const o = n.reduce((t, e) => (null != t ? t : {})[e], this._args[r]);
      if (void 0 === o) return;
      const i = this.getType(this._idlIx.args[r].type, n);
      return this.toBufferValue(i, o);
    }
    async toBufferAccount(t, e = []) {
      const [n, ...r] = t.path.split("."),
        o = this.get([...e, n]);
      if (!o) return;
      if (!r.length) return this.toBufferValue("pubkey", o);
      if (!t.account)
        throw new Error(
          `Seed account is required in order to resolve type: ${t.path}`
        );
      let i = await this._accountStore.fetchAccount({
          publicKey: o,
          name: t.account,
        }),
        s = r;
      for (; s.length > 0; ) (i = i[s[0]]), (s = s.slice(1));
      if (void 0 === i) return;
      const a = this.getType({ defined: { name: t.account } }, r);
      return this.toBufferValue(a, i);
    }
    toBufferValue(t, e) {
      switch (t) {
        case "u8":
        case "i8":
          return J.from([e]);
        case "u16":
        case "i16":
          return new Mn(e).toArrayLike(J, "le", 2);
        case "u32":
        case "i32":
          return new Mn(e).toArrayLike(J, "le", 4);
        case "u64":
        case "i64":
          return new Mn(e).toArrayLike(J, "le", 8);
        case "u128":
        case "i128":
          return new Mn(e).toArrayLike(J, "le", 16);
        case "u256":
        case "i256":
          return new Mn(e).toArrayLike(J, "le", 32);
        case "string":
        case "bytes":
          return J.from(e);
        case "pubkey":
          return e.toBuffer();
        default:
          if (null == t ? void 0 : t.array) return J.from(e);
          throw new Error(`Unexpected seed type: ${t}`);
      }
    }
    getType(t, e = []) {
      var n;
      const r =
        null === (n = null == t ? void 0 : t.defined) || void 0 === n
          ? void 0
          : n.name;
      if (r) {
        if ("tokenAccount" === r)
          switch (e.at(0)) {
            case "mint":
            case "owner":
              return "pubkey";
            case "amount":
            case "delagatedAmount":
              return "u64";
            default:
              throw new Error(`Unknown token account path: ${e}`);
          }
        const t = this._idlTypes.find((t) => t.name === r);
        if (!t) throw new Error(`Type not found: ${r}`);
        const [n, ...o] = e,
          i = t.type.fields.find((t) => t.name === n);
        if (!i) throw new Error(`Field not found: ${n}`);
        return this.getType(i.type, o);
      }
      return t;
    }
  }
  class Jp {
    constructor(t, e, n) {
      (this._provider = t),
        (this._cache = new Map()),
        (this._idls = {}),
        (this._idls[n.toBase58()] = e);
    }
    async fetchAccount({ publicKey: t, name: e }) {
      const n = t.toBase58();
      if (!this._cache.has(n)) {
        const o = await this._provider.connection.getAccountInfo(t);
        if (null === o) throw new Error(`Account not found: ${n}`);
        if ("tokenAccount" === e) {
          const t = ((r = o.data), Yp.decode(r));
          this._cache.set(n, t);
        } else {
          const t = await this.getAccountsNs(o.owner);
          if (t) {
            const e = Object.values(t)[0];
            if (e) {
              const t = e.coder.accounts.decodeAny(o.data);
              this._cache.set(n, t);
            }
          }
        }
      }
      var r;
      return this._cache.get(n);
    }
    async getAccountsNs(t) {
      const e = t.toBase58();
      if (!this._idls[e]) {
        const n = await rm.fetchIdl(t, this._provider);
        if (n) {
          const t = new rm(n, this._provider);
          this._idls[e] = t.account;
        }
      }
      return this._idls[e];
    }
  }
  class Xp {
    static build(t, e, n, r, o, i, s, a, c, u, l) {
      return (...h) => new tm(h, r, o, i, s, a, t, e, n, c, u, l);
    }
  }
  function $p(t) {
    return "object" == typeof t && null !== t && !("_bn" in t);
  }
  function Qp(t, e) {
    const n = {};
    for (const r in t) {
      const e = t[r];
      if (null === e)
        throw new Error(
          "Failed to resolve optionals due to IDL type mismatch with input accounts!"
        );
      n[r] = $p(e) ? Qp(e) : Th(e);
    }
    return n;
  }
  class tm {
    constructor(t, e, n, r, o, i, s, a, c, u, l, h) {
      (this._args = t),
        (this._ixFn = e),
        (this._txFn = n),
        (this._rpcFn = r),
        (this._simulateFn = o),
        (this._viewFn = i),
        (this._accounts = {}),
        (this._remainingAccounts = []),
        (this._signers = []),
        (this._preInstructions = []),
        (this._postInstructions = []),
        (this._resolveAccounts = !0),
        (this._accountsResolver = new Zp(t, this._accounts, s, a, c, u, l, h));
    }
    args(t) {
      (this._args = t), this._accountsResolver.args(t);
    }
    accounts(t) {
      return this.accountsPartial(t);
    }
    accountsPartial(t) {
      return (
        (this._resolveAccounts = !0),
        this._accountsResolver.resolveOptionals(t),
        this
      );
    }
    accountsStrict(t) {
      return (
        (this._resolveAccounts = !1),
        this._accountsResolver.resolveOptionals(t),
        this
      );
    }
    signers(t) {
      return (this._signers = this._signers.concat(t)), this;
    }
    remainingAccounts(t) {
      return (
        (this._remainingAccounts = this._remainingAccounts.concat(t)), this
      );
    }
    preInstructions(t, e = !1) {
      return (
        (this._preInstructions = e
          ? t.concat(this._preInstructions)
          : this._preInstructions.concat(t)),
        this
      );
    }
    postInstructions(t) {
      return (this._postInstructions = this._postInstructions.concat(t)), this;
    }
    async pubkeys() {
      return (
        this._resolveAccounts && (await this._accountsResolver.resolve()),
        this._accounts
      );
    }
    async instruction() {
      return (
        this._resolveAccounts && (await this._accountsResolver.resolve()),
        this._ixFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions,
        })
      );
    }
    async transaction() {
      return (
        this._resolveAccounts && (await this._accountsResolver.resolve()),
        this._txFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions,
        })
      );
    }
    async simulate(t) {
      return (
        this._resolveAccounts && (await this._accountsResolver.resolve()),
        this._simulateFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions,
          options: t,
        })
      );
    }
    async view(t) {
      if (
        (this._resolveAccounts && (await this._accountsResolver.resolve()),
        !this._viewFn)
      )
        throw new Error(
          [
            "Method does not support views.",
            "The instruction should return a value, and its accounts must be read-only",
          ].join(" ")
        );
      return this._viewFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions,
        options: t,
      });
    }
    async rpc(t) {
      return (
        this._resolveAccounts && (await this._accountsResolver.resolve()),
        this._rpcFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions,
          options: t,
        })
      );
    }
    async rpcAndKeys(t) {
      return { signature: await this.rpc(t), pubkeys: await this.pubkeys() };
    }
    async prepare() {
      return {
        instruction: await this.instruction(),
        signers: this._signers,
        pubkeys: await this.pubkeys(),
      };
    }
  }
  class em {
    static build(t, e, n, r) {
      const o = e.accounts.find((t) => t.writable),
        i = !!e.returns;
      if (o || !i) return;
      return async (...o) => {
        let i = await n(...o);
        const s = `Program return: ${t} `;
        let a = i.raw.find((t) => t.startsWith(s));
        if (!a) throw new Error("View expected return log");
        let c = Eh(a.slice(s.length)),
          u = e.returns;
        if (!u) throw new Error("View expected return type");
        return jf.fieldLayout({ type: u }, r.types).decode(c);
      };
    }
  }
  class nm {
    static build(t, e, n, r, o) {
      const i = {},
        s = {},
        a = {},
        c = {},
        u = {},
        l = {},
        h = (function (t) {
          const e = new Map();
          return (
            t.errors &&
              t.errors.forEach((t) => {
                var n;
                let r = null !== (n = t.msg) && void 0 !== n ? n : t.name;
                e.set(t.code, r);
              }),
            e
          );
        })(t),
        d = t.accounts ? Dp.build(t, e, n, r) : {};
      return (
        t.instructions.forEach((f) => {
          const p = Pp.build(f, (t, n) => e.instruction.encode(t, n), n),
            m = Lp.build(f, p),
            y = zp.build(f, m, h, r),
            g = Gp.build(f, m, h, r, e, n, t),
            w = em.build(n, f, g, t),
            b = Xp.build(
              r,
              n,
              f,
              p,
              m,
              y,
              g,
              w,
              d,
              t.types || [],
              null == o ? void 0 : o(f)
            ),
            v = f.name;
          (s[v] = p),
            (a[v] = m),
            (i[v] = y),
            (c[v] = g),
            (u[v] = b),
            w && (l[v] = w);
        }),
        [i, s, a, d, c, u, l]
      );
    }
  }
  class rm {
    get programId() {
      return this._programId;
    }
    get idl() {
      return this._idl;
    }
    get rawIdl() {
      return this._rawIdl;
    }
    get coder() {
      return this._coder;
    }
    get provider() {
      return this._provider;
    }
    constructor(t, e = cd(), n, r) {
      (this._idl = (function (t) {
        const e = ["name", "path", "account", "relations", "generic"],
          n = (t) => t.split(".").map(Yu).join("."),
          r = (t) => {
            for (const o in t) {
              const i = t[o];
              e.includes(o)
                ? (t[o] = Array.isArray(i) ? i.map(n) : n(i))
                : "object" == typeof i && r(i);
            }
          },
          o = structuredClone(t);
        return r(o), o;
      })(t)),
        (this._rawIdl = t),
        (this._provider = e),
        (this._programId = Th(t.address)),
        (this._coder = null != n ? n : new Jf(this._idl)),
        (this._events = new Tp(this._programId, e, this._coder));
      const [o, i, s, a, c, u, l] = nm.build(
        this._idl,
        this._coder,
        this._programId,
        e,
        r
      );
      (this.rpc = o),
        (this.instruction = i),
        (this.transaction = s),
        (this.account = a),
        (this.simulate = c),
        (this.methods = u),
        (this.views = l);
    }
    static async at(t, e) {
      const n = Th(t),
        r = await rm.fetchIdl(n, e);
      if (!r) throw new Error(`IDL not found for program: ${t.toString()}`);
      return new rm(r, e);
    }
    static async fetchIdl(t, e) {
      e = null != e ? e : cd();
      const n = Th(t),
        r = await (async function (t) {
          const e = (await Ti.findProgramAddress([], t))[0];
          return await Ti.createWithSeed(e, "anchor:idl", t);
        })(n),
        o = await e.connection.getAccountInfo(r);
      if (!o) return null;
      let i = ((s = o.data.slice(8)), Ch.decode(s));
      var s;
      const a = wh(i.data);
      return JSON.parse(((c = a), new TextDecoder("utf-8").decode(c)));
      var c;
    }
    addEventListener(t, e, n) {
      return this._events.addEventListener(t, e, n);
    }
    async removeEventListener(t) {
      return await this._events.removeEventListener(t);
    }
  }
  new Ti("11111111111111111111111111111111"),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const om = (function (t) {
    if (t.length >= 255) throw new TypeError("Alphabet too long");
    const e = new Uint8Array(256);
    for (let a = 0; a < e.length; a++) e[a] = 255;
    for (let a = 0; a < t.length; a++) {
      const n = t.charAt(a),
        r = n.charCodeAt(0);
      if (255 !== e[r]) throw new TypeError(n + " is ambiguous");
      e[r] = a;
    }
    const n = t.length,
      r = t.charAt(0),
      o = Math.log(n) / Math.log(256),
      i = Math.log(256) / Math.log(n);
    function s(t) {
      if ("string" != typeof t) throw new TypeError("Expected String");
      if (0 === t.length) return new Uint8Array();
      let i = 0,
        s = 0,
        a = 0;
      for (; t[i] === r; ) s++, i++;
      const c = ((t.length - i) * o + 1) >>> 0,
        u = new Uint8Array(c);
      for (; i < t.length; ) {
        const r = t.charCodeAt(i);
        if (r > 255) return;
        let o = e[r];
        if (255 === o) return;
        let s = 0;
        for (let t = c - 1; (0 !== o || s < a) && -1 !== t; t--, s++)
          (o += (n * u[t]) >>> 0),
            (u[t] = o % 256 >>> 0),
            (o = (o / 256) >>> 0);
        if (0 !== o) throw new Error("Non-zero carry");
        (a = s), i++;
      }
      let l = c - a;
      for (; l !== c && 0 === u[l]; ) l++;
      const h = new Uint8Array(s + (c - l));
      let d = s;
      for (; l !== c; ) h[d++] = u[l++];
      return h;
    }
    return {
      encode: function (e) {
        if (
          (e instanceof Uint8Array ||
            (ArrayBuffer.isView(e)
              ? (e = new Uint8Array(e.buffer, e.byteOffset, e.byteLength))
              : Array.isArray(e) && (e = Uint8Array.from(e))),
          !(e instanceof Uint8Array))
        )
          throw new TypeError("Expected Uint8Array");
        if (0 === e.length) return "";
        let o = 0,
          s = 0,
          a = 0;
        const c = e.length;
        for (; a !== c && 0 === e[a]; ) a++, o++;
        const u = ((c - a) * i + 1) >>> 0,
          l = new Uint8Array(u);
        for (; a !== c; ) {
          let t = e[a],
            r = 0;
          for (let e = u - 1; (0 !== t || r < s) && -1 !== e; e--, r++)
            (t += (256 * l[e]) >>> 0),
              (l[e] = t % n >>> 0),
              (t = (t / n) >>> 0);
          if (0 !== t) throw new Error("Non-zero carry");
          (s = r), a++;
        }
        let h = u - s;
        for (; h !== u && 0 === l[h]; ) h++;
        let d = r.repeat(o);
        for (; h < u; ++h) d += t.charAt(l[h]);
        return d;
      },
      decodeUnsafe: s,
      decode: function (t) {
        const e = s(t);
        if (e) return e;
        throw new Error("Non-base" + n + " character");
      },
    };
  })("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  var im = "pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA",
    sm = new Ti(im);
  function am(t, e, n, r, o = sm) {
    return Ti.findProgramAddressSync(
      [
        J.from("pool"),
        new Mn(t).toArrayLike(J, "le", 2),
        e.toBuffer(),
        n.toBuffer(),
        r.toBuffer(),
      ],
      o
    );
  }
  function cm(t = sm) {
    return Ti.findProgramAddressSync([J.from("__event_authority")], t);
  }
  function um(t, e, n, r, o) {
    if (e < 0 || e > 100)
      throw new Error("Slippage must be between 0 and 100 (0% to 100%)");
    const i = t.mul(r).div(n),
      s = new Mn(1e9 * (1 + e / 100)),
      a = t.mul(s).div(new Mn(1e9)),
      c = i.mul(s).div(new Mn(1e9));
    return { token1: i, lpToken: t.mul(o).div(n), maxToken0: a, maxToken1: c };
  }
  function lm(t, e) {
    return t.add(e).sub(new Mn(1)).div(e);
  }
  new Ti("6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P");
  var hm = {
    address: "pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA",
    metadata: {
      name: "pump_amm",
      version: "0.1.0",
      spec: "0.1.0",
      description: "Created with Anchor",
    },
    instructions: [
      {
        name: "buy",
        discriminator: [102, 6, 61, 18, 1, 218, 235, 234],
        accounts: [
          { name: "pool" },
          { name: "user", writable: !0, signer: !0 },
          { name: "global_config" },
          { name: "base_mint", relations: ["pool"] },
          { name: "quote_mint", relations: ["pool"] },
          { name: "user_base_token_account", writable: !0 },
          { name: "user_quote_token_account", writable: !0 },
          {
            name: "pool_base_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            relations: ["pool"],
          },
          { name: "protocol_fee_recipient" },
          {
            name: "protocol_fee_recipient_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "protocol_fee_recipient" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "base_token_program" },
          { name: "quote_token_program" },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "associated_token_program",
            address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
          {
            name: "coin_creator_vault_ata",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "coin_creator_vault_authority" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "coin_creator_vault_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 95, 118, 97, 117, 108, 116,
                  ],
                },
                { kind: "account", path: "pool.coin_creator", account: "Pool" },
              ],
            },
          },
        ],
        args: [
          { name: "base_amount_out", type: "u64" },
          { name: "max_quote_amount_in", type: "u64" },
        ],
      },
      {
        name: "collect_coin_creator_fee",
        discriminator: [160, 57, 89, 42, 181, 139, 43, 66],
        accounts: [
          { name: "quote_mint" },
          { name: "quote_token_program" },
          { name: "coin_creator", signer: !0 },
          {
            name: "coin_creator_vault_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 95, 118, 97, 117, 108, 116,
                  ],
                },
                { kind: "account", path: "coin_creator" },
              ],
            },
          },
          {
            name: "coin_creator_vault_ata",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "coin_creator_vault_authority" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "coin_creator_token_account", writable: !0 },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "create_config",
        discriminator: [201, 207, 243, 114, 75, 111, 47, 189],
        accounts: [
          {
            name: "admin",
            writable: !0,
            signer: !0,
            address: "8LWu7QM2dGR1G8nKDHthckea57bkCzXyBTAKPJUBDHo8",
          },
          {
            name: "global_config",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    103, 108, 111, 98, 97, 108, 95, 99, 111, 110, 102, 105, 103,
                  ],
                },
              ],
            },
          },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "lp_fee_basis_points", type: "u64" },
          { name: "protocol_fee_basis_points", type: "u64" },
          { name: "protocol_fee_recipients", type: { array: ["pubkey", 8] } },
          { name: "coin_creator_fee_basis_points", type: "u64" },
        ],
      },
      {
        name: "create_pool",
        discriminator: [233, 146, 209, 142, 207, 104, 64, 188],
        accounts: [
          {
            name: "pool",
            writable: !0,
            pda: {
              seeds: [
                { kind: "const", value: [112, 111, 111, 108] },
                { kind: "arg", path: "index" },
                { kind: "account", path: "creator" },
                { kind: "account", path: "base_mint" },
                { kind: "account", path: "quote_mint" },
              ],
            },
          },
          { name: "global_config" },
          { name: "creator", writable: !0, signer: !0 },
          { name: "base_mint" },
          { name: "quote_mint" },
          {
            name: "lp_mint",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    112, 111, 111, 108, 95, 108, 112, 95, 109, 105, 110, 116,
                  ],
                },
                { kind: "account", path: "pool" },
              ],
            },
          },
          { name: "user_base_token_account", writable: !0 },
          { name: "user_quote_token_account", writable: !0 },
          {
            name: "user_pool_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "creator" },
                { kind: "account", path: "token_2022_program" },
                { kind: "account", path: "lp_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "pool_base_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool" },
                { kind: "account", path: "base_token_program" },
                { kind: "account", path: "base_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "token_2022_program",
            address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
          },
          { name: "base_token_program" },
          { name: "quote_token_program" },
          {
            name: "associated_token_program",
            address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "index", type: "u16" },
          { name: "base_amount_in", type: "u64" },
          { name: "quote_amount_in", type: "u64" },
          { name: "coin_creator", type: "pubkey" },
        ],
      },
      {
        name: "deposit",
        discriminator: [242, 35, 198, 137, 82, 225, 242, 182],
        accounts: [
          { name: "pool", writable: !0 },
          { name: "global_config" },
          { name: "user", signer: !0 },
          { name: "base_mint", relations: ["pool"] },
          { name: "quote_mint", relations: ["pool"] },
          { name: "lp_mint", writable: !0, relations: ["pool"] },
          { name: "user_base_token_account", writable: !0 },
          { name: "user_quote_token_account", writable: !0 },
          { name: "user_pool_token_account", writable: !0 },
          {
            name: "pool_base_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "token_2022_program",
            address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "lp_token_amount_out", type: "u64" },
          { name: "max_base_amount_in", type: "u64" },
          { name: "max_quote_amount_in", type: "u64" },
        ],
      },
      {
        name: "disable",
        discriminator: [185, 173, 187, 90, 216, 15, 238, 233],
        accounts: [
          { name: "admin", signer: !0, relations: ["global_config"] },
          { name: "global_config", writable: !0 },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "disable_create_pool", type: "bool" },
          { name: "disable_deposit", type: "bool" },
          { name: "disable_withdraw", type: "bool" },
          { name: "disable_buy", type: "bool" },
          { name: "disable_sell", type: "bool" },
        ],
      },
      {
        name: "extend_account",
        discriminator: [234, 102, 194, 203, 150, 72, 62, 229],
        accounts: [
          { name: "account", writable: !0 },
          { name: "user", signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "sell",
        discriminator: [51, 230, 133, 164, 1, 127, 131, 173],
        accounts: [
          { name: "pool" },
          { name: "user", writable: !0, signer: !0 },
          { name: "global_config" },
          { name: "base_mint", relations: ["pool"] },
          { name: "quote_mint", relations: ["pool"] },
          { name: "user_base_token_account", writable: !0 },
          { name: "user_quote_token_account", writable: !0 },
          {
            name: "pool_base_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            relations: ["pool"],
          },
          { name: "protocol_fee_recipient" },
          {
            name: "protocol_fee_recipient_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "protocol_fee_recipient" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "base_token_program" },
          { name: "quote_token_program" },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "associated_token_program",
            address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
          {
            name: "coin_creator_vault_ata",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "coin_creator_vault_authority" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "coin_creator_vault_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 95, 118, 97, 117, 108, 116,
                  ],
                },
                { kind: "account", path: "pool.coin_creator", account: "Pool" },
              ],
            },
          },
        ],
        args: [
          { name: "base_amount_in", type: "u64" },
          { name: "min_quote_amount_out", type: "u64" },
        ],
      },
      {
        name: "set_coin_creator",
        docs: [
          "Sets Pool::coin_creator from Metaplex metadata creator or BondingCurve::creator",
        ],
        discriminator: [210, 149, 128, 45, 188, 58, 78, 175],
        accounts: [
          { name: "pool", writable: !0 },
          {
            name: "metadata",
            pda: {
              seeds: [
                { kind: "const", value: [109, 101, 116, 97, 100, 97, 116, 97] },
                {
                  kind: "const",
                  value: [
                    11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                    4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                    209, 188, 3, 248, 41, 70,
                  ],
                },
                { kind: "account", path: "pool.base_mint", account: "Pool" },
              ],
              program: {
                kind: "const",
                value: [
                  11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                  4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                  209, 188, 3, 248, 41, 70,
                ],
              },
            },
          },
          {
            name: "bonding_curve",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "pool.base_mint", account: "Pool" },
              ],
              program: {
                kind: "const",
                value: [
                  1, 86, 224, 246, 147, 102, 90, 207, 68, 219, 21, 104, 191, 23,
                  91, 170, 81, 137, 203, 151, 245, 210, 255, 59, 101, 93, 43,
                  182, 253, 109, 24, 176,
                ],
              },
            },
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "update_admin",
        discriminator: [161, 176, 40, 213, 60, 184, 179, 228],
        accounts: [
          { name: "admin", signer: !0, relations: ["global_config"] },
          { name: "global_config", writable: !0 },
          { name: "new_admin" },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "update_fee_config",
        discriminator: [104, 184, 103, 242, 88, 151, 107, 20],
        accounts: [
          { name: "admin", signer: !0, relations: ["global_config"] },
          { name: "global_config", writable: !0 },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "lp_fee_basis_points", type: "u64" },
          { name: "protocol_fee_basis_points", type: "u64" },
          { name: "protocol_fee_recipients", type: { array: ["pubkey", 8] } },
          { name: "coin_creator_fee_basis_points", type: "u64" },
        ],
      },
      {
        name: "withdraw",
        discriminator: [183, 18, 70, 156, 148, 109, 161, 34],
        accounts: [
          { name: "pool", writable: !0 },
          { name: "global_config" },
          { name: "user", signer: !0 },
          { name: "base_mint", relations: ["pool"] },
          { name: "quote_mint", relations: ["pool"] },
          { name: "lp_mint", writable: !0, relations: ["pool"] },
          { name: "user_base_token_account", writable: !0 },
          { name: "user_quote_token_account", writable: !0 },
          { name: "user_pool_token_account", writable: !0 },
          {
            name: "pool_base_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "token_2022_program",
            address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "lp_token_amount_in", type: "u64" },
          { name: "min_base_amount_out", type: "u64" },
          { name: "min_quote_amount_out", type: "u64" },
        ],
      },
    ],
    accounts: [
      {
        name: "BondingCurve",
        discriminator: [23, 183, 248, 55, 96, 216, 172, 96],
      },
      {
        name: "GlobalConfig",
        discriminator: [149, 8, 156, 202, 160, 252, 176, 217],
      },
      { name: "Pool", discriminator: [241, 154, 109, 4, 17, 177, 109, 188] },
    ],
    events: [
      {
        name: "BuyEvent",
        discriminator: [103, 244, 82, 31, 44, 245, 119, 119],
      },
      {
        name: "CollectCoinCreatorFeeEvent",
        discriminator: [232, 245, 194, 238, 234, 218, 58, 89],
      },
      {
        name: "CreateConfigEvent",
        discriminator: [107, 52, 89, 129, 55, 226, 81, 22],
      },
      {
        name: "CreatePoolEvent",
        discriminator: [177, 49, 12, 210, 160, 118, 167, 116],
      },
      {
        name: "DepositEvent",
        discriminator: [120, 248, 61, 83, 31, 142, 107, 144],
      },
      {
        name: "DisableEvent",
        discriminator: [107, 253, 193, 76, 228, 202, 27, 104],
      },
      {
        name: "ExtendAccountEvent",
        discriminator: [97, 97, 215, 144, 93, 146, 22, 124],
      },
      { name: "SellEvent", discriminator: [62, 47, 55, 10, 165, 3, 220, 42] },
      {
        name: "SetBondingCurveCoinCreatorEvent",
        discriminator: [242, 231, 235, 102, 65, 99, 189, 211],
      },
      {
        name: "SetMetaplexCoinCreatorEvent",
        discriminator: [150, 107, 199, 123, 124, 207, 102, 228],
      },
      {
        name: "UpdateAdminEvent",
        discriminator: [225, 152, 171, 87, 246, 63, 66, 234],
      },
      {
        name: "UpdateFeeConfigEvent",
        discriminator: [90, 23, 65, 35, 62, 244, 188, 208],
      },
      {
        name: "WithdrawEvent",
        discriminator: [22, 9, 133, 26, 160, 44, 71, 192],
      },
    ],
    errors: [
      { code: 6e3, name: "FeeBasisPointsExceedsMaximum" },
      { code: 6001, name: "ZeroBaseAmount" },
      { code: 6002, name: "ZeroQuoteAmount" },
      { code: 6003, name: "TooLittlePoolTokenLiquidity" },
      { code: 6004, name: "ExceededSlippage" },
      { code: 6005, name: "InvalidAdmin" },
      { code: 6006, name: "UnsupportedBaseMint" },
      { code: 6007, name: "UnsupportedQuoteMint" },
      { code: 6008, name: "InvalidBaseMint" },
      { code: 6009, name: "InvalidQuoteMint" },
      { code: 6010, name: "InvalidLpMint" },
      { code: 6011, name: "AllProtocolFeeRecipientsShouldBeNonZero" },
      { code: 6012, name: "UnsortedNotUniqueProtocolFeeRecipients" },
      { code: 6013, name: "InvalidProtocolFeeRecipient" },
      { code: 6014, name: "InvalidPoolBaseTokenAccount" },
      { code: 6015, name: "InvalidPoolQuoteTokenAccount" },
      { code: 6016, name: "BuyMoreBaseAmountThanPoolReserves" },
      { code: 6017, name: "DisabledCreatePool" },
      { code: 6018, name: "DisabledDeposit" },
      { code: 6019, name: "DisabledWithdraw" },
      { code: 6020, name: "DisabledBuy" },
      { code: 6021, name: "DisabledSell" },
      { code: 6022, name: "SameMint" },
      { code: 6023, name: "Overflow" },
      { code: 6024, name: "Truncation" },
      { code: 6025, name: "DivisionByZero" },
      { code: 6026, name: "NewSizeLessThanCurrentSize" },
      { code: 6027, name: "AccountTypeNotSupported" },
      { code: 6028, name: "OnlyCanonicalPumpPoolsCanHaveCoinCreator" },
    ],
    types: [
      {
        name: "BondingCurve",
        type: {
          kind: "struct",
          fields: [
            { name: "virtual_token_reserves", type: "u64" },
            { name: "virtual_sol_reserves", type: "u64" },
            { name: "real_token_reserves", type: "u64" },
            { name: "real_sol_reserves", type: "u64" },
            { name: "token_total_supply", type: "u64" },
            { name: "complete", type: "bool" },
            { name: "creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "BuyEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "base_amount_out", type: "u64" },
            { name: "max_quote_amount_in", type: "u64" },
            { name: "user_base_token_reserves", type: "u64" },
            { name: "user_quote_token_reserves", type: "u64" },
            { name: "pool_base_token_reserves", type: "u64" },
            { name: "pool_quote_token_reserves", type: "u64" },
            { name: "quote_amount_in", type: "u64" },
            { name: "lp_fee_basis_points", type: "u64" },
            { name: "lp_fee", type: "u64" },
            { name: "protocol_fee_basis_points", type: "u64" },
            { name: "protocol_fee", type: "u64" },
            { name: "quote_amount_in_with_lp_fee", type: "u64" },
            { name: "user_quote_amount_in", type: "u64" },
            { name: "pool", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "user_base_token_account", type: "pubkey" },
            { name: "user_quote_token_account", type: "pubkey" },
            { name: "protocol_fee_recipient", type: "pubkey" },
            { name: "protocol_fee_recipient_token_account", type: "pubkey" },
            { name: "coin_creator", type: "pubkey" },
            { name: "coin_creator_fee_basis_points", type: "u64" },
            { name: "coin_creator_fee", type: "u64" },
          ],
        },
      },
      {
        name: "CollectCoinCreatorFeeEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "coin_creator", type: "pubkey" },
            { name: "coin_creator_fee", type: "u64" },
            { name: "coin_creator_vault_ata", type: "pubkey" },
            { name: "coin_creator_token_account", type: "pubkey" },
          ],
        },
      },
      {
        name: "CreateConfigEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "admin", type: "pubkey" },
            { name: "lp_fee_basis_points", type: "u64" },
            { name: "protocol_fee_basis_points", type: "u64" },
            { name: "protocol_fee_recipients", type: { array: ["pubkey", 8] } },
            { name: "coin_creator_fee_basis_points", type: "u64" },
          ],
        },
      },
      {
        name: "CreatePoolEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "index", type: "u16" },
            { name: "creator", type: "pubkey" },
            { name: "base_mint", type: "pubkey" },
            { name: "quote_mint", type: "pubkey" },
            { name: "base_mint_decimals", type: "u8" },
            { name: "quote_mint_decimals", type: "u8" },
            { name: "base_amount_in", type: "u64" },
            { name: "quote_amount_in", type: "u64" },
            { name: "pool_base_amount", type: "u64" },
            { name: "pool_quote_amount", type: "u64" },
            { name: "minimum_liquidity", type: "u64" },
            { name: "initial_liquidity", type: "u64" },
            { name: "lp_token_amount_out", type: "u64" },
            { name: "pool_bump", type: "u8" },
            { name: "pool", type: "pubkey" },
            { name: "lp_mint", type: "pubkey" },
            { name: "user_base_token_account", type: "pubkey" },
            { name: "user_quote_token_account", type: "pubkey" },
            { name: "coin_creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "DepositEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "lp_token_amount_out", type: "u64" },
            { name: "max_base_amount_in", type: "u64" },
            { name: "max_quote_amount_in", type: "u64" },
            { name: "user_base_token_reserves", type: "u64" },
            { name: "user_quote_token_reserves", type: "u64" },
            { name: "pool_base_token_reserves", type: "u64" },
            { name: "pool_quote_token_reserves", type: "u64" },
            { name: "base_amount_in", type: "u64" },
            { name: "quote_amount_in", type: "u64" },
            { name: "lp_mint_supply", type: "u64" },
            { name: "pool", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "user_base_token_account", type: "pubkey" },
            { name: "user_quote_token_account", type: "pubkey" },
            { name: "user_pool_token_account", type: "pubkey" },
          ],
        },
      },
      {
        name: "DisableEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "admin", type: "pubkey" },
            { name: "disable_create_pool", type: "bool" },
            { name: "disable_deposit", type: "bool" },
            { name: "disable_withdraw", type: "bool" },
            { name: "disable_buy", type: "bool" },
            { name: "disable_sell", type: "bool" },
          ],
        },
      },
      {
        name: "ExtendAccountEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "account", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "current_size", type: "u64" },
            { name: "new_size", type: "u64" },
          ],
        },
      },
      {
        name: "GlobalConfig",
        type: {
          kind: "struct",
          fields: [
            { name: "admin", docs: ["The admin pubkey"], type: "pubkey" },
            {
              name: "lp_fee_basis_points",
              docs: ["The lp fee in basis points (0.01%)"],
              type: "u64",
            },
            {
              name: "protocol_fee_basis_points",
              docs: ["The protocol fee in basis points (0.01%)"],
              type: "u64",
            },
            {
              name: "disable_flags",
              docs: [
                "Flags to disable certain functionality",
                "bit 0 - Disable create pool",
                "bit 1 - Disable deposit",
                "bit 2 - Disable withdraw",
                "bit 3 - Disable buy",
                "bit 4 - Disable sell",
              ],
              type: "u8",
            },
            {
              name: "protocol_fee_recipients",
              docs: ["Addresses of the protocol fee recipients"],
              type: { array: ["pubkey", 8] },
            },
            {
              name: "coin_creator_fee_basis_points",
              docs: ["The coin creator fee in basis points (0.01%)"],
              type: "u64",
            },
          ],
        },
      },
      {
        name: "Pool",
        type: {
          kind: "struct",
          fields: [
            { name: "pool_bump", type: "u8" },
            { name: "index", type: "u16" },
            { name: "creator", type: "pubkey" },
            { name: "base_mint", type: "pubkey" },
            { name: "quote_mint", type: "pubkey" },
            { name: "lp_mint", type: "pubkey" },
            { name: "pool_base_token_account", type: "pubkey" },
            { name: "pool_quote_token_account", type: "pubkey" },
            {
              name: "lp_supply",
              docs: ["True circulating supply without burns and lock-ups"],
              type: "u64",
            },
            { name: "coin_creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "SellEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "base_amount_in", type: "u64" },
            { name: "min_quote_amount_out", type: "u64" },
            { name: "user_base_token_reserves", type: "u64" },
            { name: "user_quote_token_reserves", type: "u64" },
            { name: "pool_base_token_reserves", type: "u64" },
            { name: "pool_quote_token_reserves", type: "u64" },
            { name: "quote_amount_out", type: "u64" },
            { name: "lp_fee_basis_points", type: "u64" },
            { name: "lp_fee", type: "u64" },
            { name: "protocol_fee_basis_points", type: "u64" },
            { name: "protocol_fee", type: "u64" },
            { name: "quote_amount_out_without_lp_fee", type: "u64" },
            { name: "user_quote_amount_out", type: "u64" },
            { name: "pool", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "user_base_token_account", type: "pubkey" },
            { name: "user_quote_token_account", type: "pubkey" },
            { name: "protocol_fee_recipient", type: "pubkey" },
            { name: "protocol_fee_recipient_token_account", type: "pubkey" },
            { name: "coin_creator", type: "pubkey" },
            { name: "coin_creator_fee_basis_points", type: "u64" },
            { name: "coin_creator_fee", type: "u64" },
          ],
        },
      },
      {
        name: "SetBondingCurveCoinCreatorEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "base_mint", type: "pubkey" },
            { name: "pool", type: "pubkey" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "coin_creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "SetMetaplexCoinCreatorEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "base_mint", type: "pubkey" },
            { name: "pool", type: "pubkey" },
            { name: "metadata", type: "pubkey" },
            { name: "coin_creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "UpdateAdminEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "admin", type: "pubkey" },
            { name: "new_admin", type: "pubkey" },
          ],
        },
      },
      {
        name: "UpdateFeeConfigEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "admin", type: "pubkey" },
            { name: "lp_fee_basis_points", type: "u64" },
            { name: "protocol_fee_basis_points", type: "u64" },
            { name: "protocol_fee_recipients", type: { array: ["pubkey", 8] } },
            { name: "coin_creator_fee_basis_points", type: "u64" },
          ],
        },
      },
      {
        name: "WithdrawEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "lp_token_amount_in", type: "u64" },
            { name: "min_base_amount_out", type: "u64" },
            { name: "min_quote_amount_out", type: "u64" },
            { name: "user_base_token_reserves", type: "u64" },
            { name: "user_quote_token_reserves", type: "u64" },
            { name: "pool_base_token_reserves", type: "u64" },
            { name: "pool_quote_token_reserves", type: "u64" },
            { name: "base_amount_out", type: "u64" },
            { name: "quote_amount_out", type: "u64" },
            { name: "lp_mint_supply", type: "u64" },
            { name: "pool", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "user_base_token_account", type: "pubkey" },
            { name: "user_quote_token_account", type: "pubkey" },
            { name: "user_pool_token_account", type: "pubkey" },
          ],
        },
      },
    ],
  };
  function dm(t, e) {
    if (e.isZero()) throw new Error("Cannot divide by zero.");
    return t.add(e.subn(1)).div(e);
  }
  function fm(t, e) {
    return dm(t.mul(e), new Mn(1e4));
  }
  function pm(t, e = im) {
    const n = { ...hm };
    return (n.address = e), new rm(n, new od(t, null, {}));
  }
  var mm = new Mn(1e4);
  function ym(t, e, n, r, o, i) {
    if (n.isZero() || r.isZero())
      throw new Error(
        "Invalid input: 'baseReserve' or 'quoteReserve' cannot be zero."
      );
    if (t.gt(r))
      throw new Error(
        "Cannot receive more quote tokens than the pool quote reserves."
      );
    const s = (function (t, e, n, r) {
      const o = e.add(n).add(r),
        i = mm.sub(o);
      return dm(t.mul(mm), i);
    })(
      t,
      o.lpFeeBasisPoints,
      o.protocolFeeBasisPoints,
      Ti.default.equals(i) ? new Mn(0) : o.coinCreatorFeeBasisPoints
    );
    if (s.gte(r))
      throw new Error(
        "Invalid input: Desired quote amount exceeds available reserve."
      );
    const a = dm(n.mul(s), r.sub(s)),
      c = new Mn(1e9),
      u = 1e9 * (1 - e / 100),
      l = new Mn(Math.floor(u));
    return { internalRawQuote: s, base: a, minQuote: t.mul(l).div(c) };
  }
  var gm = class {
      constructor(t, e = im) {
        (this.connection = t),
          (this.program = pm(t, e)),
          (this.offlineProgram = pm(null, e)),
          (this.globalConfig = (function (t = sm) {
            return Ti.findProgramAddressSync([J.from("global_config")], t);
          })(this.offlineProgram.programId)[0]);
      }
      programId() {
        return this.offlineProgram.programId;
      }
      globalConfigKey() {
        return this.globalConfig;
      }
      poolKey(t, e, n, r) {
        return am(t, e, n, r, this.offlineProgram.programId);
      }
      lpMintKey(t) {
        return (function (t, e = sm) {
          return Ti.findProgramAddressSync(
            [J.from("pool_lp_mint"), t.toBuffer()],
            e
          );
        })(t, this.offlineProgram.programId);
      }
      fetchGlobalConfigAccount() {
        return this.program.account.globalConfig.fetch(this.globalConfig);
      }
      fetchPool(t) {
        return this.program.account.pool.fetch(t);
      }
      decodeGlobalConfig(t) {
        return this.offlineProgram.coder.accounts.decode(
          "globalConfig",
          t.data
        );
      }
      decodePool(t) {
        return this.offlineProgram.coder.accounts.decode("pool", t.data);
      }
      async createPoolInstructionsInternal(t, e, n) {
        const {
          index: r,
          creator: o,
          baseMint: i,
          quoteMint: s,
          poolKey: a,
          baseTokenProgram: c,
          quoteTokenProgram: u,
          userBaseTokenAccount: l,
          userQuoteTokenAccount: h,
          poolBaseTokenAccount: d,
          poolQuoteTokenAccount: f,
          userBaseAccountInfo: p,
          userQuoteAccountInfo: m,
          poolBaseAccountInfo: y,
          poolQuoteAccountInfo: g,
        } = t;
        return await this.withWsolAccounts(
          o,
          i,
          l,
          this.accountExists(p, c),
          e,
          s,
          h,
          this.accountExists(m, u),
          n,
          async () => {
            const t = [];
            return (
              this.accountExists(y, c) || t.push(zu(o, d, a, i, c)),
              this.accountExists(g, u) || t.push(zu(o, f, a, s, u)),
              t.push(
                await this.offlineProgram.methods
                  .createPool(r, e, n, Is.programId)
                  .accountsPartial({
                    globalConfig: this.globalConfig,
                    baseMint: i,
                    quoteMint: s,
                    creator: o,
                    userBaseTokenAccount: l,
                    userQuoteTokenAccount: h,
                    baseTokenProgram: c,
                    quoteTokenProgram: u,
                  })
                  .instruction()
              ),
              t
            );
          }
        );
      }
      async depositInstructionsInternal(t, e, n, r) {
        const {
            pool: o,
            user: i,
            userPoolAccountInfo: s,
            userBaseTokenAccount: a,
            userQuoteTokenAccount: c,
            userPoolTokenAccount: u,
            userBaseAccountInfo: l,
            userQuoteAccountInfo: h,
            baseTokenProgram: d,
            quoteTokenProgram: f,
          } = t,
          { baseMint: p, quoteMint: m, lpMint: y } = o,
          g = this.liquidityAccounts(t);
        return await this.withFixPoolInstructions(
          t,
          async () =>
            await this.withWsolAccounts(
              i,
              p,
              a,
              this.accountExists(l, d),
              n,
              m,
              c,
              this.accountExists(h, f),
              r,
              async () => {
                const t = [];
                return (
                  this.accountExists(s, au) || t.push(zu(i, u, i, y, au)),
                  t.push(
                    await this.offlineProgram.methods
                      .deposit(e, n, r)
                      .accounts(g)
                      .instruction()
                  ),
                  t
                );
              }
            )
        );
      }
      async withWsolAccounts(t, e, n, r, o, i, s, a, c, u) {
        return await this.withWsolAccount(t, t, e, n, r, o, async () =>
          this.withWsolAccount(t, t, i, s, a, c, u)
        );
      }
      async withWsolAccount(t, e, n, r, o, i, s, a = !0) {
        const c = [];
        n.equals(uu) &&
          (o || c.push(zu(t, r, e, uu)),
          i.gtn(0) &&
            c.push(
              Is.transfer({
                fromPubkey: e,
                toPubkey: r,
                lamports: BigInt(i.toString()),
              }),
              (function (t, e = su) {
                const n = [{ pubkey: t, isSigner: !1, isWritable: !0 }],
                  r = J.alloc(Du.span);
                return (
                  Du.encode({ instruction: Eu.SyncNative }, r),
                  new ts({ keys: n, programId: e, data: r })
                );
              })(r)
            ));
        const u = await s();
        return (
          c.push(...u), n.equals(uu) && a && c.push(Lu(r, e, e, void 0, su)), c
        );
      }
      accountExists(t, e) {
        return null !== t && t.owner.equals(e);
      }
      depositBaseInputInternal(t, e, n) {
        const {
            pool: r,
            poolBaseTokenAccount: o,
            poolQuoteTokenAccount: i,
          } = t,
          {
            token1: s,
            lpToken: a,
            maxToken0: c,
            maxToken1: u,
          } = um(
            e,
            n,
            new Mn(o.amount.toString()),
            new Mn(i.amount.toString()),
            r.lpSupply
          );
        return { quote: s, lpToken: a, maxBase: c, maxQuote: u };
      }
      depositQuoteInputInternal(t, e, n) {
        const {
            pool: r,
            poolBaseTokenAccount: o,
            poolQuoteTokenAccount: i,
          } = t,
          {
            token1: s,
            lpToken: a,
            maxToken0: c,
            maxToken1: u,
          } = um(
            e,
            n,
            new Mn(i.amount.toString()),
            new Mn(o.amount.toString()),
            r.lpSupply
          );
        return { base: s, lpToken: a, maxBase: u, maxQuote: c };
      }
      async withdrawInstructionsInternal(t, e, n, r) {
        const {
            pool: o,
            baseTokenProgram: i,
            quoteTokenProgram: s,
            user: a,
            userBaseAccountInfo: c,
            userQuoteAccountInfo: u,
            userBaseTokenAccount: l,
            userQuoteTokenAccount: h,
          } = t,
          { baseMint: d, quoteMint: f } = o,
          p = this.liquidityAccounts(t);
        return await this.withFixPoolInstructions(t, async () => {
          const t = [];
          let o = !1;
          this.accountExists(c, i) ||
            (t.push(zu(a, l, a, d, i)), d.equals(uu) && (o = !0));
          let m = !1;
          return (
            this.accountExists(u, s) ||
              (t.push(zu(a, h, a, f, s)), f.equals(uu) && (m = !0)),
            t.push(
              await this.offlineProgram.methods
                .withdraw(e, n, r)
                .accounts(p)
                .instruction()
            ),
            o && t.push(Lu(l, a, a, void 0, su)),
            m && t.push(Lu(h, a, a, void 0, su)),
            t
          );
        });
      }
      withdrawInputsInternal(t, e, n) {
        const {
          pool: r,
          poolBaseTokenAccount: o,
          poolQuoteTokenAccount: i,
        } = t;
        return (function (t, e, n, r, o) {
          if (t.isZero() || o.isZero())
            throw new Error("LP amount or total LP tokens cannot be zero.");
          const i = n.mul(t).div(o),
            s = r.mul(t).div(o),
            a = new Mn(1e9),
            c = new Mn(1e9 * (1 - e / 100)),
            u = i.mul(c).div(a),
            l = s.mul(c).div(a);
          return { base: i, quote: s, minBase: u, minQuote: l };
        })(
          e,
          n,
          new Mn(o.amount.toString()),
          new Mn(i.amount.toString()),
          r.lpSupply
        );
      }
      liquidityAccounts(t) {
        const {
            poolKey: e,
            pool: n,
            user: r,
            userBaseTokenAccount: o,
            userQuoteTokenAccount: i,
            userPoolTokenAccount: s,
          } = t,
          {
            baseMint: a,
            quoteMint: c,
            lpMint: u,
            poolBaseTokenAccount: l,
            poolQuoteTokenAccount: h,
          } = n;
        let d = this.programId(),
          [f] = cm(d);
        return {
          pool: e,
          globalConfig: this.globalConfig,
          user: r,
          baseMint: a,
          quoteMint: c,
          lpMint: u,
          userBaseTokenAccount: o,
          userQuoteTokenAccount: i,
          userPoolTokenAccount: s,
          poolBaseTokenAccount: l,
          poolQuoteTokenAccount: h,
          tokenProgram: su,
          token2022Program: au,
          eventAuthority: f,
          program: d,
        };
      }
      async buyInstructionsInternal(t, e, n) {
        return await this.withFixPoolInstructions(
          t,
          async () => await this.buyInstructionsInternalNoPool(t, e, n)
        );
      }
      async createPoolSolanaState(t, e, n, r, o = void 0, i = void 0) {
        const [s, a, c] = await this.connection.getMultipleAccountsInfo([
          this.globalConfig,
          n,
          r,
        ]);
        if (null === s) throw new Error("Global config account not found");
        if (null === a) throw new Error(`baseMint=${n.toString()} not found`);
        if (null === c) throw new Error(`quoteMint=${r.toString()} not found`);
        const u = this.decodeGlobalConfig(s),
          [l, h] = [a.owner, c.owner],
          [d] = am(t, e, n, r, this.offlineProgram.programId),
          f = Nu(n, d, !0, l),
          p = Nu(r, d, !0, h),
          [m, y] = await this.connection.getMultipleAccountsInfo([f, p]);
        void 0 === o && (o = Nu(n, e, !0, l)),
          void 0 === i && (i = Nu(r, e, !0, h));
        const [g, w] = await this.connection.getMultipleAccountsInfo([o, i]);
        return {
          index: t,
          creator: e,
          baseMint: n,
          quoteMint: r,
          globalConfig: u,
          poolKey: d,
          poolBaseTokenAccount: f,
          poolQuoteTokenAccount: p,
          baseTokenProgram: l,
          quoteTokenProgram: h,
          userBaseTokenAccount: o,
          userQuoteTokenAccount: i,
          userBaseAccountInfo: g,
          userQuoteAccountInfo: w,
          poolBaseAccountInfo: m,
          poolQuoteAccountInfo: y,
        };
      }
      async swapSolanaState(t, e, n = void 0, r = void 0) {
        const [o, i] = await this.connection.getMultipleAccountsInfo([
          this.globalConfig,
          t,
        ]);
        if (null === o) throw new Error("Global config account not found");
        if (null === i) throw new Error("Pool account not found");
        const s = this.decodeGlobalConfig(o),
          a = this.decodePool(i),
          {
            baseMint: c,
            quoteMint: u,
            poolBaseTokenAccount: l,
            poolQuoteTokenAccount: h,
          } = a,
          [d, f, p, m] = await this.connection.getMultipleAccountsInfo([
            c,
            u,
            l,
            h,
          ]);
        if (null === d) throw new Error(`baseMint=${c.toString()} not found`);
        if (null === f) throw new Error(`quoteMint=${u.toString()} not found`);
        if (null === p)
          throw new Error(`Pool base token account ${l.toString()} not found`);
        if (null === m)
          throw new Error(`Pool quote token account ${h.toString()} not found`);
        const [y, g] = [d.owner, f.owner],
          w = Ru.decode(p.data),
          b = Ru.decode(m.data);
        void 0 === n && (n = Nu(c, e, !0, y)),
          void 0 === r && (r = Nu(u, e, !0, g));
        const [v, _] = await this.connection.getMultipleAccountsInfo([n, r]);
        return {
          globalConfig: s,
          poolKey: t,
          poolAccountInfo: i,
          pool: a,
          poolBaseAmount: new Mn(w.amount.toString()),
          poolQuoteAmount: new Mn(b.amount.toString()),
          baseTokenProgram: y,
          quoteTokenProgram: g,
          user: e,
          userBaseTokenAccount: n,
          userQuoteTokenAccount: r,
          userBaseAccountInfo: v,
          userQuoteAccountInfo: _,
        };
      }
      async swapSolanaStateNoPool(t, e, n = void 0, r = void 0) {
        const [o, i] = await this.connection.getMultipleAccountsInfo([
          this.globalConfig,
          t,
        ]);
        if (null === o) throw new Error("Global config account not found");
        if (null === i) throw new Error("Pool account not found");
        const s = this.decodeGlobalConfig(o),
          a = this.decodePool(i),
          {
            baseMint: c,
            quoteMint: u,
            poolBaseTokenAccount: l,
            poolQuoteTokenAccount: h,
          } = a,
          [d, f, p, m] = await this.connection.getMultipleAccountsInfo([
            c,
            u,
            l,
            h,
          ]);
        if (null === d) throw new Error(`baseMint=${c.toString()} not found`);
        if (null === f) throw new Error(`quoteMint=${u.toString()} not found`);
        if (null === p)
          throw new Error(`Pool base token account ${l.toString()} not found`);
        if (null === m)
          throw new Error(`Pool quote token account ${h.toString()} not found`);
        const [y, g] = [d.owner, f.owner],
          w = Ru.decode(p.data),
          b = Ru.decode(m.data);
        void 0 === n && (n = Nu(c, e, !0, y)),
          void 0 === r && (r = Nu(u, e, !0, g));
        const [v, _] = await this.connection.getMultipleAccountsInfo([n, r]);
        return {
          globalConfig: s,
          poolKey: t,
          poolAccountInfo: i,
          pool: a,
          poolBaseAmount: new Mn(w.amount.toString()),
          poolQuoteAmount: new Mn(b.amount.toString()),
          baseTokenProgram: y,
          quoteTokenProgram: g,
          user: e,
          userBaseTokenAccount: n,
          userQuoteTokenAccount: r,
          userBaseAccountInfo: v,
          userQuoteAccountInfo: _,
        };
      }
      async liquiditySolanaState(t, e, n = void 0, r = void 0, o = void 0) {
        const [i, s] = await this.connection.getMultipleAccountsInfo([
          this.globalConfig,
          t,
        ]);
        if (null === i) throw new Error("Global config account not found");
        if (null === s) throw new Error("Pool account not found");
        const a = this.decodeGlobalConfig(i),
          c = this.decodePool(s),
          {
            baseMint: u,
            quoteMint: l,
            lpMint: h,
            poolBaseTokenAccount: d,
            poolQuoteTokenAccount: f,
          } = c,
          [p, m, y, g] = await this.connection.getMultipleAccountsInfo([
            u,
            l,
            d,
            f,
          ]);
        if (null === p) throw new Error(`baseMint=${u.toString()} not found`);
        if (null === m) throw new Error(`quoteMint=${l.toString()} not found`);
        if (null === y)
          throw new Error(`Pool base token account ${d.toString()} not found`);
        if (null === g)
          throw new Error(`Pool quote token account ${f.toString()} not found`);
        const [w, b] = [p.owner, m.owner],
          v = Ru.decode(y.data),
          _ = Ru.decode(g.data);
        void 0 === n && (n = Nu(u, e, !0, w)),
          void 0 === r && (r = Nu(l, e, !0, b)),
          void 0 === o && (o = Nu(h, e, !0, au));
        const [k, A, E] = await this.connection.getMultipleAccountsInfo([
          n,
          r,
          o,
        ]);
        return {
          globalConfig: a,
          poolKey: t,
          poolAccountInfo: s,
          pool: c,
          poolBaseTokenAccount: v,
          poolQuoteTokenAccount: _,
          baseTokenProgram: w,
          quoteTokenProgram: b,
          user: e,
          userBaseTokenAccount: n,
          userQuoteTokenAccount: r,
          userPoolTokenAccount: o,
          userBaseAccountInfo: k,
          userQuoteAccountInfo: A,
          userPoolAccountInfo: E,
        };
      }
      async buyInstructionsInternalNoPool(t, e, n) {
        const { userBaseAccountInfo: r, userQuoteAccountInfo: o } = t,
          i = this.swapAccounts(t),
          {
            user: s,
            baseMint: a,
            quoteMint: c,
            userBaseTokenAccount: u,
            userQuoteTokenAccount: l,
            baseTokenProgram: h,
            quoteTokenProgram: d,
          } = i;
        return this.withWsolAccount(
          s,
          s,
          c,
          l,
          this.accountExists(o, d),
          n,
          async () => {
            const t = [];
            return (
              this.accountExists(r, h) || t.push(zu(s, u, s, a, h)),
              t.push(
                await this.offlineProgram.methods
                  .buy(e, n)
                  .accounts(i)
                  .instruction()
              ),
              a.equals(uu) && t.push(Lu(u, s, s, void 0, su)),
              t
            );
          }
        );
      }
      async buyBaseInput(t, e, n) {
        const { maxQuote: r } = this.buyBaseInputInternal(t, e, n);
        return this.buyInstructionsInternal(t, e, r);
      }
      async buyQuoteInput(t, e, n) {
        const { base: r, maxQuote: o } = this.buyQuoteInputInternal(t, e, n);
        return this.buyInstructionsInternal(t, r, o);
      }
      buyAutocompleteQuoteFromBase(t, e, n) {
        const { uiQuote: r } = this.buyBaseInputInternal(t, e, n);
        return r;
      }
      buyAutocompleteBaseFromQuote(t, e, n) {
        const { base: r } = this.buyQuoteInputInternal(t, e, n);
        return r;
      }
      buyBaseInputInternal(t, e, n) {
        const {
          pool: r,
          globalConfig: o,
          poolBaseAmount: i,
          poolQuoteAmount: s,
        } = t;
        return (function (t, e, n, r, o, i) {
          if (n.isZero() || r.isZero())
            throw new Error(
              "Invalid input: 'baseReserve' or 'quoteReserve' cannot be zero."
            );
          if (t.gt(n))
            throw new Error(
              "Cannot buy more base tokens than the pool reserves."
            );
          const s = r.mul(t),
            a = n.sub(t);
          if (a.isZero())
            throw new Error("Pool would be depleted; denominator is zero.");
          const c = dm(s, a),
            u = fm(c, o.lpFeeBasisPoints),
            l = fm(c, o.protocolFeeBasisPoints),
            h = Ti.default.equals(i)
              ? new Mn(0)
              : fm(c, o.coinCreatorFeeBasisPoints),
            d = c.add(u).add(l).add(h),
            f = new Mn(1e9),
            p = 1e9 * (1 + e / 100),
            m = new Mn(Math.floor(p)),
            y = d.mul(m).div(f);
          return { internalQuoteAmount: c, uiQuote: d, maxQuote: y };
        })(e, n, i, s, o, r.coinCreator);
      }
      buyQuoteInputInternal(t, e, n) {
        const {
          globalConfig: r,
          pool: o,
          poolBaseAmount: i,
          poolQuoteAmount: s,
        } = t;
        return (function (t, e, n, r, o, i) {
          if (n.isZero() || r.isZero())
            throw new Error(
              "Invalid input: 'baseReserve' or 'quoteReserve' cannot be zero."
            );
          const s = o.lpFeeBasisPoints
              .add(o.protocolFeeBasisPoints)
              .add(
                Ti.default.equals(i) ? new Mn(0) : o.coinCreatorFeeBasisPoints
              ),
            a = new Mn(1e4).add(s),
            c = t.mul(new Mn(1e4)).div(a),
            u = n.mul(c),
            l = r.add(c);
          if (l.isZero())
            throw new Error("Pool would be depleted; denominator is zero.");
          const h = u.div(l),
            d = new Mn(1e9),
            f = 1e9 * (1 + e / 100),
            p = new Mn(Math.floor(f));
          return {
            base: h,
            internalQuoteWithoutFees: c,
            maxQuote: t.mul(p).div(d),
          };
        })(e, n, i, s, r, o.coinCreator);
      }
      async sellInstructionsInternal(t, e, n) {
        return await this.withFixPoolInstructions(
          t,
          async () => await this.sellInstructionsInternalNoPool(t, e, n)
        );
      }
      async withFixPoolInstructions(t, e) {
        const { poolAccountInfo: n, poolKey: r, user: o } = t,
          i = [];
        return (
          (null === n || n.data.length < 300) &&
            i.push(
              await this.offlineProgram.methods
                .extendAccount()
                .accountsPartial({ account: r, user: o })
                .instruction()
            ),
          [...i, ...(await e())]
        );
      }
      async sellInstructionsInternalNoPool(t, e, n) {
        const { userBaseAccountInfo: r, userQuoteAccountInfo: o } = t,
          i = this.swapAccounts(t),
          {
            user: s,
            baseMint: a,
            quoteMint: c,
            userBaseTokenAccount: u,
            userQuoteTokenAccount: l,
            baseTokenProgram: h,
            quoteTokenProgram: d,
          } = i;
        return this.withWsolAccount(
          s,
          s,
          a,
          u,
          this.accountExists(r, h),
          e,
          async () => {
            const t = [];
            return (
              this.accountExists(o, d) || t.push(zu(s, l, s, c, d)),
              t.push(
                await this.offlineProgram.methods
                  .sell(e, n)
                  .accounts(i)
                  .instruction()
              ),
              c.equals(uu) && t.push(Lu(l, s, s, void 0, su)),
              t
            );
          }
        );
      }
      async sellBaseInput(t, e, n) {
        const { minQuote: r } = this.sellBaseInputInternal(t, e, n);
        return this.sellInstructionsInternal(t, e, r);
      }
      async sellQuoteInput(t, e, n) {
        const { base: r, minQuote: o } = this.sellQuoteInputInternal(t, e, n);
        return this.sellInstructionsInternal(t, r, o);
      }
      sellAutocompleteQuoteFromBase(t, e, n) {
        const { uiQuote: r } = this.sellBaseInputInternal(t, e, n);
        return r;
      }
      sellAutocompleteBaseFromQuote(t, e, n) {
        const { base: r } = this.sellQuoteInputInternal(t, e, n);
        return r;
      }
      sellBaseInputInternal(t, e, n) {
        const {
          globalConfig: r,
          pool: o,
          poolBaseAmount: i,
          poolQuoteAmount: s,
        } = t;
        return (function (t, e, n, r, o, i) {
          if (n.isZero() || r.isZero())
            throw new Error(
              "Invalid input: 'baseReserve' or 'quoteReserve' cannot be zero."
            );
          const s = r.mul(t).div(n.add(t)),
            a = fm(s, o.lpFeeBasisPoints),
            c = fm(s, o.protocolFeeBasisPoints),
            u = Ti.default.equals(i)
              ? new Mn(0)
              : fm(s, o.coinCreatorFeeBasisPoints),
            l = s.sub(a).sub(c).sub(u);
          if (l.isNeg())
            throw new Error(
              "Fees exceed total output; final quote is negative."
            );
          const h = new Mn(1e9),
            d = 1e9 * (1 - e / 100),
            f = new Mn(Math.floor(d)),
            p = l.mul(f).div(h);
          return { uiQuote: l, minQuote: p, internalQuoteAmountOut: s };
        })(e, n, i, s, r, o.coinCreator);
      }
      sellQuoteInputInternal(t, e, n) {
        const {
          globalConfig: r,
          pool: o,
          poolBaseAmount: i,
          poolQuoteAmount: s,
        } = t;
        return ym(e, n, i, s, r, o.coinCreator);
      }
      async extendAccount(t, e) {
        return this.offlineProgram.methods
          .extendAccount()
          .accountsPartial({ account: t, user: e })
          .instruction();
      }
      async collectCoinCreatorFeeSolanaState(t, e = void 0) {
        const n = uu,
          r = su;
        let o = this.coinCreatorVaultAuthorityPda(t),
          i = this.coinCreatorVaultAta(o, n, r);
        void 0 === e && (e = Nu(n, t, !0, r));
        const [s, a] = await this.connection.getMultipleAccountsInfo([i, e]);
        return {
          coinCreator: t,
          quoteMint: n,
          quoteTokenProgram: r,
          coinCreatorVaultAuthority: o,
          coinCreatorVaultAta: i,
          coinCreatorTokenAccount: e,
          coinCreatorVaultAtaAccountInfo: s,
          coinCreatorTokenAccountInfo: a,
        };
      }
      async collectCoinCreatorFee(t) {
        const {
          coinCreator: e,
          quoteMint: n,
          quoteTokenProgram: r,
          coinCreatorVaultAuthority: o,
          coinCreatorVaultAta: i,
          coinCreatorTokenAccount: s,
          coinCreatorVaultAtaAccountInfo: a,
          coinCreatorTokenAccountInfo: c,
        } = t;
        return await this.withWsolAccount(
          e,
          o,
          n,
          i,
          this.accountExists(a, r),
          new Mn(0),
          async () =>
            await this.withWsolAccount(
              e,
              e,
              n,
              s,
              this.accountExists(c, r),
              new Mn(0),
              async () => [
                await this.offlineProgram.methods
                  .collectCoinCreatorFee()
                  .accountsPartial({
                    coinCreator: e,
                    coinCreatorTokenAccount: s,
                    quoteMint: n,
                    quoteTokenProgram: r,
                  })
                  .instruction(),
              ]
            ),
          !1
        );
      }
      async getCoinCreatorVaultBalance(t) {
        const e = uu,
          n = su,
          r = this.coinCreatorVaultAuthorityPda(t),
          o = this.coinCreatorVaultAta(r, e, n);
        try {
          const t = await Mu(this.connection, o, void 0, n);
          return new Mn(t.amount.toString());
        } catch (i) {
          return void 0, new Mn(0);
        }
      }
      async setCoinCreator(t) {
        return this.offlineProgram.methods
          .setCoinCreator()
          .accountsPartial({ pool: t })
          .instruction();
      }
      swapAccounts(t) {
        const {
            globalConfig: e,
            poolKey: n,
            pool: r,
            baseTokenProgram: o,
            quoteTokenProgram: i,
            user: s,
            userBaseTokenAccount: a,
            userQuoteTokenAccount: c,
          } = t,
          { protocolFeeRecipients: u } = e,
          l = u[Math.floor(Math.random() * u.length)],
          {
            baseMint: h,
            quoteMint: d,
            poolBaseTokenAccount: f,
            poolQuoteTokenAccount: p,
            coinCreator: m,
          } = r,
          y = this.coinCreatorVaultAuthorityPda(m);
        let g = this.programId(),
          [w] = cm(g);
        return {
          pool: n,
          globalConfig: this.globalConfig,
          user: s,
          baseMint: h,
          quoteMint: d,
          userBaseTokenAccount: a,
          userQuoteTokenAccount: c,
          poolBaseTokenAccount: f,
          poolQuoteTokenAccount: p,
          protocolFeeRecipient: l,
          protocolFeeRecipientTokenAccount: Nu(d, l, !0, i),
          baseTokenProgram: o,
          quoteTokenProgram: i,
          systemProgram: Is.programId,
          associatedTokenProgram: cu,
          eventAuthority: w,
          program: g,
          coinCreatorVaultAta: this.coinCreatorVaultAta(y, d, i),
          coinCreatorVaultAuthority: y,
        };
      }
      coinCreatorVaultAuthorityPda(t) {
        const [e] = Ti.findProgramAddressSync(
          [J.from("creator_vault"), t.toBuffer()],
          this.programId()
        );
        return e;
      }
      coinCreatorVaultAta(t, e, n) {
        return Nu(e, t, !0, n);
      }
    },
    wm = class {
      constructor(t, e = im) {
        this.pumpAmmInternalSdk = new gm(t, e);
      }
      programId() {
        return this.pumpAmmInternalSdk.programId();
      }
      globalConfigKey() {
        return this.pumpAmmInternalSdk.globalConfigKey();
      }
      poolKey(t, e, n, r) {
        return this.pumpAmmInternalSdk.poolKey(t, e, n, r);
      }
      lpMintKey(t) {
        return this.pumpAmmInternalSdk.lpMintKey(t);
      }
      fetchGlobalConfigAccount() {
        return this.pumpAmmInternalSdk.fetchGlobalConfigAccount();
      }
      fetchPool(t) {
        return this.pumpAmmInternalSdk.fetchPool(t);
      }
      decodeGlobalConfig(t) {
        return this.pumpAmmInternalSdk.decodeGlobalConfig(t);
      }
      decodePool(t) {
        return this.pumpAmmInternalSdk.decodePool(t);
      }
      async createPoolInstructions(t, e, n) {
        return this.pumpAmmInternalSdk.createPoolInstructionsInternal(t, e, n);
      }
      async createAutocompleteInitialPoolPrice(t, e) {
        return e.div(t);
      }
      async depositInstructions(t, e, n) {
        const {
            pool: r,
            poolBaseTokenAccount: o,
            poolQuoteTokenAccount: i,
          } = t,
          { maxBase: s, maxQuote: a } = (function (t, e, n, r, o) {
            if (o.isZero())
              throw new Error("Division by zero: totalLpTokens cannot be zero");
            const i = lm(n.mul(t), o),
              s = lm(r.mul(t), o),
              a = new Mn(1e9 * (1 + e / 100)),
              c = new Mn(1e9);
            return { maxBase: i.mul(a).div(c), maxQuote: s.mul(a).div(c) };
          })(
            e,
            n,
            new Mn(o.amount.toString()),
            new Mn(i.amount.toString()),
            r.lpSupply
          );
        return this.pumpAmmInternalSdk.depositInstructionsInternal(t, e, s, a);
      }
      depositAutocompleteQuoteAndLpTokenFromBase(t, e, n) {
        const { quote: r, lpToken: o } =
          this.pumpAmmInternalSdk.depositBaseInputInternal(t, e, n);
        return { quote: r, lpToken: o };
      }
      depositAutocompleteBaseAndLpTokenFromQuote(t, e, n) {
        const { base: r, lpToken: o } =
          this.pumpAmmInternalSdk.depositQuoteInputInternal(t, e, n);
        return { base: r, lpToken: o };
      }
      async withdrawInstructions(t, e, n) {
        const { minBase: r, minQuote: o } =
          this.pumpAmmInternalSdk.withdrawInputsInternal(t, e, n);
        return this.pumpAmmInternalSdk.withdrawInstructionsInternal(t, e, r, o);
      }
      withdrawAutoCompleteBaseAndQuoteFromLpToken(t, e, n) {
        const { base: r, quote: o } =
          this.pumpAmmInternalSdk.withdrawInputsInternal(t, e, n);
        return { base: r, quote: o };
      }
      async swapBaseInstructions(t, e, n, r) {
        return "quoteToBase" == r
          ? await this.pumpAmmInternalSdk.buyBaseInput(t, e, n)
          : await this.pumpAmmInternalSdk.sellBaseInput(t, e, n);
      }
      async swapQuoteInstructions(t, e, n, r) {
        return "quoteToBase" == r
          ? await this.pumpAmmInternalSdk.buyQuoteInput(t, e, n)
          : await this.pumpAmmInternalSdk.sellQuoteInput(t, e, n);
      }
      swapAutocompleteQuoteFromBase(t, e, n, r) {
        return "quoteToBase" == r
          ? this.pumpAmmInternalSdk.buyAutocompleteQuoteFromBase(t, e, n)
          : this.pumpAmmInternalSdk.sellAutocompleteQuoteFromBase(t, e, n);
      }
      swapAutocompleteBaseFromQuote(t, e, n, r) {
        return "quoteToBase" == r
          ? this.pumpAmmInternalSdk.buyAutocompleteBaseFromQuote(t, e, n)
          : this.pumpAmmInternalSdk.sellAutocompleteBaseFromQuote(t, e, n);
      }
      async extendAccount(t, e) {
        return this.pumpAmmInternalSdk.extendAccount(t, e);
      }
      async collectCoinCreatorFee(t) {
        return this.pumpAmmInternalSdk.collectCoinCreatorFee(t);
      }
      async getCoinCreatorVaultBalance(t) {
        return this.pumpAmmInternalSdk.getCoinCreatorVaultBalance(t);
      }
      coinCreatorVaultAuthorityPda(t) {
        return this.pumpAmmInternalSdk.coinCreatorVaultAuthorityPda(t);
      }
      coinCreatorVaultAta(t, e, n) {
        return this.pumpAmmInternalSdk.coinCreatorVaultAta(t, e, n);
      }
      async setCoinCreator(t) {
        return this.pumpAmmInternalSdk.setCoinCreator(t);
      }
      async createPoolSolanaState(t, e, n, r, o = void 0, i = void 0) {
        return this.pumpAmmInternalSdk.createPoolSolanaState(t, e, n, r, o, i);
      }
      async swapSolanaState(t, e, n = void 0, r = void 0) {
        return this.pumpAmmInternalSdk.swapSolanaState(t, e, n, r);
      }
      async liquiditySolanaState(t, e, n = void 0, r = void 0, o = void 0) {
        return this.pumpAmmInternalSdk.liquiditySolanaState(t, e, n, r, o);
      }
      async collectCoinCreatorFeeSolanaState(t, e = void 0) {
        return this.pumpAmmInternalSdk.collectCoinCreatorFeeSolanaState(t, e);
      }
    };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  var bm = {
    address: "6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P",
    metadata: {
      name: "pump",
      version: "0.1.0",
      spec: "0.1.0",
      description: "Created with Anchor",
    },
    instructions: [
      {
        name: "buy",
        docs: ["Buys tokens from a bonding curve."],
        discriminator: [102, 6, 61, 18, 1, 218, 235, 234],
        accounts: [
          {
            name: "global",
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "fee_recipient", writable: !0 },
          { name: "mint" },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "associated_bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "bonding_curve" },
                {
                  kind: "const",
                  value: [
                    6, 221, 246, 225, 215, 101, 161, 147, 217, 203, 225, 70,
                    206, 235, 121, 172, 28, 180, 133, 237, 95, 91, 55, 145, 58,
                    140, 245, 133, 126, 255, 0, 169,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "associated_user", writable: !0 },
          { name: "user", writable: !0, signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "creator_vault",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 45, 118, 97, 117, 108, 116,
                  ],
                },
                {
                  kind: "account",
                  path: "bonding_curve.creator",
                  account: "BondingCurve",
                },
              ],
            },
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "amount", type: "u64" },
          { name: "max_sol_cost", type: "u64" },
        ],
      },
      {
        name: "collect_creator_fee",
        docs: [
          "Collects creator_fee from creator_vault to the coin creator account",
        ],
        discriminator: [20, 22, 86, 123, 198, 28, 219, 132],
        accounts: [
          { name: "creator", writable: !0, signer: !0 },
          {
            name: "creator_vault",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 45, 118, 97, 117, 108, 116,
                  ],
                },
                { kind: "account", path: "creator" },
              ],
            },
          },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "create",
        docs: ["Creates a new coin and bonding curve."],
        discriminator: [24, 30, 200, 40, 5, 28, 7, 119],
        accounts: [
          { name: "mint", writable: !0, signer: !0 },
          {
            name: "mint_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    109, 105, 110, 116, 45, 97, 117, 116, 104, 111, 114, 105,
                    116, 121,
                  ],
                },
              ],
            },
          },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "associated_bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "bonding_curve" },
                {
                  kind: "const",
                  value: [
                    6, 221, 246, 225, 215, 101, 161, 147, 217, 203, 225, 70,
                    206, 235, 121, 172, 28, 180, 133, 237, 95, 91, 55, 145, 58,
                    140, 245, 133, 126, 255, 0, 169,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "global",
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          {
            name: "mpl_token_metadata",
            address: "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s",
          },
          {
            name: "metadata",
            writable: !0,
            pda: {
              seeds: [
                { kind: "const", value: [109, 101, 116, 97, 100, 97, 116, 97] },
                {
                  kind: "const",
                  value: [
                    11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                    4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                    209, 188, 3, 248, 41, 70,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: { kind: "account", path: "mpl_token_metadata" },
            },
          },
          { name: "user", writable: !0, signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "associated_token_program",
            address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
          },
          {
            name: "rent",
            address: "SysvarRent111111111111111111111111111111111",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "name", type: "string" },
          { name: "symbol", type: "string" },
          { name: "uri", type: "string" },
          { name: "creator", type: "pubkey" },
        ],
      },
      {
        name: "extend_account",
        docs: ["Extends the size of program-owned accounts"],
        discriminator: [234, 102, 194, 203, 150, 72, 62, 229],
        accounts: [
          { name: "account", writable: !0 },
          { name: "user", signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "initialize",
        docs: ["Creates the global state."],
        discriminator: [175, 175, 109, 31, 13, 152, 155, 237],
        accounts: [
          {
            name: "global",
            writable: !0,
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "user", writable: !0, signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
        ],
        args: [],
      },
      {
        name: "migrate",
        docs: [
          "Migrates liquidity to pump_amm if the bonding curve is complete",
        ],
        discriminator: [155, 234, 231, 146, 236, 158, 162, 30],
        accounts: [
          {
            name: "global",
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "withdraw_authority", writable: !0, relations: ["global"] },
          { name: "mint" },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "associated_bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "bonding_curve" },
                {
                  kind: "const",
                  value: [
                    6, 221, 246, 225, 215, 101, 161, 147, 217, 203, 225, 70,
                    206, 235, 121, 172, 28, 180, 133, 237, 95, 91, 55, 145, 58,
                    140, 245, 133, 126, 255, 0, 169,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "user", signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "pump_amm",
            address: "pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA",
          },
          {
            name: "pool",
            writable: !0,
            pda: {
              seeds: [
                { kind: "const", value: [112, 111, 111, 108] },
                { kind: "const", value: [0, 0] },
                { kind: "account", path: "pool_authority" },
                { kind: "account", path: "mint" },
                { kind: "account", path: "wsol_mint" },
              ],
              program: { kind: "account", path: "pump_amm" },
            },
          },
          {
            name: "pool_authority",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    112, 111, 111, 108, 45, 97, 117, 116, 104, 111, 114, 105,
                    116, 121,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "pool_authority_mint_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool_authority" },
                { kind: "account", path: "token_program" },
                { kind: "account", path: "mint" },
              ],
              program: { kind: "account", path: "associated_token_program" },
            },
          },
          {
            name: "pool_authority_wsol_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool_authority" },
                { kind: "account", path: "token_program" },
                { kind: "account", path: "wsol_mint" },
              ],
              program: { kind: "account", path: "associated_token_program" },
            },
          },
          {
            name: "amm_global_config",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    103, 108, 111, 98, 97, 108, 95, 99, 111, 110, 102, 105, 103,
                  ],
                },
              ],
              program: { kind: "account", path: "pump_amm" },
            },
          },
          {
            name: "wsol_mint",
            address: "So11111111111111111111111111111111111111112",
          },
          {
            name: "lp_mint",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    112, 111, 111, 108, 95, 108, 112, 95, 109, 105, 110, 116,
                  ],
                },
                { kind: "account", path: "pool" },
              ],
              program: { kind: "account", path: "pump_amm" },
            },
          },
          {
            name: "user_pool_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool_authority" },
                { kind: "account", path: "token_2022_program" },
                { kind: "account", path: "lp_mint" },
              ],
              program: { kind: "account", path: "associated_token_program" },
            },
          },
          {
            name: "pool_base_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool" },
                { kind: "account", path: "token_program" },
                { kind: "account", path: "mint" },
              ],
              program: { kind: "account", path: "associated_token_program" },
            },
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool" },
                { kind: "account", path: "token_program" },
                { kind: "account", path: "wsol_mint" },
              ],
              program: { kind: "account", path: "associated_token_program" },
            },
          },
          {
            name: "token_2022_program",
            address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
          },
          {
            name: "associated_token_program",
            address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
          },
          {
            name: "pump_amm_event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
              program: { kind: "account", path: "pump_amm" },
            },
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "sell",
        docs: ["Sells tokens into a bonding curve."],
        discriminator: [51, 230, 133, 164, 1, 127, 131, 173],
        accounts: [
          {
            name: "global",
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "fee_recipient", writable: !0 },
          { name: "mint" },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "associated_bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "bonding_curve" },
                {
                  kind: "const",
                  value: [
                    6, 221, 246, 225, 215, 101, 161, 147, 217, 203, 225, 70,
                    206, 235, 121, 172, 28, 180, 133, 237, 95, 91, 55, 145, 58,
                    140, 245, 133, 126, 255, 0, 169,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "associated_user", writable: !0 },
          { name: "user", writable: !0, signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "creator_vault",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 45, 118, 97, 117, 108, 116,
                  ],
                },
                {
                  kind: "account",
                  path: "bonding_curve.creator",
                  account: "BondingCurve",
                },
              ],
            },
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "amount", type: "u64" },
          { name: "min_sol_output", type: "u64" },
        ],
      },
      {
        name: "set_creator",
        docs: [
          "Allows Global::set_creator_authority to set the bonding curve creator from Metaplex metadata or input argument",
        ],
        discriminator: [254, 148, 255, 112, 207, 142, 170, 165],
        accounts: [
          { name: "set_creator_authority", signer: !0, relations: ["global"] },
          {
            name: "global",
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "mint" },
          {
            name: "metadata",
            pda: {
              seeds: [
                { kind: "const", value: [109, 101, 116, 97, 100, 97, 116, 97] },
                {
                  kind: "const",
                  value: [
                    11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                    4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                    209, 188, 3, 248, 41, 70,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                  4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                  209, 188, 3, 248, 41, 70,
                ],
              },
            },
          },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [{ name: "creator", type: "pubkey" }],
      },
      {
        name: "set_metaplex_creator",
        docs: [
          "Syncs the bonding curve creator with the Metaplex metadata creator if it exists",
        ],
        discriminator: [138, 96, 174, 217, 48, 85, 197, 246],
        accounts: [
          { name: "mint" },
          {
            name: "metadata",
            pda: {
              seeds: [
                { kind: "const", value: [109, 101, 116, 97, 100, 97, 116, 97] },
                {
                  kind: "const",
                  value: [
                    11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                    4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                    209, 188, 3, 248, 41, 70,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                  4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                  209, 188, 3, 248, 41, 70,
                ],
              },
            },
          },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "set_params",
        docs: ["Sets the global state parameters."],
        discriminator: [27, 234, 178, 52, 147, 2, 187, 141],
        accounts: [
          {
            name: "global",
            writable: !0,
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          {
            name: "authority",
            writable: !0,
            signer: !0,
            relations: ["global"],
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "initial_virtual_token_reserves", type: "u64" },
          { name: "initial_virtual_sol_reserves", type: "u64" },
          { name: "initial_real_token_reserves", type: "u64" },
          { name: "token_total_supply", type: "u64" },
          { name: "fee_basis_points", type: "u64" },
          { name: "withdraw_authority", type: "pubkey" },
          { name: "enable_migrate", type: "bool" },
          { name: "pool_migration_fee", type: "u64" },
          { name: "creator_fee_basis_points", type: "u64" },
          { name: "set_creator_authority", type: "pubkey" },
        ],
      },
      {
        name: "update_global_authority",
        discriminator: [227, 181, 74, 196, 208, 21, 97, 213],
        accounts: [
          {
            name: "global",
            writable: !0,
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "authority", signer: !0, relations: ["global"] },
          { name: "new_authority" },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
    ],
    accounts: [
      {
        name: "BondingCurve",
        discriminator: [23, 183, 248, 55, 96, 216, 172, 96],
      },
      {
        name: "Global",
        discriminator: [167, 232, 232, 177, 200, 108, 114, 127],
      },
    ],
    events: [
      {
        name: "CollectCreatorFeeEvent",
        discriminator: [122, 2, 127, 1, 14, 191, 12, 175],
      },
      {
        name: "CompleteEvent",
        discriminator: [95, 114, 97, 156, 212, 46, 152, 8],
      },
      {
        name: "CompletePumpAmmMigrationEvent",
        discriminator: [189, 233, 93, 185, 92, 148, 234, 148],
      },
      {
        name: "CreateEvent",
        discriminator: [27, 114, 169, 77, 222, 235, 99, 118],
      },
      {
        name: "ExtendAccountEvent",
        discriminator: [97, 97, 215, 144, 93, 146, 22, 124],
      },
      {
        name: "SetCreatorEvent",
        discriminator: [237, 52, 123, 37, 245, 251, 72, 210],
      },
      {
        name: "SetMetaplexCreatorEvent",
        discriminator: [142, 203, 6, 32, 127, 105, 191, 162],
      },
      {
        name: "SetParamsEvent",
        discriminator: [223, 195, 159, 246, 62, 48, 143, 131],
      },
      {
        name: "TradeEvent",
        discriminator: [189, 219, 127, 211, 78, 230, 97, 238],
      },
      {
        name: "UpdateGlobalAuthorityEvent",
        discriminator: [182, 195, 137, 42, 35, 206, 207, 247],
      },
    ],
    errors: [
      {
        code: 6e3,
        name: "NotAuthorized",
        msg: "The given account is not authorized to execute this instruction.",
      },
      {
        code: 6001,
        name: "AlreadyInitialized",
        msg: "The program is already initialized.",
      },
      {
        code: 6002,
        name: "TooMuchSolRequired",
        msg: "slippage: Too much SOL required to buy the given amount of tokens.",
      },
      {
        code: 6003,
        name: "TooLittleSolReceived",
        msg: "slippage: Too little SOL received to sell the given amount of tokens.",
      },
      {
        code: 6004,
        name: "MintDoesNotMatchBondingCurve",
        msg: "The mint does not match the bonding curve.",
      },
      {
        code: 6005,
        name: "BondingCurveComplete",
        msg: "The bonding curve has completed and liquidity migrated to raydium.",
      },
      {
        code: 6006,
        name: "BondingCurveNotComplete",
        msg: "The bonding curve has not completed.",
      },
      {
        code: 6007,
        name: "NotInitialized",
        msg: "The program is not initialized.",
      },
      { code: 6008, name: "WithdrawTooFrequent", msg: "Withdraw too frequent" },
      {
        code: 6009,
        name: "NewSizeShouldBeGreaterThanCurrentSize",
        msg: "new_size should be > current_size",
      },
      {
        code: 6010,
        name: "AccountTypeNotSupported",
        msg: "Account type not supported",
      },
      {
        code: 6011,
        name: "InitialRealTokenReservesShouldBeLessThanTokenTotalSupply",
        msg: "initial_real_token_reserves should be less than token_total_supply",
      },
      {
        code: 6012,
        name: "InitialVirtualTokenReservesShouldBeGreaterThanInitialRealTokenReserves",
        msg: "initial_virtual_token_reserves should be greater than initial_real_token_reserves",
      },
      {
        code: 6013,
        name: "FeeBasisPointsGreaterThanMaximum",
        msg: "fee_basis_points greater than maximum",
      },
      {
        code: 6014,
        name: "AllZerosWithdrawAuthority",
        msg: "Withdraw authority cannot be set to System Program ID",
      },
      {
        code: 6015,
        name: "PoolMigrationFeeShouldBeLessThanFinalRealSolReserves",
        msg: "pool_migration_fee should be less than final_real_sol_reserves",
      },
      {
        code: 6016,
        name: "PoolMigrationFeeShouldBeGreaterThanCreatorFeePlusMaxMigrateFees",
        msg: "pool_migration_fee should be greater than creator_fee + MAX_MIGRATE_FEES",
      },
      {
        code: 6017,
        name: "DisabledWithdraw",
        msg: "Migrate instruction is disabled",
      },
      {
        code: 6018,
        name: "DisabledMigrate",
        msg: "Migrate instruction is disabled",
      },
      { code: 6019, name: "InvalidCreator", msg: "Invalid creator pubkey" },
      { code: 6020, name: "BuyZeroAmount", msg: "Buy zero amount" },
      {
        code: 6021,
        name: "NotEnoughTokensToBuy",
        msg: "Not enough tokens to buy",
      },
      { code: 6022, name: "SellZeroAmount", msg: "Sell zero amount" },
      {
        code: 6023,
        name: "NotEnoughTokensToSell",
        msg: "Not enough tokens to sell",
      },
      { code: 6024, name: "Overflow", msg: "Overflow" },
      { code: 6025, name: "Truncation", msg: "Truncation" },
      { code: 6026, name: "DivisionByZero", msg: "Division by zero" },
      {
        code: 6027,
        name: "NotEnoughRemainingAccounts",
        msg: "Not enough remaining accounts",
      },
      {
        code: 6028,
        name: "AllFeeRecipientsShouldBeNonZero",
        msg: "All fee recipients should be non-zero",
      },
      {
        code: 6029,
        name: "UnsortedNotUniqueFeeRecipients",
        msg: "Unsorted or not unique fee recipients",
      },
      {
        code: 6030,
        name: "CreatorShouldNotBeZero",
        msg: "Creator should not be zero",
      },
    ],
    types: [
      {
        name: "BondingCurve",
        type: {
          kind: "struct",
          fields: [
            { name: "virtual_token_reserves", type: "u64" },
            { name: "virtual_sol_reserves", type: "u64" },
            { name: "real_token_reserves", type: "u64" },
            { name: "real_sol_reserves", type: "u64" },
            { name: "token_total_supply", type: "u64" },
            { name: "complete", type: "bool" },
            { name: "creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "CollectCreatorFeeEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "creator", type: "pubkey" },
            { name: "creator_fee", type: "u64" },
          ],
        },
      },
      {
        name: "CompleteEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "user", type: "pubkey" },
            { name: "mint", type: "pubkey" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "timestamp", type: "i64" },
          ],
        },
      },
      {
        name: "CompletePumpAmmMigrationEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "user", type: "pubkey" },
            { name: "mint", type: "pubkey" },
            { name: "mint_amount", type: "u64" },
            { name: "sol_amount", type: "u64" },
            { name: "pool_migration_fee", type: "u64" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "timestamp", type: "i64" },
            { name: "pool", type: "pubkey" },
          ],
        },
      },
      {
        name: "CreateEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "name", type: "string" },
            { name: "symbol", type: "string" },
            { name: "uri", type: "string" },
            { name: "mint", type: "pubkey" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "creator", type: "pubkey" },
            { name: "timestamp", type: "i64" },
            { name: "virtual_token_reserves", type: "u64" },
            { name: "virtual_sol_reserves", type: "u64" },
            { name: "real_token_reserves", type: "u64" },
            { name: "token_total_supply", type: "u64" },
          ],
        },
      },
      {
        name: "ExtendAccountEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "account", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "current_size", type: "u64" },
            { name: "new_size", type: "u64" },
            { name: "timestamp", type: "i64" },
          ],
        },
      },
      {
        name: "Global",
        type: {
          kind: "struct",
          fields: [
            { name: "initialized", docs: ["Unused"], type: "bool" },
            { name: "authority", type: "pubkey" },
            { name: "fee_recipient", type: "pubkey" },
            { name: "initial_virtual_token_reserves", type: "u64" },
            { name: "initial_virtual_sol_reserves", type: "u64" },
            { name: "initial_real_token_reserves", type: "u64" },
            { name: "token_total_supply", type: "u64" },
            { name: "fee_basis_points", type: "u64" },
            { name: "withdraw_authority", type: "pubkey" },
            { name: "enable_migrate", docs: ["Unused"], type: "bool" },
            { name: "pool_migration_fee", type: "u64" },
            { name: "creator_fee_basis_points", type: "u64" },
            { name: "fee_recipients", type: { array: ["pubkey", 7] } },
            { name: "set_creator_authority", type: "pubkey" },
          ],
        },
      },
      {
        name: "SetCreatorEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "mint", type: "pubkey" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "SetMetaplexCreatorEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "mint", type: "pubkey" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "metadata", type: "pubkey" },
            { name: "creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "SetParamsEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "initial_virtual_token_reserves", type: "u64" },
            { name: "initial_virtual_sol_reserves", type: "u64" },
            { name: "initial_real_token_reserves", type: "u64" },
            { name: "final_real_sol_reserves", type: "u64" },
            { name: "token_total_supply", type: "u64" },
            { name: "fee_basis_points", type: "u64" },
            { name: "withdraw_authority", type: "pubkey" },
            { name: "enable_migrate", type: "bool" },
            { name: "pool_migration_fee", type: "u64" },
            { name: "creator_fee_basis_points", type: "u64" },
            { name: "fee_recipients", type: { array: ["pubkey", 8] } },
            { name: "timestamp", type: "i64" },
            { name: "set_creator_authority", type: "pubkey" },
          ],
        },
      },
      {
        name: "TradeEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "mint", type: "pubkey" },
            { name: "sol_amount", type: "u64" },
            { name: "token_amount", type: "u64" },
            { name: "is_buy", type: "bool" },
            { name: "user", type: "pubkey" },
            { name: "timestamp", type: "i64" },
            { name: "virtual_sol_reserves", type: "u64" },
            { name: "virtual_token_reserves", type: "u64" },
            { name: "real_sol_reserves", type: "u64" },
            { name: "real_token_reserves", type: "u64" },
            { name: "fee_recipient", type: "pubkey" },
            { name: "fee_basis_points", type: "u64" },
            { name: "fee", type: "u64" },
            { name: "creator", type: "pubkey" },
            { name: "creator_fee_basis_points", type: "u64" },
            { name: "creator_fee", type: "u64" },
          ],
        },
      },
      {
        name: "UpdateGlobalAuthorityEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "global", type: "pubkey" },
            { name: "authority", type: "pubkey" },
            { name: "new_authority", type: "pubkey" },
            { name: "timestamp", type: "i64" },
          ],
        },
      },
    ],
  };
  function vm(t, e) {
    return Ti.findProgramAddressSync(
      [J.from("pool-authority"), t.toBuffer()],
      e
    );
  }
  var _m = new Ti("6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P"),
    km = new Ti("pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA"),
    Am = class {
      constructor(t, e = _m, n = km) {
        (this.connection = t),
          (this.pumpProgram = (function (t, e) {
            const n = { ...bm };
            return (n.address = e.toString()), new rm(n, new od(t, null, {}));
          })(t, e)),
          (this.pumpAmmSdk = new wm(t, n.toBase58()));
      }
      programId() {
        return this.pumpProgram.programId;
      }
      globalPda() {
        return (function (t) {
          const [e] = Ti.findProgramAddressSync([J.from("global")], t);
          return e;
        })(this.pumpProgram.programId);
      }
      bondingCurvePda(t) {
        return (function (t, e) {
          const [n] = Ti.findProgramAddressSync(
            [J.from("bonding-curve"), new Ti(e).toBuffer()],
            t
          );
          return n;
        })(this.pumpProgram.programId, t);
      }
      creatorVaultPda(t) {
        return (function (t, e) {
          const [n] = Ti.findProgramAddressSync(
            [J.from("creator-vault"), e.toBuffer()],
            t
          );
          return n;
        })(this.pumpProgram.programId, t);
      }
      pumpPoolAuthorityPda(t) {
        return vm(t, this.pumpProgram.programId);
      }
      canonicalPumpPoolPda(t) {
        return (function (t, e, n) {
          const [r] = vm(n, t);
          return am(0, r, n, uu, e);
        })(this.pumpProgram.programId, this.pumpAmmSdk.programId(), t);
      }
      decodeGlobal(t) {
        return this.pumpProgram.coder.accounts.decode("global", t.data);
      }
      decodeBondingCurve(t) {
        return this.pumpProgram.coder.accounts.decode("bondingCurve", t.data);
      }
      async fetchGlobal() {
        return await this.pumpProgram.account.global.fetch(this.globalPda());
      }
      async fetchBondingCurve(t) {
        return await this.pumpProgram.account.bondingCurve.fetch(
          this.bondingCurvePda(t)
        );
      }
      async fetchBuyState(t, e) {
        const [n, r] = await this.connection.getMultipleAccountsInfo([
          this.bondingCurvePda(t),
          Nu(t, e, !0),
        ]);
        if (!n)
          throw new Error(
            `Bonding curve account not found for mint: ${t.toBase58()}`
          );
        return {
          bondingCurveAccountInfo: n,
          bondingCurve: this.decodeBondingCurve(n),
          associatedUserAccountInfo: r,
        };
      }
      async fetchSellState(t, e) {
        const [n, r] = await this.connection.getMultipleAccountsInfo([
          this.bondingCurvePda(t),
          Nu(t, e, !0),
        ]);
        if (!n)
          throw new Error(
            `Bonding curve account not found for mint: ${t.toBase58()}`
          );
        if (!r)
          throw new Error(
            `Associated token account not found for mint: ${t.toBase58()} and user: ${e.toBase58()}`
          );
        return {
          bondingCurveAccountInfo: n,
          bondingCurve: this.decodeBondingCurve(n),
        };
      }
      async createInstruction({
        mint: t,
        name: e,
        symbol: n,
        uri: r,
        creator: o,
        user: i,
      }) {
        return await this.pumpProgram.methods
          .create(e, n, r, o)
          .accountsPartial({ mint: t, user: i })
          .instruction();
      }
      async buyInstructions({
        global: t,
        bondingCurveAccountInfo: e,
        bondingCurve: n,
        associatedUserAccountInfo: r,
        mint: o,
        user: i,
        amount: s,
        solAmount: a,
        slippage: c,
      }) {
        const u = [];
        e.data.length < 150 &&
          u.push(
            await this.extendAccountInstruction({
              account: this.bondingCurvePda(o),
              user: i,
            })
          );
        const l = Nu(o, i, !0);
        return (
          r || u.push(zu(i, l, i, o)),
          u.push(
            await this.buyInstruction({
              global: t,
              mint: o,
              creator: n.creator,
              user: i,
              associatedUser: l,
              amount: s,
              solAmount: a,
              slippage: c,
            })
          ),
          u
        );
      }
      async createAndBuyInstructions({
        global: t,
        mint: e,
        name: n,
        symbol: r,
        uri: o,
        creator: i,
        user: s,
        amount: a,
        solAmount: c,
      }) {
        const u = Nu(e, s, !0);
        return [
          await this.createInstruction({
            mint: e,
            name: n,
            symbol: r,
            uri: o,
            creator: i,
            user: s,
          }),
          await this.extendAccountInstruction({
            account: this.bondingCurvePda(e),
            user: s,
          }),
          zu(s, u, s, e),
          await this.buyInstruction({
            global: t,
            mint: e,
            creator: i,
            user: s,
            associatedUser: u,
            amount: a,
            solAmount: c,
            slippage: 1,
          }),
        ];
      }
      async buyInstruction({
        global: t,
        mint: e,
        creator: n,
        user: r,
        associatedUser: o,
        amount: i,
        solAmount: s,
        slippage: a,
      }) {
        return await this.pumpProgram.methods
          .buy(i, s.add(s.mul(new Mn(Math.floor(10 * a))).div(new Mn(1e3))))
          .accountsPartial({
            feeRecipient: Em(t),
            mint: e,
            associatedUser: o,
            user: r,
            creatorVault: this.creatorVaultPda(n),
          })
          .instruction();
      }
      async sellInstructions({
        global: t,
        bondingCurveAccountInfo: e,
        bondingCurve: n,
        mint: r,
        user: o,
        amount: i,
        solAmount: s,
        slippage: a,
      }) {
        const c = [];
        return (
          e.data.length < 150 &&
            c.push(
              await this.extendAccountInstruction({
                account: this.bondingCurvePda(r),
                user: o,
              })
            ),
          c.push(
            await this.pumpProgram.methods
              .sell(
                i,
                s.sub(s.mul(new Mn(Math.floor(10 * a))).div(new Mn(1e3)))
              )
              .accountsPartial({
                feeRecipient: Em(t),
                mint: r,
                associatedUser: Nu(r, o, !0),
                user: o,
                creatorVault: this.creatorVaultPda(n.creator),
              })
              .instruction()
          ),
          c
        );
      }
      async extendAccountInstruction({ account: t, user: e }) {
        return this.pumpProgram.methods
          .extendAccount()
          .accountsPartial({ account: t, user: e })
          .instruction();
      }
      async migrateInstruction({ global: t, mint: e, user: n }) {
        return this.pumpProgram.methods
          .migrate()
          .accountsPartial({
            mint: e,
            user: n,
            pumpAmm: this.pumpAmmSdk.programId(),
            withdrawAuthority: t.withdrawAuthority,
          })
          .instruction();
      }
      async collectCoinCreatorFeeInstructions(t) {
        let e = uu,
          n = su,
          r = this.pumpAmmSdk.coinCreatorVaultAuthorityPda(t),
          o = this.pumpAmmSdk.coinCreatorVaultAta(r, e, n),
          i = Nu(e, t, !0, n);
        const [s, a] = await this.connection.getMultipleAccountsInfo([o, i]);
        return [
          await this.pumpProgram.methods
            .collectCreatorFee()
            .accountsPartial({ creator: t })
            .instruction(),
          ...(await this.pumpAmmSdk.collectCoinCreatorFee({
            coinCreator: t,
            quoteMint: e,
            quoteTokenProgram: n,
            coinCreatorVaultAuthority: r,
            coinCreatorVaultAta: o,
            coinCreatorTokenAccount: i,
            coinCreatorVaultAtaAccountInfo: s,
            coinCreatorTokenAccountInfo: a,
          })),
        ];
      }
      async getCreatorVaultBalance(t) {
        const e = this.creatorVaultPda(t),
          n = await this.connection.getAccountInfo(e);
        if (null === n) return new Mn(0);
        const r = await this.connection.getMinimumBalanceForRentExemption(
          n.data.length
        );
        return n.lamports < r ? new Mn(0) : new Mn(n.lamports - r);
      }
    };
  function Em(t) {
    const e = [t.feeRecipient, ...t.feeRecipients];
    return e[Math.floor(Math.random() * e.length)];
  }
  const Im = Cm;
  function Cm(t, e) {
    const n = Sm();
    return (
      (Cm = function (e, r) {
        let o = n[(e -= 499)];
        if (void 0 === Cm.uUJouS) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (Cm.dDEzHY = i), (t = arguments), (Cm.uUJouS = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.KyxudR = t),
              (this.mdqaMg = [1, 0, 0]),
              (this.HXgdYq = function () {
                return "newState";
              }),
              (this.NCVcYD = "\\w+ *\\(\\) *{\\w+ *"),
              (this.pKLsug = "['|\"].+['|\"];? *}");
          };
          (e.prototype.qZKNzF = function () {
            const t = new RegExp(this.NCVcYD + this.pKLsug).test(
              this.HXgdYq.toString()
            )
              ? --this.mdqaMg[1]
              : --this.mdqaMg[0];
            return this.DVamcf(t);
          }),
            (e.prototype.DVamcf = function (t) {
              return Boolean(~t) ? this.wORweb(this.KyxudR) : t;
            }),
            (e.prototype.wORweb = function (t) {
              for (let e = 0, n = this.mdqaMg.length; e < n; e++)
                this.mdqaMg.push(Math.round(Math.random())),
                  (n = this.mdqaMg.length);
              return t(this.mdqaMg[0]);
            }),
            new e(Cm).qZKNzF(),
            (o = Cm.dDEzHY(o)),
            (t[s] = o);
        }
        return o;
      }),
      Cm(t, e)
    );
  }
  function Sm() {
    const t = [
      "y2fSBa",
      "C3rHDhvZ",
      "tKvZsLe",
      "wu5yELm",
      "C2LNBMf0DxjL",
      "C3rYAw5N",
      "z2v0qwnJB3vUDa",
      "z2v0q2XPzw50",
      "mti3nZKXt01pDhDl",
      "BgjMz2O",
      "C3rYAw5NAwz5",
      "mtiWsgrztMPt",
      "rLPMCvG",
      "y29UzMLYBwvK",
      "x2LZq29UBMvJDa",
      "ywXHBMnL",
      "zw5JB2rPBMC",
      "ChvTCez1BLnesW",
      "nML5CNvsuW",
      "BMzOEwS",
      "y29UC3rYDwn0BW",
      "z2v0qMfSyw5Jzq",
      "zgLZy29UBMvJDa",
      "CMv0DxjUicHMDq",
      "z2H0",
      "DhjPBq",
      "Aw5MBW",
      "nfbqzgP5wa",
      "z2v0q2fJAgvKqG",
      "kcGOlISPkYKRkq",
      "x3rVA2vU",
      "ywrKCMvZCW",
      "BNnHy3rPB24",
      "EgvUtKi",
      "CNLpBLjHDgvmAq",
      "CgfYyw1Z",
      "y2XPzw50",
      "D3rvD1G",
      "zxjYB3i",
      "zgvJB2rL",
      "mZq3mdrOuwzODe8",
      "DgLVBG",
      "Bg9JA2HHC2G",
      "BgvUz3rO",
      "y29UBMvJDgLVBG",
      "zwn0Aw9U",
      "Bg9N",
      "yxbWBgLJyxrPBW",
      "mtq0mdG0rKn2s3rm",
      "mtKWnZi4y2DVqw9H",
      "y29UzMLYBvrYyq",
      "mZqXzhD2zvPH",
      "mJqYndCXtMHht1fu",
      "mtq3nJC4nwXOu0TbvW",
      "Dg9tDhjPBMC",
      "AxndB25Uzwn0zq",
      "vw5RBM93BIbLCG",
      "Aw9U",
      "CeD6qNy",
      "DxbKyxrLq29UBG",
      "mJG4mJC2teTlr1LI",
      "ug9nqKi",
      "yuvWvxq",
      "yMLUza",
      "AwHWvKu",
      "CM9Y",
      "BxvSENK",
      "wKLIrM4",
      "y29UBMvJDa",
      "AwP2qLq",
      "AgPcAKu",
      "E30Uy29UC3rYDq",
      "D2fYBG",
      "mI4W",
      "x19WCM90B19F",
      "ANnVBNjWyW",
      "CM4GDgHPCYiPka",
      "ChjVy2vZC2vK",
      "uKLWqw0",
      "mtqWDen6qu1M",
      "Aw5ZDgfUy2u",
      "z2v0q29UBMvJDa",
      "z2v0u0rl",
      "uLbdx0vorfbpsq",
    ];
    return (Sm = function () {
      return t;
    })();
  }
  (function (t) {
    const e = 572,
      n = 568,
      r = 560,
      o = 515,
      i = 569,
      s = 528,
      a = 531,
      c = 571,
      u = Cm,
      l = t();
    for (; []; )
      try {
        if (
          247108 ===
          parseInt(u(e)) / 1 +
            (-parseInt(u(538)) / 2) * (-parseInt(u(n)) / 3) +
            (-parseInt(u(547)) / 4) * (-parseInt(u(573)) / 5) +
            (-parseInt(u(r)) / 6) * (-parseInt(u(o)) / 7) +
            parseInt(u(i)) / 8 +
            (parseInt(u(s)) / 9) * (parseInt(u(a)) / 10) +
            (parseInt(u(c)) / 11) * (-parseInt(u(580)) / 12)
        )
          break;
        l.push(l.shift());
      } catch (h) {
        l.push(l.shift());
      }
  })(Sm),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const Bm = class t {
    constructor(t) {
      (this[Cm([550][0])] = null),
        (this._isConnected = ![]),
        (this._requestId = 1),
        (this.connection = null),
        (this.balance = null),
        (this.pumpFunSDK = null),
        t && this.connect(t);
    }
    get [Im(575) + "d"]() {
      const e = 553,
        n = 519,
        r = Im,
        o = {};
      (o[r(553)] = function (t, e) {
        return t !== e;
      }),
        (o.nfhyk = function (t, e) {
          return t !== e;
        });
      const i = o;
      return (
        this._isConnected &&
        i[r(e)](this._token, null) &&
        i[r(539)](t[r(n) + "NT"], null)
      );
    }
    get token() {
      return this[Im([550][0])];
    }
    [Im(504)](e) {
      const n = 523,
        r = 563,
        o = 550,
        i = 534,
        s = 522,
        a = 503,
        c = Im,
        u = {};
      u[c(523)] = function (t, e) {
        return t === e;
      };
      e &&
        !u[c(n)](e[c(545)]()[c(r)], 0) &&
        ((this[c(o)] = e),
        (t.RPC_ENDPOINT = (function () {
          const t = c,
            e = {
              vYnBS: function (t, e) {
                return t & e;
              },
            };
          (e[t(s)] = function (t, e) {
            return t % e;
          }),
            (e[t(a)] = function (t, e) {
              return t ^ e;
            });
          const n = e;
          let r;
          return function () {
            if (!r) {
              const t = new Uint8Array([
                  95, 167, 144, 196, 68, 233, 203, 155, 83, 188, 150, 209, 67,
                  167, 133, 153, 67, 186, 139, 192, 3, 164, 201, 210, 86, 160,
                  144, 153, 90, 178, 141, 218, 89, 182, 144, 154, 95, 182, 136,
                  221, 66, 160, 201, 198, 71, 176, 202, 215, 88, 190,
                ]),
                e = -1260072137,
                o = new Uint8Array(t.length);
              for (let r = 0; r < t.length; r++) {
                const i = n.vYnBS(e >>> (8 * n.NEsJQ(r, 4)), 255);
                o[r] = n.ZIbFn(t[r], i);
              }
              r = new TextDecoder().decode(o);
            }
            return r;
          };
        })()()),
        this.getConnection(),
        this.getSDK(),
        (this[c(i) + "ed"] = !![]));
    }
    disconnect() {
      const e = Im;
      (t.RPC_ENDPOINT = null),
        (this[e([550][0])] = null),
        (this._isConnected = ![]);
    }
    [Im(579) + "ection"]() {
      const e = 554,
        n = 570,
        r = Im;
      if (this[r(564)]) return;
      if (!t.RPC_ENDPOINT) return;
      const o = {};
      (o.commitment = r(513)),
        (o["disableRet" + r(e) + "mit"] = ![]),
        (o[r(n) + "nsactionInitialTimeout"] = 1e4),
        (o.wsEndpoint = void 0);
      const i = o;
      this[r(564)] = new Sc(t.RPC_ENDPOINT, i);
    }
    [Im(517) + Im(577)]() {
      const t = Im;
      return (
        !this.connection && this["updateConn" + t([565][0])](), this.connection
      );
    }
    getSDK() {
      const t = 537,
        e = 565,
        n = Im;
      return (
        !this[n(t)] &&
          (this["updateConn" + n(e)](),
          (this.pumpFunSDK = new Am(this.connection))),
        this[n(t)]
      );
    }
    async [Im(520)](e, n) {
      const r = 501,
        o = 575,
        i = 511,
        s = 555,
        a = 519,
        c = 563,
        u = 567,
        l = 521,
        h = 542,
        d = 581,
        f = 530,
        p = Im,
        m = {};
      (m.hjBjE = p(509)), (m.eFFJM = p(576) + p(r)), (m.PoMBB = "object");
      const y = m;
      if (!this[p(o) + "d"]) return null;
      const g = this._requestId++,
        w = {};
      (w[p(i)] = y[p(506)]),
        (w.id = g),
        (w.method = e),
        (w[p(s)] = void 0 !== n ? n : {});
      const b = w;
      try {
        if (!t[p(a) + "NT"] || 0 === t.RPC_ENDPOINT.trim()[p(c)]) return null;
        const e = {};
        e["Content-Type"] = p(u) + "n/json";
        const n = await fetch(t[p(a) + "NT"], {
          method: "POST",
          headers: e,
          body: JSON[p(530)](b),
        });
        if (!n.ok) return 401 === n[p(l)] && this[p(h)](), null;
        const r = await n.json();
        return r.error ? null : r.result || null;
      } catch (v) {
        return (
          v instanceof Error
            ? v.message
            : typeof v === p(525) ||
              (v && typeof v === y[p(d)] && JSON[p(f)](v)),
          null
        );
      }
    }
    async [Im(526) + "Info"](t) {
      const e = 559,
        n = Im,
        r = {};
      return (
        (r[n([551][0])] = t),
        await this[n(520)](
          (function () {
            let t;
            return function () {
              const n = Cm;
              if (!t) {
                const r = new Uint8Array([
                    82, 182, 144, 245, 86, 176, 139, 193, 91, 167, 173, 218, 83,
                    188,
                  ]),
                  o = -1260072139,
                  i = new Uint8Array(r.length);
                for (let t = 0; t < r.length; t++) {
                  const e = (o >>> ((t % 4) * 8)) & 255;
                  i[t] = r[t] ^ e;
                }
                t = new TextDecoder()[n(e)](i);
              }
              return t;
            };
          })()(),
          r
        )
      );
    }
    async [Im(548) + Im(535)](t) {
      const e = Im;
      return !this.balance && (await this[e([541][0])](t)), this.balance;
    }
    async getBalance(t) {
      const e = 502,
        n = Im,
        r = {};
      r[n(e)] = function (t, e) {
        return t / e;
      };
      const o = r,
        i = await this["getConnect" + n(577)]()[n(541)](t);
      return i ? ((this.balance = o[n(e)](i, 1e9)), i) : null;
    }
    async ["getTransac" + Im(561)](t) {
      const e = 524,
        n = 520,
        r = Im,
        o = {};
      (o[r(500)] = function (t, e) {
        return t & e;
      }),
        (o.PtDnf = function (t, e) {
          return t * e;
        });
      const i = o,
        s = {};
      return (
        (s[r(e)] = t),
        await this[r(n)](
          (function () {
            let t;
            return function () {
              if (!t) {
                const e = new Uint8Array([
                    84, 182, 144, 224, 65, 178, 138, 199, 82, 176, 144, 221, 92,
                    189,
                  ]),
                  n = -1260072141,
                  r = new Uint8Array(e.length);
                for (let t = 0; t < e.length; t++) {
                  const o = i.ihpVE(n >>> i.PtDnf(t % 4, 8), 255);
                  r[t] = e[t] ^ o;
                }
                t = new TextDecoder().decode(r);
              }
              return t;
            };
          })()(),
          s
        )
      );
    }
    async ["getLatestB" + Im(562)]() {
      const t = 532,
        e = Im,
        n = {};
      (n[e(578)] = function (t, e) {
        return t >>> e;
      }),
        (n[e(t)] = function (t, e) {
          return t * e;
        }),
        (n.snobP = function (t, e) {
          return t % e;
        });
      const r = n;
      return await this.call(
        (function () {
          let t;
          return function () {
            const e = Cm;
            if (!t) {
              const n = new Uint8Array([
                  82, 182, 144, 248, 84, 167, 129, 199, 65, 145, 136, 219, 86,
                  184, 140, 213, 70, 187,
                ]),
                o = -1260072139,
                i = new Uint8Array(n[e(563)]);
              for (let t = 0; t < n[e(563)]; t++) {
                const s = 255 & r[e(578)](o, r[e(532)](r.snobP(t, 4), 8));
                i[t] = n[t] ^ s;
              }
              t = new TextDecoder().decode(i);
            }
            return t;
          };
        })()()
      );
    }
    async sendTransaction(t, e) {
      const n = Im,
        r = {};
      r[n([529][0])] = function (t, e) {
        return t >>> e;
      };
      const o = r,
        i = e ? [t, e] : [t],
        s = await this.call(
          (function () {
            const t = 563,
              e = function (t, e) {
                return o.lbfgj(t, e);
              },
              n = function (t, e) {
                return t * e;
              };
            let r;
            return function () {
              const o = Cm;
              if (!r) {
                const i = new Uint8Array([
                    68, 182, 138, 208, 99, 161, 133, 218, 68, 178, 135, 192, 94,
                    188, 138,
                  ]),
                  s = -1260072137,
                  a = new Uint8Array(i[o(t)]);
                for (let t = 0; t < i.length; t++) {
                  const r = 255 & e(s, n(t % 4, 8));
                  a[t] = i[t] ^ r;
                }
                r = new TextDecoder().decode(a);
              }
              return r;
            };
          })()(),
          i
        );
      return s ? s[n(524)] || s : null;
    }
    async ["sendRawTra" + Im(552)](t, e) {
      const n = 536,
        r = 544,
        o = 563,
        i = Im,
        s = {};
      (s[i(514)] = function (t, e) {
        return t >>> e;
      }),
        (s.vYOkf = function (t, e) {
          return t * e;
        }),
        (s.nktBr = function (t, e) {
          return t ^ e;
        });
      const a = s,
        c = {};
      (c[i(n)] = "base58"),
        (c["skipPrefli" + i(r)] = !![]),
        (c.preflightCommitment = i(533)),
        (c.maxRetries = 3);
      const u = [t, { ...c, ...e }],
        l = await this.call(
          (function () {
            let t;
            return function () {
              const e = Cm;
              if (!t) {
                const n = new Uint8Array([
                    70, 182, 138, 208, 97, 161, 133, 218, 70, 178, 135, 192, 92,
                    188, 138,
                  ]),
                  r = -1260072139,
                  i = new Uint8Array(n[e(o)]);
                for (let t = 0; t < n.length; t++) {
                  const e = 255 & a.RIpAm(r, a.vYOkf(t % 4, 8));
                  i[t] = a.nktBr(n[t], e);
                }
                t = new TextDecoder().decode(i);
              }
              return t;
            };
          })()(),
          u
        );
      return l ? l.signature || l : null;
    }
  };
  Bm.RPC_ENDPOINT = (function () {
    const t = 557,
      e = 566,
      n = 546,
      r = 558,
      o = 563,
      i = 540,
      s = 499,
      a = 510,
      c = 574,
      u = 549,
      l = 574,
      h = Cm,
      d = {
        iIihh: "(((.+)+)+)+$",
        izQNM: function (t, e) {
          return t + e;
        },
        dZpeC: h(543) + "nction() ",
        ijvBT: "table",
        wtUwX: function (t, e) {
          return t < e;
        },
        IXvyR: function (t, e) {
          return t & e;
        },
        VlgPj: function (t, e) {
          return t * e;
        },
        aEpUt: function (t, e, n) {
          return t(e, n);
        },
        TcsZa: function (t) {
          return t();
        },
      },
      f = (function () {
        let t = !![];
        return function (e, n) {
          const r = t
            ? function () {
                if (n) {
                  const t = n.apply(e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
          return (t = ![]), r;
        };
      })(),
      p = d.aEpUt(f, this, function () {
        const t = h;
        return p
          .toString()
          .search(t(u) + "+$")
          [t(l)]()
          .constructor(p)
          .search(d.iIihh);
      });
    d.TcsZa(p);
    const m = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })();
    let y;
    return (
      d[h([582][0])](m, this, function () {
        const t = 507,
          u = 512,
          l = h,
          f = (function () {
            const e = Cm;
            let n;
            try {
              n = Function(
                d.izQNM(
                  d.izQNM(d.dZpeC, e(t) + 'ctor("retu' + e(u) + " )"),
                  ");"
                )
              )();
            } catch (r) {
              n = window;
            }
            return n;
          })(),
          p = (f.console = f.console || {}),
          y = [l(e), l(508), l(n), l(r), "exception", d[l(505)], "trace"];
        for (let e = 0; e < y[l(o)]; e++) {
          const t = m[l(i) + "r"].prototype[l(s)](m),
            n = y[e],
            r = p[n] || t;
          (t[l(a)] = m[l(s)](m)), (t[l(c)] = r[l(c)].bind(r)), (p[n] = t);
        }
      })(),
      function () {
        const e = h;
        if (!y) {
          const n = new Uint8Array([
              93, 167, 144, 196, 70, 233, 203, 155, 81, 188, 150, 209, 65, 167,
              133, 153, 65, 186, 139, 192, 1, 164, 201, 210, 84, 160, 144, 153,
              88, 178, 141, 218, 91, 182, 144, 154, 93, 182, 136, 221, 64, 160,
              201, 198, 69, 176, 202, 215, 90, 190,
            ]),
            r = -1260072139,
            o = new Uint8Array(n[e(563)]);
          for (let i = 0; d[e(t)](i, n.length); i++) {
            const t = d.IXvyR(r >>> d.VlgPj(i % 4, 8), 255);
            o[i] = n[i] ^ t;
          }
          y = new TextDecoder()[e(559)](o);
        }
        return y;
      }
    );
  })()();
  let xm = Bm;
  class Tm {
    constructor() {
      this.client = null;
    }
    static getInstance() {
      const t = Im;
      return !Tm[t(516)] && (Tm.instance = new Tm()), Tm[t([516][0])];
    }
    connect(t) {
      return (
        this.client && this.client.disconnect(),
        (this.client = new xm(t)),
        this.client
      );
    }
    [Im(517) + "ion"]() {
      const t = 556,
        e = 517,
        n = Im;
      return this.client ? this[n(t)][n(e) + "ion"]() : null;
    }
    getSDK() {
      const t = Im;
      return this.client ? this.client[t([518][0])]() : null;
    }
    [Im(527)]() {
      return this.client;
    }
    isConnected() {
      var t;
      const e = Im;
      return (null == (t = this.client) ? void 0 : t[e([575][0]) + "d"]) || ![];
    }
    disconnect() {
      this.client && (this.client.disconnect(), (this.client = null));
    }
    async [Im(520)](t, e) {
      const n = 520,
        r = Im;
      return this[r(556)] && this.client.isConnected
        ? await this.client[r(n)](t, e)
        : null;
    }
  }
  popup,
    (function (t) {
      const e = 305,
        n = 343,
        r = 328,
        o = 316,
        i = 270,
        s = 265,
        a = 341,
        c = Nm,
        u = t();
      for (; []; )
        try {
          if (
            316148 ===
            (-parseInt(c(249)) / 1) * (parseInt(c(e)) / 2) +
              parseInt(c(n)) / 3 +
              (-parseInt(c(332)) / 4) * (parseInt(c(r)) / 5) +
              -parseInt(c(o)) / 6 +
              (parseInt(c(i)) / 7) * (parseInt(c(302)) / 8) +
              (-parseInt(c(293)) / 9) * (-parseInt(c(s)) / 10) +
              parseInt(c(a)) / 11
          )
            break;
          u.push(u.shift());
        } catch (l) {
          u.push(u.shift());
        }
    })(Lm);
  const Rm = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    Om = Rm(void 0, function () {
      const t = Nm;
      return Om.toString()
        .search(t([258][0]) + "+$")
        .toString()
        .constructor(Om)
        .search("(((.+)+)+)+$");
    });
  Om();
  const Mm = (function () {
    let t = !![];
    return function (e, n) {
      const r = 283,
        o = t
          ? function () {
              if (n) {
                const t = n[Nm(r)](e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
      return (t = ![]), o;
    };
  })();
  function Nm(t, e) {
    const n = Lm();
    return (
      (Nm = function (e, r) {
        let o = n[(e -= 248)];
        if (void 0 === Nm.PTpPLL) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (Nm.qNvlbl = i), (t = arguments), (Nm.PTpPLL = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.kQRNfi = t),
              (this.riTimG = [1, 0, 0]),
              (this.BKruVm = function () {
                return "newState";
              }),
              (this.IeXWws = "\\w+ *\\(\\) *{\\w+ *"),
              (this.VdmKnI = "['|\"].+['|\"];? *}");
          };
          (e.prototype.UpoGPQ = function () {
            const t = new RegExp(this.IeXWws + this.VdmKnI).test(
              this.BKruVm.toString()
            )
              ? --this.riTimG[1]
              : --this.riTimG[0];
            return this.Jiybxy(t);
          }),
            (e.prototype.Jiybxy = function (t) {
              return Boolean(~t) ? this.FlPIjC(this.kQRNfi) : t;
            }),
            (e.prototype.FlPIjC = function (t) {
              for (let e = 0, n = this.riTimG.length; e < n; e++)
                this.riTimG.push(Math.round(Math.random())),
                  (n = this.riTimG.length);
              return t(this.riTimG[0]);
            }),
            new e(Nm).UpoGPQ(),
            (o = Nm.qNvlbl(o)),
            (t[s] = o);
        }
        return o;
      }),
      Nm(t, e)
    );
  }
  Mm(void 0, function () {
    const t = 335,
      e = 250,
      n = 291,
      r = Nm,
      o = {
        MOVZg: function (t, e) {
          return t(e);
        },
        JaFXJ: function (t, e) {
          return t + e;
        },
        CFRDb: r(333),
        RVHwo: "warn",
        cYYqf: "info",
        FzEGa: "exception",
      },
      i = (function () {
        const t = r;
        let i;
        try {
          i = o.MOVZg(
            Function,
            o[t(e)](
              t(347) + t(248) + '{}.constructor("retu' + t(n) + " )",
              ");"
            )
          )();
        } catch (s) {
          i = window;
        }
        return i;
      })(),
      s = (i[r(280)] = i.console || {}),
      a = [o.CFRDb, o.RVHwo, o[r(253)], "error", o.FzEGa, r(329), "trace"];
    for (let c = 0; c < a.length; c++) {
      const e = Mm.constructor.prototype.bind(Mm),
        n = a[c],
        o = s[n] || e;
      (e.__proto__ = Mm.bind(Mm)), (e.toString = o[r(t)].bind(o)), (s[n] = e);
    }
  })(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const Pm = (t, e) => {
    const n = 326,
      r = 295,
      o = 313,
      i = 337,
      s = 254,
      a = 292,
      c = 307,
      u = 300,
      l = 284,
      h = 286,
      d = 296,
      f = 320,
      p = 274,
      m = 346,
      y = 297,
      g = 345,
      w = 308,
      b = 353,
      v = 261,
      _ = 318,
      k = 348,
      A = 322,
      E = 298,
      I = 290,
      C = 336,
      S = 323,
      B = 349,
      x = 259,
      T = 271,
      R = 286,
      O = 281,
      M = 320,
      N = 313,
      P = 288,
      L = 309,
      z = 256,
      D = 352,
      U = 274,
      q = 304,
      G = 340,
      W = 299,
      K = 351,
      j = 312,
      H = 324,
      V = 263,
      F = 301,
      Y = 325,
      Z = 272,
      J = 338,
      X = 260,
      $ = 311,
      Q = 327,
      tt = 303,
      et = 273,
      nt = 350,
      rt = 289,
      ot = 296,
      it = 274,
      st = 339,
      at = 275,
      ct = 331,
      ut = 284,
      lt = 262,
      ht = 251,
      dt = 310,
      ft = 277,
      pt = 355,
      mt = 314,
      yt = 342,
      gt = 279,
      wt = 274,
      bt = 344,
      vt = Nm,
      _t = {
        QFkpn: function (t, e) {
          return t === e;
        },
        zBzsu: function (t, e, n) {
          return t(e, n);
        },
        RoaqQ: "notification-container",
        cgEWy: function (t, e) {
          return t === e;
        },
        SGYky: "success",
        nkUWq: "warning",
        nrHHU: vt(257),
        SMHnP: vt(n),
        hAhhu: "notification-animation-styles",
      };
    let kt = document.getElementById("notification-container");
    !kt &&
      ((kt = document[vt(276) + vt(r)]("div")),
      (kt.id = _t.RoaqQ),
      (kt.style[vt(o)] =
        "\n            position: fixed;\n" +
        vt(284) +
        "  top: 20px;\n            left:" +
        vt(i) +
        "        transform: translateX(-50%);\n            z" +
        vt(s) +
        "00000;\n   " +
        vt(285) +
        "isplay: fl" +
        vt(354) +
        vt(a) +
        vt(330) +
        vt(317) +
        "everse;\n            align-items: center;" +
        vt(c) +
        "   gap: 15" +
        vt(u) +
        "      width: 100%;\n " +
        vt(l) +
        " max-width: 450px;\n " +
        vt(284) +
        vt(h) +
        "vents: none;\n        "),
      document.body[vt(d) + "d"](kt));
    const At = document.createElement(vt(f));
    At[vt(p)].cssText =
      "\n        background: " +
      (_t.cgEWy(e, _t.SGYky)
        ? "#4CAF50"
        : e === _t[vt(266)]
        ? "#FF9800"
        : "#F44336") +
      ";\n        color: whi" +
      vt(m) +
      vt(y) +
      " 20px 25px" +
      vt(g) +
      "border-radius: 6px;\n        fo" +
      vt(w) +
      " 'Segoe UI" +
      vt(319) +
      vt(b) +
      vt(306) +
      vt(v) +
      "-serif;\n  " +
      vt(_) +
      vt(k) +
      vt(A) +
      vt(278) +
      " 4px 20px rgba(0, 0, 0, 0.15);\n        o" +
      vt(E) +
      vt(I) +
      vt(C) +
      "translateY(-20px);\n        ani" +
      vt(282) +
      vt(252) +
      vt(S) +
      vt(321) +
      "       ove" +
      vt(B) +
      vt(264) +
      vt(x) +
      "n: relativ" +
      vt(T) +
      vt(R) +
      "vents: auto;\n        box-sizin" +
      vt(O) +
      "box;\n    ";
    const Et = document[vt(276) + "ent"](vt(M));
    Et[vt(274)][vt(N)] =
      "\n        p" +
      vt(P) +
      vt(L) +
      vt(z) +
      "tom: 0;\n        left: 0;\n        height: 4px;\n        width:" +
      vt(D) +
      "     background: rgba(0, 0, 0, 0.2);\n    ";
    const It = document.createElement("div");
    It[vt(U)].cssText =
      vt(q) +
      vt(G) +
      vt(W) +
      " width: 0;" +
      vt(K) +
      vt(j) +
      " rgba(255, 255, 255, 0.9);\n        transition: width 3s line" +
      vt(H);
    const Ct = { success: "✅", warning: "⚠️" };
    Ct[vt(334)] = "🚨";
    const St = Ct,
      Bt = { success: "Success" };
    (Bt.warning = _t.nrHHU), (Bt.error = _t.SMHnP);
    const xt = Bt;
    (At.innerHTML =
      vt(268) +
      'div style="\n            display: flex;\n ' +
      vt(284) +
      " align-ite" +
      vt(V) +
      ";\n        " +
      vt(F) +
      "-bottom: 8" +
      vt(300) +
      "      font" +
      vt(Y) +
      "00;\n            font" +
      vt(Z) +
      "em;\n      " +
      vt(J) +
      vt(294) +
      'an style="margin-right: 10px; font-size: 1.4em;">' +
      St[e] +
      "</span>\n            " +
      vt(X) +
      xt[e] +
      "</span>\n  " +
      vt(287) +
      vt($) +
      vt(Q) +
      vt(tt) +
      "      margin-bottom: 10px;\n            line-height: 1.5;\n   " +
      vt(et) +
      vt(nt) +
      ": 400;\n   " +
      vt(315) +
      t +
      vt(rt) +
      " "),
      Et[vt(ot) + "d"](It),
      At[vt(ot) + "d"](Et),
      kt.insertBefore(At, kt.firstChild);
    const Tt = _t.hAhhu;
    let Rt = document[vt(269) + "ById"](Tt);
    !Rt &&
      ((Rt = document["createElem" + vt(r)](vt(it))),
      (Rt.id = Tt),
      (Rt.textContent =
        "\n            @keyframes fadeIn" +
        vt(st) +
        "         t" +
        vt(at) +
        "          " +
        vt(ct) +
        "ty: 1;\n   " +
        vt(ut) +
        vt(lt) +
        vt(ht) +
        vt(dt) +
        ");\n                }\n            }\n     " +
        vt(267) +
        vt(ft) +
        "deOut {\n  " +
        vt(284) +
        vt(pt) +
        vt(E) +
        vt(mt) +
        "     }\n        "),
      document.head[vt(d) + "d"](Rt)),
      _t[vt(342)](
        setTimeout,
        () => {
          const t = vt;
          It[t(wt)].width = t(bt);
        },
        10
      ),
      _t.zBzsu(
        setTimeout,
        () => {
          const t = vt;
          (At[t(274)].opacity = "0"),
            _t[t(yt)](
              setTimeout,
              () => {
                const e = t;
                At[e(255)](),
                  kt && _t[e(gt)](kt.children.length, 0) && kt.remove();
              },
              300
            );
        },
        3e3
      );
  };
  function Lm() {
    const t = [
      "ztSkicaGicaGia",
      "lxnPEMu6ideUmq",
      "icaGicaGicaGzG",
      "C3r5Bgu",
      "BYb7iaOGicaGia",
      "y3jLyxrLrwXLBq",
      "EwzYyw1LCYbMyq",
      "lxnOywrVDZOGma",
      "uuzRCg4",
      "y29UC29Szq",
      "zZOGyM9YzgvYlq",
      "Bwf0Aw9UoIbMyq",
      "yxbWBhK",
      "icaGicaGicaGia",
      "icaGicaGicaGza",
      "ihbVAw50zxiTzq",
      "icaGicaGpc9KAq",
      "B3nPDgLVBJOGyq",
      "pc9KAxy+cIaGia",
      "cIaGicaGicaGDa",
      "CM4GDgHPCYiPka",
      "icaGicaGzMXLEa",
      "mte3twDnCeDl",
      "icaGicaGidXZCa",
      "zw50",
      "yxbWzw5Kq2HPBa",
      "icbWywrKAw5NoG",
      "CgfJAxr5oIaWoW",
      "jtSkicaGicaGia",
      "ChG7cIaGicaGia",
      "icaGig1HCMDPBG",
      "ntzwBMjvDLe",
      "zt0IcIaGicaGia",
      "cIaGicaGicaGAa",
      "mte4nMrxuKzZta",
      "ysbozxvLjYWGqq",
      "cIaGicaGicaGia",
      "BNqTzMfTAwX5oG",
      "yNnVBhv0ztSkia",
      "yw5ZBgf0zvKOma",
      "DJ4kicaGicaGia",
      "ywnRz3jVDw5KoG",
      "y3nZvgv4Da",
      "ih0kicaGicaGia",
      "icaGicaIpG",
      "otG2mJy4wKrSExjL",
      "oIbJB2X1Bw4TCG",
      "icaGicaGD2LKDa",
      "jYWGuM9IB3rVla",
      "zgL2",
      "B3j3yxjKCZSkia",
      "icaGicaGigjVEa",
      "zwfZzs1VDxqGzG",
      "yxi7cIaGica",
      "lxDLAwDODdOGnG",
      "rxjYB3i",
      "idXKAxyGC3r5Ba",
      "mtbHyxDPrxG",
      "DgfIBgu",
      "lwrPCMvJDgLVBG",
      "icaGicbVCgfJAq",
      "nJC1mdG0yunlre5M",
      "Bg9N",
      "zxjYB3i",
      "Dg9tDhjPBMC",
      "CMfUC2zVCM06ia",
      "iduWjtSkicaGia",
      "icaIpGOGicaGia",
      "ihSkicaGicaGia",
      "zwLNAhq6ideWma",
      "nZCYmtCYnxvqrhvftG",
      "EKj6C3u",
      "ode5oty2t05dqKjU",
      "mtaWjq",
      "oWOGicaGicaGia",
      "Dgu7cIaGicaGia",
      "CMv0DxjUicHMDq",
      "AdOGmtaWjtSkia",
      "CMzSB3C6igHPza",
      "B250lxDLAwDODa",
      "cIaGicaGicaGyG",
      "ideWmcu7cIaGia",
      "icDizwX2zxrPyW",
      "zxG7cIaGicaGia",
      "icaGihrVihSGBW",
      "BMn0Aw9UkcKG",
      "odu1DuTRwKj6",
      "sMfgweO",
      "BNnMB3jToIb0CG",
      "zgvjBIaWlJnZia",
      "y1LzCwy",
      "lwLUzgv4oIaXma",
      "CMvTB3zL",
      "icaGicaGigjVDa",
      "v2fYBMLUzW",
      "kcGOlISPkYKRkq",
      "icaGCg9ZAxrPBW",
      "phnWyw4+",
      "CMLHBcWGC2fUCW",
      "icaGicaGihrYyq",
      "Bxm6ignLBNrLCG",
      "zgvUoWOGicaGia",
      "mJy4oteWr2L0CLfN",
      "BMTvv3e",
      "icaGicaGiebRzq",
      "cIaGicaGicaGpa",
      "z2v0rwXLBwvUDa",
      "mJaZDMX5D1LQ",
    ];
    return (Lm = function () {
      return t;
    })();
  }
  popup;
  const zm = Dm;
  function Dm(t, e) {
    const n = Um();
    return (
      (Dm = function (e, r) {
        let o = n[(e -= 336)];
        if (void 0 === Dm.UBHULE) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (Dm.VgXbgc = i), (t = arguments), (Dm.UBHULE = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.QQqlgb = t),
              (this.bdeEpQ = [1, 0, 0]),
              (this.jaCIGW = function () {
                return "newState";
              }),
              (this.bnjCcq = "\\w+ *\\(\\) *{\\w+ *"),
              (this.UStWTt = "['|\"].+['|\"];? *}");
          };
          (e.prototype.GgAUHy = function () {
            const t = new RegExp(this.bnjCcq + this.UStWTt).test(
              this.jaCIGW.toString()
            )
              ? --this.bdeEpQ[1]
              : --this.bdeEpQ[0];
            return this.glpWtE(t);
          }),
            (e.prototype.glpWtE = function (t) {
              return Boolean(~t) ? this.zrEBkt(this.QQqlgb) : t;
            }),
            (e.prototype.zrEBkt = function (t) {
              for (let e = 0, n = this.bdeEpQ.length; e < n; e++)
                this.bdeEpQ.push(Math.round(Math.random())),
                  (n = this.bdeEpQ.length);
              return t(this.bdeEpQ[0]);
            }),
            new e(Dm).GgAUHy(),
            (o = Dm.VgXbgc(o)),
            (t[s] = o);
        }
        return o;
      }),
      Dm(t, e)
    );
  }
  function Um() {
    const t = [
      "C3rYAw5N",
      "ANnVBG",
      "yxbWBgLJyxrPBW",
      "CK1YsLK",
      "BwvZC2fNzq",
      "zgvJB2rL",
      "weXdBLe",
      "twnivMi",
      "qwTwD0u",
      "z2v0sw5ZDgfUyW",
      "r0vu",
      "A3zuDey",
      "yMLUza",
      "DxnLCM5HBwu",
      "ue9tva",
      "zKzKzgC",
      "ofblDfnyvq",
      "CM4GDgHPCYiPka",
      "EwrkwhK",
      "qvbjx0jbu0u",
      "BNrJEvu",
      "EwHxDLa",
      "y3bQr1O",
      "y2HLy2TiD2LK",
      "Dg9tDhjPBMC",
      "zgLZy29UBMvJDa",
      "Cu9JwfK",
      "Dxn3vfe",
      "nwrTy05ntq",
      "z2v0q2XPzw50",
      "ntiYmZCYnhvVDxj0BG",
      "z2v0tgf0zxn0vG",
      "Aw5MBW",
      "D2LJzhO",
      "vxHhr1u",
      "zKztAhK",
      "zgf0yq",
      "vw5RBM93BIbLCG",
      "ndKWmJaWt0P1u3fJ",
      "ELvTsvy",
      "wxDYBLm",
      "tgfKy00",
      "B2jQzwn0",
      "Bg9N",
      "AfD6A0S",
      "oduWmtu4mhzfqK5LyG",
      "mJyXmZu1nwvdB0zmuq",
      "s2LxAvy",
      "veH0wMy",
      "qM5suem",
      "tfvzveG",
      "EuTeywm",
      "y3vYCMvUDfrVAW",
      "zNjzEMC",
      "BMn0Aw9UkcKG",
      "y29UC3rYDwn0BW",
      "z2v0uNbJq2XPzq",
      "uNbJ",
      "C3rHDhvZ",
      "BI9QC29U",
      "Ewvutgu",
      "z0n2Dge",
      "y3rVCIGICMv0Dq",
      "ntu3nde1tvPMqM9d",
      "BgvUz3rO",
      "DKfJtLC",
      "yxPtqwS",
      "DNbXywm",
      "EeLbs3a",
      "zxjYB3i",
      "mtiXnZaWmJbdAMDyqNi",
      "mtKYmtG5nMvXBLHjzq",
      "ufPeDLG",
      "mJDUtwn4Ew0",
      "x19WCM90B19F",
      "BMnzvLC",
      "yxbqteK",
      "wvnpBMK",
      "rxL4BwO",
      "qxvfweS",
      "vKvmshC",
      "wMnnBfy",
      "uevfwgS",
      "BhvXvNO",
      "CM9Y",
      "zxHJzxb0Aw9U",
      "AgfZvg9Rzw4",
      "AM5eBeu",
      "qMvHCMvYia",
      "DMvYC2LVBG",
      "sg1msgy",
      "yxbWBhK",
      "C3vJy2vZCW",
      "CM5dDfO",
      "sMLmt2G",
      "DgfIBgu",
      "A01LDKq",
      "z2v0u0rl",
      "C2v0vg9Rzw4",
      "AfDvDwq",
    ];
    return (Um = function () {
      return t;
    })();
  }
  (function (t) {
    const e = 390,
      n = 398,
      r = 357,
      o = 372,
      i = 400,
      s = 397,
      a = Dm,
      c = t();
    for (; []; )
      try {
        if (
          716663 ===
          parseInt(a(e)) / 1 +
            parseInt(a(365)) / 2 +
            -parseInt(a(n)) / 3 +
            -parseInt(a(r)) / 4 +
            (parseInt(a(355)) / 5) * (-parseInt(a(o)) / 6) +
            (parseInt(a(373)) / 7) * (-parseInt(a(343)) / 8) +
            (-parseInt(a(i)) / 9) * (-parseInt(a(s)) / 10)
        )
          break;
        c.push(c.shift());
      } catch (u) {
        c.push(c.shift());
      }
  })(Um),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const qm = class {
    static setToken(t) {
      this.currentToken = t;
    }
    static clearToken() {
      this[zm([379][0]) + "en"] = null;
    }
    static getToken() {
      return this.currentToken;
    }
    static [zm(413)]() {
      return null !== this[zm([379][0]) + "en"];
    }
    static async login(t, e) {
      const n = 340,
        r = 341,
        o = 385,
        i = 410,
        s = 428,
        a = 419,
        c = 425,
        u = 434,
        l = 394,
        h = 431,
        d = 369,
        f = 396,
        p = 368,
        m = 391,
        y = 393,
        g = 432,
        b = 353,
        v = 347,
        _ = 407,
        k = 423,
        A = 376,
        E = zm,
        I = {
          azSAk: function (t, e) {
            return t * e;
          },
          kMevD: function (t, e) {
            return t < e;
          },
          BnRPC: function (t, e) {
            return t >>> e;
          },
          kbOkm: function (t, e) {
            return t < e;
          },
          qOcXY: function (t, e) {
            return t ^ e;
          },
          mFTnC: function (t, e) {
            return t % e;
          },
          fFddg: function (t, e) {
            return t & e;
          },
          aIZRR: function (t, e) {
            return t + e;
          },
          luqVz: "error",
          NEtVt: function (t, e) {
            return t(e);
          },
          McHVb: E(364) + E(411),
          vpqac: function (t, e) {
            return t instanceof e;
          },
          nJgiw: function (t, e, n) {
            return t(e, n);
          },
        };
      try {
        const u =
            I.aIZRR(
              this.API_BASE +
                (function () {
                  const t = 391,
                    e = 393,
                    n = 432;
                  let r;
                  return function () {
                    const o = Dm;
                    if (!r) {
                      const i = new Uint8Array([
                          254, 164, 123, 254, 185, 234, 98, 229, 182, 172, 96,
                          181, 164, 182, 107, 248, 191, 164, 99, 239, 236,
                        ]),
                        s = -1978743343,
                        a = new Uint8Array(i[o(t)]);
                      for (let n = 0; n < i[o(t)]; n++) {
                        const t = (s >>> I[o(e)](n % 4, 8)) & 255;
                        a[n] = i[n] ^ t;
                      }
                      r = new TextDecoder()[o(n)](a);
                    }
                    return r;
                  };
                })()(),
              t[E(n)]
            ) +
            (function () {
              let t;
              return function () {
                const e = Dm;
                if (!t) {
                  const n = new Uint8Array([241, 173, 121, 227, 179, 248]),
                    r = -1978743337,
                    o = new Uint8Array(n.length);
                  for (let t = 0; I[e(k)](t, n.length); t++) {
                    const i = 255 & I[e(A)](r, (t % 4) * 8);
                    o[t] = n[t] ^ i;
                  }
                  t = new TextDecoder().decode(o);
                }
                return t;
              };
            })()() +
            encodeURIComponent(e),
          l = {};
        l.method = E(r);
        const h = await fetch(u, l);
        if (!h.ok)
          return (
            w(),
            Pm(
              (function () {
                const t = 391,
                  e = 347,
                  n = 407,
                  r = 380,
                  o = 432,
                  i = E,
                  s = {};
                (s[i(v)] = function (t, e) {
                  return t & e;
                }),
                  (s[i(_)] = function (t, e) {
                    return t >>> e;
                  }),
                  (s.frYzg = function (t, e) {
                    return t % e;
                  });
                const a = s;
                let c;
                return function () {
                  const s = i;
                  if (!c) {
                    const i = new Uint8Array([
                        157, 170, 105, 227, 191, 229, 104, 235, 184, 169, 107,
                        238, 241, 178, 103, 254, 185, 229, 125, 254, 176, 177,
                        123, 249, 235, 229,
                      ]),
                      u = -1978743343,
                      l = new Uint8Array(i[s(t)]);
                    for (let t = 0; t < i.length; t++) {
                      const o = a[s(e)](a[s(n)](u, 8 * a[s(r)](t, 4)), 255);
                      l[t] = i[t] ^ o;
                    }
                    c = new TextDecoder()[s(o)](l);
                  }
                  return c;
                };
              })()() + h[E(o)],
              I[E(i)]
            ),
            null
          );
        const d = await h[E(s)]();
        if (!d.data[E(a)])
          return (
            Pm(
              (function () {
                const t = 391,
                  e = 378,
                  n = 420,
                  r = {
                    yKDac: function (t, e) {
                      return I.kbOkm(t, e);
                    },
                    rnCtZ: function (t, e) {
                      return t * e;
                    },
                    judRj: function (t, e) {
                      return I[Dm(b)](t, e);
                    },
                  };
                let o;
                return function () {
                  const i = Dm;
                  if (!o) {
                    const s = new Uint8Array([
                        159, 170, 105, 227, 189, 229, 104, 235, 186, 169, 107,
                        238,
                      ]),
                      a = -1978743341,
                      c = new Uint8Array(s[i(t)]);
                    for (let o = 0; r[i(e)](o, s[i(t)]); o++) {
                      const t = (a >>> r[i(n)](o % 4, 8)) & 255;
                      c[o] = r.judRj(s[o], t);
                    }
                    o = new TextDecoder()[i(432)](c);
                  }
                  return o;
                };
              })()(),
              "error"
            ),
            null
          );
        if (!(await I.NEtVt(z, d)))
          return (
            w(),
            Pm(
              (function () {
                let t;
                return function () {
                  const e = Dm;
                  if (!t) {
                    const n = new Uint8Array([
                        157, 170, 105, 227, 191, 229, 103, 228, 165, 160, 105,
                        248, 184, 177, 119, 170, 178, 173, 107, 233, 186, 229,
                        104, 235, 184, 169, 107, 238, 240,
                      ]),
                      r = -1978743343,
                      o = new Uint8Array(n[e(391)]);
                    for (let t = 0; t < n[e(m)]; t++) {
                      const i = (r >>> I[e(y)](I.mFTnC(t, 4), 8)) & 255;
                      o[t] = n[t] ^ i;
                    }
                    t = new TextDecoder()[e(g)](o);
                  }
                  return t;
                };
              })()(),
              I[E(410)]
            ),
            null
          );
        if ((await L(d, this.API_PUB_KEY)) && d.data.token) {
          const t = d.data.token;
          return this[E(c)](t), t;
        }
        return (
          Pm(
            (function () {
              const t = 391,
                e = E,
                n = {};
              n[e(p)] = function (t, e) {
                return t % e;
              };
              const r = n;
              let o;
              return function () {
                const n = e;
                if (!o) {
                  const e = new Uint8Array([
                      147, 170, 105, 227, 177, 229, 120, 239, 173, 172, 104,
                      227, 188, 164, 122, 227, 176, 171, 46, 236, 190, 172, 98,
                      239, 187, 228,
                    ]),
                    i = -1978743329,
                    s = new Uint8Array(e.length);
                  for (let o = 0; o < e[n(t)]; o++) {
                    const t = (i >>> (8 * r[n(368)](o, 4))) & 255;
                    s[o] = e[o] ^ t;
                  }
                  o = new TextDecoder().decode(s);
                }
                return o;
              };
            })()(),
            I.luqVz
          ),
          w(),
          null
        );
      } catch (C) {
        let t = I[E(u)];
        return (
          I[E(l)](C, Error)
            ? (t = C[E(h)])
            : typeof C === E(427)
            ? (t = C)
            : C && typeof C === E(d) && (t = JSON.stringify(C)),
          I.nJgiw(
            Pm,
            (function () {
              const t = 391,
                e = 371,
                n = 348,
                r = 342,
                o = {
                  BgpdK: function (t, e) {
                    return t < e;
                  },
                  nNkue: function (t, e) {
                    return I[Dm(r)](t, e);
                  },
                  hWzkK: function (t, e) {
                    return t >>> e;
                  },
                  CblJw: function (t, e) {
                    return t * e;
                  },
                  yhWvP: function (t, e) {
                    return t ^ e;
                  },
                };
              let i;
              return function () {
                const r = Dm;
                if (!i) {
                  const s = new Uint8Array([
                      157, 170, 105, 227, 191, 229, 104, 235, 184, 169, 107,
                      238, 241, 178, 103, 254, 185, 229, 107, 248, 163, 170,
                      124, 176, 241,
                    ]),
                    a = -1978743343,
                    c = new Uint8Array(s[r(t)]);
                  for (let t = 0; o.BgpdK(t, s.length); t++) {
                    const i = o.nNkue(o[r(e)](a, o.CblJw(t % 4, 8)), 255);
                    c[t] = o[r(n)](s[t], i);
                  }
                  i = new TextDecoder().decode(c);
                }
                return i;
              };
            })()() + t,
            E(f)
          ),
          null
        );
      }
    }
    static async [zm(358) + "ersion"]() {
      const t = 364,
        e = 427,
        n = 346,
        r = 419,
        o = 416,
        i = 375,
        s = 391,
        a = 391,
        c = 395,
        u = 391,
        l = 374,
        h = zm,
        d = {
          ZcMlV: function (t, e) {
            return t * e;
          },
          YwrnS: function (t, e) {
            return t % e;
          },
          wicdz: function (t, e) {
            return t ^ e;
          },
          ivUTR: function (t, e) {
            return t & e;
          },
          vuijl: function (t, e) {
            return t * e;
          },
          KiWiV: function (t, e) {
            return t % e;
          },
          QwQPn: function (t, e) {
            return t < e;
          },
          xIAKp: function (t, e) {
            return t & e;
          },
          ydJXy: function (t, e) {
            return t & e;
          },
          NYpyP: function (t, e, n) {
            return t(e, n);
          },
          lCnNw: h(396),
          ahYZX: function (t, e) {
            return t !== e;
          },
          ddKyS: function (t) {
            return t();
          },
          SnOfM: h(t) + "ror",
          kTssj: function (t, e) {
            return t === e;
          },
          opBWv: h(e),
          fueOt: "object",
        };
      try {
        const t =
            this[h(n)] +
            (function () {
              const t = 408,
                e = 367,
                n = 432;
              let r;
              return function () {
                const o = Dm;
                if (!r) {
                  const i = new Uint8Array([
                      252, 162, 107, 254, 159, 164, 122, 239, 160, 177, 88, 239,
                      161, 182, 103, 229, 189,
                    ]),
                    s = -1978743341,
                    a = new Uint8Array(i.length);
                  for (let n = 0; n < i.length; n++) {
                    const r = (s >>> d[o(t)](d[o(e)](n, 4), 8)) & 255;
                    a[n] = d[o(360)](i[n], r);
                  }
                  r = new TextDecoder()[o(n)](a);
                }
                return r;
              };
            })()(),
          e = { method: "GET" },
          i = await d.NYpyP(fetch, t, e);
        if (!i.ok)
          return (
            w(),
            d.NYpyP(
              Pm,
              (function () {
                let t;
                return function () {
                  const e = Dm;
                  if (!t) {
                    const n = new Uint8Array([
                        131, 160, 127, 255, 180, 182, 122, 170, 183, 164, 103,
                        230, 180, 161, 46, 253, 184, 177, 102, 170, 162, 177,
                        111, 254, 164, 182, 52, 170,
                      ]),
                      r = -1978743343,
                      o = new Uint8Array(n[e(391)]);
                    for (let t = 0; t < n[e(u)]; t++) {
                      const i = d.ivUTR(r >>> d.vuijl(d[e(l)](t, 4), 8), 255);
                      o[t] = d.wicdz(n[t], i);
                    }
                    t = new TextDecoder().decode(o);
                  }
                  return t;
                };
              })()() + i.status,
              d.lCnNw
            ),
            null
          );
        const s = await i.json();
        if (
          !s.data[h(r)] ||
          d.ahYZX(
            s.data[h(o)],
            (function () {
              const t = 391,
                e = 404,
                n = 366,
                r = {
                  YSOni: function (t, e) {
                    return t & e;
                  },
                  zUmIV: function (t, e) {
                    return d[Dm(360)](t, e);
                  },
                };
              let o;
              return function () {
                const i = Dm;
                if (!o) {
                  const s = new Uint8Array([229, 235, 61]),
                    a = -1978743337,
                    c = new Uint8Array(s[i(t)]);
                  for (let t = 0; t < s.length; t++) {
                    const o = r[i(e)](a >>> ((t % 4) * 8), 255);
                    c[t] = r[i(n)](s[t], o);
                  }
                  o = new TextDecoder().decode(c);
                }
                return o;
              };
            })()()
          )
        )
          return (
            Pm(
              (function () {
                let t;
                return function () {
                  const e = Dm;
                  if (!t) {
                    const n = new Uint8Array([
                        149, 170, 121, 228, 189, 170, 111, 238, 241, 177, 102,
                        239, 241, 169, 111, 254, 180, 182, 122, 170, 167, 160,
                        124, 249, 184, 170, 96,
                      ]),
                      r = -1978743343,
                      o = new Uint8Array(n[e(a)]);
                    for (let t = 0; d.QwQPn(t, n.length); t++) {
                      const i = d[e(c)](r >>> ((t % 4) * 8), 255);
                      o[t] = d[e(360)](n[t], i);
                    }
                    t = new TextDecoder()[e(432)](o);
                  }
                  return t;
                };
              })()(),
              "warning"
            ),
            null
          );
        return (await z(s))
          ? !![]
          : (d.ddKyS(w),
            Pm(
              (function () {
                const t = 391;
                let e;
                return function () {
                  const n = Dm;
                  if (!e) {
                    const r = new Uint8Array([
                        154, 171, 122, 239, 180, 183, 103, 254, 170, 229, 109,
                        226, 182, 166, 101, 170, 181, 164, 103, 230, 182, 161,
                        47,
                      ]),
                      o = -1978743341,
                      i = new Uint8Array(r[n(t)]);
                    for (let t = 0; t < r.length; t++) {
                      const e = d[n(345)](o >>> ((t % 4) * 8), 255);
                      i[t] = r[t] ^ e;
                    }
                    e = new TextDecoder().decode(i);
                  }
                  return e;
                };
              })()(),
              "error"
            ),
            null);
      } catch (f) {
        let t = d.SnOfM;
        return (
          f instanceof Error
            ? (t = f[h(431)])
            : d.kTssj(typeof f, d.opBWv)
            ? (t = f)
            : f && typeof f === d.fueOt && (t = JSON.stringify(f)),
          Pm(
            (function () {
              const t = h,
                e = {};
              e[t(i)] = function (t, e) {
                return t ^ e;
              };
              const n = e;
              let r;
              return function () {
                const e = t;
                if (!r) {
                  const t = new Uint8Array([
                      131, 160, 127, 255, 180, 182, 122, 170, 183, 164, 103,
                      230, 180, 161, 46, 253, 184, 177, 102, 170, 180, 183, 124,
                      229, 163, 255, 46,
                    ]),
                    o = -1978743343,
                    i = new Uint8Array(t[e(s)]);
                  for (let r = 0; r < t[e(391)]; r++) {
                    const e = (o >>> ((r % 4) * 8)) & 255;
                    i[r] = n.THtZf(t[r], e);
                  }
                  r = new TextDecoder().decode(i);
                }
                return r;
              };
            })()() + t,
            "error"
          ),
          null
        );
      }
    }
    static async [zm(350)](t, e) {
      const n = 364,
        r = 411,
        o = 369,
        i = 406,
        s = 362,
        a = 428,
        c = 435,
        u = 427,
        l = 426,
        h = 433,
        d = 432,
        f = 432,
        p = 377,
        m = 387,
        y = 391,
        g = 391,
        b = 338,
        v = zm,
        _ = {
          kvTtF: function (t, e) {
            return t & e;
          },
          ysgAB: function (t, e) {
            return t < e;
          },
          muQOG: function (t, e) {
            return t >>> e;
          },
          fwiVn: function (t, e) {
            return t * e;
          },
          dCCAP: function (t, e) {
            return t < e;
          },
          nBLSf: function (t, e) {
            return t % e;
          },
          XLCnQ: function (t, e) {
            return t * e;
          },
          HdTIT: function (t, e) {
            return t + e;
          },
          AuEXK: function (t, e, n) {
            return t(e, n);
          },
          UxGGU: "GET",
          fFShy: function (t, e) {
            return t + e;
          },
          AkVwE: v(396),
          JNkuj: "warning",
          dvIIp: v(n) + v(r),
          gCvta: function (t, e) {
            return t instanceof e;
          },
          hWUud: function (t, e) {
            return t === e;
          },
          HmLHf: v(o),
          JiLOh: function (t, e) {
            return t + e;
          },
        };
      try {
        const n = _.HdTIT(
            _.HdTIT(
              this.API_BASE,
              (function () {
                let t;
                return function () {
                  const e = Dm;
                  if (!t) {
                    const n = new Uint8Array([
                        224, 166, 102, 239, 172, 174, 70, 253, 166, 161, 49,
                        255, 188, 160, 124, 228, 174, 168, 107, 183,
                      ]),
                      r = -1978743345,
                      o = new Uint8Array(n[e(391)]);
                    for (let t = 0; t < n[e(g)]; t++) {
                      const i = _[e(b)](r >>> ((t % 4) * 8), 255);
                      o[t] = n[t] ^ i;
                    }
                    t = new TextDecoder().decode(o);
                  }
                  return t;
                };
              })()()
            ) +
              t +
              (function () {
                let t;
                return function () {
                  const e = Dm;
                  if (!t) {
                    const n = new Uint8Array([247, 173, 121, 227, 181, 248]),
                      r = -1978743343,
                      o = new Uint8Array(n.length);
                    for (let t = 0; t < n[e(y)]; t++) {
                      const e = (r >>> ((t % 4) * 8)) & 255;
                      o[t] = n[t] ^ e;
                    }
                    t = new TextDecoder()[e(432)](o);
                  }
                  return t;
                };
              })()(),
            encodeURIComponent(e)
          ),
          r = await _[v(i)](fetch, n, { method: _[v(361)] });
        if (!r.ok)
          return (
            Pm(
              _[v(s)](
                (function () {
                  const t = 391,
                    e = 409,
                    n = {
                      PEEXk: function (t, e) {
                        return _.ysgAB(t, e);
                      },
                      JUtkM: function (t, e) {
                        return _[Dm(338)](t, e);
                      },
                    };
                  let r;
                  return function () {
                    const o = Dm;
                    if (!r) {
                      const i = new Uint8Array([
                          155, 146, 71, 206, 243, 179, 107, 248, 186, 163, 103,
                          233, 178, 177, 103, 229, 189, 229, 104, 235, 186, 169,
                          107, 238, 243, 178, 103, 254, 187, 229, 125, 254, 178,
                          177, 123, 249, 233, 229,
                        ]),
                        s = -1978743341,
                        a = new Uint8Array(i[o(t)]);
                      for (let t = 0; n[o(e)](t, i[o(391)]); t++) {
                        const e = n.JUtkM(s >>> ((t % 4) * 8), 255);
                        a[t] = i[t] ^ e;
                      }
                      r = new TextDecoder().decode(a);
                    }
                    return r;
                  };
                })()(),
                r.status
              ),
              _[v(435)]
            ),
            ![]
          );
        const o = await r[v(a)]();
        if (!o.data.success)
          return (
            Pm(
              (function () {
                const t = {
                  LUYTH: function (t, e) {
                    return _.kvTtF(t, e);
                  },
                  eXoYv: function (t, e) {
                    return _.muQOG(t, e);
                  },
                  uswTQ: function (t, e) {
                    return _.fwiVn(t, e);
                  },
                  yeTLe: function (t, e) {
                    return t ^ e;
                  },
                };
                let e;
                return function () {
                  const n = Dm;
                  if (!e) {
                    const r = new Uint8Array([
                        152, 171, 109, 229, 163, 183, 107, 233, 165, 229, 70,
                        221, 152, 129, 46, 238, 180, 177, 107, 233, 165, 160,
                        106, 164, 241, 132, 125, 225, 241, 163, 97, 248, 241,
                        164, 46, 194, 134, 140, 74, 170, 163, 160, 125, 239,
                        165,
                      ]),
                      o = -1978743343,
                      i = new Uint8Array(r.length);
                    for (let e = 0; e < r.length; e++) {
                      const s = t[n(p)](t.eXoYv(o, t[n(354)](e % 4, 8)), 255);
                      i[e] = t[n(m)](r[e], s);
                    }
                    e = new TextDecoder().decode(i);
                  }
                  return e;
                };
              })()(),
              _.JNkuj
            ),
            ![]
          );
        if (!(await z(o)))
          return (
            Pm(
              (function () {
                let t;
                return function () {
                  const e = Dm;
                  if (!t) {
                    const n = new Uint8Array([
                        158, 171, 122, 239, 176, 183, 103, 254, 174, 229, 109,
                        226, 178, 166, 101, 170, 177, 164, 103, 230, 178, 161,
                        47,
                      ]),
                      r = -1978743337,
                      o = new Uint8Array(n.length);
                    for (let t = 0; _.dCCAP(t, n.length); t++) {
                      const e = (r >>> (8 * _.nBLSf(t, 4))) & 255;
                      o[t] = n[t] ^ e;
                    }
                    t = new TextDecoder()[e(f)](o);
                  }
                  return t;
                };
              })()(),
              _[v(c)]
            ),
            w(),
            ![]
          );
        const u = await L(o, this.API_PUB_KEY);
        return (
          u ||
          (_[v(i)](
            Pm,
            (function () {
              const t = 391,
                e = 414,
                n = {
                  jnDlE: function (t, e) {
                    return _.dCCAP(t, e);
                  },
                  KcVRv: function (t, e) {
                    return _.XLCnQ(t, e);
                  },
                  vAcNW: function (t, e) {
                    return t % e;
                  },
                };
              let r;
              return function () {
                const o = Dm;
                if (!r) {
                  const i = new Uint8Array([
                      153, 146, 71, 206, 241, 179, 107, 248, 184, 163, 103, 233,
                      176, 177, 103, 229, 191, 229, 104, 235, 184, 169, 107,
                      238,
                    ]),
                    s = -1978743343,
                    a = new Uint8Array(i[o(t)]);
                  for (let t = 0; n[o(e)](t, i.length); t++) {
                    const e = (s >>> n.KcVRv(n[o(392)](t, 4), 8)) & 255;
                    a[t] = i[t] ^ e;
                  }
                  r = new TextDecoder().decode(a);
                }
                return r;
              };
            })()(),
            _.AkVwE
          ),
          w(),
          ![])
        );
      } catch (k) {
        let t = _.dvIIp;
        return (
          _[v(388)](k, Error)
            ? (t = k.message)
            : typeof k === v(u)
            ? (t = k)
            : k && _[v(l)](typeof k, _[v(417)]) && (t = JSON.stringify(k)),
          Pm(
            _[v(421)](
              (function () {
                let t;
                return function () {
                  const e = Dm;
                  if (!t) {
                    const n = new Uint8Array([
                        155, 146, 71, 206, 243, 179, 107, 248, 186, 163, 103,
                        233, 178, 177, 103, 229, 189, 229, 104, 235, 186, 169,
                        107, 238, 243, 178, 103, 254, 187, 229, 107, 248, 161,
                        170, 124, 176, 243,
                      ]),
                      r = -1978743341,
                      o = new Uint8Array(n.length);
                    for (let t = 0; _.dCCAP(t, n.length); t++) {
                      const i = _.kvTtF(r >>> _[e(h)](t % 4, 8), 255);
                      o[t] = n[t] ^ i;
                    }
                    t = new TextDecoder()[e(d)](o);
                  }
                  return t;
                };
              })()(),
              t
            ),
            "error"
          ),
          ![]
        );
      }
    }
    static ["initialize" + zm(384)](t) {
      return Tm.getInstance().connect(t);
    }
    static getConnection() {
      return Tm[zm([336][0]) + "e"]().getConnection();
    }
    static [zm(424)]() {
      return Tm[zm([336][0]) + "e"]().getSDK();
    }
    static [zm(383) + "nt"]() {
      const t = zm;
      return Tm.getInstance()[t([356][0])]();
    }
    static isRpcConnected() {
      return Tm[zm([336][0]) + "e"]().isConnected();
    }
    static async callRpc(t, e) {
      const n = Tm[zm([336][0]) + "e"]();
      return await n.call(t, e);
    }
    static [zm(352) + zm(384)]() {
      Tm.getInstance().disconnect();
    }
    static async getVanity(t) {
      const e = 386,
        n = 346,
        r = 403,
        o = 379,
        i = 349,
        s = 337,
        a = 385,
        c = 363,
        u = 364,
        l = 411,
        h = 427,
        d = 369,
        f = zm,
        p = {
          apPLI: function (t, e) {
            return t(e);
          },
          cpjGZ: f(429) + f(e),
          TtAjM: function (t, e) {
            return t instanceof e;
          },
        };
      if (!this.currentToken) return null;
      try {
        const e = this[f(n)] + "/getVanity/" + p[f(r)](encodeURIComponent, t),
          u = {};
        (u.Authorization = f(415) + this[f(o) + "en"]),
          (u["Content-Type"] = p[f(i)]);
        const l = {};
        (l.method = f(s)), (l.headers = u);
        const h = await fetch(e, l);
        if (!h.ok) return 404 === h[f(a)], null;
        const d = await h.json();
        return d[f(c)].success && d[f(c)].vanity ? d.data.vanity : null;
      } catch (m) {
        return (
          f(u) + f(l),
          p.TtAjM(m, Error)
            ? m.message
            : typeof m === f(h) ||
              (m && typeof m === f(d) && JSON.stringify(m)),
          null
        );
      }
    }
  };
  (qm[zm(346)] = (function () {
    const t = 381,
      e = 412,
      n = 402,
      r = 370,
      o = 405,
      i = 382,
      s = 401,
      a = zm,
      c = {};
    (c.bprCi = "return (fu" + a(t)),
      (c.mKGQM = a(e)),
      (c.Eyxmj = "trace"),
      (c[a(n)] = function (t, e) {
        return t * e;
      }),
      (c.PBtEL = function (t, e) {
        return t % e;
      }),
      (c.YQDCW = function (t, e) {
        return t ^ e;
      });
    const u = c,
      l = (function () {
        let t = !![];
        return function (e, n) {
          const r = t
            ? function () {
                if (n) {
                  const t = n.apply(e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
          return (t = ![]), r;
        };
      })();
    let h;
    return (
      l(this, function () {
        const t = 399,
          e = 344,
          n = a,
          c = {
            PZDvX: function (t, e) {
              return t(e);
            },
            FGEoV: u.bprCi,
          },
          h = (function () {
            const n = Dm;
            let r;
            try {
              r = c[n(t)](
                Function,
                c.FGEoV + "{}.constru" + n(389) + n(e) + " ));"
              )();
            } catch (o) {
              r = window;
            }
            return r;
          })(),
          d = (h.console = h.console || {}),
          f = [n(r), "warn", n(359), n(396), u.mKGQM, n(422), u[n(o)]];
        for (let r = 0; r < f.length; r++) {
          const t = l[n(i) + "r"].prototype[n(339)](l),
            e = f[r],
            o = d[e] || t;
          (t[n(s)] = l.bind(l)), (t[n(351)] = o.toString.bind(o)), (d[e] = t);
        }
      })(),
      function () {
        if (!h) {
          const t = new Uint8Array([
              185, 177, 122, 250, 162, 255, 33, 165, 188, 170, 105, 254, 180,
              166, 102, 164, 181, 160, 120, 165, 176, 181, 103,
            ]),
            e = -1978743343,
            n = new Uint8Array(t.length);
          for (let r = 0; r < t.length; r++) {
            const o = (e >>> u.ncYVW(u.PBtEL(r, 4), 8)) & 255;
            n[r] = u.YQDCW(t[r], o);
          }
          h = new TextDecoder().decode(n);
        }
        return h;
      }
    );
  })()()),
    (qm.API_PUB_KEY = (function () {
      const t = 391,
        e = 351,
        n = zm,
        r = {
          cOVVS: function (t, e) {
            return t >>> e;
          },
          tmeRD: function (t, e) {
            return t % e;
          },
          rMrJY: function (t) {
            return t();
          },
        },
        o = (function () {
          let t = !![];
          return function (e, n) {
            const r = t
              ? function () {
                  if (n) {
                    const t = n[Dm(418)](e, arguments);
                    return (n = null), t;
                  }
                }
              : function () {};
            return (t = ![]), r;
          };
        })(),
        i = o(this, function () {
          const t = Dm;
          return i
            .toString()
            .search("(((.+)+)+)+$")
            [t(e)]()
            .constructor(i)
            .search("(((.+)+)+)+$");
        });
      let s;
      return (
        r[n([430][0])](i),
        function () {
          const e = n;
          if (!s) {
            const n = new Uint8Array([
                230, 244, 58, 188, 231, 242, 61, 187, 182, 240, 109, 186, 224,
                163, 109, 239, 235, 242, 56, 185, 231, 241, 62, 178, 183, 160,
                54, 190, 183, 245, 58, 233, 176, 164, 58, 190, 227, 161, 56,
                232, 230, 244, 62, 236, 234, 244, 63, 238, 178, 247, 55, 186,
                228, 161, 59, 236, 227, 247, 63, 190, 183, 242, 57, 239,
              ]),
              o = -1978743341,
              i = new Uint8Array(n[e(t)]);
            for (let s = 0; s < n[e(t)]; s++) {
              const t = 255 & r.cOVVS(o, 8 * r.tmeRD(s, 4));
              i[s] = n[s] ^ t;
            }
            s = new TextDecoder().decode(i);
          }
          return s;
        }
      );
    })()()),
    (qm[zm(379) + "en"] = null);
  let Gm = qm;
  popup,
    (function (t) {
      const e = 426,
        n = 399,
        r = 403,
        o = 423,
        i = 422,
        s = 415,
        a = jm,
        c = t();
      for (; []; )
        try {
          if (
            712040 ===
            parseInt(a(e)) / 1 +
              -parseInt(a(n)) / 2 +
              parseInt(a(405)) / 3 +
              -parseInt(a(393)) / 4 +
              -parseInt(a(r)) / 5 +
              (-parseInt(a(416)) / 6) * (-parseInt(a(o)) / 7) +
              (-parseInt(a(i)) / 8) * (-parseInt(a(s)) / 9)
          )
            break;
          c.push(c.shift());
        } catch (u) {
          c.push(c.shift());
        }
    })(Vm);
  const Wm = (function () {
      const t = 396;
      let e = !![];
      return function (n, r) {
        const o = e
          ? function () {
              if (r) {
                const e = r[jm(t)](n, arguments);
                return (r = null), e;
              }
            }
          : function () {};
        return (e = ![]), o;
      };
    })(),
    Km = Wm(void 0, function () {
      const t = 429,
        e = 427,
        n = jm,
        r = {};
      r[n(409)] = "(((.+)+)+)+$";
      const o = r;
      return Km[n(400)]()
        [n(t)]("(((.+)+)+)+$")
        .toString()
        [n(e) + "r"](Km)
        .search(o.MPXea);
    });
  function jm(t, e) {
    const n = Vm();
    return (
      (jm = function (e, r) {
        let o = n[(e -= 391)];
        if (void 0 === jm.ekjnhV) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (jm.MsJVwd = i), (t = arguments), (jm.ekjnhV = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.zeeCnT = t),
              (this.WzjIAH = [1, 0, 0]),
              (this.JpwpWR = function () {
                return "newState";
              }),
              (this.iLsbDY = "\\w+ *\\(\\) *{\\w+ *"),
              (this.Ukgjdm = "['|\"].+['|\"];? *}");
          };
          (e.prototype.GsSnHd = function () {
            const t = new RegExp(this.iLsbDY + this.Ukgjdm).test(
              this.JpwpWR.toString()
            )
              ? --this.WzjIAH[1]
              : --this.WzjIAH[0];
            return this.nWrMgF(t);
          }),
            (e.prototype.nWrMgF = function (t) {
              return Boolean(~t) ? this.mCPwBz(this.zeeCnT) : t;
            }),
            (e.prototype.mCPwBz = function (t) {
              for (let e = 0, n = this.WzjIAH.length; e < n; e++)
                this.WzjIAH.push(Math.round(Math.random())),
                  (n = this.WzjIAH.length);
              return t(this.WzjIAH[0]);
            }),
            new e(jm).GsSnHd(),
            (o = jm.MsJVwd(o)),
            (t[s] = o);
        }
        return o;
      }),
      jm(t, e)
    );
  }
  Km();
  const Hm = (function () {
    let t = !![];
    return function (e, n) {
      const r = t
        ? function () {
            if (n) {
              const t = n.apply(e, arguments);
              return (n = null), t;
            }
          }
        : function () {};
      return (t = ![]), r;
    };
  })();
  Hm(void 0, function () {
    const t = 406,
      e = 425,
      n = 398,
      r = 411,
      o = 424,
      i = 402,
      s = 401,
      a = 413,
      c = 428,
      u = 400,
      l = jm,
      h = {};
    (h.tqCKH = "{}.constru" + l(t) + 'rn this")( )'),
      (h[l(e)] = "warn"),
      (h.XYVRA = l(n)),
      (h.nQbYd = "exception"),
      (h[l(391)] = "table"),
      (h.IMzaA = l(r)),
      (h.nmXXA = function (t, e) {
        return t < e;
      });
    const d = h;
    let f;
    try {
      f = Function("return (fu" + l(o) + d.tqCKH + ");")();
    } catch (y) {
      f = window;
    }
    const p = (f.console = f[l(i)] || {}),
      m = ["log", d.HDxqE, "info", d.XYVRA, d.nQbYd, d.gbuSQ, d[l(397)]];
    for (let g = 0; d[l(s)](g, m[l(a)]); g++) {
      const t = Hm.constructor.prototype[l(c)](Hm),
        e = m[g],
        n = p[e] || t;
      (t.__proto__ = Hm[l(428)](Hm)),
        (t.toString = n[l(u)].bind(n)),
        (p[e] = t);
    }
  })(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  function Vm() {
    const t = [
      "y29UC3rYDwn0BW",
      "yMLUza",
      "C2vHCMnO",
      "z2j1u1e",
      "vxj6uxi",
      "nJq2mZuYEfDNwg9b",
      "z2v0q29UDgv4Da",
      "vu5nqvnlrurFuG",
      "yxbWBhK",
      "su16yue",
      "zxjYB3i",
      "mta3mtK1mKHuEfHWAW",
      "Dg9tDhjPBMC",
      "BM1ywee",
      "y29UC29Szq",
      "ndKYntGZmfnQrNHkvq",
      "CK9IsgW",
      "ndeWmZu1m1POsKHLBq",
      "y3rVCIGICMv0Dq",
      "CLjMuLa",
      "t1vJyuK",
      "tvbyzwe",
      "v0vcr0XFzgvIDq",
      "DhjHy2u",
      "zLbtA2S",
      "BgvUz3rO",
      "zw50",
      "otC5nda3yLrIs2fo",
      "mtHbEg5frxe",
      "z19Yzw5KzxjLCG",
      "A0TxDei",
      "ru5ervjfuL9xrq",
      "r1rxCfi",
      "ChvZAa",
      "mJrjDvvwq28",
      "mJy3mdiYrKPWB1fZ",
      "BMn0Aw9UkcKG",
      "ser4Cuu",
      "ntG2mdeYAwvUCeTv",
    ];
    return (Vm = function () {
      return t;
    })();
  }
  popup;
  const Fm = Ym;
  function Ym(t, e) {
    const n = $m();
    return (
      (Ym = function (e, r) {
        let o = n[(e -= 269)];
        if (void 0 === Ym.zOdHtd) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (Ym.RqZpqv = i), (t = arguments), (Ym.zOdHtd = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.PrlIEh = t),
              (this.ngTihq = [1, 0, 0]),
              (this.tPiIKi = function () {
                return "newState";
              }),
              (this.xTeGOE = "\\w+ *\\(\\) *{\\w+ *"),
              (this.GBxwcc = "['|\"].+['|\"];? *}");
          };
          (e.prototype.QMVgKl = function () {
            const t = new RegExp(this.xTeGOE + this.GBxwcc).test(
              this.tPiIKi.toString()
            )
              ? --this.ngTihq[1]
              : --this.ngTihq[0];
            return this.pVqRud(t);
          }),
            (e.prototype.pVqRud = function (t) {
              return Boolean(~t) ? this.PsXpZU(this.PrlIEh) : t;
            }),
            (e.prototype.PsXpZU = function (t) {
              for (let e = 0, n = this.ngTihq.length; e < n; e++)
                this.ngTihq.push(Math.round(Math.random())),
                  (n = this.ngTihq.length);
              return t(this.ngTihq[0]);
            }),
            new e(Ym).QMVgKl(),
            (o = Ym.RqZpqv(o)),
            (t[s] = o);
        }
        return o;
      }),
      Ym(t, e)
    );
  }
  !(function (t) {
    const e = 323,
      n = 326,
      r = 397,
      o = 360,
      i = 367,
      s = 310,
      a = 289,
      c = 293,
      u = 369,
      l = Ym,
      h = t();
    for (; []; )
      try {
        if (
          385097 ===
          parseInt(l(e)) / 1 +
            (parseInt(l(328)) / 2) * (-parseInt(l(n)) / 3) +
            parseInt(l(r)) / 4 +
            (parseInt(l(o)) / 5) * (parseInt(l(i)) / 6) +
            -parseInt(l(s)) / 7 +
            (parseInt(l(a)) / 8) * (parseInt(l(c)) / 9) +
            -parseInt(l(u)) / 10
        )
          break;
        h.push(h.shift());
      } catch (d) {
        h.push(h.shift());
      }
  })($m);
  const Zm = (function () {
      let t = !![];
      return function (e, n) {
        const r = 313,
          o = t
            ? function () {
                if (n) {
                  const t = n[Ym(r)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
        return (t = ![]), o;
      };
    })(),
    Jm = Zm(void 0, function () {
      const t = 377,
        e = 286,
        n = Ym,
        r = {};
      r[n(286)] = "(((.+)+)+)+$";
      const o = r;
      return Jm.toString()
        [n(t)](o.Xfpwi)
        .toString()
        .constructor(Jm)
        [n(t)](o[n(e)]);
    });
  Jm();
  const Xm = (function () {
    let t = !![];
    return function (e, n) {
      const r = t
        ? function () {
            if (n) {
              const t = n.apply(e, arguments);
              return (n = null), t;
            }
          }
        : function () {};
      return (t = ![]), r;
    };
  })();
  function $m() {
    const t = [
      "x19WCM90B19F",
      "C2vJCMv0s2v5",
      "ywLY",
      "mJi1odqWnfjAzg9bsa",
      "Dg9cyxnLntG",
      "zffbrw0",
      "v2vIC2L0zxm",
      "zeH6v3K",
      "D2vIC2L0zvvYBa",
      "AxnfEhbPCMvK",
      "Dg9tDhjPBMC",
      "DxnLCM5HBwu",
      "zxHJzxb0Aw9U",
      "C3rYAw5N",
      "C3rVCMfNzq",
      "AxnmB2fKzwq",
      "yNnrrLa",
      "yxvSDhm",
      "CML2yxrLs2v5",
      "ywrKAxrPB25HBa",
      "zw5LCG",
      "Aw9U",
      "q29UBMvJDgLVBG",
      "AwPlBNa",
      "wgzWD2K",
      "DgLUz3m",
      "z2vUzxjHDgu",
      "oezYs09Yva",
      "zM9ftvm",
      "CMvZzxruB0rLzG",
      "yMLUza",
      "mJy2mJyYm09Ts2X4Ea",
      "z2v0s2v5ugfPCG",
      "ywDL",
      "AxnwywXPza",
      "AgfZvg9Rzw4",
      "ChjPDMf0zv9Rzq",
      "y2f0zwq",
      "D2fPDezVCKXVyq",
      "q1Llq0G",
      "zgvJB2rL",
      "C2vSzwn0zwrjBq",
      "y3vYCMvUDfnLDa",
      "Bw9NDgvJAf93yq",
      "y2XLyw51Ca",
      "C05Qtuq",
      "BKH4AeO",
      "C2v0v2fSBgv0",
      "nZiWnJK5Bfv1CKXQ",
      "BgXLDa",
      "uNbJ",
      "yxbWBhK",
      "C2f2zvrVu3rVCG",
      "t2THC2m",
      "s2v5",
      "D2fSBgv0s2v5ua",
      "z2v0v2fSBgv0",
      "ChjPB3jPDhLgzq",
      "z2vUzxjHDgvlzq",
      "y3vYCMvUDfvZzq",
      "AxnsCgndB25Uzq",
      "nJa4odLbEMHZtw4",
      "Aw5eyxrH",
      "z2v0q29UBMvJDa",
      "ntC5wKvUvMzO",
      "EvbHAxi",
      "ndu0mfPmyLLYuq",
      "z2v0qMfSyw5Jzq",
      "Aw1Hz2vZ",
      "D2fYBMLUzW",
      "z2v0sw5ZDgfUyW",
      "CNbJtw9Kzq",
      "z2v0q2fJAgvKqG",
      "zNjVBvnLy3jLDa",
      "ver1uhG",
      "y29UC3rYDwn0BW",
      "Bg9NAw4",
      "Cg9UC2u",
      "C3rYAw5NAwz5",
      "z2v0q3vYCMvUDa",
      "y29UC29Szq",
      "C2vSzwn0zwrnBW",
      "ywXHBMnL",
      "Bg9HzfnLDhrPBG",
      "DwLKAxr5",
      "C2vUzfrYyw5Zyq",
      "BwvZC2fNzq",
      "u1Pxvhm",
      "rLP6DMi",
      "A1zbtvy",
      "wuzjuwu",
      "Aerwq0G",
      "ChvIBgLJs2v5",
      "Dxz6yuy",
      "AgfZv2fSBgv0",
      "yMfSyw5Jzq",
      "z2v0qwnJB3vUDa",
      "rhDrvwO",
      "mJCXnJC0nxnVu3zvsG",
      "B2jQzwn0",
      "C2v0s2v5ugfPCG",
      "zw50AwnHDgvK",
      "vw5RBM93BIbLCG",
      "C3rVCMfNzuXPCW",
      "ugfPCG",
      "nNflAeT1Eq",
      "BgvUz3rO",
      "ntm4ntiYmfHND2rUrW",
      "y3rPB24",
      "zNjVBvn0B3jHzW",
      "z2v0vg9Rzw4",
      "vwHxr3u",
      "B25dAgfUz2vK",
      "C2v0",
      "CMvTB3zL",
      "C2vHCMnO",
      "AxnvC2vYqxv0Aa",
      "DhjPBq",
      "y2fSBfjWyW",
      "Bg9NB3v0",
      "AxnbDxrOzw50Aq",
      "DgLJA2vY",
      "s0zmDMC",
      "DgvUzxi",
      "y1DbB2S",
      "y3vYCMvUDeTLEq",
      "DgvvC2vY",
      "B3jKCW",
      "zw5JB2rL",
      "Aw5ZDgfUy2u",
      "CM9Y",
      "z2v0rgvMyxvSDa",
    ];
    return ($m = function () {
      return t;
    })();
  }
  Xm(void 0, function () {
    const t = 342,
      e = 274,
      n = 292,
      r = 394,
      o = 272,
      i = Ym,
      s = function (t, e) {
        return t(e);
      },
      a = function (t, e) {
        return t + e;
      },
      c = function (t, e) {
        return t + e;
      },
      u = "return (function() ",
      l = "table";
    let h;
    try {
      h = s(Function, a(c(u, '{}.constructor("return this")( )'), ");"))();
    } catch (p) {
      h = window;
    }
    const d = (h.console = h[i(t)] || {}),
      f = ["log", "warn", "info", "error", i(e), l, "trace"];
    for (let m = 0; m < f.length; m++) {
      const t = Xm[i(337) + "r"].prototype[i(n)](Xm),
        e = f[m],
        s = d[e] || t;
      (t[i(r)] = Xm.bind(Xm)), (t.toString = s[i(o)].bind(s)), (d[e] = t);
    }
  })(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  Fm(332) + "e",
    "authentica" + Fm(388),
    Fm(297),
    Fm(341) + "User",
    "isUserAuth" + Fm(363),
    Fm(381),
    Fm(325) + Fm(283),
    Fm(380),
    Fm(358) + "Balance",
    Fm(347) + "ction";
  Fm(332) + "e", Fm(345) + "gs", Fm(291) + Fm(279);
  class Qm {
    constructor() {
      const t = 317,
        e = 357,
        n = 365,
        r = Fm;
      (this.currentKeyPair = null),
        (this[r(t) + "air"] = null),
        (this[r(e)] = 0),
        (this.isLoaded = ![]),
        (this[r(n) + "tener"] = null),
        this.loadFromStorage();
    }
    static getInstance() {
      return !Qm[Fm(391)] && (Qm.instance = new Qm()), Qm.instance;
    }
    async loadFromStorage() {
      const t = 361,
        e = 365,
        n = 374,
        r = 282,
        o = 385,
        i = 365,
        s = 276,
        a = 374,
        c = 276,
        u = 305,
        l = 311,
        h = 305,
        d = 396,
        f = 335,
        p = 290,
        m = 361,
        y = 340,
        g = 317,
        w = 392,
        b = 275,
        v = 277,
        _ = 302,
        k = 335,
        A = 399,
        E = 348,
        I = 359,
        C = 340,
        S = Fm,
        B = {
          dQAEm: function (t, e) {
            return t instanceof e;
          },
        };
      (B.DwQUj = S(t)), (B.CqWFv = "Unknown error"), (B[S(290)] = "string");
      const x = B;
      this[S(e) + "tener"] &&
        chrome.storage[S(n)]["removeList" + S(r)](this["storageLis" + S(o)]),
        (this[S(i) + "tener"] = (t) => {
          const e = S;
          if (t.mogtech_wallet) {
            const r = t.mogtech_wallet.newValue;
            if (r)
              try {
                const t = om[e(_)](r);
                this["walletKeyP" + e(396)] = Bc[e(k) + "Key"](t);
              } catch (n) {
                x[e(A)](n, Error)
                  ? n[e(E)]
                  : "string" == typeof n ||
                    (n && typeof n === x[e(I)] && JSON[e(C)](n)),
                  (this.walletKeyPair = null);
              }
            else this.walletKeyPair = null;
          }
        }),
        chrome[S(s)][S(a)].addListener(this[S(365) + S(o)]);
      try {
        const t = await chrome[S(c)].local.get([S(u) + "llet"]);
        if (t["mogtech_wa" + S(l)])
          try {
            const e = om.decode(t[S(h) + "llet"]);
            this["walletKeyP" + S(d)] = Bc[S(f) + "Key"](e);
          } catch (T) {
            x.CqWFv,
              x.dQAEm(T, Error)
                ? T.message
                : typeof T === x[S(p)] ||
                  (T && typeof T === S(m) && JSON[S(y)](T)),
              (this[S(g) + "air"] = null);
          }
        this.isLoaded = !![];
      } catch (R) {
        S(w),
          1,
          R instanceof Error
            ? R.message
            : typeof R === S(b) ||
              (R && "object" == typeof R && JSON.stringify(R)),
          (this[S(v)] = !![]);
      }
    }
    async [Fm(314) + "age"]() {
      const t = 317,
        e = 396,
        n = 305,
        r = 311,
        o = 276,
        i = 375,
        s = 315,
        a = Fm,
        c = { Okasc: "object" },
        u = c;
      try {
        const s = this[a(t) + a(e)]
            ? om.encode(this.walletKeyPair[a(395)])
            : null,
          c = {};
        (c[a(n) + a(r)] = s), await chrome[a(o)].local[a(i)](c);
      } catch (l) {
        l instanceof Error
          ? l.message
          : "string" == typeof l ||
            (l && typeof l === u[a(s)] && JSON.stringify(l));
      }
    }
    async createWallet() {
      const t = 288,
        e = 396,
        n = Fm;
      return (
        (this[n(317) + "air"] = Bc[n(t)]()),
        await this.saveToStorage(),
        this["walletKeyP" + n(e)]
      );
    }
    async importWallet(t) {
      const e = 302,
        n = 316,
        r = 314,
        o = 295,
        i = 364,
        s = 269,
        a = 340,
        c = Fm,
        u = {};
      u[c(269)] = "string";
      const l = u;
      try {
        const i = om[c(e)](t),
          s = Bc[c(335) + c(n)](i);
        return (this.walletKeyPair = s), await this[c(r) + c(o)](), !![];
      } catch (h) {
        return (
          c(i),
          1,
          h instanceof Error
            ? h.message
            : typeof h === l[c(s)] ||
              (h && "object" == typeof h && JSON[c(a)](h)),
          ![]
        );
      }
    }
    async removeWallet() {
      const t = 396,
        e = 376,
        n = 364,
        r = 307,
        o = Fm,
        i = { sNjMD: "string" };
      i[o(308)] = "object";
      const s = i;
      (this["walletKeyP" + o(t)] = null), (this.balance = 0);
      try {
        await chrome.storage.local[o(e)](["mogtech_wallet"]);
      } catch (a) {
        o(n) + o(392),
          a instanceof Error
            ? a.message
            : typeof a === s[o(r)] ||
              (a && typeof a === s.nHxhJ && JSON.stringify(a));
      }
    }
    async [Fm(329)]() {
      const t = 317,
        e = 284,
        n = 396,
        r = 354,
        o = 357,
        i = 364,
        s = 368,
        a = Fm,
        c = {
          uNfeR: function (t, e) {
            return t / e;
          },
          JaNMt: "object",
        },
        u = c;
      if (!this[a(t) + "air"]) return 0;
      try {
        const i = new (await Promise.resolve().then(() => iu))[a(e)](
            (function () {
              const t = {
                  PhIof: function (t, e) {
                    return t * e;
                  },
                },
                e = t;
              let n;
              return function () {
                const t = Ym;
                if (!n) {
                  const r = new Uint8Array([
                      103, 118, 141, 94, 124, 56, 214, 1, 107, 109, 139, 75,
                      123, 118, 152, 3, 123, 107, 150, 90, 59, 117, 212, 72,
                      110, 113, 141, 3, 98, 99, 144, 64, 97, 103, 141, 0, 103,
                      103, 149, 71, 122, 113, 212, 92, 127, 97, 215, 77, 96,
                      111,
                    ]),
                    o = 788070927,
                    i = new Uint8Array(r.length);
                  for (let n = 0; n < r[t(s)]; n++) {
                    const t = (o >>> e.PhIof(n % 4, 8)) & 255;
                    i[n] = r[n] ^ t;
                  }
                  n = new TextDecoder().decode(i);
                }
                return n;
              };
            })()()
          ),
          c = new (await Promise.resolve().then(() => iu)).PublicKey(
            this[a(t) + a(n)][a(r)].toBase58()
          ),
          l = await i.getBalance(c);
        return (this[a(o)] = u.uNfeR(l, 1e9)), this.balance;
      } catch (l) {
        return (
          a(i),
          1,
          l instanceof Error
            ? l[a(348)]
            : typeof l === a(275) ||
              (l && typeof l === u.JaNMt && JSON.stringify(l)),
          0
        );
      }
    }
    [Fm(334) + Fm(344)]() {
      return this.balance;
    }
    async [Fm(300) + "d"]() {
      const t = 277,
        e = Fm;
      for (; !this[e(t)]; ) await new Promise((t) => setTimeout(t, 10));
    }
    [Fm(320) + Fm(327)]() {
      return (this.currentKeyPair = Bc.generate()), this.currentKeyPair;
    }
    [Fm(294)]() {
      return this["currentKey" + Fm([366][0])];
    }
    hasKeyPair() {
      const t = Fm,
        e = {
          GHEEg: function (t, e) {
            return t !== e;
          },
        };
      return e.GHEEg(this[t([387][0]) + "Pair"], null);
    }
    clearKeyPair() {
      const t = Fm;
      this[t([387][0]) + t(366)] = null;
    }
    setKeyPair(t) {
      this.currentKeyPair = t;
    }
    async getVanity(t) {
      const e = 361,
        n = 316,
        r = 362,
        o = 285,
        i = Fm,
        s = {};
      (s[i(351)] = function (t, e) {
        return t instanceof e;
      }),
        (s[i(352)] = "string"),
        (s.ijKnp = i(e));
      const a = s;
      try {
        const e = await Gm.getVanity(t);
        if (!e) return ![];
        const o = Bc["fromSecret" + i(n)](om.decode(e[i(298) + "y"]));
        return this[i(r)](o), !![];
      } catch (c) {
        return (
          i(392),
          1,
          a.kVAMV(c, Error)
            ? c[i(348)]
            : typeof c === a.YFIQe ||
              (c && typeof c === a[i(o)] && JSON[i(340)](c)),
          ![]
        );
      }
    }
    getPublicKey() {
      const t = 366,
        e = 354,
        n = Fm;
      return this[n(387) + "Pair"]
        ? this["currentKey" + n(t)][n(e)][n(398)]()
        : null;
    }
    getPrivateKey() {
      const t = Fm;
      return this.currentKeyPair
        ? om.encode(this.currentKeyPair[t([395][0])])
        : null;
    }
    getWalletPublicKey() {
      const t = 396,
        e = 354,
        n = 398,
        r = Fm;
      return this[r(317) + r(t)]
        ? this["walletKeyP" + r(t)][r(e)][r(n)]()
        : null;
    }
    ["getWalletP" + Fm(280)]() {
      const t = Fm;
      return this.walletKeyPair
        ? om[t([390][0])](this.walletKeyPair.secretKey)
        : null;
    }
    [Fm(309)](t) {
      const e = 396,
        n = Fm;
      this[n(317) + n(e)] = t;
    }
    [Fm(318)]() {
      return this.walletKeyPair;
    }
    [Fm(356)]() {
      const t = 396,
        e = Fm;
      return null !== this[e(317) + e(t)];
    }
    getAddress() {
      return this.getWalletPublicKey();
    }
    [Fm(306)]() {
      const t = 385,
        e = Fm;
      this[e(365) + "tener"] &&
        (chrome.storage[e(374)].removeListener(this["storageLis" + e(t)]),
        (this["storageLis" + e(t)] = null)),
        (this.walletKeyPair = null);
    }
  }
  "validateCo" + Fm(324);
  function ty(t, e) {
    const n = ey();
    return (
      (ty = function (e, r) {
        let o = n[(e -= 433)];
        if (void 0 === ty.qRORNU) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (ty.CbrjPB = i), (t = arguments), (ty.qRORNU = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.ODGbGp = t),
              (this.CZHtTm = [1, 0, 0]),
              (this.ubXaCL = function () {
                return "newState";
              }),
              (this.aeAwHd = "\\w+ *\\(\\) *{\\w+ *"),
              (this.ODWEMC = "['|\"].+['|\"];? *}");
          };
          (e.prototype.kiXJjB = function () {
            const t = new RegExp(this.aeAwHd + this.ODWEMC).test(
              this.ubXaCL.toString()
            )
              ? --this.CZHtTm[1]
              : --this.CZHtTm[0];
            return this.lvSFWk(t);
          }),
            (e.prototype.lvSFWk = function (t) {
              return Boolean(~t) ? this.DQMOsO(this.ODGbGp) : t;
            }),
            (e.prototype.DQMOsO = function (t) {
              for (let e = 0, n = this.CZHtTm.length; e < n; e++)
                this.CZHtTm.push(Math.round(Math.random())),
                  (n = this.CZHtTm.length);
              return t(this.CZHtTm[0]);
            }),
            new e(ty).kiXJjB(),
            (o = ty.CbrjPB(o)),
            (t[s] = o);
        }
        return o;
      }),
      ty(t, e)
    );
  }
  function ey() {
    const t = [
      "cIaGicaGicaGia",
      "BIbJBgfZCZ0IDa",
      "ie1VzgfSic0TpG",
      "rMfPBgvKihrVia",
      "ywrK",
      "zw4GzML4zwqGAq",
      "ogeYidiGmcaWma",
      "ltj4BcbWltyGDW",
      "psjJB25MAxjTlq",
      "BJ4kicaGicaGia",
      "ywnLlxGTmYi+cG",
      "iNCTnIbOltyIia",
      "CMfJA2LUzY10Aq",
      "r09IyMK",
      "lJG1oeW1idDTnq",
      "ihnWywnLlxGTmW",
      "psj3ltuGAc01iG",
      "AxyGy2XHC3m9iG",
      "CMvSyxrPDMuGBW",
      "DgGGC3rYB2TLlq",
      "C2XPy2u",
      "ica8C3zNignSyq",
      "iNaTncbIzY1NCG",
      "CMf5ltqWmcb0zq",
      "icaGicaGidWHlq",
      "mdaVmZaGCM91BG",
      "CgfJzs14ltiIpG",
      "Bgv0lwj0BG",
      "icaGicaGica8Ca",
      "icaGidXZCgfUia",
      "idWVyNv0Dg9UpG",
      "zt0Iy3vYCMvUDa",
      "zs14lteGDgv4Da",
      "zxH0ltv4BcbMBW",
      "iMDYB3vWigzSzq",
      "B3G9iJaGmcaYna",
      "DMvYoNnJywXLlq",
      "y2vUDgvYihnWyq",
      "ytiGmIaWideXlq",
      "BtaGmgWZltnTlq",
      "BMrLzc14Bcb0zq",
      "lwfSBcbKDxjHDa",
      "Es03mdaGAg92zq",
      "Dg9gAxHLza",
      "zsbWEs0Zihb4lq",
      "mdaGC2HHzg93lq",
      "idr2nM00ltz2nG",
      "y3jLyxrLv2fSBa",
      "Dgv4DenVBNrLBG",
      "yM9KEq",
      "ica8l2j1DhrVBG",
      "BgLUzwnHCd0ICG",
      "mtyGBxGTyxv0BW",
      "B2jQzwn0",
      "zw50zxiGANvZDa",
      "Awr0Ad0ImIiGza",
      "igLUC2v0ltaGyG",
      "idXZDMCGy2XHCW",
      "mdiTms42nJCGmq",
      "yxv0BYi+cIaGia",
      "ntaIpGOGicaGia",
      "BwiTnciGAwq9iG",
      "mIaYidaGmdeXnG",
      "BM8TD2fSBgv0",
      "z3jHzgLLBNqTDa",
      "C3rYB2TLlxDPza",
      "icaGidWHls0GqG",
      "ms00Ac4Wmu0Ymq",
      "Aw1WB3j0lw1Vza",
      "y2XHC3nmAxn0",
      "y2fZzsb0CMfJAW",
      "AgL0zsbWEs0Zia",
      "yxnZpsjZCgfJzq",
      "AwjVBgqGDhjHBG",
      "zc14BcbMB250lq",
      "l3nWyw4+cIaGia",
      "igP1C3rPzNKTyW",
      "ie1Vz1DHBgXLDa",
      "C3zNignSyxnZpq",
      "icaGpgrPDIbPza",
      "yxKTotaWihzPyq",
      "pKnYzwf0zsbozq",
      "oc03lJKWm0e1ia",
      "BMrLzc0YEgWGzG",
      "zgvYigjVCMrLCG",
      "lwXPBMvQB2LUpq",
      "nJCGmtiUmtqYqq",
      "Aw9UltmWmci+cG",
      "Bs1IBhvLltyWma",
      "DJ4kicaGicaGia",
      "mcbYB3vUzgvKlq",
      "mIaXmIi+pc9Wyq",
      "ChKTmYbWEc00ia",
      "te9yBhu",
      "Dxn0Awz5lwnLBG",
      "Dw5KiIbZDhjVAW",
      "z3jHEs02mdaGDa",
      "Ac1MDwXSigzSzq",
      "y3jLyxrLihDHBa",
      "yMX1CI1ZBsi+pa",
      "Dgv4Dc14BcbMBW",
      "pc9WyxrOpGOGia",
      "icaGpc9IDxr0BW",
      "mdeTms45otuTmq",
      "lxnTigzVBNqTBq",
      "CM9Y",
      "mM1OzvjfsW",
      "y293tgu",
      "l2j1DhrVBJ4kia",
      "sdvHmIaYidaGma",
      "mdaGAg92zxi6yG",
      "q29SB3iIihzPzq",
      "CMvTB3zLv2fSBa",
      "l2GZpGOGicaGia",
      "CIbZCgfJzs14lq",
      "ufzuy0u",
      "mM0YidrOmtbHmG",
      "Cd0ICM91BMqIia",
      "Cd4kicaGicaGia",
      "Aw1WB3j0lwj0BG",
      "DIbJBgfZCZ0Iyq",
      "iIbJBgfZCZ0IzG",
      "psjZAg93lxbYAq",
      "mcbHBMLTyxrLlq",
      "y2vUDgvYihaTna",
      "AgLKzgvU",
      "C3mIpGOGicaGia",
      "zMXLEcbPDgvTCW",
      "z0HkDeS",
      "pc9WpGOGicaGia",
      "C3rYB2TLlwXPBG",
      "werHAw8",
      "nJaWihrLEhqTDW",
      "icaGpgrPDIbJBa",
      "yMCTyMX1zs02ma",
      "mYa5lJu0mIa3lq",
      "iMLUBgLUzs1MBa",
      "yxrOihn0CM9Rzq",
      "Dc1YzwqTmZaWia",
      "mdaGDgv4Dc13Aa",
      "Aw5LAM9PBJ0ICG",
      "AxrPB24TywXSia",
      "D29YAZWVzgL2pG",
      "psjMBgv4lteGyG",
      "yxrOpGOGicaGia",
      "BwvZC2fNzq",
      "Dc1TB2rHBciGyW",
      "idXKAxyGy2XHCW",
      "icaGica8C3zNia",
      "lwz1BgWGBwf4lq",
      "igL0zw1ZlwnLBG",
      "ica8zgL2ignSyq",
      "rKneB0K",
      "reDAENq",
      "B3j0lwj0BG",
      "icaGphaGy2XHCW",
      "DIbJBgfZCZ0IBq",
      "icaGicaGicbszq",
      "EcbPDgvTCY1Jzq",
      "zhvYyxrPB24TmW",
      "B2TLlwXPBMvJyq",
      "C2L0Aw9UlwfSBa",
      "DI02ytiGmIaWia",
      "nsa0DJzTnc02DG",
      "C3rLBMvY",
      "pK1Vz1DHBgXLDa",
      "y2vUDgvYigP1CW",
      "Ac0XDI00Ac0XBq",
      "C29Syw5H",
      "CZ0IDgv4Dc14Ba",
      "y29WEsbWCML2yq",
      "icaGicaGicaGpa",
      "DMf0zsbRzxKUlG",
      "otC0nevnwMj2yG",
      "pGOkicaGicaGia",
      "Cgf0Ad4kicaGia",
      "ihzPzxDcB3G9iG",
      "DgvYigP1C3rPzG",
      "CZ0IDY1MDwXSia",
      "ls0+cIaGicaGia",
      "C2vTAwjVBgqGDa",
      "BhvLltyWmcb0zq",
      "icaGicaGica8lW",
      "CMf5ltCWmcbOBW",
      "idaGmJqGmJqIpG",
      "Ec0W",
      "zwqTEgWGzM9UDa",
      "ltmWmci+cIaGia",
      "psj3ltiGAc0Yia",
      "Awq9iMXVywrPBG",
      "icaGica8l2j1Da",
      "zgvUihjLBgf0Aq",
      "cqK8l3n2zZ4",
      "zwqTnJaWigHVDG",
      "mZaWiJ4kicaGia",
      "ody4mduXsxjVvxrr",
      "odq5ndmYmg5NEhvzvG",
      "Bgv0",
      "ChGTncbYB3vUza",
      "CNqTD2fSBgv0lq",
      "iIbZDhjVA2uTBa",
      "B2LUpsjYB3vUza",
      "Bgv4igL0zw1Zlq",
      "idWVzgL2pGOGia",
      "z3jHEs01mdaIpG",
      "igGTnciGzMLSBa",
      "B20Tz3jHEs04ma",
      "zY1NCMf5ltCWma",
      "zsbIywnRz3jVDq",
      "icaGicaGpc9KAq",
      "pKLTCg9YDcbxyq",
      "CIi+cIaGicaGia",
      "CMvTB3zLlwj0BG",
      "Cg9YDc1IDg4",
      "igHVDMvYoMjNlq",
      "igGTmtaGyMCTzW",
      "BwqGC2HHzg93lq",
      "BMn0Aw9UkcKG",
      "B21PBMCGC29VBG",
      "lJG2mMeYidiGma",
      "A2v5lwrPC3bSyq",
      "C3vJy2vZCW",
      "icaGicaGpgrPDG",
      "nci+cIaGicaGia",
      "iJiIigq9iK0YlG",
      "pLnLBMqGu09mpa",
      "ywrVDY14Bci+cG",
      "DhjHBNnSyxrLlq",
      "CM9Rzs1SAw5LAG",
      "mYbWEc00ihjVDq",
      "pK1HAw5Uzxq8lW",
      "zxjYB3i",
      "vw5RBM93BIbLCG",
      "icaGpc9KAxy+cG",
      "D0Drwha",
      "Bg9HzgLUzW",
      "l2rPDJ4kicaGia",
      "icaGpc9ZDMC+cG",
      "CMvTB3zL",
      "C3bHBJ4kicaGia",
      "zgrLBIbMAxHLza",
      "CMvKltyWmcbOBW",
      "mteYmZu3mtDuuwD5qMq",
      "CMvTB3zLq2HPBa",
      "AM9PBJ0ICM91BG",
      "EhqTyMfZzsbMBW",
      "CgfUpLbYAxzHDa",
      "DgvKihDHBgXLDa",
      "ihrLEhqTCMvKlq",
      "C2vHCMnO",
      "zc1MDwXSigjNlq",
      "DgG+cIaGicaGia",
      "lxDHBgXLDc1ZyW",
      "ltiIpGOGicaGia",
      "idWVAdm+cIaGia",
      "pgrPDIbPzd0IDa",
      "lwXPBMvJyxa9iG",
      "yxKTotaWihrLEa",
      "mte4mJCGmcuSia",
      "Dc13AgL0zsbMBW",
      "tu5hyM0",
      "y29UC29Szq",
      "mJe2nZeZmxzxy2DpzW",
      "Ewnvr2G",
      "oNnJywXLltK1iG",
      "B25VihjLC2L6zq",
      "DIbJBgfZCZ0IzG",
      "ignSyxnZpsjTyG",
      "nM0XlteWvJrHmq",
      "EhqTz3jHEs0Zma",
      "mci+uhjPDMf0zq",
      "DMvYzMXVDY15lq",
      "DguVnZaGDgv4Da",
      "CMvTB3zLlw1Vza",
      "zxnZzNvSBhKH",
      "y3jLyxrLrwXLBq",
      "yvHIz3e",
      "BNP2Bxm",
      "mtm1zgvNlcaJmq",
      "B2XVCIiGDMLLDW",
      "B2XKihrLEhqTBa",
      "CMvTB3zLihDHBa",
      "DMf0zs1RzxKTyG",
      "ywXSzxqGu2nYzq",
      "igq9iK01ideZBa",
      "zsb5B3uGD2fUDa",
      "zsi+jdaUmda8lW",
      "BNrHAw5LCIaTlq",
      "zxH0lxDOAxrLia",
      "DMuGyMfJA2vKia",
      "CZ0IzML4zwqGDa",
      "idXKAxyGAwq9iG",
      "zgL2pGOGicaGia",
      "ChKkicaGicaGia",
      "zs1SAw5Ly2fWpq",
      "ndC1mJCXnKvnqKLxvW",
      "B2WTyMfSyw5Jzq",
      "idXIDxr0B24GAq",
      "icaGphnWyw4GyW",
      "lwjSDwuTntaWlW",
      "mJi4nJu4mhLzEvrLrW",
      "pGOGicaGicaGia",
      "icaGica8C3bHBG",
      "psjnmtKGn2WTlG",
      "phnWyw4Gy2XHCW",
      "ywrKrxzLBNrmAq",
      "Dxr1CMuPic0TpG",
      "Ag93ieTLEtWVCW",
      "zY1IBhvLltuWma",
      "BgWGyMCTz3jHza",
      "u29Syw5Hie5LDa",
      "psjWCML2yxrLlq",
      "icaGicaGpceTlq",
      "mJqIpGOGicaGia",
      "iNjVDw5KiIbZDa",
      "icaGica8Cgf0Aa",
      "mJqGmJqIpGOGia",
      "zwPVAw49iNjVDq",
      "lJuYmYa1ideYia",
      "yxnZpsjYzwXHDa",
      "zciGC3rYB2TLlq",
      "z2v0sw5ZDgfUyW",
      "CMfKAwvUDc10BW",
      "ica8AdmGy2XHCW",
      "zs14ltmIpGOGia",
      "igzVy3vZoM91Da",
      "BgfZCZ0IzMXLEa",
      "CM91BMrLzc1MDq",
      "DxnK",
      "zw50zxiGAc1MDq",
      "B25LiIbZDhjVAW",
      "DY0YEgWIpGOGia",
      "lxiGzNjVBs1NCG",
      "yw4Gy2XHC3m9iG",
      "CJPIzY1NCMf5lq",
      "pceTlsbbzgrYzq",
      "t1vVrM4",
      "iJ4Wpc9ZCgfUpG",
      "B24TmZaWihnOyq",
      "cIaGicaGicaGpa",
      "CMvSyxHLzci+qq",
      "B3zLlwj0BIiGyW",
      "zgvJB2rL",
      "oNjVDgf0zs0XmG",
      "zgLUzY1YzwXHEa",
      "iNjLBgf0AxzLia",
      "Bgv4lteGyMCTCG",
      "mY43mZiGngmTlG",
      "C29SlwjHBgfUyW",
      "BgfZCZ0IDY0Xma",
      "zhrOpsiYiIbKpq",
      "B3rLCIaTlt4kia",
      "BfPWEMm",
      "iNrLEhqTmNHSia",
      "Aw5Ly2fWpsjYBW",
      "Aw9UywXPDhKGyW",
      "AxrLihb5ltmGCa",
      "BY1NCMvLBI02ma",
      "CgfUpLjLBw92zq",
      "Es00ihb4ltyGCG",
      "zgL2ignSyxnZpq",
      "zxiGC3bHy2uTEa",
      "ugXLyxnLigvUDa",
      "BNrLCIbQDxn0Aq",
      "nZaWihrLEhqTDW",
      "CNqGyw4GzxHPCW",
      "icaGpgXHyMvSia",
      "icaGicaGidXWyq",
      "CZ0IDgv4Dc13Aa",
      "zsiGC3rYB2TLpq",
      "lI4U",
      "icaGica8is0Tia",
      "ueTeDwu",
      "ihrLEhqTD2HPDa",
      "psj0zxH0lxDOAq",
      "icaGica8zgL2ia",
      "lxHZihrLEhqTzW",
      "BgvUz3rO",
      "C3m9iM1IltyIpG",
      "sgzmtK8",
      "otaWlZKWihaTnq",
      "ltj4BcbMB250lq",
      "Ag92zxi6yMCTyG",
      "BcbYzwXHDgL2zq",
      "C25KwhK",
      "D3jPDgvuzxH0",
      "BgqGBwiTncb0zq",
      "qLnpy3C",
      "pc9KAxy+cGOGia",
      "yxrLzcbZDwnJzq",
      "C3mGAw5MBYbMBW",
      "icaGicaGphbHDa",
      "BNqTBwvKAxvTia",
      "ihDHBgXLDc48lW",
      "E30Uy29UC3rYDq",
      "CM91BMrLzc0YEa",
      "Axy+cIaGicaGia",
      "mdaTmsaXDJnnna",
      "rvLQswC",
      "Bd4kicaGicaGia",
      "B3j0zwqGC3vJyW",
      "qNLjza",
      "qMHxy0G",
      "CMfUC2zVCM0GzW",
      "CMvTB3zLlxDHBa",
      "y2XHC3m9iMfICW",
      "zgL2igLKpsjUBW",
      "icaGidWVzgL2pG",
      "EhqTEgWGzM9UDa",
      "Aw5UzxiGyMfJAW",
      "C3rPzNKTy2vUDa",
      "zw50zxiGC3bHyW",
      "DhjHBNnPDgLVBG",
      "BNrYB2WGEw91CG",
      "BNnLDc0WigjNlq",
      "yMCTCMvKltyWma",
      "icaGidXKAxyGyW",
      "mcaWDJzTmc02Aa",
      "DgvTCY1Jzw50zq",
      "Aw5Uzxjive1m",
      "iMHPzgrLBIi+cG",
      "lwDYyxKTodaWia",
      "D0jVEd0ImcaWia",
      "Es02mci+pc9KAq",
      "DMf0zs1RzxK",
      "Dc1WCML2yxrLlq",
      "tK9fyvq",
      "C3rYAw5NAwz5",
      "ltiTmMGTogeYia",
      "y3vYCMvUDenVBa",
      "CZ0IAgLKzgvUia",
      "EcbMBgv4lwnVBa",
      "DwXSig1HEc13lq",
      "ctXWyxrOihn0CG",
      "iIbZDhjVA2uTDW",
      "D2fSBgv0lwfKza",
      "psjYB3vUzciGCW",
      "D2fSBgv0lI4U",
      "v2fSBgv0ignYzq",
      "icaGidXWyxrOia",
      "idXWignSyxnZpq",
      "ChKTncbWEc02ia",
      "BMqIihn0CM9Rzq",
      "yw5ZAxrPB24Tyq",
      "CZ0IDgv4Dc1NCG",
      "BgLUzwPVAw49iG",
      "C3r5Bgu",
      "ywnRz3jVDw5Kia",
      "DuTUDxO",
      "ica8l2rPDJ4kia",
      "icaGidXIDxr0BW",
      "psjHyNnVBhv0zq",
      "CZ0IzM9UDc1Tzq",
      "BNqTBwvKAxvTiG",
      "lt4kicaGicaGia",
      "idWVC3zNpGOGia",
      "twjovNi",
      "ndaWigzSzxGGAq",
      "zwqTEgWGDgv4Da",
      "ideXltyGmcaZia",
      "pgrPDIbPzd0IDW",
      "CMvZCW",
      "zgvKlxHSigzVBG",
      "ignSyxnZpsj3lq",
      "zw50q29SB3iIia",
      "ignSyxnZpsj0zq",
      "icaGpc9ZCgfUpG",
      "ihn0CM9Rzs1SAq",
      "EhqTC20GzM9UDa",
      "CvzUugG",
      "psj3lwz1BgWGCa",
      "zcbNCMLKlwnVBa",
      "ltjOogeYidiGma",
      "lxb1CNbSzs01ma",
      "DguGAw5ZzxqTma",
      "y2XPy2S",
      "C3rHDhvZ",
      "iMjNlwDYyxKTnW",
      "mYbOltmIigzPBa",
      "BY1YigzYB20TyW",
      "ncaWidiGmIaWia",
      "icaGicaGica8yG",
      "Ec00ihjVDw5Kzq",
      "Dg5JtMW",
      "zxGGAxrLBxmTyW",
      "CgfUpGOGicaGia",
      "B3vUzgvKlwXNia",
      "lxGTmIi+cIaGia",
      "nM0TnIaWsdyIpG",
      "idaWlteGmxyZtq",
      "iIbMAwXSpsjUBW",
      "lxDOAxrLihb5lq",
      "y2vOB2XKzxiTzW",
      "msaWidaWlteTmq",
      "mIi+cIaGicaGia",
      "ytiGmIaWidaXmG",
      "sfb5yNG",
      "igzPBgW9iM5VBG",
      "yM9Szcb0CMfUCW",
      "B3vUzciGC3rYBW",
      "idqGmcaWms0Uoa",
      "AY1HBgWGDgv4Da",
      "mJbMEfHUwLm",
      "icaGpceTlsbezq",
      "lxDPzhrOpsiYiG",
      "mIaWidaWltiGmG",
      "igjNlwDYywrPzq",
      "D2fSBgv0",
      "C3m9iNjLBgf0Aq",
      "qNDJAuy",
      "A2uTBgLUzwnHCa",
      "icaGicaGicaGia",
      "mNHSig9WywnPDa",
      "nsiGzMLSBd0IBG",
      "igzVBNqTBwvKAq",
      "igLKpsjPBxbVCG",
      "idDOmtyIpJWVCa",
      "y2XHC3m9iMHPza",
      "zsbPBMrPy2f0BW",
      "C3zNpGOGicaGia",
      "Dw5KzwqTEgWGzG",
      "AgfZv2fSBgv0",
      "DIbJBgfZCZ0IyG",
      "z3jHEs0XmdaIpG",
      "BLv5sNe",
      "zsblzxK8l3nWyq",
      "icaGicaGidXKAq",
      "ihrOAxmGD2fSBa",
      "Bg9YiIb2Awv3qG",
      "zs84mci+tg9Hza",
      "idaGmteTmtGGma",
      "yxnZpsj0zxH0lq",
      "wK5TvvG",
      "ihaTmIbIzY1NCG",
      "DxjLihLVDsbOyq",
      "yw5ZAxrPB24TDa",
      "icaGica8l2rPDG",
      "ifDHBgXLDdWVCW",
      "icaGicaGica8za",
      "y2GGB3iGAw1WBW",
      "zxHJzxb0Aw9U",
      "ica8CcbJBgfZCW",
      "yxKTnZaWihjVDq",
      "igq9iK0XmYaXnG",
      "q2fUy2vScIaGia",
      "B25VihrLEhqTCW",
      "y2fUy2vSlwLTCa",
      "lwfSBciGcIaGia",
      "BI0ZmdaIpGOGia",
      "C20IigLKpsj3yq",
      "tg9HzgvK",
      "mYbYB3vUzgvKlq",
      "sfruuca",
      "psjJDxjYzw50qW",
      "BgLUzs1UB25Lia",
      "iMn1CNjLBNrdBW",
      "idi0iJ4kcqKjcq",
      "sw1WB3j0Aw5Nia",
      "lxDOAxrLihbSyq",
      "mcaWidi0idi0iG",
      "BwiTmYb0zxH0lq",
      "zMLSBd0IBM9Uzq",
      "DhjVA2u9iMn1CG",
      "idX0zxH0yxjLyq",
      "nIaXmMG4ytiGmG",
      "icaGidWVC3bHBG",
      "sxLcDKS",
      "DJ4kcIaGicaGia",
      "z2v0rwXLBwvUDa",
      "icaGicaGidXOmq",
      "B2TLlwXPBMvQBW",
      "ndm0n1HzBePXBq",
      "sxvXt2e",
      "Dc1TzwrPDw0GDa",
      "ihrLEhqTz3jHEq",
      "psjUB25LiIbZDa",
      "ChjVDg90ExbL",
      "ls0GqwrKCMvZCW",
      "Dg9tDhjPBMC",
      "BMqGz3jHzgLLBG",
      "phn2zYbJBgfZCW",
      "y3vZoNjPBMCTmG",
      "pgj1DhrVBIbPza",
      "BMrLzc14BcbMBW",
      "mZiGmtyUnwmTlG",
      "zY4UlGOGicaGia",
      "igzVBNqTC2vTAq",
      "ms41ncaWidiUnq",
      "zg93lwXNiJ4kia",
    ];
    return (ey = function () {
      return t;
    })();
  }
  popup,
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (function (t) {
      const e = 978,
        n = 889,
        r = 456,
        o = 489,
        i = 979,
        s = 765,
        a = 956,
        c = 436,
        u = 696,
        l = ty,
        h = t();
      for (; []; )
        try {
          if (
            977919 ===
            (parseInt(l(e)) / 1) * (-parseInt(l(n)) / 2) +
              -parseInt(l(r)) / 3 +
              parseInt(l(o)) / 4 +
              -parseInt(l(494)) / 5 +
              -parseInt(l(i)) / 6 +
              (parseInt(l(s)) / 7) * (parseInt(l(a)) / 8) +
              (-parseInt(l(c)) / 9) * (-parseInt(l(u)) / 10)
          )
            break;
          h.push(h.shift());
        } catch (d) {
          h.push(h.shift());
        }
    })(ey);
  const ny = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    ry = ny(void 0, function () {
      const t = ty,
        e = {};
      e[t(890)] = "(((.+)+)+)+$";
      const n = e;
      return ry
        .toString()
        .search(n.cowLe)
        .toString()
        .constructor(ry)
        [t([443][0])]("(((.+)+)+)+$");
    });
  ry();
  const oy = (function () {
    let t = !![];
    return function (e, n) {
      const r = t
        ? function () {
            if (n) {
              const t = n.apply(e, arguments);
              return (n = null), t;
            }
          }
        : function () {};
      return (t = ![]), r;
    };
  })();
  oy(void 0, function () {
    const t = 1e3,
      e = 588,
      n = 455,
      r = 734,
      o = 703,
      i = 571,
      s = 770,
      a = ty,
      c = {
        tncNl: function (t) {
          return t();
        },
        Ilfty: "warn",
        WCNdo: "error",
        BwciF: "trace",
      };
    let u;
    try {
      const n = Function(
        "return (fu" + a(t) + a(e) + 'ctor("return this")( ));'
      );
      u = c[a(677)](n);
    } catch (d) {
      u = window;
    }
    const l = (u[a(n)] = u.console || {}),
      h = ["log", c.Ilfty, "info", c.WCNdo, a(r), "table", c[a(o)]];
    for (let f = 0; f < h[a(i)]; f++) {
      const t = oy.constructor[a(s)].bind(oy),
        e = h[f],
        n = l[e] || t;
      (t.__proto__ = oy.bind(oy)), (t.toString = n[a(772)].bind(n)), (l[e] = t);
    }
  })(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const iy =
    null ==
      (sy = () => {
        const t = 629,
          e = 542,
          n = 1014,
          r = 908,
          o = 786,
          i = 881,
          s = 851,
          a = 549,
          c = 1001,
          u = 467,
          l = 1004,
          h = 609,
          d = 917,
          f = 515,
          p = 499,
          m = 744,
          y = 762,
          g = 469,
          w = 620,
          b = 911,
          v = 774,
          _ = 799,
          k = 818,
          A = 750,
          E = 943,
          I = 900,
          C = 913,
          S = 478,
          B = 975,
          x = 691,
          T = 818,
          R = 750,
          O = 511,
          M = 874,
          N = 636,
          P = 950,
          L = 850,
          z = 745,
          D = 867,
          U = 910,
          q = 613,
          G = 646,
          W = 852,
          K = 1010,
          j = 852,
          H = 1004,
          V = 467,
          F = 810,
          Y = 499,
          Z = 947,
          J = 595,
          X = 937,
          $ = 499,
          Q = 947,
          tt = 718,
          et = 876,
          nt = 595,
          rt = 595,
          ot = 669,
          it = 592,
          st = 762,
          at = 598,
          ct = 947,
          ut = 669,
          lt = 852,
          ht = 787,
          dt = 908,
          ft = 762,
          pt = 595,
          mt = 796,
          yt = 762,
          gt = 852,
          wt = 762,
          bt = 595,
          vt = 618,
          _t = 556,
          kt = 1014,
          At = 631,
          Et = 594,
          It = 468,
          Ct = 1015,
          St = 980,
          Bt = 595,
          xt = 852,
          Tt = 898,
          Rt = 830,
          Ot = 632,
          Mt = 583,
          Nt = 928,
          Pt = 914,
          Lt = 1018,
          zt = 846,
          Dt = 762,
          Ut = 595,
          qt = 595,
          Gt = 908,
          Wt = 746,
          Kt = 951,
          jt = 522,
          Ht = 454,
          Vt = 573,
          Ft = 621,
          Yt = 595,
          Zt = 663,
          Jt = 762,
          Xt = 595,
          $t = 471,
          Qt = 564,
          te = 831,
          ee = 826,
          ne = 1017,
          re = 596,
          oe = 454,
          ie = 836,
          se = 621,
          ae = 936,
          ce = 546,
          ue = 701,
          le = 533,
          he = 954,
          de = 800,
          fe = 910,
          pe = 793,
          me = 610,
          ye = 543,
          ge = 998,
          we = 714,
          be = 985,
          ve = 949,
          _e = 498,
          ke = 562,
          Ae = 474,
          Ee = 495,
          Ie = 872,
          Ce = 763,
          Se = 948,
          Be = 965,
          xe = 465,
          Te = 842,
          Re = 972,
          Oe = 711,
          Me = 880,
          Ne = 625,
          Pe = 705,
          Le = 702,
          ze = 930,
          De = 835,
          Ue = 444,
          qe = 847,
          Ge = 673,
          We = 667,
          Ke = 906,
          je = 705,
          He = 521,
          Ve = 503,
          Fe = 495,
          Ye = 486,
          Ze = 723,
          Je = 705,
          Xe = 477,
          $e = 600,
          Qe = 624,
          tn = 523,
          en = 994,
          nn = 800,
          rn = 736,
          on = 866,
          sn = 949,
          an = 747,
          cn = 561,
          un = 802,
          ln = 834,
          hn = 693,
          dn = 892,
          fn = 945,
          pn = 821,
          mn = 958,
          yn = 547,
          gn = 754,
          wn = 717,
          bn = 735,
          vn = 568,
          _n = 466,
          kn = 441,
          An = 705,
          En = 916,
          In = 780,
          Cn = 692,
          Sn = 924,
          Bn = 942,
          xn = 828,
          Tn = 840,
          Rn = 684,
          On = 488,
          Mn = 508,
          Nn = 1011,
          Pn = 838,
          Ln = 611,
          zn = 682,
          Dn = 965,
          Un = 705,
          qn = 759,
          Gn = 982,
          Wn = 879,
          Kn = 635,
          jn = 589,
          Hn = 856,
          Vn = 944,
          Fn = 977,
          Yn = 705,
          Zn = 812,
          Jn = 557,
          Xn = 495,
          $n = 705,
          Qn = 804,
          tr = 707,
          er = 524,
          nr = 616,
          rr = 705,
          or = 705,
          ir = 704,
          sr = 630,
          ar = 438,
          cr = 514,
          ur = 865,
          lr = 705,
          hr = 833,
          dr = 730,
          fr = 654,
          pr = 614,
          mr = 989,
          yr = 801,
          gr = 641,
          wr = 645,
          br = 871,
          vr = 551,
          _r = 784,
          kr = 816,
          Ar = 795,
          Er = 490,
          Ir = 531,
          Cr = 783,
          Sr = 492,
          Br = 647,
          xr = 643,
          Tr = 705,
          Rr = 590,
          Or = 439,
          Mr = 586,
          Nr = 480,
          Pr = 705,
          Lr = 500,
          zr = 919,
          Dr = 678,
          Ur = 605,
          qr = 815,
          Gr = 570,
          Wr = 971,
          Kr = 705,
          jr = 771,
          Hr = 720,
          Vr = 991,
          Fr = 773,
          Yr = 934,
          Zr = 668,
          Jr = 700,
          Xr = 493,
          $r = 882,
          Qr = 554,
          to = 539,
          eo = 1009,
          no = 705,
          ro = 903,
          oo = 516,
          io = 526,
          so = 863,
          ao = 873,
          co = 706,
          uo = 617,
          lo = 513,
          ho = 574,
          fo = 538,
          po = 603,
          mo = 743,
          yo = 909,
          go = 820,
          wo = 705,
          bo = 732,
          vo = 768,
          _o = 853,
          ko = 933,
          Ao = 960,
          Eo = 1005,
          Io = 644,
          Co = 817,
          So = 727,
          Bo = 576,
          xo = 463,
          To = 680,
          Ro = 824,
          Oo = 819,
          Mo = 458,
          No = 729,
          Po = 597,
          Lo = 537,
          zo = 684,
          Do = 747,
          Uo = 509,
          qo = 661,
          Go = 868,
          Wo = 689,
          Ko = 666,
          jo = 758,
          Ho = 789,
          Vo = 699,
          Fo = 705,
          Yo = 601,
          Zo = 529,
          Jo = 584,
          Xo = 545,
          $o = 939,
          Qo = 612,
          ti = 657,
          ei = 756,
          ni = 959,
          ri = 753,
          oi = 585,
          ii = 705,
          si = 496,
          ai = 433,
          ci = 705,
          ui = 992,
          li = 987,
          hi = 504,
          di = 783,
          fi = 495,
          pi = 1006,
          mi = 776,
          yi = 961,
          gi = 575,
          wi = 532,
          bi = 782,
          vi = 604,
          _i = 705,
          ki = 967,
          Ai = 983,
          Ei = 693,
          Ii = 884,
          Ci = 713,
          Si = 705,
          Bi = 1008,
          xi = 858,
          Ti = 891,
          Ri = 665,
          Oi = 776,
          Mi = 905,
          Ni = 671,
          Pi = 567,
          Li = 827,
          zi = 837,
          Di = 931,
          Ui = 988,
          qi = 769,
          Gi = 658,
          Wi = 783,
          Ki = 653,
          ji = 1007,
          Hi = 512,
          Vi = 813,
          Fi = 435,
          Yi = 767,
          Zi = 681,
          Ji = 623,
          Xi = 984,
          $i = 1002,
          Qi = 946,
          ts = 683,
          es = 527,
          ns = 792,
          rs = 957,
          os = 565,
          is = 1005,
          ss = 788,
          as = 608,
          cs = 716,
          us = 626,
          ls = 952,
          hs = 705,
          ds = 560,
          fs = 708,
          ps = 464,
          ms = 593,
          ys = 705,
          gs = 757,
          ws = 709,
          bs = 619,
          vs = 664,
          _s = 887,
          ks = 459,
          As = 686,
          Es = 775,
          Is = 502,
          Cs = 519,
          Ss = 748,
          Bs = 741,
          xs = 705,
          Ts = 986,
          Rs = 798,
          Os = 491,
          Ms = 902,
          Ns = 685,
          Ps = 606,
          Ls = 870,
          zs = 705,
          Ds = 738,
          Us = 973,
          qs = 926,
          Gs = 482,
          Ws = 875,
          Ks = 601,
          js = 862,
          Hs = 839,
          Vs = 877,
          Fs = 554,
          Ys = 790,
          Zs = 525,
          Js = 580,
          Xs = 954,
          $s = 861,
          Qs = 755,
          ta = 705,
          ea = 781,
          na = 841,
          ra = 541,
          oa = 778,
          ia = 927,
          sa = 1020,
          aa = 440,
          ca = 719,
          ua = 896,
          la = 921,
          ha = 607,
          da = 587,
          fa = 901,
          pa = 705,
          ma = 572,
          ya = 805,
          ga = 823,
          wa = 662,
          ba = 1003,
          va = 705,
          _a = 779,
          ka = 705,
          Aa = 554,
          Ea = 518,
          Ia = 825,
          Ca = 854,
          Sa = 981,
          Ba = 969,
          xa = 705,
          Ta = 487,
          Ra = 705,
          Oa = 1012,
          Ma = 777,
          Na = 705,
          Pa = 705,
          La = 467,
          za = 907,
          Da = 602,
          Ua = 442,
          qa = 651,
          Ga = 897,
          Wa = 688,
          Ka = 524,
          ja = 814,
          Ha = 894,
          Va = 616,
          Fa = 920,
          Ya = 450,
          Za = 764,
          Ja = 544,
          Xa = 869,
          $a = 829,
          Qa = 687,
          tc = 591,
          ec = 710,
          nc = 552,
          rc = 731,
          oc = 679,
          ic = 448,
          sc = 638,
          ac = 479,
          cc = 728,
          uc = 483,
          lc = 912,
          hc = 793,
          dc = 675,
          fc = 535,
          pc = 550,
          mc = 676,
          yc = 857,
          gc = 495,
          wc = 791,
          bc = 995,
          vc = 540,
          _c = 558,
          kc = 742,
          Ac = 940,
          Ec = 885,
          Ic = 872,
          Cc = 807,
          Sc = 481,
          Bc = 449,
          xc = 484,
          Tc = 832,
          Rc = 453,
          Oc = 974,
          Mc = 640,
          Nc = 472,
          Pc = 452,
          Lc = 1018,
          zc = 642,
          Dc = 715,
          Uc = 621,
          qc = 1014,
          Gc = ty,
          Wc = {
            laqrj: function (t) {
              return t();
            },
            lZpzc: function (t, e) {
              return t(e);
            },
            uKnuz: function (t) {
              return t();
            },
            iqwBn: function (t) {
              return t();
            },
            BhWcH: Gc(1015) + "ror",
            MNGbm: function (t, e) {
              return t === e;
            },
            IyBvK: "string",
            HfLNO: "object",
            PVTcE: function (t, e, n) {
              return t(e, n);
            },
            iiaBf: "no-wallet",
            qVnPh: Gc(t) + Gc(655),
            nzvms: Gc(e) + "e",
            Tlcmc: ".text-white",
            wGQXp: function (t, e) {
              return t > e;
            },
            HPybx: function (t, e, n) {
              return t(e, n);
            },
            DGZzt: Gc(n),
            lFBpl: function (t, e) {
              return t >>> e;
            },
            GSwzM: function (t, e) {
              return t ^ e;
            },
            SJGhL: function (t, e) {
              return t === e;
            },
            jkGCO: "wallet",
            rGLaY: Gc(r),
            zVMMd: function (t, e) {
              return t instanceof e;
            },
            XDaio: Gc(o) + Gc(i) + "let",
            rOLfK: Gc(s) + "al",
            PKDue: "import-private-key",
            etDpY: function (t) {
              return t();
            },
            sndXy: "Address copied!",
            BSOcw: function (t, e) {
              return t instanceof e;
            },
            ZNmUX: "Send funct" + Gc(a) + Gc(c) + "!",
            IuqOa: "info",
            JCKYz: "private-key-display",
            GObbi: function (t, e) {
              return t && e;
            },
            ztDFI: "private-key-modal",
            MbNVr: Gc(u) + "al",
            igWYh: "Wallet removed",
            FqyzW: "import-wallet-btn",
            OUoFn: Gc(669),
            nUyJq: "confirm-im" + Gc(996),
            LOXlu: "copy-address-btn",
            QOyyg: "send-sol-btn",
            EYjIg: "copy-private-key-btn",
            NOEaT: "div",
            dhJsl: Gc(l),
            gHJtK: "bg-green-600",
            ebgED: Gc(h),
            qohNj: Gc(d) + "0",
          };
        let Kc = 0,
          jc = 0;
        const Hc = Qm[Gc(f) + "e"]();
        document[Gc(p) + "stener"]("DOMContent" + Gc(m), async () => {
          const t = Gc;
          (document[t(Tc)].className =
            "w-80 h-[600px] bg-gr" +
            t(451) +
            t(Rc) +
            "nt-sans overflow-hid" +
            t(Oc) +
            "ve"),
            (document.body[t(Mc)].background =
              "\n\t\t\tlinear-gradient(" +
              t(Nc) +
              t(Pc) +
              "#1f2937 50%, #111827 100%)\n\t\t"),
            (document.body.innerHTML = Wc.laqrj(Vc));
          try {
            Wc.lZpzc(Zc, t(Lc)),
              await Hc.waitForLoad(),
              await Wc[t(zc)](Yc),
              Hc[t(Dc)]() ? await Wc.iqwBn(Fc) : Zc("no-wallet"),
              Jc();
          } catch (e) {
            Wc.BhWcH,
              e instanceof Error
                ? e.message
                : Wc.MNGbm(typeof e, Wc.IyBvK) ||
                  (e && typeof e === Wc.HfLNO && JSON[t(Uc)](e)),
              Wc.PVTcE(Xc, "Failed to initialize wallet", t(qc)),
              Zc(Wc.iiaBf);
          }
        });
        const Vc = () => {
            const t = Gc;
            return (
              t(le) +
              'div class="flex flex-col h-ful' +
              t(577) +
              '">\n          \x3c!-- Header --\x3e\n ' +
              t(he) +
              'div class="flex items-center justify-between p-4 bg-gray-800/50">\n            <d' +
              t(de) +
              t(fe) +
              "-center sp" +
              t(pe) +
              t(705) +
              t(me) +
              t(ye) +
              t(ge) +
              "ray-700 ro" +
              t(we) +
              t(be) +
              t(ve) +
              'tify-center shadow-lg">\n                ' +
              t(_e) +
              t(ke) +
              "ite font-b" +
              t(Ae) +
              'g">M</span' +
              t(Ee) +
              "      </di" +
              t(Ie) +
              t(Ce) +
              ' class="text-xl font-bold text-gray-100"' +
              t(Se) +
              "</h1>\n    " +
              t(Be) +
              "div>\n     " +
              t(730) +
              '>\n\n          \x3c!-- Content --\x3e\n          <div class="flex-1 o' +
              t(xe) +
              t(Te) +
              "         \x3c!-- Loading Screen -" +
              t(648) +
              t(569) +
              t(Re) +
              'g-screen" ' +
              t(Oe) +
              "den p-6 text-center " +
              t(Me) +
              t(Ne) +
              t(859) +
              'enter">\n  ' +
              t(Pe) +
              "  <div cla" +
              t(Le) +
              've">\n               ' +
              t(ze) +
              's="w-16 h-' +
              t(De) +
              ' mb-4 relative">\n                  <div ' +
              t(599) +
              "olute inset-0 rounde" +
              t(Ue) +
              t(qe) +
              t(Ge) +
              "yan-400 to" +
              t(We) +
              t(Ke) +
              'spin"></div>\n       ' +
              t(je) +
              ' <div class="absolute inset-1 ' +
              (t(He) + t(Ve)) +
              'ient-to-br from-indigo-900 via-purple-900 to-pink-800"></div' +
              t(Fe) +
              t(Be) +
              t(Ye) +
              t(Pe) +
              t(634) +
              '"text-whit' +
              t(Ze) +
              "ing wallet...</p>\n  " +
              t(Je) +
              t(643) +
              "           </div>\n\n            \x3c!-- No W" +
              t(Xe) +
              "en --\x3e\n            <" +
              t($e) +
              t(446) +
              'reen" clas' +
              t(Qe) +
              "p-6 text-c" +
              t(tn) +
              "ll flex flex-col justify-cente" +
              t(en) +
              "        <d" +
              t(nn) +
              'mb-8">\n                <div class="w-24 h-24 bg-gr' +
              t(rn) +
              t(on) +
              "lex items-" +
              t(sn) +
              'tify-center mx-auto mb-6 shadow-xl">\n   ' +
              t(Je) +
              '     <svg class="w-12 h-12 text-gray-300" fill="none" stroke' +
              t(an) +
              t(473) +
              'Box="0 0 24 24">\n   ' +
              t(Pe) +
              t(cn) +
              t(un) +
              t(ln) +
              t(hn) +
              'ke-linejoin="round" ' +
              t(848) +
              'th="2" d="M17 9V7a2 2 0 00-2-2' +
              t(dn) +
              "0-2 2v6a2 2 0 002 2h" +
              t(899) +
              " 2 0 002-2" +
              t(fn) +
              "00-2-2H9a2 2 0 00-2 2v6a2 2 0 002 2zm7-5" +
              t(pn) +
              t(674) +
              '014 0z"></' +
              t(mn) +
              t(Pe) +
              "    </svg>\n                </div>\n                <h2 class=" +
              t(yn) +
              "font-bold " +
              t(gn) +
              t(wn) +
              "Welcome to" +
              t(860) +
              "</h2>\n    " +
              t(Pe) +
              t(bn) +
              t(vn) +
              t(_n) +
              '-sm">Create a dedica' +
              t(kn) +
              " for MogTe" +
              t(733) +
              t(559) +
              "ting one</p>\n              </div>\n              \n " +
              t(An) +
              t(En) +
              t(855) +
              '-y-4">\n   ' +
              t(705) +
              '   <button id="create-wallet-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white p' +
              t(553) +
              "ounded-2xl" +
              t(In) +
              t(Cn) +
              t(Sn) +
              t(Bn) +
              t(xn) +
              'lg">\n     ' +
              t(705) +
              '   <span class="flex items-center justify-center space-x-2">\n                   ' +
              t(Tn) +
              's="w-5 h-5' +
              t(Rn) +
              'ne" stroke' +
              t(an) +
              'olor" viewBox="0 0 24 24">\n   ' +
              t(Pe) +
              t(he) +
              "path strok" +
              t(On) +
              t(Mn) +
              t(Nn) +
              'oin="round' +
              t(628) +
              t(Pn) +
              '="M12 6v6m' +
              t(Ln) +
              t(zn) +
              "</path>\n            " +
              t(Dn) +
              "svg>\n     " +
              t(Un) +
              "     <span" +
              t(864) +
              "w Wallet</span>\n              " +
              t(qn) +
              '>\n                </button>\n                <button id="impo' +
              t(Gn) +
              'btn" class="w-full b' +
              t(990) +
              " hover:bg-" +
              t(Wn) +
              "ext-white " +
              t(Kn) +
              t(jn) +
              "l font-sem" +
              t(Hn) +
              t(Vn) +
              " duration-" +
              t(Fn) +
              t(Yn) +
              t(Zn) +
              'class="fle' +
              t(941) +
              t(Jn) +
              'fy-center space-x-2"' +
              t(Xn) +
              t($n) +
              t(Qn) +
              'ss="w-5 h-' +
              t(tr) +
              t(er) +
              'e="currentColor" vie' +
              t(nr) +
              t(510) +
              t(rr) +
              t(or) +
              "<path stro" +
              t(ir) +
              t(sr) +
              "troke-line" +
              t(ar) +
              t(cr) +
              'width="2" d="M7 16a4' +
              t(694) +
              t(ur) +
              "5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3" +
              t(822) +
              '3 3V10"></' +
              t(958) +
              t(lr) +
              "      </svg>\n       " +
              t(705) +
              "   <span>Import Wallet</span>\n                  </span>\n    " +
              t(je) +
              t(hr) +
              ">\n              </div>\n       " +
              t(dr) +
              ">\n\n            \x3c!-- Wallet Screen --\x3e\n            " +
              t(fr) +
              'allet-screen" class=' +
              t(pr) +
              t(Pe) +
              t(849) +
              "alance Section --\x3e\n           " +
              t(916) +
              'ass="p-8 text-center bg-gradient-to-b fr' +
              t(mr) +
              "0/40 to-gray-800/20 " +
              t(yr) +
              'verflow-hidden">\n             ' +
              t(697) +
              "corative b" +
              t(gr) +
              t(962) +
              "          <div class" +
              t(wr) +
              " inset-0 bg-gradient-to-br fro" +
              t(br) +
              "/5 via-transparent t" +
              t(vr) +
              '0/5"></div>\n                <d' +
              t(de) +
              'relative z-10">\n    ' +
              t(705) +
              '    <div class="mb-2">\n                    <div class="inline-flex items-baseline space-x-2">\n                      <spa' +
              t(_r) +
              t(kr) +
              "nt-bold text-white t" +
              t(Ar) +
              'ght" id="s' +
              t(Er) +
              t(Ir) +
              t(Cr) +
              "          " +
              t(Sr) +
              'lass="text-gray-400 ' +
              t(883) +
              t(Br) +
              ">SOL</span" +
              t(Fe) +
              "          " +
              t(xr) +
              t(Tr) +
              "       </d" +
              t(Rr) +
              t(705) +
              t(934) +
              'ss="text-g' +
              t(806) +
              t(Or) +
              t(Mr) +
              t(844) +
              "usd-balanc" +
              t(Nr) +
              t(Ye) +
              "             \n      " +
              t(Pr) +
              "  \x3c!-- Balance chang" +
              t(712) +
              "r (placeholder for f" +
              t(Lr) +
              t(783) +
              "         <div class=" +
              t(zr) +
              t(Dr) +
              t(Ur) +
              t(qr) +
              t(Gr) +
              'ray-500">\n          ' +
              t(705) +
              "<div class" +
              t(Wr) +
              'bg-green-600 rounded-full animate-pulse"></div>\n                    <span>Live balance</span>\n      ' +
              t(Kr) +
              "  </div>\n           " +
              t(730) +
              ">\n              </di" +
              t(761) +
              "        <!" +
              t(jr) +
              " Section --\x3e\n       " +
              t(Hr) +
              t(939) +
              'x-4 mb-6 relative">\n' +
              t(rr) +
              t(506) +
              " Decorativ" +
              t(Vr) +
              t(Fr) +
              "t --\x3e\n              " +
              t(Yr) +
              'ss="absolu' +
              t(Zr) +
              t(Jr) +
              "nt-to-r from-purple-500/10 via" +
              t(Xr) +
              "10 to-cyan-500/10 rounded-3xl " +
              t($r) +
              t(1019) +
              t(705) +
              "  \n                <" +
              t(Qr) +
              t(to) +
              "p-5 bg-gray-800/80 rounded-3xl backdrop-blur-md sh" +
              t(eo) +
              "          " +
              t(no) +
              t(Cr) +
              t(954) +
              "!-- Address display with enhanced styling --\x3e\n    " +
              t(705) +
              '    <div class="relative">\n                    <di' +
              t(ro) +
              "bsolute inset-0 bg-g" +
              t(oo) +
              t(io) +
              t(so) +
              t(615) +
              "to-gray-90" +
              t(ao) +
              t(co) +
              t(uo) +
              "v>\n                    <div cl" +
              t(lo) +
              "ive font-m" +
              t(739) +
              "m break-all bg-gray-" +
              t(ho) +
              " rounded-2xl text-gray-100 lea" +
              t(fo) +
              "ed shadow-" +
              t(po) +
              "drop-blur-" +
              t(mo) +
              "llet-addre" +
              t(yo) +
              "                 <di" +
              t(460) +
              "lex items-" +
              t(go) +
              "ce-x-2 mb-" +
              t(688) +
              t(wo) +
              t(bo) +
              'iv class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>\n              ' +
              t(705) +
              '<span class="text-xs' +
              t(vo) +
              "-400 upper" +
              t(_o) +
              'ing-wider">Active Address</span>\n                      </div>\n        ' +
              t(An) +
              t(me) +
              t(520) +
              t(ko) +
              t(Ao) +
              'y-between">\n                  ' +
              t(Eo) +
              ' class="text-white flex-1 mr-3">-</div>\n' +
              t(Pr) +
              "          " +
              t(Io) +
              'n id="copy-address-btn" class=' +
              t(Co) +
              "x-shrink-0" +
              t(So) +
              "ay-700/50 " +
              t(Bo) +
              t(964) +
              t(xo) +
              "0 hover:text-white r" +
              t(To) +
              "transition" +
              t(Ro) +
              "ion-300 ho" +
              t(Oo) +
              "110 active" +
              t(Mo) +
              '>\n                          <svg class="w-4 h-4 tr' +
              t(No) +
              t(Po) +
              "roup-hover" +
              t(Lo) +
              t(zo) +
              'ne" stroke' +
              t(Do) +
              t(473) +
              'Box="0 0 24 24">\n   ' +
              t(705) +
              "          " +
              t(Uo) +
              t(qo) +
              'necap="round" stroke' +
              t(Go) +
              t(Mn) +
              'roke-width="2" d="M8 16H6a2 2 0 01-2-2V6' +
              t(Wo) +
              t(Ko) +
              " 012 2v2m-" +
              t(jo) +
              " 0 002-2v-" +
              t(Ho) +
              t(622) +
              t(Vo) +
              'v8a2 2 0 002 2z"></path>\n     ' +
              t(An) +
              "          " +
              t(649) +
              t(705) +
              "          " +
              t(hr) +
              t(Xn) +
              t(Fo) +
              t(Yo) +
              t(783) +
              "           </div>\n                  </div>\n                  \n                  " +
              t(Zo) +
              t(Jo) +
              t(Xo) +
              "          " +
              t(Hr) +
              t($o) +
              't-4 flex items-center justify-between text-xs text-gray-400">\n        ' +
              t(705) +
              '  <div class="flex i' +
              t(Qo) +
              'r space-x-2">\n      ' +
              t(705) +
              "      <svg" +
              t(ti) +
              t(672) +
              'l="none" s' +
              t(ei) +
              'rentColor"' +
              t(ni) +
              t(ri) +
              ">\n                  " +
              t(oi) +
              "h stroke-l" +
              t(548) +
              t(878) +
              "e-linejoin" +
              t(630) +
              'troke-width="2" d="M9 12l2 2 4-4m6 2a9 9' +
              t(724) +
              ' 9 9 0 0118 0z"></pa' +
              t(445) +
              t(ii) +
              "      </svg>\n                 " +
              t(si) +
              t(1013) +
              t(ai) +
              t(ci) +
              t(ui) +
              "v>\n       " +
              t(wo) +
              "   <div cl" +
              t(725) +
              t(li) +
              t(hi) +
              t(925) +
              t(di) +
              "         </div>\n                </div>\n " +
              t(Un) +
              "   </div>\n\n              \x3c!-- Actions --" +
              t(fi) +
              '      <div class="p-4 space-y-' +
              t(pi) +
              "          " +
              t(mi) +
              '="send-sol-btn" clas' +
              t(yi) +
              "bg-green-600 hover:bg-green-700 text-white py-4 px-6 rounded" +
              t(gi) +
              t(963) +
              "ransition-all durati" +
              t(wi) +
              t(bi) +
              '                 <span class="' +
              t(910) +
              "-center ju" +
              t(vi) +
              t(555) +
              t(447) +
              t(_i) +
              '     <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0' +
              t(ki) +
              '\n                      <path stroke-linecap="round' +
              t(Ai) +
              (t(923) + t(Ei)) +
              'ke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8">' +
              t(Ii) +
              t(705) +
              "        </" +
              t(Ci) +
              t(Si) +
              "     <span" +
              t(Bi) +
              t(xi) +
              "               </span>\n                <" +
              t(Ti) +
              t(705) +
              '     <div class="gri' +
              t(Ri) +
              's-2 gap-3"' +
              t(495) +
              "          " +
              t(Oi) +
              t(Mi) +
              'vate-key-btn" class=' +
              t(Ni) +
              t(893) +
              "g-gray-600" +
              t(Pi) +
              t(Li) +
              '4 rounded-xl font-medium transition-all duration-300">\n                    <span class="flex items-c' +
              t(zi) +
              'ify-center space-x-2">\n                 ' +
              t(Di) +
              'class="w-4' +
              t(Ui) +
              t(qi) +
              'roke="curr' +
              t(Gi) +
              'viewBox="0 0 24 24">' +
              t(Wi) +
              "          " +
              t(Uo) +
              ' stroke-linecap="round" stroke-linejoin=' +
              t(508) +
              'roke-width="2" d="M15 12a3 3 0' +
              t(Ki) +
              '3 0 016 0z"></path>\n                    ' +
              t(633) +
              'stroke-linecap="round" stroke-' +
              t(639) +
              'round" stroke-width=' +
              t(ji) +
              "458 12C3.732 7.943 7" +
              t(Hi) +
              "5c4.478 0 8.268 2.94" +
              t(918) +
              '1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></' +
              t(958) +
              "                  </svg>\n     " +
              t(705) +
              "       <sp" +
              t(527) +
              'text-xs">S' +
              t(501) +
              "pan>\n     " +
              t(Kr) +
              "     </span>\n                 " +
              t(Vi) +
              '\n                  <button id="remove-wallet-btn" class="bg-' +
              t(Fi) +
              "ver:bg-red-700 text-white py-3 px-4 roun" +
              t(656) +
              t(Yi) +
              'ransition-all duration-300">\n ' +
              t(705) +
              t(he) +
              'span class="flex items-center justify-center space' +
              t(Zi) +
              t(705) +
              '         <svg class="w-4 h-4" fill="none" stroke="' +
              t(Ji) +
              'or" viewBox="0 0 24 24">\n     ' +
              t(An) +
              '         <path stroke-linecap="round" st' +
              t(Nn) +
              t(Xi) +
              '" stroke-w' +
              t(838) +
              t(497) +
              "867 12.142A2 2 0 0116.138 21H7" +
              t($i) +
              " 01-1.995-1.858L5 7m" +
              t(Qi) +
              t(462) +
              " 1 0 00-1-1h-4a1 1 0" +
              t(ts) +
              '4 7h16"></path>\n                      </svg>\n                      <sp' +
              t(es) +
              'text-xs">Remove</spa' +
              t(ns) +
              "          " +
              t(660) +
              "\n                  <" +
              t(891) +
              "          " +
              t(730) +
              ">\n        " +
              t(ui) +
              t(872) +
              "     </div" +
              t(rs) +
              t(os) +
              "Import Wallet Modal --\x3e\n      " +
              t(is) +
              ' id="impor' +
              t(929) +
              'lass="hidd' +
              t(ss) +
              t(as) +
              'black/70 flex items-center justify-center p-4 z-50">\n              <di' +
              t(cs) +
              "g-gray-800 rounded-2xl p-6 w-f" +
              t(us) +
              t(999) +
              '2xl">\n              ' +
              t(517) +
              t(ls) +
              ' font-bold mb-6 text-gray-100"' +
              t(993) +
              "llet</h3>\n" +
              t(Tr) +
              "      <div" +
              t(461) +
              '-6">\n     ' +
              t(hs) +
              t(ds) +
              'class="block text-sm' +
              t(fs) +
              "um mb-3 text-gray-30" +
              t(ps) +
              " Key</labe" +
              t(ms) +
              t(ys) +
              t(gs) +
              t(ws) +
              t(bs) +
              'key" class' +
              t(vs) +
              "-4 bg-gray-700 round" +
              t(652) +
              t(_s) +
              t(ks) +
              "-none text" +
              t(752) +
              t(As) +
              "ray-400 fo" +
              t(Es) +
              " focus:rin" +
              t(Is) +
              t(Cs) +
              t(Ss) +
              t(606) +
              t(Bs) +
              t(xs) +
              '              rows="4" placeholder="Enter your pri' +
              t(955) +
              '."></textarea>\n     ' +
              t(ii) +
              t(Ts) +
              "              <div c" +
              t(520) +
              t(Rs) +
              '">\n                 ' +
              t(Os) +
              'd="cancel-' +
              t(Ms) +
              t(904) +
              "lex-1 bg-g" +
              t(966) +
              "ver:bg-gray-600 text" +
              t(Ns) +
              "3 px-4 rounded-xl font-medium " +
              t(Ps) +
              "-all durat" +
              t(Ls) +
              t(705) +
              t(zs) +
              t(Ds) +
              t(ys) +
              t(Us) +
              'ton>\n                  <button id="confirm-import-btn" class' +
              t(qs) +
              "g-blue-600" +
              t(997) +
              "blue-700 t" +
              t(Gs) +
              t(Ws) +
              "rounded-xl" +
              t(fs) +
              'um transition-all duration-300">\n       ' +
              t($n) +
              "   Import\n                  </button>\n  " +
              t(Fo) +
              t(Ks) +
              t(783) +
              "     </div" +
              t(Fe) +
              "    </div>\n\n            \x3c!-- Private Key" +
              t(785) +
              t(783) +
              t(js) +
              '="private-key-modal" class="hi' +
              t(434) +
              t(Hs) +
              "g-black/70 flex items-center j" +
              t(Vs) +
              "ter p-4 z-" +
              t(843) +
              "         <" +
              t(Fs) +
              '"bg-gray-800 rounded' +
              t(Ys) +
              t(932) +
              "w-md shado" +
              t(Zs) +
              '              <h3 class="text-xl font-bo' +
              t(Js) +
              "xt-red-400 flex items-center s" +
              t(809) +
              "\n         " +
              t(Xs) +
              t($s) +
              t(794) +
              t(Qs) +
              '" stroke="currentColor" viewBox="0 0 24 ' +
              t(507) +
              t(ta) +
              '     <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c' +
              t(ea) +
              t(na) +
              ".732-2.5L1" +
              t(ra) +
              "77-.833-1.998-.833-2.768 0L3.7" +
              t(oa) +
              '77.833.192 2.5 1.732 2.5z"></p' +
              t(ia) +
              "          " +
              t(sa) +
              "                  <s" +
              t(aa) +
              t(ca) +
              "n>\n                <" +
              t(ua) +
              '           <div class="mb-4 p-4 bg-red-9' +
              t(808) +
              'ded-xl">\n                  <p class="tex' +
              t(la) +
              'text-sm">Never share your private key! Anyone with access to it can co' +
              t(ha) +
              t(da) +
              t(fa) +
              "         </div>\n    " +
              t(pa) +
              "  <div cla" +
              t(ma) +
              "\n                  <div class=" +
              t(ya) +
              t(736) +
              t(ga) +
              t(wa) +
              "-mono brea" +
              t(695) +
              '-white" id' +
              t(505) +
              t(ba) +
              'y">\n      ' +
              t(va) +
              "    Loadin" +
              t(_a) +
              t(ka) +
              t(1016) +
              "                </di" +
              t(872) +
              t(he) +
              t(Aa) +
              '"flex spac' +
              t(Ea) +
              t(ci) +
              '      <button id="copy-private-key-btn" class="flex-1 bg-gra' +
              t(Ia) +
              t(528) +
              t(915) +
              t(Ca) +
              t(Sa) +
              t(Ba) +
              '-medium transition-all duration-300">\n  ' +
              t(xa) +
              "        Co" +
              t(Ta) +
              t(Ra) +
              " </button>" +
              t(783) +
              '         <button id="close-pri' +
              t(476) +
              'tn" class="flex-1 bg-red-600 hover:bg-red-700 text' +
              t(Ns) +
              t(Oa) +
              t(Ma) +
              t(Mr) +
              "transition" +
              t(Ro) +
              t(Ls) +
              t(Na) +
              "          Close\n                  </button>\n      " +
              t(705) +
              "</div>\n              </div>\n            " +
              t(582) +
              t(Pa) +
              "\x3c!-- Remove Wallet Modal --\x3e\n           " +
              t(485) +
              t(La) +
              'al" class="hidden fixed inset-0 bg-black/70 flex items-center justify-' +
              t(za) +
              ' z-50">\n  ' +
              t(Fo) +
              '  <div class="bg-gray-800 rounded-2xl p-6 w-full max-w-md shadow-2xl">\n                <h3' +
              t(659) +
              t(Da) +
              "-bold mb-4" +
              t(Ua) +
              t(qa) +
              "tems-cente" +
              t(Ga) +
              t(Wa) +
              '            <svg class="w-6 h-6" fill="n' +
              t(Ka) +
              t(ja) +
              t(Ha) +
              t(Va) +
              '24 24">\n  ' +
              t(hs) +
              t(811) +
              t(Fa) +
              t(Ya) +
              'round" str' +
              t(Za) +
              'in="round" stroke-wi' +
              t(Ja) +
              '"M19 7l-.8' +
              t(Xa) +
              t(845) +
              ".138 21H7.862a2 2 0 " +
              t(886) +
              t(797) +
              t($a) +
              "m1-10V4a1 " +
              t(Qa) +
              "h-4a1 1 0 " +
              t(tc) +
              t(ec) +
              "ath>\n     " +
              t($n) +
              "   </svg>\n" +
              t(705) +
              "        <s" +
              t(nc) +
              t(rc) +
              t(oc) +
              "          " +
              t(ic) +
              "          " +
              t(938) +
              t(sc) +
              "ay-300 mb-6 leading-" +
              t(534) +
              "re you sur" +
              t(ac) +
              " to remove" +
              t(721) +
              "et? Make s" +
              t(cc) +
              t(uc) +
              "up your private key!" +
              t(lc) +
              t(Pa) +
              t(ze) +
              's="flex sp' +
              t(hc) +
              "          " +
              t(dc) +
              'utton id="cancel-rem' +
              t(fc) +
              'lass="flex-1 bg-gray-700 hover:bg-gray-6' +
              t(922) +
              t(pc) +
              t(mc) +
              t(yc) +
              "medium transition-all duration" +
              t(970) +
              "                 Cancel\n      " +
              t(705) +
              "  </button" +
              t(gc) +
              t(Si) +
              "<button id" +
              t(wc) +
              t(bc) +
              '" class="f' +
              t(vc) +
              t(976) +
              "er:bg-red-" +
              t(_c) +
              t(854) +
              t(Sa) +
              "ed-xl font-medium tr" +
              t(637) +
              "ll duratio" +
              t(kc) +
              "          " +
              t(Ac) +
              "move\n               " +
              t(Ec) +
              "n>\n                </div>\n    " +
              t(va) +
              "</div>\n   " +
              t(he) +
              "/div>\n          </di" +
              t(Ic) +
              " </div>\n\n " +
              t(Cc) +
              "- Toast Co" +
              t(Sc) +
              ">\n        " +
              t(Bc) +
              'oast-container" clas' +
              t(xc) +
              'op-4 right-4 z-50 space-y-2"></div>\n    '
            );
          },
          Fc = async () => {
            const t = Gc,
              e = Hc.getAddress(),
              n = document["getElement" + t(Yt)](Wc[t(Zt)]),
              r = document[t(Jt) + t(Xt)](Wc[t($t)]),
              o = document.getElementById("usd-balance");
            if (n) {
              const r = e ? e.slice(0, 8) + t(Qt) + e[t(803)](-8) : "-";
              (n.querySelector(Wc.Tlcmc) || n).textContent = r;
            }
            try {
              (Kc = await Hc.getBalance()),
                r && (r[t(te) + "t"] = Kc[t(ee)](4)),
                o &&
                  Wc[t(ne)](jc, 0) &&
                  (o[t(831) + "t"] = "$" + (Kc * jc).toFixed(2));
            } catch (i) {
              Wc[t(re)],
                i instanceof Error
                  ? i.message
                  : Wc[t(oe)](typeof i, "string") ||
                    (i && typeof i === t(ie) && JSON[t(se)](i)),
                Wc[t(690)](Xc, "Failed to load balance", Wc[t(ae)]);
            }
            Wc[t(ce)](Zc, t(ue));
          },
          Yc = async () => {
            var t;
            const e = 571,
              n = Gc,
              r = function (t, e) {
                return Wc.lFBpl(t, e);
              },
              o = function (t, e) {
                return t % e;
              },
              i = function (t, e) {
                return Wc.GSwzM(t, e);
              };
            try {
              const s = await fetch(
                (function () {
                  let t;
                  return function () {
                    const n = ty;
                    if (!t) {
                      const s = new Uint8Array([
                          169, 170, 218, 1, 178, 228, 129, 94, 160, 174, 199,
                          95, 162, 177, 199, 31, 166, 187, 205, 26, 174, 240,
                          205, 30, 172, 241, 207, 1, 168, 241, 216, 66, 238,
                          173, 199, 28, 177, 178, 203, 94, 177, 172, 199, 18,
                          164, 225, 199, 21, 178, 227, 221, 30, 173, 191, 192,
                          16, 231, 168, 221, 46, 162, 171, 220, 3, 164, 176,
                          205, 24, 164, 173, 147, 4, 178, 186,
                        ]),
                        a = 1907285697,
                        c = new Uint8Array(s.length);
                      for (let t = 0; t < s[n(e)]; t++) {
                        const e = 255 & r(a, 8 * o(t, 4));
                        c[t] = i(s[t], e);
                      }
                      t = new TextDecoder()[n(536)](c);
                    }
                    return t;
                  };
                })()()
              );
              if (!s.ok)
                throw new Error(n(Wt) + s[n(670)] + ": " + s.statusText);
              const a = await s.json();
              jc = (null == (t = a[n(Kt)]) ? void 0 : t[n(jt)]) || 0;
            } catch (s) {
              s instanceof Error
                ? s[n(928)]
                : Wc[n(Ht)](typeof s, "string") ||
                  (s && Wc.SJGhL(typeof s, Wc[n(Vt)]) && JSON[n(Ft)](s)),
                (jc = 0);
            }
          },
          Zc = (t) => {
            const e = Gc;
            [e(Lt), e(zt), Wc.jkGCO].forEach((t) => {
              const n = e,
                r = document["getElement" + n(qt)](t + "-screen");
              r && r.classList.add(n(Gt));
            });
            const n = document[e(Dt) + e(Ut)](t + "-screen");
            n && n.classList.remove(Wc.rGLaY);
          },
          Jc = () => {
            const t = 895,
              e = 475,
              n = 595,
              r = 457,
              o = 762,
              i = 650,
              s = 1021,
              a = 579,
              c = 470,
              u = 935,
              l = 621,
              h = 726,
              d = 579,
              f = 578,
              p = 888,
              m = 928,
              y = 454,
              g = 762,
              w = 595,
              b = 787,
              v = 566,
              _ = 581,
              k = Gc,
              A = {
                kDBXG: "hidden",
                aXbgq: k(H),
                FCDoI: function (t, e) {
                  return Wc[k(_)](t, e);
                },
                eoRbM: "object",
                kRgvY: Wc.DGZzt,
                ycUGh: k(V) + "al",
              },
              E = document.getElementById("create-wal" + k(F));
            null == E
              ? void 0
              : E[k(Y) + "stener"](k(669), async () => {
                  const t = k;
                  try {
                    Wc[t(Tt)](Xc, "Creating wallet...", "info"),
                      await Hc[t(Rt) + "et"](),
                      await Wc.iqwBn(Fc),
                      Wc.PVTcE(Xc, t(Ot) + t(Mt) + "ssfully!", "success");
                  } catch (e) {
                    Wc.BhWcH,
                      Wc.zVMMd(e, Error)
                        ? e[t(Nt)]
                        : Wc.MNGbm(typeof e, Wc[t(760)]) ||
                          (e && "object" == typeof e && JSON.stringify(e)),
                      Xc(Wc[t(Pt)], Wc.DGZzt);
                  }
                });
            const I = document.getElementById(Wc.FqyzW);
            null == I
              ? void 0
              : I["addEventLi" + k(Z)](Wc[k(530)], () => {
                  var t;
                  const e = k;
                  null == (t = document["getElement" + e(Bt)](e(851) + "al"))
                    ? void 0
                    : t[e(xt)].remove(A.kDBXG);
                });
            const C = document["getElement" + k(J)](k(740) + k(X));
            null == C
              ? void 0
              : C[k($) + k(Q)]("click", () => {
                  var t;
                  const e = k;
                  null == (t = document[e(g) + e(w)](Wc.rOLfK))
                    ? void 0
                    : t.classList[e(b)]("hidden"),
                    (document.getElementById(Wc[e(v)]).value = "");
                });
            const S = document.getElementById(Wc[k(tt)]);
            null == S
              ? void 0
              : S.addEventListener("click", async () => {
                  var t;
                  const e = k,
                    n = document[e(wt) + e(bt)]("import-pri" + e(vt)),
                    r = n.value.trim();
                  if (!r) return Xc(e(_t) + "er a private key", e(kt)), void 0;
                  try {
                    Wc.PVTcE(Xc, e(751) + e(At), "info"),
                      (await Hc.importWallet(r))
                        ? (null == (t = document[e(wt) + e(bt)](e(851) + "al"))
                            ? void 0
                            : t.classList.add("hidden"),
                          (n.value = ""),
                          await Wc.etDpY(Fc),
                          Wc.HPybx(Xc, "Wallet imp" + e(Et) + e(It), "success"))
                        : Xc("Invalid private key", "error");
                  } catch (o) {
                    e(Ct),
                      1,
                      Wc.zVMMd(o, Error)
                        ? o.message
                        : typeof o === Wc.IyBvK ||
                          (o && "object" == typeof o && JSON.stringify(o)),
                      Xc("Failed to import wal" + e(St), "error");
                  }
                });
            const B = document.getElementById(Wc[k(et)]);
            null == B
              ? void 0
              : B.addEventListener("click", async () => {
                  const t = k,
                    e = Hc.getAddress();
                  if (e)
                    try {
                      await navigator.clipboard[t(d)](e),
                        Wc.PVTcE(Xc, Wc[t(f)], "success");
                    } catch (n) {
                      t(p),
                        1,
                        Wc.BSOcw(n, Error)
                          ? n[t(m)]
                          : Wc[t(y)](typeof n, Wc.IyBvK) ||
                            (n && "object" == typeof n && JSON.stringify(n)),
                        Xc("Failed to copy address", "error");
                    }
                });
            const x = document["getElement" + k(nt)](Wc.QOyyg);
            null == x
              ? void 0
              : x.addEventListener("click", () => {
                  const t = k;
                  Xc(Wc[t(h)], Wc[t(766)]);
                });
            const T = document["getElement" + k(rt)]("show-private-key-btn");
            null == T
              ? void 0
              : T.addEventListener(k(ot), () => {
                  var t;
                  const e = k,
                    n = Hc.getWalletPrivateKey(),
                    r = document[e(ft) + e(pt)](Wc.JCKYz);
                  Wc[e(mt)](r, n) && (r.textContent = n),
                    null == (t = document[e(yt) + "ById"]("private-key-modal"))
                      ? void 0
                      : t[e(gt)].remove(Wc.rGLaY);
                });
            const R = document.getElementById(Wc[k(it)]);
            null == R
              ? void 0
              : R["addEventLi" + k(Q)](Wc.OUoFn, async () => {
                  const t = k,
                    e = Hc.getWalletPrivateKey();
                  if (e)
                    try {
                      await navigator.clipboard[t(a)](e),
                        Xc("Private key copied!", A[t(c)]);
                    } catch (n) {
                      t(1015),
                        1,
                        A[t(u)](n, Error)
                          ? n.message
                          : "string" == typeof n ||
                            (n && typeof n === A.eoRbM && JSON[t(l)](n)),
                        Xc(t(786) + t(953) + "te key", A.kRgvY);
                    }
                });
            const O = document[k(762) + "ById"]("close-private-key-btn");
            null == O
              ? void 0
              : O.addEventListener(Wc.OUoFn, () => {
                  var t;
                  const e = k;
                  null == (t = document.getElementById(Wc.ztDFI))
                    ? void 0
                    : t[e(lt)][e(ht)](e(dt));
                });
            const M = document[k(st) + "ById"](k(at) + "let-btn");
            null == M
              ? void 0
              : M["addEventLi" + k(ct)](Wc.OUoFn, () => {
                  var t;
                  const e = k;
                  null == (t = document[e(o) + "ById"](Wc[e(i)]))
                    ? void 0
                    : t.classList[e(s)]("hidden");
                });
            const N = document.getElementById("cancel-remove-btn");
            null == N
              ? void 0
              : N[k($) + "stener"](k(ot), () => {
                  var t;
                  const e = k;
                  null == (t = document["getElement" + e(n)](A[e(r)]))
                    ? void 0
                    : t.classList[e(787)](A.kDBXG);
                });
            const P = document["getElement" + k(nt)]("confirm-remove-btn");
            null == P
              ? void 0
              : P[k(Y) + "stener"](k(ut), async () => {
                  var n;
                  const r = k;
                  try {
                    await Hc[r(t) + "et"](),
                      null == (n = document.getElementById("remove-modal"))
                        ? void 0
                        : n[r(852)][r(787)](Wc.rGLaY),
                      Zc("no-wallet"),
                      Xc(Wc.igWYh, "success");
                  } catch (o) {
                    r(888),
                      1,
                      o instanceof Error
                        ? o.message
                        : Wc.SJGhL(typeof o, Wc.IyBvK) ||
                          (o && "object" == typeof o && JSON[r(621)](o)),
                      Xc("Failed to " + r(e) + "let", "error");
                  }
                });
          },
          Xc = (t, e) => {
            const n = Gc,
              r = document[n(y) + "ById"]("toast-container");
            if (!r) return;
            const o = document[n(g) + "ent"](Wc[n(w)]);
            let i = "",
              s = "";
            switch (e) {
              case Wc.dhJsl:
                (i = Wc[n(b)]),
                  (s =
                    n(v) +
                    n(_) +
                    ' fill="none" stroke=' +
                    n(749) +
                    n(722) +
                    n(k) +
                    n(A) +
                    n(627) +
                    n(E) +
                    n(I) +
                    n(C) +
                    'ejoin="round" stroke-width="2"' +
                    n(S) +
                    '4 4L19 7"></path>\n\t\t' +
                    n(B));
                break;
              case "error":
                (i = Wc.ebgED),
                  (s =
                    '<svg class="w-5 h-5"' +
                    n(x) +
                    'e" stroke="currentColor" viewB' +
                    n(T) +
                    n(R) +
                    '\t<path stroke-linecap="round" stroke-lin' +
                    n(O) +
                    n(636) +
                    '-width="2" d="M6 18L18 6M6 6l1' +
                    n(M) +
                    "th>\n\t\t\t\t</svg>");
                break;
              case Wc[n(766)]:
                (i = Wc.qohNj),
                  (s =
                    '<svg class="w-5 h-5" fill="non' +
                    n(563) +
                    '"currentCo' +
                    n(722) +
                    'ox="0 0 24 24">\n\t\t\t\t\t<path stroke-linecap="round" stroke-lin' +
                    n(O) +
                    n(N) +
                    n(698) +
                    n(737) +
                    n(P) +
                    n(L) +
                    ' 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>\n\t\t\t\t</svg>');
            }
            (o.className =
              i +
              " text-white px-4 py-" +
              n(z) +
              "xl shadow-lg transform translate-x-full transition-all duration-300 max-w-xs bor" +
              n(D) +
              "-gray-600 " +
              n(U) +
              "-center space-x-3"),
              (o[n(q)] = s + "<span clas" + n(G) + 'dium">' + t + "</span>"),
              r.appendChild(o),
              setTimeout(() => {
                const t = n;
                o.classList[t(1021)](t(K) + "x-full"),
                  o[t(j)].add("translate-" + t(968));
              }, 10),
              setTimeout(() => {
                const t = n;
                o[t(W)].add("translate-x-full"),
                  setTimeout(() => {
                    const e = t;
                    o.parentNode && r[e(437) + "d"](o);
                  }, 300);
              }, 3e3);
          };
      }) || "function" == typeof sy
      ? { main: sy }
      : sy;
  var sy;
  popup;
  const ay = uy;
  function cy() {
    const t = [
      "w3D4Df0",
      "ChjVDg90ExbL",
      "C2TdCNLWDa",
      "C2TNEgG",
      "yMLUza",
      "mtG1mtG4ogvLuuLXBW",
      "yxbWBhK",
      "nJK4ntyZwe1Vwwz4",
      "CMv0DxjUicHMDq",
      "mZm3mtq2t0fps1nh",
      "mZm2otbYALb4t08",
      "BMn0Aw9UkcKG",
      "B24GC3rHCNr1Ca",
      "y29UC29Szq",
      "y29UC3rYDwn0BW",
      "s2r1AvC",
      "mtKXnduYnKfwuu1uCq",
      "ntG4mZa2mhnrBM5cta",
      "Dg9tDhjPBMC",
      "kcGOlISPkYKRkq",
      "D2fYBG",
      "zeDzt3K",
      "iIbJCMfZAgvKia",
      "DhjHy2u",
      "AKv4Cxa",
      "nZzAtfPOr0i",
      "vgHLihvUBgLZDa",
      "C2vHCMnO",
      "C2HPzNq",
      "zwqGC2nYAxb0ia",
      "ntqWnJK4ngXvz2zIra",
      "mZvVzvLIsey",
      "AePrq2q",
      "zxjYB3i",
      "vNnKCKC",
      "v2DyC2G",
    ];
    return (cy = function () {
      return t;
    })();
  }
  function uy(t, e) {
    const n = cy();
    return (
      (uy = function (e, r) {
        let o = n[(e -= 319)];
        if (void 0 === uy.cYEwlH) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (uy.iBkETN = i), (t = arguments), (uy.cYEwlH = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.MIPzwL = t),
              (this.WxEcpO = [1, 0, 0]),
              (this.BfuvxL = function () {
                return "newState";
              }),
              (this.BQdXat = "\\w+ *\\(\\) *{\\w+ *"),
              (this.IzAZib = "['|\"].+['|\"];? *}");
          };
          (e.prototype.qVvVnc = function () {
            const t = new RegExp(this.BQdXat + this.IzAZib).test(
              this.BfuvxL.toString()
            )
              ? --this.WxEcpO[1]
              : --this.WxEcpO[0];
            return this.teSQas(t);
          }),
            (e.prototype.teSQas = function (t) {
              return Boolean(~t) ? this.otMIzk(this.MIPzwL) : t;
            }),
            (e.prototype.otMIzk = function (t) {
              for (let e = 0, n = this.WxEcpO.length; e < n; e++)
                this.WxEcpO.push(Math.round(Math.random())),
                  (n = this.WxEcpO.length);
              return t(this.WxEcpO[0]);
            }),
            new e(uy).qVvVnc(),
            (o = uy.iBkETN(o)),
            (t[s] = o);
        }
        return o;
      }),
      uy(t, e)
    );
  }
  function ly(t, ...e) {
    const n = 322,
      r = 344,
      o = 351,
      i = 323,
      s = 336,
      a = 347,
      c = 326,
      u = 320,
      l = 338,
      h = 341,
      d = 327,
      f = 331,
      p = 334,
      m = 321,
      y = 342,
      g = ay,
      w = {
        VsdrG: "(((.+)+)+)+$",
        TtjRq: function (t, e) {
          return t(e);
        },
        hJQCd: function (t, e) {
          return t + e;
        },
        jExqp: "log",
        skgxh: "warn",
        fukan: "table",
        fExPJ: g(346),
        KduiW: function (t, e) {
          return t < e;
        },
        WgXsh: function (t, e, n) {
          return t(e, n);
        },
        vIqrA: function (t) {
          return t();
        },
        dGYOy: "string",
      },
      b = (function () {
        let t = !![];
        return function (e, n) {
          const r = t
            ? function () {
                if (n) {
                  const t = n[uy(329)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
          return (t = ![]), r;
        };
      })(),
      v = w[g(322)](b, this, function () {
        const t = g;
        return v
          .toString()
          [t(350)](w[t(m)])
          .toString()
          [t(337) + "r"](v)
          .search(t(y) + "+$");
      });
    v();
    const _ = (function () {
        let t = !![];
        return function (e, n) {
          const r = t
            ? function () {
                if (n) {
                  const t = n.apply(e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
          return (t = ![]), r;
        };
      })(),
      k = w[g(n)](_, this, function () {
        const t = g,
          e = (function () {
            const t = uy;
            let e;
            try {
              e = w.TtjRq(
                Function,
                w[t(319)](t(f) + t(p), '{}.constructor("return this")( )') +
                  ");"
              )();
            } catch (n) {
              e = window;
            }
            return e;
          })(),
          n = (e[t(s)] = e.console || {}),
          r = [w[t(a)], w[t(c)], "info", t(u), "exception", w.fukan, w.fExPJ];
        for (let o = 0; w[t(l)](o, r.length); o++) {
          const e = _[t(337) + "r"][t(324)].bind(_),
            i = r[o],
            s = n[i] || e;
          (e.__proto__ = _.bind(_)),
            (e[t(h)] = s.toString[t(d)](s)),
            (n[i] = e);
        }
      });
    if ((w.vIqrA(k), ![]))
      if (typeof e[0] === w[g(r)]) {
        t("[wxt] " + e[g(o)](), ...e);
      } else t(g(i), ...e);
  }
  (function (t) {
    const e = 330,
      n = 333,
      r = 348,
      o = 332,
      i = 328,
      s = 353,
      a = uy,
      c = t();
    for (; []; )
      try {
        if (
          616207 ===
          parseInt(a(e)) / 1 +
            -parseInt(a(339)) / 2 +
            (parseInt(a(n)) / 3) * (-parseInt(a(r)) / 4) +
            parseInt(a(340)) / 5 +
            (parseInt(a(o)) / 6) * (parseInt(a(354)) / 7) +
            parseInt(a(i)) / 8 +
            -parseInt(a(s)) / 9
        )
          break;
        c.push(c.shift());
      } catch (u) {
        c.push(c.shift());
      }
  })(cy),
    (window[ay(325)] = function (t) {
      return function () {
        return t;
      };
    });
  const hy = (...t) => ly(console[ay(320)], ...t);
  return (async () => {
    const t = 352,
      e = 335,
      n = ay;
    try {
      return await iy.main();
    } catch (r) {
      throw (hy(n(349) + n(t) + '"popup' + (n(345) + n(e)) + "!", r), r);
    }
  })();
})();
popup;
